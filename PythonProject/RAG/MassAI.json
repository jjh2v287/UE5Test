{
  "metadata": {
    "total_files": 498,
    "extensions": [
      ".h",
      ".cpp",
      ".cs"
    ],
    "root_path": "C:\\Users\\jjh\\Desktop\\tttt\\Mass",
    "total_lines": 64707,
    "created_at": "2024-11-30T14:54:29.369298"
  },
  "files": [
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\IMassAIBehaviorModule.h",
      "extension": ".h",
      "size_bytes": 1133,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n * The public interface to this module.  In most cases, this interface is only public to sibling modules \n * within this plugin.\n */\nclass IMassAIBehaviorModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t * Singleton-like access to this module's interface.  This is just for convenience!\n\t * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t *\n\t * @return Returns singleton instance, loading the module on demand if needed\n\t */\n\tstatic inline IMassAIBehaviorModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassAIBehaviorModule>( \"MassAIBehavior\" );\n\t}\n\n\t/**\n\t * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t *\n\t * @return True if the module is loaded and ready to use\n\t */\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassAIBehavior\" );\n\t}\n};\n\n",
      "lines": 40
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassAIBehaviorTypes.h",
      "extension": ".h",
      "size_bytes": 2263,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Logging/LogMacros.h\"\n#include \"MassCommonTypes.h\"\n#include \"VisualLogger/VisualLogger.h\"\n\nMASSAIBEHAVIOR_API DECLARE_LOG_CATEGORY_EXTERN(LogMassBehavior, Log, All);\n\nnamespace UE::Mass::ProcessorGroupNames\n{\n\tconst FName UpdateAnnotationTags = FName(TEXT(\"UpdateAnnotationTags\"));\n}\n\n/**\n * Helper macros that could be used inside FMassStateTreeEvaluators and FMassStateTreeTasks.\n * Requirements is a property or parameters with the following declaration: FStateTreeExecutionContext& Context\n * These macros should be used to standardize the output format and simplify code at call site.\n * They could also easily be changed from UE_(C)VLOG to UE_(C)VLOG_UELOG (or any other implementation) in one go.\n *  e.g. the following:\n *\t\t#if WITH_MASSGAMEPLAY_DEBUG\n *\t\t\tconst FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);\n *\t\t\tUE_VLOG(MassContext.GetOwner(), LogMassBehavior, Log, TEXT(\"Entity [%s]: Starting action: %s\"), *MassContext.GetEntity().DebugGetDescription(), *StaticEnum<ESomeActionEnum>()->GetValueAsString(SomeActionEnumValue));\n *\t\t#endif // WITH_MASSGAMEPLAY_DEBUG\n *\n *\tcould be replaced by:\n *\t\tMASSBEHAVIOR_CLOG(bDisplayDebug, Log, TEXT(\"Starting action: %s\"), *StaticEnum<ESomeActionEnum>()->GetValueAsString(SomeActionEnumValue));\n */\n#if WITH_MASSGAMEPLAY_DEBUG\n#define MASSBEHAVIOR_LOG(Verbosity, Format, ...) UE_VLOG(static_cast<FMassStateTreeExecutionContext&>(Context).GetOwner(), LogMassBehavior, Verbosity, \\\n\tTEXT(\"Entity [%s][%s] \") Format, *static_cast<FMassStateTreeExecutionContext&>(Context).GetEntity().DebugGetDescription(), *StaticStruct()->GetName(), ##__VA_ARGS__)\n#define MASSBEHAVIOR_CLOG(Condition, Verbosity, Format, ...) UE_CVLOG((Condition), static_cast<FMassStateTreeExecutionContext&>(Context).GetOwner(), LogMassBehavior, Verbosity, \\\n\tTEXT(\"Entity [%s][%s] \") Format, *static_cast<FMassStateTreeExecutionContext&>(Context).GetEntity().DebugGetDescription(), *StaticStruct()->GetName(), ##__VA_ARGS__)\n#else\n#define MASSBEHAVIOR_LOG(Verbosity, Format, ...)\n#define MASSBEHAVIOR_CLOG(Condition, Verbosity, Format, ...)\n#endif // WITH_MASSGAMEPLAY_DEBUG\n",
      "lines": 38
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassBehaviorSettings.h",
      "extension": ".h",
      "size_bytes": 569,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassSettings.h\"\n#include \"MassLODTypes.h\"\n#include \"MassBehaviorSettings.generated.h\"\n\nUCLASS(config = Mass, defaultconfig, meta = (DisplayName = \"Mass Behavior\"))\nclass MASSAIBEHAVIOR_API UMassBehaviorSettings : public UMassModuleSettings\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassBehaviorSettings(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());\n\t\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", config)\n\tint32 MaxActivationsPerLOD[EMassLOD::Max];\n};\n",
      "lines": 19
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassComponentHitSubsystem.h",
      "extension": ".h",
      "size_bytes": 1622,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassComponentHitTypes.h\"\n#include \"MassSubsystemBase.h\"\n\n#include \"MassComponentHitSubsystem.generated.h\"\n\nclass UMassAgentSubsystem;\nclass UMassSignalSubsystem;\nclass UCapsuleComponent;\n\n\n/**\n * Subsystem that keeps track of the latest component hits and allow mass entities to retrieve and handle them\n */\nUCLASS()\nclass MASSAIBEHAVIOR_API UMassComponentHitSubsystem : public UMassTickableSubsystemBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tconst FMassHitResult* GetLastHit(const FMassEntityHandle Entity) const;\n\nprotected:\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\tvirtual void Deinitialize() override;\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual TStatId GetStatId() const override;\n\t\n\tvoid RegisterForComponentHit(const FMassEntityHandle Entity, UCapsuleComponent& CapsuleComponent);\n\tvoid UnregisterForComponentHit(FMassEntityHandle Entity, UCapsuleComponent& CapsuleComponent);\n\n\tUFUNCTION()\n\tvoid OnHitCallback(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\n\tUPROPERTY()\n\tTObjectPtr<UMassSignalSubsystem> SignalSubsystem;\n\n\tUPROPERTY()\n    TObjectPtr<UMassAgentSubsystem> AgentSubsystem;\n\n\tUPROPERTY()\n\tTMap<FMassEntityHandle, FMassHitResult> HitResults;\n\n\tUPROPERTY()\n\tTMap<TObjectPtr<UActorComponent>, FMassEntityHandle> ComponentToEntityMap;\n\n\tUPROPERTY()\n\tTMap<FMassEntityHandle, TObjectPtr<UActorComponent>> EntityToComponentMap;\n};\n",
      "lines": 53
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassComponentHitTypes.h",
      "extension": ".h",
      "size_bytes": 807,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Engine/EngineTypes.h\"\n#include \"MassEntityTypes.h\"\n#include \"StateTreeTypes.h\"\n\n#include \"MassComponentHitTypes.generated.h\"\n\nnamespace UE::Mass::Signals\n{\nconst FName HitReceived = FName(TEXT(\"HitReceived\"));\n}\n\nUSTRUCT()\nstruct FMassHitResult\n{\n\tGENERATED_BODY()\n\n\tFMassHitResult() = default;\n\n\tFMassHitResult(const FMassEntityHandle OtherEntity, const double Time)\n\t\t: OtherEntity(OtherEntity)\n\t\t, HitTime(Time)\n\t\t, LastFilteredHitTime(Time)\n\t{\n\t}\n\n\tbool IsValid() const { return OtherEntity.IsValid(); }\n\t\n\tFMassEntityHandle OtherEntity;\n\n\t/** Time when first hit was received. */\n\tdouble HitTime = 0.;\n\n\t/** Time used for filtering frequent hits. */\n\tdouble LastFilteredHitTime = 0.;\n};\n",
      "lines": 39
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassLookAtFragments.h",
      "extension": ".h",
      "size_bytes": 4664,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassCommonTypes.h\"\n#include \"ZoneGraphTypes.h\"\n#include \"Containers/StaticArray.h\"\n#include \"MassLookAtFragments.generated.h\"\n\n/** Primary look at mode, gazing can be applied on top. */\nUENUM()\nenum class EMassLookAtMode : uint8\n{\n\t/** Look forward */\n\tLookForward,\n\t/** Look along the current path */\n\tLookAlongPath,\n\t/** Track specified entity */\n\tLookAtEntity,\n};\n\n/** Gifferent gaze modes applied on top of the look at mode. */\nUENUM()\nenum class EMassLookAtGazeMode : uint8\n{\n\t/** No gazing */\n\tNone,\n\t/** Look constantly in gaze direction until next gaze target is picked. */\n\tConstant,\n\t/** Quick look at gaze target, ease in back to main look direction. */\n\tGlance,\n};\n\n/**\n * Struct that holds all parameters of the current entity look at \n */\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassLookAtFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tFMassLookAtFragment()\n\t\t: bRandomGazeEntities(false)\n\t{\n\t}\n\t\n\tvoid Reset()\n\t{\n\t\tDirection = FVector::ForwardVector;\n\t\tGazeDirection = FVector::ForwardVector;\n\t\tTrackedEntity.Reset();\n\t\tGazeTrackedEntity.Reset();\n\t\tGazeStartTime = 0.0f;\n\t\tGazeDuration = 0.0f;\n\t\tLastSeenActionID = 0;\n\t\tLookAtMode = EMassLookAtMode::LookForward;\n\t\tRandomGazeMode = EMassLookAtGazeMode::None;\n\t\tRandomGazeYawVariation = 0;\n\t\tRandomGazePitchVariation = 0;\n\t\tbRandomGazeEntities = false;\n\t}\n\n\t/** Current look at direction (with gaze applied). */\n\tUPROPERTY(Transient)\n\tFVector Direction = FVector::ForwardVector;\n\n\t/** Current gaze direction, applied on top of look at direction based on gaze mode. */\n\tUPROPERTY(Transient)\n\tFVector GazeDirection = FVector::ForwardVector;\n\n\t/** Specific entity that is being tracked as primary look at. */\n\tUPROPERTY(Transient)\n\tFMassEntityHandle TrackedEntity;\n\n\t/** Entity that is tracked as part of gazing. */\n\tUPROPERTY(Transient)\n\tFMassEntityHandle GazeTrackedEntity;\n\n\t/** Start time of the current gaze. */\n\tUPROPERTY(Transient)\n\tdouble GazeStartTime = 0.;\n\n\t/** Duration of the current gaze. */\n\tUPROPERTY(Transient)\n\tfloat GazeDuration = 0.0f;\n\n\t/** Last seen action ID, used to check when look at trajectory needs to be updated. */\n\tUPROPERTY(Transient)\n\tuint16 LastSeenActionID = 0;\n\n\t/** Primary look at mode. */\n\tUPROPERTY(Transient)\n\tEMassLookAtMode LookAtMode = EMassLookAtMode::LookForward;\n\n\t/** Gaze look at mode. */\n\tUPROPERTY(Transient)\n\tEMassLookAtGazeMode RandomGazeMode = EMassLookAtGazeMode::None;\n\n\t/** Random gaze angle yaw variation (in degrees). */\n\tUPROPERTY(Transient)\n\tuint8 RandomGazeYawVariation = 0;\n\n\t/** Random gaze angle pitch variation (in degrees). */\n\tUPROPERTY(Transient)\n\tuint8 RandomGazePitchVariation = 0;\n\n\t/** Tru if random gaze can also pick interesting entities to look at. */\n\tUPROPERTY(Transient)\n\tuint8 bRandomGazeEntities : 1;\n};\n\n/**\n * Special tag to mark an entity that could be tracked by the LookAt\n */\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassLookAtTargetTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\n\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassLookAtTrajectoryPoint\n{\n\tGENERATED_BODY()\n\n\tvoid Set(const FVector InPosition, const FVector2D InTangent, const float InDistanceAlongLane)\n\t{\n\t\tPosition = InPosition;\n\t\tTangent.Set(InTangent);\n\t\tDistanceAlongLane.Set(InDistanceAlongLane);\n\t}\n\t\n\t/** Position of the path. */\n\tFVector Position = FVector::ZeroVector;\n\t\n\t/** Tangent direction of the path. */\n\tFMassSnorm8Vector2D Tangent;\n\t\n\t/** Position of the point along the original path. (Could potentially be uint16 at 10cm accuracy) */\n\tFMassInt16Real10 DistanceAlongLane = FMassInt16Real10(0.0f);\n};\n\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassLookAtTrajectoryFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tFMassLookAtTrajectoryFragment() = default;\n\t\n\tstatic constexpr uint8 MaxPoints = 3;\n\n\tvoid Reset()\n\t{\n\t\tNumPoints = 0;\n\t}\n\n\tbool AddPoint(const FVector Position, const FVector2D Tangent, const float DistanceAlongLane)\n\t{\n\t\tif (NumPoints < MaxPoints)\n\t\t{\n\t\t\tFMassLookAtTrajectoryPoint& Point = Points[NumPoints++];\n\t\t\tPoint.Set(Position, Tangent, DistanceAlongLane);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tFVector GetPointAtDistanceExtrapolated(const float DistanceAlongPath) const;\n\t\n\t/** Path points */\n\tTStaticArray<FMassLookAtTrajectoryPoint, MaxPoints> Points;\n\n\t/** Lane handle the trajectory was build for. */\n\tFZoneGraphLaneHandle LaneHandle;\n\n\t/** Number of points on path. */\n\tuint8 NumPoints = 0;\n\n\tbool bMoveReverse = false;\n};\n",
      "lines": 182
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassLookAtProcessors.h",
      "extension": ".h",
      "size_bytes": 3427,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessor.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassSignalProcessorBase.h\"\n#include \"MassLookAtProcessors.generated.h\"\n\nclass UMassNavigationSubsystem;\nclass UZoneGraphSubsystem;\nstruct FMassLookAtFragment;\nstruct FMassZoneGraphLaneLocationFragment;\nstruct FMassLookAtTrajectoryFragment;\nstruct FMassZoneGraphShortPathFragment;\nstruct FMassMoveTargetFragment;\n\n/**\n * Processor to choose and assign LookAt configurations  \n */\nUCLASS()\nclass MASSAIBEHAVIOR_API UMassLookAtProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\n\tUMassLookAtProcessor();\n\nprotected:\n\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\t/** Selects a nearby target if possible or use a random fixed direction */\n\tvoid FindNewGazeTarget(const UMassNavigationSubsystem& MassNavSystem, const FMassEntityManager& EntityManager, const double CurrentTime, const FTransform& Transform, FMassLookAtFragment& LookAt) const;\n\n\t/** Updates look direction based on look at trajectory. */\n\tvoid UpdateLookAtTrajectory(const FTransform& Transform, const FMassZoneGraphLaneLocationFragment& ZoneGraphLocation,\n\t\t\t\t\t\t\t\tconst FMassLookAtTrajectoryFragment& LookAtTrajectory, const bool bDisplayDebug, FMassLookAtFragment& LookAt) const;\n\n\t/** Updates look at based on tracked entity. */\n\tvoid UpdateLookAtTrackedEntity(const FMassEntityManager& EntityManager, const FTransform& Transform, const bool bDisplayDebug, FMassLookAtFragment& LookAt) const;\n\n\t/** Updates gaze based on tracked entity. */\n\tbool UpdateGazeTrackedEntity(const FMassEntityManager& EntityManager, const FTransform& Transform, const bool bDisplayDebug, FMassLookAtFragment& LookAt) const;\n\n\t/** Builds look at trajectory along the current path. */\n\tvoid BuildTrajectory(const UZoneGraphSubsystem& ZoneGraphSubsystem, const FMassZoneGraphLaneLocationFragment& LaneLocation, const FMassZoneGraphShortPathFragment& ShortPath,\n\t\t\t\t\t\t\tconst FMassEntityHandle Entity, const bool bDisplayDebug, FMassLookAtTrajectoryFragment& LookAtTrajectory);\n\n\t/** Size of the query to find potential targets */\n\tUPROPERTY(EditDefaultsOnly, Category = LookAt, config, meta = (UIMin = 0.0, ClampMin = 0.0))\n\tfloat QueryExtent = 0.f;\n\n\t/** Time an entity must use a random look at. */\n\tUPROPERTY(EditDefaultsOnly, Category = LookAt, config, meta = (UIMin = 0.0, ClampMin = 0.0))\n\tfloat Duration = 0.f;\n\t\n\t/** Variation applied to a random look at duration [Duration-Variation : Duration+Variation] */\n\tUPROPERTY(EditDefaultsOnly, Category = LookAt, config, meta = (UIMin = 0.0, ClampMin = 0.0))\n\tfloat DurationVariation = 0.f;\n\n\t/** Height offset that will be added for debug draw of the look at vector. Useful to bring arrow near character's eyes */\n\tUPROPERTY(EditDefaultsOnly, Category = LookAt, config, meta = (UIMin = 0.0, ClampMin = 0.0, DisplayName=\"Debug draw Z offset (cm)\"))\n\tfloat DebugZOffset = 0.f;\n\n\t/** Tolerance in degrees between the forward direction and the look at duration to track an entity */\n\tUPROPERTY(EditDefaultsOnly, Category = LookAt, config, meta = (UIMin = 0.0, ClampMin = 0.0, UIMax = 180.0, ClampMax = 180.0, DisplayName=\"Angle Threshold (degrees)\"))\n\tfloat AngleThresholdInDegrees = 0.f;\n\n\tFMassEntityQuery EntityQuery_Conditional;\n};\n",
      "lines": 71
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassLookAtTargetTrait.h",
      "extension": ".h",
      "size_bytes": 438,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"MassEntityTraitBase.h\"\n#include \"MassLookAtTargetTrait.generated.h\"\n\nUCLASS(meta=(DisplayName=\"Look At Target\"))\nclass UMassLookAtTargetTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n};\n",
      "lines": 17
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassLookAtTrait.h",
      "extension": ".h",
      "size_bytes": 422,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"MassEntityTraitBase.h\"\n#include \"MassLookAtTrait.generated.h\"\n\nUCLASS(meta=(DisplayName=\"Look At\"))\nclass UMassLookAtTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n};\n",
      "lines": 17
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassStateTreeExecutionContext.h",
      "extension": ".h",
      "size_bytes": 1702,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"StateTreeExecutionContext.h\"\n//#include \"MassStateTreeExecutionContext.generated.h\"\n\nstruct FMassExecutionContext;\nstruct FMassEntityManager;\nclass UMassSignalSubsystem;\n\n/**\n * Extends FStateTreeExecutionContext to provide additional data to Evaluators and Tasks related to MassSimulation\n */\nstruct MASSAIBEHAVIOR_API FMassStateTreeExecutionContext : public FStateTreeExecutionContext \n{\npublic:\n\t// @todo: refactor subsystems out of the exec context.\n\tFMassStateTreeExecutionContext(UObject& InOwner, const UStateTree& InStateTree, FStateTreeInstanceData& InInstanceData, FMassEntityManager& InEntityManager, UMassSignalSubsystem& InSignalSubsystem, FMassExecutionContext& InContext);\n\n\tFMassEntityManager& GetEntityManager() const { check(EntityManager); return *EntityManager; }\n\tFMassExecutionContext& GetEntitySubsystemExecutionContext() const { return *EntitySubsystemExecutionContext; }\n\n\tFMassEntityHandle GetEntity() const { return Entity; }\n\tvoid SetEntity(const FMassEntityHandle InEntity) { Entity = InEntity; }\n\nprotected:\n\n\t/** Prefix that will be used by STATETREE_LOG and STATETREE_CLOG, using Entity description. */\n\tvirtual FString GetInstanceDescription() const override { return FString::Printf(TEXT(\"Entity [%s]\"), *Entity.DebugGetDescription()); }\n\n\tvirtual void BeginDelayedTransition(const FStateTreeTransitionDelayedState& DelayedState) override;\n\n\tFMassEntityManager* EntityManager;\n\tUMassSignalSubsystem* SignalSubsystem = nullptr;\n\tFMassExecutionContext* EntitySubsystemExecutionContext = nullptr;\n\tFMassEntityHandle Entity;\n};\n",
      "lines": 39
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassStateTreeFragments.h",
      "extension": ".h",
      "size_bytes": 822,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassStateTreeSubsystem.h\"\n#include \"MassStateTreeFragments.generated.h\"\n\n\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassStateTreeInstanceFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tFMassStateTreeInstanceFragment() = default;\n\n\t/** Handle to a StateTree instance data in MassStateTreeSubsystem. */\n\tFMassStateTreeInstanceHandle InstanceHandle;\n\n\t/** The last update time use to calculate ticking delta time. */\n\tdouble LastUpdateTimeInSeconds = 0.;\n};\n\n\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassStateTreeSharedFragment : public FMassConstSharedFragment\n{\n\tGENERATED_BODY()\n\n\tFMassStateTreeSharedFragment() = default;\n\n\tUPROPERTY()\n\tTObjectPtr<UStateTree> StateTree = nullptr;\n};\n",
      "lines": 34
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassStateTreeProcessors.h",
      "extension": ".h",
      "size_bytes": 2065,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassSignalProcessorBase.h\"\n#include \"MassStateTreeFragments.h\"\n#include \"MassObserverProcessor.h\"\n#include \"MassLODTypes.h\"\n#include \"MassStateTreeProcessors.generated.h\"\n\nstruct FMassStateTreeExecutionContext;\n\n/** \n * Processor to stop and uninitialize StateTrees on entities.\n */\nUCLASS()\nclass MASSAIBEHAVIOR_API UMassStateTreeFragmentDestructor : public UMassObserverProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassStateTreeFragmentDestructor();\n\nprotected:\n\tvirtual void Initialize(UObject& Owner) override;\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<UMassSignalSubsystem> SignalSubsystem = nullptr;\n};\n\n/**\n * Special tag to know if the state tree has been activated\n */\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassStateTreeActivatedTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n/**\n * Processor to send the activation signal to the state tree which will execute the first tick */\nUCLASS()\nclass MASSAIBEHAVIOR_API UMassStateTreeActivationProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\npublic:\n\tUMassStateTreeActivationProcessor();\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\t\n\tFMassEntityQuery EntityQuery;\n};\n\n/** \n * Processor for executing a StateTree\n */\nUCLASS()\nclass MASSAIBEHAVIOR_API UMassStateTreeProcessor : public UMassSignalProcessorBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassStateTreeProcessor(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());\n\nprotected:\n\tvirtual void Initialize(UObject& Owner) override;\n\tvirtual void ConfigureQueries() override;\n\tvirtual void SignalEntities(FMassEntityManager& EntityManager, FMassExecutionContext& Context, FMassSignalNameLookup& EntitySignals) override;\n};\n",
      "lines": 73
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassStateTreeSchema.h",
      "extension": ".h",
      "size_bytes": 581,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"StateTreeSchema.h\"\n#include \"MassStateTreeSchema.generated.h\"\n\n/**\n * StateTree for Mass behaviors.\n */\nUCLASS(BlueprintType, EditInlineNew, CollapseCategories, meta = (DisplayName = \"Mass Behavior\", CommonSchema))\nclass MASSAIBEHAVIOR_API UMassStateTreeSchema : public UStateTreeSchema\n{\n\tGENERATED_BODY()\n\nprotected:\n\n\tvirtual bool IsStructAllowed(const UScriptStruct* InScriptStruct) const override;\n\tvirtual bool IsExternalItemAllowed(const UStruct& InStruct) const override;\n};\n\n",
      "lines": 21
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassStateTreeSubsystem.h",
      "extension": ".h",
      "size_bytes": 2038,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassStateTreeTypes.h\"\n#include \"MassSubsystemBase.h\"\n#include \"StateTreeExecutionContext.h\"\n#include \"MassExternalSubsystemTraits.h\"\n#include \"MassStateTreeSubsystem.generated.h\"\n\nclass UStateTree;\n\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassStateTreeInstanceDataItem\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY()\n\tFStateTreeInstanceData InstanceData;\n\n\tUPROPERTY()\n\tint32 Generation = 0;\n};\n\n/**\n* A subsystem managing StateTree assets in Mass\n*/\nUCLASS()\nclass MASSAIBEHAVIOR_API UMassStateTreeSubsystem : public UMassSubsystemBase\n{\n\tGENERATED_BODY()\n\t\nprotected:\n\t// USubsystem BEGIN\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\t// USubsystem END\n\npublic:\n\t/**\n\t * Allocates new instance data for specified StateTree.\n\t * @param StateTree StateTree to allocated the data for.\n\t * @return Handle to the data.\n\t */\n\tFMassStateTreeInstanceHandle AllocateInstanceData(const UStateTree* StateTree);\n\n\t/**\n\t * Frees instance data.\n\t * @param Handle Instance data handle to free.\n\t */\n\tvoid FreeInstanceData(const FMassStateTreeInstanceHandle Handle);\n\n\t/** @return Pointer to instance data held by the handle, or nullptr if handle is not valid. */\n\tFStateTreeInstanceData* GetInstanceData(const FMassStateTreeInstanceHandle Handle)\n\t{\n\t\treturn IsValidHandle(Handle) ? &InstanceDataArray[Handle.GetIndex()].InstanceData : nullptr;\n\t}\n\n\t/** @return True if the handle points to active instance data. */\n\tbool IsValidHandle(const FMassStateTreeInstanceHandle Handle) const\n\t{\n\t\treturn InstanceDataArray.IsValidIndex(Handle.GetIndex()) && InstanceDataArray[Handle.GetIndex()].Generation == Handle.GetGeneration();\n\t}\n\t\nprotected:\n\n\tTArray<int32> InstanceDataFreelist;\n\n\tUPROPERTY(Transient)\n\tTArray<FMassStateTreeInstanceDataItem> InstanceDataArray;\n};\n\ntemplate<>\nstruct TMassExternalSubsystemTraits<UMassStateTreeSubsystem> final\n{\n\tenum\n\t{\n\t\tGameThreadOnly = true\n\t};\n};\n",
      "lines": 79
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassStateTreeTrait.h",
      "extension": ".h",
      "size_bytes": 866,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTraitBase.h\"\n#include \"MassStateTreeTrait.generated.h\"\n\nclass UStateTree;\n\n/**\n * Feature that adds StateTree execution functionality to a mass agent.\n */\nUCLASS(meta=(DisplayName=\"StateTree\"))\nclass MASSAIBEHAVIOR_API UMassStateTreeTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\tvirtual bool ValidateTemplate(const FMassEntityTemplateBuildContext& BuildContext, const UWorld& World, FAdditionalTraitRequirements& OutTraitRequirements) const override;\n\n\tUPROPERTY(Category=\"StateTree\", EditAnywhere, meta=(RequiredAssetDataTags=\"Schema=/Script/MassAIBehavior.MassStateTreeSchema\"))\n\tTObjectPtr<UStateTree> StateTree;\n};\n",
      "lines": 25
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassStateTreeTypes.h",
      "extension": ".h",
      "size_bytes": 2176,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"StateTreeEvaluatorBase.h\" \n#include \"StateTreeTaskBase.h\"\n#include \"MassStateTreeTypes.generated.h\"\n\n/**\n * Signals used by the StateTree framework in Mass\n */\nnamespace UE::Mass::Signals\n{\n\tconst FName StateTreeActivate = FName(TEXT(\"StateTreeActivate\"));\n\tconst FName LookAtFinished = FName(TEXT(\"LookAtFinished\"));\n\tconst FName NewStateTreeTaskRequired = FName(TEXT(\"NewStateTreeTaskRequired\"));\n\tconst FName StandTaskFinished = FName(TEXT(\"StandTaskFinished\"));\n\tconst FName DelayedTransitionWakeup = FName(TEXT(\"DelayedTransitionWakeup\"));\n\t// @todo MassStateTree: move this to its game plugin when possible\n\tconst FName ContextualAnimTaskFinished = FName(TEXT(\"ContextualAnimTaskFinished\"));\n}\n\n/**\n * Base struct for all Mass StateTree Evaluators.\n */\nUSTRUCT(meta = (DisplayName = \"Mass Evaluator Base\"))\nstruct MASSAIBEHAVIOR_API FMassStateTreeEvaluatorBase : public FStateTreeEvaluatorBase\n{\n\tGENERATED_BODY()\n};\n\n/**\n * Base struct for all Mass StateTree Tasks.\n */\nUSTRUCT(meta = (DisplayName = \"Mass Task Base\"))\nstruct MASSAIBEHAVIOR_API FMassStateTreeTaskBase : public FStateTreeTaskBase\n{\n\tGENERATED_BODY()\n};\n\n/**\n * A handle pointing to a StateTree instance data in UMassStateTreeSubsystem.\n */\nstruct FMassStateTreeInstanceHandle\n{\n\tFMassStateTreeInstanceHandle() = default;\n\n\t/** Initializes new handle based on an index */\n\tstatic FMassStateTreeInstanceHandle Make(const int32 InIndex, const int32 InGeneration) { return FMassStateTreeInstanceHandle(InIndex, InGeneration); }\n\t\n\t/** @returns index the handle points to */\n\tint32 GetIndex() const { return Index; }\n\n\t/** @returns generation of the handle, used to identify recycled indices. */ \n\tint32 GetGeneration() const { return Generation; }\n\n\t/** @returns true if the handle is valid. */\n\tbool IsValid() const { return Index != INDEX_NONE; }\n\nprotected:\n\tFMassStateTreeInstanceHandle(const int32 InIndex, const int32 InGeneration) : Index(InIndex), Generation(InGeneration) {}\n\n\tint32 Index = INDEX_NONE;\n\tint32 Generation = 0;\n};\n\n",
      "lines": 67
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassZoneGraphAnnotationFragments.h",
      "extension": ".h",
      "size_bytes": 778,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"ZoneGraphTypes.h\"\n#include \"MassZoneGraphAnnotationFragments.generated.h\"\n\nstruct FMassExecutionContext;\n\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassZoneGraphAnnotationFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\t/** Behavior tags for current lane */\n\tUPROPERTY()\n\tFZoneGraphTagMask Tags;\n};\n\nUSTRUCT()\nstruct FMassZoneGraphAnnotationVariableTickChunkFragment : public FMassChunkFragment\n{\n\tGENERATED_BODY();\n\n\t/** Update the ticking frequency of the chunk and return if this chunk should be process this frame */\n\tstatic bool UpdateChunk(FMassExecutionContext& Context);\n\n\tfloat TimeUntilNextTick = 0.0f;\n\tbool bInitialized = false;\n};",
      "lines": 31
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassZoneGraphAnnotationProcessors.h",
      "extension": ".h",
      "size_bytes": 1822,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassSignalProcessorBase.h\"\n#include \"MassObserverProcessor.h\"\n#include \"MassZoneGraphAnnotationProcessors.generated.h\"\n\nclass UMassSignalSubsystem;\nclass UZoneGraphAnnotationSubsystem;\nstruct FMassZoneGraphAnnotationFragment;\nstruct FMassZoneGraphLaneLocationFragment;\nstruct FMassEntityHandle;\n\n/** \n * Processor for initializing ZoneGraph annotation tags.\n */\nUCLASS()\nclass MASSAIBEHAVIOR_API UMassZoneGraphAnnotationTagsInitializer : public UMassObserverProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassZoneGraphAnnotationTagsInitializer();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};\n\n/** \n * Processor for update ZoneGraph annotation tags periodically and on lane changed signal.\n */\nUCLASS()\nclass MASSAIBEHAVIOR_API UMassZoneGraphAnnotationTagUpdateProcessor : public UMassSignalProcessorBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassZoneGraphAnnotationTagUpdateProcessor();\n\t\nprotected:\n\tvirtual void Initialize(UObject& Owner) override;\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tvoid UpdateAnnotationTags(UZoneGraphAnnotationSubsystem& ZoneGraphAnnotationSubsystem, FMassZoneGraphAnnotationFragment& AnnotationTags, const FMassZoneGraphLaneLocationFragment& LaneLocation, FMassEntityHandle Entity);\n\n\tvirtual void SignalEntities(FMassEntityManager& EntityManager, FMassExecutionContext& Context, FMassSignalNameLookup& /*Unused*/) override;\n\n\t// Frame buffer, it gets reset every frame.\n\tTArray<FMassEntityHandle> TransientEntitiesToSignal;\n};\n",
      "lines": 55
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassZoneGraphAnnotationTrait.h",
      "extension": ".h",
      "size_bytes": 457,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassEntityTraitBase.h\"\n#include \"MassZoneGraphAnnotationTrait.generated.h\"\n\nUCLASS(meta = (DisplayName = \"ZoneGraph Annotation\"))\nclass MASSAIBEHAVIOR_API UMassZoneGraphAnnotationTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n};\n",
      "lines": 15
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\MassZoneGraphAnnotationTypes.h",
      "extension": ".h",
      "size_bytes": 239,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"UObject/NameTypes.h\"\n\nnamespace UE::Mass::Signals\n{\n\tconst FName AnnotationTagsChanged = FName(TEXT(\"AnnotationTagsChanged\"));\n} // UE::Mass::Signals\n",
      "lines": 10
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\Conditions\\ZoneGraphTagConditions.h",
      "extension": ".h",
      "size_bytes": 2955,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"StateTreeConditionBase.h\"\n#include \"ZoneGraphTypes.h\"\n#include \"ZoneGraphTagConditions.generated.h\"\n\n/**\n* ZoneGraph Tag condition.\n*/\n\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FZoneGraphTagFilterConditionInstanceData\n{\n\tGENERATED_BODY()\n\t\n\tUPROPERTY(EditAnywhere, Category = Input)\n\tFZoneGraphTagMask Tags = FZoneGraphTagMask::None;\n};\n\nUSTRUCT(DisplayName=\"ZoneGraphTagFilter Compare\")\nstruct MASSAIBEHAVIOR_API FZoneGraphTagFilterCondition : public FStateTreeConditionBase\n{\n\tGENERATED_BODY()\n\n\tusing FInstanceDataType = FZoneGraphTagFilterConditionInstanceData;\n\n\tFZoneGraphTagFilterCondition() = default;\n\t\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\tvirtual bool TestCondition(FStateTreeExecutionContext& Context) const override;\n\n\tUPROPERTY(EditAnywhere, Category = Condition)\n\tFZoneGraphTagFilter Filter;\n\n\tUPROPERTY(EditAnywhere, Category = Condition)\n\tbool bInvert = false;\n};\n\n/**\n* ZoneGraph Tag condition.\n*/\n\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FZoneGraphTagMaskConditionInstanceData\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, Category = Input)\n\tFZoneGraphTagMask Left = FZoneGraphTagMask::None;\n\n\tUPROPERTY(EditAnywhere, Category = Parameter)\n\tFZoneGraphTagMask Right = FZoneGraphTagMask::None;\n};\n\nUSTRUCT(DisplayName=\"ZoneGraphTagMask Compare\")\nstruct MASSAIBEHAVIOR_API FZoneGraphTagMaskCondition : public FStateTreeConditionBase\n{\n\tGENERATED_BODY()\n\n\tusing FInstanceDataType = FZoneGraphTagMaskConditionInstanceData;\n\n\tFZoneGraphTagMaskCondition() = default;\n\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\tvirtual bool TestCondition(FStateTreeExecutionContext& Context) const override;\n\n\tUPROPERTY(EditAnywhere, Category = Condition)\n\tEZoneLaneTagMaskComparison Operator = EZoneLaneTagMaskComparison::Any;\n\n\tUPROPERTY(EditAnywhere, Category = Condition)\n\tbool bInvert = false;\n};\n\n/**\n* ZoneGraph Tag condition.\n*/\n\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FZoneGraphTagConditionInstanceData\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, Category = Input)\n\tFZoneGraphTag Left = FZoneGraphTag::None;\n\n\tUPROPERTY(EditAnywhere, Category = Parameter)\n\tFZoneGraphTag Right = FZoneGraphTag::None;\n};\n\nUSTRUCT(DisplayName=\"ZoneGraphTag Compare\")\nstruct MASSAIBEHAVIOR_API FZoneGraphTagCondition : public FStateTreeConditionBase\n{\n\tGENERATED_BODY()\n\n\tusing FInstanceDataType = FZoneGraphTagConditionInstanceData;\n\n\tFZoneGraphTagCondition() = default;\n\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\tvirtual bool TestCondition(FStateTreeExecutionContext& Context) const override;\n\n\tUPROPERTY(EditAnywhere, Category = Condition)\n\tbool bInvert = false;\n};\n",
      "lines": 107
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\Evaluators\\MassComponentHitEvaluator.h",
      "extension": ".h",
      "size_bytes": 1227,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassComponentHitSubsystem.h\"\n#include \"MassStateTreeTypes.h\"\n#include \"MassComponentHitEvaluator.generated.h\"\n\nclass UMassComponentHitSubsystem;\n\n/**\n * Evaluator to extract last hit from the MassComponentHitSubsystem and expose it for tasks and transitions\n */\n\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassComponentHitEvaluatorInstanceData\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(VisibleAnywhere, Category = Output)\n\tbool bGotHit = false;\n\n\tUPROPERTY(VisibleAnywhere, Category = Output)\n\tFMassEntityHandle LastHitEntity;\n};\n\nUSTRUCT(meta = (DisplayName = \"Mass ComponentHit Eval\"))\nstruct MASSAIBEHAVIOR_API FMassComponentHitEvaluator : public FMassStateTreeEvaluatorBase\n{\n\tGENERATED_BODY()\n\n\tusing FInstanceDataType = FMassComponentHitEvaluatorInstanceData;\n\t\nprotected:\n\tvirtual bool Link(FStateTreeLinker& Linker) override;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\tvirtual void Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const override;\n\n\tTStateTreeExternalDataHandle<UMassComponentHitSubsystem> ComponentHitSubsystemHandle;\n};\n",
      "lines": 40
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\Evaluators\\MassZoneGraphAnnotationEvaluator.h",
      "extension": ".h",
      "size_bytes": 1241,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassStateTreeTypes.h\"\n#include \"ZoneGraphTypes.h\"\n#include \"MassZoneGraphAnnotationEvaluator.generated.h\"\n\nstruct FStateTreeExecutionContext;\nstruct FMassZoneGraphAnnotationFragment;\n/**\n * Evaluator to expose ZoneGraph Annotation Tags for decision making.\n */\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassZoneGraphAnnotationEvaluatorInstanceData\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, Category = Output)\n\tFZoneGraphTagMask AnnotationTags = FZoneGraphTagMask::None;\n};\n\nUSTRUCT(meta = (DisplayName = \"ZG Annotation Tags\"))\nstruct MASSAIBEHAVIOR_API FMassZoneGraphAnnotationEvaluator : public FMassStateTreeEvaluatorBase\n{\n\tGENERATED_BODY()\n\n\tusing FInstanceDataType = FMassZoneGraphAnnotationEvaluatorInstanceData;\n\n\tFMassZoneGraphAnnotationEvaluator();\n\nprotected:\n\tvirtual bool Link(FStateTreeLinker& Linker) override;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\tvirtual void Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const override;\n\n\tTStateTreeExternalDataHandle<FMassZoneGraphAnnotationFragment> AnnotationTagsFragmentHandle;\n};\n",
      "lines": 38
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\Tasks\\MassClaimSmartObjectTask.h",
      "extension": ".h",
      "size_bytes": 2117,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassSmartObjectRequest.h\"\n#include \"MassStateTreeTypes.h\"\n#include \"MassClaimSmartObjectTask.generated.h\"\n\nstruct FStateTreeExecutionContext;\nstruct FMassSmartObjectUserFragment;\nclass USmartObjectSubsystem;\nclass UMassSignalSubsystem;\nstruct FTransformFragment;\nstruct FMassMoveTargetFragment;\n\n/**\n * Tasks to claim a smart object from search results and release it when done.\n */\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassClaimSmartObjectTaskInstanceData\n{\n\tGENERATED_BODY()\n\n\t/** Result of the candidates search request (Input) */\n\tUPROPERTY(VisibleAnywhere, Category = Input, meta = (BaseStruct = \"/Script/MassSmartObjects.MassSmartObjectCandidateSlots\"))\n\tFStateTreeStructRef CandidateSlots;\n\n\tUPROPERTY(VisibleAnywhere, Category = Output)\n\tFSmartObjectClaimHandle ClaimedSlot;\n};\n\nUSTRUCT(meta = (DisplayName = \"Claim SmartObject\"))\nstruct MASSAIBEHAVIOR_API FMassClaimSmartObjectTask : public FMassStateTreeTaskBase\n{\n\tGENERATED_BODY()\n\n\tusing FInstanceDataType = FMassClaimSmartObjectTaskInstanceData;\n\n\tFMassClaimSmartObjectTask();\n\nprotected:\n\tvirtual bool Link(FStateTreeLinker& Linker) override;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\tvirtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\tvirtual void ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\tvirtual EStateTreeRunStatus Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const override;\n\n\tTStateTreeExternalDataHandle<FMassSmartObjectUserFragment> SmartObjectUserHandle;\n\tTStateTreeExternalDataHandle<USmartObjectSubsystem> SmartObjectSubsystemHandle;\n\tTStateTreeExternalDataHandle<UMassSignalSubsystem> MassSignalSubsystemHandle;\n\n\t/** Delay in seconds before trying to use another smart object */\n\tUPROPERTY(EditAnywhere, Category = Parameter)\n\tfloat InteractionCooldown = 0.f;\n};\n",
      "lines": 55
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\Tasks\\MassFindSmartObjectTask.h",
      "extension": ".h",
      "size_bytes": 2747,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n#include \"MassStateTreeTypes.h\"\n#include \"SmartObjectSubsystem.h\"\n#include \"MassSignalSubsystem.h\"\n#include \"MassSmartObjectRequest.h\"\n#include \"MassFindSmartObjectTask.generated.h\"\n\nstruct FMassSmartObjectUserFragment;\nstruct FMassZoneGraphLaneLocationFragment;\nstruct FTransformFragment;\n\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassFindSmartObjectTaskInstanceData\n{\n\tGENERATED_BODY()\n\n\t/** Result of the candidates search request */\n\tUPROPERTY(VisibleAnywhere, Category = Output)\n\tFMassSmartObjectCandidateSlots FoundCandidateSlots;\t\t// @todo: Should turn this in a StateTree result/value.\n\n\tUPROPERTY(VisibleAnywhere, Category = Output)\n\tbool bHasCandidateSlots = false;\n\n\t/** The identifier of the search request send by the task to find candidates */\n\tUPROPERTY()\n\tFMassSmartObjectRequestID SearchRequestID;\n\n\t/** Next update time; task will not do anything when Tick gets called before that time */\n\tUPROPERTY()\n\tdouble NextUpdate = 0.;\n\n\t/** Last lane where the smart objects were searched. */\n\tUPROPERTY()\n\tFZoneGraphLaneHandle LastLane;\n};\n\nUSTRUCT(meta = (DisplayName = \"Find Smart Object\"))\nstruct MASSAIBEHAVIOR_API FMassFindSmartObjectTask : public FMassStateTreeTaskBase\n{\n\tGENERATED_BODY()\n\n\tusing FInstanceDataType = FMassFindSmartObjectTaskInstanceData;\n\n\tFMassFindSmartObjectTask();\n\nprotected:\n\tvirtual bool Link(FStateTreeLinker& Linker) override;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\tvirtual void ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\tvirtual void StateCompleted(FStateTreeExecutionContext& Context, const EStateTreeRunStatus CompletionStatus, const FStateTreeActiveStates& CompletedActiveStates) const override;\n\tvirtual EStateTreeRunStatus Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const override;\n\n\tTStateTreeExternalDataHandle<USmartObjectSubsystem> SmartObjectSubsystemHandle;\n\tTStateTreeExternalDataHandle<UMassSignalSubsystem> MassSignalSubsystemHandle;\n\tTStateTreeExternalDataHandle<FTransformFragment> EntityTransformHandle;\n\tTStateTreeExternalDataHandle<FMassSmartObjectUserFragment> SmartObjectUserHandle;\n\tTStateTreeExternalDataHandle<FMassZoneGraphLaneLocationFragment, EStateTreeExternalDataRequirement::Optional> LocationHandle;\n\n\t/** Gameplay tag query for finding matching smart objects. */\n\tUPROPERTY(EditAnywhere, Category = Parameter)\n\tFGameplayTagQuery ActivityRequirements;\n\n\t/** How frequently to search for new candidates. */\n\tUPROPERTY(EditAnywhere, Category = Parameter)\n\tfloat SearchInterval = 10.0f;\n};",
      "lines": 68
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\Tasks\\MassLookAtTask.h",
      "extension": ".h",
      "size_bytes": 2722,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassStateTreeTypes.h\"\n#include \"MassLookAtFragments.h\"\n#include \"MassLookAtTask.generated.h\"\n\nclass UMassSignalSubsystem;\n\n/**\n * Task to assign a LookAt target for mass processing\n */\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassLookAtTaskInstanceData\n{\n\tGENERATED_BODY()\n\n\t/** Entity to set as the target for the LookAt behavior. */\n\tUPROPERTY(EditAnywhere, Category = Input, meta = (Optional))\n\tFMassEntityHandle TargetEntity;\n \n\t/** Delay before the task ends. Default (0 or any negative) will run indefinitely so it requires a transition in the state tree to stop it. */\n\tUPROPERTY(EditAnywhere, Category = Parameter)\n\tfloat Duration = 0.f;\n\n\t/** Accumulated time used to stop task if duration is set */\n\tUPROPERTY()\n\tfloat Time = 0.f;\n};\n\nUSTRUCT(meta = (DisplayName = \"Mass LookAt Task\"))\nstruct MASSAIBEHAVIOR_API FMassLookAtTask : public FMassStateTreeTaskBase\n{\n\tGENERATED_BODY()\n\n\tusing FInstanceDataType = FMassLookAtTaskInstanceData;\n\t\nprotected:\n\tvirtual bool Link(FStateTreeLinker& Linker) override;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\tvirtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\tvirtual void ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\tvirtual EStateTreeRunStatus Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const override;\n\n\tTStateTreeExternalDataHandle<UMassSignalSubsystem> MassSignalSubsystemHandle;\n\tTStateTreeExternalDataHandle<FMassLookAtFragment> LookAtHandle;\n\n\t/** Look At Mode */\n\tUPROPERTY(EditAnywhere, Category = Parameter)\n\tEMassLookAtMode LookAtMode = EMassLookAtMode::LookForward; \n\n\t/** Random gaze Mode */\n\tUPROPERTY(EditAnywhere, Category = Parameter)\n\tEMassLookAtGazeMode RandomGazeMode = EMassLookAtGazeMode::None;\n\t\n\t/** Random gaze yaw angle added to the look direction determined by the look at mode. */\n\tUPROPERTY(EditAnywhere, Category = Parameter, meta = (UIMin = 0.0, ClampMin = 0.0, UIMax = 180.0, ClampMax = 180.0))\n\tuint8 RandomGazeYawVariation = 0;\n\n\t/** Random gaze pitch angle added to the look direction determined by the look at mode. */\n\tUPROPERTY(EditAnywhere, Category = Parameter, meta = (UIMin = 0.0, ClampMin = 0.0, UIMax = 180.0, ClampMax = 180.0))\n\tuint8 RandomGazePitchVariation = 0;\n\n\t/** If true, allow random gaze to look at other entities too. */\n\tUPROPERTY(EditAnywhere, Category = Parameter)\n\tbool bRandomGazeEntities = false;\n};\n",
      "lines": 69
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\Tasks\\MassUseSmartObjectTask.h",
      "extension": ".h",
      "size_bytes": 2051,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassSmartObjectRequest.h\"\n#include \"MassStateTreeTypes.h\"\n#include \"MassUseSmartObjectTask.generated.h\"\n\nstruct FStateTreeExecutionContext;\nstruct FMassSmartObjectUserFragment;\nclass USmartObjectSubsystem;\nclass UMassSignalSubsystem;\nstruct FTransformFragment;\nstruct FMassMoveTargetFragment;\n\n/**\n * Task to tell an entity to start using a claimed smart object.\n */\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassUseSmartObjectTaskInstanceData\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(VisibleAnywhere, Category = Input)\n\tFSmartObjectClaimHandle ClaimedSlot;\n};\n\nUSTRUCT(meta = (DisplayName = \"Mass Use SmartObject Task\"))\nstruct MASSAIBEHAVIOR_API FMassUseSmartObjectTask : public FMassStateTreeTaskBase\n{\n\tGENERATED_BODY()\n\t\n\tusing FInstanceDataType = FMassUseSmartObjectTaskInstanceData;\n\n\tFMassUseSmartObjectTask();\n\nprotected:\n\tvirtual bool Link(FStateTreeLinker& Linker) override;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\tvirtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\tvirtual void ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\tvirtual void StateCompleted(FStateTreeExecutionContext& Context, const EStateTreeRunStatus CompletionStatus, const FStateTreeActiveStates& CompletedActiveStates) const override;\n\tvirtual EStateTreeRunStatus Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const override;\n\n\tTStateTreeExternalDataHandle<USmartObjectSubsystem> SmartObjectSubsystemHandle;\n\tTStateTreeExternalDataHandle<UMassSignalSubsystem> MassSignalSubsystemHandle;\n\tTStateTreeExternalDataHandle<FTransformFragment> EntityTransformHandle;\n\tTStateTreeExternalDataHandle<FMassSmartObjectUserFragment> SmartObjectUserHandle;\n\tTStateTreeExternalDataHandle<FMassMoveTargetFragment> MoveTargetHandle;\n};\n\n",
      "lines": 51
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\Tasks\\MassZoneGraphFindEscapeTarget.h",
      "extension": ".h",
      "size_bytes": 1684,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassStateTreeTypes.h\"\n#include \"Tasks/MassZoneGraphPathFollowTask.h\"\n#include \"MassZoneGraphFindEscapeTarget.generated.h\"\n\nstruct FStateTreeExecutionContext;\nstruct FMassZoneGraphLaneLocationFragment;\nclass UZoneGraphSubsystem;\nclass UZoneGraphAnnotationSubsystem;\n\n/**\n * Updates TargetLocation to a escape target based on the agents current location on ZoneGraph, and disturbance annotation.\n */\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassZoneGraphFindEscapeTargetInstanceData\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(VisibleAnywhere, Category = Output)\n\tFMassZoneGraphTargetLocation EscapeTargetLocation;\n};\n\nUSTRUCT(meta = (DisplayName = \"ZG Find Escape Target\"))\nstruct MASSAIBEHAVIOR_API FMassZoneGraphFindEscapeTarget : public FMassStateTreeTaskBase\n{\n\tGENERATED_BODY()\n\n\tusing FInstanceDataType = FMassZoneGraphFindEscapeTargetInstanceData;\n\t\n\tFMassZoneGraphFindEscapeTarget();\n\nprotected:\n\tvirtual bool Link(FStateTreeLinker& Linker) override;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\tvirtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\n\tTStateTreeExternalDataHandle<FMassZoneGraphLaneLocationFragment> LocationHandle;\n\tTStateTreeExternalDataHandle<UZoneGraphSubsystem> ZoneGraphSubsystemHandle;\n\tTStateTreeExternalDataHandle<UZoneGraphAnnotationSubsystem> ZoneGraphAnnotationSubsystemHandle;\n\n\tUPROPERTY(EditAnywhere, Category = Parameter)\n\tFZoneGraphTag DisturbanceAnnotationTag = FZoneGraphTag::None;\n};\n",
      "lines": 46
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\Tasks\\MassZoneGraphFindSmartObjectTarget.h",
      "extension": ".h",
      "size_bytes": 1616,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n#include \"MassStateTreeTypes.h\"\n#include \"SmartObjectRuntime.h\"\n#include \"MassZoneGraphPathFollowTask.h\"\n#include \"MassZoneGraphFindSmartObjectTarget.generated.h\"\n\nstruct FMassSmartObjectUserFragment;\nstruct FMassZoneGraphLaneLocationFragment;\nclass UZoneGraphAnnotationSubsystem;\nclass USmartObjectSubsystem;\n\n/**\n* Computes move target to a smart object based on current location on ZoneGraph.\n*/\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassZoneGraphFindSmartObjectTargetInstanceData\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(VisibleAnywhere, Category = Input)\n\tFSmartObjectClaimHandle ClaimedSlot;\n\n\tUPROPERTY(EditAnywhere, Category = Output)\n\tFMassZoneGraphTargetLocation SmartObjectLocation;\n};\n\nUSTRUCT(meta = (DisplayName = \"ZG Find Smart Object Target\"))\nstruct MASSAIBEHAVIOR_API FMassZoneGraphFindSmartObjectTarget : public FMassStateTreeTaskBase\n{\n\tGENERATED_BODY()\n\n\tusing FInstanceDataType = FMassZoneGraphFindSmartObjectTargetInstanceData;\n\nprotected:\n\tvirtual bool Link(FStateTreeLinker& Linker) override;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\tvirtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\n\tTStateTreeExternalDataHandle<FMassZoneGraphLaneLocationFragment> LocationHandle;\n\tTStateTreeExternalDataHandle<UZoneGraphAnnotationSubsystem> AnnotationSubsystemHandle;\n\tTStateTreeExternalDataHandle<USmartObjectSubsystem> SmartObjectSubsystemHandle;\n};",
      "lines": 44
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\Tasks\\MassZoneGraphPathFollowTask.h",
      "extension": ".h",
      "size_bytes": 3993,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassNavigationTypes.h\"\n#include \"MassMovementTypes.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassStateTreeTypes.h\"\n#include \"ZoneGraphTypes.h\"\n#include \"MassZoneGraphPathFollowTask.generated.h\"\n\nstruct FMassStateTreeExecutionContext;\nstruct FMassZoneGraphLaneLocationFragment;\nstruct FMassMoveTargetFragment;\nstruct FMassZoneGraphPathRequestFragment;\nstruct FMassZoneGraphShortPathFragment;\nstruct FMassZoneGraphCachedLaneFragment;\nstruct FAgentRadiusFragment;\nstruct FMassMovementParameters;\nclass UZoneGraphSubsystem;\n\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassZoneGraphTargetLocation\n{\n\tGENERATED_BODY()\n\n\tvoid Reset()\n\t{\n\t\tLaneHandle.Reset();\n\t\tNextLaneHandle.Reset();\n\t\tNextExitLinkType = EZoneLaneLinkType::None;\n\t\tbMoveReverse = false;\n\t\tTargetDistance = 0.0f;\n\t\tEndOfPathPosition.Reset();\n\t\tAnticipationDistance.Set(50.0f);\n\t\tEndOfPathIntent = EMassMovementAction::Move;\n\t}\n\n\t/** Current lane handle. (Could be debug only) */\n\tFZoneGraphLaneHandle LaneHandle;\n\t\n\t/** If valid, the this lane will be set as current lane after the path follow is completed. */\n\tFZoneGraphLaneHandle NextLaneHandle;\n\t\n\t/** Target distance along current lane. */\n\tfloat TargetDistance = 0.0f;\n\t\n\t/** Optional end of path location. */\n\tTOptional<FVector> EndOfPathPosition;\n\n\t/** Optional end of path direction, used only if EndOfPathPosition is set. */\n\tTOptional<FVector> EndOfPathDirection;\n\n\t/** If start or end of path is off-lane, the distance along the lane is pushed forward/back along the lane to make smoother transition. */\n\tFMassInt16Real AnticipationDistance = FMassInt16Real(50.0f);\n\n\t/** True, if we're moving reverse along the lane. */\n\tbool bMoveReverse = false;\n\t\n\t/** Movement intent at the end of the path */\n\tEMassMovementAction EndOfPathIntent = EMassMovementAction::Move;\n\t\n\t/** How the next lane handle is reached relative to the current lane. */\n\tEZoneLaneLinkType NextExitLinkType = EZoneLaneLinkType::None;\n};\n\n/**\n * Follows a path long the current lane to a specified point.\n */\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassZoneGraphPathFollowTaskInstanceData\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, Category = Input, meta=(BaseStruct = \"/Script/MassAIBehavior.MassZoneGraphTargetLocation\"))\n\tFStateTreeStructRef TargetLocation; \n\n\tUPROPERTY(EditAnywhere, Category = Parameter)\n\tFMassMovementStyleRef MovementStyle;\n\n\tUPROPERTY(EditAnywhere, Category = Parameter)\n\tfloat SpeedScale = 1.0f;\n};\n\nUSTRUCT(meta = (DisplayName = \"ZG Path Follow\"))\nstruct MASSAIBEHAVIOR_API FMassZoneGraphPathFollowTask : public FMassStateTreeTaskBase\n{\n\tGENERATED_BODY()\n\n\tusing FInstanceDataType = FMassZoneGraphPathFollowTaskInstanceData;\n\nprotected:\n\tvirtual bool Link(FStateTreeLinker& Linker) override;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); };\n\tvirtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\tvirtual EStateTreeRunStatus Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const override;\n\n\tbool RequestPath(FMassStateTreeExecutionContext& Context, const FMassZoneGraphTargetLocation& TargetLocation) const;\n\n\tTStateTreeExternalDataHandle<FMassZoneGraphLaneLocationFragment> LocationHandle;\n\tTStateTreeExternalDataHandle<FMassMoveTargetFragment> MoveTargetHandle;\n\tTStateTreeExternalDataHandle<FMassZoneGraphPathRequestFragment> PathRequestHandle;\n\tTStateTreeExternalDataHandle<FMassZoneGraphShortPathFragment> ShortPathHandle;\n\tTStateTreeExternalDataHandle<FMassZoneGraphCachedLaneFragment> CachedLaneHandle;\n\tTStateTreeExternalDataHandle<FAgentRadiusFragment> AgentRadiusHandle;\n\tTStateTreeExternalDataHandle<FMassMovementParameters> MovementParamsHandle;\n\tTStateTreeExternalDataHandle<UZoneGraphSubsystem> ZoneGraphSubsystemHandle;\n};\n",
      "lines": 108
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Public\\Tasks\\MassZoneGraphStandTask.h",
      "extension": ".h",
      "size_bytes": 2069,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassStateTreeTypes.h\"\n#include \"MassZoneGraphStandTask.generated.h\"\n\nstruct FStateTreeExecutionContext;\nstruct FMassZoneGraphLaneLocationFragment;\nstruct FMassMoveTargetFragment;\nstruct FMassZoneGraphShortPathFragment;\nstruct FMassZoneGraphCachedLaneFragment;\nstruct FMassMovementParameters;\nclass UZoneGraphSubsystem;\nclass UMassSignalSubsystem;\n\n/**\n * Stop, and stand on current ZoneGraph location\n */\n\nUSTRUCT()\nstruct MASSAIBEHAVIOR_API FMassZoneGraphStandTaskInstanceData\n{\n\tGENERATED_BODY()\n\n\t/** Delay before the task ends. Default (0 or any negative) will run indefinitely so it requires a transition in the state tree to stop it. */\n\tUPROPERTY(EditAnywhere, Category = Parameter)\n\tfloat Duration = 0.0f;\n\n\tUPROPERTY()\n\tfloat Time = 0.0f;\n};\n\nUSTRUCT(meta = (DisplayName = \"ZG Stand\"))\nstruct MASSAIBEHAVIOR_API FMassZoneGraphStandTask : public FMassStateTreeTaskBase\n{\n\tGENERATED_BODY()\n\n\tusing FInstanceDataType = FMassZoneGraphStandTaskInstanceData;\n\nprotected:\n\tvirtual bool Link(FStateTreeLinker& Linker) override;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\tvirtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\tvirtual EStateTreeRunStatus Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const override;\n\n\tTStateTreeExternalDataHandle<FMassZoneGraphLaneLocationFragment> LocationHandle;\n\tTStateTreeExternalDataHandle<FMassMoveTargetFragment> MoveTargetHandle;\n\tTStateTreeExternalDataHandle<FMassZoneGraphShortPathFragment> ShortPathHandle;\n\tTStateTreeExternalDataHandle<FMassZoneGraphCachedLaneFragment> CachedLaneHandle;\n\tTStateTreeExternalDataHandle<FMassMovementParameters> MovementParamsHandle;\n\tTStateTreeExternalDataHandle<UZoneGraphSubsystem> ZoneGraphSubsystemHandle;\n\tTStateTreeExternalDataHandle<UMassSignalSubsystem> MassSignalSubsystemHandle;\n};\n",
      "lines": 54
    },
    {
      "file_path": "MassAI\\MassAIDebug\\Public\\GameplayDebuggerCategory_Mass.h",
      "extension": ".h",
      "size_bytes": 4894,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n// Required first for WITH_MASSGAMEPLAY_DEBUG\n#include \"MassCommonTypes.h\"\n\n#if WITH_GAMEPLAY_DEBUGGER && WITH_MASSGAMEPLAY_DEBUG\n\n#include \"HAL/IConsoleManager.h\"\n#include \"GameplayDebuggerCategory.h\"\n\nstruct FMassEntityManager;\nclass UMassDebuggerSubsystem;\nclass APlayerController;\nclass AActor;\n\nclass FGameplayDebuggerCategory_Mass : public FGameplayDebuggerCategory\n{\n\tusing Super = FGameplayDebuggerCategory;\npublic:\n\tFGameplayDebuggerCategory_Mass();\n\tvirtual ~FGameplayDebuggerCategory_Mass();\n\n\tstatic TSharedRef<FGameplayDebuggerCategory> MakeInstance();\n\nprotected:\n\tvirtual void CollectData(APlayerController* OwnerPC, AActor* DebugActor) override;\n\tvirtual void DrawData(APlayerController* OwnerPC, FGameplayDebuggerCanvasContext& CanvasContext) override;\n\t\n\tvoid SetCachedEntity(const FMassEntityHandle Entity, const FMassEntityManager& EntityManager);\n\n\tvoid OnToggleArchetypes() { bShowArchetypes = !bShowArchetypes; }\n\tvoid OnToggleShapes() { bShowShapes = !bShowShapes; }\n\tvoid OnToggleAgentFragments() { bShowAgentFragments = !bShowAgentFragments; }\n\tvoid OnPickEntity() { bPickEntity = true; }\n\tvoid OnToggleEntityDetails() { bShowEntityDetails = !bShowEntityDetails; }\n\tvoid OnToggleNearEntityOverview() { bShowNearEntityOverview = !bShowNearEntityOverview; }\n\tvoid OnToggleNearEntityAvoidance() { bShowNearEntityAvoidance = !bShowNearEntityAvoidance; }\n\tvoid OnToggleNearEntityPath() { bShowNearEntityPath = !bShowNearEntityPath; }\n\tvoid OnToggleDebugLocalEntityManager();\n\tvoid OnIncreaseSearchRange();\n\tvoid OnDecreaseSearchRange();\n\tvoid OnTogglePickedActorAsViewer();\n\tvoid OnToggleDrawViewers() { bShowViewers = !bShowViewers; }\n\tvoid OnClearActorViewers();\n\t\n\tvoid PickEntity(const FVector& ViewLocation, const FVector& ViewDirection, const UWorld& World, FMassEntityManager& EntityManager, const bool bLimitAngle = true);\n\n\tUE_DEPRECATED(5.3, \"This flavor of PickEntity has been deprecated. Use the one getting ViewLocation and ViewDirection parameters instead.\")\n\tvoid PickEntity(const APlayerController& OwnerPC, const UWorld& World, FMassEntityManager& EntityManager, const bool bLimitAngle = true);\n\n\tvoid OnEntitySelected(const FMassEntityManager& EntityManager, const FMassEntityHandle EntityHandle);\n\tvoid ClearCachedEntity();\n\nprotected:\n\tTWeakObjectPtr<AActor> CachedDebugActor;\n\tFMassEntityHandle CachedEntity;\n\tbool bShowArchetypes;\n\tbool bShowShapes;\n\tbool bShowAgentFragments;\n\tbool bPickEntity;\n\tbool bShowEntityDetails;\n\tbool bShowNearEntityOverview;\n\tbool bShowNearEntityAvoidance;\n\tbool bShowNearEntityPath;\n\tbool bMarkEntityBeingDebugged;\n\tbool bDebugLocalEntityManager;\n\tbool bShowViewers;\n\tint32 ToggleDebugLocalEntityManagerInputIndex = INDEX_NONE;\n\tint32 TogglePickedActorAsViewerInputIndex = INDEX_NONE;\n\tint32 ToggleDrawViewersInputIndex = INDEX_NONE;\n\tint32 ClearViewersInputIndex = INDEX_NONE;\n\tfloat SearchRange = 25000.f;\n\n\tstruct FEntityDescription\n\t{\n\t\tFEntityDescription() = default;\n\t\tFEntityDescription(const float InScore, const FVector& InLocation, const FString& InDescription) : Score(InScore), Location(InLocation), Description(InDescription) {}\n\n\t\tfloat Score = 0.0f;\n\t\tFVector Location = FVector::ZeroVector;\n\t\tFString Description;\n\t};\n\tTArray<FEntityDescription> NearEntityDescriptions;\n\n\tstatic TArray<FAutoConsoleCommandWithWorld> ConsoleCommands;\n\tDECLARE_MULTICAST_DELEGATE_OneParam(FOnConsoleCommandBroadcastDelegate, UWorld*);\n\tstatic FOnConsoleCommandBroadcastDelegate OnToggleArchetypesBroadcast;\n\tstatic FOnConsoleCommandBroadcastDelegate OnToggleShapesBroadcast;\n\tstatic FOnConsoleCommandBroadcastDelegate OnToggleAgentFragmentsBroadcast;\n\tstatic FOnConsoleCommandBroadcastDelegate OnPickEntityBroadcast;\n\tstatic FOnConsoleCommandBroadcastDelegate OnToggleEntityDetailsBroadcast;\n\tstatic FOnConsoleCommandBroadcastDelegate OnToggleNearEntityOverviewBroadcast;\n\tstatic FOnConsoleCommandBroadcastDelegate OnToggleNearEntityAvoidanceBroadcast;\n\tstatic FOnConsoleCommandBroadcastDelegate OnToggleNearEntityPathBroadcast; \t\n\tstatic FOnConsoleCommandBroadcastDelegate OnToggleDebugLocalEntityManagerBroadcast; \t\n\tstatic FOnConsoleCommandBroadcastDelegate OnTogglePickedActorAsViewerBroadcast;\n\tstatic FOnConsoleCommandBroadcastDelegate OnToggleDrawViewersBroadcast;\n\tstatic FOnConsoleCommandBroadcastDelegate OnClearActorViewersBroadcast;\n\n\tusing FDelegateHandlePair = TPair<FOnConsoleCommandBroadcastDelegate*, FDelegateHandle>;\n\tTArray<FDelegateHandlePair> ConsoleCommandHandles;\n\n\tFDelegateHandle OnEntitySelectedHandle;\n\n\tstatic constexpr float MaxSearchRange = 1000000.f;\n\tstatic constexpr float MinSearchRange = 1.f;\n\tstatic constexpr float SearchRangeChangeScale = 2.f;\n};\n\n#endif // WITH_GAMEPLAY_DEBUGGER && WITH_MASSGAMEPLAY_DEBUG\n",
      "lines": 112
    },
    {
      "file_path": "MassAI\\MassAIDebug\\Public\\IMassAIDebugModule.h",
      "extension": ".h",
      "size_bytes": 1118,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n * The public interface to this module.  In most cases, this interface is only public to sibling modules \n * within this plugin.\n */\nclass IMassAIDebugModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t * Singleton-like access to this module's interface.  This is just for convenience!\n\t * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t *\n\t * @return Returns singleton instance, loading the module on demand if needed\n\t */\n\tstatic inline IMassAIDebugModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassAIDebugModule>( \"MassAIDebug\" );\n\t}\n\n\t/**\n\t * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t *\n\t * @return True if the module is loaded and ready to use\n\t */\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassAIDebug\" );\n\t}\n};\n\n",
      "lines": 40
    },
    {
      "file_path": "MassAI\\MassAIDebug\\Public\\MassDebugStateTreeProcessor.h",
      "extension": ".h",
      "size_bytes": 579,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessor.h\"\n#include \"MassDebugStateTreeProcessor.generated.h\"\n\nstruct FMassEntityManager;\nstruct FMassEntityQuery;\nstruct FMassExecutionContext;\n\nUCLASS()\nclass MASSAIDEBUG_API UMassDebugStateTreeProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\nprotected:\n\tUMassDebugStateTreeProcessor();\n\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};\n",
      "lines": 24
    },
    {
      "file_path": "MassAI\\MassAIReplication\\Public\\IMassAIReplicationModule.h",
      "extension": ".h",
      "size_bytes": 1148,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n * The public interface to this module.  In most cases, this interface is only public to sibling modules \n * within this plugin.\n */\nclass IMassAIReplicationModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t * Singleton-like access to this module's interface.  This is just for convenience!\n\t * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t *\n\t * @return Returns singleton instance, loading the module on demand if needed\n\t */\n\tstatic inline IMassAIReplicationModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassAIReplicationModule>( \"MassAIReplication\" );\n\t}\n\n\t/**\n\t * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t *\n\t * @return True if the module is loaded and ready to use\n\t */\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassAIReplication\" );\n\t}\n};\n\n",
      "lines": 40
    },
    {
      "file_path": "MassAI\\MassAIReplication\\Public\\MassReplicationPathHandlers.h",
      "extension": ".h",
      "size_bytes": 10857,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassReplicationTypes.h\"\n#include \"MassEntityView.h\"\n#include \"MassClientBubbleHandler.h\"\n#include \"MassNavigationFragments.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n\n#include \"MassReplicationPathHandlers.generated.h\"\n\nstruct FMassEntityQuery;\n\n//////////////////////////////////////////////////////////////////////////// FReplicatedAgentPathData ////////////////////////////////////////////////////////////////////////////\n/**\n * To replicate path following make a member variable of this class in your FReplicatedAgentBase derived class. In the FReplicatedAgentBase derived class you must also provide an accessor function\n * FReplicatedAgentPathData& GetReplicatedPathDataMutable().\n */\nUSTRUCT()\nstruct MASSAIREPLICATION_API FReplicatedAgentPathData\n{\n\tGENERATED_BODY()\n\n\tfriend class FMassClientBubblePathHandlerBase;\n\n\tFReplicatedAgentPathData() = default;\n\texplicit FReplicatedAgentPathData(const FMassZoneGraphPathRequestFragment& RequestFragment,\n\t\tconst FMassMoveTargetFragment& MoveTargetFragment,\n\t\tconst FMassZoneGraphLaneLocationFragment& LaneLocationFragment);\n\n\tvoid InitEntity(const UWorld& InWorld,\n\t\t\t\t\tconst FMassEntityView& InEntityView,\n\t\t\t\t\tFMassZoneGraphLaneLocationFragment& OutLaneLocation,\n\t\t\t\t\tFMassMoveTargetFragment& OutMoveTarget,\n\t\t\t\t\tFMassZoneGraphPathRequestFragment& OutActionRequest) const;\n\n\tvoid ApplyToEntity(const UWorld& InWorld, const FMassEntityView& InEntityView) const;\n\n\tUPROPERTY(Transient)\n\tmutable FZoneGraphShortPathRequest PathRequest;\n\n\t/** Handle to current lane. */\n\tUPROPERTY(Transient)\n\tFZoneGraphLaneHandle LaneHandle;\n\n\t/** Server time in seconds when the action started. */\n\tUPROPERTY(Transient)\n\tdouble ActionServerStartTime = 0.;\n\n\t/** Distance along current lane. */\n\tUPROPERTY(Transient)\n\tfloat DistanceAlongLane = 0.0f;\n\n\t/** Cached lane length, used for clamping and testing if at end of lane. */\n\tUPROPERTY(Transient)\n\tfloat LaneLength = 0.0f;\n\n\t/** Requested movement speed. */\n\tUPROPERTY(Transient)\n\tFMassInt16Real DesiredSpeed = FMassInt16Real(0.0f);\n\n\tUPROPERTY(Transient)\n\tuint16 ActionID = 0;\n\n\t/** Current movement action. */\n\tUPROPERTY(Transient)\n\tEMassMovementAction Action = EMassMovementAction::Move;\n};\n\n//////////////////////////////////////////////////////////////////////////// TMassClientBubblePathHandler ////////////////////////////////////////////////////////////////////////////\n/**\n * To replicate path following make a member variable of this class in your TClientBubbleHandlerBase derived class. This class is a friend of TMassClientBubblePathHandler.\n * It is meant to have access to the protected data declared there.\n */\ntemplate<typename AgentArrayItem>\nclass TMassClientBubblePathHandler\n{\npublic:\n\tTMassClientBubblePathHandler(TClientBubbleHandlerBase<AgentArrayItem>& InOwnerHandler)\n\t\t: OwnerHandler(InOwnerHandler)\n\t{}\n\n#if UE_REPLICATION_COMPILE_SERVER_CODE\n\t/** Sets the path data in the client bubble on the server */\n\tvoid SetBubblePathData(const FMassReplicatedAgentHandle Handle,\n\t\tconst FMassZoneGraphPathRequestFragment& PathRequest,\n\t\tconst FMassMoveTargetFragment& MoveTargetFragment,\n\t\tconst FMassZoneGraphLaneLocationFragment& LaneLocationFragment);\n#endif // UE_REPLICATION_COMPILE_SERVER_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\t/**\n\t * When entities are spawned in Mass by the replication system on the client, a spawn query is used to set the data on the spawned entities.\n\t * The following functions are used to configure the query and then set that data for path following.\n\t */\n\tstatic void AddRequirementsForSpawnQuery(FMassEntityQuery& InQuery);\n\tvoid CacheFragmentViewsForSpawnQuery(FMassExecutionContext& InExecContext);\n\tvoid ClearFragmentViewsForSpawnQuery();\n\n\tvoid SetSpawnedEntityData(const FMassEntityView& EntityView, const FReplicatedAgentPathData& ReplicatedPathData, const int32 EntityIdx) const;\n\n\t/** Call this when an Entity that has already been spawned is modified on the client */\n\tvoid SetModifiedEntityData(const FMassEntityView& EntityView, const FReplicatedAgentPathData& ReplicatedPathData) const;\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\nprotected:\n\tTArrayView<FMassZoneGraphPathRequestFragment> PathRequestList;\n\tTArrayView<FMassMoveTargetFragment> MoveTargetList;\n\tTArrayView<FMassZoneGraphLaneLocationFragment> LaneLocationList;\n\n\tTClientBubbleHandlerBase<AgentArrayItem>& OwnerHandler;\n};\n\n#if UE_REPLICATION_COMPILE_SERVER_CODE\ntemplate<typename AgentArrayItem>\nvoid TMassClientBubblePathHandler<AgentArrayItem>::SetBubblePathData(const FMassReplicatedAgentHandle Handle,\n\tconst FMassZoneGraphPathRequestFragment& PathRequestFragment,\n\tconst FMassMoveTargetFragment& MoveTargetFragment,\n\tconst FMassZoneGraphLaneLocationFragment& LaneLocationFragment)\n{\n\tcheck(OwnerHandler.AgentHandleManager.IsValidHandle(Handle));\n\n\tconst int32 AgentsIdx = OwnerHandler.AgentLookupArray[Handle.GetIndex()].AgentsIdx;\n\tAgentArrayItem& Item = (*OwnerHandler.Agents)[AgentsIdx];\n\n\tcheckf(Item.Agent.GetNetID().IsValid(), TEXT(\"Pos should not be updated on FCrowdFastArrayItem's that have an Invalid ID! First Add the Agent!\"));\n\n\t// GetReplicatedPathDataMutable() must be defined in your FReplicatedAgentBase derived class\n\tFReplicatedAgentPathData& ReplicatedPath = Item.Agent.GetReplicatedPathDataMutable();\n\n\tif (ReplicatedPath.ActionID != MoveTargetFragment.GetCurrentActionID())\n\t{\n\t\tReplicatedPath = FReplicatedAgentPathData(PathRequestFragment, MoveTargetFragment, LaneLocationFragment);\n\n\t\tOwnerHandler.Serializer->MarkItemDirty(Item);\n\t}\n}\n#endif //UE_REPLICATION_COMPILE_SERVER_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\ntemplate<typename AgentArrayItem>\nvoid TMassClientBubblePathHandler<AgentArrayItem>::AddRequirementsForSpawnQuery(FMassEntityQuery& InQuery)\n{\n\tInQuery.AddRequirement<FMassZoneGraphPathRequestFragment>(EMassFragmentAccess::ReadWrite);\n\tInQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadWrite);\n\tInQuery.AddRequirement<FMassZoneGraphLaneLocationFragment>(EMassFragmentAccess::ReadWrite);\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\ntemplate<typename AgentArrayItem>\nvoid TMassClientBubblePathHandler<AgentArrayItem>::CacheFragmentViewsForSpawnQuery(FMassExecutionContext& InExecContext)\n{\n\tPathRequestList = InExecContext.GetMutableFragmentView<FMassZoneGraphPathRequestFragment>();\n\tMoveTargetList = InExecContext.GetMutableFragmentView<FMassMoveTargetFragment>();\n\tLaneLocationList = InExecContext.GetMutableFragmentView<FMassZoneGraphLaneLocationFragment>();\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\ntemplate<typename AgentArrayItem>\nvoid TMassClientBubblePathHandler<AgentArrayItem>::ClearFragmentViewsForSpawnQuery()\n{\n\tLaneLocationList = TArrayView<FMassZoneGraphLaneLocationFragment>();\n\tMoveTargetList = TArrayView<FMassMoveTargetFragment>();\n\tPathRequestList = TArrayView<FMassZoneGraphPathRequestFragment>();\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\ntemplate<typename AgentArrayItem>\nvoid TMassClientBubblePathHandler<AgentArrayItem>::SetSpawnedEntityData(const FMassEntityView& EntityView, const FReplicatedAgentPathData& ReplicatedPathData, const int32 EntityIdx) const\n{\n\tUWorld* World = OwnerHandler.Serializer->GetWorld();\n\tcheck(World);\n\tReplicatedPathData.InitEntity(*World, EntityView, LaneLocationList[EntityIdx], MoveTargetList[EntityIdx], PathRequestList[EntityIdx]);\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\ntemplate<typename AgentArrayItem>\nvoid TMassClientBubblePathHandler<AgentArrayItem>::SetModifiedEntityData(const FMassEntityView& EntityView, const FReplicatedAgentPathData& ReplicatedPathData) const\n{\n\tUWorld* World = OwnerHandler.Serializer->GetWorld();\n\tcheck(World);\n\tReplicatedPathData.ApplyToEntity(*World, EntityView);\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n//////////////////////////////////////////////////////////////////////////// FMassReplicationProcessorPathHandler ////////////////////////////////////////////////////////////////////////////\n/**\n * Used to replicate path following by your UMassReplicationProcessorBase derived class. This class should only get used on the server.\n * @todo add #if UE_REPLICATION_COMPILE_SERVER_CODE\n */\nclass MASSAIREPLICATION_API FMassReplicationProcessorPathHandler\n{\npublic:\n\t/** Adds the requirements for the path following to the query. */\n\tstatic void AddRequirements(FMassEntityQuery& InQuery);\n\n\t/** Cache any component views you want to, this will get called before we iterate through entities. */\n\tvoid CacheFragmentViews(FMassExecutionContext& ExecContext);\n\n\t/**\n\t * Set the replicated path data when we are adding an entity to the client bubble.\n\t * @param EntityIdx the index of the entity in fragment views that have been cached.\n\t * @param InOUtReplicatedPathData the data to set.\n\t */\n\tvoid AddEntity(const int32 EntityIdx, FReplicatedAgentPathData& InOUtReplicatedPathData) const;\n\n\t/**\n\t * Set the replicated path data when we are modifying an entity that already exists in the client bubble.\n\t * @param Handle to the agent in the TMassClientBubbleHandler (that TMassClientBubblePathHandler is a member variable of).\n\t * @param EntityIdx the index of the entity in fragment views that have been cached.\n\t * @param BubblePathHandler handler to actually set the data in the client bubble\n\t * @param bLastClient means it safe to reset any dirtiness\n\t */\n\ttemplate<typename AgentArrayItem>\n\tvoid ModifyEntity(const FMassReplicatedAgentHandle Handle, const int32 EntityIdx, TMassClientBubblePathHandler<AgentArrayItem>& BubblePathHandler, bool bLastClient);\n\n\tTArrayView<FMassZoneGraphPathRequestFragment> PathRequestList;\n\tTArrayView<FMassMoveTargetFragment> MoveTargetList;\n\tTArrayView<FMassZoneGraphLaneLocationFragment> LaneLocationList;\n};\n\ntemplate<typename AgentArrayItem>\nvoid FMassReplicationProcessorPathHandler::ModifyEntity(const FMassReplicatedAgentHandle Handle, const int32 EntityIdx, TMassClientBubblePathHandler<AgentArrayItem>& BubblePathHandler, bool bLastClient)\n{\n\tconst FMassZoneGraphPathRequestFragment& PathRequest = PathRequestList[EntityIdx];\n\tFMassMoveTargetFragment& MoveTargetFragment = MoveTargetList[EntityIdx];\n\tconst FMassZoneGraphLaneLocationFragment& LaneLocationFragment = LaneLocationList[EntityIdx];\n\n\tif (MoveTargetFragment.GetNetDirty())\n\t{\n\t\tBubblePathHandler.SetBubblePathData(Handle, PathRequest, MoveTargetFragment, LaneLocationFragment);\n\t\tif (bLastClient)\n\t\t{\n\t\t\tMoveTargetFragment.ResetNetDirty();\n\t\t}\n\t}\n}\n",
      "lines": 242
    },
    {
      "file_path": "MassAI\\MassAITestSuite\\Public\\MassAITestSuiteModule.h",
      "extension": ".h",
      "size_bytes": 993,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma  once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleManager.h\"\n\n/**\n* The public interface to this module\n*/\nclass IMassAITestSuiteModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t* Singleton-like access to this module's interface.  This is just for convenience!\n\t* Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t*\n\t* @return Returns singleton instance, loading the module on demand if needed\n\t*/\n\tstatic inline IMassAITestSuiteModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassAITestSuiteModule>(\"MassAITestSuite\");\n\t}\n\n\t/**\n\t* Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t*\n\t* @return True if the module is loaded and ready to use\n\t*/\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded(\"MassAITestSuite\");\n\t}\n};\n\n",
      "lines": 37
    },
    {
      "file_path": "MassAI\\MassNavigation\\Public\\IMassNavigationModule.h",
      "extension": ".h",
      "size_bytes": 1133,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n * The public interface to this module.  In most cases, this interface is only public to sibling modules \n * within this plugin.\n */\nclass IMassNavigationModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t * Singleton-like access to this module's interface.  This is just for convenience!\n\t * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t *\n\t * @return Returns singleton instance, loading the module on demand if needed\n\t */\n\tstatic inline IMassNavigationModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassNavigationModule>( \"MassNavigation\" );\n\t}\n\n\t/**\n\t * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t *\n\t * @return True if the module is loaded and ready to use\n\t */\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassNavigation\" );\n\t}\n};\n\n",
      "lines": 40
    },
    {
      "file_path": "MassAI\\MassNavigation\\Public\\MassNavigationFragments.h",
      "extension": ".h",
      "size_bytes": 5153,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassNavigationTypes.h\"\n#include \"MassNavigationSubsystem.h\"\n#include \"MassNavigationFragments.generated.h\"\n\nclass UWorld;\n\n/** Move target. */\nUSTRUCT()\nstruct MASSNAVIGATION_API FMassMoveTargetFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tFMassMoveTargetFragment() : bNetDirty(false), bOffBoundaries(false), bSteeringFallingBehind(false) {}\n\n\t/** To setup current action from the authoritative world */\n\tvoid CreateNewAction(const EMassMovementAction InAction, const UWorld& InWorld);\n\n\t/** To setup current action from replicated data */\n\tvoid CreateReplicatedAction(const EMassMovementAction InAction, const uint16 InActionID, const double InWorldStartTime, const double InServerStartTime);\n\n\tvoid MarkNetDirty() { bNetDirty = true; }\n\tbool GetNetDirty() const { return bNetDirty; }\n\tvoid ResetNetDirty() { bNetDirty = false; }\n\npublic:\n\tFString ToString() const;\n\n\tEMassMovementAction GetPreviousAction() const { return PreviousAction; }\n\tEMassMovementAction GetCurrentAction() const { return CurrentAction; }\n\tdouble GetCurrentActionStartTime() const { return CurrentActionWorldStartTime; }\n\tdouble GetCurrentActionServerStartTime() const { return CurrentActionServerStartTime; }\n\tuint16 GetCurrentActionID() const { return CurrentActionID; }\n\n\t/** Center of the move target. */\n\tFVector Center = FVector::ZeroVector;\n\n\t/** Forward direction of the movement target.  */\n\tFVector Forward = FVector::ZeroVector;\n\n\t/** Distance remaining to the movement goal. */\n\tfloat DistanceToGoal = 0.0f;\n\n\t/** Allowed deviation around the movement target. */\n\tfloat SlackRadius = 0.0f;\n\nprivate:\n\t/** World time in seconds when the action started. */\n\tdouble CurrentActionWorldStartTime = 0.0;\n\n\t/** Server time in seconds when the action started. */\n\tdouble CurrentActionServerStartTime = 0.0;\n\n\t/** Number incremented each time new action (i.e move, stand, animation) is started. */\n\tuint16 CurrentActionID = 0;\n\npublic:\n\t/** Requested movement speed. */\n\tFMassInt16Real DesiredSpeed = FMassInt16Real(0.0f);\n\n\t/** Intended movement action at the target. */\n\tEMassMovementAction IntentAtGoal = EMassMovementAction::Move;\n\nprivate:\n\t/** Current movement action. */\n\tEMassMovementAction CurrentAction = EMassMovementAction::Move;\n\n\t/** Previous movement action. */\n\tEMassMovementAction PreviousAction = EMassMovementAction::Move;\n\n\tuint8 bNetDirty : 1;\npublic:\n\t/** True if the movement target is assumed to be outside navigation boundaries. */\n\tuint8 bOffBoundaries : 1;\n\n\t/** True if the movement target is assumed to be outside navigation boundaries. */\n\tuint8 bSteeringFallingBehind : 1;\n};\n\n/** Ghost location used for standing navigation. */\nUSTRUCT()\nstruct MASSNAVIGATION_API FMassGhostLocationFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tbool IsValid(const uint16 CurrentActionID) const\n\t{\n\t\treturn LastSeenActionID == CurrentActionID;\n\t}\n\n\t/** The action ID the ghost was initialized for */\n\tuint16 LastSeenActionID = 0;\n\n\t/** Location of the ghost */\n\tFVector Location = FVector::ZeroVector;\n\t\n\t/** Velocity of the ghost */\n\tFVector Velocity = FVector::ZeroVector;\n};\n\n/** Cell location for dynamic obstacles */\nUSTRUCT()\nstruct MASSNAVIGATION_API FMassNavigationObstacleGridCellLocationFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\tFNavigationObstacleHashGrid2D::FCellLocation CellLoc;\n};\n\n\nenum class EMassColliderType : uint8\n{\n\tCircle,\n\tPill,\n};\n\nstruct FMassCircleCollider\n{\n\tFMassCircleCollider() = default;\n\tFMassCircleCollider(const float Radius) : Radius(Radius) {}\n\tfloat Radius = 0.f;\n};\n\nstruct FMassPillCollider\n{\n\tFMassPillCollider() = default;\n\tFMassPillCollider(const float Radius, const float HalfLength) : Radius(Radius), HalfLength(HalfLength) {}\n\tfloat Radius = 0.f;\n\tfloat HalfLength = 0.f;\n};\n\n/** Fragment holding data for avoidance colliders */\nUSTRUCT()\nstruct MASSNAVIGATION_API FMassAvoidanceColliderFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tFMassAvoidanceColliderFragment()\n\t{\n\t\tType = EMassColliderType::Circle;\n\t\tData[0] = 0.f;\n\t\tData[1] = 0.f;\n\t}\n\n\tFMassAvoidanceColliderFragment(const FMassCircleCollider& Circle)\n\t{\n\t\tType = EMassColliderType::Circle;\n\t\tData[0] = Circle.Radius;\n\t\tData[1] = 0.f;\n\t}\n\n\tFMassAvoidanceColliderFragment(const FMassPillCollider& Pill)\n\t{\n\t\tType = EMassColliderType::Pill;\n\t\tData[0] = Pill.Radius;\n\t\tData[1] = Pill.HalfLength;\n\t}\n\t\n\tFMassCircleCollider GetCircleCollider() const\n\t{\n\t\tcheck(Type == EMassColliderType::Circle);\n\t\treturn FMassCircleCollider(Data[0]);\n\t}\n\n\tFMassPillCollider GetPillCollider() const\n\t{\n\t\tcheck(Type == EMassColliderType::Pill);\n\t\treturn FMassPillCollider(Data[0], Data[1]);\n\t}\n\n\tfloat Data[2];\n\tEMassColliderType Type;\n};\n\n\n/** Component Tag to tell if the entity is in the navigation obstacle grid */\nUSTRUCT()\nstruct MASSNAVIGATION_API FMassInNavigationObstacleGridTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n",
      "lines": 185
    },
    {
      "file_path": "MassAI\\MassNavigation\\Public\\MassNavigationProcessors.h",
      "extension": ".h",
      "size_bytes": 2615,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessor.h\"\n#include \"MassObserverProcessor.h\"\n#include \"MassNavigationProcessors.generated.h\"\n\nclass UMassNavigationSubsystem;\n\n/**\n * Updates Off-LOD entities position to move targets position.\n */\nUCLASS()\nclass MASSNAVIGATION_API UMassOffLODNavigationProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassOffLODNavigationProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\nprivate:\n\tFMassEntityQuery EntityQuery_Conditional;\n};\n\n/**\n * Updates entities height to move targets position smoothly.\n * Does not update Off-LOD entities.\n */\nUCLASS()\nclass MASSNAVIGATION_API UMassNavigationSmoothHeightProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassNavigationSmoothHeightProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\nprivate:\n\tFMassEntityQuery EntityQuery;\n};\n\n/**\n * Initializes the move target's location to the agents initial position.\n */\nUCLASS()\nclass MASSNAVIGATION_API UMassMoveTargetFragmentInitializer : public UMassObserverProcessor\n{\n\tGENERATED_BODY()\npublic:\n\tUMassMoveTargetFragmentInitializer();\n\t\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery InitializerQuery;\n};\n\n/** Processor to update obstacle grid */\nUCLASS()\nclass MASSNAVIGATION_API UMassNavigationObstacleGridProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassNavigationObstacleGridProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\nprivate:\n\tFMassEntityQuery AddToGridEntityQuery;\n\tFMassEntityQuery UpdateGridEntityQuery;\n\tFMassEntityQuery RemoveFromGridEntityQuery;\n};\n\n/** Deinitializer processor to remove avoidance obstacles from the avoidance obstacle grid */\nUCLASS()\nclass MASSNAVIGATION_API UMassNavigationObstacleRemoverProcessor : public UMassObserverProcessor\n{\n\tGENERATED_BODY()\n\n\tUMassNavigationObstacleRemoverProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};\n",
      "lines": 99
    },
    {
      "file_path": "MassAI\\MassNavigation\\Public\\MassNavigationSubsystem.h",
      "extension": ".h",
      "size_bytes": 1454,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"HierarchicalHashGrid2D.h\"\n#include \"MassSubsystemBase.h\"\n#include \"MassNavigationSubsystem.generated.h\"\n\nUENUM()\nenum class EMassNavigationObstacleFlags : uint8\n{\n\tNone\t\t\t= 0,\n\tHasColliderData = 1 << 0,\n};\nENUM_CLASS_FLAGS(EMassNavigationObstacleFlags)\n\nstruct FMassNavigationObstacleItem\n{\n\tbool operator==(const FMassNavigationObstacleItem& Other) const\n\t{\n\t\treturn Entity == Other.Entity;\n\t}\n\n\tFMassEntityHandle Entity;\n\tEMassNavigationObstacleFlags ItemFlags = EMassNavigationObstacleFlags::None;\n};\n\ntypedef THierarchicalHashGrid2D<2, 4, FMassNavigationObstacleItem> FNavigationObstacleHashGrid2D;\t// 2 levels of hierarchy, 4 ratio between levels\n\nUCLASS()\nclass MASSNAVIGATION_API UMassNavigationSubsystem : public UMassSubsystemBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassNavigationSubsystem();\n\n\tconst FNavigationObstacleHashGrid2D& GetObstacleGrid() const { return AvoidanceObstacleGrid; }\n\tFNavigationObstacleHashGrid2D& GetObstacleGridMutable() { return AvoidanceObstacleGrid; }\n\nprotected:\n\t// USubsystem BEGIN\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\t// USubsystem END\n\n\tFNavigationObstacleHashGrid2D AvoidanceObstacleGrid;\n};\n\ntemplate<>\nstruct TMassExternalSubsystemTraits<UMassNavigationSubsystem> final\n{\n\tenum\n\t{\n\t\tGameThreadOnly = false\n\t};\n};\n",
      "lines": 57
    },
    {
      "file_path": "MassAI\\MassNavigation\\Public\\MassNavigationTypes.h",
      "extension": ".h",
      "size_bytes": 1041,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassCommonTypes.h\"\n#include \"RandomSequence.h\"\n#include \"MassNavigationTypes.generated.h\"\n\nMASSNAVIGATION_API DECLARE_LOG_CATEGORY_EXTERN(LogMassNavigation, Warning, All);\nMASSNAVIGATION_API DECLARE_LOG_CATEGORY_EXTERN(LogMassNavigationObstacle, Warning, All);\n\n//@ todo remove optimization hack once we find a better way to filter out signals from LOD/listener on signals, as for now we only need this signal for look at in high and med LOD\n#define HACK_DISABLE_PATH_CHANGED_ON_LOWER_LOD 1\n\nnamespace UE::Mass::Signals\n{\n\tconst FName FollowPointPathStart = FName(TEXT(\"FollowPointPathStart\"));\n\tconst FName FollowPointPathDone = FName(TEXT(\"FollowPointPathDone\"));\n\tconst FName CurrentLaneChanged = FName(TEXT(\"CurrentLaneChanged\"));\n}\n\nUENUM()\nenum class EMassMovementAction : uint8\n{\n\tStand,\t\t// Stop and stand.\n\tMove,\t\t// Move or keep on moving.\n\tAnimate,\t// Animation has control over the transform\n};\n",
      "lines": 29
    },
    {
      "file_path": "MassAI\\MassNavigation\\Public\\MassNavigationUtils.h",
      "extension": ".h",
      "size_bytes": 3704,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreTypes.h\"\n#include \"Math/Quat.h\"\n#include \"Math/UnrealMathUtility.h\"\n\nnamespace UE::MassNavigation\n{\n\t// Calculates yaw angle from direction vector.\n\tinline FQuat::FReal GetYawFromQuat(const FQuat Rotation)\n\t{\n\t\tconst FQuat::FReal YawY = 2. * (Rotation.W * Rotation.Z + Rotation.X * Rotation.Y);\n\t\tconst FQuat::FReal YawX = (1. - 2. * (FMath::Square(Rotation.Y) + FMath::Square(Rotation.Z)));\n\t\treturn FMath::Atan2(YawY, YawX);\n\t}\n\n\tinline FVector::FReal GetYawFromDirection(const FVector Direction)\n\t{\n\t\treturn FMath::Atan2(Direction.Y, Direction.X);\n\t}\n\n\t// Wraps and angle to range -PI..PI. Angle in radians.\n\tinline FVector::FReal WrapAngle(const FVector::FReal Angle)\n\t{\n\t\tFVector::FReal WrappedAngle = FMath::Fmod(Angle, UE_DOUBLE_PI*2.);\n\t\tWrappedAngle = (WrappedAngle > UE_DOUBLE_PI) ? WrappedAngle - UE_DOUBLE_PI * 2. : WrappedAngle;\n\t\tWrappedAngle = (WrappedAngle < -UE_DOUBLE_PI) ? WrappedAngle + UE_DOUBLE_PI * 2. : WrappedAngle;\n\t\treturn WrappedAngle;\n\t}\n\n\t// Linearly interpolates between two angles (in Radians).\n\tinline FVector::FReal LerpAngle(const FVector::FReal AngleA, const FVector::FReal AngleB, const FVector::FReal T)\n\t{\n\t\tconst FVector::FReal DeltaAngle = WrapAngle(AngleB - AngleA);\n\t\treturn AngleA + DeltaAngle * T;\n\t}\n\n\t// Exponential smooth from current angle to target angle. Angles in radians.\n\tinline FVector::FReal ExponentialSmoothingAngle(const FVector::FReal Angle, const FVector::FReal TargetAngle, const FVector::FReal DeltaTime, const FVector::FReal SmoothingTime)\n\t{\n\t\t// Note: based on FMath::ExponentialSmoothingApprox().\n\t\tif (SmoothingTime < KINDA_SMALL_NUMBER)\n\t\t{\n\t\t\treturn TargetAngle;\n\t\t}\n\t\tconst FVector::FReal A = DeltaTime / SmoothingTime;\n\t\tconst FVector::FReal Exp = FMath::InvExpApprox(A);\n\t\treturn TargetAngle + WrapAngle(Angle - TargetAngle) * Exp;\n\t}\n\n\t// Clamps vectors magnitude to Mag.\n\tinline FVector ClampVector(const FVector Vec, const FVector::FReal Mag)\n\t{\n\t\tconst FVector::FReal Len = Vec.SizeSquared();\n\t\tif (Len > FMath::Square(Mag)) {\n\t\t\treturn Vec * Mag / FMath::Sqrt(Len);\n\t\t}\n\t\treturn Vec;\n\t}\n\n\t// Projects a point to segment and returns the time interpolation value.\n\tinline FVector::FReal ProjectPtSeg(const FVector2D Point, const FVector2D Start, const FVector2D End)\n\t{\n\t\tconst FVector2D Seg = End - Start;\n\t\tconst FVector2D Dir = Point - Start;\n\t\tconst FVector::FReal SegSizeSquared = Seg.SizeSquared();\n\t\tconst FVector::FReal SegDirDot = FVector2D::DotProduct(Seg, Dir);\n\n\t\tif (SegDirDot < 0.)\n\t\t{\n\t\t\treturn 0.;\n\t\t}\n\n\t\tif (SegDirDot > SegSizeSquared)\n\t\t{\n\t\t\treturn 1.;\n\t\t}\n\n\t\treturn SegSizeSquared > 0. ? (SegDirDot / SegSizeSquared) : 0.;\n\t}\n\n\t// Returns the SmoothStep curve for X in range [0..1]. \n\tinline float Smooth(const float X)\n\t{\n\t\treturn X * X * (3.f - 2.f * X);\n\t}\n\n\t// Returns the SmoothStep curve for X in range [0..1]. \n\tinline double Smooth(const double X)\n\t{\n\t\treturn X * X * (3. - 2. * X);\n\t}\n\n\t// Returns left direction from forward and up directions.\n\tinline FVector GetLeftDirection(const FVector Forward, const FVector Up)\n\t{\n\t\treturn FVector::CrossProduct(Forward, Up);\n\t}\n\n\t// Computes miter normal in XY plane from two neighbour edge normals.\n\tinline FVector ComputeMiterNormal(const FVector NormalA, const FVector NormalB)\n\t{\n\t\tFVector Mid = 0.5 * (NormalA + NormalB);\n\t\tconst FVector::FReal MidSquared = FVector::DotProduct(Mid, Mid);\n\t\tif (MidSquared > KINDA_SMALL_NUMBER)\n\t\t{\n\t\t\tconst FVector::FReal Scale = FMath::Min(1. / MidSquared, 20.);\n\t\t\tMid *= Scale;\n\t\t}\n\t\treturn Mid;\n\t}\n\t\n} // UE::MassMovement",
      "lines": 115
    },
    {
      "file_path": "MassAI\\MassNavigation\\Public\\Avoidance\\MassAvoidanceFragments.h",
      "extension": ".h",
      "size_bytes": 9078,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassNavigationSubsystem.h\"\n#include \"MassAvoidanceFragments.generated.h\"\n\nUSTRUCT()\nstruct MASSNAVIGATION_API FMassMovingAvoidanceParameters : public FMassConstSharedFragment\n{\n\tGENERATED_BODY()\n\n\tFMassMovingAvoidanceParameters GetValidated() const\n\t{\n\t\tFMassMovingAvoidanceParameters Copy = *this;\n\t\tCopy.PredictiveAvoidanceTime = FMath::Max(Copy.PredictiveAvoidanceTime, KINDA_SMALL_NUMBER);\n\t\tCopy.ObstacleSeparationDistance = FMath::Max(Copy.ObstacleSeparationDistance, KINDA_SMALL_NUMBER);\n\t\tCopy.PredictiveAvoidanceDistance = FMath::Max(Copy.PredictiveAvoidanceDistance, KINDA_SMALL_NUMBER);\n\t\tCopy.EnvironmentSeparationDistance = FMath::Max(Copy.EnvironmentSeparationDistance, KINDA_SMALL_NUMBER);\n\t\tCopy.StartOfPathDuration = FMath::Max(Copy.StartOfPathDuration, KINDA_SMALL_NUMBER);\n\t\tCopy.EndOfPathDuration = FMath::Max(Copy.EndOfPathDuration, KINDA_SMALL_NUMBER);\n\n\t\treturn Copy;\n\t}\n\n\t/** The distance at which neighbour agents are detected. Range: 200...600 */\n\tUPROPERTY(EditAnywhere, Category = \"General\", meta = (ClampMin = \"0.0\", ForceUnits=\"cm\"))\n\tfloat ObstacleDetectionDistance = 400.f;\n\n\t/** The time the agent is considered to be near the start of the path when starting to move. Range: 0..3 */\n\tUPROPERTY(EditAnywhere, Category = \"General\", meta = (ClampMin = \"0\", ForceUnits=\"s\"))\n\tfloat StartOfPathDuration = 1.0f;\n\n\t/** The time the agent is considered to be near the end of the path when approaching end. Range: 0..3 */\n\tUPROPERTY(EditAnywhere, Category = \"General\", meta = (ClampMin = \"0\", ForceUnits=\"s\"))\n\tfloat EndOfPathDuration = 0.5f;\n\n\t/** How much to tune down the avoidance at the start of the path. Range: 0..1. */\n\tUPROPERTY(EditAnywhere, Category = \"General\", meta = (ClampMin = \"0\", ForceUnits=\"x\"))\n\tfloat StartOfPathAvoidanceScale = 0.0f;\n\n\t/** How much to tune down the avoidance towards the end of the path. Range: 0..1 */\n\tUPROPERTY(EditAnywhere, Category = \"General\", meta = (ClampMin = \"0\", ForceUnits=\"x\"))\n\tfloat EndOfPathAvoidanceScale = 0.1f;\n\n\t/** How much to tune down the avoidance when an obstacle is standing. This allows the agents to pass through standing agents more easily. Range: 0..1 */\n\tUPROPERTY(EditAnywhere, Category = \"General\", meta = (ClampMin = \"0\", ForceUnits=\"x\"))\n\tfloat StandingObstacleAvoidanceScale = 0.65f;\n\n\t/** Agent radius scale for avoiding static obstacles near wall. If the clarance between obstacle and wall is less than the scaled radius, the agent will not try to move through the gap. Range: 0..1 */\n\tUPROPERTY(EditAnywhere, Category = \"General\", meta = (ClampMin = \"0\", ForceUnits=\"x\"))\n\tfloat StaticObstacleClearanceScale = 0.7f;\n\n\t/** Agent radius scale for separation. Making it smaller makes the separation softer. Range: 0.8..1 */\n\tUPROPERTY(EditAnywhere, Category = \"Separation\", meta = (ClampMin = \"0\", ForceUnits=\"x\"))\n\tfloat SeparationRadiusScale = 0.9f;\n\n\t/** Separation force stiffness between agents and obstacles. Range: 100..500 N/cm */\n\tUPROPERTY(EditAnywhere, Category = \"Separation\", meta = (ClampMin = \"0\"))\n\tfloat ObstacleSeparationStiffness = 250.f;\n\n\t/** Separation force effect distance. The actual observed separation distance will be smaller. Range: 0..100 */\n\tUPROPERTY(EditAnywhere, Category = \"Separation\", meta = (ClampMin = \"0\", ForceUnits=\"cm\"))\n\tfloat ObstacleSeparationDistance = 75.f;\n\n\t/** Environment separation force stiffness between agents and walls. Range: 200..1000 N/cm */\n\tUPROPERTY(EditAnywhere, Category = \"Separation\", meta = (ClampMin = \"0\"))\n\tfloat EnvironmentSeparationStiffness = 500.f;\n\n\t/** Environment separation force effect distance. The actual observed separation distance will be smaller. Range: 0..200 */\n\tUPROPERTY(EditAnywhere, Category = \"Separation\", meta = (ClampMin = \"0\", ForceUnits=\"cm\"))\n\tfloat EnvironmentSeparationDistance = 50.f;\n\n\t/** How far in the future the agent reacts to collisions. Range: 1..3, Indoor humans 1.4, outdoor humans 2.4 (seconds). */\n\tUPROPERTY(EditAnywhere, Category = \"Predictive Avoidance\", meta = (ClampMin = \"0.1\", ForceUnits=\"s\"))\n\tfloat PredictiveAvoidanceTime = 2.5f;\n\n\t/** Agent radius scale for anticipatory avoidance. Making the scale smaller makes the agent more eager to squeeze through other agents. Range: 0.5..1 */\n\tUPROPERTY(EditAnywhere, Category = \"Predictive Avoidance\", meta = (ClampMin = \"0\", ForceUnits=\"x\"))\n\tfloat PredictiveAvoidanceRadiusScale = 0.65f;\n\t\n\t/** Predictive avoidance force effect distance. The avoidance force is applied at the point in future where the agents are closest. The actual observed separation distance will be smaller. Range: 0..200 */\n\tUPROPERTY(EditAnywhere, Category = \"Predictive Avoidance\", meta = (ClampMin = \"0\", ForceUnits=\"cm\"))\n\tfloat PredictiveAvoidanceDistance = 75.f;\n\n\t/** Predictive avoidance force stiffness between agents and obstacles. Range: 400..1000 N/cm */\n\tUPROPERTY(EditAnywhere, Category = \"Predictive Avoidance\", meta = (ClampMin = \"0\"))\n\tfloat ObstaclePredictiveAvoidanceStiffness = 700.f;\n\n\t/** Predictive avoidance force stiffness between agents and walls. Range: 400..1000 N/cm */\n\tUPROPERTY(EditAnywhere, Category = \"Predictive Avoidance\", meta = (ClampMin = \"0\"))\n\tfloat EnvironmentPredictiveAvoidanceStiffness = 200.f;\n};\n\nUSTRUCT()\nstruct MASSNAVIGATION_API FMassStandingAvoidanceParameters : public FMassConstSharedFragment\n{\n\tGENERATED_BODY()\n\n\tFMassStandingAvoidanceParameters GetValidated() const\n\t{\n\t\tFMassStandingAvoidanceParameters Copy = *this;\n\t\t\n\t\tCopy.GhostSteeringReactionTime = FMath::Max(Copy.GhostSteeringReactionTime, KINDA_SMALL_NUMBER);\n\n\t\treturn Copy;\n\t}\n\n\t/** The distance at which neighbour agents are detected when updating the ghost. */\n\tUPROPERTY(EditAnywhere, Category = \"General\", meta = (ClampMin = \"0.0\", ForceUnits=\"cm\"))\n\tfloat GhostObstacleDetectionDistance = 300.f;\n\n\t/** How far the ghost can deviate from the target location. */\n\tUPROPERTY(EditAnywhere, Category = \"Ghost\", meta = (ClampMin = \"0\", ForceUnits=\"cm\"))\n\tfloat GhostToTargetMaxDeviation = 80.0f;\n\n\t/**  */\n\tUPROPERTY(EditAnywhere, Category = \"Ghost\", meta = (ClampMin = \"0\", ForceUnits=\"s\"))\n\tfloat GhostSteeringReactionTime = 2.0f;\n\n\t/** The steering will slow down when the ghost is closer than this distance to the target. Range: 5..50 */\n\tUPROPERTY(EditAnywhere, Category = \"Ghost\", meta = (ClampMin = \"0\", ForceUnits=\"cm\"))\n\tfloat GhostStandSlowdownRadius = 15.0f;\n\n\t/** Mas speed the ghost can move. */\n\tUPROPERTY(EditAnywhere, Category = \"Ghost\", meta = (ClampMin = \"0\", ForceUnits=\"cm/s\"))\n\tfloat GhostMaxSpeed = 250.0f;\n\n\t/** Max acceleration of the ghost. Making this larger than the agent speed will make the ghost react quickly.  */\n\tUPROPERTY(EditAnywhere, Category = \"Ghost\", meta = (ClampMin = \"0\", ForceUnits=\"cm/s\"))\n\tfloat GhostMaxAcceleration = 300.0f;\n\n\t/** How quickly the ghost speed goes to zero. The smaller the value, the more the movement is dampened. */\n\tUPROPERTY(EditAnywhere, Category = \"Ghost\", meta = (ClampMin = \"0\", ForceUnits=\"s\"))\n\tfloat GhostVelocityDampingTime = 0.4f;\n\n\t/** Agent radius scale for separation. Making it smaller makes the separation softer. Range: 0.8..1 */\n\tUPROPERTY(EditAnywhere, Category = \"Ghost\", meta = (ClampMin = \"0\", ForceUnits=\"x\"))\n\tfloat GhostSeparationRadiusScale = 0.8f;\n\t\n\tUPROPERTY(EditAnywhere, Category = \"Ghost\", meta = (ClampMin = \"0\", ForceUnits=\"cm\"))\n\tfloat GhostSeparationDistance = 20.0f;\n\t\n\tUPROPERTY(EditAnywhere, Category = \"Ghost\", meta = (ClampMin = \"0\", ForceUnits=\"N/cm\"))\n\tfloat GhostSeparationStiffness = 200.0f;\n\n\t/** Much much avoidance is scaled for moving obstacles. Range: 1..5. */\n\tUPROPERTY(EditAnywhere, Category = \"Ghost\", meta = (ClampMin = \"0\", ForceUnits=\"x\"))\n\tfloat MovingObstacleAvoidanceScale = 3.0f;\n\n\t/** How much the ghost avoidance is tuned down when the moving obstacle is moving away from the ghost. Range: 0..1 */\n\tUPROPERTY(EditAnywhere, Category = \"Ghost\", meta = (ClampMin = \"0\", ForceUnits=\"x\"))\n\tfloat MovingObstacleDirectionalScale = 0.1f;\n\n\t/** How much extra space is preserved in front of moving obstacles (relative to their size). Range: 1..5 */\n\tUPROPERTY(EditAnywhere, Category = \"Ghost\", meta = (ClampMin = \"0\", ForceUnits=\"x\"))\n\tfloat MovingObstaclePersonalSpaceScale = 3.0f;\n};\n\n\n/** Edge with normal */\nstruct MASSNAVIGATION_API FNavigationAvoidanceEdge\n{\n\tFNavigationAvoidanceEdge(const FVector InStart, const FVector InEnd)\n\t{\n\t\tStart = InStart;\n\t\tEnd = InEnd;\n\t\tLeftDir = FVector::CrossProduct((End - Start).GetSafeNormal(), FVector::UpVector);\n\t}\n\tFVector Start = FVector::ZeroVector;\n\tFVector End = FVector::ZeroVector;\n\tFVector LeftDir = FVector::ZeroVector;\n};\n\nUSTRUCT()\nstruct MASSNAVIGATION_API FMassNavigationEdgesFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tstatic const int MaxEdgesCount = 8;\n\tTArray<FNavigationAvoidanceEdge, TFixedAllocator<MaxEdgesCount>> AvoidanceEdges;\n};\n",
      "lines": 183
    },
    {
      "file_path": "MassAI\\MassNavigation\\Public\\Avoidance\\MassAvoidanceProcessors.h",
      "extension": ".h",
      "size_bytes": 1639,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessor.h\"\n#include \"MassAvoidanceProcessors.generated.h\"\n\nMASSNAVIGATION_API DECLARE_LOG_CATEGORY_EXTERN(LogAvoidance, Warning, All);\nMASSNAVIGATION_API DECLARE_LOG_CATEGORY_EXTERN(LogAvoidanceVelocities, Warning, All);\nMASSNAVIGATION_API DECLARE_LOG_CATEGORY_EXTERN(LogAvoidanceAgents, Warning, All);\nMASSNAVIGATION_API DECLARE_LOG_CATEGORY_EXTERN(LogAvoidanceObstacles, Warning, All);\n\nclass UMassNavigationSubsystem;\n\n/** Experimental: move using cumulative forces to avoid close agents */\nUCLASS()\nclass MASSNAVIGATION_API UMassMovingAvoidanceProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassMovingAvoidanceProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Initialize(UObject& Owner) override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\nprivate:\n\tTObjectPtr<UWorld> World;\n\tTObjectPtr<UMassNavigationSubsystem> NavigationSubsystem;\n\tFMassEntityQuery EntityQuery;\n};\n\n/** Avoidance while standing. */\nUCLASS()\nclass MASSNAVIGATION_API UMassStandingAvoidanceProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassStandingAvoidanceProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Initialize(UObject& Owner) override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\nprivate:\n\tTObjectPtr<UWorld> World;\n\tTObjectPtr<UMassNavigationSubsystem> NavigationSubsystem;\n\tFMassEntityQuery EntityQuery;\n};\n",
      "lines": 53
    },
    {
      "file_path": "MassAI\\MassNavigation\\Public\\Avoidance\\MassAvoidanceTrait.h",
      "extension": ".h",
      "size_bytes": 660,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassEntityTraitBase.h\"\n#include \"MassAvoidanceFragments.h\"\n#include \"MassAvoidanceTrait.generated.h\"\n\nUCLASS(meta = (DisplayName = \"Avoidance\"))\nclass MASSNAVIGATION_API UMassObstacleAvoidanceTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\t\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\n\tUPROPERTY(EditAnywhere, Category=\"\")\n\tFMassMovingAvoidanceParameters MovingParameters;\n\t\n\tUPROPERTY(EditAnywhere, Category=\"\")\n\tFMassStandingAvoidanceParameters StandingParameters;\n};\n",
      "lines": 23
    },
    {
      "file_path": "MassAI\\MassNavigation\\Public\\Avoidance\\MassNavigationObstacleTrait.h",
      "extension": ".h",
      "size_bytes": 451,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassEntityTraitBase.h\"\n#include \"MassNavigationObstacleTrait.generated.h\"\n\nUCLASS(meta = (DisplayName = \"Navigation Obstacle\"))\nclass MASSNAVIGATION_API UMassNavigationObstacleTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\n};",
      "lines": 16
    },
    {
      "file_path": "MassAI\\MassNavigation\\Public\\SmoothOrientation\\MassSmoothOrientationFragments.h",
      "extension": ".h",
      "size_bytes": 1782,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassCommonTypes.h\"\n#include \"MassSmoothOrientationFragments.generated.h\"\n\n\nUSTRUCT()\nstruct MASSNAVIGATION_API FMassSmoothOrientationWeights : public FMassSharedFragment\n{\n\tGENERATED_BODY()\n\n\tFMassSmoothOrientationWeights() = default;\n\n\tFMassSmoothOrientationWeights(const float InMoveTargetWeight, const float InVelocityWeight)\n\t\t: MoveTargetWeight(InMoveTargetWeight)\n\t\t, VelocityWeight(InVelocityWeight)\n\t{\n\t}\n\t\n\tUPROPERTY(EditAnywhere, Category = \"Orientation\", meta = (ClampMin = \"0.0\", ClampMax=\"1.0\"))\n\tfloat MoveTargetWeight = 0.0f;\n\n\tUPROPERTY(EditAnywhere, Category = \"Orientation\", meta = (ClampMin = \"0.0\", ClampMax=\"1.0\"))\n\tfloat VelocityWeight = 0.0f;\n};\n\nUSTRUCT()\nstruct MASSNAVIGATION_API FMassSmoothOrientationParameters : public FMassConstSharedFragment\n{\n\tGENERATED_BODY()\n\n\t/** The time it takes the orientation to catchup to the requested orientation. */\n\tUPROPERTY(EditAnywhere, Category = \"Orientation\", meta = (ClampMin = \"0.0\", ForceUnits=\"s\"))\n\tfloat EndOfPathDuration = 1.0f;\n\t\n\t/** The time it takes the orientation to catchup to the requested orientation. */\n\tUPROPERTY(EditAnywhere, Category = \"Orientation\", meta = (ClampMin = \"0.0\", ForceUnits=\"s\"))\n\tfloat OrientationSmoothingTime = 0.3f;\n\n\t/* Orientation blending weights while moving. */\t\n\tUPROPERTY(EditAnywhere, Category = \"Orientation\")\n\tFMassSmoothOrientationWeights Moving = FMassSmoothOrientationWeights(/*MoveTarget*/0.4f, /*Velocity*/0.6f);\n\n\t/* Orientation blending weights while standing. */\t\n\tUPROPERTY(EditAnywhere, Category = \"Orientation\")\n\tFMassSmoothOrientationWeights Standing = FMassSmoothOrientationWeights(/*MoveTarget*/0.95f, /*Velocity*/0.05f);\n};",
      "lines": 49
    },
    {
      "file_path": "MassAI\\MassNavigation\\Public\\SmoothOrientation\\MassSmoothOrientationProcessors.h",
      "extension": ".h",
      "size_bytes": 653,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessor.h\"\n#include \"MassSmoothOrientationProcessors.generated.h\"\n\n/**\n * Updates agent's orientation based on current movement.\n */\nUCLASS()\nclass MASSNAVIGATION_API UMassSmoothOrientationProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassSmoothOrientationProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\nprivate:\n\tFMassEntityQuery HighResEntityQuery;\n\tFMassEntityQuery LowResEntityQuery_Conditional;\n};\n",
      "lines": 26
    },
    {
      "file_path": "MassAI\\MassNavigation\\Public\\SmoothOrientation\\MassSmoothOrientationTrait.h",
      "extension": ".h",
      "size_bytes": 585,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassEntityTraitBase.h\"\n#include \"MassSmoothOrientationFragments.h\"\n#include \"MassSmoothOrientationTrait.generated.h\"\n\nUCLASS(meta = (DisplayName = \"Smooth Orientation\"))\nclass MASSNAVIGATION_API UMassSmoothOrientationTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\n\tUPROPERTY(EditAnywhere, Category=\"\")\n\tFMassSmoothOrientationParameters Orientation;\n};\n",
      "lines": 19
    },
    {
      "file_path": "MassAI\\MassNavigation\\Public\\Steering\\MassSteeringFragments.h",
      "extension": ".h",
      "size_bytes": 3253,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassSteeringFragments.generated.h\"\n\nclass UWorld;\n\n/** Steering fragment. */\nUSTRUCT()\nstruct MASSNAVIGATION_API FMassSteeringFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tvoid Reset()\n\t{\n\t\tDesiredVelocity = FVector::ZeroVector;\n\t}\n\n\t/** Cached desired velocity from steering. Note: not used for moving the entity. */\n\tFVector DesiredVelocity = FVector::ZeroVector;\n};\n\n/** Standing steering. */\nUSTRUCT()\nstruct MASSNAVIGATION_API FMassStandingSteeringFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\t/** Selected steer target based on ghost, updates periodically. */\n\tFVector TargetLocation = FVector::ZeroVector;\n\n\t/** Used during target update to see when the target movement stops */\n\tfloat TrackedTargetSpeed = 0.0f;\n\n\t/** Cooldown between target updates */\n\tfloat TargetSelectionCooldown = 0.0f;\n\n\t/** True if the target is being updated */\n\tbool bIsUpdatingTarget = false;\n\n\t/** True if we just entered from move action */\n\tbool bEnteredFromMoveAction = false;\n};\n\n\n/** Steering related movement parameters. */\nUSTRUCT()\nstruct MASSNAVIGATION_API FMassMovingSteeringParameters : public FMassConstSharedFragment\n{\n\tGENERATED_BODY()\n\n\t/** Steering reaction time in seconds. */\n\tUPROPERTY(config, EditAnywhere, Category = \"Moving\", meta = (ClampMin = \"0.05\", ForceUnits=\"s\"))\n\tfloat ReactionTime = 0.3f;\n\n\t/** How much we look ahead when steering. Affects how steeply we steer towards the goal and when to start to slow down at the end of the path. */\n\tUPROPERTY(EditAnywhere, Category = \"Moving\", meta = (ClampMin = \"0\", ForceUnits=\"s\"))\n\tfloat LookAheadTime = 1.0f;\n};\n\nUSTRUCT()\nstruct FMassStandingSteeringParameters : public FMassConstSharedFragment\n{\n\tGENERATED_BODY()\n\n\t/** Steering reaction time in seconds. */\n\tUPROPERTY(EditAnywhere, Category = \"Standing\", meta = (ClampMin = \"0.05\", ForceUnits=\"s\"))\n\tfloat ReactionTime = 0.3f;\n\n\t/** How much the target should deviate from the ghost location before update */\n\tUPROPERTY(EditAnywhere, Category = \"Standing\", meta = (ClampMin = \"0.05\", ForceUnits=\"cm\"))\n\tfloat TargetMoveThreshold = 15.0f;\n\t\n\tUPROPERTY(EditAnywhere, Category = \"Standing\")\n\tfloat TargetMoveThresholdVariance = 0.1f;\n\n\t/** If the velocity is below this threshold, it is clamped to 0. This allows to prevent jittery movement when trying to be stationary. */\n\tUPROPERTY(EditAnywhere, Category = \"Movement\", meta = (ClampMin = \"0.0\", ForceUnits=\"cm/s\"))\n\tfloat LowSpeedThreshold = 3.0f;\n\n\t/** How much the max speed can drop before we stop tracking it. */\n\tUPROPERTY(EditAnywhere, Category = \"Standing\", meta = (ClampMin = \"0.05\", ForceUnits=\"x\"))\n\tfloat TargetSpeedHysteresisScale = 0.85f;\n\n\t/** Time between updates, varied randomly. */\n\tUPROPERTY(EditAnywhere, Category = \"Standing\", meta = (ClampMin = \"0.05\", ForceUnits=\"s\"))\n\tfloat TargetSelectionCooldown = 1.5f;\n\t\n\tUPROPERTY(EditAnywhere, Category = \"Standing\")\n\tfloat TargetSelectionCooldownVariance = 0.5f;\n\n\tUPROPERTY(EditAnywhere, Category = \"Standing\", meta = (ForceUnits=\"cm\"))\n\tfloat DeadZoneRadius = 15.0f;\n};\n",
      "lines": 97
    },
    {
      "file_path": "MassAI\\MassNavigation\\Public\\Steering\\MassSteeringProcessors.h",
      "extension": ".h",
      "size_bytes": 601,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessor.h\"\n#include \"MassObserverProcessor.h\"\n#include \"MassSteeringProcessors.generated.h\"\n\n/** \n* Processor for updating steering towards MoveTarget.\n*/\nUCLASS()\nclass MASSNAVIGATION_API UMassSteerToMoveTargetProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\nprotected:\n\tUMassSteerToMoveTargetProcessor();\n\t\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};\n",
      "lines": 24
    },
    {
      "file_path": "MassAI\\MassNavigation\\Public\\Steering\\MassSteeringTrait.h",
      "extension": ".h",
      "size_bytes": 706,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassEntityTraitBase.h\"\n#include \"Steering/MassSteeringFragments.h\"\n#include \"MassSteeringTrait.generated.h\"\n\n\nUCLASS(meta = (DisplayName = \"Steering\"))\nclass MASSNAVIGATION_API UMassSteeringTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\n\tUPROPERTY(Category=\"Steering\", EditAnywhere, meta=(EditInline))\n\tFMassMovingSteeringParameters MovingSteering;\n\n\tUPROPERTY(Category=\"Steering\", EditAnywhere, meta=(EditInline))\n\tFMassStandingSteeringParameters StandingSteering;\n};\n",
      "lines": 23
    },
    {
      "file_path": "MassAI\\MassNavigationEditor\\Private\\MassNavigationTestingActor.h",
      "extension": ".h",
      "size_bytes": 3678,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"GameFramework/Actor.h\"\n#include \"Debug/DebugDrawComponent.h\"\n#include \"DebugRenderSceneProxy.h\"\n#include \"ZoneGraphTypes.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"MassNavigationTestingActor.generated.h\"\n\nclass AZoneGraphData;\nclass UZoneGraphTestingComponent;\nclass UZoneGraphSubsystem;\nclass AMassNavigationTestingActor;\n\n#if UE_ENABLE_DEBUG_DRAWING\nclass MASSNAVIGATIONEDITOR_API FMassNavigationTestingSceneProxy final : public FDebugRenderSceneProxy\n{\npublic:\n\tFMassNavigationTestingSceneProxy(const UPrimitiveComponent& InComponent);\n\t\n\tvirtual SIZE_T GetTypeHash() const override;\n\tvirtual FPrimitiveViewRelevance GetViewRelevance(const FSceneView* View) const override;\n\tvirtual uint32 GetMemoryFootprint(void) const override;\n};\n#endif // UE_ENABLE_DEBUG_DRAWING\n\n/** Component for testing MassMovement functionality. */\nUCLASS(ClassGroup = Debug)\nclass MASSNAVIGATIONEDITOR_API UMassNavigationTestingComponent : public UDebugDrawComponent\n{\n\tGENERATED_BODY()\npublic:\n\tUMassNavigationTestingComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());\n\n#if WITH_EDITOR\n\tvirtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;\n#endif // WITH_EDITOR\n\n\tvirtual void OnRegister() override;\n\tvirtual void OnUnregister() override;\n\n\tvirtual FBoxSphereBounds CalcBounds(const FTransform& LocalToWorld) const override;\n\n#if UE_ENABLE_DEBUG_DRAWING\n\tvirtual FDebugRenderSceneProxy* CreateDebugSceneProxy() override;\n#endif\n\n\tvoid UpdateTests();\n\tvoid PinLane();\n\tvoid ClearPinnedLane();\n\nprotected:\n\n#if WITH_EDITOR\n\tvoid OnZoneGraphDataBuildDone(const struct FZoneGraphBuildData& BuildData);\n#endif\n\tvoid OnZoneGraphDataChanged(const AZoneGraphData* ZoneGraphData);\n\n#if WITH_EDITOR\n\tFDelegateHandle OnDataChangedHandle;\n#endif\n\tFDelegateHandle OnDataAddedHandle;\n\tFDelegateHandle OnDataRemovedHandle;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<UZoneGraphSubsystem> ZoneGraph;\n\n\tUPROPERTY(Transient)\n\tFZoneGraphLaneLocation LaneLocation;\n\n\tUPROPERTY(Transient)\n\tFZoneGraphLaneLocation GoalLaneLocation;\n\n\tUPROPERTY(EditAnywhere, Category = Default);\n\tFVector SearchExtent;\n\n\tUPROPERTY(EditAnywhere, Category = Default);\n\tfloat AnticipationDistance = 50.0f;\n\n\tUPROPERTY(EditAnywhere, Category = Default);\n\tfloat AgentRadius = 40.0f;\n\n\tUPROPERTY(EditAnywhere, Category = Default);\n\tbool bHasSpecificEndPoint = true;\n\n\tUPROPERTY(EditAnywhere, Category = Default);\n\tFZoneGraphTagFilter QueryFilter;\n\n\tUPROPERTY(EditAnywhere, Category = Default, meta = (MakeEditWidget=true))\n\tFVector GoalPosition;\n\n\tFZoneGraphLaneHandle PinnedLane;\n\t\n\tFMassZoneGraphCachedLaneFragment CachedLane;\n\tTArray<FMassZoneGraphShortPathFragment> ShortPaths;\n};\n\n/** Debug actor to visually test zone graph. */\nUCLASS(hidecategories = (Actor, Input, Collision, Rendering, Replication, Partition, HLOD, Cooking))\nclass MASSNAVIGATIONEDITOR_API AMassNavigationTestingActor : public AActor\n{\n\tGENERATED_BODY()\npublic:\n\tAMassNavigationTestingActor(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());\n\n#if WITH_EDITOR\n\tvirtual void PostEditMove(bool bFinished) override;\n#endif // WITH_EDITOR\n\n\tUFUNCTION(BlueprintCallable, CallInEditor, Category = \"Default\")\n\tvoid PinLane();\n\t\n\tUFUNCTION(BlueprintCallable, CallInEditor, Category = \"Default\")\n\tvoid ClearPinnedLane();\n\nprotected:\n\tUPROPERTY(Category = Default, VisibleAnywhere, meta = (AllowPrivateAccess = \"true\"))\n\tTObjectPtr<UMassNavigationTestingComponent> DebugComp;\n};\n",
      "lines": 121
    },
    {
      "file_path": "MassAI\\MassNavigationEditor\\Public\\IMassNavigationEditor.h",
      "extension": ".h",
      "size_bytes": 292,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Toolkits/AssetEditorToolkit.h\"\n\n/** MassNavigation Editor public interface */\nclass MASSNAVIGATIONEDITOR_API IMassNavigationEditor : public FAssetEditorToolkit\n{\npublic:\n\n};\n\n\n",
      "lines": 15
    },
    {
      "file_path": "MassAI\\MassNavigationEditor\\Public\\MassNavigationEditorModule.h",
      "extension": ".h",
      "size_bytes": 532,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma  once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleManager.h\"\n#include \"AssetTypeCategories.h\"\n#include \"Toolkits/IToolkitHost.h\"\n#include \"Toolkits/AssetEditorToolkit.h\"\n\n\nclass IMassNavigationEditor;\n\nclass MASSNAVIGATIONEDITOR_API FMassNavigationEditorModule : public IModuleInterface\n{\npublic:\n\t// Begin IModuleInterface\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n\t// End IModuleInterface\n\nprivate:\n};\n",
      "lines": 23
    },
    {
      "file_path": "MassAI\\MassZoneGraphNavigation\\Public\\IMassZoneGraphNavigationModule.h",
      "extension": ".h",
      "size_bytes": 1169,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n* The public interface to this module.  In most cases, this interface is only public to sibling modules \n* within this plugin.\n*/\nclass IMassZoneGraphNavigationModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t* Singleton-like access to this module's interface.  This is just for convenience!\n\t* Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t*\n\t* @return Returns singleton instance, loading the module on demand if needed\n\t*/\n\tstatic inline IMassZoneGraphNavigationModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassZoneGraphNavigationModule>( \"MassZoneGraphNavigation\" );\n\t}\n\n\t/**\n\t* Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t*\n\t* @return True if the module is loaded and ready to use\n\t*/\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassZoneGraphNavigation\" );\n\t}\n};\n\n",
      "lines": 40
    },
    {
      "file_path": "MassAI\\MassZoneGraphNavigation\\Public\\MassZoneGraphNavigationFragments.h",
      "extension": ".h",
      "size_bytes": 9051,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"ZoneGraphTypes.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassZoneGraphNavigationTypes.h\"\n#include \"Containers/StaticArray.h\"\n#include \"MassZoneGraphNavigationFragments.generated.h\"\n\n\nUSTRUCT()\nstruct MASSZONEGRAPHNAVIGATION_API FMassZoneGraphNavigationParameters : public FMassConstSharedFragment\n{\n\tGENERATED_BODY()\n\n\t/** Filter describing which lanes can be used when spawned. */\n\tUPROPERTY(EditAnywhere, Category=\"Navigation\")\n\tFZoneGraphTagFilter LaneFilter;\n\n\t/** Query radius when trying to find nearest lane when spawned. */\n\tUPROPERTY(EditAnywhere, Category=\"Navigation\", meta = (UIMin = 0.0, ClampMin = 0.0, ForceUnits=\"cm\"))\n\tfloat QueryRadius = 500.0f;\n};\n\n\n/** Stores path request associated to a new movement action. This is used to replicate actions. */\nUSTRUCT()\nstruct MASSZONEGRAPHNAVIGATION_API FMassZoneGraphPathRequestFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\t/** Short path request Handle to current lane. */\n\tUPROPERTY(Transient)\n\tFZoneGraphShortPathRequest PathRequest;\n};\n\n/** Describes current location on ZoneGraph */ \nUSTRUCT()\nstruct MASSZONEGRAPHNAVIGATION_API FMassZoneGraphLaneLocationFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\t/** Handle to current lane. */\n\tFZoneGraphLaneHandle LaneHandle;\n\t\n\t/** Distance along current lane. */\n\tfloat DistanceAlongLane = 0.0f;\n\t\n\t/** Cached lane length, used for clamping and testing if at end of lane. */\n\tfloat LaneLength = 0.0f;\n};\n\n/** Describes part of a ZoneGraph lane. */\nUSTRUCT()\nstruct MASSZONEGRAPHNAVIGATION_API FMassZoneGraphCachedLaneFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tstatic constexpr uint8 MaxPoints = 5;\n\n\tvoid Reset()\n\t{\n\t\tLaneHandle.Reset();\n\t\tLaneLength = 0.0f;\n\t\tLaneWidth = FMassInt16Real(0.0f);\n\t\tNumPoints = 0;\n\t}\n\n\t/** Caches portion of a lane from ZoneGraph. */\n\tvoid CacheLaneData(const FZoneGraphStorage& ZoneGraphStorage, const FZoneGraphLaneHandle CurrentLaneHandle,\n\t\t\t\t\t   const float CurrentDistanceAlongLane, const float TargetDistanceAlongLane, const float InflateDistance);\n\n\tint32 FindSegmentIndexAtDistance(const float DistanceAlongPath) const\n\t{\n\t\tint32 SegmentIndex = 0;\n\t\twhile (SegmentIndex < ((int32)NumPoints - 2))\n\t\t{\n\t\t\tif (DistanceAlongPath < LanePointProgressions[SegmentIndex + 1].Get())\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSegmentIndex++;\n\t\t}\n\n\t\treturn SegmentIndex;\n\t}\n\n\tfloat GetInterpolationTimeOnSegment(const int32 SegmentIndex, const float DistanceAlongPath) const\n\t{\n\t\tcheck(SegmentIndex >= 0 && SegmentIndex <= (int32)NumPoints - 2);\n\t\tconst float StartDistance = LanePointProgressions[SegmentIndex].Get();\n\t\tconst float EndDistance = LanePointProgressions[SegmentIndex + 1].Get();\n\t\tconst float SegLength = EndDistance - StartDistance;\n\t\tconst float InvSegLength = SegLength > KINDA_SMALL_NUMBER ? 1.0f / SegLength : 0.0f;\n\t\treturn FMath::Clamp((DistanceAlongPath - StartDistance) * InvSegLength, 0.0f, 1.0f);\n\t}\n\t\n\tvoid InterpolatePointAndTangentOnSegment(const int32 SegmentIndex, const float DistanceAlongPath, FVector& OutPoint, FVector& OutTangent) const\n\t{\n\t\tconst float T = GetInterpolationTimeOnSegment(SegmentIndex, DistanceAlongPath);\n\t\tOutPoint = FMath::Lerp(LanePoints[SegmentIndex], LanePoints[SegmentIndex + 1], T);\n\t\tOutTangent = FVector(FMath::Lerp(LaneTangentVectors[SegmentIndex].Get(), LaneTangentVectors[SegmentIndex + 1].Get(), T), 0.0f);\n\t}\n\n\tFVector InterpolatePointOnSegment(const int32 SegmentIndex, const float DistanceAlongPath) const\n\t{\n\t\tconst float T = GetInterpolationTimeOnSegment(SegmentIndex, DistanceAlongPath);\n\t\treturn FMath::Lerp(LanePoints[SegmentIndex], LanePoints[SegmentIndex + 1], T);\n\t}\n\n\tvoid GetPointAndTangentAtDistance(const float DistanceAlongPath, FVector& OutPoint, FVector& OutTangent) const\n\t{\n\t\tif (NumPoints == 0)\n\t\t{\n\t\t\tOutPoint = FVector::ZeroVector;\n\t\t\tOutTangent = FVector::ForwardVector;\n\t\t\treturn;\n\t\t}\n\t\tif (NumPoints == 1)\n\t\t{\n\t\t\tOutPoint = LanePoints[0];\n\t\t\tOutTangent = FVector(LaneTangentVectors[0].Get(), 0.0f);\n\t\t\treturn;\n\t\t}\n\n\t\tconst int32 SegmentIndex = FindSegmentIndexAtDistance(DistanceAlongPath);\n\t\tInterpolatePointAndTangentOnSegment(SegmentIndex, DistanceAlongPath, OutPoint, OutTangent);\n\t}\n\n\tFVector GetPointAtDistance(const float DistanceAlongPath) const\n\t{\n\t\tif (NumPoints == 0)\n\t\t{\n\t\t\treturn FVector::ZeroVector;\n\t\t}\n\t\tif (NumPoints == 1)\n\t\t{\n\t\t\treturn LanePoints[0];\n\t\t}\n\n\t\tconst int32 SegmentIndex = FindSegmentIndexAtDistance(DistanceAlongPath);\n\t\treturn InterpolatePointOnSegment(SegmentIndex, DistanceAlongPath);\n\t}\n\n\tbool IsDistanceAtLaneExtrema(const float Distance) const\n\t{\n\t\tstatic constexpr float Epsilon = 0.1f;\n\t\treturn Distance <= Epsilon || (Distance - LaneLength) >= -Epsilon;\n\t}\n\n\tFZoneGraphLaneHandle LaneHandle;\n\t\n\t/** Lane points */\n\tTStaticArray<FVector, MaxPoints> LanePoints;\n\n\t/** Cached length of the lane. */\n\tfloat LaneLength = 0.0f;\n\n\t/** Lane tangents */\n\tTStaticArray<FMassSnorm8Vector2D, MaxPoints> LaneTangentVectors;\n\n\t/** lane Advance distances */\n\tTStaticArray<FMassInt16Real10, MaxPoints> LanePointProgressions;\n\n\t/** Cached width of the lane. */\n\tFMassInt16Real LaneWidth = FMassInt16Real(0.0f);\n\n\t/** Additional space left of the lane */\n\tFMassInt16Real LaneLeftSpace = FMassInt16Real(0.0f);\n\n\t/** Additional space right of the lane */\n\tFMassInt16Real LaneRightSpace = FMassInt16Real(0.0f);\n\n\t/** ID incremented each time the cache is updated. */\n\tuint16 CacheID = 0;\n\t\n\t/** Number of points on path. */\n\tuint8 NumPoints = 0;\n};\n\nUSTRUCT()\nstruct MASSZONEGRAPHNAVIGATION_API FMassZoneGraphPathPoint\n{\n\tGENERATED_BODY()\n\n\t/** Position of the path. */\n\tFVector Position = FVector::ZeroVector;\n\n\t/** Tangent direction of the path. */\n\tFMassSnorm8Vector2D Tangent;\n\n\t/** Position of the point along the original path. (Could potentially be uint16 at 10cm accuracy) */\n\tFMassInt16Real10 DistanceAlongLane = FMassInt16Real10(0.0f);\n\n\t/** Distance along the offset path from first point. (Could potentially be uint16 at 10cm accuracy) */\n\tFMassInt16Real Distance = FMassInt16Real(0.0f);\n\n\t/** True if this point is assumed to be off lane. */\n\tuint8 bOffLane : 1;\n\n\t/** True if this point is lane start or end point. */\n\tuint8 bIsLaneExtrema : 1;\n};\n\n/** Describes short path along ZoneGraph */\n// @todo MassMovement: it should be possible to prune this down to 64bytes\n// - remove debug lane handle, and replace other with index\n// - see if we can remove move tangent?\nUSTRUCT()\nstruct MASSZONEGRAPHNAVIGATION_API FMassZoneGraphShortPathFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tFMassZoneGraphShortPathFragment() = default;\n\t\n\tstatic constexpr uint8 MaxPoints = 3;\n\n\tvoid Reset()\n\t{\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\tDebugLaneHandle.Reset();\n#endif\n\t\tNextLaneHandle.Reset();\n\t\tNextExitLinkType = EZoneLaneLinkType::None;\n\t\tProgressDistance = 0.0f;\n\t\tNumPoints = 0;\n\t\tbMoveReverse = false;\n\t\tEndOfPathIntent = EMassMovementAction::Stand;\n\t\tbPartialResult = false;\n\t\tbDone = false;\n\t}\n\n\t/** Requests path along the current lane */\n\tbool RequestPath(const FMassZoneGraphCachedLaneFragment& CachedLane, const FZoneGraphShortPathRequest& Request, const float CurrentDistanceAlongLane, const float AgentRadius);\n\n\t/** Requests path to stand at current position. */\n\tbool RequestStand(const FMassZoneGraphCachedLaneFragment& CachedLane, const float CurrentDistanceAlongLane, const FVector& CurrentPosition);\n\t\n\tbool IsDone() const\n\t{\n\t\t// @todo MassMovement: should we remove NumPoints == 0? The logic used to be quite different when it was really needed.\n\t\treturn NumPoints == 0 || bDone;\n\t}\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\t/** Current lane handle, for debug */\n\tFZoneGraphLaneHandle DebugLaneHandle;\n#endif\n\t\n\t/** If valid, the this lane will be set as current lane after the path follow is completed. */\n\tFZoneGraphLaneHandle NextLaneHandle;\n\t\n\t/** Current progress distance along the lane. */\n\tfloat ProgressDistance = 0.0f;\n\t\n\t/** Path points */\n\tTStaticArray<FMassZoneGraphPathPoint, MaxPoints> Points;\n\n\t/** If next lane is set, this is how to reach the lane from current lane. */\n\tEZoneLaneLinkType NextExitLinkType = EZoneLaneLinkType::None;\n\t\n\t/** Number of points on path. */\n\tuint8 NumPoints = 0;\n\t\n\t/** Intent at the end of the path. */\n\tEMassMovementAction EndOfPathIntent = EMassMovementAction::Stand;\n\n\t/** True if we're moving reverse */\n\tuint8 bMoveReverse : 1;\n\n\t/** True if the path was partial. */\n\tuint8 bPartialResult : 1;\n\n\t/** True when path follow is completed. */\n\tuint8 bDone : 1;\n};\n\nUSTRUCT()\nstruct MASSZONEGRAPHNAVIGATION_API FMassLaneCacheBoundaryFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\t/** Last update position. */\n\tFVector LastUpdatePosition = FVector::ZeroVector;\n\n\t/** Lane cached ID at last update. */\n\tuint16 LastUpdateCacheID = 0;\n};\n",
      "lines": 290
    },
    {
      "file_path": "MassAI\\MassZoneGraphNavigation\\Public\\MassZoneGraphNavigationProcessors.h",
      "extension": ".h",
      "size_bytes": 1845,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessor.h\"\n#include \"MassObserverProcessor.h\"\n#include \"MassZoneGraphNavigationProcessors.generated.h\"\n\nclass UMassSignalSubsystem;\n\n\n/**\n * Processor for initializing nearest location on ZoneGraph.\n */\nUCLASS()\nclass MASSZONEGRAPHNAVIGATION_API UMassZoneGraphLocationInitializer : public UMassObserverProcessor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tUMassZoneGraphLocationInitializer();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};\n\n/** \n * Processor for updating move target on ZoneGraph path.\n */\nUCLASS()\nclass MASSZONEGRAPHNAVIGATION_API UMassZoneGraphPathFollowProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\nprotected:\n\tUMassZoneGraphPathFollowProcessor();\n\t\n\tvirtual void Initialize(UObject& Owner) override;\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery_Conditional;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<UMassSignalSubsystem> SignalSubsystem = nullptr;\n};\n\n/** ZoneGraph lane cache boundary processor */\n// @todo MassMovement: Make this signal based.\nUCLASS()\nclass MASSZONEGRAPHNAVIGATION_API UMassZoneGraphLaneCacheBoundaryProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassZoneGraphLaneCacheBoundaryProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Initialize(UObject& Owner) override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\nprivate:\n\tTWeakObjectPtr<UWorld> WeakWorld;\n\tFMassEntityQuery EntityQuery;\n};\n",
      "lines": 69
    },
    {
      "file_path": "MassAI\\MassZoneGraphNavigation\\Public\\MassZoneGraphNavigationTrait.h",
      "extension": ".h",
      "size_bytes": 623,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassEntityTraitBase.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"MassZoneGraphNavigationTrait.generated.h\"\n\n\nUCLASS(meta = (DisplayName = \"ZoneGraph Navigation\"))\nclass MASSZONEGRAPHNAVIGATION_API UMassZoneGraphNavigationTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\n\tUPROPERTY(Category=\"Movement\", EditAnywhere)\n\tFMassZoneGraphNavigationParameters NavigationParameters;\n};\n",
      "lines": 20
    },
    {
      "file_path": "MassAI\\MassZoneGraphNavigation\\Public\\MassZoneGraphNavigationTypes.h",
      "extension": ".h",
      "size_bytes": 2620,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassCommonTypes.h\"\n#include \"MassNavigationTypes.h\"\n#include \"ZoneGraphTypes.h\"\n#include \"MassZoneGraphNavigationTypes.generated.h\"\n\n/** Describes path request along one ZoneGraph lane. If the NextLaneHandle is set, lane is changed when path finishes. */\nUSTRUCT()\nstruct MASSZONEGRAPHNAVIGATION_API FZoneGraphShortPathRequest\n{\n\tGENERATED_BODY()\n\n\tFZoneGraphShortPathRequest()\n\t\t: bMoveReverse(false)\n\t\t, bIsEndOfPathPositionSet(false)\n\t\t, bIsEndOfPathDirectionSet(false)\n\t{\n\t}\n\n\tFString ToString() const\n\t{\n\t\treturn FString::Printf(TEXT(\"%s to distance %.1f Next lane: %s of type %s. End of path intent:%s\"),\n\t\t\tbMoveReverse ? TEXT(\"forward\") : TEXT(\"reverse\"), TargetDistance,\n\t\t\tNextLaneHandle.IsValid() ? *NextLaneHandle.ToString() : TEXT(\"unset\"),\n\t\t\tNextLaneHandle.IsValid() ? *UEnum::GetValueAsString(NextExitLinkType) : TEXT(\"Unset\"),\n\t\t\t*UEnum::GetValueAsString(EndOfPathIntent));\n\t}\n\n\t/** Position used as the start of the path*/\n\tUPROPERTY(Transient)\n\tFVector StartPosition = FVector::ZeroVector;\n\n\t/** Optional specific point at the end of the path. */\n\tUPROPERTY(Transient)\n\tFVector EndOfPathPosition = FVector::ZeroVector;\n\n\t/** If set, the lane will be switched when path finishes. */\n\tUPROPERTY(Transient)\n\tFZoneGraphLaneHandle NextLaneHandle;\n\n\t/** Distance to move. */\n\tUPROPERTY(Transient)\n\tfloat TargetDistance = 0.0f;\n\n\t/** Optional specific direction at the end of the path. Used only if EndOfPathPosition is set. */\n\tUPROPERTY(Transient)\n\tFMassSnorm8Vector EndOfPathDirection;\n\n\t/** If start or end of path is off-lane, the distance along the lane is pushed forward/back along the lane to make smoother transition. */\n\tUPROPERTY(Transient)\n\tFMassInt16Real AnticipationDistance = FMassInt16Real(50.f);\n\n\tUPROPERTY(Transient)\n\tFMassInt16Real EndOfPathOffset = FMassInt16Real(0.0f);\n\n\t/** Movement intent at the end of the path. */\n\tUPROPERTY(Transient)\n\tEMassMovementAction EndOfPathIntent = EMassMovementAction::Stand;\n\n\t/** How the NextLaneHandle links to current lane. */\n\tUPROPERTY(Transient)\n\tEZoneLaneLinkType NextExitLinkType = EZoneLaneLinkType::None;\n\n\t/** If true, move backwards along the lane. */\n\tUPROPERTY(Transient)\n\tuint8 bMoveReverse : 1;\n\n\t/** Indicates if the optional end of path position is set. */\n\tUPROPERTY(Transient)\n\tuint8 bIsEndOfPathPositionSet : 1;\n\n\t/** Indicates if the optional end of path direction is set. Used only if EndOfPathPosition is set. */\n\tUPROPERTY(Transient)\n\tuint8 bIsEndOfPathDirectionSet : 1;\n};\n",
      "lines": 78
    },
    {
      "file_path": "MassAI\\MassZoneGraphNavigation\\Public\\MassZoneGraphNavigationUtils.h",
      "extension": ".h",
      "size_bytes": 1790,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n\nstruct FZoneGraphShortPathRequest;\nstruct FMassZoneGraphCachedLaneFragment;\nstruct FMassZoneGraphShortPathFragment;\nstruct FMassMoveTargetFragment;\nstruct FMassZoneGraphPathRequestFragment;\nstruct FMassZoneGraphLaneLocationFragment;\nclass UMassSignalSubsystem;\nclass UZoneGraphSubsystem;\nclass UZoneGraphAnnotationSubsystem;\n\nnamespace UE::MassNavigation\n{\n\tMASSZONEGRAPHNAVIGATION_API bool ActivateActionMove(const UWorld& World,\n\t\t\t\t\t\t\t\t\t\t\t const UObject* Requester,\n\t\t\t\t\t\t\t\t\t\t\t const FMassEntityHandle Entity,\n\t\t\t\t\t\t\t\t\t\t\t const UZoneGraphSubsystem& ZoneGraphSubsystem,\n\t\t\t\t\t\t\t\t\t\t\t const FMassZoneGraphLaneLocationFragment& LaneLocation,\n\t\t\t\t\t\t\t\t\t\t\t const FZoneGraphShortPathRequest& PathRequest,\n\t\t\t\t\t\t\t\t\t\t\t const float AgentRadius,\n\t\t\t\t\t\t\t\t\t\t\t const float DesiredSpeed,\n\t\t\t\t\t\t\t\t\t\t\t FMassMoveTargetFragment& MoveTarget,\n\t\t\t\t\t\t\t\t\t\t\t FMassZoneGraphShortPathFragment& ShortPath,\n\t\t\t\t\t\t\t\t\t\t\t FMassZoneGraphCachedLaneFragment& CachedLane);\n\n\tMASSZONEGRAPHNAVIGATION_API bool ActivateActionStand(const UWorld& World,\n\t\t\t\t\t\t\t\t\t\t\t  const UObject* Requester,\n\t\t\t\t\t\t\t\t\t\t\t  const FMassEntityHandle Entity,\n\t\t\t\t\t\t\t\t\t\t\t  const UZoneGraphSubsystem& ZoneGraphSubsystem,\n\t\t\t\t\t\t\t\t\t\t\t  const FMassZoneGraphLaneLocationFragment& LaneLocation,\n\t\t\t\t\t\t\t\t\t\t\t  const float DesiredSpeed,\n\t\t\t\t\t\t\t\t\t\t\t  FMassMoveTargetFragment& MoveTarget,\n\t\t\t\t\t\t\t\t\t\t\t  FMassZoneGraphShortPathFragment& ShortPath,\n\t\t\t\t\t\t\t\t\t\t\t  FMassZoneGraphCachedLaneFragment& CachedLane);\n\n\tMASSZONEGRAPHNAVIGATION_API bool ActivateActionAnimate(const UWorld& World,\n\t\t\t\t\t\t\t\t\t\t\t\tconst UObject* Requester,\n\t\t\t\t\t\t\t\t\t\t\t\tconst FMassEntityHandle Entity,\n\t\t\t\t\t\t\t\t\t\t\t\tFMassMoveTargetFragment& MoveTarget);\n};\n",
      "lines": 45
    },
    {
      "file_path": "MassCrowd\\Public\\IMassCrowdModule.h",
      "extension": ".h",
      "size_bytes": 1108,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n * The public interface to this module.  In most cases, this interface is only public to sibling modules \n * within this plugin.\n */\nclass IMassCrowdModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t * Singleton-like access to this module's interface.  This is just for convenience!\n\t * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t *\n\t * @return Returns singleton instance, loading the module on demand if needed\n\t */\n\tstatic inline IMassCrowdModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassCrowdModule>( \"MassCrowd\" );\n\t}\n\n\t/**\n\t * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t *\n\t * @return True if the module is loaded and ready to use\n\t */\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassCrowd\" );\n\t}\n};\n\n",
      "lines": 40
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdBubble.h",
      "extension": ".h",
      "size_bytes": 3984,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassReplicationPathHandlers.h\"\n#include \"MassReplicationTransformHandlers.h\"\n#include \"MassCrowdReplicatedAgent.h\"\n#include \"MassClientBubbleHandler.h\"\n#include \"MassClientBubbleInfoBase.h\"\n#include \"MassEntityView.h\"\n\n#include \"MassCrowdBubble.generated.h\"\n\nclass FMassCrowdClientBubbleHandler;\n\nclass MASSCROWD_API FMassCrowdClientBubbleHandler : public TClientBubbleHandlerBase<FCrowdFastArrayItem>\n{\npublic:\n\ttypedef TClientBubbleHandlerBase<FCrowdFastArrayItem> Super;\n\ttypedef TMassClientBubblePathHandler<FCrowdFastArrayItem> FMassClientBubblePathHandler;\n\ttypedef TMassClientBubbleTransformHandler<FCrowdFastArrayItem> FMassClientBubbleTransformHandler;\n\n\tFMassCrowdClientBubbleHandler()\n\t\t: PathHandler(*this)\n\t\t, TransformHandler(*this)\n\t{}\n\n#if UE_REPLICATION_COMPILE_SERVER_CODE\n\tconst FMassClientBubblePathHandler& GetPathHandler() const { return PathHandler; }\n\tFMassClientBubblePathHandler& GetPathHandlerMutable() { return PathHandler; }\n\n\tconst FMassClientBubbleTransformHandler& GetTransformHandler() const { return TransformHandler; }\n\tFMassClientBubbleTransformHandler& GetTransformHandlerMutable() { return TransformHandler; }\n#endif // UE_REPLICATION_COMPILE_SERVER_CODE\n\n\nprotected:\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\tvirtual void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize) override;\n\tvirtual void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize) override;\n\n\tvoid PostReplicatedChangeEntity(const FMassEntityView& EntityView, const FReplicatedCrowdAgent& Item) const;\n#endif //UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if WITH_MASSGAMEPLAY_DEBUG && WITH_EDITOR\n\tvirtual void DebugValidateBubbleOnServer() override;\n\tvirtual void DebugValidateBubbleOnClient() override;\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\tFMassClientBubblePathHandler PathHandler;\n\tFMassClientBubbleTransformHandler TransformHandler;\n};\n\n/** Mass client bubble, there will be one of these per client and it will handle replicating the fast array of Agents between the server and clients */\nUSTRUCT()\nstruct MASSCROWD_API FMassCrowdClientBubbleSerializer : public FMassClientBubbleSerializerBase\n{\n\tGENERATED_BODY()\n\n\tFMassCrowdClientBubbleSerializer()\n\t{\n\t\tBubble.Initialize(Crowd, *this);\n\t};\n\t\t\n\tbool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParams)\n\t{\n\t\treturn FFastArraySerializer::FastArrayDeltaSerialize<FCrowdFastArrayItem, FMassCrowdClientBubbleSerializer>(Crowd, DeltaParams, *this);\n\t}\n\npublic:\n\tFMassCrowdClientBubbleHandler Bubble;\n\nprotected:\n\t/** Fast Array of Agents for efficient replication. Maintained as a freelist on the server, to keep index consistency as indexes are used as Handles into the Array \n\t *  Note array order is not guaranteed between server and client so handles will not be consistent between them, FMassNetworkID will be.\n\t */\n\tUPROPERTY(Transient)\n\tTArray<FCrowdFastArrayItem> Crowd;\n};\n\ntemplate<>\nstruct TStructOpsTypeTraits<FMassCrowdClientBubbleSerializer> : public TStructOpsTypeTraitsBase2<FMassCrowdClientBubbleSerializer>\n{\n\tenum\n\t{\n\t\tWithNetDeltaSerializer = true,\n\t\tWithCopy = false,\n\t};\n};\n\n/**\n *  This class will allow us to replicate Mass data based on the fidelity required for each player controller. There is one AMassReplicationActor per PlayerController and \n *  which is also its owner.\n */\nUCLASS()\nclass MASSCROWD_API AMassCrowdClientBubbleInfo : public AMassClientBubbleInfoBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMassCrowdClientBubbleInfo(const FObjectInitializer& ObjectInitializer);\n\n\tFMassCrowdClientBubbleSerializer& GetCrowdSerializer() { return CrowdSerializer; }\n\nprotected:\n\tvirtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n\nprotected:\n\tUPROPERTY(Replicated, Transient)\n\tFMassCrowdClientBubbleSerializer CrowdSerializer;\n};\n",
      "lines": 111
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdFragments.h",
      "extension": ".h",
      "size_bytes": 1187,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"ZoneGraphTypes.h\"\n#include \"ZoneGraphAnnotationTypes.h\"\n#include \"MassCrowdFragments.generated.h\"\n\n/**\n * Special tag to differentiate the crowd from the rest of the other entities\n * Should not contain any data, this is purely a tag\n */\nUSTRUCT()\nstruct MASSCROWD_API FMassCrowdTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\n/**\n * Data fragment to store the last lane the agent was tracked on.\n */\nUSTRUCT()\nstruct MASSCROWD_API FMassCrowdLaneTrackingFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\tFZoneGraphLaneHandle TrackedLaneHandle;\n};\n\n\nUSTRUCT()\nstruct MASSCROWD_API FMassCrowdObstacleFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\t/** Obstacle ID reported to the obstruction annotation. */\n\tFMassLaneObstacleID LaneObstacleID;\n\n\t/** Position of the obstacle when it last moved. */\n\tFVector LastPosition = FVector::ZeroVector;\n\n\t/** Time since the obstacle has not moved based on speed tolerance. */\n\tfloat TimeSinceStopped = 0.0f;\n\n\t/** True of the current obstacle state is moving. */\n\tbool bIsMoving = true;\n};\n",
      "lines": 47
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdLaneClosingTest.h",
      "extension": ".h",
      "size_bytes": 941,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"ZoneGraphTestingActor.h\"\n#include \"MassCrowdSubsystem.h\"\n#include \"MassCrowdLaneClosingTest.generated.h\"\n\nclass UMassCrowdSubsystem;\n\nUCLASS()\nclass UZoneGraphCloseCrowdLaneTest : public UZoneLaneTest\n{\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void OnLaneLocationUpdated(const FZoneGraphLaneLocation& PrevLaneLocation, const FZoneGraphLaneLocation& NextLaneLocation) override;\n\tvirtual void Draw(FPrimitiveDrawInterface* PDI) const override;\n\tvirtual void OnOwnerSet() override;\n\nprivate:\n\tUPROPERTY(Transient)\n\tFZoneGraphLaneLocation LaneLocation;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<UMassCrowdSubsystem> CrowdSubsystem;\n\n\tUPROPERTY(EditAnywhere, Category = Test)\n\tECrowdLaneState LaneState = ECrowdLaneState::Closed;\n\n\tUPROPERTY(VisibleAnywhere, Transient, Category = Test)\n\tECrowdLaneState PrevLaneState = ECrowdLaneState::Opened;\n};",
      "lines": 33
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdLaneDataRenderingComponent.h",
      "extension": ".h",
      "size_bytes": 1385,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Components/PrimitiveComponent.h\"\n#include \"MassCrowdLaneDataRenderingComponent.generated.h\"\n\n/**\n * Primitive component that can be used to render runtime state of zone graph lanes (e.g. Opened|Closed, Density, etc.)\n * The component must be added on a ZoneGraphData actor.\n */\nUCLASS(editinlinenew, meta = (BlueprintSpawnableComponent), hidecategories = (Object, LOD, Lighting, VirtualTexture, Transform, HLOD, Collision, TextureStreaming, Mobile, Physics, Tags, AssetUserData, Activation, Cooking, Rendering, Navigation))\nclass MASSCROWD_API UMassCrowdLaneDataRenderingComponent : public UPrimitiveComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassCrowdLaneDataRenderingComponent() = default;\n\n#if !UE_BUILD_SHIPPING && !UE_BUILD_TEST\nprivate:\n\tvirtual FPrimitiveSceneProxy* CreateSceneProxy() override;\n\tvirtual void OnRegister() override;\n\tvirtual void OnUnregister() override;\n\tvirtual FBoxSphereBounds CalcBounds(const FTransform& LocalToWorld) const override;\n\tvoid DebugDrawOnCanvas(UCanvas* Canvas, APlayerController*) const;\n\tFDelegateHandle DebugTextDrawingDelegateHandle;\n\tFDelegateHandle OnLaneStateChangedDelegateHandle;\n#if WITH_EDITOR\n\tFDelegateHandle OnLaneRenderSettingsChangedDelegateHandle;\n#endif // WITH_EDITOR\n#endif // !UE_BUILD_SHIPPING && !UE_BUILD_TEST\n};",
      "lines": 33
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdMemberTrait.h",
      "extension": ".h",
      "size_bytes": 532,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTraitBase.h\"\n#include \"MassCrowdMemberTrait.generated.h\"\n\n/**\n * Trait to mark an entity with the crowd tag and add required fragments to track current lane\n */\nUCLASS(meta = (DisplayName = \"CrowdMember\"))\nclass MASSCROWD_API UMassCrowdMemberTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n};\n",
      "lines": 18
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdNavigationProcessor.h",
      "extension": ".h",
      "size_bytes": 2823,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassSignalProcessorBase.h\"\n#include \"MassObserverProcessor.h\"\n#include \"MassCrowdFragments.h\"\n#include \"MassCrowdNavigationProcessor.generated.h\"\n\nclass UZoneGraphAnnotationSubsystem;\nclass UMassCrowdSubsystem;\n\n/** Processor that monitors when entities change lane and notify the MassCrowd subsystem. */\nUCLASS()\nclass MASSCROWD_API UMassCrowdLaneTrackingSignalProcessor : public UMassSignalProcessorBase\n{\n\tGENERATED_BODY()\npublic:\n\tUMassCrowdLaneTrackingSignalProcessor();\n\nprotected:\n\tvirtual void Initialize(UObject& Owner) override;\n\tvirtual void ConfigureQueries() override;\n\tvirtual void SignalEntities(FMassEntityManager& EntityManager, FMassExecutionContext& Context, FMassSignalNameLookup& /*Unused*/) override;\n};\n\n/** Processors that cleans up the lane tracking on entity destruction. */\nUCLASS()\nclass MASSCROWD_API UMassCrowdLaneTrackingDestructor : public UMassObserverProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassCrowdLaneTrackingDestructor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};\n\n\nUCLASS()\nclass MASSCROWD_API UMassCrowdDynamicObstacleProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassCrowdDynamicObstacleProcessor();\n\nprotected:\n\tvirtual void Initialize(UObject& Owner) override;\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context);\n\n\tvoid OnStop(FMassCrowdObstacleFragment& OutObstacle, const float Radius);\n\tvoid OnMove(FMassCrowdObstacleFragment& OutObstacle);\n\n\tFMassEntityQuery EntityQuery_Conditional;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<UZoneGraphAnnotationSubsystem> ZoneGraphAnnotationSubsystem;\n};\n\n\nUCLASS()\nclass MASSCROWD_API UMassCrowdDynamicObstacleInitializer : public UMassObserverProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassCrowdDynamicObstacleInitializer();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};\n\n\nUCLASS()\nclass MASSCROWD_API UMassCrowdDynamicObstacleDeinitializer : public UMassObserverProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassCrowdDynamicObstacleDeinitializer();\n\nprotected:\n\tvirtual void Initialize(UObject& Owner) override;\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<UZoneGraphAnnotationSubsystem> ZoneGraphAnnotationSubsystem;\n\n\tFMassEntityQuery EntityQuery;\n};\n",
      "lines": 100
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdReplicatedAgent.h",
      "extension": ".h",
      "size_bytes": 1929,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassReplicationTransformHandlers.h\"\n#include \"MassReplicationTypes.h\"\n#include \"MassClientBubbleHandler.h\"\n#include \"MassReplicationPathHandlers.h\"\n\n#include \"MassCrowdReplicatedAgent.generated.h\"\n\n/** The data that is replicated specific to each Crowd agent */\nUSTRUCT()\nstruct MASSCROWD_API FReplicatedCrowdAgent : public FReplicatedAgentBase\n{\n\tGENERATED_BODY()\n\n\tconst FReplicatedAgentPathData& GetReplicatedPathData() const { return Path; }\n\n\t/** This function is required to be provided in FReplicatedAgentBase derived classes that use FReplicatedAgentPathData */\n\tFReplicatedAgentPathData& GetReplicatedPathDataMutable() { return Path; }\n\n\tconst FReplicatedAgentPositionYawData& GetReplicatedPositionYawData() const { return PositionYaw; }\n\n\t/** This function is required to be provided in FReplicatedAgentBase derived classes that use FReplicatedAgentPositionYawData */\n\tFReplicatedAgentPositionYawData& GetReplicatedPositionYawDataMutable() { return PositionYaw; }\n\nprivate:\n\tUPROPERTY(Transient)\n\tFReplicatedAgentPathData Path;\n\n\tUPROPERTY(Transient)\n\tFReplicatedAgentPositionYawData PositionYaw;\n};\n\n/** Fast array item for efficient agent replication. Remember to make this dirty if any FReplicatedCrowdAgent member variables are modified */\nUSTRUCT()\nstruct MASSCROWD_API FCrowdFastArrayItem : public FMassFastArrayItemBase\n{\n\tGENERATED_BODY()\n\n\tFCrowdFastArrayItem() = default;\n\tFCrowdFastArrayItem(const FReplicatedCrowdAgent& InAgent, const FMassReplicatedAgentHandle InHandle)\n\t\t: FMassFastArrayItemBase(InHandle)\n\t\t, Agent(InAgent)\n\t{}\n\n\t/** This typedef is required to be provided in FMassFastArrayItemBase derived classes (with the associated FReplicatedAgentBase derived class) */\n\ttypedef FReplicatedCrowdAgent FReplicatedAgentType;\n\n\tUPROPERTY()\n\tFReplicatedCrowdAgent Agent;\n};",
      "lines": 53
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdReplicator.h",
      "extension": ".h",
      "size_bytes": 967,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassReplicationProcessor.h\"\n\n#include \"MassCrowdReplicator.generated.h\"\n\n/** Class that handles replication and only runs on the server. It queries Mass entity fragments and sets those values when appropriate using the MassClientBubbleHandler. */\nUCLASS()\nclass MASSCROWD_API UMassCrowdReplicator : public UMassReplicatorBase\n{\n\tGENERATED_BODY()\n\npublic:\n\t/**\n\t * Overridden to add specific entity query requirements for replication.\n\t * Usually we add replication processor handler requirements.\n\t */\n\tvirtual void AddRequirements(FMassEntityQuery& EntityQuery) override;\n\t\n\t/**\n\t * Overridden to process the client replication.\n\t * This methods should call CalculateClientReplication with the appropriate callback implementation.\n\t */\n\tvirtual void ProcessClientReplication(FMassExecutionContext& Context, FMassReplicationContext& ReplicationContext) override;\n};",
      "lines": 27
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdRepresentationActorManagement.h",
      "extension": ".h",
      "size_bytes": 2629,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassRepresentationActorManagement.h\"\n\n#include \"MassCrowdRepresentationActorManagement.generated.h\"\n\n/**\n * Overridden representation processor to make it tied to the crowd via the requirements.\n * It is also the base class for all the different type of crowd representation (Visualization & ServerSideRepresentation)\n */\nUCLASS(abstract)\nclass MASSCROWD_API UMassCrowdRepresentationActorManagement : public UMassRepresentationActorManagement\n{\n\tGENERATED_BODY()\n\nprotected:\n\n\t/**\n\t * Enable/disable a spawned actor\n\t * @param EnabledType is the type of enabling to do on this actor\n\t * @param Actor is the actual actor to perform enabling type on\n\t * @param EntityIdx is the entity index currently processing\n\t * @param Context is the current Mass execution context\n\t */\n\tvirtual void SetActorEnabled(const EMassActorEnabledType EnabledType, AActor& Actor, const int32 EntityIdx, FMassCommandBuffer& CommandBuffer) const override;\n\n\t/**\n\t * Returns an actor of the template type and setup fragments values from it\n\t * @param RepresentationSubsystem to use to get or spawn the actor\n\t * @param EntitySubsystem associated to the mass agent\n\t * @param MassAgent is the handle to the associated mass agent\n\t * @param ActorInfo is the fragment where we are going to store the actor pointer\n\t * @param Transform is the spatial information about where to spawn the actor\n\t * @param TemplateActorIndex is the index of the type fetched with UMassRepresentationSubsystem::FindOrAddTemplateActor()\n\t * @param SpawnRequestHandle (in/out) In: previously requested spawn Out: newly requested spawn\n\t * @param Priority of this spawn request in comparison with the others, lower value means higher priority\n\t * @return the actor spawned\n\t */\n\tvirtual AActor* GetOrSpawnActor(UMassRepresentationSubsystem& RepresentationSubsystem, FMassEntityManager& EntitySubsystem\n\t\t, const FMassEntityHandle MassAgent, const FTransform& Transform, const int16 TemplateActorIndex\n\t\t, FMassActorSpawnRequestHandle& SpawnRequestHandle, const float Priority) const override;\n\n\t/**\n\t * Teleports the actor at the specified transform by preserving its velocity and without collision.\n\t * The destination will be adjusted to fit an existing capsule.\n\t * @param Transform is the new actor's transform \n\t * @param Actor is the actual actor to teleport\n\t * @param Context is the current Mass execution context\n\t */\n\tvirtual void TeleportActor(const FTransform& Transform, AActor& Actor, FMassCommandBuffer& CommandBuffer) const override;\n};",
      "lines": 53
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdRepresentationSubsystem.h",
      "extension": ".h",
      "size_bytes": 557,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassRepresentationSubsystem.h\"\n\n#include \"MassCrowdRepresentationSubsystem.generated.h\"\n\n/**\n * Subsystem responsible for all visual of mass crowd agents, will handle actors spawning and static mesh instances\n */\nUCLASS()\nclass MASSCROWD_API UMassCrowdRepresentationSubsystem : public UMassRepresentationSubsystem\n{\n\tGENERATED_BODY()\n\nprotected:\n\t// USubsystem BEGIN\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\t// USubsystem END\n};",
      "lines": 21
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdServerRepresentationLODProcessor.h",
      "extension": ".h",
      "size_bytes": 1332,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassCrowdTypes.h\"\n#include \"MassCrowdFragments.h\"\n#include \"MassProcessor.h\"\n#include \"MassLODCalculator.h\"\n#include \"MassLODTickRateController.h\"\n\n#include \"MassCrowdServerRepresentationLODProcessor.generated.h\"\n\nUCLASS(meta=(DisplayName=\"Crowd Simulation LOD\"))\nclass MASSCROWD_API UMassCrowdServerRepresentationLODProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassCrowdServerRepresentationLODProcessor();\n\nprotected:\n\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Initialize(UObject& InOwner) override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\t/** Distance where each LOD becomes relevant */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", config)\n\tfloat LODDistance[EMassLOD::Max];\n\n\t/** Hysteresis percentage on delta between the LOD distances */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", meta = (ClampMin = \"0.0\", UIMin = \"0.0\"), config)\n\tfloat BufferHysteresisOnDistancePercentage = 10.0f;\n\n\t/** Maximum limit of entity per LOD */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", config)\n\tint32 LODMaxCount[EMassLOD::Max];\n\n\tTMassLODCalculator<FLODDefaultLogic> LODCalculator;\n\n\tFMassEntityQuery EntityQuery;\n};\n",
      "lines": 42
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdServerRepresentationProcessor.h",
      "extension": ".h",
      "size_bytes": 756,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassRepresentationProcessor.h\"\n\n#include \"MassCrowdServerRepresentationProcessor.generated.h\"\n\n/**\n * Overridden representation processor to make it tied to the crowd on the server via the requirements\n * It is the counter part of the crowd visualization processor on the client.\n */\nUCLASS(meta = (DisplayName = \"Mass Crowd Server Representation\"))\nclass MASSCROWD_API UMassCrowdServerRepresentationProcessor : public UMassRepresentationProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassCrowdServerRepresentationProcessor();\n\n\t/** Configure the owned FMassEntityQuery instances to express processor's requirements */\n\tvirtual void ConfigureQueries() override;\n};",
      "lines": 23
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdServerRepresentationTrait.h",
      "extension": ".h",
      "size_bytes": 937,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassEntityTraitBase.h\"\n#include \"MassRepresentationTypes.h\"\n#include \"MassRepresentationFragments.h\"\n#include \"GameFramework/Actor.h\"\n\n#include \"MassCrowdServerRepresentationTrait.generated.h\"\n\n\nUCLASS(meta=(DisplayName=\"Crowd Server Representation\"))\nclass MASSCROWD_API UMassCrowdServerRepresentationTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\n\tUMassCrowdServerRepresentationTrait();\n\nprotected:\n\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\n\t/** Actor class of this agent when spawned on server */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tTSubclassOf<AActor> TemplateActor;\n\n\t/** Configuration parameters for the representation processor */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tFMassRepresentationParameters Params;\n};\n",
      "lines": 31
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdSettings.h",
      "extension": ".h",
      "size_bytes": 6448,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassSettings.h\"\n#include \"ZoneGraphTypes.h\"\n#include \"MassCrowdSettings.generated.h\"\n\n#if WITH_EDITOR\n/** Called when density settings change. */\nDECLARE_MULTICAST_DELEGATE(FOnMassCrowdLaneDataSettingsChanged);\n/** Called when rendering settings change. */\nDECLARE_MULTICAST_DELEGATE(FOnMassCrowdLaneRenderSettingsChanged);\n#endif\n\n/**\n * Structure holding data to associate lane densities to\n * weights so lane selection at intersection could use that\n * to maintain overall density during the simulation\n */\nUSTRUCT()\nstruct MASSCROWD_API FMassCrowdLaneDensityDesc\n{\n\tGENERATED_BODY()\n\n\t/** Default weight of a lane if it has no density tag */\n\tstatic constexpr float DefaultWeight = 1.0f;\n\n\t/** Tag representing the lane density. */\n\tUPROPERTY(EditAnywhere, Category = \"Lane Density\")\n\tFZoneGraphTag Tag;\n\n\t/**\n\t * Weight associated to the current lane density.\n\t * This weight is used during lane selection at intersection\n\t * and the random selection will consider the weight of each\n\t * lane and the combined weight of all lanes.\n\t */\n\tUPROPERTY(EditAnywhere, Category = \"Lane Density\")\n\tfloat Weight = DefaultWeight;\n\n\tUPROPERTY(EditAnywhere, Category = \"Lane Density\", meta = (HideAlphaChannel))\n\tFColor RenderColor = FColor::Silver;\n};\n\n/**\n * Settings for the MassCrowd plugin.\n */\nUCLASS(config = Plugins, defaultconfig, DisplayName = \"Mass Crowd\", dontCollapseCategories)\nclass MASSCROWD_API UMassCrowdSettings : public UMassModuleSettings\n{\n\tGENERATED_BODY()\n\npublic:\n\tconst TArray<FMassCrowdLaneDensityDesc>& GetLaneDensities() const { return LaneDensities; }\n\tfloat GetMoveDistance() const\n\t{ \n\t\treturn FMath::Max(0.0f, MoveDistance + FMath::RandRange(-MoveDistanceRandomDeviation, MoveDistanceRandomDeviation));\n\t}\n\n#if WITH_EDITOR\n\tmutable FOnMassCrowdLaneDataSettingsChanged OnMassCrowdLaneDataSettingsChanged;\n\tmutable FOnMassCrowdLaneRenderSettingsChanged OnMassCrowdLaneRenderSettingsChanged;\n#endif\n\n\t/** Base thickness used to render lane data specific to crowd. */\n\tUPROPERTY(EditAnywhere, config, meta = (ClampMin = \"0.0\", UIMin = \"0.0\"), Category = \"Lane Debug Rendering\")\n\tfloat LaneBaseLineThickness = 5.0f;\n\n\t/** Z offset used to render lane data specific to crowd over the actual zone graph. */\n\tUPROPERTY(EditAnywhere, config, meta = (ClampMin = \"0.0\", UIMin = \"0.0\"), Category = \"Lane Debug Rendering\")\n\tfloat LaneRenderZOffset = 50.0f;\n\n\t/** Scale factor applied on the base thickness to render intersection lanes data. */\n\tUPROPERTY(EditAnywhere, config, meta = (ClampMin = \"1.0\", UIMin = \"1.0\", ClampMax = \"10.0\", UIMax = \"10.0\"), Category = \"Lane Debug Rendering\")\n\tfloat IntersectionLaneScaleFactor = 1.5f;\n\n\t/** Scale factor applied on the base or intersection thickness to render density outline. */\n\tUPROPERTY(EditAnywhere, config, meta = (ClampMin = \"1.0\", UIMin = \"1.0\", ClampMax = \"10.0\", UIMax = \"10.0\"), Category = \"Lane Debug Rendering\")\n\tfloat LaneDensityScaleFactor = 1.5f;\n\n\t/** Color used to render crowd lane that are opened for navigation. */\n\tUPROPERTY(EditAnywhere, config, Category = \"Lane Density\", meta = (HideAlphaChannel))\n\tFColor OpenedLaneColor = FColor::Green;\n\n\t/** Color used to render crowd lane that are closed to navigation. */\n\tUPROPERTY(EditAnywhere, config, Category = \"Lane Density\", meta = (HideAlphaChannel))\n\tFColor ClosedLaneColor = FColor::Red;\n\n\t/** Tag required on a lane to build crowd related runtime data for it and render it. */\n\tUPROPERTY(EditDefaultsOnly, config, Category = Lane)\n\tFZoneGraphTag CrowdTag;\n\n\t/** Tag required on a lane to build intersection crossing runtime data for it. */\n\tUPROPERTY(EditDefaultsOnly, config, Category = Lane)\n\tFZoneGraphTag CrossingTag;\n\n\t/** Distance reserved for each entity while waiting on an intersection lane. */\n\tUPROPERTY(EditDefaultsOnly, config, Category = WaitArea)\n\tuint32 SlotSize = 50;\n\n\t/** Offset from the lane entry where the slots are created. */\n\tUPROPERTY(EditDefaultsOnly, config, Category = WaitArea)\n\tfloat SlotOffset = 75;\n\n\t/** Text will be added on lanes with entity tracking or waiting area to indicate the current occupation */\n\tUPROPERTY(EditAnywhere, config, Category = Options)\n\tbool bDisplayTrackingData = true;\n\n\t/** Lanes will be displayed to indicates the current state. See MassCrowd settings for parameters. */\n\tUPROPERTY(EditAnywhere, config, Category = Options)\n\tbool bDisplayStates = true;\n\n\t/** Lanes will be displayed to represent their assigned densities. See MassCrowd settings for parameters. */\n\tUPROPERTY(EditAnywhere, config, Category = Options)\n\tbool bDisplayDensities = true;\n\n\t/** An obstacle is considered being stopped when it's speed is less than the tolerance. */\n\tUPROPERTY(EditAnywhere, config, Category = Obstacles, meta = (ClampMin = \"0.0\", UIMin = \"0.0\", ForceUnits = \"cm/s\"))\n\tfloat ObstacleStoppingSpeedTolerance = 5.0f;\n\n\t/** An obstacle is considered moving when it has moved this much after being stationary. */\n\tUPROPERTY(EditAnywhere, config, Category = Obstacles, meta = (ClampMin = \"0.0\", UIMin = \"0.0\", ForceUnits = \"cm\"))\n\tfloat ObstacleMovingDistanceTolerance = 10.0f;\n\n\t/** The time an obstacle needs to be not moving before it is reported as stopped.*/\n\tUPROPERTY(EditAnywhere, config, Category = Obstacles, meta = (ClampMin = \"0.0\", UIMin = \"0.0\", ForceUnits = \"s\"))\n\tfloat ObstacleTimeToStop = 0.3f;\n\n\t/** The radius an obstacle has effects on navigation.*/\n\tUPROPERTY(EditAnywhere, config, Category = Obstacles, meta = (ClampMin = \"0.0\", UIMin = \"0.0\", ForceUnits = \"cm\"))\n\tfloat ObstacleEffectRadius = 1000.f;\n\nprotected:\n\n#if WITH_EDITOR\n\tvirtual void PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent) override;\n#endif\n\n\t/** Distance ahead of the current lane location for the next movement target location. */\n\tUPROPERTY(EditDefaultsOnly, config, meta = (ClampMin = \"0.0\", UIMin = \"0.0\"), Category = Movement)\n\tfloat MoveDistance = 500.f;\n\n\t/** Random deviation of the of the MoveDistance */\n\tUPROPERTY(EditDefaultsOnly, config, meta = (ClampMin = \"0.0\", UIMin = \"0.0\"), Category = Movement)\n\tfloat MoveDistanceRandomDeviation = 100.f;\n\n\t/** List of all lane density descriptors. */\n\tUPROPERTY(EditAnywhere, config, Category = \"Lane Density\")\n\tTArray<FMassCrowdLaneDensityDesc> LaneDensities;\n};",
      "lines": 151
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdSpawnerSubsystem.h",
      "extension": ".h",
      "size_bytes": 337,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassActorSpawnerSubsystem.h\"\n\n#include \"MassCrowdSpawnerSubsystem.generated.h\"\n\n/**\n * A subsystem managing spawning of crowd\n */\nUCLASS()\nclass MASSCROWD_API UMassCrowdSpawnerSubsystem : public UMassActorSpawnerSubsystem\n{\n\tGENERATED_BODY()\n};\n",
      "lines": 16
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdSubsystem.h",
      "extension": ".h",
      "size_bytes": 10936,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassCrowdTypes.h\"\n#include \"ZoneGraphTypes.h\"\n#include \"MassSubsystemBase.h\"\n#include \"MassCrowdSubsystem.generated.h\"\n\nclass UZoneGraphAnnotationSubsystem;\nclass UMassCrowdSettings;\nclass UZoneGraphSubsystem;\nclass AZoneGraphData;\n\n#if !UE_BUILD_SHIPPING\n/** Called when a lane changes state at runtime. */\nDECLARE_MULTICAST_DELEGATE(FDebugOnMassCrowdLaneStateChanged);\n#endif\n\n/** Structure holding all pertinent data related to the selected lane. */\nstruct FSelectLaneResult\n{\n\t/** The handle of the next lane selected from the available links. */\n\tFZoneGraphLaneHandle NextLaneHandle;\n\n\t/** The distance along the lane the entity should reach before stopping. */\n\tTOptional<float> WaitDistance;\n};\n\n/** Container for the crowd lane data associated to a specific registered ZoneGraph data. */\nstruct FRegisteredCrowdLaneData\n{\n\tvoid Reset()\n\t{\n\t\tCrowdLaneDataArray.Reset();\n\t\tDataHandle.Reset();\n\t\tLaneToTrackingDataLookup.Reset();\n\t\tLaneToBranchingDataLookup.Reset();\n\t\tWaitAreas.Reset();\n\t}\n\n\t/** Per lane data; array size matches the ZoneGraph storage. */\n\tTArray<FZoneGraphCrowdLaneData> CrowdLaneDataArray;\n\n\t/** Handle of the storage the data was initialized from. */\n\tFZoneGraphDataHandle DataHandle;\n\n\t/** Lane to entity tracking data lookup */\n\tTMap<int32, FCrowdTrackingLaneData> LaneToTrackingDataLookup;\n\n\t/** Lane to branching data lookup */\n\tTMap<int32, FCrowdBranchingLaneData> LaneToBranchingDataLookup;\n\n\tTArray<FCrowdWaitAreaData> WaitAreas;\n};\n\n/**\n * Subsystem that tracks mass entities that are wandering on the zone graph.\n * It will create custom runtime lane data to allow branching decisions.\n */\nUCLASS()\nclass MASSCROWD_API UMassCrowdSubsystem : public UMassSubsystemBase\n{\n\tGENERATED_BODY()\npublic:\n#if !UE_BUILD_SHIPPING\n\tFDebugOnMassCrowdLaneStateChanged DebugOnMassCrowdLaneStateChanged;\n#endif\n\n#if WITH_EDITOR\n\t/** Clears and rebuilds all lane and intersection data for registered zone graphs using the current settings. */\n\tvoid RebuildLaneData();\n#endif\n\n\t/** @return true if the Crowd subsystem has lane data for specified graph. */\n\tbool HasCrowdDataForZoneGraph(const FZoneGraphDataHandle DataHandle) const;\n\n\t/**\n\t * Returns the readonly runtime data associated to a given zone graph.\n\t * @param DataHandle A valid handle of the zone graph used to retrieve the runtime crowd data\n\t * @return Runtime data associated to the zone graph if available; nullptr otherwise\n\t * @note Method will ensure if DataHandle is invalid or if associated data doesn't exist. Should call HasCrowdDataForZoneGraph first.\n\t */\n\tconst FRegisteredCrowdLaneData* GetCrowdData(const FZoneGraphDataHandle DataHandle) const;\n\n\t/**\n\t * Returns the readonly runtime data associated to a given zone graph lane.\n\t * @param LaneHandle A valid lane handle used to retrieve the runtime data; ensure if handle is invalid\n\t * @return Runtime data associated to the lane (if available)\n\t */\n\tTOptional<FZoneGraphCrowdLaneData> GetCrowdLaneData(const FZoneGraphLaneHandle LaneHandle) const;\n\n\t/**\n\t * Returns the entity tracking runtime data associated to a given zone graph lane.\n\t * @param LaneHandle A valid lane handle used to retrieve the associated tracking data; ensure if handle is invalid\n\t * @return Runtime data associated to the lane (nullptr if provided handle is invalid or no data is associated to that lane)\n\t */\n\tconst FCrowdTrackingLaneData* GetCrowdTrackingLaneData(const FZoneGraphLaneHandle LaneHandle) const;\n\n\t/**\n\t * Returns the branching data associated to a given zone graph lane.\n \t * @param LaneHandle A valid lane handle used to retrieve the associated data; ensure if handle is invalid\n\t * @return Branching data associated to the lane (nullptr if provided handle is invalid or no data is associated to that lane)\n\t */\n\tconst FCrowdBranchingLaneData* GetCrowdBranchingLaneData(const FZoneGraphLaneHandle LaneHandle) const;\n\n\t/**\n\t * Returns the waiting area runtime data associated to a given zone graph lane.\n\t * @param LaneHandle A valid lane handle used to retrieve the associated intersection data; ensure if handle is invalid\n\t * @return Runtime data associated to the lane (nullptr if provided handle is invalid or no data is associated to that lane)\n\t */\n\tconst FCrowdWaitAreaData* GetCrowdWaitingAreaData(const FZoneGraphLaneHandle LaneHandle) const;\n\n\t/**\n\t * Return the current state of a lane.\n\t * @param LaneHandle A valid lane handle used to retrieve the runtime data and change the lane state; ensure if handle is invalid\n\t * @return The state of the lane\n\t */\n\tECrowdLaneState GetLaneState(const FZoneGraphLaneHandle LaneHandle) const;\n\n\t/**\n\t * Changes the state of a lane.\n\t * @param LaneHandle A valid lane handle used to retrieve the runtime data and change the lane state; ensure if handle is invalid\n\t * @param NewState The new state of the lane\n\t * @return True if the state was successfully changed or was already in the right state; false if handle is invalid\n\t */\n\tbool SetLaneState(const FZoneGraphLaneHandle LaneHandle, ECrowdLaneState NewState);\n\n\t/** @return Combined Tag mask that represents all possible lane density tags. Built from MassCrowdSettings. */\n\tFZoneGraphTagMask GetDensityMask() const { return DensityMask; }\n\n\t/**\n\t * Acquires a slot from a specified waiting lane. Nearest vacant slot to EntityPosition is returned. \n\t * @param Entity Requesting entity\n\t * @param EntityPosition Position of the entity.\n\t * @param LaneHandle A handle to a lane with waiting data.\n\t * @param OutSlotPosition Position associated to the acquired slot.\n\t * @param OutSlotDirection Facing direction associated to the acquire slot.\n\t * @return Index of the slot, or INDEX_NONE if no slots are available or if the lane is not a waiting lane.\n\t */\n\tint32 AcquireWaitingSlot(const FMassEntityHandle Entity, const FVector& EntityPosition, const FZoneGraphLaneHandle LaneHandle,\n\t\t\t\t\t\t\t FVector& OutSlotPosition, FVector& OutSlotDirection);\n\t\n\t/**\n\t * Releases previously acquired slot from a specified waiting lane.\n\t * @param Entity Requesting entity\n\t * @param LaneHandle A handle to a lane with waiting data.\n\t * @param SlotIndex Index of the previously acquired slot.\n\t */\n\tvoid ReleaseWaitingSlot(const FMassEntityHandle Entity, const FZoneGraphLaneHandle LaneHandle, const int32 SlotIndex);\n\n\t/**\n\t * Callback from the lane tracker processor to indicates a mass entity changing lane.\n\t * @param Entity The mass entity\n\t * @param PreviousLaneHandle Last frame lane handle (can be invalid)\n\t * @param CurrentLaneHandle Current frame lane handle (can be invalid)\n\t */\n\tvoid OnEntityLaneChanged(const FMassEntityHandle Entity, const FZoneGraphLaneHandle PreviousLaneHandle, const FZoneGraphLaneHandle CurrentLaneHandle);\n\n\t/** Returns the weight for lane selection that is associated to the given lane based on its density tag. */\n\tfloat GetDensityWeight(const FZoneGraphLaneHandle LaneHandle, const FZoneGraphTagMask LaneTagMask) const;\n\nprotected:\n\tfriend class UMassCrowdLaneTrackingProcessor;\n\tfriend class UMassCrowdWanderFragmentDestructor;\n\tfriend class UZoneGraphCrowdLaneAnnotations;\n\n\tvoid UpdateDensityMask();\n\n\t// USubsystem BEGIN\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\tvirtual void PostInitialize() override;\n\tvirtual void Deinitialize() override;\n\t// USubsystem END\n\n\tvoid PostZoneGraphDataAdded(const AZoneGraphData* ZoneGraphData);\n\tvoid PreZoneGraphDataRemoved(const AZoneGraphData* ZoneGraphData);\n\n\t/**\n\t * Returns the modifiable runtime data associated to a given zone graph lane.\n\t * @param LaneHandle A valid lane handle used to retrieve the runtime data; ensure if handle is invalid\n\t * @return Runtime data associated to the lane if available; nullptr otherwise\n\t */\n\tFZoneGraphCrowdLaneData* GetMutableCrowdLaneData(const FZoneGraphLaneHandle LaneHandle);\n\n\t/**\n\t * Populates the crowd lane data array with all existing lane in the zone graph.\n\t * Also creates some extra data for lanes that could be used to wait in case of\n\t * temporarily closed lane (e.g. intersection crossings).\n\t */\n\tvoid BuildLaneData(FRegisteredCrowdLaneData& LaneData, const FZoneGraphStorage& Storage);\n\n\t/**\n\t * Callback to keep count of entities currently on a given lane.\n\t * @param Entity The entity entering the lane\n\t * @param LaneIndex Index of the lane\n\t * @param TrackingData Runtime state associated to the lane\n\t */\n\tvoid OnEnterTrackedLane(const FMassEntityHandle Entity, const int32 LaneIndex, FCrowdTrackingLaneData& TrackingData);\n\n\t/**\n\t * Callback to keep count of entities currently on a given lane.\n\t * @param Entity The entity exiting the lane\n\t * @param LaneIndex Index of the lane\n\t * @param TrackingData Runtime state associated to the lane\n\t */\n\tvoid OnExitTrackedLane(const FMassEntityHandle Entity, const int32 LaneIndex, FCrowdTrackingLaneData& TrackingData);\n\n\t/**\n\t * Creates and initializes the occupancy data of a lane.\n\t * @param LaneIndex Index of the source zone graph lane\n\t * @param ZoneGraphStorage ZoneGraph data storage to extract lane information from\n\t * @return The newly created structure holding occupancy data associated to the zone graph lane\n\t */\n\tFCrowdTrackingLaneData& CreateTrackingData(const int32 LaneIndex, const FZoneGraphStorage& ZoneGraphStorage);\n\n\t/**\n\t * Creates dedicated structure to hold data of a branching lane.\n\t * @param LaneIndex Index of the source zone graph lane\n\t * @param ZoneGraphStorage ZoneGraph data storage to extract lane information from\n\t * @return The newly created structure holding specific data of a branching lane\n\t */\n\tFCrowdBranchingLaneData& CreateBranchingData(const int32 LaneIndex, const FZoneGraphStorage& ZoneGraphStorage);\n\n\tvoid CreateWaitSlots(const int32 CrossingLaneIndex, FCrowdWaitAreaData& WaitArea, const FZoneGraphStorage& ZoneGraphStorage);\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<UZoneGraphSubsystem> ZoneGraphSubsystem = nullptr;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<UZoneGraphAnnotationSubsystem> ZoneGraphAnnotationSubsystem = nullptr;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<const UMassCrowdSettings> MassCrowdSettings = nullptr;\n\n\tFDelegateHandle OnPostZoneGraphDataAddedHandle;\n\tFDelegateHandle OnPreZoneGraphDataRemovedHandle;\n#if WITH_EDITOR\n\tFDelegateHandle OnMassCrowdSettingsChangedHandle;\n\tFDelegateHandle OnZoneGraphDataBuildDoneHandle;\n#endif\n\n\t/** Per lane data for all registered ZoneGraph data. */\n\tTArray<FRegisteredCrowdLaneData> RegisteredLaneData;\n\n\t/** Tag mask that represents all possible lane density tags. Built from MassCrowdSettings. */\n\tFZoneGraphTagMask DensityMask;\n};\n\ntemplate<>\nstruct TMassExternalSubsystemTraits<UMassCrowdSubsystem> final\n{\n\tenum\n\t{\n\t\tGameThreadOnly = false\n\t};\n};\n",
      "lines": 257
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdTypes.h",
      "extension": ".h",
      "size_bytes": 2922,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassLODLogic.h\"\n#include \"ZoneGraphTypes.h\"\n\n#include \"MassCrowdTypes.generated.h\"\n\nstruct FMassCrowdSimulationLODLogic : public FLODDefaultLogic\n{\n\tenum\n\t{\n\t\tbDoVariableTickRate = true,\n\t};\n};\n\nstruct FMassCrowdViewerLODLogic : public FLODDefaultLogic\n{\n\tenum\n\t{\n\t\tbDoVisibilityLogic = true,\n\t\tbCalculateLODSignificance = true,\n\t\tbLocalViewersOnly = true,\n\t};\n};\n\nstruct FMassCrowdCombinedLODLogic : public FLODDefaultLogic\n{\n\tenum\n\t{\n\t\tbDoVariableTickRate = true,\n\t\tbDoVisibilityLogic = true,\n\t\tbCalculateLODSignificance = true,\n\t\tbLocalViewersOnly = true,\n\t};\n};\n\n/** State of a given lane */\nUENUM()\nenum class ECrowdLaneState : uint8\n{\n\tOpened, // Pedestrians can enter the lane\n\tClosed, // Pedestrians can not enter the lane\n};\n\n/** Runtime data associated to lane that can be used to track count of entities on it. */\nUSTRUCT()\nstruct MASSCROWD_API FCrowdTrackingLaneData\n{\n\tGENERATED_BODY()\n\n\t/**\n\t * Index of an associated waiting area. This will be valid for branching lanes leading\n\t * to a crossing that requires agent to wait for incoming lane to open.\n\t */\n\tint32 WaitAreaIndex = INDEX_NONE;\n\n\tint32 NumEntitiesOnLane = 0;\n};\n\n/** Runtime data associated to lane that can be used to wait another one to open. */\nUSTRUCT()\nstruct MASSCROWD_API FCrowdWaitSlot\n{\n\tGENERATED_BODY()\n\n\tFVector Position = FVector::Zero();\n\t\n\tFVector Forward = FVector::ForwardVector;\n\n\tfloat Radius = 0;\n\n\tbool bOccupied = false;\n};\n\n/** Runtime data associated to entry to a lane that can be opened or closed. */\nUSTRUCT()\nstruct MASSCROWD_API FCrowdWaitAreaData\n{\n\tGENERATED_BODY()\n\n\tvoid Reset()\n\t{\n\t\tSlots.Reset();\n\t\tNumFreeSlots = 0;\n\t}\n\t\n\tbool IsFull() const { return NumFreeSlots == 0; }\n\tint32 GetNumSlots() const { return Slots.Num(); }\n\tint32 GetNumFreeSlots() const { return NumFreeSlots; }\n\tint32 GetNumOccupiedSlots() const { return Slots.Num() - NumFreeSlots; }\n\n\tTArray<FCrowdWaitSlot> Slots;\n\n\tTArray<FZoneGraphLaneHandle> ConnectedLanes;\n\t\n\tint32 NumFreeSlots = 0;\n};\n\n/** Runtime data associated to branching. */\nUSTRUCT()\nstruct MASSCROWD_API FCrowdBranchingLaneData\n{\n\tGENERATED_BODY()\n\n\t/**\n\t * Density mask extracted from the incoming lane.\n\t * This is required since the intersection might split and reach different densities on connected shapes.\n\t * We can't keep a single density for the whole polygon so we keep it per lane.\n\t */\n\tuint32 DensityMask = 0;\n};\n\n/** Structure holding runtime data associated to a zone graph lane to handle pedestrian navigation. */\nUSTRUCT()\nstruct FZoneGraphCrowdLaneData\n{\n\tGENERATED_BODY()\npublic:\n\tECrowdLaneState GetState() const { return State; }\n\tvoid SetState(ECrowdLaneState Value) { State = Value; }\nprotected:\n\tECrowdLaneState State = ECrowdLaneState::Opened;\n};\n",
      "lines": 125
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdVisualizationLODProcessor.h",
      "extension": ".h",
      "size_bytes": 1046,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassVisualizationLODProcessor.h\"\n#include \"MassLODCollectorProcessor.h\"\n#include \"MassCrowdVisualizationLODProcessor.generated.h\"\n\n/*\n * Created a crowd version for parallelization of the crowd with the traffic\n */\nUCLASS(meta=(DisplayName=\"Crowd visualization LOD\"))\nclass MASSCROWD_API UMassCrowdVisualizationLODProcessor : public UMassVisualizationLODProcessor\n{\n\tGENERATED_BODY()\npublic:\n\tUMassCrowdVisualizationLODProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n};\n\n/*\n * Created a crowd version for parallelization of the crowd with the traffic\n */\nUCLASS(meta = (DisplayName = \"Crowd LOD Collection \"))\nclass MASSCROWD_API UMassCrowdLODCollectorProcessor : public UMassLODCollectorProcessor\n{\n\tGENERATED_BODY()\n\n\tUMassCrowdLODCollectorProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n};\n\n",
      "lines": 37
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdVisualizationProcessor.h",
      "extension": ".h",
      "size_bytes": 1557,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassRepresentationProcessor.h\"\n\n#include \"MassCrowdVisualizationProcessor.generated.h\"\n\n/**\n * Overridden visualization processor to make it tied to the crowd via the requirements\n */\nUCLASS(meta = (DisplayName = \"Mass Crowd Visualization\"))\nclass MASSCROWD_API UMassCrowdVisualizationProcessor : public UMassVisualizationProcessor\n{\n\tGENERATED_BODY()\npublic:\n\tUMassCrowdVisualizationProcessor();\n\nprotected:\n\n\t/** Configure the owned FMassEntityQuery instances to express processor's requirements */\n\tvirtual void ConfigureQueries() override;\n};\n\n/**\n * A custom visualization processor for debugging mass crowd\n */\nUCLASS(meta = (DisplayName = \"Mass Crowd Visualization\"))\nclass MASSCROWD_API UMassDebugCrowdVisualizationProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\npublic:\n\tUMassDebugCrowdVisualizationProcessor();\n\nprotected:\n\n\t/** Configure the owned FMassEntityQuery instances to express processor's requirements */\n\tvirtual void ConfigureQueries() override;\n\n\tvirtual void Initialize(UObject& Owner) override;\n\n\t/**\n\t * Execution method for this processor\n\t * @param EntitySubsystem is the system to execute the lambdas on each entity chunk\n\t * @param Context is the execution context to be passed when executing the lambdas\n\t */\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<UWorld> World;\n\n\tFMassEntityQuery EntityQuery;\n};",
      "lines": 53
    },
    {
      "file_path": "MassCrowd\\Public\\MassCrowdVisualizationTrait.h",
      "extension": ".h",
      "size_bytes": 529,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassVisualizationTrait.h\"\n#include \"MassCrowdVisualizationTrait.generated.h\"\n\nUCLASS(BlueprintType, EditInlineNew, CollapseCategories, meta=(DisplayName=\"Crowd Visualization\"))\nclass MASSCROWD_API UMassCrowdVisualizationTrait : public UMassVisualizationTrait\n{\n\tGENERATED_BODY()\npublic:\n\tUMassCrowdVisualizationTrait();\n\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n};\n",
      "lines": 16
    },
    {
      "file_path": "MassCrowd\\Public\\ZoneGraphCrowdLaneAnnotations.h",
      "extension": ".h",
      "size_bytes": 2133,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassCrowdSubsystem.h\"\n#include \"ZoneGraphAnnotationComponent.h\"\n#include \"ZoneGraphAnnotationTypes.h\"\n\n#include \"ZoneGraphCrowdLaneAnnotations.generated.h\"\n\n/** Event indicating the new state of a lane. */\nUSTRUCT()\nstruct MASSCROWD_API FZoneGraphCrowdLaneStateChangeEvent : public FZoneGraphAnnotationEventBase\n{\n\tGENERATED_BODY()\n\n\tFZoneGraphCrowdLaneStateChangeEvent() = default;\n\tFZoneGraphCrowdLaneStateChangeEvent(const FZoneGraphLaneHandle LaneHandle, const ECrowdLaneState NewState)\n\t\t: Lane(LaneHandle), State(NewState)\t{}\n\n\t/** Affected lane. */\n\tUPROPERTY()\n\tFZoneGraphLaneHandle Lane;\n\n\t/** New state. */\n\tUPROPERTY()\n\tECrowdLaneState State = ECrowdLaneState::Opened;\n};\n\n/**\n * Zone graph blocking behavior\n */\nUCLASS(ClassGroup = AI, BlueprintType, meta = (BlueprintSpawnableComponent))\nclass MASSCROWD_API UZoneGraphCrowdLaneAnnotations : public UZoneGraphAnnotationComponent\n{\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void PostSubsystemsInitialized() override;\n\tvirtual FZoneGraphTagMask GetAnnotationTags() const override;\n\tvirtual void HandleEvents(const FInstancedStructContainer& Events) override;\n\tvirtual void TickAnnotation(const float DeltaTime, FZoneGraphAnnotationTagContainer& AnnotationTagContainer) override;\n\n#if UE_ENABLE_DEBUG_DRAWING\n\tvirtual void DebugDraw(FZoneGraphAnnotationSceneProxy* DebugProxy) override;\n\tvirtual void DebugDrawCanvas(UCanvas* Canvas, APlayerController*) override;\n#endif // UE_ENABLE_DEBUG_DRAWING\n\n\t/** Annotation Tag to mark a closed lane. */\n\tUPROPERTY(EditAnywhere, Category = CrowdLane)\n\tFZoneGraphTag CloseLaneTag;\n\n\t/** Annotation Tag to mark a waiting lane. */\n\tUPROPERTY(EditAnywhere, Category = CrowdLane)\n\tFZoneGraphTag WaitingLaneTag;\n\n\tUPROPERTY(EditAnywhere, Category = Debug)\n\tbool bDisplayTags = false;\n\n\t/** Array of queued events. */\n\tTArray<FZoneGraphCrowdLaneStateChangeEvent> StateChangeEvents;\n\n\t/** Cached ZoneGraphSubsystem */\n\tUPROPERTY(Transient)\n\tTObjectPtr<UMassCrowdSubsystem> CrowdSubsystem = nullptr;\n};\n",
      "lines": 66
    },
    {
      "file_path": "MassCrowd\\Public\\Tasks\\MassCrowdClaimWaitSlotTask.h",
      "extension": ".h",
      "size_bytes": 1625,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassStateTreeTypes.h\"\n#include \"ZoneGraphTypes.h\"\n#include \"Tasks/MassZoneGraphPathFollowTask.h\"\n#include \"MassCrowdClaimWaitSlotTask.generated.h\"\n\nstruct FStateTreeExecutionContext;\nclass UMassCrowdSubsystem;\n\n/**\n* Claim wait slot and expose slot position for path follow.\n*/\nUSTRUCT()\nstruct MASSCROWD_API FMassCrowdClaimWaitSlotTaskInstanceData\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, Category = Output)\n\tFMassZoneGraphTargetLocation WaitSlotLocation;\n\n\tUPROPERTY()\n\tint32 WaitingSlotIndex = INDEX_NONE;\n\t\n\tUPROPERTY()\n\tFZoneGraphLaneHandle AcquiredLane;\n};\n\nUSTRUCT(meta = (DisplayName = \"Crowd Claim Wait Slot\"))\nstruct MASSCROWD_API FMassCrowdClaimWaitSlotTask : public FMassStateTreeTaskBase\n{\n\tGENERATED_BODY()\n\n\tusing FInstanceDataType = FMassCrowdClaimWaitSlotTaskInstanceData;\n\t\n\tFMassCrowdClaimWaitSlotTask();\n\nprotected:\n\tvirtual bool Link(FStateTreeLinker& Linker) override;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\tvirtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\tvirtual void ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\n\tTStateTreeExternalDataHandle<FMassZoneGraphLaneLocationFragment> LocationHandle;\n\tTStateTreeExternalDataHandle<FMassMoveTargetFragment> MoveTargetHandle;\n\tTStateTreeExternalDataHandle<UMassCrowdSubsystem> CrowdSubsystemHandle;\n};\n",
      "lines": 49
    },
    {
      "file_path": "MassCrowd\\Public\\Tasks\\MassZoneGraphFindWanderTarget.h",
      "extension": ".h",
      "size_bytes": 1730,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassStateTreeTypes.h\"\n#include \"Tasks/MassZoneGraphPathFollowTask.h\"\n#include \"MassZoneGraphFindWanderTarget.generated.h\"\n\nstruct FStateTreeExecutionContext;\nstruct FMassZoneGraphLaneLocationFragment;\nclass UZoneGraphSubsystem;\nclass UZoneGraphAnnotationSubsystem;\nclass UMassCrowdSubsystem;\n\n/**\n * Updates TargetLocation to a wander target based on the agents current location on ZoneGraph.\n */\nUSTRUCT()\nstruct MASSCROWD_API FMassZoneGraphFindWanderTargetInstanceData\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, Category = Output)\n\tFMassZoneGraphTargetLocation WanderTargetLocation;\n};\n\nUSTRUCT(meta = (DisplayName = \"ZG Find Wander Target\"))\nstruct MASSCROWD_API FMassZoneGraphFindWanderTarget : public FMassStateTreeTaskBase\n{\n\tGENERATED_BODY()\n\n\tusing FInstanceDataType = FMassZoneGraphFindWanderTargetInstanceData;\n\t\n\tFMassZoneGraphFindWanderTarget();\n\nprotected:\n\tvirtual bool Link(FStateTreeLinker& Linker) override;\n\tvirtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }\n\tvirtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;\n\n\tTStateTreeExternalDataHandle<FMassZoneGraphLaneLocationFragment> LocationHandle;\n\tTStateTreeExternalDataHandle<UZoneGraphSubsystem> ZoneGraphSubsystemHandle;\n\tTStateTreeExternalDataHandle<UZoneGraphAnnotationSubsystem> ZoneGraphAnnotationSubsystemHandle;\n\tTStateTreeExternalDataHandle<UMassCrowdSubsystem> MassCrowdSubsystemHandle;\n\n\tUPROPERTY(EditAnywhere, Category = Parameter)\n\tFZoneGraphTagFilter AllowedAnnotationTags;\n};\n",
      "lines": 48
    },
    {
      "file_path": "MassEntity\\Internal\\MassArchetypeData.h",
      "extension": ".h",
      "size_bytes": 21107,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityManager.h\"\n#include \"MassArchetypeTypes.h\"\n\n\nstruct FMassEntityQuery;\nstruct FMassExecutionContext;\nclass FOutputDevice;\nstruct FMassArchetypeEntityCollection;\n\nnamespace UE::Mass\n{\n\tint32 SanitizeChunkMemorySize(const int32 InChunkMemorySize, const bool bLogMismatch = true);\n}\n\n// This is one chunk within an archetype\nstruct FMassArchetypeChunk\n{\nprivate:\n\tuint8* RawMemory = nullptr;\n\tSIZE_T AllocSize = 0;\n\tint32 NumInstances = 0;\n\tint32 SerialModificationNumber = 0;\n\tTArray<FInstancedStruct> ChunkFragmentData;\n\tFMassArchetypeSharedFragmentValues SharedFragmentValues;\n\npublic:\n\texplicit FMassArchetypeChunk(const SIZE_T InAllocSize, TConstArrayView<FInstancedStruct> InChunkFragmentTemplates, FMassArchetypeSharedFragmentValues InSharedFragmentValues)\n\t\t: AllocSize(InAllocSize)\n\t\t, ChunkFragmentData(InChunkFragmentTemplates)\n\t\t, SharedFragmentValues(InSharedFragmentValues)\n\t{\n\t\tRawMemory = (uint8*)FMemory::Malloc(AllocSize);\n\t}\n\n\t~FMassArchetypeChunk()\n\t{\n\t\t// Only release memory if it was not done already.\n\t\tif (RawMemory != nullptr)\n\t\t{\n\t\t\tFMemory::Free(RawMemory);\n\t\t\tRawMemory = nullptr;\n\t\t}\n\t}\n\n\t// Returns the Entity array element at the specified index\n\tFMassEntityHandle& GetEntityArrayElementRef(int32 ChunkBase, int32 IndexWithinChunk)\n\t{\n\t\treturn ((FMassEntityHandle*)(RawMemory + ChunkBase))[IndexWithinChunk];\n\t}\n\n\tuint8* GetRawMemory() const\n\t{\n\t\treturn RawMemory;\n\t}\n\n\tint32 GetNumInstances() const\n\t{\n\t\treturn NumInstances;\n\t}\n\n\tvoid AddMultipleInstances(uint32 Count)\n\t{\n\t\tNumInstances += Count;\n\t\tSerialModificationNumber++;\n\t}\n\n\tvoid RemoveMultipleInstances(uint32 Count)\n\t{\n\t\tNumInstances -= Count;\n\t\tcheck(NumInstances >= 0);\n\t\tSerialModificationNumber++;\n\n\t\t// Because we only remove trailing chunks to avoid messing up the absolute indices in the entities map,\n\t\t// We are freeing the memory here to save memory\n\t\tif (NumInstances == 0)\n\t\t{\n\t\t\tFMemory::Free(RawMemory);\n\t\t\tRawMemory = nullptr;\n\t\t}\n\t}\n\n\tvoid AddInstance()\n\t{\n\t\tAddMultipleInstances(1);\n\t}\n\n\tvoid RemoveInstance()\n\t{\n\t\tRemoveMultipleInstances(1);\n\t}\n\n\tint32 GetSerialModificationNumber() const\n\t{\n\t\treturn SerialModificationNumber;\n\t}\n\n\tFStructView GetMutableChunkFragmentViewChecked(const int32 Index) { return FStructView(ChunkFragmentData[Index]); }\n\n\tFInstancedStruct* FindMutableChunkFragment(const UScriptStruct* Type)\n\t{\n\t\treturn ChunkFragmentData.FindByPredicate([Type](const FInstancedStruct& Element)\n\t\t\t{\n\t\t\t\treturn Element.GetScriptStruct()->IsChildOf(Type);\n\t\t\t});\n\t}\n\n\tvoid Recycle(TConstArrayView<FInstancedStruct> InChunkFragmentsTemplate, const FMassArchetypeSharedFragmentValues& InSharedFragmentValues)\n\t{\n\t\tcheckf(NumInstances == 0, TEXT(\"Recycling a chunk that is not empty.\"));\n\t\tSerialModificationNumber++;\n\t\tChunkFragmentData = InChunkFragmentsTemplate;\n\t\tSharedFragmentValues = InSharedFragmentValues;\n\t\t\n\t\t// If this chunk previously had entity and it does not anymore, we might have to reallocate the memory as it was freed to save memory\n\t\tif (RawMemory == nullptr)\n\t\t{\n\t\t\tRawMemory = (uint8*)FMemory::Malloc(AllocSize);\n\t\t}\n\t}\n\n\tbool IsValidSubChunk(const int32 StartIndex, const int32 Length) const\n\t{\n\t\treturn StartIndex >= 0 && StartIndex < NumInstances && (StartIndex + Length) <= NumInstances;\n\t}\n\n#if WITH_MASSENTITY_DEBUG\n\tint32 DebugGetChunkFragmentCount() const { return ChunkFragmentData.Num(); }\n#endif // WITH_MASSENTITY_DEBUG\n\n\tFMassArchetypeSharedFragmentValues& GetMutableSharedFragmentValues() { return SharedFragmentValues; }\n\tconst FMassArchetypeSharedFragmentValues& GetSharedFragmentValues() const { return SharedFragmentValues; }\n};\n\n// Information for a single fragment type in an archetype\nstruct FMassArchetypeFragmentConfig\n{\n\tconst UScriptStruct* FragmentType = nullptr;\n\tint32 ArrayOffsetWithinChunk = 0;\n\n\tvoid* GetFragmentData(uint8* ChunkBase, int32 IndexWithinChunk) const\n\t{\n\t\treturn ChunkBase + ArrayOffsetWithinChunk + (IndexWithinChunk * FragmentType->GetStructureSize());\n\t}\n};\n\n// An archetype is defined by a collection of unique fragment types (no duplicates).\n// Order doesn't matter, there will only ever be one FMassArchetypeData per unique set of fragment types per entity manager subsystem\nstruct FMassArchetypeData\n{\nprivate:\n\t// One-stop-shop variable describing the archetype's fragment and tag composition \n\tFMassArchetypeCompositionDescriptor CompositionDescriptor;\n\n\t// Pre-created default chunk fragment templates\n\tTArray<FInstancedStruct> ChunkFragmentsTemplate;\n\n\tTArray<FMassArchetypeFragmentConfig, TInlineAllocator<16>> FragmentConfigs;\n\t\n\tTArray<FMassArchetypeChunk> Chunks;\n\n\t// Entity ID to index within archetype\n\t//@TODO: Could be folded into FEntityData in the entity manager at the expense of a bit\n\t// of loss of encapsulation and extra complexity during archetype changes\n\tTMap<int32, int32> EntityMap;\n\t\n\tTMap<const UScriptStruct*, int32> FragmentIndexMap;\n\n\tint32 NumEntitiesPerChunk;\n\tSIZE_T TotalBytesPerEntity = 0;\n\tint32 EntityListOffsetWithinChunk;\n\n\t// Archetype version at which this archetype was created, useful for query to do incremental archetype matching\n\tuint32 CreatedArchetypeDataVersion = 0;\n\n#if WITH_MASSENTITY_DEBUG\n\t// Arrays of names the archetype is referred as.\n\tTArray<FName> DebugNames;\n#endif // WITH_MASSENTITY_DEBUG\n\n\t// Defaults to UMassEntitySettings.ChunkMemorySize. In near future will support being set via constructor.\n\tconst SIZE_T ChunkMemorySize = 0;\n\t\n\tfriend FMassEntityQuery;\n\tfriend FMassArchetypeEntityCollection;\n\tfriend FMassDebugger;\n\npublic:\n\texplicit FMassArchetypeData(const FMassArchetypeCreationParams& CreationParams = FMassArchetypeCreationParams());\n\n\tTConstArrayView<FMassArchetypeFragmentConfig> GetFragmentConfigs() const { return FragmentConfigs; }\n\tconst FMassFragmentBitSet& GetFragmentBitSet() const { return CompositionDescriptor.Fragments; }\n\tconst FMassTagBitSet& GetTagBitSet() const { return CompositionDescriptor.Tags; }\n\tconst FMassChunkFragmentBitSet& GetChunkFragmentBitSet() const { return CompositionDescriptor.ChunkFragments; }\n\tconst FMassSharedFragmentBitSet& GetSharedFragmentBitSet() const { return CompositionDescriptor.SharedFragments; }\n\tconst FMassConstSharedFragmentBitSet& GetConstSharedFragmentBitSet() const { return CompositionDescriptor.ConstSharedFragments; }\n\n\tconst FMassArchetypeCompositionDescriptor& GetCompositionDescriptor() const { return CompositionDescriptor; }\n\tFORCEINLINE const FMassArchetypeSharedFragmentValues& GetSharedFragmentValues(int32 EntityIndex) const\n\t{ \n\t\tconst int32 AbsoluteIndex = EntityMap.FindChecked(EntityIndex);\n\t\tconst int32 ChunkIndex = AbsoluteIndex / NumEntitiesPerChunk;\n\n\t\treturn Chunks[ChunkIndex].GetSharedFragmentValues();\n\t}\n\tFORCEINLINE const FMassArchetypeSharedFragmentValues& GetSharedFragmentValues(FMassEntityHandle Entity) const\n\t{\n\t\treturn GetSharedFragmentValues(Entity.Index);\n\t}\n\n\t/** Method to iterate on all the fragment types */\n\tvoid ForEachFragmentType(TFunction< void(const UScriptStruct* /*FragmentType*/)> Function) const;\n\tbool HasFragmentType(const UScriptStruct* FragmentType) const;\n\tbool HasTagType(const UScriptStruct* FragmentType) const { check(FragmentType); return CompositionDescriptor.Tags.Contains(*FragmentType); }\n\n\tbool IsEquivalent(const FMassArchetypeCompositionDescriptor& OtherCompositionDescriptor) const\n\t{\n\t\treturn CompositionDescriptor.IsEquivalent(OtherCompositionDescriptor);\n\t}\n\n\tvoid Initialize(const FMassArchetypeCompositionDescriptor& InCompositionDescriptor, const uint32 ArchetypeDataVersion);\n\n\t/** \n\t * A special way of initializing an archetype resulting in a copy of BaseArchetype's setup with OverrideTags\n\t * replacing original tags of BaseArchetype\n\t */\n\tvoid InitializeWithSimilar(const FMassArchetypeData& BaseArchetype, FMassArchetypeCompositionDescriptor&& NewComposition, const uint32 ArchetypeDataVersion);\n\n\tvoid AddEntity(FMassEntityHandle Entity, const FMassArchetypeSharedFragmentValues& InSharedFragmentValues);\n\tvoid RemoveEntity(FMassEntityHandle Entity);\n\n\tbool HasFragmentDataForEntity(const UScriptStruct* FragmentType, int32 EntityIndex) const;\n\tvoid* GetFragmentDataForEntityChecked(const UScriptStruct* FragmentType, int32 EntityIndex) const;\n\tvoid* GetFragmentDataForEntity(const UScriptStruct* FragmentType, int32 EntityIndex) const;\n\n\tFORCEINLINE const int32* GetInternalIndexForEntity(const int32 EntityIndex) const { return EntityMap.Find(EntityIndex); }\n\tFORCEINLINE int32 GetInternalIndexForEntityChecked(const int32 EntityIndex) const { return EntityMap.FindChecked(EntityIndex); }\n\tint32 GetNumEntitiesPerChunk() const { return NumEntitiesPerChunk; }\n\tSIZE_T GetBytesPerEntity() const { return TotalBytesPerEntity; }\n\n\tint32 GetNumEntities() const { return EntityMap.Num(); }\n\n\tSIZE_T GetChunkAllocSize() const { return ChunkMemorySize; }\n\n\tint32 GetChunkCount() const { return Chunks.Num(); }\n\tint32 GetNonEmptyChunkCount() const;\n\n\tuint32 GetCreatedArchetypeDataVersion() const { return CreatedArchetypeDataVersion; }\n\n\tvoid ExecuteFunction(FMassExecutionContext& RunContext, const FMassExecuteFunction& Function, const FMassQueryRequirementIndicesMapping& RequirementMapping\n\t\t, FMassArchetypeEntityCollection::FConstEntityRangeArrayView EntityRangeContainer, const FMassChunkConditionFunction& ChunkCondition);\n\tvoid ExecuteFunction(FMassExecutionContext& RunContext, const FMassExecuteFunction& Function, const FMassQueryRequirementIndicesMapping& RequirementMapping\n\t\t, const FMassChunkConditionFunction& ChunkCondition);\n\n\tvoid ExecutionFunctionForChunk(FMassExecutionContext& RunContext, const FMassExecuteFunction& Function, const FMassQueryRequirementIndicesMapping& RequirementMapping\n\t\t, const FMassArchetypeEntityCollection::FArchetypeEntityRange& EntityRange, const FMassChunkConditionFunction& ChunkCondition = FMassChunkConditionFunction());\n\n\t/**\n\t * Compacts entities to fill up chunks as much as possible\n\t * @return number of entities moved around\n\t */\n\tint32 CompactEntities(const double TimeAllowed);\n\n\t/**\n\t * Moves the entity from this archetype to another, will only copy all matching fragment types\n\t * @param Entity is the entity to move\n\t * @param NewArchetype the archetype to move to\n\t * @param SharedFragmentValuesOverride if provided will override all given Entity's shared fragment values\n\t */\n\tvoid MoveEntityToAnotherArchetype(const FMassEntityHandle Entity, FMassArchetypeData& NewArchetype, const FMassArchetypeSharedFragmentValues* SharedFragmentValuesOverride = nullptr);\n\n\t/**\n\t * Set all fragment sources data on specified entity, will check if there are fragment sources type that does not exist in the archetype\n\t * @param Entity is the entity to set the data of all fragments\n\t * @param FragmentSources are the fragments to copy the data from\n\t */\n\tvoid SetFragmentsData(const FMassEntityHandle Entity, TArrayView<const FInstancedStruct> FragmentSources);\n\n\t/** For all entities indicated by EntityCollection the function sets the value of fragment of type\n\t *  FragmentSource.GetScriptStruct to the value represented by FragmentSource.GetMemory */\n\tvoid SetFragmentData(FMassArchetypeEntityCollection::FConstEntityRangeArrayView EntityRangeContainer, const FInstancedStruct& FragmentSource);\n\n\t/** Returns conversion from given Requirements to archetype's fragment indices */\n\tvoid GetRequirementsFragmentMapping(TConstArrayView<FMassFragmentRequirementDescription> Requirements, FMassFragmentIndicesMapping& OutFragmentIndices) const;\n\n\t/** Returns conversion from given ChunkRequirements to archetype's chunk fragment indices */\n\tvoid GetRequirementsChunkFragmentMapping(TConstArrayView<FMassFragmentRequirementDescription> ChunkRequirements, FMassFragmentIndicesMapping& OutFragmentIndices) const;\n\n\t/** Returns conversion from given const shared requirements to archetype's const shared fragment indices */\n\tvoid GetRequirementsConstSharedFragmentMapping(TConstArrayView<FMassFragmentRequirementDescription> Requirements, FMassFragmentIndicesMapping& OutFragmentIndices) const;\n\n\t/** Returns conversion from given shared requirements to archetype's shared fragment indices */\n\tvoid GetRequirementsSharedFragmentMapping(TConstArrayView<FMassFragmentRequirementDescription> Requirements, FMassFragmentIndicesMapping& OutFragmentIndices) const;\n\n\tSIZE_T GetAllocatedSize() const;\n\n\t// Converts the list of fragments into a user-readable debug string\n\tFString DebugGetDescription() const;\n\n\t/** Copies debug names from another archetype data. */\n\tvoid CopyDebugNamesFrom(const FMassArchetypeData& Other)\n\t{ \n#if WITH_MASSENTITY_DEBUG\n\t\tDebugNames = Other.DebugNames; \n#endif // WITH_MASSENTITY_DEBUG\n\t}\n\n#if WITH_MASSENTITY_DEBUG\n\t/** Fetches how much memory is allocated for active chunks, and how much of that memory is actually occupied */\n\tvoid DebugGetEntityMemoryNumbers(SIZE_T& OutActiveChunksMemorySize, SIZE_T& OutActiveEntitiesMemorySize) const;\n\n\t/** Adds new debug name associated with the archetype. */\n\tvoid AddUniqueDebugName(const FName& Name) { DebugNames.AddUnique(Name); }\n\t\n\t/** @return array of debug names associated with this archetype. */\n\tconst TConstArrayView<FName> GetDebugNames() const { return DebugNames; }\n\t\n\t/** @return string of all debug names combined */\n\tFString GetCombinedDebugNamesAsString() const;\n\n\t/**\n\t * Prints out debug information about the archetype\n\t */\n\tvoid DebugPrintArchetype(FOutputDevice& Ar);\n\n\t/**\n\t * Prints out fragment's values for the specified entity. \n\t * @param Entity The entity for which we want to print fragment values\n\t * @param Ar The output device\n\t * @param InPrefix Optional prefix to remove from fragment names\n\t */\n\tvoid DebugPrintEntity(FMassEntityHandle Entity, FOutputDevice& Ar, const TCHAR* InPrefix = TEXT(\"\")) const;\n#endif // WITH_MASSENTITY_DEBUG\n\n\tvoid REMOVEME_GetArrayViewForFragmentInChunk(int32 ChunkIndex, const UScriptStruct* FragmentType, void*& OutChunkBase, int32& OutNumEntities);\n\n\t//////////////////////////////////////////////////////////////////////\n\t// low level api\n\tFORCEINLINE const int32* GetFragmentIndex(const UScriptStruct* FragmentType) const { return FragmentIndexMap.Find(FragmentType); }\n\tFORCEINLINE int32 GetFragmentIndexChecked(const UScriptStruct* FragmentType) const { return FragmentIndexMap.FindChecked(FragmentType); }\n\n\tFORCEINLINE void* GetFragmentData(const int32 FragmentIndex, const FMassRawEntityInChunkData EntityIndex) const\n\t{\n\t\treturn FragmentConfigs[FragmentIndex].GetFragmentData(EntityIndex.ChunkRawMemory, EntityIndex.IndexWithinChunk);\n\t}\n\n\tFORCEINLINE FMassRawEntityInChunkData MakeEntityHandle(int32 EntityIndex) const\n\t{\n\t\tconst int32 AbsoluteIndex = EntityMap.FindChecked(EntityIndex);\n\t\tconst int32 ChunkIndex = AbsoluteIndex / NumEntitiesPerChunk;\n\t\n\t\treturn FMassRawEntityInChunkData(Chunks[ChunkIndex].GetRawMemory(), AbsoluteIndex % NumEntitiesPerChunk); \n\t}\n\n\tFORCEINLINE FMassRawEntityInChunkData MakeEntityHandle(FMassEntityHandle Entity) const\n\t{\n\t\treturn MakeEntityHandle(Entity.Index); \n\t}\n\n\tbool IsInitialized() const { return TotalBytesPerEntity > 0 && FragmentConfigs.IsEmpty() == false; }\n\n\t//////////////////////////////////////////////////////////////////////\n\t// batched api\n\tvoid BatchDestroyEntityChunks(FMassArchetypeEntityCollection::FConstEntityRangeArrayView EntityRangeContainer, TArray<FMassEntityHandle>& OutEntitiesRemoved);\n\tvoid BatchAddEntities(TConstArrayView<FMassEntityHandle> Entities, const FMassArchetypeSharedFragmentValues& SharedFragmentValues\n\t\t, TArray<FMassArchetypeEntityCollection::FArchetypeEntityRange>& OutNewRanges);\n\t/** \n\t * @param SharedFragmentValuesOverride if provided will override shared fragment values for the entities being moved\n\t */\n\tvoid BatchMoveEntitiesToAnotherArchetype(const FMassArchetypeEntityCollection& EntityCollection, FMassArchetypeData& NewArchetype\n\t\t, TArray<FMassEntityHandle>& OutEntitiesBeingMoved, TArray<FMassArchetypeEntityCollection::FArchetypeEntityRange>* OutNewChunks = nullptr\n\t\t, const FMassArchetypeSharedFragmentValues* SharedFragmentValuesToAdd = nullptr\n\t\t, const FMassSharedFragmentBitSet* SharedFragmentToRemoveBitSet = nullptr\n\t\t, const FMassConstSharedFragmentBitSet* ConstSharedFragmentToRemoveBitSet = nullptr);\n\tvoid BatchSetFragmentValues(TConstArrayView<FMassArchetypeEntityCollection::FArchetypeEntityRange> EntityCollection, const FMassGenericPayloadViewSlice& Payload);\n\nprotected:\n\tFMassArchetypeEntityCollection::FArchetypeEntityRange PrepareNextEntitiesSpanInternal(TConstArrayView<FMassEntityHandle> Entities, const FMassArchetypeSharedFragmentValues& InSharedFragmentValues, const int32 StartingChunk = 0);\n\tvoid BatchRemoveEntitiesInternal(const int32 ChunkIndex, const int32 StartIndexWithinChunk, const int32 NumberToRemove);\n\n\tstruct FTransientChunkLocation\n\t{\n\t\tuint8* RawChunkMemory;\n\t\tint32 IndexWithinChunk;\n\t};\n\tvoid MoveFragmentsToAnotherArchetypeInternal(FMassArchetypeData& TargetArchetype, FTransientChunkLocation Target, const FTransientChunkLocation Source, const int32 ElementsNum);\n\tvoid MoveFragmentsToNewLocationInternal(FTransientChunkLocation Target, const FTransientChunkLocation Source, const int32 NumberToMove);\n\tvoid ConfigureFragments();\n\n\tFORCEINLINE void* GetFragmentData(const int32 FragmentIndex, uint8* ChunkRawMemory, const int32 IndexWithinChunk) const\n\t{\n\t\treturn FragmentConfigs[FragmentIndex].GetFragmentData(ChunkRawMemory, IndexWithinChunk);\n\t}\n\n\tvoid BindEntityRequirements(FMassExecutionContext& RunContext, const FMassFragmentIndicesMapping& EntityFragmentsMapping, FMassArchetypeChunk& Chunk, const int32 SubchunkStart, const int32 SubchunkLength);\n\tvoid BindChunkFragmentRequirements(FMassExecutionContext& RunContext, const FMassFragmentIndicesMapping& ChunkFragmentsMapping, FMassArchetypeChunk& Chunk);\n\tvoid BindConstSharedFragmentRequirements(FMassExecutionContext& RunContext, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, const FMassFragmentIndicesMapping& ChunkFragmentsMapping);\n\tvoid BindSharedFragmentRequirements(FMassExecutionContext& RunContext, FMassArchetypeSharedFragmentValues& SharedFragmentValues, const FMassFragmentIndicesMapping& ChunkFragmentsMapping);\n\n\t/**\n\t * The function first creates new FMassArchetypeSharedFragmentValues instance combining existing values\n\t * and the contents of SharedFragmentValueOverrides. Then that is used to find the target chunk for Entity,\n\t * and if one cannot be found a new one will be created. \n\t * @param SharedFragmentValueOverrides is expected to contain only instance of types already\n\t *    present in given archetypes FMassArchetypeSharedFragmentValues\n\t */\n\tvoid SetSharedFragmentsData(const FMassEntityHandle Entity, TConstArrayView<FSharedStruct> SharedFragmentValueOverrides);\n\n\tFMassArchetypeChunk& GetOrAddChunk(const FMassArchetypeSharedFragmentValues& SharedFragmentValues, int32& OutAbsoluteIndex, int32& OutIndexWithinChunk);\n\t\nprivate:\n\tint32 AddEntityInternal(FMassEntityHandle Entity, const FMassArchetypeSharedFragmentValues& InSharedFragmentValues);\n\tvoid RemoveEntityInternal(const int32 AbsoluteIndex);\n};\n\n\nstruct FMassArchetypeHelper\n{\n\tFORCEINLINE static FMassArchetypeData* ArchetypeDataFromHandle(const FMassArchetypeHandle& ArchetypeHandle) { return ArchetypeHandle.DataPtr.Get(); }\n\tFORCEINLINE static FMassArchetypeData& ArchetypeDataFromHandleChecked(const FMassArchetypeHandle& ArchetypeHandle)\n\t{\n\t\tcheck(ArchetypeHandle.IsValid());\n\t\treturn *ArchetypeHandle.DataPtr.Get();\n\t}\n\tFORCEINLINE static FMassArchetypeHandle ArchetypeHandleFromData(const TSharedPtr<FMassArchetypeData>& Archetype)\n\t{\n\t\treturn FMassArchetypeHandle(Archetype);\n\t}\n\n\t/**\n\t * Determines whether given Archetype matches given Requirements. In case of failure to match and if WITH_MASSENTITY_DEBUG\n\t * the function will also log the reasons for said failure (at VeryVerbose level).\n\t * @param bBailOutOnFirstFail if true will skip the remaining tests as soon as a single mismatch is detected. This option\n\t *\tis used when looking for matching archetypes. For debugging purposes use `false` to list all the mismatching elements.\n\t */\n#if WITH_MASSENTITY_DEBUG\n\tMASSENTITY_API static bool DoesArchetypeMatchRequirements(const FMassArchetypeData& Archetype, const FMassFragmentRequirements& Requirements\n\t\t, const bool bBailOutOnFirstFail = true, FOutputDevice* OutputDevice = nullptr);\n#endif // WITH_MASSENTITY_DEBUG\n\n\tMASSENTITY_API static bool DoesArchetypeMatchRequirements(const FMassArchetypeData& Archetype, const FMassFragmentRequirements& Requirements);\n\tMASSENTITY_API static bool DoesArchetypeMatchRequirements(const FMassArchetypeCompositionDescriptor& ArchetypeComposition, const FMassFragmentRequirements& Requirements);\n};\n",
      "lines": 446
    },
    {
      "file_path": "MassEntity\\Private\\MassEntityManagerConstants.h",
      "extension": ".h",
      "size_bytes": 237,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"HAL/Platform.h\"\n\nnamespace UE::Mass::Private\n{\n\t// Index 0 is a sentinel for an Empty/Unset EntityHandle\n\tconstexpr int32 InvalidEntityIndex = 0;\n};",
      "lines": 11
    },
    {
      "file_path": "MassEntity\\Public\\MassArchetypeTypes.h",
      "extension": ".h",
      "size_bytes": 9041,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"UObject/Class.h\"\n#include \"Containers/ArrayView.h\"\n#include \"Containers/StridedView.h\"\n#include \"Containers/UnrealString.h\"\n#include \"MassEntityTypes.h\"\n\nstruct FMassEntityManager;\nstruct FMassArchetypeData;\nstruct FMassExecutionContext;\nstruct FMassFragment;\nstruct FMassArchetypeChunkIterator;\nstruct FMassEntityQuery;\nstruct FMassArchetypeEntityCollection;\nstruct FMassEntityView;\nstruct FMassDebugger;\nstruct FMassArchetypeHelper;\n\ntypedef TFunction< void(FMassExecutionContext& /*ExecutionContext*/) > FMassExecuteFunction;\ntypedef TFunction< bool(const FMassExecutionContext& /*ExecutionContext*/) > FMassChunkConditionFunction;\n\n\n//////////////////////////////////////////////////////////////////////\n// FMassArchetypeHandle\n\n// An opaque handle to an archetype\nstruct FMassArchetypeHandle final\n{\n\tFMassArchetypeHandle() = default;\n\tbool IsValid() const { return DataPtr.IsValid(); }\n\n\tbool operator==(const FMassArchetypeHandle& Other) const { return DataPtr == Other.DataPtr; }\n\tbool operator!=(const FMassArchetypeHandle& Other) const { return DataPtr != Other.DataPtr; }\n\n\tMASSENTITY_API friend uint32 GetTypeHash(const FMassArchetypeHandle& Instance);\nprivate:\n\tFMassArchetypeHandle(const TSharedPtr<FMassArchetypeData>& InDataPtr)\n\t: DataPtr(InDataPtr)\n\t{}\n\tTSharedPtr<FMassArchetypeData> DataPtr;\n\n\tfriend FMassArchetypeHelper;\n\tfriend FMassEntityManager;\n};\n\n\n//////////////////////////////////////////////////////////////////////\n// FMassArchetypeEntityCollection \n\n/** A struct that converts an arbitrary array of entities of given Archetype into a sequence of continuous\n *  entity chunks. The goal is to have the user create an instance of this struct once and run through a bunch of\n *  systems. The runtime code usually uses FMassArchetypeChunkIterator to iterate on the chunk collection.\n */\nstruct MASSENTITY_API FMassArchetypeEntityCollection \n{\npublic:\n\tstruct FArchetypeEntityRange\n\t{\n\t\tint32 ChunkIndex = INDEX_NONE;\n\t\tint32 SubchunkStart = 0;\n\t\t/** negative or 0-length means \"all available entities within chunk\" */\n\t\tint32 Length = 0;\n\n\t\tFArchetypeEntityRange() = default;\n\t\texplicit FArchetypeEntityRange(const int32 InChunkIndex, const int32 InSubchunkStart = 0, const int32 InLength = 0) : ChunkIndex(InChunkIndex), SubchunkStart(InSubchunkStart), Length(InLength) {}\n\t\t/** Note that we consider invalid-length chunks valid as long as ChunkIndex and SubchunkStart are valid */\n\t\tbool IsSet() const { return ChunkIndex != INDEX_NONE && SubchunkStart >= 0; }\n\n\t\t/** Checks if given InRange comes right after this instance */\n\t\tbool IsAdjacentAfter(const FArchetypeEntityRange& Other) const\n\t\t{\n\t\t\treturn ChunkIndex == Other.ChunkIndex && SubchunkStart + Length == Other.SubchunkStart;\n\t\t}\n\n\t\tbool operator==(const FArchetypeEntityRange& Other) const\n\t\t{\n\t\t\treturn ChunkIndex == Other.ChunkIndex && SubchunkStart == Other.SubchunkStart && Length == Other.Length;\n\t\t}\n\t\tbool operator!=(const FArchetypeEntityRange& Other) const { return !(*this == Other); }\n\t};\n\n\tenum EDuplicatesHandling\n\t{\n\t\tNoDuplicates,\t// indicates that the caller guarantees there are no duplicates in the input Entities collection\n\t\t\t\t\t\t// note that in no-shipping builds a `check` will fail if duplicates are present.\n\t\tFoldDuplicates,\t// indicates that it's possible that Entities contains duplicates. The input Entities collection \n\t\t\t\t\t\t// will be processed and duplicates will be removed.\n\t};\n\n\tenum EInitializationType\n\t{\n\t\tGatherAll,\t// default behavior, makes given FMassArchetypeEntityCollection instance represent all entities of the given archetype\n\t\tDoNothing,\t// meant for procedural population by external code (like child classes)\n\t};\n\n\tusing FEntityRangeArray = TArray<FArchetypeEntityRange>;\n\tusing FConstEntityRangeArrayView = TConstArrayView<FArchetypeEntityRange>;\n\nprivate:\n\tFEntityRangeArray Ranges;\n\t/** entity indices indicated by EntityRanges are only valid with given Archetype */\n\tFMassArchetypeHandle Archetype;\n\npublic:\n\tFMassArchetypeEntityCollection() = default;\n\tFMassArchetypeEntityCollection(const FMassArchetypeHandle& InArchetype, TConstArrayView<FMassEntityHandle> InEntities, EDuplicatesHandling DuplicatesHandling);\n\texplicit FMassArchetypeEntityCollection(const FMassArchetypeHandle& InArchetypeHandle, const EInitializationType Initialization = EInitializationType::GatherAll);\n\texplicit FMassArchetypeEntityCollection(TSharedPtr<FMassArchetypeData>& InArchetype, const EInitializationType Initialization = EInitializationType::GatherAll);\n\tFMassArchetypeEntityCollection(const FMassArchetypeHandle& InArchetypeHandle, FEntityRangeArray&& InEntityRanges)\n\t\t: Ranges(MoveTemp(InEntityRanges))\n\t\t, Archetype(InArchetypeHandle)\n\t{}\n\n\tFConstEntityRangeArrayView GetRanges() const { return Ranges; }\n\tconst FMassArchetypeHandle& GetArchetype() const { return Archetype; }\n\tbool IsEmpty() const { return Ranges.Num() == 0 && Archetype.IsValid() == false; }\n\tbool IsSet() const { return Archetype.IsValid(); }\n\tvoid Reset() \n\t{ \n\t\tArchetype = FMassArchetypeHandle();\n\t\tRanges.Reset();\n\t}\n\n\t/** The comparison function that checks if Other is identical to this. Intended for diagnostics/debugging. */\n\tbool IsSame(const FMassArchetypeEntityCollection& Other) const;\n\nprotected:\n\tfriend struct FMassArchetypeEntityCollectionWithPayload;\n\tvoid BuildEntityRanges(TStridedView<const int32> TrueIndices);\n\t\nprivate:\n\tvoid GatherChunksFromArchetype();\n};\n\nstruct MASSENTITY_API FMassArchetypeEntityCollectionWithPayload\n{\n\texplicit FMassArchetypeEntityCollectionWithPayload(const FMassArchetypeEntityCollection& InEntityCollection)\n\t\t: Entities(InEntityCollection)\n\t{\n\t}\n\n\tstatic void CreateEntityRangesWithPayload(const FMassEntityManager& EntitySubsystem, const TConstArrayView<FMassEntityHandle> Entities\n\t\t, const FMassArchetypeEntityCollection::EDuplicatesHandling DuplicatesHandling, FMassGenericPayloadView Payload\n\t\t, TArray<FMassArchetypeEntityCollectionWithPayload>& OutEntityCollections);\n\n\tconst FMassArchetypeEntityCollection& GetEntityCollection() const { return Entities; }\n\tconst FMassGenericPayloadViewSlice& GetPayload() const { return PayloadSlice; }\n\nprivate:\n\tFMassArchetypeEntityCollectionWithPayload(const FMassArchetypeHandle& InArchetype, TStridedView<const int32> TrueIndices, FMassGenericPayloadViewSlice&& Payload);\n\n\tFMassArchetypeEntityCollection Entities;\n\tFMassGenericPayloadViewSlice PayloadSlice;\n};\n\n//////////////////////////////////////////////////////////////////////\n// FMassArchetypeChunkIterator\n\n/**\n *  The type used to iterate over given archetype's chunks, be it full, continuous chunks or sparse subchunks. It hides\n *  this details from the rest of the system.\n */\nstruct MASSENTITY_API FMassArchetypeChunkIterator\n{\nprivate:\n\tFMassArchetypeEntityCollection::FConstEntityRangeArrayView EntityRanges;\n\tint32 CurrentChunkIndex = 0;\n\npublic:\n\texplicit FMassArchetypeChunkIterator(const FMassArchetypeEntityCollection::FConstEntityRangeArrayView& InEntityRanges) : EntityRanges(InEntityRanges), CurrentChunkIndex(0) {}\n\n\toperator bool() const { return EntityRanges.IsValidIndex(CurrentChunkIndex) && EntityRanges[CurrentChunkIndex].IsSet(); }\n\tFMassArchetypeChunkIterator& operator++() { ++CurrentChunkIndex; return *this; }\n\n\tconst FMassArchetypeEntityCollection::FArchetypeEntityRange* operator->() const { check(bool(*this)); return &EntityRanges[CurrentChunkIndex]; }\n\tconst FMassArchetypeEntityCollection::FArchetypeEntityRange& operator*() const { check(bool(*this)); return EntityRanges[CurrentChunkIndex]; }\n};\n\n//////////////////////////////////////////////////////////////////////\n// FMassRawEntityInChunkData\n\nstruct FMassRawEntityInChunkData \n{\n\tFMassRawEntityInChunkData() = default;\n\tFMassRawEntityInChunkData(uint8* InChunkRawMemory, const int32 InIndexWithinChunk)\n        : ChunkRawMemory(InChunkRawMemory), IndexWithinChunk(InIndexWithinChunk)\n\t{}\n\tbool IsValid() const { return ChunkRawMemory != nullptr && IndexWithinChunk != INDEX_NONE; }\n\tbool operator==(const FMassRawEntityInChunkData & Other) const { return ChunkRawMemory == Other.ChunkRawMemory && IndexWithinChunk == Other.IndexWithinChunk; }\n\n\tuint8* ChunkRawMemory = nullptr;\n\tint32 IndexWithinChunk = INDEX_NONE;\n};\n\n//////////////////////////////////////////////////////////////////////\n// FMassQueryRequirementIndicesMapping\n\nusing FMassFragmentIndicesMapping = TArray<int32, TInlineAllocator<16>>;\n\nstruct FMassQueryRequirementIndicesMapping\n{\n\tFMassQueryRequirementIndicesMapping() = default;\n\n\tFMassFragmentIndicesMapping EntityFragments;\n\tFMassFragmentIndicesMapping ChunkFragments;\n\tFMassFragmentIndicesMapping ConstSharedFragments;\n\tFMassFragmentIndicesMapping SharedFragments;\n\tFORCEINLINE bool IsEmpty() const\n\t{\n\t\treturn EntityFragments.Num() == 0 || ChunkFragments.Num() == 0;\n\t}\n};\n",
      "lines": 215
    },
    {
      "file_path": "MassEntity\\Public\\MassCommandBuffer.h",
      "extension": ".h",
      "size_bytes": 8469,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassEntityManager.h\"\n#include \"Misc/MTAccessDetector.h\"\n#include \"MassEntityUtils.h\"\n#include \"MassCommands.h\"\n\n//@TODO: Consider debug information in case there is an assert when replaying the command buffer\n// (e.g., which system added the command, or even file/line number in development builds for the specific call via a macro)\n\n#define COMMAND_PUSHING_CHECK() \\\ncheckf(IsFlushing() == false, TEXT(\"Trying to push commands is not supported while the given buffer is being flushed\")); \\\ncheckf(OwnerThreadId == FPlatformTLS::GetCurrentThreadId(), TEXT(\"Commands can be pushed only in the same thread where the command buffer was created.\"))\n\nstruct MASSENTITY_API FMassCommandBuffer\n{\npublic:\n\tFMassCommandBuffer();\n\t~FMassCommandBuffer();\n\n\t/** Adds a new entry to a given TCommand batch command instance */\n\ttemplate< template<typename... TArgs> typename TCommand, typename... TArgs >\n\tvoid PushCommand(const FMassEntityHandle Entity, TArgs&&... InArgs)\n\t{\n\t\tCOMMAND_PUSHING_CHECK();\n\n\t\tLLM_SCOPE_BYNAME(TEXT(\"Mass/PushCommand\"));\n\t\tTCommand<TArgs...>& Instance = CreateOrAddCommand<TCommand<TArgs...>>();\n\t\tInstance.Add(Entity, Forward<TArgs>(InArgs)...);\n\t\t++ActiveCommandsCounter;\n\t}\n\n\ttemplate<typename TCommand, typename... TArgs>\n\tvoid PushCommand(TArgs&&... InArgs)\n\t{\n\t\tCOMMAND_PUSHING_CHECK();\n\n\t\tLLM_SCOPE_BYNAME(TEXT(\"Mass/PushCommand\"));\n\t\tTCommand& Instance = CreateOrAddCommand<TCommand>();\n\t\tInstance.Add(Forward<TArgs>(InArgs)...);\n\t\t++ActiveCommandsCounter;\n\t}\n\n\t/** Adds a new entry to a given TCommand batch command instance */\n\ttemplate< typename TCommand>\n\tvoid PushCommand(const FMassEntityHandle Entity)\n\t{\n\t\tCOMMAND_PUSHING_CHECK();\n\n\t\tLLM_SCOPE_BYNAME(TEXT(\"Mass/PushCommand\"));\n\t\tCreateOrAddCommand<TCommand>().Add(Entity);\n\t\t++ActiveCommandsCounter;\n\t}\n\n\ttemplate< typename TCommand>\n\tvoid PushCommand(TConstArrayView<FMassEntityHandle> Entities)\n\t{\n\t\tCOMMAND_PUSHING_CHECK();\n\n\t\tLLM_SCOPE_BYNAME(TEXT(\"Mass/PushCommand\"));\n\t\tCreateOrAddCommand<TCommand>().Add(Entities);\n\t\t++ActiveCommandsCounter;\n\t}\n\n\ttemplate<typename T>\n\tvoid AddFragment(FMassEntityHandle Entity)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassFragment>::IsDerived, \"Given struct type is not a valid fragment type.\");\n\t\tPushCommand<FMassCommandAddFragmentsInternal<EMassCommandCheckTime::CompileTimeCheck, T>>(Entity);\n\t}\n\n\ttemplate<typename T>\n\tvoid AddFragment_RuntimeCheck(FMassEntityHandle Entity)\n\t{\n\t\tcheckf(T::StaticStruct()->IsChildOf(FMassFragment::StaticStruct()), TEXT(\"Given struct type is not a valid fragment type.\"));\n\t\tPushCommand<FMassCommandAddFragmentsInternal<EMassCommandCheckTime::RuntimeCheck, T>>(Entity);\n\t}\n\n\ttemplate<typename T>\n\tvoid RemoveFragment(FMassEntityHandle Entity)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassFragment>::IsDerived, \"Given struct type is not a valid fragment type.\");\n\t\tPushCommand<FMassCommandRemoveFragmentsInternal<EMassCommandCheckTime::CompileTimeCheck, T>>(Entity);\n\t}\n\n\ttemplate<typename T>\n\tvoid RemoveFragment_RuntimeCheck(FMassEntityHandle Entity)\n\t{\n\t\tcheckf(T::StaticStruct()->IsChildOf(FMassFragment::StaticStruct()), TEXT(\"Given struct type is not a valid fragment type.\"));\n\t\tPushCommand<FMassCommandRemoveFragmentsInternal<EMassCommandCheckTime::RuntimeCheck, T>>(Entity);\n\t}\n\n\t/** the convenience function equivalent to calling PushCommand<FMassCommandAddTag<T>>(Entity) */\n\ttemplate<typename T>\n\tvoid AddTag(FMassEntityHandle Entity)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassTag>::IsDerived, \"Given struct type is not a valid tag type.\");\n\t\tPushCommand<FMassCommandAddTagsInternal<EMassCommandCheckTime::CompileTimeCheck, T>>(Entity);\n\t}\n\n\ttemplate<typename T>\n\tvoid AddTag_RuntimeCheck(FMassEntityHandle Entity)\n\t{\n\t\tcheckf(T::StaticStruct()->IsChildOf(FMassTag::StaticStruct()), TEXT(\"Given struct type is not a valid tag type.\"));\n\t\tPushCommand<FMassCommandAddTagsInternal<EMassCommandCheckTime::RuntimeCheck, T>>(Entity);\n\t}\n\n\t/** the convenience function equivalent to calling PushCommand<FMassCommandRemoveTag<T>>(Entity) */\n\ttemplate<typename T>\n\tvoid RemoveTag(FMassEntityHandle Entity)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassTag>::IsDerived, \"Given struct type is not a valid tag type.\");\n\t\tPushCommand<FMassCommandRemoveTagsInternal<EMassCommandCheckTime::CompileTimeCheck, T>>(Entity);\n\t}\n\n\ttemplate<typename T>\n\tvoid RemoveTag_RuntimeCheck(FMassEntityHandle Entity)\n\t{\n\t\tcheckf(T::StaticStruct()->IsChildOf(FMassTag::StaticStruct()), TEXT(\"Given struct type is not a valid tag type.\"));\n\t\tPushCommand<FMassCommandRemoveTagsInternal<EMassCommandCheckTime::RuntimeCheck, T>>(Entity);\n\t}\n\n\t/** the convenience function equivalent to calling PushCommand<FMassCommandSwapTags<TOld, TNew>>(Entity)  */\n\ttemplate<typename TOld, typename TNew>\n\tvoid SwapTags(FMassEntityHandle Entity)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<TOld, FMassTag>::IsDerived, \"Given struct type is not a valid tag type.\");\n\t\tstatic_assert(TIsDerivedFrom<TNew, FMassTag>::IsDerived, \"Given struct type is not a valid tag type.\");\n\t\tPushCommand<FMassCommandSwapTagsInternal<EMassCommandCheckTime::CompileTimeCheck, TOld, TNew>>(Entity);\n\t}\n\n\ttemplate<typename TOld, typename TNew>\n\tvoid SwapTags_RuntimeCheck(FMassEntityHandle Entity)\n\t{\n\t\tcheckf(TOld::StaticStruct()->IsChildOf(FMassTag::StaticStruct()), TEXT(\"Given struct type is not a valid tag type.\"));\n\t\tcheckf(TNew::StaticStruct()->IsChildOf(FMassTag::StaticStruct()), TEXT(\"Given struct type is not a valid tag type.\"));\n\t\tPushCommand<FMassCommandSwapTagsInternal<EMassCommandCheckTime::RuntimeCheck, TOld, TNew>>(Entity);\n\t}\n\n\tvoid DestroyEntity(FMassEntityHandle Entity)\n\t{\n\t\tPushCommand<FMassCommandDestroyEntities>(Entity);\n\t}\n\n\tvoid DestroyEntities(TConstArrayView<FMassEntityHandle> InEntitiesToDestroy)\n\t{\n\t\tPushCommand<FMassCommandDestroyEntities>(InEntitiesToDestroy);\n\t}\n\n\tSIZE_T GetAllocatedSize() const;\n\n\t/** \n\t * Appends the commands from the passed buffer into this one\n\t * @param InOutOther the source buffer to copy the commands from. Note that after the call the InOutOther will be \n\t *\temptied due to the function using Move semantics\n\t */\n\tvoid MoveAppend(FMassCommandBuffer& InOutOther);\n\n\tbool HasPendingCommands() const \n\t{\n\t\treturn ActiveCommandsCounter > 0;\n\t}\n\tbool IsFlushing() const { return bIsFlushing; }\n\nprivate:\n\tfriend FMassEntityManager;\n\n\tvoid ForceUpdateCurrentThreadID();\n\n\ttemplate<typename T>\n\tT& CreateOrAddCommand()\n\t{\n\t\tconst int32 Index = FMassBatchedCommand::GetCommandIndex<T>();\n\n\t\tif (CommandInstances.IsValidIndex(Index) == false)\n\t\t{\n\t\t\tCommandInstances.AddZeroed(Index - CommandInstances.Num() + 1);\n\t\t}\n\t\telse if (CommandInstances[Index])\n\t\t{\n\t\t\treturn (T&)(*CommandInstances[Index].Get());\n\t\t}\n\n\t\tCommandInstances[Index] = MakeUnique<T>();\n\t\treturn (T&)(*CommandInstances[Index].Get());\n\t}\n\n\t/** \n\t * Executes all accumulated commands. \n\t * @return whether any commands have actually been executed\n\t */\n\tbool Flush(FMassEntityManager& EntityManager);\n\tvoid CleanUp();\n\n\tFCriticalSection AppendingCommandsCS;\n\n\tUE_MT_DECLARE_RW_ACCESS_DETECTOR(PendingBatchCommandsDetector);\n\t/** \n\t * Commands created for this specific command buffer. All commands in the array are unique (by type) and reusable \n\t * with subsequent PushCommand calls\n\t */\n\tTArray<TUniquePtr<FMassBatchedCommand>> CommandInstances;\n\t/** \n\t * Commands appended to this command buffer (via FMassCommandBuffer::MoveAppend). These commands are just naive list\n\t * of commands, potentially containing duplicates with multiple MoveAppend calls. Once appended these commands are \n\t * not being reused and consumed, destructively, during flushing\n\t */\n\tTArray<TUniquePtr<FMassBatchedCommand>> AppendedCommandInstances;\n\n\tint32 ActiveCommandsCounter = 0;\n\n\t/** Indicates that this specific MassCommandBuffer is currently flushing its contents */\n\tbool bIsFlushing = false;\n\n\t/** \n\t * Identifies the thread where given FMassCommandBuffer instance was created. Adding commands from other\n\t * threads is not supported and we use this value to check that.\n\t * Note that it could be const since we set it in the constructor, but we need to recache on server forking.\n\t */\n\tuint32 OwnerThreadId;\n};\n\n#undef COMMAND_PUSHING_CHECK\n",
      "lines": 226
    },
    {
      "file_path": "MassEntity\\Public\\MassCommands.h",
      "extension": ".h",
      "size_bytes": 20391,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"ProfilingDebugging/CsvProfilerConfig.h\"\n#include \"Misc/MTAccessDetector.h\"\n#include \"MassEntityTypes.h\"\n#include \"MassEntityUtils.h\"\n#include \"MassEntityManager.h\"\n\n#include \"MassCommands.generated.h\"\n\n/**\n * Enum used by MassBatchCommands to declare their \"type\". This data is later used to group commands so that command \n * effects are applied in a controllable fashion \n * Important: if changed make sure to update FMassCommandBuffer::Flush.CommandTypeOrder as well\n */\nUENUM()\nenum class EMassCommandOperationType : uint8\n{\n\tNone,\t\t\t\t// default value. Commands marked this way will be always executed last. Programmers are encouraged to instead use one of the meaningful values below.\n\tCreate,\t\t\t\t// signifies commands performing entity creation\n\tAdd,\t\t\t\t// signifies commands adding fragments or tags to entities\n\tRemove,\t\t\t\t// signifies commands removing fragments or tags from entities\n\tChangeComposition,\t// signifies commands both adding and removing fragments and/or tags from entities\n\tSet,\t\t\t\t// signifies commands setting values to pre-existing fragments. The fragments might be added if missing,\n\t\t\t\t\t\t// depending on specific command, so this group will always be executed after the Add group\n\tDestroy,\t\t\t// signifies commands removing entities\n\tMAX\n};\n\nenum class EMassCommandCheckTime : bool\n{\n\tRuntimeCheck = true,\n\tCompileTimeCheck = false\n};\n\n#if CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG\n#\tdefine DEBUG_NAME(Name) , FName(TEXT(Name))\n#\tdefine DEBUG_NAME_PARAM(Name) , const FName InDebugName = TEXT(Name)\n#\tdefine FORWARD_DEBUG_NAME_PARAM , InDebugName\n#else\n#\tdefine DEBUG_NAME(Name)\n#\tdefine DEBUG_NAME_PARAM(Name)\n#\tdefine FORWARD_DEBUG_NAME_PARAM\n#endif // CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG\n\nnamespace UE::Mass::Utils\n{\n\ttemplate<typename BitSetType, EMassCommandCheckTime CheckTime, typename... TTypes>\n\tBitSetType ConstructBitSet()\n\t{\n\t\tif constexpr (CheckTime == EMassCommandCheckTime::RuntimeCheck)\n\t\t{\n\t\t\treturn BitSetType({ TTypes::StaticStruct()... });\n\t\t}\n\t\telse\n\t\t{\n\t\t\tBitSetType Result;\n\t\t\tUE::Mass::TMultiTypeList<TTypes...>::PopulateBitSet(Result);\n\t\t\treturn Result;\n\t\t}\n\t}\n\n\ttemplate<EMassCommandCheckTime CheckTime, typename... TTypes>\n\tFMassFragmentBitSet ConstructFragmentBitSet()\n\t{\n\t\treturn ConstructBitSet<FMassFragmentBitSet, CheckTime, TTypes...>();\n\t}\n\n\ttemplate<EMassCommandCheckTime CheckTime, typename... TTypes>\n\tFMassTagBitSet ConstructTagBitSet()\n\t{\n\t\treturn ConstructBitSet<FMassTagBitSet, CheckTime, TTypes...>();\n\t}\n} // namespace UE::Mass::Utils\n\nstruct MASSENTITY_API FMassBatchedCommand\n{\n\tFMassBatchedCommand() = default;\n\texplicit FMassBatchedCommand(EMassCommandOperationType OperationType)\n\t\t: OperationType(OperationType)\n\t{}\n#if CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG\n\tFMassBatchedCommand(EMassCommandOperationType OperationType, FName DebugName)\n\t\t: OperationType(OperationType)\n\t\t, DebugName(DebugName)\n\t{}\n#endif // CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG\n\tvirtual ~FMassBatchedCommand() { Reset(); }\n\n\tvirtual void Execute(FMassEntityManager& System) const = 0;\n\tvirtual void Reset()\n\t{\n\t\tbHasWork = false;\n\t}\n\n\tbool HasWork() const { return bHasWork; }\n\tEMassCommandOperationType GetOperationType() const { return OperationType; }\n\n\ttemplate<typename T>\n\tstatic uint32 GetCommandIndex()\n\t{\n\t\tstatic const uint32 ThisTypesStaticIndex = CommandsCounter++;\n\t\treturn ThisTypesStaticIndex;\n\t}\n\n\tvirtual SIZE_T GetAllocatedSize() const = 0;\n\n#if CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG\n\tvirtual int32 GetNumOperationsStat() const = 0;\n\tFName GetFName() const { return DebugName; }\n#endif // CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG\n\nprotected:\n\t// @todo note for reviewers - I could use an opinion if having a virtual function per-command would be a more \n\t// preferable way of asking commands if there's anything to do.\n\tbool bHasWork = false;\n\tEMassCommandOperationType OperationType = EMassCommandOperationType::None;\n\n#if CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG\n\tFName DebugName;\n#endif // CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG\n\nprivate:\n\tstatic std::atomic<uint32> CommandsCounter;\n};\n\nstruct FMassBatchedEntityCommand : public FMassBatchedCommand\n{\n\tusing Super = FMassBatchedCommand;\n\n\tFMassBatchedEntityCommand() = default;\n\texplicit FMassBatchedEntityCommand(EMassCommandOperationType OperationType DEBUG_NAME_PARAM(\"BatchedEntityCommand\"))\n\t\t: Super(OperationType FORWARD_DEBUG_NAME_PARAM)\n\t{}\n\n\tvoid Add(FMassEntityHandle Entity)\n\t{\n\t\tUE_MT_SCOPED_WRITE_ACCESS(EntitiesAccessDetector);\n\t\tTargetEntities.Add(Entity);\n\t\tbHasWork = true;\n\t}\n\n\tvoid Add(TConstArrayView<FMassEntityHandle> Entities)\n\t{\n\t\tUE_MT_SCOPED_WRITE_ACCESS(EntitiesAccessDetector);\n\t\tTargetEntities.Append(Entities.GetData(), Entities.Num());\n\t\tbHasWork = true;\n\t}\n\nprotected:\n\tvirtual SIZE_T GetAllocatedSize() const\n\t{\n\t\treturn TargetEntities.GetAllocatedSize();\n\t}\n\n\tvirtual void Reset() override\n\t{\n\t\tTargetEntities.Reset();\n\t\tSuper::Reset();\n\t}\n\n#if CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG\n\tvirtual int32 GetNumOperationsStat() const override { return TargetEntities.Num(); }\n#endif // CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG\n\n\tUE_MT_DECLARE_RW_ACCESS_DETECTOR(EntitiesAccessDetector); \n\tTArray<FMassEntityHandle> TargetEntities;\n};\n\n//////////////////////////////////////////////////////////////////////\n// Entity destruction\n\nstruct FMassCommandDestroyEntities : public FMassBatchedEntityCommand\n{\n\tusing Super = FMassBatchedEntityCommand;\n\n\tFMassCommandDestroyEntities()\n\t\t: Super(EMassCommandOperationType::Destroy DEBUG_NAME(\"DestroyEntities\"))\n\t{\n\t}\n\nprotected:\n\tvirtual void Execute(FMassEntityManager& System) const override\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(MassCommandDestroyEntities_Execute);\n\n\t\tTArray<FMassArchetypeEntityCollection> EntityCollectionsToDestroy;\n\t\tUE::Mass::Utils::CreateEntityCollections(System, TargetEntities, FMassArchetypeEntityCollection::FoldDuplicates, EntityCollectionsToDestroy);\n\t\tSystem.BatchDestroyEntityChunks(EntityCollectionsToDestroy);\n\t}\n};\n\n//////////////////////////////////////////////////////////////////////\n// Simple fragment composition change\n\ntemplate<EMassCommandCheckTime CheckTime, typename... TTypes>\nstruct FMassCommandAddFragmentsInternal : public FMassBatchedEntityCommand\n{\n\tusing Super = FMassBatchedEntityCommand;\n\tFMassCommandAddFragmentsInternal()\n\t\t: Super(EMassCommandOperationType::Add DEBUG_NAME(\"AddFragments\"))\n\t\t, FragmentsAffected(UE::Mass::Utils::ConstructFragmentBitSet<CheckTime, TTypes...>())\n\t{}\n\nprotected:\n\tvirtual void Execute(FMassEntityManager& System) const override\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(MassCommandAddFragments_Execute);\n\t\tTArray<FMassArchetypeEntityCollection> EntityCollections;\n\t\tUE::Mass::Utils::CreateEntityCollections(System, TargetEntities, FMassArchetypeEntityCollection::FoldDuplicates, EntityCollections);\n\t\tSystem.BatchChangeFragmentCompositionForEntities(EntityCollections, FragmentsAffected, FMassFragmentBitSet());\n\t}\n\tFMassFragmentBitSet FragmentsAffected;\n};\n\ntemplate<typename... TTypes>\nusing FMassCommandAddFragments = FMassCommandAddFragmentsInternal<EMassCommandCheckTime::CompileTimeCheck, TTypes...>;\n\ntemplate<EMassCommandCheckTime CheckTime, typename... TTypes>\nstruct FMassCommandRemoveFragmentsInternal : public FMassBatchedEntityCommand\n{\n\tusing Super = FMassBatchedEntityCommand;\n\tFMassCommandRemoveFragmentsInternal()\n\t\t: Super(EMassCommandOperationType::Remove DEBUG_NAME(\"RemoveFragments\"))\n\t\t, FragmentsAffected(UE::Mass::Utils::ConstructFragmentBitSet<CheckTime, TTypes...>())\n\t{}\n\nprotected:\n\tvirtual void Execute(FMassEntityManager& System) const override\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(MassCommandRemoveFragments_Execute);\n\t\tTArray<FMassArchetypeEntityCollection> EntityCollections;\n\t\tUE::Mass::Utils::CreateEntityCollections(System, TargetEntities, FMassArchetypeEntityCollection::FoldDuplicates, EntityCollections);\n\t\tSystem.BatchChangeFragmentCompositionForEntities(EntityCollections, FMassFragmentBitSet(), FragmentsAffected);\n\t}\n\tFMassFragmentBitSet FragmentsAffected;\n};\n\ntemplate<typename... TTypes>\nusing FMassCommandRemoveFragments = FMassCommandRemoveFragmentsInternal<EMassCommandCheckTime::CompileTimeCheck, TTypes...>;\n\n//////////////////////////////////////////////////////////////////////\n// Simple tag composition change\n\nstruct FMassCommandChangeTags : public FMassBatchedEntityCommand\n{\n\tusing Super = FMassBatchedEntityCommand;\n\tFMassCommandChangeTags()\n\t\t: Super(EMassCommandOperationType::ChangeComposition DEBUG_NAME(\"ChangeTags\"))\n\t{}\n\n\tFMassCommandChangeTags(EMassCommandOperationType OperationType, FMassTagBitSet TagsToAdd, FMassTagBitSet TagsToRemove DEBUG_NAME_PARAM(\"ChangeTags\"))\n\t\t: Super(OperationType FORWARD_DEBUG_NAME_PARAM)\n\t\t, TagsToAdd(TagsToAdd)\n\t\t, TagsToRemove(TagsToRemove)\n\t{}\n\nprotected:\n\tvirtual void Execute(FMassEntityManager& System) const override\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(MassCommandChangeTags_Execute);\n\t\tTArray<FMassArchetypeEntityCollection> EntityCollections;\n\t\tUE::Mass::Utils::CreateEntityCollections(System, TargetEntities, FMassArchetypeEntityCollection::FoldDuplicates, EntityCollections);\n\n\t\tSystem.BatchChangeTagsForEntities(EntityCollections, TagsToAdd, TagsToRemove);\n\t}\n\n\tvirtual SIZE_T GetAllocatedSize() const override\n\t{\n\t\treturn TagsToAdd.GetAllocatedSize() + TagsToRemove.GetAllocatedSize() + Super::GetAllocatedSize();\n\t}\n\n\tFMassTagBitSet TagsToAdd;\n\tFMassTagBitSet TagsToRemove;\n};\n\ntemplate<EMassCommandCheckTime CheckTime, typename... TTypes>\nstruct FMassCommandAddTagsInternal : public FMassCommandChangeTags\n{\n\tusing Super = FMassCommandChangeTags;\n\tFMassCommandAddTagsInternal()\n\t\t: Super(\n\t\t\tEMassCommandOperationType::Add, \n\t\t\tUE::Mass::Utils::ConstructTagBitSet<CheckTime, TTypes...>(),\n\t\t\t{} \n\t\t\tDEBUG_NAME(\"AddTags\"))\n\t{}\n};\n\ntemplate<typename T>\nusing FMassCommandAddTag = FMassCommandAddTagsInternal<EMassCommandCheckTime::CompileTimeCheck, T>;\n\ntemplate<typename... TTypes>\nusing FMassCommandAddTags = FMassCommandAddTagsInternal<EMassCommandCheckTime::CompileTimeCheck, TTypes...>;\n\ntemplate<EMassCommandCheckTime CheckTime, typename... TTypes>\nstruct FMassCommandRemoveTagsInternal : public FMassCommandChangeTags\n{\n\tusing Super = FMassCommandChangeTags;\n\tFMassCommandRemoveTagsInternal()\n\t\t: Super(\n\t\t\tEMassCommandOperationType::Remove, \n\t\t\t{}, \n\t\t\tUE::Mass::Utils::ConstructTagBitSet<CheckTime, TTypes...>()\n\t\t\tDEBUG_NAME(\"RemoveTags\"))\n\t{}\n};\n\ntemplate<typename T>\nusing FMassCommandRemoveTag = FMassCommandRemoveTagsInternal<EMassCommandCheckTime::CompileTimeCheck, T>;\n\ntemplate<typename... TTypes>\nusing FMassCommandRemoveTags = FMassCommandRemoveTagsInternal<EMassCommandCheckTime::CompileTimeCheck, TTypes...>;\n\ntemplate<EMassCommandCheckTime CheckTime, typename TOld, typename TNew>\nstruct FMassCommandSwapTagsInternal : public FMassCommandChangeTags\n{\n\tusing Super = FMassCommandChangeTags;\n\tFMassCommandSwapTagsInternal()\n\t\t: Super(\n\t\t\tEMassCommandOperationType::ChangeComposition,\n\t\t\tUE::Mass::Utils::ConstructTagBitSet<CheckTime, TNew>(),\n\t\t\tUE::Mass::Utils::ConstructTagBitSet<CheckTime, TOld>()\n\t\t\tDEBUG_NAME(\"SwapTags\"))\n\t{}\n};\n\ntemplate<typename TOld, typename TNew>\nusing FMassCommandSwapTags = FMassCommandSwapTagsInternal<EMassCommandCheckTime::CompileTimeCheck, TOld, TNew>;\n\n//////////////////////////////////////////////////////////////////////\n// Struct Instances adding and setting\n\ntemplate<typename... TOthers>\nstruct FMassCommandAddFragmentInstances : public FMassBatchedEntityCommand\n{\n\tusing Super = FMassBatchedEntityCommand;\n\n\tFMassCommandAddFragmentInstances(EMassCommandOperationType OperationType = EMassCommandOperationType::Set DEBUG_NAME_PARAM(\"AddFragmentInstanceList\"))\n\t\t: Super(EMassCommandOperationType::Set FORWARD_DEBUG_NAME_PARAM)\n\t\t, FragmentsAffected(UE::Mass::Utils::ConstructFragmentBitSet<EMassCommandCheckTime::CompileTimeCheck, TOthers...>())\n\t{}\n\n\tvoid Add(FMassEntityHandle Entity, TOthers... InFragments)\n\t{\n\t\tSuper::Add(Entity);\n\t\tFragments.Add(InFragments...);\n\t}\n\nprotected:\n\tvirtual void Reset() override\n\t{\n\t\tFragments.Reset();\n\t\tSuper::Reset();\n\t}\n\n\tvirtual SIZE_T GetAllocatedSize() const override\n\t{\n\t\treturn Super::GetAllocatedSize() + Fragments.GetAllocatedSize() + FragmentsAffected.GetAllocatedSize();\n\t}\n\n\tvirtual void Execute(FMassEntityManager& System) const override\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(MassCommandAddFragmentInstances_Execute);\n\n\t\tTArray<FStructArrayView> GenericMultiArray;\n\t\tGenericMultiArray.Reserve(Fragments.GetNumArrays());\n\t\tFragments.GetAsGenericMultiArray(GenericMultiArray);\n\n\t\tTArray<FMassArchetypeEntityCollectionWithPayload> EntityCollections;\n\t\tFMassArchetypeEntityCollectionWithPayload::CreateEntityRangesWithPayload(System, TargetEntities, FMassArchetypeEntityCollection::FoldDuplicates\n\t\t\t, FMassGenericPayloadView(GenericMultiArray), EntityCollections);\n\n\t\tSystem.BatchAddFragmentInstancesForEntities(EntityCollections, FragmentsAffected);\n\t}\n\n\tmutable UE::Mass::TMultiArray<TOthers...> Fragments;\n\tconst FMassFragmentBitSet FragmentsAffected;\n};\n\ntemplate<typename... TOthers>\nstruct FMassCommandBuildEntity : public FMassCommandAddFragmentInstances<TOthers...>\n{\n\tusing Super = FMassCommandAddFragmentInstances<TOthers...>;\n\n\tFMassCommandBuildEntity()\n\t\t: Super(EMassCommandOperationType::Create DEBUG_NAME(\"BuildEntity\"))\n\t{\n\t}\n\nprotected:\n\n\tvirtual void Execute(FMassEntityManager& System) const override\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(MassCommandBuildEntity_Execute);\n\n\t\tTArray<FStructArrayView> GenericMultiArray;\n\t\tGenericMultiArray.Reserve(Super::Fragments.GetNumArrays());\n\t\tSuper::Fragments.GetAsGenericMultiArray(GenericMultiArray);\n\n\t\tTArray<FMassArchetypeEntityCollectionWithPayload> EntityCollections;\n\t\tFMassArchetypeEntityCollectionWithPayload::CreateEntityRangesWithPayload(System, Super::TargetEntities, FMassArchetypeEntityCollection::FoldDuplicates\n\t\t\t, FMassGenericPayloadView(GenericMultiArray), EntityCollections);\n\n\t\tcheck(EntityCollections.Num() <= 1);\n\t\tif (EntityCollections.Num())\n\t\t{\n\t\t\tSystem.BatchBuildEntities(EntityCollections[0], Super::FragmentsAffected, FMassArchetypeSharedFragmentValues());\n\t\t}\n\t}\n};\n\n/** \n * Note: that TSharedFragmentValues is always expected to be FMassArchetypeSharedFragmentValues, but is declared as \n *\ttemplate's param to maintain uniform command adding interface via FMassCommandBuffer.PushCommand. \n *\tPushCommands received all input params in one `typename...` list and as such cannot be easily split up to reason about.\n */\ntemplate<typename TSharedFragmentValues, typename... TOthers>\nstruct FMassCommandBuildEntityWithSharedFragments : public FMassBatchedCommand\n{\n\tusing Super = FMassBatchedCommand;\n\n\tFMassCommandBuildEntityWithSharedFragments()\n\t\t: Super(EMassCommandOperationType::Create DEBUG_NAME(\"FMassCommandBuildEntityWithSharedFragments\"))\n\t\t, FragmentsAffected(UE::Mass::Utils::ConstructFragmentBitSet<EMassCommandCheckTime::CompileTimeCheck, TOthers...>())\n\t{}\n\n\tvoid Add(FMassEntityHandle Entity, FMassArchetypeSharedFragmentValues&& InSharedFragments, TOthers... InFragments)\n\t{\n\t\tInSharedFragments.Sort();\n\n\t\t// Compute hash before adding to the map since evaluation order is not guaranteed\n\t\t// and MoveTemp will invalidate InSharedFragments\n\t\tconst uint32 Hash = GetTypeHash(InSharedFragments);\n\n\t\tFPerSharedFragmentsHashData& Instance = Data.FindOrAdd(Hash, MoveTemp(InSharedFragments));\n\t\tInstance.Fragments.Add(InFragments...);\n\t\tInstance.TargetEntities.Add(Entity);\n\n\t\tbHasWork = true;\n\t}\n\nprotected:\n\tvirtual SIZE_T GetAllocatedSize() const override\n\t{\n\t\tSIZE_T TotalSize = 0;\n\t\tfor (const auto& KeyValue : Data)\n\t\t{\n\t\t\tTotalSize += KeyValue.Value.GetAllocatedSize();\n\t\t}\n\t\tTotalSize += Data.GetAllocatedSize();\n\t\tTotalSize += FragmentsAffected.GetAllocatedSize();\n\t\treturn TotalSize;\n\t}\n\n\tvirtual void Execute(FMassEntityManager& System) const \n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(MassCommandBuildEntityWithSharedFragments_Execute);\n\n\t\tconstexpr int FragmentTypesCount = UE::Mass::TMultiTypeList<TOthers...>::Ordinal + 1;\n\t\tTArray<FStructArrayView> GenericMultiArray;\n\t\tGenericMultiArray.Reserve(FragmentTypesCount);\n\n\t\tfor (auto It : Data)\n\t\t{\t\t\t\n\t\t\tIt.Value.Fragments.GetAsGenericMultiArray(GenericMultiArray);\n\n\t\t\tTArray<FMassArchetypeEntityCollectionWithPayload> EntityCollections;\n\t\t\tFMassArchetypeEntityCollectionWithPayload::CreateEntityRangesWithPayload(System, It.Value.TargetEntities, FMassArchetypeEntityCollection::FoldDuplicates\n\t\t\t\t, FMassGenericPayloadView(GenericMultiArray), EntityCollections);\n\t\t\tcheckf(EntityCollections.Num() <= 1, TEXT(\"We expect TargetEntities to only contain archetype-less entities, ones that need to be \\'build\\'\"));\n\n\t\t\tif (EntityCollections.Num())\n\t\t\t{\n\t\t\t\tSystem.BatchBuildEntities(EntityCollections[0], FragmentsAffected, It.Value.SharedFragmentValues);\n\t\t\t}\n\n\t\t\tGenericMultiArray.Reset();\n\t\t}\n\t}\n\n\tvirtual void Reset() override\n\t{\n\t\tData.Reset();\n\t\tSuper::Reset();\n\t}\n\n#if CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG\n\tvirtual int32 GetNumOperationsStat() const override\n\t{\n\t\tint32 TotalCount = 0;\n\t\tfor (const auto& KeyValue : Data)\n\t\t{\n\t\t\tTotalCount += KeyValue.Value.TargetEntities.Num();\n\t\t}\n\t\treturn TotalCount;\n\t}\n#endif // CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG\n\n\tFMassFragmentBitSet FragmentsAffected;\n\n\tstruct FPerSharedFragmentsHashData\n\t{\n\t\tFPerSharedFragmentsHashData(FMassArchetypeSharedFragmentValues&& InSharedFragmentValues)\n\t\t\t: SharedFragmentValues(MoveTemp(InSharedFragmentValues))\n\t\t{\t\n\t\t}\n\n\t\tSIZE_T GetAllocatedSize() const\n\t\t{\n\t\t\treturn TargetEntities.GetAllocatedSize() + Fragments.GetAllocatedSize() + SharedFragmentValues.GetAllocatedSize();\n\t\t}\n\n\t\tTArray<FMassEntityHandle> TargetEntities;\n\t\tmutable UE::Mass::TMultiArray<TOthers...> Fragments;\n\t\tFMassArchetypeSharedFragmentValues SharedFragmentValues;\n\t};\n\n\tTMap<uint32, FPerSharedFragmentsHashData> Data;\n};\n\n//////////////////////////////////////////////////////////////////////\n// Commands that really can't know the types at compile time\n\ntemplate<EMassCommandOperationType OpType>\nstruct FMassDeferredCommand : public FMassBatchedCommand\n{\n\tusing Super = FMassBatchedCommand;\n\tusing FExecFunction = TFunction<void(FMassEntityManager& System)>;\n\n\tFMassDeferredCommand()\n\t\t: Super(OpType DEBUG_NAME(\"BatchedDeferredCommand\"))\n\t{}\n\n\tvoid Add(FExecFunction&& ExecFunction)\n\t{\n\t\tDeferredFunctions.Add(MoveTemp(ExecFunction));\n\t\tbHasWork = true;\n\t}\n\n\tvoid Add(const FExecFunction& ExecFunction)\n\t{\n\t\tDeferredFunctions.Add(ExecFunction);\n\t\tbHasWork = true;\n\t}\n\nprotected:\n\tvirtual SIZE_T GetAllocatedSize() const\n\t{\n\t\treturn DeferredFunctions.GetAllocatedSize();\n\t}\n\n\tvirtual void Execute(FMassEntityManager& System) const override\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(MassDeferredCommand_Execute);\n\n\t\tfor (const FExecFunction& ExecFunction : DeferredFunctions)\n\t\t{\n\t\t\tExecFunction(System);\n\t\t}\n\t}\n\n\tvirtual void Reset() override\n\t{\n\t\tDeferredFunctions.Reset();\n\t\tSuper::Reset();\n\t}\n\n#if CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG\n\tvirtual int32 GetNumOperationsStat() const override\n\t{\n\t\treturn DeferredFunctions.Num();\n\t}\n#endif // CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG\n\n\tTArray<FExecFunction> DeferredFunctions;\n};\n\nusing FMassDeferredCreateCommand = FMassDeferredCommand<EMassCommandOperationType::Create>;\nusing FMassDeferredAddCommand = FMassDeferredCommand<EMassCommandOperationType::Add>;\nusing FMassDeferredRemoveCommand = FMassDeferredCommand<EMassCommandOperationType::Remove>;\nusing FMassDeferredChangeCompositionCommand = FMassDeferredCommand<EMassCommandOperationType::ChangeComposition>;\nusing FMassDeferredSetCommand = FMassDeferredCommand<EMassCommandOperationType::Set>;\nusing FMassDeferredDestroyCommand = FMassDeferredCommand<EMassCommandOperationType::Destroy>;\n\n#undef DEBUG_NAME\n#undef DEBUG_NAME_PARAM\n#undef FORWARD_DEBUG_NAME_PARAM\n",
      "lines": 590
    },
    {
      "file_path": "MassEntity\\Public\\MassDebugger.h",
      "extension": ".h",
      "size_bytes": 10601,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessingTypes.h\"\n#if WITH_MASSENTITY_DEBUG\n#include \"Containers/ContainersFwd.h\"\n#include \"MassEntityQuery.h\"\n#include \"MassProcessor.h\"\n#include \"Misc/SpinLock.h\"\n#include \"StructUtils/InstancedStruct.h\"\n#include \"Logging/TokenizedMessage.h\"\n\nclass FOutputDevice;\nclass UMassProcessor;\nstruct FMassEntityQuery;\nstruct FMassEntityManager;\nstruct FMassArchetypeHandle;\nstruct FMassFragmentRequirements;\nstruct FMassFragmentRequirementDescription;\nenum class EMassFragmentAccess : uint8;\nenum class EMassFragmentPresence : uint8;\n#endif // WITH_MASSENTITY_DEBUG\n#include \"MassDebugger.generated.h\"\n\nnamespace UE::Mass::Debug\n{\n\tstruct FArchetypeStats\n\t{\n\t\t/** Number of active entities of the archetype. */\n\t\tint32 EntitiesCount = 0;\n\t\t/** Number of entities that fit per chunk. */\n\t\tint32 EntitiesCountPerChunk = 0;\n\t\t/** Number of allocated chunks. */\n\t\tint32 ChunksCount = 0;\n\t\t/** Total amount of memory taken by this archetype */\n\t\tSIZE_T AllocatedSize = 0;\n\t\t/** How much memory allocated for entities is being unused */\n\t\tSIZE_T WastedEntityMemory = 0;\n\t\t/** Total amount of memory needed by a single entity */\n\t\tSIZE_T BytesPerEntity = 0;\n\t};\n} // namespace UE::Mass::Debug\n\nUSTRUCT()\nstruct MASSENTITY_API FMassGenericDebugEvent\n{\n\tGENERATED_BODY()\n\texplicit FMassGenericDebugEvent(const UObject* InContext = nullptr)\n#if WITH_EDITORONLY_DATA\n\t\t: Context(InContext)\n#endif // WITH_EDITORONLY_DATA\n\t{\n\t}\n\n#if WITH_EDITORONLY_DATA\n\t// note that it's not a uproperty since these events are only intended to be used instantly, never stored\n\tconst UObject* Context = nullptr;\n#endif // WITH_EDITORONLY_DATA\n};\n\n#if WITH_MASSENTITY_DEBUG\n\nnamespace UE::Mass::Debug\n{\n\textern MASSENTITY_API bool bAllowProceduralDebuggedEntitySelection;\n\textern MASSENTITY_API bool bAllowBreakOnDebuggedEntity;\n\textern MASSENTITY_API bool bTestSelectedEntityAgainstProcessorQueries;\n} // namespace UE::Mass::Debug\n\n#define MASS_IF_ENTITY_DEBUGGED(Manager, EntityHandle) (FMassDebugger::GetSelectedEntity(Manager) == EntityHandle)\n#define MASS_BREAK_IF_ENTITY_DEBUGGED(Manager, EntityHandle) { if (UE::Mass::Debug::bAllowBreakOnDebuggedEntity && MASS_IF_ENTITY_DEBUGGED(Manager, EntityHandle)) { PLATFORM_BREAK();} }\n#define MASS_BREAK_IF_ENTITY_INDEX(EntityHandle, InIndex) { if (UE::Mass::Debug::bAllowBreakOnDebuggedEntity && EntityHandle.Index == InIndex) { PLATFORM_BREAK();} }\n#define MASS_SET_ENTITY_DEBUGGED(Manager, EntityHandle) { if (UE::Mass::Debug::bAllowProceduralDebuggedEntitySelection) {FMassDebugger::SelectEntity(Manager, EntityHandle); }}\n\nenum class EMassDebugMessageSeverity : uint8\n{\n\tError,\n\tWarning,\n\tInfo,\n\t// the following two need to remain last\n\tDefault,\n\tMAX = Default\n};\n\nnamespace UE::Mass::Debug\n{\n\tstruct MASSENTITY_API FQueryRequirementsView\n\t{\n\t\tTConstArrayView<FMassFragmentRequirementDescription> FragmentRequirements;\n\t\tTConstArrayView<FMassFragmentRequirementDescription> ChunkRequirements;\n\t\tTConstArrayView<FMassFragmentRequirementDescription> ConstSharedRequirements;\n\t\tTConstArrayView<FMassFragmentRequirementDescription> SharedRequirements;\n\t\tconst FMassTagBitSet& RequiredAllTags;\n\t\tconst FMassTagBitSet& RequiredAnyTags;\n\t\tconst FMassTagBitSet& RequiredNoneTags;\n\t\tconst FMassTagBitSet& RequiredOptionalTags;\n\t\tconst FMassExternalSubsystemBitSet& RequiredConstSubsystems;\n\t\tconst FMassExternalSubsystemBitSet& RequiredMutableSubsystems;\n\t};\n\n\tFString DebugGetFragmentAccessString(EMassFragmentAccess Access);\n\tMASSENTITY_API extern void DebugOutputDescription(TConstArrayView<UMassProcessor*> Processors, FOutputDevice& Ar);\n\n\tMASSENTITY_API extern bool HasDebugEntities();\n\tMASSENTITY_API extern bool IsDebuggingSingleEntity();\n\n\t/**\n\t * Populates OutBegin and OutEnd with entity index ranges as set by mass.debug.SetDebugEntityRange or\n\t * mass.debug.DebugEntity console commands.\n\t * @return whether any range has been configured.\n\t */\n\tMASSENTITY_API extern bool GetDebugEntitiesRange(int32& OutBegin, int32& OutEnd);\n\tMASSENTITY_API extern bool IsDebuggingEntity(FMassEntityHandle Entity, FColor* OutEntityColor = nullptr);\n\tMASSENTITY_API extern FColor GetEntityDebugColor(FMassEntityHandle Entity);\n\n\tinline EMessageSeverity::Type MassSeverityToMessageSeverity(EMessageSeverity::Type OriginalSeverity, EMassDebugMessageSeverity MassSeverity)\n\t{\n\t\tstatic constexpr EMessageSeverity::Type ConversionMap[int(EMassDebugMessageSeverity::MAX)] =\n\t\t{\n\t\t\t/*EMassDebugMessageSeverity::Error=*/EMessageSeverity::Error,\n\t\t\t/*EMassDebugMessageSeverity::Warning=*/EMessageSeverity::Warning,\n\t\t\t/*EMassDebugMessageSeverity::Info=*/EMessageSeverity::Info\n\t\t};\n\t\treturn MassSeverity == EMassDebugMessageSeverity::Default \n\t\t\t? OriginalSeverity\n\t\t\t: ConversionMap[int(MassSeverity)];\n\t}\n} // namespace UE::Mass::Debug\n\nstruct MASSENTITY_API FMassDebugger\n{\n\tDECLARE_MULTICAST_DELEGATE_TwoParams(FOnEntitySelected, const FMassEntityManager&, const FMassEntityHandle);\n\tDECLARE_MULTICAST_DELEGATE_OneParam(FOnMassEntityManagerEvent, const FMassEntityManager&);\n\tDECLARE_MULTICAST_DELEGATE_ThreeParams(FOnDebugEvent, const FName /*EventName*/, FConstStructView /*Payload*/, const EMassDebugMessageSeverity /*SeverityOverride*/);\n\n\tstruct FEnvironment\n\t{\n\t\tTWeakPtr<const FMassEntityManager> EntityManager;\n\t\tFMassEntityHandle SelectedEntity;\n\n\t\texplicit FEnvironment(const FMassEntityManager& InEntityManager)\n\t\t\t: EntityManager(InEntityManager.AsWeak())\n\t\t{}\n\n\t\tbool IsValid() const { return EntityManager.IsValid(); }\n\t};\n\n\tstatic TConstArrayView<FMassEntityQuery*> GetProcessorQueries(const UMassProcessor& Processor);\n\t/** fetches all queries registered for given Processor. Note that in order to get up to date information\n\t *  FMassEntityQuery::CacheArchetypes will be called on each query */\n\tstatic TConstArrayView<FMassEntityQuery*> GetUpToDateProcessorQueries(const FMassEntityManager& EntitySubsystem, UMassProcessor& Processor);\n\n\tstatic UE::Mass::Debug::FQueryRequirementsView GetQueryRequirements(const FMassEntityQuery& Query);\n\tstatic void GetQueryExecutionRequirements(const FMassEntityQuery& Query, FMassExecutionRequirements& OutExecutionRequirements);\n\n\tstatic TArray<FMassArchetypeHandle> GetAllArchetypes(const FMassEntityManager& EntitySubsystem);\n\tstatic const FMassArchetypeCompositionDescriptor& GetArchetypeComposition(const FMassArchetypeHandle& ArchetypeHandle);\n\n\tstatic void GetArchetypeEntityStats(const FMassArchetypeHandle& ArchetypeHandle, UE::Mass::Debug::FArchetypeStats& OutStats);\n\tstatic const TConstArrayView<FName> GetArchetypeDebugNames(const FMassArchetypeHandle& ArchetypeHandle);\n\n\tstatic TConstArrayView<UMassCompositeProcessor::FDependencyNode> GetProcessingGraph(const UMassCompositeProcessor& GraphOwner);\n\tstatic TConstArrayView<TObjectPtr<UMassProcessor>> GetHostedProcessors(const UMassCompositeProcessor& GraphOwner);\n\t\n\tstatic FString GetSingleRequirementDescription(const FMassFragmentRequirementDescription& Requirement);\n\tstatic FString GetRequirementsDescription(const FMassFragmentRequirements& Requirements);\n\tstatic FString GetArchetypeRequirementCompatibilityDescription(const FMassFragmentRequirements& Requirements, const FMassArchetypeHandle& ArchetypeHandle);\n\tstatic FString GetArchetypeRequirementCompatibilityDescription(const FMassFragmentRequirements& Requirements, const FMassArchetypeCompositionDescriptor& ArchetypeComposition);\n\n\tstatic void OutputArchetypeDescription(FOutputDevice& Ar, const FMassArchetypeHandle& Archetype);\n\tstatic void OutputEntityDescription(FOutputDevice& Ar, const FMassEntityManager& EntityManager, const int32 EntityIndex, const TCHAR* InPrefix = TEXT(\"\"));\n\tstatic void OutputEntityDescription(FOutputDevice& Ar, const FMassEntityManager& EntityManager, const FMassEntityHandle Entity, const TCHAR* InPrefix = TEXT(\"\"));\n\n\tstatic void SelectEntity(const FMassEntityManager& EntityManager, const FMassEntityHandle EntityHandle);\n\tstatic FMassEntityHandle GetSelectedEntity(const FMassEntityManager& EntityManager);\n\n\tstatic FOnEntitySelected OnEntitySelectedDelegate;\n\n\tstatic FOnMassEntityManagerEvent OnEntityManagerInitialized;\n\tstatic FOnMassEntityManagerEvent OnEntityManagerDeinitialized;\n\n\tstatic FOnDebugEvent OnDebugEvent;\n\t\n\tstatic void DebugEvent(const FName EventName, FConstStructView Payload, const EMassDebugMessageSeverity SeverityOverride = EMassDebugMessageSeverity::Default)\n\t{\n\t\tOnDebugEvent.Broadcast(EventName, Payload, SeverityOverride);\n\t}\n\n\ttemplate<typename TMessage, typename... TArgs>\n\tstatic void DebugEvent(TArgs&&... InArgs)\n\t{\n\t\tDebugEvent(TMessage::StaticStruct()->GetFName()\n\t\t\t, FConstStructView::Make(TMessage(Forward<TArgs>(InArgs)...)));\n\t}\n\n\tstatic void RegisterEntityManager(FMassEntityManager& EntityManager);\n\tstatic void UnregisterEntityManager(FMassEntityManager& EntityManager);\n\tstatic TConstArrayView<FEnvironment> GetEnvironments() { return ActiveEnvironments; }\n\n\t/**\n\t * Determines whether given Archetype matches given Requirements. In case of a mismatch description of failed conditions will be added to OutputDevice.\n\t */\n\tstatic bool DoesArchetypeMatchRequirements(const FMassArchetypeHandle& ArchetypeHandle, const FMassFragmentRequirements& Requirements, FOutputDevice& OutputDevice);\n\nprivate:\n\tstatic TArray<FEnvironment> ActiveEnvironments;\n\tstatic UE::FSpinLock EntityManagerRegistrationLock;\n};\n\n#else\n\nstruct FMassArchetypeHandle;\nstruct FMassFragmentRequirements;\nstruct FMassFragmentRequirementDescription;\nstruct FMassArchetypeCompositionDescriptor;\n\nstruct MASSENTITY_API FMassDebugger\n{\n\tstatic FString GetSingleRequirementDescription(const FMassFragmentRequirementDescription&) { return TEXT(\"[no debug information]\"); }\n\tstatic FString GetRequirementsDescription(const FMassFragmentRequirements&) { return TEXT(\"[no debug information]\"); }\n\tstatic FString GetArchetypeRequirementCompatibilityDescription(const FMassFragmentRequirements&, const FMassArchetypeHandle&) { return TEXT(\"[no debug information]\"); }\n\tstatic FString GetArchetypeRequirementCompatibilityDescription(const FMassFragmentRequirements&, const FMassArchetypeCompositionDescriptor&) { return TEXT(\"[no debug information]\"); }\n};\n\n#define MASS_IF_ENTITY_DEBUGGED(a, b) false\n#define MASS_BREAK_IF_ENTITY_DEBUGGED(a, b)\n#define MASS_BREAK_IF_ENTITY_INDEX(a, b)\n#define MASS_SET_ENTITY_DEBUGGED(a, b)\n\n#endif // WITH_MASSENTITY_DEBUG\n",
      "lines": 231
    },
    {
      "file_path": "MassEntity\\Public\\MassEntityManager.h",
      "extension": ".h",
      "size_bytes": 58607,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"UObject/GCObject.h\"\n#include \"MassEntityTypes.h\"\n#include \"MassProcessingTypes.h\"\n#include \"MassEntityQuery.h\"\n#if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_5\n#include \"StructUtils/InstancedStruct.h\"\n#include \"StructUtils/StructUtilsTypes.h\"\n#endif\n#include \"MassObserverManager.h\"\n#include \"Containers/MpscQueue.h\"\n#include \"MassRequirementAccessDetector.h\"\n#include \"Templates/FunctionFwd.h\"\n#include \"MassEntityManagerStorage.h\"\n\n\nstruct FInstancedStruct;\nstruct FMassEntityQuery;\nstruct FMassExecutionContext;\nstruct FMassArchetypeData;\nstruct FMassCommandBuffer;\nstruct FMassArchetypeEntityCollection;\nclass FOutputDevice;\nstruct FMassDebugger;\nenum class EMassFragmentAccess : uint8;\nenum class EForkProcessRole : uint8;\nnamespace UE::Mass::Private\n{\n\tstruct FEntityStorageInitializer;\n}\n\n#define MASS_CONCURRENT_RESERVE 1\n\n/** \n * The type responsible for hosting Entities managing Archetypes.\n * Entities are stored as FEntityData entries in a chunked array. \n * Each valid entity is assigned to an Archetype that stored fragments associated with a given entity at the moment. \n * \n * FMassEntityManager supplies API for entity creation (that can result in archetype creation) and entity manipulation.\n * Even though synchronized manipulation methods are available in most cases the entity operations are performed via a command \n * buffer. The default command buffer can be obtained with a Defer() call. @see FMassCommandBuffer for more details.\n * \n * FMassEntityManager are meant to be stored with a TSharedPtr or TSharedRef. Some of Mass API pass around \n * FMassEntityManager& but programmers can always use AsShared() call to obtain a shared ref for a given manager instance \n * (as supplied by deriving from TSharedFromThis<FMassEntityManager>).\n * IMPORTANT: if you create your own FMassEntityManager instance remember to call Initialize() before using it.\n */\nstruct MASSENTITY_API FMassEntityManager : public TSharedFromThis<FMassEntityManager>, public FGCObject\n{\n\tfriend FMassEntityQuery;\n\tfriend FMassDebugger;\n\n\tDECLARE_MULTICAST_DELEGATE_OneParam(FOnNewArchetypeDelegate, const FMassArchetypeHandle&);\n\nprivate:\n\t// Index 0 is reserved so we can treat that index as an invalid entity handle\n\tconstexpr static int32 NumReservedEntities = 1;\n\t\npublic:\n\tstruct FScopedProcessing\n\t{\n\t\texplicit FScopedProcessing(std::atomic<int32>& InProcessingScopeCount) : ScopedProcessingCount(InProcessingScopeCount)\n\t\t{\n\t\t\t++ScopedProcessingCount;\n\t\t}\n\t\t~FScopedProcessing()\n\t\t{\n\t\t\t--ScopedProcessingCount;\n\t\t}\n\tprivate:\n\t\tstd::atomic<int32>& ScopedProcessingCount;\n\t};\n\tusing FStructInitializationCallback = TFunctionRef<void(void* Fragment, const UScriptStruct& FragmentType)>;\n\n\tconst static FMassEntityHandle InvalidEntity;\n\n\texplicit FMassEntityManager(UObject* InOwner = nullptr);\n\tFMassEntityManager(const FMassEntityManager& Other) = delete;\n\tvirtual ~FMassEntityManager();\n\n\t// FGCObject interface\n\tvirtual void AddReferencedObjects(FReferenceCollector& Collector) override;\n\tvirtual FString GetReferencerName() const override\n\t{\n\t\treturn TEXT(\"FMassEntityManager\");\n\t}\n\t// End of FGCObject interface\n\tvoid GetResourceSizeEx(FResourceSizeEx& CumulativeResourceSize);\n\n\t// Default to use single threaded implementation\n\tvoid Initialize();\n\tvoid Initialize(const FMassEntityManagerStorageInitParams& InitializationParams);\n\tvoid PostInitialize();\n\tvoid Deinitialize();\n\n\t/** \n\t * A special, relaxed but slower version of CreateArchetype functions that allows FragmentAngTagsList to contain \n\t * both fragments and tags. \n\t */\n\tFMassArchetypeHandle CreateArchetype(TConstArrayView<const UScriptStruct*> FragmentsAndTagsList, const FMassArchetypeCreationParams& CreationParams = FMassArchetypeCreationParams());\n\n\t/**\n\t * A special, relaxed but slower version of CreateArchetype functions that allows FragmentAngTagsList to contain\n\t * both fragments and tags. This version takes an original archetype and copies it layout, then appends any fragments and tags from the\n\t * provided list if they're not already in the original archetype.\n\t * \n\t * @param SourceArchetype The archetype where the composition will be copied from.\n\t * @param FragmentsAndTagsList The list of fragments and tags to add to the copied composition.\n\t */\n\tFMassArchetypeHandle CreateArchetype(FMassArchetypeHandle SourceArchetype, TConstArrayView<const UScriptStruct*> FragmentsAndTagsList);\n\t\n\t/**\n\t * A special, relaxed but slower version of CreateArchetype functions that allows FragmentAngTagsList to contain\n\t * both fragments and tags. This version takes an original archetype and copies it layout, then appends any fragments and tags from the\n\t * provided list if they're not already in the original archetype.\n\t * \n\t * @param SourceArchetype The archetype where the composition will be copied from.\n\t * @param FragmentsAndTagsList The list of fragments and tags to add to the copied composition.\n\t * @param CreationParams Additional arguments used to create the new archetype.\n\t */\n\tFMassArchetypeHandle CreateArchetype(FMassArchetypeHandle SourceArchetype, TConstArrayView<const UScriptStruct*> FragmentsAndTagsList, \n\t\tconst FMassArchetypeCreationParams& CreationParams);\n\n\t/**\n\t * CreateArchetype from a composition descriptor and initial values\n\t *\n\t * @param Composition of fragment, tag and chunk fragment types\n\t * @param CreationParams Parameters used during archetype construction\n\t * @return a handle of a new archetype \n\t */\n\tFMassArchetypeHandle CreateArchetype(const FMassArchetypeCompositionDescriptor& Composition, const FMassArchetypeCreationParams& CreationParams = FMassArchetypeCreationParams());\n\n\t/**\n\t *  Creates an archetype like SourceArchetype + InFragments.\n\t *  @param SourceArchetype the archetype used to initially populate the list of fragments of the archetype being created.\n\t *  @param InFragments list of unique fragments to add to fragments fetched from SourceArchetype. Note that\n\t *   adding an empty list is not supported and doing so will result in failing a `check`\n\t *  @return a handle of a new archetype\n\t *  @note it's caller's responsibility to ensure that NewFragmentList is not empty and contains only fragment\n\t *   types that SourceArchetype doesn't already have. If the caller cannot guarantee it use of AddFragment functions\n\t *   family is recommended.\n\t */\n\tFMassArchetypeHandle CreateArchetype(const TSharedPtr<FMassArchetypeData>& SourceArchetype, const FMassFragmentBitSet& InFragments);\n\t\n\t/** \n\t *  Creates an archetype like SourceArchetype + InFragments. \n\t *  @param SourceArchetype the archetype used to initially populate the list of fragments of the archetype being created. \n\t *  @param InFragments list of unique fragments to add to fragments fetched from SourceArchetype. Note that \n\t *   adding an empty list is not supported and doing so will result in failing a `check`\n\t *  @param CreationParams Parameters used during archetype construction\n\t *  @return a handle of a new archetype\n\t *  @note it's caller's responsibility to ensure that NewFragmentList is not empty and contains only fragment\n\t *   types that SourceArchetype doesn't already have. If the caller cannot guarantee it use of AddFragment functions\n\t *   family is recommended.\n\t */\n\tFMassArchetypeHandle CreateArchetype(const TSharedPtr<FMassArchetypeData>& SourceArchetype, const FMassFragmentBitSet& InFragments, \n\t\tconst FMassArchetypeCreationParams& CreationParams);\n\n\t/** \n\t * A helper function to be used when creating entities with shared fragments provided, or when adding shared fragments\n\t * to existing entities\n\t * @param ArchetypeHandle that's the assumed target archetype. But we'll be making sure its composition matches SharedFragmentsBitSet\n\t * @param SharedFragmentBitSet indicates which shared fragments we want the target archetype to have. If ArchetypeHandle \n\t *\tdoesn't have these a new archetype will be created.\n\t */\n\tFMassArchetypeHandle GetOrCreateSuitableArchetype(const FMassArchetypeHandle& ArchetypeHandle\n\t\t, const FMassSharedFragmentBitSet& SharedFragmentBitSet\n\t\t, const FMassConstSharedFragmentBitSet& ConstSharedFragmentBitSet\n\t\t, const FMassArchetypeCreationParams& CreationParams = FMassArchetypeCreationParams());\n\n\t/** Fetches the archetype for a given Entity. If Entity is not valid it will still return a handle, just with an invalid archetype */\n\tFMassArchetypeHandle GetArchetypeForEntity(FMassEntityHandle Entity) const;\n\t/**\n\t * Fetches the archetype for a given Entity. Note that it's callers responsibility the given Entity handle is valid.\n\t * If you can't ensure that call GetArchetypeForEntity.\n\t */\n\tFMassArchetypeHandle GetArchetypeForEntityUnsafe(FMassEntityHandle Entity) const;\n\n\t/** Method to iterate on all the fragment types of an archetype */\n\tstatic void ForEachArchetypeFragmentType(const FMassArchetypeHandle& ArchetypeHandle, TFunction< void(const UScriptStruct* /*FragmentType*/)> Function);\n\n\t/**\n\t * Go through all archetypes and compact entities\n\t * @param TimeAllowed to do entity compaction, once it reach that time it will stop and return\n\t */\n\tvoid DoEntityCompaction(const double TimeAllowed);\n\n\t/**\n\t * Creates fully built entity ready to be used by the subsystem\n\t * @param ArchetypeHandle you want this entity to be\n\t * @param SharedFragmentValues to be associated with the entity\n\t * @return FMassEntityHandle id of the newly created entity */\n\tFMassEntityHandle CreateEntity(const FMassArchetypeHandle& ArchetypeHandle, const FMassArchetypeSharedFragmentValues& SharedFragmentValues = {});\n\n\t/**\n\t * Creates fully built entity ready to be used by the subsystem\n\t * @param FragmentInstanceList is the fragments to create the entity from and initialize values\n\t * @param SharedFragmentValues to be associated with the entity\n\t * @return FMassEntityHandle id of the newly created entity */\n\tFMassEntityHandle CreateEntity(TConstArrayView<FInstancedStruct> FragmentInstanceList, const FMassArchetypeSharedFragmentValues& SharedFragmentValues = {}, const FMassArchetypeCreationParams& CreationParams = FMassArchetypeCreationParams());\n\n\t/**\n\t * A dedicated structure for ensuring the \"on entities creation\" observers get notified only once all other \n\t * initialization operations are done and this creation context instance gets released. \n\t */\n\tstruct MASSENTITY_API FEntityCreationContext\n\t{\n\tprivate:\n\t\tFEntityCreationContext();\n\t\texplicit FEntityCreationContext(FMassEntityManager& InManager, const TConstArrayView<FMassEntityHandle> InCreatedEntities = {});\n\t\tFEntityCreationContext(FMassEntityManager& InManager, const TConstArrayView<FMassEntityHandle> InCreatedEntities, FMassArchetypeEntityCollection&& EntityCollection);\n\t\t\n\tpublic:\n\t\t~FEntityCreationContext();\n\n\t\t/** Returns EntityCollections, reconstructing them if needed (empty or dirtied). */\n\t\tTConstArrayView<FMassArchetypeEntityCollection> GetEntityCollections() const;\n\t\tint32 GetSpawnedNum() const { return CreatedEntities.Num(); }\n\t\tvoid MarkDirty();\n\t\tFORCEINLINE bool IsDirty() const { return EntityCollections.IsEmpty() && (CreatedEntities.IsEmpty() == false); }\n\t\tvoid AppendEntities(const TConstArrayView<FMassEntityHandle> EntitiesToAppend);\n\t\tvoid AppendEntities(const TConstArrayView<FMassEntityHandle> EntitiesToAppend, FMassArchetypeEntityCollection&& EntityCollection);\n\n\t\t/** Function for debugging/testing purposes. We don't expect users to ever call it, always get collections via GetEntityCollections */\n\t\tbool DebugAreEntityCollectionsUpToDate() const { return EntityCollections.IsEmpty() == CreatedEntities.IsEmpty(); }\n\n\t\tUE_DEPRECATED(5.5, \"This constructor is now deprecated and defunct. Use one of the others instead.\")\n\t\texplicit FEntityCreationContext(const int32 InNumSpawned) : FEntityCreationContext() {}\n\t\tUE_DEPRECATED(5.5, \"This function is now deprecated since FEntityCreationContext can contain more than a single collection now. Use GetEntityCollections instead.\")\n\t\tconst FMassArchetypeEntityCollection& GetEntityCollection() const;\n\n\tprivate:\n\t\tfriend FMassEntityManager;\n\t\t/** To be called in case of processor forking. */\n\t\tvoid ForceUpdateCurrentThreadID();\n\n\t\t/**\n\t\t * Identifies the thread where given FEntityCreationContext instance was created. All subsequent operations are \n\t\t * expected to be run in the same thread.\n\t\t */\n\t\tuint32 OwnerThreadId;\n\t\tmutable TArray<FMassArchetypeEntityCollection> EntityCollections;\n\t\tTArray<FMassEntityHandle> CreatedEntities;\n\t\tFMassArchetypeEntityCollection::EDuplicatesHandling CollectionCreationDuplicatesHandling = FMassArchetypeEntityCollection::EDuplicatesHandling::NoDuplicates;\n\t\tTSharedPtr<FMassEntityManager> Manager;\n\t};\n\t/**\n\t * The main use-case for this function is to create a blank FEntityCreationContext and hold on to it while creating \n\t * a bunch of entities (with multiple calls to BatchCreate* and/or BatchBuild*) and modifying them (with mutating batched API)\n\t * while not causing multiple Observers to trigger. All the observers will be triggered at one go, once the FEntityCreationContext \n\t * instance gets destroyed. \n\t * @return ActiveCreationContext. If it's valid FEntityCreationContext instance will be created and assigned to ActiveCreationContext first.\n\t */\n\tTSharedRef<FEntityCreationContext> GetOrMakeCreationContext();\n\n\t/**\n\t * A version of CreateEntity that's creating a number of entities (Count) in one go\n\t * @param ArchetypeHandle you want this entity to be\n\t * @param SharedFragmentValues to be associated with the entities\n\t * @param ReservedEntities a list of reserved entities that have not yet been assigned to an archetype.\n\t * @return a creation context that will notify all the interested observers about newly created fragments once the context is released */\n\tTSharedRef<FEntityCreationContext> BatchCreateReservedEntities(const FMassArchetypeHandle& ArchetypeHandle,\n\t\tconst FMassArchetypeSharedFragmentValues& SharedFragmentValues, TConstArrayView<FMassEntityHandle> ReservedEntities);\n\tFORCEINLINE TSharedRef<FEntityCreationContext> BatchCreateReservedEntities(const FMassArchetypeHandle& ArchetypeHandle,\n\t\tTConstArrayView<FMassEntityHandle> OutEntities)\n\t{\n\t\treturn BatchCreateReservedEntities(ArchetypeHandle, FMassArchetypeSharedFragmentValues(), OutEntities);\n\t}\n\t/**\n\t * A version of CreateEntity that's creating a number of entities (Count) in one go\n\t * @param ArchetypeHandle you want this entity to be\n\t * @param SharedFragmentValues to be associated with the entities\n\t * @param Count number of entities to create\n\t * @param InOutEntities the newly created entities are appended to given array, i.e. the pre-existing content of OutEntities won't be affected by the call\n\t * @return a creation context that will notify all the interested observers about newly created fragments once the context is released */\n\tTSharedRef<FEntityCreationContext> BatchCreateEntities(const FMassArchetypeHandle& ArchetypeHandle, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, const int32 Count, TArray<FMassEntityHandle>& InOutEntities);\n\tFORCEINLINE TSharedRef<FEntityCreationContext> BatchCreateEntities(const FMassArchetypeHandle& ArchetypeHandle, const int32 Count, TArray<FMassEntityHandle>& InOutEntities)\n\t{\n\t\treturn BatchCreateEntities(ArchetypeHandle, FMassArchetypeSharedFragmentValues(), Count, InOutEntities);\n\t}\n\n\t/**\n\t * Destroys a fully built entity, use ReleaseReservedEntity if entity was not yet built.\n\t * @param Entity to destroy */\n\tvoid DestroyEntity(FMassEntityHandle Entity);\n\n\t/**\n\t * Reserves an entity in the subsystem, the entity is still not ready to be used by the subsystem, need to call BuildEntity()\n\t * @return FMassEntityHandle id of the reserved entity */\n\tFMassEntityHandle ReserveEntity();\n\n\t/**\n\t * Builds an entity for it to be ready to be used by the subsystem\n\t * @param Entity to build which was retrieved with ReserveEntity() method\n\t * @param ArchetypeHandle you want this entity to be\n\t * @param SharedFragmentValues to be associated with the entity\n\t */\n\tvoid BuildEntity(FMassEntityHandle Entity, const FMassArchetypeHandle& ArchetypeHandle, const FMassArchetypeSharedFragmentValues& SharedFragmentValues = {});\n\n\t/**\n\t * Builds an entity for it to be ready to be used by the subsystem\n\t * @param Entity to build which was retrieved with ReserveEntity() method\n\t * @param FragmentInstanceList is the fragments to create the entity from and initialize values\n\t * @param SharedFragmentValues to be associated with the entity\n\t */\n\tvoid BuildEntity(FMassEntityHandle Entity, TConstArrayView<FInstancedStruct> FragmentInstanceList, const FMassArchetypeSharedFragmentValues& SharedFragmentValues = {});\n\n\t/*\n\t * Releases a previously reserved entity that was not yet built, otherwise call DestroyEntity\n\t * @param Entity to release */\n\tvoid ReleaseReservedEntity(FMassEntityHandle Entity);\n\n\t/**\n\t * Destroys all the entities in the provided array of entities. The function will also gracefully handle entities\n\t * that have been reserved but not created yet.\n\t * @note the function doesn't handle duplicates in InEntities.\n\t * @param InEntities to destroy\n\t */\n\tvoid BatchDestroyEntities(TConstArrayView<FMassEntityHandle> InEntities);\n\n\t/**\n\t * Destroys all the entities provided via the Collection. The function will also gracefully handle entities\n\t * that have been reserved but not created yet.\n\t * @param Collection to destroy\n\t */\n\tvoid BatchDestroyEntityChunks(const FMassArchetypeEntityCollection& Collection);\n\tvoid BatchDestroyEntityChunks(TConstArrayView<FMassArchetypeEntityCollection> Collections);\n\n\tvoid AddFragmentToEntity(FMassEntityHandle Entity, const UScriptStruct* FragmentType);\n\tvoid AddFragmentToEntity(FMassEntityHandle Entity, const UScriptStruct* FragmentType, const FStructInitializationCallback& Initializer);\n\n\t/** \n\t *  Ensures that only unique fragments are added. \n\t *  @note It's caller's responsibility to ensure Entity's and FragmentList's validity. \n\t */\n\tvoid AddFragmentListToEntity(FMassEntityHandle Entity, TConstArrayView<const UScriptStruct*> FragmentList);\n\n\tvoid AddFragmentInstanceListToEntity(FMassEntityHandle Entity, TConstArrayView<FInstancedStruct> FragmentInstanceList);\n\tvoid RemoveFragmentFromEntity(FMassEntityHandle Entity, const UScriptStruct* FragmentType);\n\tvoid RemoveFragmentListFromEntity(FMassEntityHandle Entity, TConstArrayView<const UScriptStruct*> FragmentList);\n\n\tvoid AddTagToEntity(FMassEntityHandle Entity, const UScriptStruct* TagType);\n\tvoid RemoveTagFromEntity(FMassEntityHandle Entity, const UScriptStruct* TagType);\n\tvoid SwapTagsForEntity(FMassEntityHandle Entity, const UScriptStruct* FromFragmentType, const UScriptStruct* ToFragmentType);\n\n\t/** \n\t * Adds a new const shared fragment to the given entity. Note that it only works if the given entity doesn't have\n\t * a shared fragment of the given type. The function will give a soft \"pass\" if the entity has the shared fragment\n\t * of the same value. Setting shared fragment value (i.e. changing) is not supported and the function will log\n\t * a warning if that's attempted.\n\t * @return whether the Entity has the Fragment value assigned to it, regardless of its original state (i.e. the function will\n\t *\treturn true also if the Entity already had the same values associated with it)\n\t */\n\tbool AddConstSharedFragmentToEntity(const FMassEntityHandle Entity, const FConstSharedStruct& InConstSharedFragment);\n\n\t/**\n\t * Removes a const shared fragment of the given type from the entity.\n\t * Will do nothing if entity did not have the shared fragment.\n\t * @return True if fragment removed from entity, false otherwise.\n\t */\n\tbool RemoveConstSharedFragmentFromEntity(const FMassEntityHandle Entity, const UScriptStruct& ConstSharedFragmentType);\n\n\t/** \n\t * Reserves Count number of entities and appends them to InOutEntities\n\t * @return a view into InOutEntities containing only the freshly reserved entities\n\t */\n\tTConstArrayView<FMassEntityHandle> BatchReserveEntities(const int32 Count, TArray<FMassEntityHandle>& InOutEntities);\n\t\n\t/**\n\t * Reserves number of entities corresponding to number of entries in the provided array view InOutEntities.\n\t * As a result InOutEntities gets filled with handles of reserved entities\n\t * @return the number of entities reserved\n\t */\n\tint32 BatchReserveEntities(TArrayView<FMassEntityHandle> InOutEntities);\n\n\tTSharedRef<FEntityCreationContext> BatchBuildEntities(const FMassArchetypeEntityCollectionWithPayload& EncodedEntitiesWithPayload, const FMassFragmentBitSet& FragmentsAffected\n\t\t, const FMassArchetypeSharedFragmentValues& SharedFragmentValues = {}, const FMassArchetypeCreationParams& CreationParams = FMassArchetypeCreationParams());\n\tTSharedRef<FEntityCreationContext> BatchBuildEntities(const FMassArchetypeEntityCollectionWithPayload& EncodedEntitiesWithPayload, FMassArchetypeCompositionDescriptor&& Composition\n\t\t, const FMassArchetypeSharedFragmentValues& SharedFragmentValues = {}, const FMassArchetypeCreationParams& CreationParams = FMassArchetypeCreationParams());\n\tvoid BatchChangeTagsForEntities(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, const FMassTagBitSet& TagsToAdd, const FMassTagBitSet& TagsToRemove);\n\tvoid BatchChangeFragmentCompositionForEntities(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, const FMassFragmentBitSet& FragmentsToAdd, const FMassFragmentBitSet& FragmentsToRemove);\n\tvoid BatchAddFragmentInstancesForEntities(TConstArrayView<FMassArchetypeEntityCollectionWithPayload> EntityCollections, const FMassFragmentBitSet& FragmentsAffected);\n\t/** \n\t * Adds a new const and non-const shared fragments to all entities provided via EntityCollections \n\t */\n\tvoid BatchAddSharedFragmentsForEntities(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, const FMassArchetypeSharedFragmentValues& AddedFragmentValues);\n\n\t/**\n\t * Adds fragments and tags indicated by InOutDescriptor to the Entity. The function also figures out which elements\n\t * in InOutDescriptor are missing from the current composition of the given entity and then returns the resulting \n\t * delta via InOutDescriptor.\n\t */\n\tvoid AddCompositionToEntity_GetDelta(FMassEntityHandle Entity, FMassArchetypeCompositionDescriptor& InOutDescriptor);\n\tvoid RemoveCompositionFromEntity(FMassEntityHandle Entity, const FMassArchetypeCompositionDescriptor& InDescriptor);\n\n\tconst FMassArchetypeCompositionDescriptor& GetArchetypeComposition(const FMassArchetypeHandle& ArchetypeHandle) const;\n\n\t/** \n\t * Moves an entity over to a new archetype by copying over fragments common to both archetypes\n\t * @param Entity is the entity to move \n\t * @param NewArchetypeHandle the handle to the new archetype\n\t */\n\tvoid MoveEntityToAnotherArchetype(FMassEntityHandle Entity, FMassArchetypeHandle NewArchetypeHandle);\n\n\t/** Copies values from FragmentInstanceList over to Entity's fragment. Caller is responsible for ensuring that \n\t *  the given entity does have given fragments. Failing this assumption will cause a check-fail.*/\n\tvoid SetEntityFragmentsValues(FMassEntityHandle Entity, TArrayView<const FInstancedStruct> FragmentInstanceList);\n\n\t/** Copies values from FragmentInstanceList over to fragments of given entities collection. The caller is responsible \n\t *  for ensuring that the given entity archetype (FMassArchetypeEntityCollection .Archetype) does have given fragments. \n\t *  Failing this assumption will cause a check-fail. */\n\tstatic void BatchSetEntityFragmentsValues(const FMassArchetypeEntityCollection& SparseEntities, TArrayView<const FInstancedStruct> FragmentInstanceList);\n\n\tstatic void BatchSetEntityFragmentsValues(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, TArrayView<const FInstancedStruct> FragmentInstanceList);\n\n\t// Return true if it is an valid built entity\n\tbool IsEntityActive(FMassEntityHandle Entity) const \n\t{\n\t\treturn IsEntityValid(Entity) && IsEntityBuilt(Entity);\n\t}\n\n\t// Returns true if Entity is valid\n\tbool IsEntityValid(FMassEntityHandle Entity) const;\n\n\t// Returns true if Entity is has been fully built (expecting a valid Entity)\n\tbool IsEntityBuilt(FMassEntityHandle Entity) const;\n\n\t// Asserts that IsEntityValid\n\tvoid CheckIfEntityIsValid(FMassEntityHandle Entity) const;\n\n\t// Asserts that IsEntityBuilt\n\tvoid CheckIfEntityIsActive(FMassEntityHandle Entity) const;\n\n\ttemplate<typename FragmentType>\n\tFragmentType& GetFragmentDataChecked(FMassEntityHandle Entity) const\n\t{\n\t\tstatic_assert(TIsDerivedFrom<FragmentType, FMassFragment>::IsDerived\n\t\t\t, \"Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.\");\n\t\treturn *((FragmentType*)InternalGetFragmentDataChecked(Entity, FragmentType::StaticStruct()));\n\t}\n\n\ttemplate<typename FragmentType>\n\tFragmentType* GetFragmentDataPtr(FMassEntityHandle Entity) const\n\t{\n\t\tstatic_assert(TIsDerivedFrom<FragmentType, FMassFragment>::IsDerived\n\t\t\t, \"Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.\");\n\t\treturn (FragmentType*)InternalGetFragmentDataPtr(Entity, FragmentType::StaticStruct());\n\t}\n\n\tFStructView GetFragmentDataStruct(FMassEntityHandle Entity, const UScriptStruct* FragmentType) const\n\t{\n\t\tcheckf((FragmentType != nullptr) && FragmentType->IsChildOf(FMassFragment::StaticStruct())\n\t\t\t, TEXT(\"GetFragmentDataStruct called with an invalid fragment type '%s'\"), *GetPathNameSafe(FragmentType));\n\t\treturn FStructView(FragmentType, static_cast<uint8*>(InternalGetFragmentDataPtr(Entity, FragmentType)));\n\t}\n\n\ttemplate<typename ConstSharedFragmentType>\n\tConstSharedFragmentType* GetConstSharedFragmentDataPtr(FMassEntityHandle Entity) const\n\t{\n\t\tstatic_assert(TIsDerivedFrom<ConstSharedFragmentType, FMassConstSharedFragment>::IsDerived, \"Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.\");\n\t\tconst FConstSharedStruct* ConstSharedStruct = InternalGetConstSharedFragmentPtr(Entity, ConstSharedFragmentType::StaticStruct());\n\t\treturn (ConstSharedFragmentType*)(ConstSharedStruct ? ConstSharedStruct->GetMemory() : nullptr);\n\t}\n\n\ttemplate<typename ConstSharedFragmentType>\n\tConstSharedFragmentType& GetConstSharedFragmentDataChecked(FMassEntityHandle Entity) const\n\t{\n\t\tConstSharedFragmentType* TypePtr = GetConstSharedFragmentDataPtr<ConstSharedFragmentType>(Entity);\n\t\tcheck(TypePtr);\n\t\treturn *TypePtr;\n\t}\n\n\tFConstStructView GetConstSharedFragmentDataStruct(FMassEntityHandle Entity, const UScriptStruct* ConstSharedFragmentType) const\n\t{\n\t\tcheckf((ConstSharedFragmentType != nullptr) && ConstSharedFragmentType->IsChildOf(FMassConstSharedFragment::StaticStruct())\n\t\t\t, TEXT(\"GetConstSharedFragmentDataStruct called with an invalid fragment type '%s'\"), *GetPathNameSafe(ConstSharedFragmentType));\n\t\tconst FConstSharedStruct* ConstSharedStruct = InternalGetConstSharedFragmentPtr(Entity, ConstSharedFragmentType);\n\t\treturn ConstSharedStruct\n\t\t\t? FConstStructView(*ConstSharedStruct)\n\t\t\t: FConstStructView();\n\t}\n\n\ttemplate<typename SharedFragmentType>\n\tTConstArrayView<FSharedStruct> GetSharedFragmentsOfType()\n\t{\n\t\tstatic_assert(TIsDerivedFrom<SharedFragmentType, FMassSharedFragment>::IsDerived\n\t\t\t, \"Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.\");\n\n\t\tTArray<FSharedStruct>* InstancesOfType = SharedFragmentsTypeMap.Find(SharedFragmentType::StaticStruct());\n\t\treturn InstancesOfType ? *InstancesOfType : TConstArrayView<FSharedStruct>();\n\t}\n\n\ttemplate<typename SharedFragmentType>\n\tSharedFragmentType* GetSharedFragmentDataPtr(FMassEntityHandle Entity) const\n\t{\n\t\tstatic_assert(TIsDerivedFrom<SharedFragmentType, FMassSharedFragment>::IsDerived\n\t\t\t, \"Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.\");\n\t\tconst FSharedStruct* FragmentPtr = InternalGetSharedFragmentPtr(Entity, SharedFragmentType::StaticStruct());\n\t\treturn (SharedFragmentType*)(FragmentPtr ? FragmentPtr->GetMemory() : nullptr);\n\t}\n\n\ttemplate<typename SharedFragmentType>\n\tSharedFragmentType& GetSharedFragmentDataChecked(FMassEntityHandle Entity) const\n\t{\n\t\tSharedFragmentType* TypePtr = GetSharedFragmentDataPtr<SharedFragmentType>(Entity);\n\t\tcheck(TypePtr);\n\t\treturn *TypePtr;\n\t}\n\n\tFConstStructView GetSharedFragmentDataStruct(FMassEntityHandle Entity, const UScriptStruct* SharedFragmentType) const\n\t{\n\t\tcheckf((SharedFragmentType != nullptr) && SharedFragmentType->IsChildOf(FMassSharedFragment::StaticStruct())\n\t\t\t, TEXT(\"GetSharedFragmentDataStruct called with an invalid fragment type '%s'\"), *GetPathNameSafe(SharedFragmentType));\n\t\tconst FSharedStruct* FragmentPtr = InternalGetSharedFragmentPtr(Entity, SharedFragmentType);\n\t\treturn FragmentPtr\n\t\t\t? FConstStructView(*FragmentPtr)\n\t\t\t: FConstStructView();\n\t}\n\n\tuint32 GetArchetypeDataVersion() const { return ArchetypeDataVersion; }\n\n\t/**\n\t * Creates and initializes a FMassExecutionContext instance.\n\t */\n\tFMassExecutionContext CreateExecutionContext(const float DeltaSeconds);\n\n\tFScopedProcessing NewProcessingScope() { return FScopedProcessing(ProcessingScopeCount); }\n\n\t/** \n\t * Indicates whether there are processors out there performing operations on this instance of MassEntityManager. \n\t * Used to ensure that mutating operations (like entity destruction) are not performed while processors are running, \n\t * which rely on the assumption that the data layout doesn't change during calculations. \n\t */\n\tbool IsProcessing() const { return ProcessingScopeCount > 0; }\n\n\tFMassCommandBuffer& Defer() const { return *DeferredCommandBuffers[OpenedCommandBufferIndex].Get(); }\n\t/** \n\t * @param InCommandBuffer if not set then the default command buffer will be flushed. If set and there's already \n\t *\t\ta command buffer being flushed (be it the main one or a previously requested one) then this command buffer \n\t *\t\twill be queue itself.\n\t */\n\tvoid FlushCommands(TSharedPtr<FMassCommandBuffer>& InCommandBuffer);\n\n\tvoid FlushCommands();\n\n\t/** \n\t * Depending on the current state of Manager's command buffer the function will either move all the commands out of \n\t * InOutCommandBuffer into the main command buffer or append it to the list of command buffers waiting to be flushed.\n\t * @note as a consequence of the call InOutCommandBuffer can get its contents emptied due some of the underlying code using Move semantics\n\t */\n\tvoid AppendCommands(TSharedPtr<FMassCommandBuffer>& InOutCommandBuffer);\n\n\ttemplate<typename T>\n\tUE_DEPRECATED(5.5, \"This method will no longer be exposed. Use GetOrCreateConstSharedFragment instead.\")\n\tconst FConstSharedStruct& GetOrCreateConstSharedFragmentByHash(const uint32 Hash, const T& Fragment)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassConstSharedFragment>::IsDerived, \"Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.\");\n\t\tint32& Index = ConstSharedFragmentsMap.FindOrAddByHash(Hash, Hash, INDEX_NONE);\n\t\tif (Index == INDEX_NONE)\n\t\t{\n\t\t\tIndex = ConstSharedFragments.Add(FConstSharedStruct::Make(Fragment));\n\t\t}\n\t\treturn ConstSharedFragments[Index];\n\t}\n\nprivate:\n\ttemplate<typename T>\n\tconst FSharedStruct& GetOrCreateSharedFragmentByHash(const uint32 Hash, const T& Fragment)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassSharedFragment>::IsDerived, \"Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.\");\n\t\tint32& Index = SharedFragmentsMap.FindOrAddByHash(Hash, Hash, INDEX_NONE);\n\t\tif (Index == INDEX_NONE)\n\t\t{\n\t\t\tIndex = SharedFragments.Add(FSharedStruct::Make(Fragment));\n\t\t\t// note that even though we're copying the freshly created FSharedStruct instance it's perfectly fine since \n\t\t\t// FSharedStruct do guarantee there's not going to be data duplication (via a member shared pointer to hosted data)\n\t\t\tTArray<FSharedStruct>& InstancesOfType = SharedFragmentsTypeMap.FindOrAdd(T::StaticStruct(), {});\n\t\t\tInstancesOfType.Add(SharedFragments[Index]);\n\t\t}\n\n\t\treturn SharedFragments[Index];\n\t}\n\n\tconst FConstSharedStruct& GetOrCreateConstSharedFragmentByHash(const uint32 Hash, const UScriptStruct* InScriptStruct, const uint8* InStructMemory)\n\t{\n\t\tint32& Index = ConstSharedFragmentsMap.FindOrAddByHash(Hash, Hash, INDEX_NONE);\n\t\tif (Index == INDEX_NONE)\n\t\t{\n\t\t\tIndex = ConstSharedFragments.Add(FConstSharedStruct::Make(InScriptStruct, InStructMemory));\n\t\t}\n\t\treturn ConstSharedFragments[Index];\n\t}\n\n\tconst FSharedStruct& GetOrCreateSharedFragmentByHash(const uint32 Hash, const UScriptStruct* InScriptStruct, const uint8* InStructMemory)\n\t{\n\t\tint32& Index = SharedFragmentsMap.FindOrAddByHash(Hash, Hash, INDEX_NONE);\n\t\tif (Index == INDEX_NONE)\n\t\t{\n\t\t\tIndex = SharedFragments.Add(FSharedStruct::Make(InScriptStruct, InStructMemory));\n\t\t\t// note that even though we're copying the freshly created FSharedStruct instance it's perfectly fine since \n\t\t\t// FSharedStruct do guarantee there's not going to be data duplication (via a member shared pointer to hosted data)\n\t\t\tTArray<FSharedStruct>& InstancesOfType = SharedFragmentsTypeMap.FindOrAdd(InScriptStruct, {});\n\t\t\tInstancesOfType.Add(SharedFragments[Index]);\n\t\t}\n\t\treturn SharedFragments[Index];\n\t}\n\n\ttemplate<typename T, typename... TArgs>\n\tconst FConstSharedStruct& GetOrCreateConstSharedFragmentByHash(const uint32 Hash, TArgs&&... InArgs)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassConstSharedFragment>::IsDerived, \"Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.\");\n\t\tint32& Index = ConstSharedFragmentsMap.FindOrAddByHash(Hash, Hash, INDEX_NONE);\n\t\tif (Index == INDEX_NONE)\n\t\t{\n\t\t\tIndex = ConstSharedFragments.Add(FConstSharedStruct::Make<T>(Forward<TArgs>(InArgs)...));\n\t\t}\n\n\t\treturn ConstSharedFragments[Index];\n\t}\n\npublic:\n\n\ttemplate<typename T, typename... TArgs>\n\tUE_DEPRECATED(5.5, \"This method will no longer be exposed. Use GetOrCreateSharedFragment instead.\")\n\tconst FSharedStruct& GetOrCreateSharedFragmentByHash(const uint32 Hash, TArgs&&... InArgs)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassSharedFragment>::IsDerived, \"Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.\");\n\t\tint32& Index = SharedFragmentsMap.FindOrAddByHash(Hash, Hash, INDEX_NONE);\n\t\tif (Index == INDEX_NONE)\n\t\t{\n\t\t\tIndex = SharedFragments.Add(FSharedStruct::Make<T>(Forward<TArgs>(InArgs)...));\n\t\t\t// note that even though we're copying the freshly created FSharedStruct instance it's perfectly fine since \n\t\t\t// FSharedStruct do guarantee there's not going to be data duplication (via a member shared pointer to hosted data)\n\t\t\tTArray<FSharedStruct>& InstancesOfType = SharedFragmentsTypeMap.FindOrAdd(T::StaticStruct(), {});\n\t\t\tInstancesOfType.Add(SharedFragments[Index]);\n\t\t}\n\n\t\treturn SharedFragments[Index];\n\t}\n\n\t/**\n\t * Returns or creates a shared struct associated to a given shared fragment set of values\n\t * identified internally by a CRC.\n\t * Use this overload when an instance of the desired const shared fragment type is available and\n\t * that can be used directly to compute a CRC (i.e., UE::StructUtils::GetStructCrc32)\n\t *\te.g.,\n\t *\tUSTRUCT()\n\t *\tstruct FIntConstSharedFragment : public FMassConstSharedFragment\n\t *\t{\n\t *\t\tGENERATED_BODY()\n\t *\n\t *\t\tUPROPERTY()\n\t *\t\tint32 Value = 0;\n\t *\t};\n\t *\n\t *\tFIntConstSharedFragment Fragment;\n\t *\tFragment.Value = 123;\n\t *\tconst FConstSharedStruct SharedStruct = EntityManager.GetOrCreateConstSharedFragment(Fragment);\n\t *\n\t * @params Fragment Instance of the desired fragment type\n\t * @return FConstSharedStruct to the matching, or newly created shared fragment\n\t */\n\ttemplate<typename T>\n\tconst FConstSharedStruct& GetOrCreateConstSharedFragment(const T& Fragment)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassConstSharedFragment>::IsDerived,\n\t\t\t\"Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.\");\n\t\tconst uint32 Hash = UE::StructUtils::GetStructCrc32(FConstStructView::Make(Fragment));\nPRAGMA_DISABLE_DEPRECATION_WARNINGS\n\t\treturn GetOrCreateConstSharedFragmentByHash(Hash, Fragment);\nPRAGMA_ENABLE_DEPRECATION_WARNINGS\n\t}\n\n\t/**\n\t * Returns or creates a shared struct associated to a given shared fragment set of values\n\t * identified internally by a CRC.\n\t * Use this overload when an instance of the desired shared fragment type is available and\n\t * that can be used directly to compute a CRC (i.e., UE::StructUtils::GetStructCrc32)\n\t *\te.g.,\n\t *\tUSTRUCT()\n\t *\tstruct FIntSharedFragment : public FMassSharedFragment\n\t *\t{\n\t *\t\tGENERATED_BODY()\n\t *\n\t *\t\tUPROPERTY()\n\t *\t\tint32 Value = 0;\n\t *\t};\n\t *\n\t *\tFIntSharedFragment Fragment;\n\t *\tFragment.Value = 123;\n\t *\tconst FSharedStruct SharedStruct = EntityManager.GetOrCreateSharedFragment(Fragment);\n\t *\n\t * @params Fragment Instance of the desired fragment type\n\t * @return FSharedStruct to the matching, or newly created shared fragment\n\t */\n\ttemplate<typename T>\n\tconst FSharedStruct& GetOrCreateSharedFragment(const T& Fragment)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassSharedFragment>::IsDerived,\n\t\t\t\"Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.\");\n\t\tconst uint32 Hash = UE::StructUtils::GetStructCrc32(FConstStructView::Make(Fragment));\n\t\treturn GetOrCreateSharedFragmentByHash(Hash, Fragment);\n\t}\n\n\t/**\n\t * Returns or creates a shared struct associated to a given shared fragment set of values\n\t * identified internally by a CRC.\n\t * Use this overload when values can be provided as constructor arguments for the desired const shared fragment type and\n\t * that can be used directly to compute a CRC (i.e., UE::StructUtils::GetStructCrc32)\n \t *\te.g.,\n\t *\tUSTRUCT()\n\t *\tstruct FIntConstSharedFragment : public FMassConstSharedFragment\n\t *\t{\n\t *\t\tGENERATED_BODY()\n\t *\n\t *\t\tFIntConstSharedFragment(const int32 InValue) : Value(InValue) {}\n\t *\n\t *\t\tUPROPERTY()\n\t *\t\tint32 Value = 0;\n\t *\t};\n\t *\n\t *\tconst FConstSharedStruct SharedStruct = EntityManager.GetOrCreateConstSharedFragment<FIntConstSharedFragment>(123);\n\t *\n\t * @params InArgs List of arguments provided to the constructor of the desired fragment type\n\t * @return FConstSharedStruct to the matching, or newly created shared fragment\n\t */\n\ttemplate<typename T, typename... TArgs>\n\tconst FConstSharedStruct& GetOrCreateConstSharedFragment(TArgs&&... InArgs)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassConstSharedFragment>::IsDerived,\n\t\t\t\"Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.\");\n\t\tT Struct(Forward<TArgs>(InArgs)...);\n\t\tconst uint32 Hash = UE::StructUtils::GetStructCrc32(FConstStructView::Make(Struct));\nPRAGMA_DISABLE_DEPRECATION_WARNINGS\n\t\treturn GetOrCreateConstSharedFragmentByHash(Hash, MoveTemp(Struct));\nPRAGMA_ENABLE_DEPRECATION_WARNINGS\n\t}\n\n\t/**\n\t * Returns or creates a shared struct associated to a given shared fragment set of values\n\t * identified internally by a CRC.\n\t * Use this overload when values can be provided as constructor arguments for the desired shared fragment type and\n\t * that can be used directly to compute a CRC (i.e., UE::StructUtils::GetStructCrc32)\n \t *\te.g.,\n\t *\tUSTRUCT()\n\t *\tstruct FIntSharedFragment : public FMassSharedFragment\n\t *\t{\n\t *\t\tGENERATED_BODY()\n\t *\n\t *\t\tFIntSharedFragment(const int32 InValue) : Value(InValue) {}\n\t *\n\t *\t\tUPROPERTY()\n\t *\t\tint32 Value = 0;\n\t *\t};\n\t *\n\t *\tconst FSharedStruct SharedStruct = EntityManager.GetOrCreateSharedFragment<FIntSharedFragment>(123);\n\t *\n\t * @params InArgs List of arguments provided to the constructor of the desired fragment type\n\t * @return FSharedStruct to the matching, or newly created shared fragment\n\t */\n\ttemplate<typename T, typename... TArgs>\n\tconst FSharedStruct& GetOrCreateSharedFragment(TArgs&&... InArgs)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassSharedFragment>::IsDerived,\n\t\t\t\"Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.\");\n\t\tT Struct(Forward<TArgs>(InArgs)...);\n\t\tconst uint32 Hash = UE::StructUtils::GetStructCrc32(FConstStructView::Make(Struct));\n\t\treturn GetOrCreateSharedFragmentByHash(Hash, MoveTemp(Struct));\n\t}\n\n\t/**\n\t * Returns or creates a shared struct associated to a given shared fragment set of values\n\t * identified internally by a CRC.\n\t * Use this overload when the reflection data and the memory of an instance of the desired const shared fragment type\n\t * is available and that can be used directly to compute a CRC (i.e., UE::StructUtils::GetStructCrc32)\n\t * e.g.,\n\t * FSharedStruct SharedStruct = EntityManager.GetOrCreateConstSharedFragment(*StructView.GetScriptStruct(), StructView.GetMemory());\n\t *\n\t * @params InScriptStruct Reflection data structure associated to the desired fragment type\n\t * @params InStructMemory Actual data of the desired fragment type \n\t * @return FConstSharedStruct to the matching, or newly created shared fragment\n\t */\n\tconst FConstSharedStruct& GetOrCreateConstSharedFragment(const UScriptStruct& InScriptStruct, const uint8* InStructMemory)\n\t{\n\t\tcheckf(InScriptStruct.IsChildOf(TBaseStructure<FMassConstSharedFragment>::Get()),\n\t\t\tTEXT(\"Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.\"));\n\t\tconst uint32 Hash = UE::StructUtils::GetStructCrc32(InScriptStruct, InStructMemory);\n\t\treturn GetOrCreateConstSharedFragmentByHash(Hash, &InScriptStruct, InStructMemory);\n\t}\n\n\t/**\n\t * Returns or creates a shared struct associated to a given shared fragment set of values\n\t * identified internally by a CRC.\n\t * Use this overload when the reflection data and the memory of an instance of the desired shared fragment type\n\t * is available and that can be used directly to compute a CRC (i.e., UE::StructUtils::GetStructCrc32)\n\t * e.g.,\n\t * FSharedStruct SharedStruct = EntityManager.GetOrCreateSharedFragment(*StructView.GetScriptStruct(), StructView.GetMemory());\n\t *\n\t * @params InScriptStruct Reflection data structure associated to the desired fragment type\n\t * @params InStructMemory Actual data of the desired fragment type \n\t * @return FSharedStruct to the matching, or newly created shared fragment\n\t */\n\tconst FSharedStruct& GetOrCreateSharedFragment(const UScriptStruct& InScriptStruct, const uint8* InStructMemory)\n\t{\n\t\tcheckf(InScriptStruct.IsChildOf(TBaseStructure<FMassSharedFragment>::Get()),\n\t\t\tTEXT(\"Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.\"));\n\t\tconst uint32 Hash = UE::StructUtils::GetStructCrc32(InScriptStruct, InStructMemory);\n\t\treturn GetOrCreateSharedFragmentByHash(Hash, &InScriptStruct, InStructMemory);\n\t}\n\n\t/**\n\t * Returns or creates a shared struct associated to a given shared fragment set of values\n\t * identified internally by a CRC.\n\t * Use this overload when a different struct should be used to compute a CRC (i.e., UE::StructUtils::GetStructCrc32)\n\t * and values can be provided as constructor arguments for the desired const shared fragment type\n\t *\te.g.,\n\t *\n\t *\tUSTRUCT()\n\t *\tstruct FIntConstSharedFragmentParams\n\t *\t{\n\t *\t\tGENERATED_BODY()\n\t *\n\t *\t\tFIntConstSharedFragmentParams(const int32 InValue) : Value(InValue) {}\n\t *\n\t *\t\tUPROPERTY()\n\t *\t\tint32 Value = 0;\n\t *\t};\n\t *\n\t *\tUSTRUCT()\n\t *\tstruct FIntConstSharedFragment : public FMassConstSharedFragment\n\t *\t{\n\t *\t\tGENERATED_BODY()\n\t *\n\t *\t\tFIntConstSharedFragment(const FIntConstSharedFragmentParams& InParams) : Value(InParams.Value) {}\n\t *\n\t *\t\tint32 Value = 0;\n\t *\t};\n\t *\n\t *\tFIntConstSharedFragmentParams Params(123);\n\t *\tconst FConstSharedStruct SharedStruct = EntityManager.GetOrCreateConstSharedFragment<FIntConstSharedFragment>(FConstStructView::Make(Params), Params);\n\t *\n\t * @params HashingHelperStruct Struct view passed to UE::StructUtils::GetStructCrc32 to compute the CRC\n\t * @params InArgs List of arguments provided to the constructor of the desired fragment type\n\t * @return FConstSharedStruct to the matching, or newly created shared fragment\n\t */\n\ttemplate<typename T, typename... TArgs>\n\tconst FConstSharedStruct& GetOrCreateConstSharedFragment(const FConstStructView HashingHelperStruct, TArgs&&... InArgs)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassConstSharedFragment>::IsDerived,\n\t\t\t\"Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.\");\n\t\tT Fragment(Forward<TArgs>(InArgs)...);\n\t\tconst uint32 Hash = UE::StructUtils::GetStructCrc32(HashingHelperStruct);\nPRAGMA_DISABLE_DEPRECATION_WARNINGS\n\t\treturn GetOrCreateConstSharedFragmentByHash(Hash, MoveTemp(Fragment));\nPRAGMA_ENABLE_DEPRECATION_WARNINGS\n\t}\n\n\t/**\n\t * Returns or creates a shared struct associated to a given shared fragment set of values\n\t * identified internally by a CRC.\n\t * Use this overload when a different struct should be used to compute a CRC (i.e., UE::StructUtils::GetStructCrc32)\n\t * and values can be provided as constructor arguments for the desired shared fragment type\n\t *\te.g.,\n\t *\n\t *\tUSTRUCT()\n\t *\tstruct FIntSharedFragmentParams\n\t *\t{\n\t *\t\tGENERATED_BODY()\n\t *\n\t *\t\tFInSharedFragmentParams(const int32 InValue) : Value(InValue) {}\n\t *\n\t *\t\tUPROPERTY()\n\t *\t\tint32 Value = 0;\n\t *\t};\n\t *\n\t *\tUSTRUCT()\n\t *\tstruct FIntSharedFragment : public FMassSharedFragment\n\t *\t{\n\t *\t\tGENERATED_BODY()\n\t *\n\t *\t\tFIntSharedFragment(const FIntConstSharedFragmentParams& InParams) : Value(InParams.Value) {}\n\t *\n\t *\t\tint32 Value = 0;\n\t *\t};\n\t *\n\t *\tFIntSharedFragmentParams Params(123);\n\t *\tconst FSharedStruct SharedStruct = EntityManager.GetOrCreateSharedFragment<FIntSharedFragment>(FConstStructView::Make(Params), Params);\n\t *\n\t * @params HashingHelperStruct Struct view passed to UE::StructUtils::GetStructCrc32 to compute the CRC\n\t * @params InArgs List of arguments provided to the constructor of the desired fragment type\n\t * @return FSharedStruct to the matching, or newly created shared fragment\n\t */\n\ttemplate<typename T, typename... TArgs>\n\tconst FSharedStruct& GetOrCreateSharedFragment(const FConstStructView HashingHelperStruct, TArgs&&... InArgs)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassSharedFragment>::IsDerived,\n\t\t\t\"Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.\");\n\t\tT Fragment(Forward<TArgs>(InArgs)...);\n\t\tconst uint32 Hash = UE::StructUtils::GetStructCrc32(HashingHelperStruct);\n\t\treturn GetOrCreateSharedFragmentByHash(Hash, MoveTemp(Fragment));\n\t}\n\n\ttemplate<typename T>\n\tvoid ForEachSharedFragment(TFunctionRef< void(T& /*SharedFragment*/) > ExecuteFunction)\n\t{\n\t\tif (TArray<FSharedStruct>* InstancesOfType = SharedFragmentsTypeMap.Find(T::StaticStruct()))\n\t\t{\n\t\t\tfor (const FSharedStruct& SharedStruct : *InstancesOfType)\n\t\t\t{\n\t\t\t\tExecuteFunction(SharedStruct.Get<T>());\n\t\t\t}\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tvoid ForEachSharedFragmentConditional(TFunctionRef< bool(T& /*SharedFragment*/) > ConditionFunction, TFunctionRef< void(T& /*SharedFragment*/) > ExecuteFunction)\n\t{\n\t\tif (TArray<FSharedStruct>* InstancesOfType = SharedFragmentsTypeMap.Find(T::StaticStruct()))\n\t\t{\n\t\t\tfor (const FSharedStruct& SharedStruct : *InstancesOfType)\n\t\t\t{\n\t\t\t\tT& StructInstanceRef = SharedStruct.Get<T>();\n\t\t\t\tif (ConditionFunction(StructInstanceRef))\n\t\t\t\t{\n\t\t\t\t\tExecuteFunction(StructInstanceRef);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tFMassObserverManager& GetObserverManager() { return ObserverManager; }\n\n\tFOnNewArchetypeDelegate& GetOnNewArchetypeEvent() { return OnNewArchetypeEvent; }\n\t/** \n\t * Fetches the world associated with the Owner. \n\t * @note that it's ok for a given EntityManager to not have an owner or the owner not being part of a UWorld, depending on the use case\n\t */\n\tUWorld* GetWorld() const { return Owner.IsValid() ? Owner->GetWorld() : nullptr; }\n\tUObject* GetOwner() const { return Owner.Get(); }\n\n\tvoid SetDebugName(const FString& NewDebugGame);\n#if WITH_MASSENTITY_DEBUG\n\tvoid DebugPrintArchetypes(FOutputDevice& Ar, const bool bIncludeEmpty = true) const;\n\tvoid DebugGetArchetypesStringDetails(FOutputDevice& Ar, const bool bIncludeEmpty = true) const;\n\tvoid DebugGetArchetypeFragmentTypes(const FMassArchetypeHandle& Archetype, TArray<const UScriptStruct*>& InOutFragmentList) const;\n\tint32 DebugGetArchetypeEntitiesCount(const FMassArchetypeHandle& Archetype) const;\n\tint32 DebugGetArchetypeEntitiesCountPerChunk(const FMassArchetypeHandle& Archetype) const;\n\tint32 DebugGetEntityCount() const;\n\tint32 DebugGetArchetypesCount() const;\n\tvoid DebugRemoveAllEntities();\n\tvoid DebugForceArchetypeDataVersionBump();\n\tvoid DebugGetArchetypeStrings(const FMassArchetypeHandle& Archetype, TArray<FName>& OutFragmentNames, TArray<FName>& OutTagNames);\n\tFMassEntityHandle DebugGetEntityIndexHandle(const int32 EntityIndex) const;\n\tconst FString& DebugGetName() const;\n\n\tFMassRequirementAccessDetector& GetRequirementAccessDetector();\n\n\t// For use by the friend MassDebugger\n\tUE::Mass::IEntityStorageInterface& DebugGetEntityStorageInterface();\n\t// For use by the friend MassDebugger\n\tconst UE::Mass::IEntityStorageInterface& DebugGetEntityStorageInterface() const;\n#endif // WITH_MASSENTITY_DEBUG\n\nprotected:\n\t/** Called on the child process upon process's forking */\n\tvoid OnPostFork(EForkProcessRole Role);\n\n\tvoid GetMatchingArchetypes(const FMassFragmentRequirements& Requirements, TArray<FMassArchetypeHandle>& OutValidArchetypes, const uint32 FromArchetypeDataVersion) const;\n\t\n\t/** \n\t * A \"similar\" archetype is an archetype exactly the same as SourceArchetype except for one composition aspect \n\t * like Fragments or \"Tags\" \n\t */\n\tFMassArchetypeHandle InternalCreateSimilarArchetype(const TSharedPtr<FMassArchetypeData>& SourceArchetype, const FMassTagBitSet& OverrideTags);\n\tFMassArchetypeHandle InternalCreateSimilarArchetype(const TSharedPtr<FMassArchetypeData>& SourceArchetype, const FMassFragmentBitSet& OverrideFragments);\n\n\tFMassArchetypeHandle InternalCreateSimilarArchetype(const FMassArchetypeData& SourceArchetypeRef, FMassArchetypeCompositionDescriptor&& NewComposition);\n\n\tvoid InternalAppendFragmentsAndTagsToArchetypeCompositionDescriptor(FMassArchetypeCompositionDescriptor& InOutComposition,\n\t\tTConstArrayView<const UScriptStruct*> FragmentsAndTagsList) const;\n\nprivate:\n\tvoid InternalBuildEntity(FMassEntityHandle Entity, const FMassArchetypeHandle& ArchetypeHandle, const FMassArchetypeSharedFragmentValues& SharedFragmentValues);\n\tvoid InternalReleaseEntity(FMassEntityHandle Entity);\n\n\t/** \n\t *  Adds fragments in FragmentList to Entity. Only the unique fragments will be added.\n\t *  @return Bitset for the added fragments (might be empty or a subset of `InFragments` depending on the current archetype fragments)\n\t */\n\tFMassFragmentBitSet InternalAddFragmentListToEntityChecked(FMassEntityHandle Entity, const FMassFragmentBitSet& InFragments);\n\n\t/** \n\t *  Similar to InternalAddFragmentListToEntity but expects NewFragmentList not overlapping with current entity's\n\t *  fragment list. It's callers responsibility to ensure that's true. Failing this will cause a `check` fail.\n\t */\n\tvoid InternalAddFragmentListToEntity(FMassEntityHandle Entity, const FMassFragmentBitSet& InFragments);\n\t/** Note that it's the caller's responsibility to ensure `FragmentType` is a kind of FMassFragment */\n\tvoid* InternalGetFragmentDataChecked(FMassEntityHandle Entity, const UScriptStruct* FragmentType) const;\n\t/** Note that it's the caller's responsibility to ensure `FragmentType` is a kind of FMassFragment */\n\tvoid* InternalGetFragmentDataPtr(FMassEntityHandle Entity, const UScriptStruct* FragmentType) const;\n\t/** Note that it's the caller's responsibility to ensure `ConstSharedFragmentType` is a kind of FMassSharedFragment */\n\tconst FConstSharedStruct* InternalGetConstSharedFragmentPtr(FMassEntityHandle Entity, const UScriptStruct* ConstSharedFragmentType) const;\n\t/** Note that it's the caller's responsibility to ensure `SharedFragmentType` is a kind of FMassSharedFragment */\n\tconst FSharedStruct* InternalGetSharedFragmentPtr(FMassEntityHandle Entity, const UScriptStruct* SharedFragmentType) const;\n\n\tTSharedRef<FEntityCreationContext> InternalBatchCreateReservedEntities(const FMassArchetypeHandle& ArchetypeHandle,\n\t\tconst FMassArchetypeSharedFragmentValues& SharedFragmentValues, TConstArrayView<FMassEntityHandle> ReservedEntities);\n\t\n#if MASS_CONCURRENT_RESERVE\n\tUE::Mass::IEntityStorageInterface& GetEntityStorageInterface();\n\tconst UE::Mass::IEntityStorageInterface& GetEntityStorageInterface() const;\n#else\n\tUE::Mass::FSingleThreadedEntityStorage& GetEntityStorageInterface();\n\tconst UE::Mass::FSingleThreadedEntityStorage& GetEntityStorageInterface() const;\n#endif\n\n\t/**\n\t * If ActiveCreationContext is not valid the function creates a new shared FEntityCreationContext instance and returns that.\n\t * Otherwise ActiveCreationContext will get extended with ReservedEntities and EntityCollection, and returned by the function.\n\t */\n\tTSharedRef<FEntityCreationContext> GetOrMakeCreationContext(TConstArrayView<FMassEntityHandle> ReservedEntities, FMassArchetypeEntityCollection&& EntityCollection);\n\tbool IsDuringEntityCreation() const { return ActiveCreationContext.IsValid(); }\n\t\n\t/** \n\t * This type is used in entity mutating batched API to ensure the active FEntityCreationContext gets dirtied \n\t * upon function's end (since the mutating operations render FEntityCreationContext.EntityCollections invalid).\n\t * It also serves as a cached IsDuringEntityCreation value.\n\t */\n\tstruct FScopedCreationContextOperations\n\t{\n\t\tFScopedCreationContextOperations(FMassEntityManager& InManager)\n\t\t\t: bIsDuringEntityCreation(InManager.IsDuringEntityCreation())\n\t\t\t, Manager(InManager)\n\t\t{}\n\t\t~FScopedCreationContextOperations()\n\t\t{\n\t\t\tif (bIsDuringEntityCreation)\n\t\t\t{\n\t\t\t\tManager.DirtyCreationContext();\n\t\t\t}\n\t\t\t// else, there's nothing to do, there's no creation context to call functions for\n\t\t}\n\n\t\tbool IsAllowedToTriggerObservers() const { return (bIsDuringEntityCreation == false); }\n\n\tprivate:\n\t\tconst bool bIsDuringEntityCreation = false;\n\t\tFMassEntityManager& Manager;\n\t};\n\tfriend FScopedCreationContextOperations;\n\n\t/** @return whether actual context dirtying took place which is equivalent to IsDuringEntityCreation */\n\tbool DirtyCreationContext();\n\n\t/** \n\t * @return whether it's allowed for observers to get triggered. If not then the active creation context will be dirtied\n\t *\tto cause observers triggering upon context's destruction\n\t */\n\tbool IsAllowedToTriggerObservers() { return DirtyCreationContext() == false; }\n\tbool DebugDoCollectionsOverlapCreationContext(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections) const;\n\t\t\nprivate:\n\n\tfriend struct UE::Mass::Private::FEntityStorageInitializer;\n\tusing FEntityStorageContainerType = TVariant<\n\t\tFEmptyVariantState,\n\t\tUE::Mass::FSingleThreadedEntityStorage,\n\t\tUE::Mass::FConcurrentEntityStorage>;\n\tFEntityStorageContainerType EntityStorage;\n\n\t/** Never access directly, use GetOrMakeCreationContext instead. */\n\tTWeakPtr<FEntityCreationContext> ActiveCreationContext;\n\n\tstd::atomic<bool> bCommandBufferFlushingInProgress = false;\n\n\t/**\n\t * This index will be enough to control which buffer is available for pushing commands since flashing is taking place \n\t * in the game thread and pushing commands to the buffer fetched by Defer() is only supported also on the game thread\n\t * (due to checking the cached thread ID).\n\t * The whole CL aims to support non-mass code trying to push commands while the flushing is going on (as triggered\n\t * by MassObservers reacting to the commands being flushed currently).\n\t */\n\tuint8 OpenedCommandBufferIndex = 0;\n\tTStaticArray<TSharedPtr<FMassCommandBuffer>, 2> DeferredCommandBuffers;\n\t\n\tstd::atomic<int32> ProcessingScopeCount = 0;\n\n\t// the \"version\" number increased every time an archetype gets added\n\tuint32 ArchetypeDataVersion = 0;\n\n\t// Map of hash of sorted fragment list to archetypes with that hash\n\tTMap<uint32, TArray<TSharedPtr<FMassArchetypeData>>> FragmentHashToArchetypeMap;\n\n\t// Map to list of archetypes that contain the specified fragment type\n\tTMap<const UScriptStruct*, TArray<TSharedPtr<FMassArchetypeData>>> FragmentTypeToArchetypeMap;\n\n\t// Contains all archetypes ever created. The array always growing and a given archetypes remains at a given index \n\t// throughout its lifetime, and the index is never reused for another archetype. \n\tTArray<TSharedPtr<FMassArchetypeData>> AllArchetypes;\n\n\t// Shared fragments\n\tTArray<FConstSharedStruct> ConstSharedFragments;\n\t// Hash/Index in array pair\n\tTMap<uint32, int32> ConstSharedFragmentsMap;\n\n\tTArray<FSharedStruct> SharedFragments;\n\t// Hash/Index in array pair, indices point at SharedFragments\n\tTMap<uint32, int32> SharedFragmentsMap;\n\t// Maps specific struct type to a collection of FSharedStruct instances of that type\n\tTMap<const UScriptStruct*, TArray<FSharedStruct>> SharedFragmentsTypeMap;\n\n\tFMassObserverManager ObserverManager;\n\n#if WITH_MASSENTITY_DEBUG\n\tFMassRequirementAccessDetector RequirementAccessDetector;\n\tFString DebugName;\n#endif // WITH_MASSENTITY_DEBUG\n\n\tTWeakObjectPtr<UObject> Owner;\n\n\tFOnNewArchetypeDelegate OnNewArchetypeEvent;\n\n\tbool bInitialized = false;\n\tbool bFirstCommandFlush = true;\n\n\tFDelegateHandle OnPostForkHandle;\n};\n",
      "lines": 1130
    },
    {
      "file_path": "MassEntity\\Public\\MassEntityManagerStorage.h",
      "extension": ".h",
      "size_bytes": 9570,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n#pragma once\n\n#include \"Async/Mutex.h\"\n#include \"Containers/ChunkedArray.h\"\n#include \"Misc/TVariant.h\"\n#include \"Templates/SharedPointer.h\"\n#include \"MassProcessingTypes.h\"\n\nstruct FMassArchetypeData;\nstruct FMassEntityHandle;\n\n// Initialization parameters to configure MassEntityManager to reserve entities only single threaded\n// Supported in all build configurations\nstruct MASSENTITY_API FMassEntityManager_InitParams_SingleThreaded {};\n\n// Initialization parameters to configure MassEntityManager to concurrently reserve entities\n// Only supported in editor builds.\n//\n// Expected static memory requirement for array of Page pointers can be computed:\n// MaxPages = MaxEntityCount / MaxEntitiesPerPage\n// MemorySize = MaxPages * sizeof(Page**)\n//\n// For default values, expectation is 128kB\nstruct MASSENTITY_API FMassEntityManager_InitParams_Concurrent\n{\n\t// Maximum supported entities by the MassEntityManager\n\t// Must be multiple of 2\n\tuint32 MaxEntityCount = 1 << 30; // 1 billion\n\n\t// Number of entities per chunk\n\t// Must be multiple of 2\n\tuint32 MaxEntitiesPerPage = 1 << 16; // 65536\n};\n\nusing FMassEntityManagerStorageInitParams = TVariant<FMassEntityManager_InitParams_SingleThreaded, FMassEntityManager_InitParams_Concurrent>;\n\nnamespace UE::Mass\n{\n\t/**\n\t * Interface that abstracts the storage system for Mass Entities in the EntityManager\n\t * This may be temporary until the concurrent mechanism has been vetted for performance\n\t */\n\tclass IEntityStorageInterface\n\t{\n\tpublic:\n\t\tenum class EEntityState\n\t\t{\n\t\t\t// Entity index refers to an entity that is free to be reserved or created\n\t\t\tFree,\n\t\t\t// Entity index refers to a reserved entity\n\t\t\tReserved,\n\t\t\t// Entity index refers to an entity assigned to an archetype\n\t\t\tCreated\n\t\t};\n\t\tvirtual ~IEntityStorageInterface() = default;\n\n\t\tvirtual FMassArchetypeData* GetArchetype(int32 Index) = 0;\n\t\tvirtual const FMassArchetypeData* GetArchetype(int32 Index) const = 0;\n\t\tvirtual TSharedPtr<FMassArchetypeData>& GetArchetypeAsShared(int32 Index) = 0;\n\t\tvirtual const TSharedPtr<FMassArchetypeData>& GetArchetypeAsShared(int32 Index) const = 0;\n\t\n\t\tvirtual void SetArchetypeFromShared(int32 Index, TSharedPtr<FMassArchetypeData>& Archetype) = 0;\n\t\tvirtual void SetArchetypeFromShared(int32 Index, const TSharedPtr<FMassArchetypeData>& Archetype) = 0;\n\n\t\t// Returns true if the given entity at index is currently reserved\n\t\t// False if free or assigned an archetype\n\t\tvirtual EEntityState GetEntityState(int32 Index) const = 0;\n\t\n\t\tvirtual int32 GetSerialNumber(int32 Index) const = 0;\n\n\t\t// Checks if index can be used to access entity data\n\t\tvirtual bool IsValidIndex(int32 Index) const = 0;\n\t\tvirtual SIZE_T GetAllocatedSize() const = 0;\n\n\t\t// Checks if entity at Index is built\n\t\tvirtual bool IsValid(int32 Index) const = 0;\n\n\t\tvirtual FMassEntityHandle AcquireOne() = 0;\n\t\t// @return number of entities actually added\n\t\tint32 Acquire(const int32 Count, TArray<FMassEntityHandle>& OutEntityHandles);\n\t\tvirtual int32 Acquire(TArrayView<FMassEntityHandle> OutEntityHandles) = 0;\n\n\t\tvirtual int32 Release(TConstArrayView<FMassEntityHandle> Handles) = 0;\n\t\tvirtual int32 ReleaseOne(FMassEntityHandle Handles) = 0;\n\t\t\n\t\t// Bypasses Serial Number Check\n\t\t// Only use if caller has ensured serial number matches or for debug purposes\n\t\tvirtual int32 ForceRelease(TConstArrayView<FMassEntityHandle> Handles) = 0;\n\t\tvirtual int32 ForceReleaseOne(FMassEntityHandle Handle) = 0;\n\n\t\t// Returns the number of entities that are not free\n\t\t// For debug purposes only.  In multi-threaded environments, the result is going to be out of date\n\t\tvirtual int32 Num() const = 0;\n\n\t\t// Returns the number of entities that are free\n\t\t// For debug purposes only.  In multi-threaded environments, the result is going to be out of date\n\t\tvirtual int32 ComputeFreeSize() const = 0;\n\t};\n\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t// FSingleThreadedEntityStorage\n\n\t/**\n\t * This storage backend should be used when the user of MassEntityManager can guarantee\n\t * that all entity management will be done on a single thread.\n\t */\n\tclass FSingleThreadedEntityStorage final : public IEntityStorageInterface\n\t{\n\tpublic:\n\t\tvoid Initialize(const FMassEntityManager_InitParams_SingleThreaded&);\n\t\tvirtual FMassArchetypeData* GetArchetype(int32 Index) override;\n\t\tvirtual const FMassArchetypeData* GetArchetype(int32 Index) const override;\n\t\tvirtual TSharedPtr<FMassArchetypeData>& GetArchetypeAsShared(int32 Index) override;\n\t\tvirtual const TSharedPtr<FMassArchetypeData>& GetArchetypeAsShared(int32 Index) const override;\n\t\tvirtual void SetArchetypeFromShared(int32 Index, TSharedPtr<FMassArchetypeData>&) override;\n\t\tvirtual void SetArchetypeFromShared(int32 Index, const TSharedPtr<FMassArchetypeData>&) override;\n\t\tvirtual EEntityState GetEntityState(int32 Index) const override;\n\t\tvirtual int32 GetSerialNumber(int32 Index) const override;\n\t\tvirtual bool IsValidIndex(int32 Index) const override;\n\t\tvirtual SIZE_T GetAllocatedSize() const override;\n\t\tvirtual bool IsValid(int32 Index) const override;\n\t\tvirtual FMassEntityHandle AcquireOne() override;\n\t\tusing IEntityStorageInterface::Acquire;\n\t\tvirtual int32 Acquire(TArrayView<FMassEntityHandle> OutEntityHandles) override;\n\t\tvirtual int32 Release(TConstArrayView<FMassEntityHandle> Handles) override;\n\t\tvirtual int32 ReleaseOne(FMassEntityHandle Handle) override;\n\t\tvirtual int32 ForceRelease(TConstArrayView<FMassEntityHandle> Handles) override;\n\t\tvirtual int32 ForceReleaseOne(FMassEntityHandle Handle) override;\n\t\tvirtual int32 Num() const override;\n\t\tvirtual int32 ComputeFreeSize() const override;\n\tprivate:\n\t\n\t\tstruct FEntityData\n\t\t{\n\t\t\tTSharedPtr<FMassArchetypeData> CurrentArchetype;\n\t\t\tint32 SerialNumber = 0;\n\t\t\t\n\t\t\t~FEntityData();\n\t\t\tvoid Reset();\n\t\t\tbool IsValid() const;\n\t\t};\n\n\t\tstd::atomic<int32> SerialNumberGenerator = 0;\n\t\tTChunkedArray<FEntityData> Entities;\n\t\tTArray<int32> EntityFreeIndexList;\n\t};\n\n\t//////////////////////////////////////////////////////////////////////\n\t// FConcurrentEntityStorage\n\n\t/**\n\t * This storage backend allows for entities to be concurrently reserved.  Reserved entities can also\n\t * be concurrently freed.\n\t * Creation of entities (ie. assignment of an archetype and addition of data into chunks) cannot be done\n\t * concurrently with this implementation.\n\t */\n\tclass FConcurrentEntityStorage final : public IEntityStorageInterface\n\t{\n\tpublic:\n\n\t\tvoid Initialize(const FMassEntityManager_InitParams_Concurrent& InInitializationParams);\n\n\t\tvirtual ~FConcurrentEntityStorage() override;\n\n\t\tvirtual FMassArchetypeData* GetArchetype(int32 Index) override;\n\t\tvirtual const FMassArchetypeData* GetArchetype(int32 Index) const override;\n\t\tvirtual TSharedPtr<FMassArchetypeData>& GetArchetypeAsShared(int32 Index) override;\n\t\tvirtual const TSharedPtr<FMassArchetypeData>& GetArchetypeAsShared(int32 Index) const override;\n\t\tvirtual void SetArchetypeFromShared(int32 Index, TSharedPtr<FMassArchetypeData>& Archetype) override;\n\t\tvirtual void SetArchetypeFromShared(int32 Index, const TSharedPtr<FMassArchetypeData>& Archetype) override;\n\t\tvirtual EEntityState GetEntityState(int32 Index) const override;\n\t\tvirtual int32 GetSerialNumber(int32 Index) const override;\n\t\tvirtual bool IsValidIndex(int32 Index) const override;\n\t\tvirtual SIZE_T GetAllocatedSize() const override;\n\t\tvirtual bool IsValid(int32 Index) const override;\n\t\tvirtual FMassEntityHandle AcquireOne() override;\n\t\tusing IEntityStorageInterface::Acquire;\n\t\tvirtual int32 Acquire(TArrayView<FMassEntityHandle> OutEntityHandles) override;\n\t\tvirtual int32 Release(TConstArrayView<FMassEntityHandle> Handles) override;\n\t\tvirtual int32 ReleaseOne(FMassEntityHandle Handle) override;\n\t\tvirtual int32 ForceRelease(TConstArrayView<FMassEntityHandle> Handles) override;\n\t\tvirtual int32 ForceReleaseOne(FMassEntityHandle Handle) override;\n\t\tvirtual int32 Num() const override;\n\t\tvirtual int32 ComputeFreeSize() const override;\n#if WITH_MASSENTITY_DEBUG\n\t\t/** @return whether the assumptions are still valid */\n\t\tMASSENTITY_API static bool DebugAssumptionsSelfTest();\n#endif // WITH_MASSENTITY_DEBUG\n\tprivate:\t\n\t\n\t\tstruct FEntityData\n\t\t{\n\t\t\tstatic constexpr int MaxGenerationBits = 30;\n\t\t\n\t\t\tTSharedPtr<FMassArchetypeData> CurrentArchetype;\n\t\t\t// Generation ID or version of the entity in this slot\n\t\t\tuint32 GenerationId : MaxGenerationBits = 0;\n\t\t\t// 1 if the entity is NOT free\n\t\t\tuint32 bIsAllocated : 1 = 0;\n\n\t\t\t~FEntityData();\n\t\t\t// Converts EntityData state into a SerialNumber for public usage\n\t\t\tint32 GetSerialNumber() const;\n\n\t\t\tbool operator==(const FEntityData& Other) const;\n\t\t};\n\t\n\t\tFEntityData& LookupEntity(int32 Index);\n\t\tconst FEntityData& LookupEntity(int32 Index) const;\n\n\t\t// Returns size of a page in bytes\n\t\tuint64 ComputePageSize() const;\n\n\t\t// @return whether the operation was successful. Will return false when OOM\n\t\tbool AddPage();\n\n\t\t// Number of allocated Entities\n\t\tstd::atomic<uint64> EntityCount = 0;\n\t\tuint32 MaximumEntityCountShift = 0;\n\t\tuint32 MaxEntitiesPerPage = 0;\n\t\tuint32 PageCount = 0;\n\t\t// ALWAYS acquire FreeListMutex before this one\n\t\tUE::FMutex PageAllocateMutex;\n\t\t// Pointer to array of pages\n\t\tFEntityData** EntityPages = nullptr;\n\t\n\t\tTArray<int32> EntityFreeIndexList;\n\t\tUE::FMutex FreeListMutex;\n\t};\n\t\n} // namespace UE::Mass",
      "lines": 233
    },
    {
      "file_path": "MassEntity\\Public\\MassEntityQuery.h",
      "extension": ".h",
      "size_bytes": 8080,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"UObject/Class.h\"\n#include \"Containers/ArrayView.h\"\n#include \"Containers/UnrealString.h\"\n#include \"MassEntityTypes.h\"\n#include \"MassArchetypeTypes.h\"\n#include \"MassExternalSubsystemTraits.h\"\n#include \"MassRequirements.h\"\n#include \"MassEntityQuery.generated.h\"\n\n\n/** \n *  FMassEntityQuery is a structure that is used to trigger calculations on cached set of valid archetypes as described \n *  by requirements. See the parent classes FMassFragmentRequirements and FMassSubsystemRequirements for setting up the \n *\trequired fragments and subsystems.\n * \n *  A query to be considered valid needs declared at least one EMassFragmentPresence::All, EMassFragmentPresence::Any \n *  EMassFragmentPresence::Optional fragment requirement.\n */\nUSTRUCT()\nstruct MASSENTITY_API FMassEntityQuery : public FMassFragmentRequirements, public FMassSubsystemRequirements\n{\n\tGENERATED_BODY()\n\n\tfriend struct FMassDebugger;\n\npublic:\n\tenum EParallelForMode\n\t{\n\t\tDefault, // use whatever the whole system has been configured for\n\t\tForceParallelExecution // force\n\t};\n\n\tFMassEntityQuery();\n\tFMassEntityQuery(std::initializer_list<UScriptStruct*> InitList);\n\tFMassEntityQuery(TConstArrayView<const UScriptStruct*> InitList);\n\tFMassEntityQuery(UMassProcessor& Owner);\n\n\tvoid RegisterWithProcessor(UMassProcessor& Owner);\n\n\t/** Runs ExecuteFunction on all entities matching Requirements */\n\tvoid ForEachEntityChunk(FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext, const FMassExecuteFunction& ExecuteFunction);\n\t\n\t/** Will first verify that the archetype given with Collection matches the query's requirements, and if so will run the other, more generic ForEachEntityChunk implementation */\n\tvoid ForEachEntityChunk(const FMassArchetypeEntityCollection& EntityCollection, FMassEntityManager& EntitySubsystem\n\t\t, FMassExecutionContext& ExecutionContext, const FMassExecuteFunction& ExecuteFunction);\n\n\t/**\n\t * Attempts to process every chunk of every affected archetype in parallel.\n\t */\n\tvoid ParallelForEachEntityChunk(FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext\n\t\t, const FMassExecuteFunction& ExecuteFunction, const EParallelForMode ParallelMode = Default);\n\n\tvoid ForEachEntityChunkInCollections(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, FMassEntityManager& EntityManager\n\t\t, FMassExecutionContext& ExecutionContext, const FMassExecuteFunction& ExecuteFunction);\n\n\tvoid ParallelForEachEntityChunkInCollection(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections\n\t\t, FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext, const FMassExecuteFunction& ExecuteFunction\n\t\t, const EParallelForMode ParallelMode);\n\n\t/** Will gather all archetypes from InEntityManager matching this->Requirements.\n\t *  Note that no work will be done if the cached data is up to date (as tracked by EntitySubsystemHash and \n\t *\tArchetypeDataVersion properties). */\n\tvoid CacheArchetypes(const FMassEntityManager& InEntityManager);\n\n\tvoid Clear()\n\t{\n\t\tFMassFragmentRequirements::Reset();\n\t\tFMassSubsystemRequirements::Reset();\n\t\tDirtyCachedData();\n\t}\n\n\tFORCEINLINE void DirtyCachedData()\n\t{\n\t\tEntitySubsystemHash = 0;\n\t\tLastUpdatedArchetypeDataVersion = 0;\n\t}\n\t\n\tbool DoesRequireGameThreadExecution() const \n\t{ \n\t\treturn FMassFragmentRequirements::DoesRequireGameThreadExecution() \n\t\t\t|| FMassSubsystemRequirements::DoesRequireGameThreadExecution() \n\t\t\t|| bRequiresMutatingWorldAccess;\n\t}\n\n\tvoid RequireMutatingWorldAccess() { bRequiresMutatingWorldAccess = true; }\n\n\tbool IsEmpty() const { return FMassFragmentRequirements::IsEmpty() && FMassSubsystemRequirements::IsEmpty(); }\n\n\tconst TArray<FMassArchetypeHandle>& GetArchetypes() const\n\t{ \n\t\treturn ValidArchetypes; \n\t}\n\n\t/** \n\t * Goes through ValidArchetypes and sums up the number of entities contained in them.\n\t * Note that the function is not const because calling it can result in re-caching of ValidArchetypes \n\t * @return the number of entities this given query would process if called \"now\"\n\t */\n\tint32 GetNumMatchingEntities(FMassEntityManager& InEntityManager);\n\n\t/** \n\t * Sums the entity range lengths for each collection in EntityCollections, where the collection's \n\t * archetype matches the querie's requirements.\n\t * @return the number of entities this given query would process if called \"now\" for EntityCollections\n\t */\n\tint32 GetNumMatchingEntities(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections);\n\n\t/**\n\t * Checks if any of ValidArchetypes has any entities.\n\t * Note that the function is not const because calling it can result in re-caching of ValidArchetypes\n\t * @return \"true\" if any of the ValidArchetypes has any entities, \"false\" otherwise\n\t */\n\tbool HasMatchingEntities(FMassEntityManager& InEntityManager);\n\n\t/** \n\t * Sets a chunk filter condition that will applied to each chunk of all valid archetypes. Note \n\t * that this condition won't be applied when a specific entity colleciton is used (via FMassArchetypeEntityCollection )\n\t * The value returned by InFunction controls whether to allow execution (true) or block it (false).\n\t */\n\tvoid SetChunkFilter(const FMassChunkConditionFunction& InFunction) { checkf(!HasChunkFilter(), TEXT(\"Chunk filter needs to be cleared before setting a new one.\")); ChunkCondition = InFunction; }\n\n\tvoid ClearChunkFilter() { ChunkCondition.Reset(); }\n\n\tbool HasChunkFilter() const { return bool(ChunkCondition); }\n\n\t/** \n\t * If ArchetypeHandle is among ValidArchetypes then the function retrieves requirements mapping cached for it,\n\t * otherwise an empty mapping will be returned (and the requirements binding will be done the slow way).\n\t */\n\tconst FMassQueryRequirementIndicesMapping& GetRequirementsMappingForArchetype(const FMassArchetypeHandle ArchetypeHandle) const;\n\n\tvoid ExportRequirements(FMassExecutionRequirements& OutRequirements) const;\n\n\t/** \n\t * Controls whether ParallelForEachEntityChunk creates separate command buffers for each job.\n\t * @see bAllowParallelCommands for more details\n\t */\n\tvoid SetParallelCommandBufferEnabled(const bool bInAllowParallelCommands) { bAllowParallelCommands = bInAllowParallelCommands; }\n\nprivate:\n\tstruct FScopedSubsystemRequirementsRestore\n\t{\n\t\tFScopedSubsystemRequirementsRestore(FMassExecutionContext& ExecutionContext);\n\t\t~FScopedSubsystemRequirementsRestore();\n\n\t\tFMassExecutionContext& CachedExecutionContext;\n\t\tFMassExternalSubsystemBitSet ConstSubsystemsBitSet;\n\t\tFMassExternalSubsystemBitSet MutableSubsystemsBitSet;\n\t};\n\n\t/** \n\t * This function represents a condition that will be called for every chunk to be processed before the actual \n\t * execution function is called. The chunk fragment requirements are already bound and ready to be used by the time \n\t * ChunkCondition is executed.\n\t */\n\tFMassChunkConditionFunction ChunkCondition;\n\n\tuint32 EntitySubsystemHash = 0;\n\tuint32 LastUpdatedArchetypeDataVersion = 0;\n\n\tTArray<FMassArchetypeHandle> ValidArchetypes;\n\tTArray<FMassQueryRequirementIndicesMapping> ArchetypeFragmentMapping;\n\n\t/** \n\t * Controls whether ParallelForEachEntityChunk created dedicated command buffer for each job. This is required \n\t * to ensure thread safety. Disable by calling SetParallelCommandBufferEnabled(false) if execution function doesn't \n\t * issue commands. Disabling will save some performance since it will avoid dynamic allocation of command buffers.\n\t * \n\t * @Note that disabling parallel commands will result in no command buffer getting passed to execution which in turn\n\t *\twill cause crashes if the underlying code does try to issue commands. \n\t */\n\tuint8 bAllowParallelCommands : 1 = true;\n\tuint8 bRequiresMutatingWorldAccess : 1 = false;\n\n\tEMassExecutionContextType ExpectedContextType = EMassExecutionContextType::Local;\n\n#if WITH_MASSENTITY_DEBUG\n\tuint8 bRegistered : 1;\n#endif // WITH_MASSENTITY_DEBUG\n};\n\n",
      "lines": 185
    },
    {
      "file_path": "MassEntity\\Public\\MassEntitySettings.h",
      "extension": ".h",
      "size_bytes": 3273,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassSettings.h\"\n#include \"MassProcessingPhaseManager.h\"\n#include \"MassProcessor.h\"\n#include \"StructUtils/InstancedStruct.h\"\n#include \"MassEntitySettings.generated.h\"\n\n\n#define GET_MASS_CONFIG_VALUE(a) (GetMutableDefault<UMassEntitySettings>()->a)\n\nstruct FPropertyChangedEvent;\n\n\n/**\n * Implements the settings for MassEntity plugin\n */\nUCLASS(config = Mass, defaultconfig, DisplayName = \"Mass Entity\")\nclass MASSENTITY_API UMassEntitySettings : public UMassModuleSettings\n{\n\tGENERATED_BODY()\npublic:\n#if WITH_EDITORONLY_DATA\n\tDECLARE_MULTICAST_DELEGATE_OneParam(FOnSettingsChange, const FPropertyChangedEvent& /*PropertyChangedEvent*/);\n#endif // WITH_EDITORONLY_DATA\n\tDECLARE_MULTICAST_DELEGATE(FOnInitialized);\n\n\tUMassEntitySettings(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());\n\n\tvoid BuildProcessorListAndPhases();\n\tvoid AddToActiveProcessorsList(TSubclassOf<UMassProcessor> ProcessorClass);\n\n\tTConstArrayView<FMassProcessingPhaseConfig> GetProcessingPhasesConfig();\n\tconst FMassProcessingPhaseConfig& GetProcessingPhaseConfig(const EMassProcessingPhase ProcessingPhase) const { check(ProcessingPhase != EMassProcessingPhase::MAX); return ProcessingPhasesConfig[int(ProcessingPhase)]; }\n\n\tstatic FOnInitialized& GetOnInitializedEvent() { return GET_MASS_CONFIG_VALUE(OnInitializedEvent); }\n#if WITH_EDITOR\n\tFOnSettingsChange& GetOnSettingsChange() { return OnSettingsChange; }\n\n\tstatic bool IsInitialized() { return GET_MASS_CONFIG_VALUE(bInitialized); }\n\nprotected:\n\tvirtual void PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent) override;\n\tvirtual void PostEditChangeChainProperty(struct FPropertyChangedChainEvent& PropertyChangedEvent) override;\n#endif // WITH_EDITOR\n\n\tvirtual void PostInitProperties() override;\n\tvirtual void BeginDestroy() override;\n\n\tvoid OnPostEngineInit();\n\tvoid BuildPhases();\n\tvoid BuildProcessorList();\n\npublic:\n\tUPROPERTY(EditDefaultsOnly, Category = Mass, config, AdvancedDisplay)\n\tint32 ChunkMemorySize = 128 * 1024;\n\n\t/**\n\t * The name of the file to dump the processor dependency graph. T\n\t * The dot file will be put in the project log folder.\n\t * To generate a svg out of that file, simply run dot executable with following parameters: -Tsvg -O filename.dot \n\t */\n\tUPROPERTY(EditDefaultsOnly, Category = Mass, Transient)\n\tFString DumpDependencyGraphFileName;\n\n\t/** Lets users configure processing phases including the composite processor class to be used as a container for the phases' processors. */\n\tUPROPERTY(EditDefaultsOnly, Category = Mass, config)\n\tFMassProcessingPhaseConfig ProcessingPhasesConfig[(uint8)EMassProcessingPhase::MAX];\n\n\t/** This list contains all the processors available in the given binary (including plugins). The contents are sorted by display name.*/\n\tUPROPERTY(VisibleAnywhere, Category = Mass, Transient, Instanced, EditFixedSize)\n\tTArray<TObjectPtr<UMassProcessor>> ProcessorCDOs;\n\n#if WITH_EDITORONLY_DATA\nprotected:\n\tFOnSettingsChange OnSettingsChange;\n#endif // WITH_EDITORONLY_DATA\n\tbool bInitialized = false;\n\tbool bEngineInitialized = false;\n\n\tFOnInitialized OnInitializedEvent;\n};\n",
      "lines": 84
    },
    {
      "file_path": "MassEntity\\Public\\MassEntitySubsystem.h",
      "extension": ".h",
      "size_bytes": 1218,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassSubsystemBase.h\"\n#include \"MassEntityManager.h\"\n#include \"MassEntitySubsystem.generated.h\"\n\n\n/** \n * The sole responsibility of this world subsystem class is to host the default instance of FMassEntityManager\n * for a given UWorld. All the gameplay-related use cases of Mass (found in MassGameplay and related plugins) \n * use this by default. \n */\nUCLASS()\nclass MASSENTITY_API UMassEntitySubsystem : public UMassSubsystemBase\n{\n\tGENERATED_BODY()\n\n\t//~USubsystem interface\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\tvirtual void PostInitialize() override;\n\tvirtual void Deinitialize() override;\n\t//~End of USubsystem interface\n\npublic:\n\tUMassEntitySubsystem();\n\n\t//~UObject interface\n\tvirtual void GetResourceSizeEx(FResourceSizeEx& CumulativeResourceSize) override;\n\t//~End of UObject interface\n\n\tconst FMassEntityManager& GetEntityManager() const { check(EntityManager); return *EntityManager.Get(); }\n\tFMassEntityManager& GetMutableEntityManager() { check(EntityManager); return *EntityManager.Get(); }\n\nprotected:\n\tTSharedPtr<FMassEntityManager> EntityManager;\n};\n",
      "lines": 38
    },
    {
      "file_path": "MassEntity\\Public\\MassEntityTypes.h",
      "extension": ".h",
      "size_bytes": 27195,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"StructUtils/StructTypeBitSet.h\"\n#include \"MassProcessingTypes.h\"\n#include \"StructUtils/StructArrayView.h\"\n#include \"Subsystems/Subsystem.h\"\n#include \"MassExternalSubsystemTraits.h\"\n#include \"StructUtils/SharedStruct.h\"\n#include \"MassEntityTypes.generated.h\"\n#ifdef WITH_AITESTSUITE\n#include \"TestableEnsures.h\"\n#else\n#define testableEnsureMsgf ensureMsgf\n#define testableCheckf checkf\n#define testableCheckfReturn(InExpression, ReturnValue, InFormat, ... ) checkf(InExpression, InFormat, ##__VA_ARGS__)\n#endif \n\n\nMASSENTITY_API DECLARE_LOG_CATEGORY_EXTERN(LogMass, Warning, All);\n\nDECLARE_STATS_GROUP(TEXT(\"Mass\"), STATGROUP_Mass, STATCAT_Advanced);\nDECLARE_CYCLE_STAT_EXTERN(TEXT(\"Mass Total Frame Time\"), STAT_Mass_Total, STATGROUP_Mass, MASSENTITY_API);\n\n// This is the base class for all lightweight fragments\nUSTRUCT()\nstruct FMassFragment\n{\n\tGENERATED_BODY()\n\n\tFMassFragment() {}\n};\n\n// This is the base class for types that will only be tested for presence/absence, i.e. Tags.\n// Subclasses should never contain any member properties.\nUSTRUCT()\nstruct FMassTag\n{\n\tGENERATED_BODY()\n\n\tFMassTag() {}\n};\n\nUSTRUCT()\nstruct FMassChunkFragment\n{\n\tGENERATED_BODY()\n\n\tFMassChunkFragment() {}\n};\n\nUSTRUCT()\nstruct FMassSharedFragment\n{\n\tGENERATED_BODY()\n\n\tFMassSharedFragment() {}\n};\n\nUSTRUCT()\nstruct FMassConstSharedFragment\n{\n\tGENERATED_BODY()\n\n\tFMassConstSharedFragment() {}\n};\n\n\n// A handle to a lightweight entity.  An entity is used in conjunction with the FMassEntityManager\n// for the current world and can contain lightweight fragments.\nUSTRUCT()\nstruct alignas(8) FMassEntityHandle\n{\n\tGENERATED_BODY()\n\n\tFMassEntityHandle() = default;\n\tFMassEntityHandle(const int32 InIndex, const int32 InSerialNumber)\n\t\t: Index(InIndex), SerialNumber(InSerialNumber)\n\t{\n\t}\n\t\n\tUPROPERTY(VisibleAnywhere, Category = \"Mass|Debug\", Transient)\n\tint32 Index = 0;\n\t\n\tUPROPERTY(VisibleAnywhere, Category = \"Mass|Debug\", Transient)\n\tint32 SerialNumber = 0;\n\n\tbool operator==(const FMassEntityHandle Other) const\n\t{\n\t\treturn Index == Other.Index && SerialNumber == Other.SerialNumber;\n\t}\n\n\tbool operator!=(const FMassEntityHandle Other) const\n\t{\n\t\treturn !operator==(Other);\n\t}\n\n\t/** Has meaning only for sorting purposes */\n\tbool operator<(const FMassEntityHandle Other) const { return Index < Other.Index; }\n\n\t/** Note that this function is merely checking if Index and SerialNumber are set. There's no way to validate if \n\t *  these indicate a valid entity in an EntitySubsystem without asking the system. */\n\tbool IsSet() const\n\t{\n\t\treturn Index != 0 && SerialNumber != 0;\n\t}\n\n\tFORCEINLINE bool IsValid() const\n\t{\n\t\treturn IsSet();\n\t}\n\n\tvoid Reset()\n\t{\n\t\tIndex = SerialNumber = 0;\n\t}\n\n\t/** Allows the entity handle to be shared anonymously. */\n\tuint64 AsNumber() const { return *reinterpret_cast<const uint64*>(this); } // Relying on the fact that this struct only stores 2 integers and is aligned correctly.\n\t/** Reconstruct the entity handle from an anonymously shared integer. */\n\tstatic FMassEntityHandle FromNumber(uint64 Value) \n\t{ \n\t\tFMassEntityHandle Result;\n\t\t*reinterpret_cast<uint64_t*>(&Result) = Value;\n\t\treturn Result;\n\t}\n\n\tfriend uint32 GetTypeHash(const FMassEntityHandle Entity)\n\t{\n\t\treturn HashCombine(Entity.Index, Entity.SerialNumber);\n\t}\n\n\tFString DebugGetDescription() const\n\t{\n\t\treturn FString::Printf(TEXT(\"i: %d sn: %d\"), Index, SerialNumber);\n\t}\n};\n\nstatic_assert(sizeof(FMassEntityHandle) == sizeof(uint64), \"Expected FMassEntityHandle to be convertable to a 64-bit integer value, so size needs to be 8 bytes.\");\nstatic_assert(alignof(FMassEntityHandle) == sizeof(uint64), \"Expected FMassEntityHandle to be convertable to a 64-bit integer value, so alignment needs to be 8 bytes.\");\n\nDECLARE_STRUCTTYPEBITSET_EXPORTED(MASSENTITY_API, FMassFragmentBitSet, FMassFragment);\nDECLARE_STRUCTTYPEBITSET_EXPORTED(MASSENTITY_API, FMassTagBitSet, FMassTag);\nDECLARE_STRUCTTYPEBITSET_EXPORTED(MASSENTITY_API, FMassChunkFragmentBitSet, FMassChunkFragment);\nDECLARE_STRUCTTYPEBITSET_EXPORTED(MASSENTITY_API, FMassSharedFragmentBitSet, FMassSharedFragment);\nDECLARE_STRUCTTYPEBITSET_EXPORTED(MASSENTITY_API, FMassConstSharedFragmentBitSet, FMassConstSharedFragment);\nDECLARE_CLASSTYPEBITSET_EXPORTED(MASSENTITY_API, FMassExternalSubsystemBitSet, USubsystem);\n\n/** The type summarily describing a composition of an entity or an archetype. It contains information on both the\n *  fragments as well as tags */\nstruct FMassArchetypeCompositionDescriptor\n{\n\tFMassArchetypeCompositionDescriptor() = default;\n\tFMassArchetypeCompositionDescriptor(const FMassFragmentBitSet& InFragments,\n\t\tconst FMassTagBitSet& InTags,\n\t\tconst FMassChunkFragmentBitSet& InChunkFragments,\n\t\tconst FMassSharedFragmentBitSet& InSharedFragments,\n\t\tconst FMassConstSharedFragmentBitSet& InConstSharedFragments)\n\t\t: Fragments(InFragments)\n\t\t, Tags(InTags)\n\t\t, ChunkFragments(InChunkFragments)\n\t\t, SharedFragments(InSharedFragments)\n\t\t, ConstSharedFragments(InConstSharedFragments)\n\t{}\n\n\tFMassArchetypeCompositionDescriptor(TConstArrayView<const UScriptStruct*> InFragments,\n\t\tconst FMassTagBitSet& InTags,\n\t\tconst FMassChunkFragmentBitSet& InChunkFragments,\n\t\tconst FMassSharedFragmentBitSet& InSharedFragments,\n\t\tconst FMassConstSharedFragmentBitSet& InConstSharedFragments)\n\t\t: FMassArchetypeCompositionDescriptor(FMassFragmentBitSet(InFragments), InTags, InChunkFragments, InSharedFragments, InConstSharedFragments)\n\t{}\n\n\tFMassArchetypeCompositionDescriptor(TConstArrayView<FInstancedStruct> InFragmentInstances,\n\t\tconst FMassTagBitSet& InTags,\n\t\tconst FMassChunkFragmentBitSet& InChunkFragments,\n\t\tconst FMassSharedFragmentBitSet& InSharedFragments,\n\t\tconst FMassConstSharedFragmentBitSet& InConstSharedFragments)\n\t\t: FMassArchetypeCompositionDescriptor(FMassFragmentBitSet(InFragmentInstances), InTags, InChunkFragments, InSharedFragments, InConstSharedFragments)\n\t{}\n\n\tFMassArchetypeCompositionDescriptor(FMassFragmentBitSet&& InFragments,\n\t\tFMassTagBitSet&& InTags,\n\t\tFMassChunkFragmentBitSet&& InChunkFragments,\n\t\tFMassSharedFragmentBitSet&& InSharedFragments,\n\t\tFMassConstSharedFragmentBitSet&& InConstSharedFragments)\n\t\t: Fragments(MoveTemp(InFragments))\n\t\t, Tags(MoveTemp(InTags))\n\t\t, ChunkFragments(MoveTemp(InChunkFragments))\n\t\t, SharedFragments(MoveTemp(InSharedFragments))\n\t\t, ConstSharedFragments(MoveTemp(InConstSharedFragments))\n\t{}\n\n\tFMassArchetypeCompositionDescriptor(FMassFragmentBitSet&& InFragments)\n\t\t: Fragments(MoveTemp(InFragments))\n\t{}\n\n\tFMassArchetypeCompositionDescriptor(FMassTagBitSet&& InTags)\n\t\t: Tags(MoveTemp(InTags))\n\t{}\n\n\tvoid Reset()\n\t{\n\t\tFragments.Reset();\n\t\tTags.Reset();\n\t\tChunkFragments.Reset();\n\t\tSharedFragments.Reset();\n\t\tConstSharedFragments.Reset();\n\t}\n\n\tbool IsEquivalent(const FMassArchetypeCompositionDescriptor& OtherDescriptor) const\n\t{\n\t\treturn Fragments.IsEquivalent(OtherDescriptor.Fragments) &&\n\t\t\tTags.IsEquivalent(OtherDescriptor.Tags) &&\n\t\t\tChunkFragments.IsEquivalent(OtherDescriptor.ChunkFragments) &&\n\t\t\tSharedFragments.IsEquivalent(OtherDescriptor.SharedFragments) &&\n\t\t\tConstSharedFragments.IsEquivalent(OtherDescriptor.ConstSharedFragments);\n\t}\n\n\tbool IsEmpty() const \n\t{ \n\t\treturn Fragments.IsEmpty() &&\n\t\t\tTags.IsEmpty() &&\n\t\t\tChunkFragments.IsEmpty() &&\n\t\t\tSharedFragments.IsEmpty() &&\n\t\t\tConstSharedFragments.IsEmpty();\n\t}\n\n\tbool HasAll(const FMassArchetypeCompositionDescriptor& OtherDescriptor) const\n\t{\n\t\treturn Fragments.HasAll(OtherDescriptor.Fragments) &&\n\t\t\tTags.HasAll(OtherDescriptor.Tags) &&\n\t\t\tChunkFragments.HasAll(OtherDescriptor.ChunkFragments) &&\n\t\t\tSharedFragments.HasAll(OtherDescriptor.SharedFragments) &&\n\t\t\tConstSharedFragments.HasAll(OtherDescriptor.ConstSharedFragments);\n\t}\n\n\tstatic uint32 CalculateHash(const FMassFragmentBitSet& InFragments, const FMassTagBitSet& InTags\n\t\t, const FMassChunkFragmentBitSet& InChunkFragments, const FMassSharedFragmentBitSet& InSharedFragmentBitSet\n\t\t, const FMassConstSharedFragmentBitSet& InConstSharedFragmentBitSet)\n\t{\n\t\tconst uint32 FragmentsHash = GetTypeHash(InFragments);\n\t\tconst uint32 TagsHash = GetTypeHash(InTags);\n\t\tconst uint32 ChunkFragmentsHash = GetTypeHash(InChunkFragments);\n\t\tconst uint32 SharedFragmentsHash = GetTypeHash(InSharedFragmentBitSet);\n\t\tconst uint32 ConstSharedFragmentsHash = GetTypeHash(InConstSharedFragmentBitSet);\n\t\treturn HashCombine(HashCombine(HashCombine(HashCombine(FragmentsHash, TagsHash), ChunkFragmentsHash), SharedFragmentsHash), ConstSharedFragmentsHash);\n\t}\t\n\n\tuint32 CalculateHash() const \n\t{\n\t\treturn CalculateHash(Fragments, Tags, ChunkFragments, SharedFragments, ConstSharedFragments);\n\t}\n\n\tint32 CountStoredTypes() const\n\t{\n\t\treturn Fragments.CountStoredTypes()\n\t\t\t+ Tags.CountStoredTypes()\n\t\t\t+ ChunkFragments.CountStoredTypes()\n\t\t\t+ SharedFragments.CountStoredTypes()\n\t\t\t+ ConstSharedFragments.CountStoredTypes();\n\t}\n\n\tvoid DebugOutputDescription(FOutputDevice& Ar) const\n\t{\n#if WITH_MASSENTITY_DEBUG\n\t\tif (Fragments.IsEmpty()\n\t\t\t&& Tags.IsEmpty()\n\t\t\t&& ChunkFragments.IsEmpty())\n\t\t{\n\t\t\tAr.Logf(TEXT(\"Empty\"));\n\t\t\treturn;\n\t\t}\n\n\t\tconst bool bAutoLineEnd = Ar.GetAutoEmitLineTerminator();\n\t\tAr.SetAutoEmitLineTerminator(false);\n\n\t\tif (!Fragments.IsEmpty())\n\t\t{\n\t\t\tAr.Logf(TEXT(\"Fragments:\\n\"));\n\t\t\tFragments.DebugGetStringDesc(Ar);\n\t\t}\n\n\t\tif (!Tags.IsEmpty())\n\t\t{\n\t\t\tAr.Logf(TEXT(\"Tags:\\n\"));\n\t\t\tTags.DebugGetStringDesc(Ar);\n\t\t}\n\n\t\tif (!ChunkFragments.IsEmpty())\n\t\t{\n\t\t\tAr.Logf(TEXT(\"ChunkFragments:\\n\"));\n\t\t\tChunkFragments.DebugGetStringDesc(Ar);\n\t\t}\n\n\t\tif (!SharedFragments.IsEmpty())\n\t\t{\n\t\t\tAr.Logf(TEXT(\"SharedFragments:\\n\"));\n\t\t\tSharedFragments.DebugGetStringDesc(Ar);\n\t\t}\n\n\t\tif (!ConstSharedFragments.IsEmpty())\n\t\t{\n\t\t\tAr.Logf(TEXT(\"ConstSharedFragments:\\n\"));\n\t\t\tConstSharedFragments.DebugGetStringDesc(Ar);\n\t\t}\n\n\t\tAr.SetAutoEmitLineTerminator(bAutoLineEnd);\n#endif // WITH_MASSENTITY_DEBUG\n\n\t}\n\n\tFMassFragmentBitSet Fragments;\n\tFMassTagBitSet Tags;\n\tFMassChunkFragmentBitSet ChunkFragments;\n\tFMassSharedFragmentBitSet SharedFragments;\n\tFMassConstSharedFragmentBitSet ConstSharedFragments;\n\n\tUE_DEPRECATED(5.5, \"This FMassArchetypeCompositionDescriptor constructor is deprecated. Please explicitly provide FConstSharedFragmentBitSet.\")\n\tFMassArchetypeCompositionDescriptor(const FMassFragmentBitSet& InFragments, const FMassTagBitSet& InTags, const FMassChunkFragmentBitSet& InChunkFragments, const FMassSharedFragmentBitSet& InSharedFragments)\n\t\t: FMassArchetypeCompositionDescriptor(InFragments, InTags, InChunkFragments, InSharedFragments, FMassConstSharedFragmentBitSet())\n\t{}\n\n\tUE_DEPRECATED(5.5, \"This FMassArchetypeCompositionDescriptor constructor is deprecated. Please explicitly provide FConstSharedFragmentBitSet.\")\n\tFMassArchetypeCompositionDescriptor(TConstArrayView<const UScriptStruct*> InFragments, const FMassTagBitSet& InTags, const FMassChunkFragmentBitSet& InChunkFragments, const FMassSharedFragmentBitSet& InSharedFragments)\n\t\t: FMassArchetypeCompositionDescriptor(FMassFragmentBitSet(InFragments), InTags, InChunkFragments, InSharedFragments, FMassConstSharedFragmentBitSet())\n\t{}\n\n\tUE_DEPRECATED(5.5, \"This FMassArchetypeCompositionDescriptor constructor is deprecated. Please explicitly provide FConstSharedFragmentBitSet.\")\n\tFMassArchetypeCompositionDescriptor(TConstArrayView<FInstancedStruct> InFragmentInstances, const FMassTagBitSet& InTags, const FMassChunkFragmentBitSet& InChunkFragments, const FMassSharedFragmentBitSet& InSharedFragments)\n\t\t: FMassArchetypeCompositionDescriptor(FMassFragmentBitSet(InFragmentInstances), InTags, InChunkFragments, InSharedFragments, FMassConstSharedFragmentBitSet())\n\t{}\n\n\tUE_DEPRECATED(5.5, \"This FMassArchetypeCompositionDescriptor constructor is deprecated. Please explicitly provide FConstSharedFragmentBitSet.\")\n\tFMassArchetypeCompositionDescriptor(FMassFragmentBitSet&& InFragments, FMassTagBitSet&& InTags, FMassChunkFragmentBitSet&& InChunkFragments, FMassSharedFragmentBitSet&& InSharedFragments)\n\t{\n\t\tensureMsgf(false, TEXT(\"This constructor is defunct. Please update your implementation based on deprecation warning.\"));\n\t}\n};\n\n/** \n * Wrapper for const and non-const shared fragment containers that tracks which struct types it holds (via a FMassSharedFragmentBitSet).\n * Note that having multiple instanced of a given struct type is not supported and Add* functions will fetch the previously \n * added fragment instead of adding a new one.\n */\nstruct MASSENTITY_API FMassArchetypeSharedFragmentValues\n{\n\tFMassArchetypeSharedFragmentValues() = default;\n\tFMassArchetypeSharedFragmentValues(const FMassArchetypeSharedFragmentValues& OtherFragmentValues) = default;\n\tFMassArchetypeSharedFragmentValues(FMassArchetypeSharedFragmentValues&& OtherFragmentValues) = default;\n\tFMassArchetypeSharedFragmentValues& operator=(const FMassArchetypeSharedFragmentValues& OtherFragmentValues) = default;\n\tFMassArchetypeSharedFragmentValues& operator=(FMassArchetypeSharedFragmentValues&& OtherFragmentValues) = default;\n\n\tFORCEINLINE bool HasExactFragmentTypesMatch(const FMassSharedFragmentBitSet& InSharedFragmentBitSet, const FMassConstSharedFragmentBitSet& InConstSharedFragmentBitSet) const\n\t{\n\t\treturn HasExactSharedFragmentTypesMatch(InSharedFragmentBitSet)\n\t\t\t&& HasExactConstSharedFragmentTypesMatch(InConstSharedFragmentBitSet);\n\t}\n\n\tFORCEINLINE bool HasExactSharedFragmentTypesMatch(const FMassSharedFragmentBitSet& InSharedFragmentBitSet) const\n\t{\n\t\treturn SharedFragmentBitSet.IsEquivalent(InSharedFragmentBitSet);\n\t}\n\n\tFORCEINLINE bool HasAllRequiredSharedFragmentTypes(const FMassSharedFragmentBitSet& InSharedFragmentBitSet) const\n\t{\n\t\treturn SharedFragmentBitSet.HasAll(InSharedFragmentBitSet);\n\t}\n\n\tFORCEINLINE bool HasExactConstSharedFragmentTypesMatch(const FMassConstSharedFragmentBitSet& InConstSharedFragmentBitSet) const\n\t{\n\t\treturn ConstSharedFragmentBitSet.IsEquivalent(InConstSharedFragmentBitSet);\n\t}\n\n\tFORCEINLINE bool HasAllRequiredConstSharedFragmentTypes(const FMassConstSharedFragmentBitSet& InConstSharedFragmentBitSet) const\n\t{\n\t\treturn ConstSharedFragmentBitSet.HasAll(InConstSharedFragmentBitSet);\n\t}\n\n\tFORCEINLINE bool IsEquivalent(const FMassArchetypeSharedFragmentValues& OtherSharedFragmentValues) const\n\t{\n\t\treturn GetTypeHash(*this) == GetTypeHash(OtherSharedFragmentValues);\n\t}\n\n\t/** \n\t * Compares contents of `this` and the Other, and allows different order of elements in both containers.\n\t * Note that the function ignores \"nulls\", i.e. empty FConstSharedStruct and FSharedStruct instances. The function\n\t * does care however about matching \"mode\", meaning ConstSharedFragments and SharedFragments arrays are compared\n\t * independently.\n\t */\n\tbool HasSameValues(const FMassArchetypeSharedFragmentValues& Other) const;\n\n\tFORCEINLINE bool ContainsType(const UScriptStruct* FragmentType) const\n\t{\n\t\tif (FragmentType)\n\t\t{\n\t\t\tif (FragmentType->IsChildOf(FMassSharedFragment::StaticStruct()))\n\t\t\t{\n\t\t\t\treturn SharedFragmentBitSet.Contains(*FragmentType);\n\t\t\t}\n\n\t\t\tif (FragmentType->IsChildOf(FMassConstSharedFragment::StaticStruct()))\n\t\t\t{\n\t\t\t\treturn ConstSharedFragmentBitSet.Contains(*FragmentType);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\ttemplate<typename T>\n\tFORCEINLINE bool ContainsType() const\n\t{\n\t\tif constexpr (TIsDerivedFrom<T, FMassConstSharedFragment>::IsDerived)\n\t\t{\n\t\t\treturn ConstSharedFragmentBitSet.Contains(*T::StaticStruct());\n\t\t}\n\t\telse if constexpr (TIsDerivedFrom<T, FMassSharedFragment>::IsDerived)\n\t\t{\n\t\t\treturn SharedFragmentBitSet.Contains(*T::StaticStruct());\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/** \n\t * Adds Fragment to the collection. If a fragment of the given FMassSharedFragment subclass has already added then \n\t * the function will return the previously added instance. In that case the function will also assert if the given type \n\t * has been added as a CONST shared fragment and if not it will return an empty FConstSharedStruct\n\t */\n\tFConstSharedStruct AddConstSharedFragment(const FConstSharedStruct& Fragment);\n\n\t/**\n\t * Adds Fragment to the collection. If a fragment of the given FMassSharedFragment subclass has already added then\n\t * the function will return the previously added instance. In that case the function will also assert if the given type\n\t * has been added as a NON-CONST shared fragment and if not it will return an empty FSharedStruct\n\t */\n\tFSharedStruct AddSharedFragment(const FSharedStruct& Fragment);\n\n\t/**\n\t * Finds instances of fragment types given by Fragments and replaces their values with contents of respective\n\t * element of Fragments.\n\t * Note that it's callers responsibility to ensure every fragment type in Fragments already has an instance in\n\t * this FMassArchetypeSharedFragmentValues instance. Failing that assumption will result in ensure failure. \n\t */\n\tvoid ReplaceSharedFragments(TConstArrayView<FSharedStruct> Fragments);\n\n\t/** \n\t * Appends contents of Other to `this` instance. All common fragments will get overridden with values in Other.\n\t * Note that changing a fragments \"role\" (being const or non-const) is not supported and the function will fail an\n\t * ensure when that is attempted.\n\t * @return number of fragments added or changed\n\t */\n\tint32 Append(const FMassArchetypeSharedFragmentValues& Other);\n\n\t/** \n\t * Note that the function removes the shared fragments by type\n\t * @return number of fragments types removed\n\t */\n\tint32 Remove(const FMassSharedFragmentBitSet& SharedFragmentToRemoveBitSet);\n\n\t/** \n\t * Note that the function removes the const shared fragments by type\n\t * @return number of fragments types removed\n\t */\n\tint32 Remove(const FMassConstSharedFragmentBitSet& ConstSharedFragmentToRemoveBitSet);\n\n\tFORCEINLINE const TArray<FConstSharedStruct>& GetConstSharedFragments() const\n\t{\n\t\treturn ConstSharedFragments;\n\t}\n\n\tFORCEINLINE TArray<FSharedStruct>& GetMutableSharedFragments()\n\t{\n\t\treturn SharedFragments;\n\t}\n\t\n\tFORCEINLINE const TArray<FSharedStruct>& GetSharedFragments() const\n\t{\n\t\treturn SharedFragments;\n\t}\n\t\n\tFConstSharedStruct GetConstSharedFragmentStruct(const UScriptStruct* StructType) const\n\t{\n\t\tconst int32 FragmentIndex = ConstSharedFragments.IndexOfByPredicate(FStructTypeEqualOperator(StructType));\n\t\treturn FragmentIndex != INDEX_NONE ? ConstSharedFragments[FragmentIndex] : FConstSharedStruct();\n\t}\n\t\t\n\tFSharedStruct GetSharedFragmentStruct(const UScriptStruct* StructType)\n\t{\n\t\tconst int32 FragmentIndex = SharedFragments.IndexOfByPredicate(FStructTypeEqualOperator(StructType));\n\t\treturn FragmentIndex != INDEX_NONE ? SharedFragments[FragmentIndex] : FSharedStruct();\n\t}\n\n\tconst FMassSharedFragmentBitSet& GetSharedFragmentBitSet() const\n\t{\n\t\treturn SharedFragmentBitSet;\n\t}\n\n\tconst FMassConstSharedFragmentBitSet& GetConstSharedFragmentBitSet() const\n\t{\n\t\treturn ConstSharedFragmentBitSet;\n\t}\n\n\tFORCEINLINE void DirtyHashCache()\n\t{\n\t\tHashCache = UINT32_MAX;\n\t\t// we consider a single shared fragment as being \"sorted\"\n\t\tbSorted = (SharedFragments.Num() + ConstSharedFragments.Num() <= 1) ;\n\t}\n\n\tFORCEINLINE void CacheHash() const\n\t{\n\t\tif (HashCache == UINT32_MAX)\n\t\t{\n\t\t\tHashCache = CalculateHash();\n\t\t}\n\t}\n\n\tfriend FORCEINLINE uint32 GetTypeHash(const FMassArchetypeSharedFragmentValues& SharedFragmentValues)\n\t{\n\t\tSharedFragmentValues.CacheHash();\n\t\treturn SharedFragmentValues.HashCache;\n\t}\n\n\tuint32 CalculateHash() const;\n\n\tSIZE_T GetAllocatedSize() const\n\t{\n\t\treturn ConstSharedFragments.GetAllocatedSize() + SharedFragments.GetAllocatedSize();\n\t}\n\n\tvoid Sort()\n\t{\n\t\tif(!bSorted)\n\t\t{\n\t\t\tConstSharedFragments.Sort(FStructTypeSortOperator());\n\t\t\tSharedFragments.Sort(FStructTypeSortOperator());\n\t\t\tbSorted = true;\n\t\t}\n\t}\n\n\tbool IsSorted() const { return bSorted; }\n\nprotected:\n\tmutable uint32 HashCache = UINT32_MAX;\n\t/**\n\t * We consider empty FMassArchetypeSharedFragmentValues a sorted containter.Same goes for a container containing\n\t * a single element, @see DirtyHashCache\n\t */ \n\tmutable bool bSorted = true; \n\t\n\tFMassSharedFragmentBitSet SharedFragmentBitSet;\n\tFMassConstSharedFragmentBitSet ConstSharedFragmentBitSet;\n\tTArray<FConstSharedStruct> ConstSharedFragments;\n\tTArray<FSharedStruct> SharedFragments;\n\npublic:\n\t//-----------------------------------------------------------------------------\n\t// DEPRECATED\n\t//-----------------------------------------------------------------------------\n\tUE_DEPRECATED(5.5, \"HasExactFragmentTypesMatch is deprecated. Use HasExactSharedFragmentTypesMatch or the two-parameter version of HasExactFragmentTypesMatch.\")\n\tFORCEINLINE bool HasExactFragmentTypesMatch(const FMassSharedFragmentBitSet& InSharedFragmentBitSet) const\n\t{\n\t\treturn HasExactSharedFragmentTypesMatch(InSharedFragmentBitSet);\n\t}\n};\n\nUENUM()\nenum class EMassObservedOperation : uint8\n{\n\tAdd,\n\tRemove,\n\t// @todo Keeping this here as a indication of design intent. For now we handle entity destruction like removal, but \n\t// there might be computationally expensive cases where we might want to avoid for soon-to-be-dead entities. \n\t// Destroy,\n\t// @todo another planned supported operation type\n\t// Touch,\n\tMAX\n};\n\nenum class EMassExecutionContextType : uint8\n{\n\tLocal,\n\tProcessor,\n\tMAX\n};\n\n/** \n * Note that this is a view and is valid only as long as the source data is valid. Used when flushing mass commands to\n * wrap different kinds of data into a uniform package so that it can be passed over to a common interface.\n */\nstruct FMassGenericPayloadView\n{\n\tFMassGenericPayloadView() = default;\n\tFMassGenericPayloadView(TArray<FStructArrayView>&SourceData)\n\t\t: Content(SourceData)\n\t{}\n\tFMassGenericPayloadView(TArrayView<FStructArrayView> SourceData)\n\t\t: Content(SourceData)\n\t{}\n\n\tint32 Num() const { return Content.Num(); }\n\n\tvoid Reset()\n\t{\n\t\tContent = TArrayView<FStructArrayView>();\n\t}\n\n\tFORCEINLINE void Swap(const int32 A, const int32 B)\n\t{\n\t\tfor (FStructArrayView& View : Content)\n\t\t{\n\t\t\tView.Swap(A, B);\n\t\t}\n\t}\n\n\t/** Moves NumToMove elements to the back of the viewed collection. */\n\tvoid SwapElementsToEnd(int32 StartIndex, int32 NumToMove);\n\n\tTArrayView<FStructArrayView> Content;\n};\n\n/**\n * Used to indicate a specific slice of a preexisting FMassGenericPayloadView, it's essentially an access pattern\n * Note: accessing content generates copies of FStructArrayViews stored (still cheap, those are just views). \n */\nstruct FMassGenericPayloadViewSlice\n{\n\tFMassGenericPayloadViewSlice() = default;\n\tFMassGenericPayloadViewSlice(const FMassGenericPayloadView& InSource, const int32 InStartIndex, const int32 InCount)\n\t\t: Source(InSource), StartIndex(InStartIndex), Count(InCount)\n\t{\n\t}\n\n\tFStructArrayView operator[](const int32 Index) const\n\t{\n\t\treturn Source.Content[Index].Slice(StartIndex, Count);\n\t}\n\n\t/** @return the number of \"layers\" (i.e. number of original arrays) this payload has been built from */\n\tint32 Num() const \n\t{\n\t\treturn Source.Num();\n\t}\n\n\tbool IsEmpty() const\n\t{\n\t\treturn !(Source.Num() > 0 && Count > 0);\n\t}\n\nprivate:\n\tFMassGenericPayloadView Source;\n\tconst int32 StartIndex = 0;\n\tconst int32 Count = 0;\n};\n\nnamespace UE::Mass\n{\n\t/**\n\t * A statically-typed list of of related types. Used mainly to differentiate type collections at compile-type as well as\n\t * efficiently produce TStructTypeBitSet representing given collection.\n\t */\n\ttemplate<typename T, typename... TOthers>\n\tstruct TMultiTypeList : TMultiTypeList<TOthers...>\n\t{\n\t\tusing Super = TMultiTypeList<TOthers...>;\n\t\tusing FType = std::remove_const_t<typename TRemoveReference<T>::Type>;\n\t\tenum\n\t\t{\n\t\t\tOrdinal = Super::Ordinal + 1\n\t\t};\n\n\t\ttemplate<typename TBitSetType>\n\t\tconstexpr static void PopulateBitSet(TBitSetType& OutBitSet)\n\t\t{\n\t\t\tSuper::PopulateBitSet(OutBitSet);\n\t\t\tOutBitSet += TBitSetType::template GetTypeBitSet<FType>();\n\t\t}\n\t};\n\t\t\n\t/** Single-type specialization of TMultiTypeList. */\n\ttemplate<typename T>\n\tstruct TMultiTypeList<T>\n\t{\n\t\tusing FType = std::remove_const_t<typename TRemoveReference<T>::Type>;\n\t\tenum\n\t\t{\n\t\t\tOrdinal = 0\n\t\t};\n\n\t\ttemplate<typename TBitSetType>\n\t\tconstexpr static void PopulateBitSet(TBitSetType& OutBitSet)\n\t\t{\n\t\t\tOutBitSet += TBitSetType::template GetTypeBitSet<FType>();\n\t\t}\n\t};\n\n\t/** \n\t * The type hosts a statically-typed collection of TArrays, where each TArray is strongly-typed (i.e. it contains \n\t * instances of given structs rather than structs wrapped up in FInstancedStruct). This type lets us do batched \n\t * fragment values setting by simply copying data rather than setting per-instance. \n\t */\n\ttemplate<typename T, typename... TOthers>\n\tstruct TMultiArray : TMultiArray<TOthers...>\n\t{\n\t\tusing FType = std::remove_const_t<typename TRemoveReference<T>::Type>;\n\t\tusing Super = TMultiArray<TOthers...>;\n\n\t\tenum\n\t\t{\n\t\t\tOrdinal = Super::Ordinal + 1\n\t\t};\n\n\t\tSIZE_T GetAllocatedSize() const\n\t\t{\n\t\t\treturn FragmentInstances.GetAllocatedSize() + Super::GetAllocatedSize();\n\t\t}\n\n\t\tint GetNumArrays() const { return Ordinal + 1; }\n\n\t\tvoid Add(const FType& Item, TOthers... Rest)\n\t\t{\n\t\t\tFragmentInstances.Add(Item);\n\t\t\tSuper::Add(Rest...);\n\t\t}\n\n\t\tvoid GetAsGenericMultiArray(TArray<FStructArrayView>& A) /*const*/\n\t\t{\n\t\t\tSuper::GetAsGenericMultiArray(A);\n\t\t\tA.Add(FStructArrayView(FragmentInstances));\n\t\t}\n\n\t\tvoid GetheredAffectedFragments(FMassFragmentBitSet& OutBitSet) const\n\t\t{\n\t\t\tSuper::GetheredAffectedFragments(OutBitSet);\n\t\t\tOutBitSet += FMassFragmentBitSet::GetTypeBitSet<FType>();\n\t\t}\n\n\t\tvoid Reset()\n\t\t{\n\t\t\tSuper::Reset();\n\t\t\tFragmentInstances.Reset();\n\t\t}\n\n\t\tTArray<FType> FragmentInstances;\n\t};\n\n\t/**TMultiArray simple-type specialization */\n\ttemplate<typename T>\n\tstruct TMultiArray<T>\n\t{\n\t\tusing FType = std::remove_const_t<typename TRemoveReference<T>::Type>;\n\t\tenum { Ordinal = 0 };\n\n\t\tSIZE_T GetAllocatedSize() const\n\t\t{\n\t\t\treturn FragmentInstances.GetAllocatedSize();\n\t\t}\n\n\t\tint GetNumArrays() const { return Ordinal + 1; }\n\n\t\tvoid Add(const FType& Item) { FragmentInstances.Add(Item); }\n\n\t\tvoid GetAsGenericMultiArray(TArray<FStructArrayView>& A) /*const*/\n\t\t{\n\t\t\tA.Add(FStructArrayView(FragmentInstances));\n\t\t}\n\n\t\tvoid GetheredAffectedFragments(FMassFragmentBitSet& OutBitSet) const\n\t\t{\n\t\t\tOutBitSet += FMassFragmentBitSet::GetTypeBitSet<FType>();\n\t\t}\n\n\t\tvoid Reset()\n\t\t{\n\t\t\tFragmentInstances.Reset();\n\t\t}\n\n\t\tTArray<FType> FragmentInstances;\n\t};\n\n} // UE::Mass\n\n\nstruct FMassArchetypeCreationParams\n{\n\tFMassArchetypeCreationParams() = default;\n\texplicit FMassArchetypeCreationParams(const struct FMassArchetypeData& Archetype);\n\n\t/** Created archetype will have chunks of this size. 0 denotes \"use default\" (see UE::Mass::ChunkSize) */\n\tint32 ChunkMemorySize = 0;\n\n\t/** Name to identify the archetype while debugging*/\n\tFName DebugName;\n};\n",
      "lines": 799
    },
    {
      "file_path": "MassEntity\\Public\\MassEntityUtils.h",
      "extension": ".h",
      "size_bytes": 3281,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessingTypes.h\"\n#include \"MassArchetypeTypes.h\"\n\nclass UWorld;\nstruct FMassEntityManager;\nstruct FMassEntityHandle;\n\nnamespace UE::Mass::Utils\n{\n\n/** returns the current execution mode for the processors calculated from the world network mode */\nMASSENTITY_API extern EProcessorExecutionFlags GetProcessorExecutionFlagsForWorld(const UWorld& World);\n\n/** based on the given World (which can be null) and 'ExecutionFlagsOverride', the function determines the execution flags to use */\nMASSENTITY_API extern EProcessorExecutionFlags DetermineProcessorExecutionFlags(const UWorld* World, EProcessorExecutionFlags ExecutionFlagsOverride = EProcessorExecutionFlags::None);\n\n/** based on the given World (which can be null), the function determines additional level tick types for the processing phases */\nuint8 DetermineProcessorSupportedTickTypes(const UWorld* World);\n\nUE_DEPRECATED(5.3, \"This function is deprecated. Please use the properly spelled GetProcessorExecutionFlagsForWorld instead.\")\nFORCEINLINE EProcessorExecutionFlags GetProcessorExecutionFlagsForWold(const UWorld& World)\n{\n\treturn GetProcessorExecutionFlagsForWorld(World);\n}\n\n/** \n * Fills OutEntityCollections with per-archetype FMassArchetypeEntityCollection instances. \n * @param DuplicatesHandling used to inform the function whether to expect duplicates.\n */\nMASSENTITY_API extern void CreateEntityCollections(const FMassEntityManager& EntitySubsystem, const TConstArrayView<FMassEntityHandle> Entities\n\t, const FMassArchetypeEntityCollection::EDuplicatesHandling DuplicatesHandling, TArray<FMassArchetypeEntityCollection>& OutEntityCollections);\n\n/**\n* AbstractSort is a sorting function that only needs to know how many items there are, how to compare items\n* at individual locations - where location is in [0, NumElements) - and how to swap two elements at given locations.\n* The main use case is to sort multiple arrays while keeping them in sync. For example:\n*\n* TArray<float> Lead = { 3.1, 0.2, 2.6, 1.0 };\n* TArray<UObject*> Payload = { A, B, C, D };\n*\n* AbstractSort(Lead.Num()\t\t\t\t\t\t\t\t\t\t\t// NumElements\n* \t, [&Lead](const int32 LHS, const int32 RHS)\t\t\t\t\t// Predicate\n*\t\t{\n*\t\t\treturn Lead[LHS] < Lead[RHS];\n*\t\t}\n* \t, [&Lead, &Payload](const int32 A, const int32 B)\t\t\t// SwapFunctor\n*\t \t{\n*\t\t\tSwap(Lead[A], Lead[B]);\n* \t\t\tSwap(Payload[A], Payload[B]);\n*\t\t}\n* );\n*/\ntemplate<typename TPred, typename TSwap>\ninline void AbstractSort(const int32 NumElements, TPred&& Predicate, TSwap&& SwapFunctor)\n{\n\tif (NumElements == 0)\n\t{\n\t\treturn;\n\t}\n\n\tTArray<int32> Indices;\n\tIndices.AddUninitialized(NumElements);\n\tint i = 0;\n\tdo\n\t{\n\t\tIndices[i] = i;\n\t} while (++i < NumElements);\n\n\tIndices.Sort(Predicate);\n\n\tfor (i = 0; i < NumElements; ++i)\n\t{\n\t\tint32 SwapFromIndex = Indices[i];\n\t\twhile (SwapFromIndex < i)\n\t\t{\n\t\t\tSwapFromIndex = Indices[SwapFromIndex];\n\t\t}\n\n\t\tif (SwapFromIndex != i)\n\t\t{\n\t\t\tSwapFunctor(i, SwapFromIndex);\n\t\t}\n\t}\n}\n\nMASSENTITY_API extern FMassEntityManager* GetEntityManager(const UWorld* World);\nMASSENTITY_API extern FMassEntityManager& GetEntityManagerChecked(const UWorld& World);\n\n} // namespace UE::Mass::Utils\n\n",
      "lines": 94
    },
    {
      "file_path": "MassEntity\\Public\\MassEntityView.h",
      "extension": ".h",
      "size_bytes": 7012,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassArchetypeTypes.h\"\n#include \"StructUtils/InstancedStruct.h\"\n#include \"MassEntityView.generated.h\"\n\n\nstruct FMassEntityManager;\nstruct FMassArchetypeData;\nstruct FMassArchetypeHandle;\n\n/** \n * The type representing a single entity in a single archetype. It's of a very transient nature so we guarantee it's \n * validity only within the scope it has been created in. Don't store it. \n */\nUSTRUCT()\nstruct MASSENTITY_API FMassEntityView\n{\n\tGENERATED_BODY()\n\n\tFMassEntityView() = default;\n\n\t/** \n\t *  Resolves Entity against ArchetypeHandle. Note that this approach requires the caller to ensure that Entity\n\t *  indeed belongs to ArchetypeHandle. If not the call will fail a check. As a remedy calling the \n\t *  FMassEntityManager-flavored constructor is recommended since it will first find the appropriate archetype for\n\t *  Entity. \n\t */\n\tFMassEntityView(const FMassArchetypeHandle& ArchetypeHandle, FMassEntityHandle Entity);\n\n\t/** \n\t *  Finds the archetype Entity belongs to and then resolves against it. The caller is responsible for ensuring\n\t *  that the given Entity is in fact a valid ID tied to any of the archetypes \n\t */\n\tFMassEntityView(const FMassEntityManager& EntityManager, FMassEntityHandle Entity);\n\n\t/** \n\t * If the given handle represents a valid entity the function will create a FMassEntityView just like a constructor \n\t * would. If the entity is not valid the produced view will be \"unset\".\n\t */\n\tstatic FMassEntityView TryMakeView(const FMassEntityManager& EntityManager, FMassEntityHandle Entity);\n\n\tFMassEntityHandle GetEntity() const\t{ return Entity; }\n\n\t/** will fail a check if the viewed entity doesn't have the given fragment */\t\n\ttemplate<typename T>\n\tT& GetFragmentData() const\n\t{\n\t\tstatic_assert(!std::is_base_of_v<FMassTag, T>,\n\t\t\t\"Given struct doesn't represent a valid fragment type but a tag. Use HasTag instead.\");\n\t\tstatic_assert(std::is_base_of_v<FMassTag, T> || std::is_base_of_v<FMassFragment, T>,\n\t\t\t\"Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.\");\n\n\t\treturn *((T*)GetFragmentPtrChecked(*T::StaticStruct()));\n\t}\n\t\t\n\t/** if the viewed entity doesn't have the given fragment the function will return null */\n\ttemplate<typename T>\n\tT* GetFragmentDataPtr() const\n\t{\n\t\tstatic_assert(!std::is_base_of_v<FMassTag, T>,\n\t\t\t\"Given struct doesn't represent a valid fragment type but a tag. Use HasTag instead.\");\n\t\tstatic_assert(std::is_base_of_v<FMassTag, T> || std::is_base_of_v<FMassFragment, T>,\n\t\t\t\"Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.\");\n\n\t\treturn (T*)GetFragmentPtr(*T::StaticStruct());\n\t}\n\n\tFStructView GetFragmentDataStruct(const UScriptStruct* FragmentType) const\n\t{\n\t\tcheck(FragmentType);\n\t\treturn FStructView(FragmentType, static_cast<uint8*>(GetFragmentPtr(*FragmentType)));\n\t}\n\n\t/** if the viewed entity doesn't have the given const shared fragment the function will return null */\n\ttemplate<typename T>\n\tconst T* GetConstSharedFragmentDataPtr() const\n\t{\n\t\tstatic_assert(std::is_base_of_v<FMassConstSharedFragment, T>,\n\t\t\t\"Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.\");\n\n\t\treturn (const T*)GetConstSharedFragmentPtr(*T::StaticStruct());\n\t}\n\n\t/** will fail a check if the viewed entity doesn't have the given const shared fragment */\n\ttemplate<typename T>\n\tconst T& GetConstSharedFragmentData() const\n\t{\n\t\tstatic_assert(std::is_base_of_v<FMassConstSharedFragment, T>,\n\t\t\t\"Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.\");\n\n\t\treturn *((const T*)GetConstSharedFragmentPtrChecked(*T::StaticStruct()));\n\t}\n\n\tFConstStructView GetConstSharedFragmentDataStruct(const UScriptStruct* FragmentType) const\n\t{\n\t\tcheck(FragmentType && FragmentType->IsChildOf(FMassConstSharedFragment::StaticStruct()));\n\t\treturn FConstStructView(FragmentType, static_cast<const uint8*>(GetConstSharedFragmentPtr(*FragmentType)));\n\t}\n\n\t/** will fail a check if the viewed entity doesn't have the given shared fragment */\n\ttemplate<typename T UE_REQUIRES(std::is_base_of_v<FMassSharedFragment, T>)>\n\tT& GetSharedFragmentData() const\n\t{\n\t\treturn *((T*)GetSharedFragmentPtrChecked(*T::StaticStruct()));\n\t}\n\n\t/** if the viewed entity doesn't have the given shared fragment the function will return null */\n\ttemplate<typename T UE_REQUIRES(std::is_base_of_v<FMassSharedFragment, T>)>\n\tT* GetSharedFragmentDataPtr() const\n\t{\n\t\treturn (T*)GetSharedFragmentPtr(*T::StaticStruct());\n\t}\n\n\ttemplate<typename T UE_REQUIRES(std::is_base_of_v<FMassConstSharedFragment, T>)>\n\tUE_DEPRECATED(5.5, \"Using GetSharedFragmentDataPtr with const shared fragments is deprecated. Use GetConstSharedFragmentDataPtr instead\")\n\tT* GetSharedFragmentDataPtr() const\n\t{\n\t\treturn const_cast<T*>(GetConstSharedFragmentDataPtr<T>());\n\t}\n\n\ttemplate<typename T UE_REQUIRES(std::is_base_of_v<FMassConstSharedFragment, T>)>\n\tUE_DEPRECATED(5.5, \"Using GetSharedFragmentDataPtr with const shared fragments is deprecated. Use GetConstSharedFragmentData instead\")\n\tT& GetSharedFragmentData() const\n\t{\n\t\t/*static T DummyInstance;\n\t\treturn DummyInstance;*/\n\t\treturn const_cast<T&>(GetConstSharedFragmentData<T>());\n\t}\n\n\tFStructView GetSharedFragmentDataStruct(const UScriptStruct* FragmentType) const\n\t{\n\t\tcheck(FragmentType && FragmentType->IsChildOf(FMassSharedFragment::StaticStruct()));\n\t\treturn FStructView(FragmentType, static_cast<uint8*>(GetSharedFragmentPtr(*FragmentType)));\n\t}\n\n\ttemplate<typename T>\n\tbool HasTag() const\n\t{\n\t\tstatic_assert(std::is_base_of_v<FMassTag, T>, \"Given struct doesn't represent a valid tag type. Make sure to inherit from FMassTag or one of its child-types.\");\n\t\treturn HasTag(*T::StaticStruct());\n\t}\n\n\tbool HasTag(const UScriptStruct& TagType) const;\n\n\tbool IsSet() const { return Archetype != nullptr && EntityDataHandle.IsValid(); }\n\tbool IsValid() const { return IsSet(); }\n\tbool operator==(const FMassEntityView& Other) const { return Archetype == Other.Archetype && EntityDataHandle == Other.EntityDataHandle; }\n\nprotected:\n\tvoid* GetFragmentPtr(const UScriptStruct& FragmentType) const;\n\tvoid* GetFragmentPtrChecked(const UScriptStruct& FragmentType) const;\n\tconst void* GetConstSharedFragmentPtr(const UScriptStruct& FragmentType) const;\n\tconst void* GetConstSharedFragmentPtrChecked(const UScriptStruct& FragmentType) const;\n\tvoid* GetSharedFragmentPtr(const UScriptStruct& FragmentType) const;\n\tvoid* GetSharedFragmentPtrChecked(const UScriptStruct& FragmentType) const;\n\nprivate:\n\tFMassEntityHandle Entity;\n\tFMassRawEntityInChunkData EntityDataHandle;\n\tFMassArchetypeData* Archetype = nullptr;\n};\n",
      "lines": 164
    },
    {
      "file_path": "MassEntity\\Public\\MassExecutionContext.h",
      "extension": ".h",
      "size_bytes": 20044,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassExternalSubsystemTraits.h\"\n#include \"MassEntityQuery.h\"\n#include \"MassSubsystemAccess.h\"\n\n\n#define CHECK_IF_VALID(View, Type) \\\n\tcheckf(View \\\n\t\t, TEXT(\"Requested fragment type not bound, type %s. Make sure it has been listed as required.\"), *GetNameSafe(Type))\n\n#define CHECK_IF_READWRITE(View) \\\n\tcheckf(View == nullptr || View->Requirement.AccessMode == EMassFragmentAccess::ReadWrite \\\n\t\t, TEXT(\"Requested fragment type not bound for writing, type %s. Make sure it has been listed as required in ReadWrite mode.\") \\\n\t\t, View ? *GetNameSafe(View->Requirement.StructType) : TEXT(\"[Not found]\"))\n\n\nstruct MASSENTITY_API FMassExecutionContext\n{\nprivate:\n\n\ttemplate< typename ViewType >\n\tstruct TFragmentView \n\t{\n\t\tFMassFragmentRequirementDescription Requirement;\n\t\tViewType FragmentView;\n\n\t\tTFragmentView() {}\n\t\texplicit TFragmentView(const FMassFragmentRequirementDescription& InRequirement) : Requirement(InRequirement) {}\n\n\t\tbool operator==(const UScriptStruct* FragmentType) const { return Requirement.StructType == FragmentType; }\n\t};\n\tusing FFragmentView = TFragmentView<TArrayView<FMassFragment>>;\n\tTArray<FFragmentView, TInlineAllocator<8>> FragmentViews;\n\n\tusing FChunkFragmentView = TFragmentView<FStructView>;\n\tTArray<FChunkFragmentView, TInlineAllocator<4>> ChunkFragmentViews;\n\n\tusing FConstSharedFragmentView = TFragmentView<FConstStructView>;\n\tTArray<FConstSharedFragmentView, TInlineAllocator<4>> ConstSharedFragmentViews;\n\n\tusing FSharedFragmentView = TFragmentView<FStructView>;\n\tTArray<FSharedFragmentView, TInlineAllocator<4>> SharedFragmentViews;\n\n\tFMassSubsystemAccess SubsystemAccess;\n\t\n\t// mz@todo make this shared ptr thread-safe and never auto-flush in MT environment. \n\tTSharedPtr<FMassCommandBuffer> DeferredCommandBuffer;\n\tTArrayView<FMassEntityHandle> EntityListView;\n\t\n\t/** If set this indicates the exact archetype and its chunks to be processed. \n\t *  @todo this data should live somewhere else, preferably be just a parameter to Query.ForEachEntityChunk function */\n\tFMassArchetypeEntityCollection EntityCollection;\n\t\n\t/** @todo rename to \"payload\" */\n\tFInstancedStruct AuxData;\n\tfloat DeltaTimeSeconds = 0.0f;\n\tint32 ChunkSerialModificationNumber = -1;\n\tFMassArchetypeCompositionDescriptor CurrentArchetypeCompositionDescriptor;\n\n\tTSharedRef<FMassEntityManager> EntityManager;\n\n#if WITH_MASSENTITY_DEBUG\n\tFString DebugExecutionDescription;\n#endif\n\t\n\t/** Used to control when the context is allowed to flush commands collected in DeferredCommandBuffer. This mechanism \n\t * is mainly utilized to avoid numerous small flushes in favor of fewer larger ones. */\n\tbool bFlushDeferredCommands = true;\n\n\tTArrayView<FFragmentView> GetMutableRequirements() { return FragmentViews; }\n\tTArrayView<FChunkFragmentView> GetMutableChunkRequirements() { return ChunkFragmentViews; }\n\tTArrayView<FConstSharedFragmentView> GetMutableConstSharedRequirements() { return ConstSharedFragmentViews; }\n\tTArrayView<FSharedFragmentView> GetMutableSharedRequirements() { return SharedFragmentViews; }\n\n\tvoid GetSubsystemRequirementBits(FMassExternalSubsystemBitSet& OutConstSubsystemsBitSet, FMassExternalSubsystemBitSet& OutMutableSubsystemsBitSet)\n\t{\n\t\tSubsystemAccess.GetSubsystemRequirementBits(OutConstSubsystemsBitSet, OutMutableSubsystemsBitSet);\n\t}\n\n\tvoid SetSubsystemRequirementBits(const FMassExternalSubsystemBitSet& InConstSubsystemsBitSet, const FMassExternalSubsystemBitSet& InMutableSubsystemsBitSet)\n\t{\n\t\tSubsystemAccess.SetSubsystemRequirementBits(InConstSubsystemsBitSet, InMutableSubsystemsBitSet);\n\t}\n\n\tEMassExecutionContextType ExecutionType = EMassExecutionContextType::Local;\n\n\tfriend FMassArchetypeData;\n\tfriend FMassEntityQuery;\n\npublic:\n\texplicit FMassExecutionContext(FMassEntityManager& InEntityManager, const float InDeltaTimeSeconds = 0.f, const bool bInFlushDeferredCommands = true);\n\n\tFMassEntityManager& GetEntityManagerChecked() { return EntityManager.Get(); }\n\n#if WITH_MASSENTITY_DEBUG\n\tconst FString& DebugGetExecutionDesc() const { return DebugExecutionDescription; }\n\tvoid DebugSetExecutionDesc(const FString& Description) { DebugExecutionDescription = Description; }\n#endif\n\n\t/** Sets bFlushDeferredCommands. Note that setting to True while the system is being executed doesn't result in\n\t *  immediate commands flushing */\n\tvoid SetFlushDeferredCommands(const bool bNewFlushDeferredCommands) { bFlushDeferredCommands = bNewFlushDeferredCommands; } \n\tvoid SetDeferredCommandBuffer(const TSharedPtr<FMassCommandBuffer>& InDeferredCommandBuffer) { DeferredCommandBuffer = InDeferredCommandBuffer; }\n\tvoid SetEntityCollection(const FMassArchetypeEntityCollection& InEntityCollection);\n\tvoid SetEntityCollection(FMassArchetypeEntityCollection&& InEntityCollection);\n\tvoid ClearEntityCollection() { EntityCollection.Reset(); }\n\tvoid SetAuxData(const FInstancedStruct& InAuxData) { AuxData = InAuxData; }\n\tvoid SetExecutionType(EMassExecutionContextType InExecutionType) { check(InExecutionType != EMassExecutionContextType::MAX); ExecutionType = InExecutionType; }\n\n\tfloat GetDeltaTimeSeconds() const\n\t{\n\t\treturn DeltaTimeSeconds;\n\t}\n\n\tUWorld* GetWorld();\n\n\tTSharedPtr<FMassCommandBuffer> GetSharedDeferredCommandBuffer() const { return DeferredCommandBuffer; }\n\tFMassCommandBuffer& Defer() const { checkSlow(DeferredCommandBuffer.IsValid()); return *DeferredCommandBuffer.Get(); }\n\n\tTConstArrayView<FMassEntityHandle> GetEntities() const { return EntityListView; }\n\tint32 GetNumEntities() const { return EntityListView.Num(); }\n\n\tFMassEntityHandle GetEntity(const int32 Index) const\n\t{\n\t\treturn EntityListView[Index];\n\t}\n\n\tbool DoesArchetypeHaveFragment(const UScriptStruct& FragmentType) const\n\t{\n\t\treturn CurrentArchetypeCompositionDescriptor.Fragments.Contains(FragmentType);\n\t}\n\n\ttemplate<typename T>\n\tbool DoesArchetypeHaveFragment() const\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassFragment>::IsDerived, \"Given struct is not of a valid fragment type.\");\n\t\treturn CurrentArchetypeCompositionDescriptor.Fragments.Contains<T>();\n\t}\n\n\tbool DoesArchetypeHaveTag(const UScriptStruct& TagType) const\n\t{\n\t\treturn CurrentArchetypeCompositionDescriptor.Tags.Contains(TagType);\n\t}\n\n\ttemplate<typename T>\n\tbool DoesArchetypeHaveTag() const\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassTag>::IsDerived, \"Given struct is not of a valid tag type.\");\n\t\treturn CurrentArchetypeCompositionDescriptor.Tags.Contains<T>();\n\t}\n\n\t/** Chunk related operations */\n\tvoid SetCurrentChunkSerialModificationNumber(const int32 SerialModificationNumber) { ChunkSerialModificationNumber = SerialModificationNumber; }\n\tint32 GetChunkSerialModificationNumber() const { return ChunkSerialModificationNumber; }\n\n\ttemplate<typename T>\n\tT* GetMutableChunkFragmentPtr()\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassChunkFragment>::IsDerived, \"Given struct doesn't represent a valid chunk fragment type. Make sure to inherit from FMassChunkFragment or one of its child-types.\");\n\n\t\tconst UScriptStruct* Type = T::StaticStruct();\n\t\tFChunkFragmentView* FoundChunkFragmentData = ChunkFragmentViews.FindByPredicate([Type](const FChunkFragmentView& Element) { return Element.Requirement.StructType == Type; } );\n\t\tCHECK_IF_READWRITE(FoundChunkFragmentData);\n\t\treturn FoundChunkFragmentData ? FoundChunkFragmentData->FragmentView.GetPtr<T>() : static_cast<T*>(nullptr);\n\t}\n\t\n\ttemplate<typename T>\n\tT& GetMutableChunkFragment()\n\t{\n\t\tT* ChunkFragment = GetMutableChunkFragmentPtr<T>();\n\t\tCHECK_IF_VALID(ChunkFragment, T::StaticStruct());\n\t\treturn *ChunkFragment;\n\t}\n\n\ttemplate<typename T>\n\tconst T* GetChunkFragmentPtr() const\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassChunkFragment>::IsDerived, \"Given struct doesn't represent a valid chunk fragment type. Make sure to inherit from FMassChunkFragment or one of its child-types.\");\n\n\t\tconst UScriptStruct* Type = T::StaticStruct();\n\t\tconst FChunkFragmentView* FoundChunkFragmentData = ChunkFragmentViews.FindByPredicate([Type](const FChunkFragmentView& Element) { return Element.Requirement.StructType == Type; } );\n\t\treturn FoundChunkFragmentData ? FoundChunkFragmentData->FragmentView.GetPtr<T>() : static_cast<const T*>(nullptr);\n\t}\n\t\n\ttemplate<typename T>\n\tconst T& GetChunkFragment() const\n\t{\n\t\tconst T* ChunkFragment = GetChunkFragmentPtr<T>();\n\t\tCHECK_IF_VALID(ChunkFragment, T::StaticStruct());\n\t\treturn *ChunkFragment;\n\t}\n\n\t/** Shared fragment related operations */\n\tconst void* GetConstSharedFragmentPtr(const UScriptStruct& SharedFragmentType) const\n\t{\n\t\tconst FConstSharedFragmentView* FoundSharedFragmentData = ConstSharedFragmentViews.FindByPredicate([&SharedFragmentType](const FConstSharedFragmentView& Element) { return Element.Requirement.StructType == &SharedFragmentType; });\n\t\treturn FoundSharedFragmentData ? FoundSharedFragmentData->FragmentView.GetMemory() : nullptr;\n\t}\n\t\n\ttemplate<typename T>\n\tconst T* GetConstSharedFragmentPtr() const\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassConstSharedFragment>::IsDerived, \"Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.\");\n\n\t\tconst FConstSharedFragmentView* FoundSharedFragmentData = ConstSharedFragmentViews.FindByPredicate([](const FConstSharedFragmentView& Element) { return Element.Requirement.StructType == T::StaticStruct(); });\n\t\treturn FoundSharedFragmentData ? FoundSharedFragmentData->FragmentView.GetPtr<const T>() : static_cast<const T*>(nullptr);\n\t}\n\n\ttemplate<typename T>\n\tconst T& GetConstSharedFragment() const\n\t{\n\t\tconst T* SharedFragment = GetConstSharedFragmentPtr<const T>();\n\t\tCHECK_IF_VALID(SharedFragment, T::StaticStruct());\n\t\treturn *SharedFragment;\n\t}\n\n\ttemplate<typename T>\n\tT* GetMutableSharedFragmentPtr()\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassSharedFragment>::IsDerived, \"Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.\");\n\n\t\tFSharedFragmentView* FoundSharedFragmentData = SharedFragmentViews.FindByPredicate([](const FSharedFragmentView& Element) { return Element.Requirement.StructType == T::StaticStruct(); });\n\t\tCHECK_IF_READWRITE(FoundSharedFragmentData);\n\t\treturn FoundSharedFragmentData ? FoundSharedFragmentData->FragmentView.GetPtr<T>() : static_cast<T*>(nullptr);\n\t}\n\n\ttemplate<typename T>\n\tconst T* GetSharedFragmentPtr() const\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassSharedFragment>::IsDerived, \"Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.\");\n\n\t\tconst FSharedFragmentView* FoundSharedFragmentData = SharedFragmentViews.FindByPredicate([](const FSharedFragmentView& Element) { return Element.Requirement.StructType == T::StaticStruct(); });\n\t\treturn FoundSharedFragmentData ? FoundSharedFragmentData->FragmentView.GetPtr<T>() : static_cast<const T*>(nullptr);\n\t}\n\n\ttemplate<typename T>\n\tT& GetMutableSharedFragment()\n\t{\n\t\tT* SharedFragment = GetMutableSharedFragmentPtr<T>();\n\t\tCHECK_IF_VALID(SharedFragment, T::StaticStruct());\n\t\treturn *SharedFragment;\n\t}\n\n\ttemplate<typename T>\n\tconst T& GetSharedFragment() const\n\t{\n\t\tconst T* SharedFragment = GetSharedFragmentPtr<T>();\n\t\tCHECK_IF_VALID(SharedFragment, T::StaticStruct());\n\t\treturn *SharedFragment;\n\t}\n\n\t/* Fragments related operations */\n\ttemplate<typename TFragment>\n\tTArrayView<TFragment> GetMutableFragmentView()\n\t{\n\t\tconst UScriptStruct* FragmentType = TFragment::StaticStruct();\n\t\tconst FFragmentView* View = FragmentViews.FindByPredicate([FragmentType](const FFragmentView& Element) { return Element.Requirement.StructType == FragmentType; });\n\t\tCHECK_IF_VALID(View, FragmentType);\n\t\tCHECK_IF_READWRITE(View);\n\t\treturn MakeArrayView<TFragment>((TFragment*)View->FragmentView.GetData(), View->FragmentView.Num());\n\t}\n\n\ttemplate<typename TFragment>\n\tTConstArrayView<TFragment> GetFragmentView() const\n\t{\n\t\tconst UScriptStruct* FragmentType = TFragment::StaticStruct();\n\t\tconst FFragmentView* View = FragmentViews.FindByPredicate([FragmentType](const FFragmentView& Element) { return Element.Requirement.StructType == FragmentType; });\n\t\tCHECK_IF_VALID(View, TFragment::StaticStruct());\n\t\treturn TConstArrayView<TFragment>((const TFragment*)View->FragmentView.GetData(), View->FragmentView.Num());\n\t}\n\n\tTConstArrayView<FMassFragment> GetFragmentView(const UScriptStruct* FragmentType) const\n\t{\n\t\tconst FFragmentView* View = FragmentViews.FindByPredicate([FragmentType](const FFragmentView& Element) { return Element.Requirement.StructType == FragmentType; });\n\t\tCHECK_IF_VALID(View, FragmentType);\n\t\treturn TConstArrayView<FMassFragment>((const FMassFragment*)View->FragmentView.GetData(), View->FragmentView.Num());;\n\t}\n\n\tTArrayView<FMassFragment> GetMutableFragmentView(const UScriptStruct* FragmentType) \n\t{\n\t\tconst FFragmentView* View = FragmentViews.FindByPredicate([FragmentType](const FFragmentView& Element) { return Element.Requirement.StructType == FragmentType; });\n\t\tCHECK_IF_VALID(View, FragmentType);\n\t\tCHECK_IF_READWRITE(View);\n\t\treturn View->FragmentView;\n\t}\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tT* GetMutableSubsystem()\n\t{\n\t\treturn SubsystemAccess.GetMutableSubsystem<T>();\n\t}\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tT& GetMutableSubsystemChecked()\n\t{\n\t\treturn SubsystemAccess.GetMutableSubsystemChecked<T>();\n\t}\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tconst T* GetSubsystem()\n\t{\n\t\treturn SubsystemAccess.GetSubsystem<T>();\n\t}\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tconst T& GetSubsystemChecked()\n\t{\n\t\treturn SubsystemAccess.GetSubsystemChecked<T>();\n\t}\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tT* GetMutableSubsystem(const TSubclassOf<USubsystem> SubsystemClass)\n\t{\n\t\treturn SubsystemAccess.GetMutableSubsystem<T>(SubsystemClass);\n\t}\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tT& GetMutableSubsystemChecked(const TSubclassOf<USubsystem> SubsystemClass)\n\t{\n\t\treturn SubsystemAccess.GetMutableSubsystemChecked<T>(SubsystemClass);\n\t}\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tconst T* GetSubsystem(const TSubclassOf<USubsystem> SubsystemClass)\n\t{\n\t\treturn SubsystemAccess.GetSubsystem<T>(SubsystemClass);\n\t}\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tconst T& GetSubsystemChecked(const TSubclassOf<USubsystem> SubsystemClass)\n\t{\n\t\treturn SubsystemAccess.GetSubsystemChecked<T>(SubsystemClass);\n\t}\n\n\t/** Sparse chunk related operation */\n\tconst FMassArchetypeEntityCollection& GetEntityCollection() const { return EntityCollection; }\n\n\tconst FInstancedStruct& GetAuxData() const { return AuxData; }\n\tFInstancedStruct& GetMutableAuxData() { return AuxData; }\n\t\n\ttemplate<typename TFragment>\n\tbool ValidateAuxDataType() const\n\t{\n\t\tconst UScriptStruct* FragmentType = GetAuxData().GetScriptStruct();\n\t\treturn FragmentType != nullptr && FragmentType == TFragment::StaticStruct();\n\t}\n\n\tvoid FlushDeferred();\n\n\tvoid ClearExecutionData();\n\tvoid SetCurrentArchetypeCompositionDescriptor(const FMassArchetypeCompositionDescriptor& Descriptor)\n\t{\n\t\tCurrentArchetypeCompositionDescriptor = Descriptor;\n\t}\n\n\t/** \n\t * Processes SubsystemRequirements to fetch and cache all the indicated subsystems. If a UWorld is required to fetch\n\t * a specific subsystem then the one associated with the stored EntityManager will be used.\n\t *\n\t * @param SubsystemRequirements indicates all the subsystems that are expected to be accessed. Requesting a subsystem \n\t *\tnot indicated by the SubsystemRequirements will result in a failure.\n\t * \n\t * @return `true` if all required subsystems have been found, `false` otherwise.\n\t */\n\tbool CacheSubsystemRequirements(const FMassSubsystemRequirements& SubsystemRequirements);\n\nprotected:\n\tvoid SetSubsystemRequirements(const FMassSubsystemRequirements& SubsystemRequirements)\n\t{\n\t\tSubsystemAccess.SetSubsystemRequirements(SubsystemRequirements);\n\t}\n\n\tvoid SetFragmentRequirements(const FMassFragmentRequirements& FragmentRequirements);\n\n\tvoid ClearFragmentViews()\n\t{\n\t\tfor (FFragmentView& View : FragmentViews)\n\t\t{\n\t\t\tView.FragmentView = TArrayView<FMassFragment>();\n\t\t}\n\t\tfor (FChunkFragmentView& View : ChunkFragmentViews)\n\t\t{\n\t\t\tView.FragmentView.Reset();\n\t\t}\n\t\tfor (FConstSharedFragmentView& View : ConstSharedFragmentViews)\n\t\t{\n\t\t\tView.FragmentView.Reset();\n\t\t}\n\t\tfor (FSharedFragmentView& View : SharedFragmentViews)\n\t\t{\n\t\t\tView.FragmentView.Reset();\n\t\t}\n\t}\n\npublic:\n\t//////////////////////////////////////////////////////////////////////////\n\t// DEPRECATED functions\n\n\ttemplate<typename T>\n\tUE_DEPRECATED(5.2, \"The Get*Subsystem(World) functions have been deprecated. Use the world-less flavor.\")\n\tT* GetMutableSubsystem(const UWorld* World)\n\t{\n\t\treturn SubsystemAccess.GetMutableSubsystem<T>();\n\t}\n\n\ttemplate<typename T>\n\tUE_DEPRECATED(5.2, \"The Get*Subsystem(World) functions have been deprecated. Use the world-less flavor.\")\n\tT& GetMutableSubsystemChecked(const UWorld* World)\n\t{\n\t\treturn SubsystemAccess.GetMutableSubsystemChecked<T>();\n\t}\n\n\ttemplate<typename T>\n\tUE_DEPRECATED(5.2, \"The Get*Subsystem(World) functions have been deprecated. Use the world-less flavor.\")\n\tconst T* GetSubsystem(const UWorld* World)\n\t{\n\t\treturn SubsystemAccess.GetSubsystem<T>();\n\t}\n\n\ttemplate<typename T>\n\tUE_DEPRECATED(5.2, \"The Get*Subsystem(World) functions have been deprecated. Use the world-less flavor.\")\n\tconst T& GetSubsystemChecked(const UWorld* World)\n\t{\n\t\treturn SubsystemAccess.GetSubsystemChecked<T>();\n\t}\n\n\ttemplate<typename T>\n\tUE_DEPRECATED(5.2, \"The Get*Subsystem(World) functions have been deprecated. Use the world-less flavor.\")\n\tT* GetMutableSubsystem(const UWorld* World, const TSubclassOf<USubsystem> SubsystemClass)\n\t{\n\t\treturn SubsystemAccess.GetMutableSubsystem<T>(SubsystemClass);\n\t}\n\n\ttemplate<typename T>\n\tUE_DEPRECATED(5.2, \"The Get*Subsystem(World) functions have been deprecated. Use the world-less flavor.\")\n\tT& GetMutableSubsystemChecked(const UWorld* World, const TSubclassOf<USubsystem> SubsystemClass)\n\t{\n\t\treturn SubsystemAccess.GetMutableSubsystemChecked<T>(SubsystemClass);\n\t}\n\n\ttemplate<typename T>\n\tUE_DEPRECATED(5.2, \"The Get*Subsystem(World) functions have been deprecated. Use the world-less flavor.\")\n\tconst T* GetSubsystem(const UWorld* World, const TSubclassOf<USubsystem> SubsystemClass)\n\t{\n\t\treturn SubsystemAccess.GetSubsystem<T>(SubsystemClass);\n\t}\n\n\ttemplate<typename T>\n\tUE_DEPRECATED(5.2, \"The Get*Subsystem(World) functions have been deprecated. Use the world-less flavor.\")\n\tconst T& GetSubsystemChecked(const UWorld* World, const TSubclassOf<USubsystem> SubsystemClass)\n\t{\n\t\treturn SubsystemAccess.GetSubsystemChecked<T>(SubsystemClass);\n\t}\n\n\tUE_DEPRECATED(5.2, \"This version of CacheSubsystemRequirements is deprecated. Use the one without the UWorld parameter\")\n\tbool CacheSubsystemRequirements(const UWorld*, const FMassSubsystemRequirements& SubsystemRequirements)\n\t{\n\t\treturn CacheSubsystemRequirements(SubsystemRequirements);\n\t}\n\n\tUE_DEPRECATED(5.4, \"Deprecated in favor of 'SetCurrentArchetypeCompositionDescriptor' as this provides information on the entire archetype.\")\n\tvoid SetCurrentArchetypesTagBitSet(const FMassTagBitSet&) {}\n};\n\n#undef CHECK_IF_VALID\n#undef CHECK_IF_READWRITE\n",
      "lines": 470
    },
    {
      "file_path": "MassEntity\\Public\\MassExecutor.h",
      "extension": ".h",
      "size_bytes": 2992,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassArchetypeTypes.h\"\n#include \"Async/TaskGraphInterfaces.h\"\n\n\nstruct FMassRuntimePipeline;\nstruct FMassProcessingContext;\nstruct FMassEntityHandle;\nstruct FMassArchetypeEntityCollection;\nclass UMassProcessor;\n\n\nnamespace UE::Mass::Executor\n{\n\t/** Executes processors in a given RuntimePipeline */\n\tMASSENTITY_API void Run(FMassRuntimePipeline& RuntimePipeline, FMassProcessingContext& ProcessingContext);\n\n\t/** Executes given Processor. Used mainly for triggering calculations via MassCompositeProcessors, e.g processing phases */\n\tMASSENTITY_API void Run(UMassProcessor& Processor, FMassProcessingContext& ProcessingContext);\n\n\t/** Similar to the Run function, but instead of using all the entities hosted by ProcessingContext.EntitySubsystem \n\t *  it is processing only the entities given by EntityID via the Entities input parameter. \n\t *  Note that all the entities need to be of Archetype archetype. \n\t *  Under the hood the function converts Archetype-Entities pair to FMassArchetypeEntityCollection and calls the other flavor of RunSparse\n\t */\n\tMASSENTITY_API void RunSparse(FMassRuntimePipeline& RuntimePipeline, FMassProcessingContext& ProcessingContext, FMassArchetypeHandle Archetype, TConstArrayView<FMassEntityHandle> Entities);\n\n\t/** Similar to the Run function, but instead of using all the entities hosted by ProcessingContext.EntitySubsystem \n\t *  it is processing only the entities given by SparseEntities input parameter.\n\t *  @todo rename\n\t */\n\tMASSENTITY_API void RunSparse(FMassRuntimePipeline& RuntimePipeline, FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection& EntityCollection);\n\n\t/** Executes given Processors array view. This function gets called under the hood by the rest of Run* functions */\n\tMASSENTITY_API void RunProcessorsView(TArrayView<UMassProcessor* const> Processors, FMassProcessingContext& ProcessingContext, TConstArrayView<FMassArchetypeEntityCollection> EntityCollections = {});\n\n\t/** \n\t *  Triggers tasks executing Processor (and potentially it's children) and returns the task graph event representing \n\t *  the task (the event will be \"completed\" once all the processors finish running). \n\t *  @param OnDoneNotification will be called after all the processors are done, just after flushing the command buffer.\n\t *    Note that OnDoneNotification will be executed on GameThread.\n\t */\n\tMASSENTITY_API FGraphEventRef TriggerParallelTasks(UMassProcessor& Processor, FMassProcessingContext& ProcessingContext, TFunction<void()> OnDoneNotification);\n\n\tUE_DEPRECATED(5.5, \"This flavor of RunProcessorsView is deprecated. Use the one with TConstArrayView<FMassArchetypeEntityCollection> parameter instead.\")\n\tMASSENTITY_API void RunProcessorsView(TArrayView<UMassProcessor* const> Processors, FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection* EntityCollection);\n};\n",
      "lines": 50
    },
    {
      "file_path": "MassEntity\\Public\\MassExternalSubsystemTraits.h",
      "extension": ".h",
      "size_bytes": 2627,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Engine/World.h\"\n#include \"Subsystems/WorldSubsystem.h\"\n\n/**\n * Traits describing how a given piece of code can be used by Mass. We require author or user of a given subsystem to \n * define its traits. To do it add the following in an accessible location. \n *\n * template<>\n * struct TMassExternalSubsystemTraits<UMyCustomManager>\n * {\n *\t\tenum { GameThreadOnly = false; }\n * }\n *\n * this will let Mass know it can access UMyCustomManager on any thread.\n *\n * This information is being used to calculate processor and query dependencies as well as appropriate distribution of\n * calculations across threads.\n */\ntemplate <typename T>\nstruct TMassExternalSubsystemTraits final\n{\n\tenum\n\t{\n\t\t// Note that we're not supplying a default value for this property to be able to statically catch code that tries\n\t\t// to access given subsystem without including the appropriate headers. See the comment above if you want to use\n\t\t// a UWorldSubsystem that has not had its traits defined before. \n\t\t// GameThreadOnly = true,\n\t\tThreadSafeRead = false,\n\t\tThreadSafeWrite = false,\n\t};\n};\n\nnamespace FMassExternalSubsystemTraits\n{\n\t/**\n\t * Every TMassExternalSubsystemTraits specialization needs to implement the following. Not supplying default implementations\n\t * to be able to catch missing implementations and header inclusion at compilation time.\n\t * \n\t * This is a getter function that given a UWorld* fetches an instance.\n\t*/\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, UWorldSubsystem>::IsDerived>::Type>\n\tUE_DEPRECATED(5.2, \"FMassExternalSubsystemTraits::GetInstance has been marked as deprecated. Use FMassSubsystemAccess::FetchSubsystemInstance instead.\")\n\tFORCEINLINE T* GetInstance(const UWorld* World)\n\t{ \n\t\t// note that the default implementation works only for UWorldSubsystems\n\t\treturn UWorld::GetSubsystem<T>(World);\n\t}\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, UWorldSubsystem>::IsDerived>::Type>\n\tUE_DEPRECATED(5.2, \"FMassExternalSubsystemTraits::GetInstance has been marked as deprecated. Use FMassSubsystemAccess::FetchSubsystemInstance instead.\")\n\tFORCEINLINE T* GetInstance(const UWorld* World, const TSubclassOf<UWorldSubsystem> SubsystemClass)\n\t{\n\t\treturn World ? Cast<T>(World->GetSubsystemBase(SubsystemClass)) : (T*)nullptr;\n\t}\n}\n\n/** \n * Shared Fragments' traits.\n * @see TMassExternalSubsystemTraits\n */\ntemplate <typename T>\nstruct TMassSharedFragmentTraits final\n{\n\tenum\n\t{\n\t\tGameThreadOnly = false,\n\t};\n};\n",
      "lines": 72
    },
    {
      "file_path": "MassEntity\\Public\\MassObserverManager.h",
      "extension": ".h",
      "size_bytes": 8099,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassObserverManager.generated.h\"\n\n\nstruct FMassEntityManager;\nstruct FMassArchetypeEntityCollection;\nclass UMassProcessor;\nstruct FMassProcessingContext;\n\n/** \n * A wrapper type for a TMap to support having array-of-maps UPROPERTY members in FMassObserverManager\n */\nUSTRUCT()\nstruct FMassObserversMap\n{\n\tGENERATED_BODY()\n\n\t// a helper accessor simplifying access while still keeping Container private\n\tTMap<TObjectPtr<const UScriptStruct>, FMassRuntimePipeline>& operator*()\n\t{\n\t\treturn Container;\n\t}\n\nprivate:\n\tUPROPERTY()\n\tTMap<TObjectPtr<const UScriptStruct>, FMassRuntimePipeline> Container;\n};\n\n/** \n * A type that encapsulates logic related to notifying interested parties of entity composition changes. Upon creation it\n * reads information from UMassObserverRegistry and instantiates processors interested in handling given fragment\n * type addition or removal.\n */\nUSTRUCT()\nstruct MASSENTITY_API FMassObserverManager\n{\n\tGENERATED_BODY()\n\npublic:\n\tFMassObserverManager();\t\n\n\tconst FMassFragmentBitSet* GetObservedFragmentBitSets() const { return ObservedFragments; }\n\tconst FMassFragmentBitSet& GetObservedFragmentsBitSet(const EMassObservedOperation Operation) const \n\t{ \n\t\treturn ObservedFragments[(uint8)Operation]; \n\t}\n\n\tconst FMassTagBitSet* GetObservedTagBitSets() const { return ObservedTags; }\n\tconst FMassTagBitSet& GetObservedTagsBitSet(const EMassObservedOperation Operation) const \n\t{ \n\t\treturn ObservedTags[(uint8)Operation]; \n\t}\n\t\n\tbool HasObserversForBitSet(const FMassFragmentBitSet& InQueriedBitSet, const EMassObservedOperation Operation) const\n\t{\n\t\treturn ObservedFragments[(uint8)Operation].HasAny(InQueriedBitSet);\n\t}\n\n\tbool HasObserversForBitSet(const FMassTagBitSet& InQueriedBitSet, const EMassObservedOperation Operation) const\n\t{\n\t\treturn ObservedTags[(uint8)Operation].HasAny(InQueriedBitSet);\n\t}\n\n\tbool HasObserversForComposition(const FMassArchetypeCompositionDescriptor& Composition, const EMassObservedOperation Operation) const\n\t{\n\t\treturn HasObserversForBitSet(Composition.Fragments, Operation) || HasObserversForBitSet(Composition.Tags, Operation);\n\t}\n\n\t/** @return whether any observers have been executed */\n\tbool OnPostEntitiesCreated(const FMassArchetypeEntityCollection& EntityCollection);\n\n\t/** @return whether any observers have been executed */\n\tbool OnPostEntitiesCreated(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections);\n\n\t/** @return whether any observers have been executed */\n\tbool OnPostEntitiesCreated(FMassProcessingContext& InProcessingContext, TConstArrayView<FMassArchetypeEntityCollection> EntityCollections);\n\n\t/** @return whether any observers have been executed */\n\tbool OnPreEntitiesDestroyed(const FMassArchetypeEntityCollection& EntityCollection);\n\n\t/** @return whether any observers have been executed */\n\tbool OnPreEntitiesDestroyed(FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection& EntityCollection);\n\n\t/** @return whether any observers have been executed */\n\tbool OnPreEntityDestroyed(const FMassArchetypeCompositionDescriptor& ArchetypeComposition, const FMassEntityHandle Entity);\n\n\t/** @return whether any observers have been executed */\n\tbool OnCompositionChanged(const FMassEntityHandle Entity, const FMassArchetypeCompositionDescriptor& CompositionDelta, const EMassObservedOperation Operation);\n\n\t/** @return whether any observers have been executed */\n\tbool OnPostCompositionAdded(const FMassEntityHandle Entity, const FMassArchetypeCompositionDescriptor& Composition)\n\t{\n\t\treturn OnCompositionChanged(Entity, Composition, EMassObservedOperation::Add);\n\t}\n\t/** @return whether any observers have been executed */\n\tbool OnPreCompositionRemoved(const FMassEntityHandle Entity, const FMassArchetypeCompositionDescriptor& Composition)\n\t{\n\t\treturn OnCompositionChanged(Entity, Composition, EMassObservedOperation::Remove);\n\t}\n\n\t/** @return whether any observers have been executed */\n\tbool OnCompositionChanged(FMassProcessingContext& InProcessingContext, const FMassArchetypeEntityCollection& EntityCollection, const FMassArchetypeCompositionDescriptor& Composition, const EMassObservedOperation Operation);\n\t/** @return whether any observers have been executed */\n\tbool OnCompositionChanged(const FMassArchetypeEntityCollection& EntityCollection, const FMassArchetypeCompositionDescriptor& Composition, const EMassObservedOperation Operation)\n\t{\n\t\tFMassProcessingContext LocalContext(EntityManager, /*DeltaSeconds=*/0.f);\n\t\tLocalContext.bFlushCommandBuffer = false;\n\t\treturn OnCompositionChanged(LocalContext, EntityCollection, Composition, Operation);\n\t}\n\n\tvoid OnPostFragmentOrTagAdded(const UScriptStruct& FragmentOrTagType, const FMassArchetypeEntityCollection& EntityCollection)\n\t{\n\t\tOnFragmentOrTagOperation(FragmentOrTagType, EntityCollection, EMassObservedOperation::Add);\n\t}\n\tvoid OnPreFragmentOrTagRemoved(const UScriptStruct& FragmentOrTagType, const FMassArchetypeEntityCollection& EntityCollection)\n\t{\n\t\tOnFragmentOrTagOperation(FragmentOrTagType, EntityCollection, EMassObservedOperation::Remove);\n\t}\n\t// @todo I don't love this name. Alternatively could be OnSingleFragmentOrTagOperation. Long term we'll switch to\n\t// OnSingleFragmentOperation and advertise that Tags are a type of Fragment as well (conceptually).\n\tvoid OnFragmentOrTagOperation(const UScriptStruct& FragmentOrTagType, const FMassArchetypeEntityCollection& EntityCollection, const EMassObservedOperation Operation);\n\n\tvoid AddObserverInstance(const UScriptStruct& FragmentOrTagType, const EMassObservedOperation Operation, UMassProcessor& ObserverProcessor);\n\tvoid RemoveObserverInstance(const UScriptStruct& FragmentOrTagType, const EMassObservedOperation Operation, UMassProcessor& ObserverProcessor);\n\nprotected:\n\tfriend FMassEntityManager;\n\texplicit FMassObserverManager(FMassEntityManager& Owner);\n\n\tvoid Initialize();\n\tvoid DeInitialize();\n\tvoid HandleFragmentsImpl(FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection& EntityCollection\n\t\t, TArrayView<const UScriptStruct*> ObservedTypes, FMassObserversMap& HandlersContainer);\n\tvoid HandleSingleEntityImpl(const UScriptStruct& FragmentType, const FMassArchetypeEntityCollection& EntityCollection, FMassObserversMap& HandlersContainer);\n\n\tFMassFragmentBitSet ObservedFragments[(uint8)EMassObservedOperation::MAX];\n\tFMassTagBitSet ObservedTags[(uint8)EMassObservedOperation::MAX];\n\n\tUPROPERTY()\n\tFMassObserversMap FragmentObservers[(uint8)EMassObservedOperation::MAX];\n\n\tUPROPERTY()\n\tFMassObserversMap TagObservers[(uint8)EMassObservedOperation::MAX];\n\n\t/** \n\t * The owning EntityManager. No need for it to be a UPROPERTY since by design we don't support creation of \n\t * FMassObserverManager outside of an FMassEntityManager instance \n\t */\n\tFMassEntityManager& EntityManager;\n\npublic:\n\tUE_DEPRECATED(5.4, \"This flavor of OnCompositionChanged is deprecated. Please use the one taking a FMassProcessingContext& parameter instead\")\n\tbool OnCompositionChanged(const FMassArchetypeEntityCollection& EntityCollection, const FMassArchetypeCompositionDescriptor& Composition, const EMassObservedOperation Operation, FMassProcessingContext* InProcessingContext)\n\t{\n\t\tif (InProcessingContext)\n\t\t{\n\t\t\treturn OnCompositionChanged(*InProcessingContext, EntityCollection, Composition, Operation);\n\t\t}\n\t\treturn OnCompositionChanged(EntityCollection, Composition, Operation);\n\t}\n\n\tUE_DEPRECATED(5.5, \"This flavor of OnPostEntitiesCreated is deprecated. Please use the one taking a TConstArrayView<FMassArchetypeEntityCollection> parameter instead\")\n\tbool OnPostEntitiesCreated(FMassProcessingContext& InProcessingContext, const FMassArchetypeEntityCollection& EntityCollection);\n};\n\ntemplate<>\nstruct TStructOpsTypeTraits<FMassObserverManager> : public TStructOpsTypeTraitsBase2<FMassObserverManager>\n{\n\tenum\n\t{\n\t\tWithCopy = false,\n\t};\n};\n",
      "lines": 177
    },
    {
      "file_path": "MassEntity\\Public\\MassObserverProcessor.h",
      "extension": ".h",
      "size_bytes": 901,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessor.h\"\n#include \"MassObserverProcessor.generated.h\"\n\n\nUCLASS(abstract)\nclass MASSENTITY_API UMassObserverProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassObserverProcessor();\n\nprotected:\n\tvirtual void PostInitProperties() override;\n\n\t/** \n\t * By default registers this class as Operation observer of ObservedType. Override to register for multiple \n\t * operations and/or types \n\t */\n\tvirtual void Register();\n\nprotected:\n\tUPROPERTY(EditDefaultsOnly, Category = Processor, config)\n\tbool bAutoRegisterWithObserverRegistry = true;\n\n\t/** Determines which Fragment or Tag type this given UMassObserverProcessor will be observing */\n\tUPROPERTY()\n\tTObjectPtr<UScriptStruct> ObservedType = nullptr;\n\n\tEMassObservedOperation Operation = EMassObservedOperation::MAX;\n};\n",
      "lines": 35
    },
    {
      "file_path": "MassEntity\\Public\\MassObserverRegistry.h",
      "extension": ".h",
      "size_bytes": 1830,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassProcessor.h\"\n#include \"MassObserverRegistry.generated.h\"\n\n\nstruct FMassObserverManager;\n\n/**\n * A wrapper type for a TArray to support having map-of-arrays UPROPERTY members in FMassEntityObserverClassesMap\n */\nUSTRUCT()\nstruct FMassProcessorClassCollection\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY()\n\tTArray<TSubclassOf<UMassProcessor>> ClassCollection;\n};\n\n/**\n * A wrapper type for a TMap to support having array-of-maps UPROPERTY members in UMassObserverRegistry\n */\nUSTRUCT()\nstruct FMassEntityObserverClassesMap\n{\n\tGENERATED_BODY()\n\n\t/** a helper accessor simplifying access while still keeping Container private */\n\tconst TMap<TObjectPtr<const UScriptStruct>, FMassProcessorClassCollection>& operator*() const\n\t{\n\t\treturn Container;\n\t}\n\n\tTMap<TObjectPtr<const UScriptStruct>, FMassProcessorClassCollection>& operator*()\n\t{\n\t\treturn Container;\n\t}\n\nprivate:\n\tUPROPERTY()\n\tTMap<TObjectPtr<const UScriptStruct>, FMassProcessorClassCollection> Container;\n};\n\nUCLASS()\nclass MASSENTITY_API UMassObserverRegistry : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassObserverRegistry();\n\n\tstatic UMassObserverRegistry& GetMutable() { return *GetMutableDefault<UMassObserverRegistry>(); }\n\tstatic const UMassObserverRegistry& Get() { return *GetDefault<UMassObserverRegistry>(); }\n\n\tvoid RegisterObserver(const UScriptStruct& ObservedType, const EMassObservedOperation Operation, TSubclassOf<UMassProcessor> ObserverClass);\n\nprotected:\n\tfriend FMassObserverManager;\n\n\tUPROPERTY()\n\tFMassEntityObserverClassesMap FragmentObservers[(uint8)EMassObservedOperation::MAX];\n\n\tUPROPERTY()\n\tFMassEntityObserverClassesMap TagObservers[(uint8)EMassObservedOperation::MAX];\n};\n",
      "lines": 69
    },
    {
      "file_path": "MassEntity\\Public\\MassProcessingPhaseManager.h",
      "extension": ".h",
      "size_bytes": 10387,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/UObjectGlobals.h\"\n#include \"UObject/Object.h\"\n#include \"UObject/GCObject.h\"\n#include \"Engine/EngineBaseTypes.h\"\n#include \"MassProcessingTypes.h\"\n#include \"MassProcessor.h\"\n#include \"MassProcessorDependencySolver.h\"\n#include \"MassProcessingPhaseManager.generated.h\"\n\n\nstruct FMassProcessingPhaseManager;\nclass UMassProcessor;\nclass UMassCompositeProcessor;\nstruct FMassEntityManager;\nstruct FMassCommandBuffer;\nstruct FMassProcessingPhaseConfig;\n\n\nUSTRUCT()\nstruct MASSENTITY_API FMassProcessingPhaseConfig\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, Category = Mass, config)\n\tFName PhaseName;\n\n\tUPROPERTY(EditAnywhere, Category = Mass, config, NoClear)\n\tTSubclassOf<UMassCompositeProcessor> PhaseGroupClass = UMassCompositeProcessor::StaticClass();\n\n\tUPROPERTY(Transient)\n\tTArray<TObjectPtr<UMassProcessor>> ProcessorCDOs;\n\n#if WITH_EDITORONLY_DATA\n\t// this processor is available only in editor since it's used to present the user the order in which processors\n\t// will be executed when given processing phase gets triggered\n\tUPROPERTY(Transient)\n\tTObjectPtr<UMassCompositeProcessor> PhaseProcessor = nullptr;\n\n\tUPROPERTY(VisibleAnywhere, Category = Mass, Transient)\n\tFText Description;\n#endif //WITH_EDITORONLY_DATA\n};\n\n\nstruct MASSENTITY_API FMassProcessingPhase : public FTickFunction\n{\n\tDECLARE_MULTICAST_DELEGATE_OneParam(FOnPhaseEvent, const float /*DeltaSeconds*/);\n\n\tFMassProcessingPhase();\n\tFMassProcessingPhase(const FMassProcessingPhase& Other) = delete;\n\tFMassProcessingPhase& operator=(const FMassProcessingPhase& Other) = delete;\n\nprotected:\n\t// FTickFunction interface\n\tvirtual void ExecuteTick(float DeltaTime, ELevelTick TickType, ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent) override;\n\tvirtual FString DiagnosticMessage() override;\n\tvirtual FName DiagnosticContext(bool bDetailed) override;\n\t// End of FTickFunction interface\n\n\tvoid OnParallelExecutionDone(const float DeltaTime);\n\n\tbool IsConfiguredForParallelMode() const { return bRunInParallelMode; }\n\tvoid ConfigureForParallelMode() { bRunInParallelMode = true; }\n\tvoid ConfigureForSingleThreadMode() { bRunInParallelMode = false; }\n\n\tbool ShouldTick(const ELevelTick TickType) const { return SupportedTickTypes & (1 << TickType); }\n\npublic:\n\tvoid Initialize(FMassProcessingPhaseManager& InPhaseManager, const EMassProcessingPhase InPhase, const ETickingGroup InTickGroup, UMassCompositeProcessor& InPhaseProcessor);\n\tvoid AddSupportedTickType(const ELevelTick TickType) { SupportedTickTypes |= (1 << TickType); }\n\tvoid RemoveSupportedTickType(const ELevelTick TickType) { SupportedTickTypes &= ~(1 << TickType); }\n\nprotected:\n\tfriend FMassProcessingPhaseManager;\n\n\t// composite processor representing work to be performed. GC-referenced via AddReferencedObjects\n\tTObjectPtr<UMassCompositeProcessor> PhaseProcessor = nullptr;\n\n\tEMassProcessingPhase Phase = EMassProcessingPhase::MAX;\n\tFOnPhaseEvent OnPhaseStart;\n\tFOnPhaseEvent OnPhaseEnd;\n\nprivate:\n\tFMassProcessingPhaseManager* PhaseManager = nullptr;\n\tstd::atomic<bool> bIsDuringMassProcessing = false;\n\tbool bRunInParallelMode = false;\n\tuint8 SupportedTickTypes = 0;\n};\n\n\nstruct MASSENTITY_API FMassPhaseProcessorConfigurationHelper\n{\n\tFMassPhaseProcessorConfigurationHelper(UMassCompositeProcessor& InOutPhaseProcessor, const FMassProcessingPhaseConfig& InPhaseConfig, UObject& InProcessorOuter, EMassProcessingPhase InPhase)\n\t\t: PhaseProcessor(InOutPhaseProcessor), PhaseConfig(InPhaseConfig), ProcessorOuter(InProcessorOuter), Phase(InPhase)\n\t{\n\t}\n\n\t/** \n\t * @param InWorldExecutionFlags - provide EProcessorExecutionFlags::None to let underlying code decide\n\t */\n\tvoid Configure(TArrayView<UMassProcessor* const> DynamicProcessors, EProcessorExecutionFlags InWorldExecutionFlags\n\t\t, const TSharedPtr<FMassEntityManager>& EntityManager = TSharedPtr<FMassEntityManager>()\n\t\t, FMassProcessorDependencySolver::FResult* OutOptionalResult = nullptr);\n\n\tUMassCompositeProcessor& PhaseProcessor;\n\tconst FMassProcessingPhaseConfig& PhaseConfig;\n\tUObject& ProcessorOuter;\n\tEMassProcessingPhase Phase;\n\tbool bInitializeCreatedProcessors = true;\n\tbool bIsGameRuntime = true;\n\n\tUE_DEPRECATED(5.2, \"This flavor of Configure has been deprecated. Use the one requiring the first parameter to be an array view of additional processors\")\n\tvoid Configure(const TSharedPtr<FMassEntityManager>& EntityManager = TSharedPtr<FMassEntityManager>(), FMassProcessorDependencySolver::FResult* OutOptionalResult = nullptr)\n\t{\n\t\tConfigure({}, EProcessorExecutionFlags::None, EntityManager, OutOptionalResult);\n\t}\n\n\tUE_DEPRECATED(5.3, \"This flavor of Configure has been deprecated. Use the one requiring the first parameter to be an array view of additional processors and EProcessorExecutionFlags to be provided\")\n\tvoid Configure(TArrayView<UMassProcessor* const> DynamicProcessors, const TSharedPtr<FMassEntityManager>& EntityManager = TSharedPtr<FMassEntityManager>(),\n\t\tFMassProcessorDependencySolver::FResult* OutOptionalResult = nullptr)\n\t{\n\t\tConfigure(DynamicProcessors, EProcessorExecutionFlags::None, EntityManager, OutOptionalResult);\n\t}\n};\n\n/** \n * MassProcessingPhaseManager owns separate FMassProcessingPhase instances for every ETickingGroup. When activated\n * via Start function it registers and enables the FMassProcessingPhase instances which themselves are tick functions \n * that host UMassCompositeProcessor which they trigger as part of their Tick function. \n * MassProcessingPhaseManager serves as an interface to said FMassProcessingPhase instances and allows initialization\n * with collections of processors (via Initialize function) as well as registering arbitrary functions to be called \n * when a particular phase starts or ends (via GetOnPhaseStart and GetOnPhaseEnd functions). \n */\nstruct MASSENTITY_API FMassProcessingPhaseManager : public FGCObject\n{\npublic:\n\texplicit FMassProcessingPhaseManager(EProcessorExecutionFlags InProcessorExecutionFlags = EProcessorExecutionFlags::None) \n\t\t: ProcessorExecutionFlags(InProcessorExecutionFlags)\n\t{}\n\tFMassProcessingPhaseManager(const FMassProcessingPhaseManager& Other) = delete;\n\tFMassProcessingPhaseManager& operator=(const FMassProcessingPhaseManager& Other) = delete;\n\n\tconst TSharedPtr<FMassEntityManager>& GetEntityManager() { return EntityManager; }\n\tFMassEntityManager& GetEntityManagerRef() { check(EntityManager); return *EntityManager.Get(); }\n\n\t/** Retrieves OnPhaseStart multicast delegate's reference for a given Phase */\n\tFMassProcessingPhase::FOnPhaseEvent& GetOnPhaseStart(const EMassProcessingPhase Phase) { return ProcessingPhases[uint8(Phase)].OnPhaseStart; } //-V557\n\t/** Retrieves OnPhaseEnd multicast delegate's reference for a given Phase */\n\tFMassProcessingPhase::FOnPhaseEvent& GetOnPhaseEnd(const EMassProcessingPhase Phase) { return ProcessingPhases[uint8(Phase)].OnPhaseEnd; }\n\n\t/** \n\t *  Populates hosted FMassProcessingPhase instances with Processors read from MassEntitySettings configuration.\n\t *  Calling this function overrides previous configuration of Phases.\n\t */\n\tvoid Initialize(UObject& InOwner, TConstArrayView<FMassProcessingPhaseConfig> ProcessingPhasesConfig, const FString& DependencyGraphFileName = TEXT(\"\"));\n\n\t/** Needs to be called before destruction, ideally before owner's BeginDestroy (a FGCObject's limitation) */\n\tvoid Deinitialize();\n\n\tconst FGraphEventRef& TriggerPhase(const EMassProcessingPhase Phase, const float DeltaTime, const FGraphEventRef& MyCompletionGraphEvent);\n\n\t/** \n\t *  Stores EntityManager associated with given world's MassEntitySubsystem and kicks off phase ticking.\n\t */\n\tvoid Start(UWorld& World);\n\t\n\t/**\n\t *  Stores InEntityManager as the entity manager. It also kicks off phase ticking if the given InEntityManager is tied to a UWorld.\n\t */\n\tvoid Start(const TSharedPtr<FMassEntityManager>& InEntityManager);\n\tvoid Stop();\n\tbool IsRunning() const { return EntityManager.IsValid(); }\n\n\tFString GetName() const;\n\n\t/** Registers a dynamic processor. This needs to be a fully formed processor and will be slotted in during the next tick. */\n\tvoid RegisterDynamicProcessor(UMassProcessor& Processor);\n\t/** Removes a previously registered dynamic processor of throws an assert if not found. */\n\tvoid UnregisterDynamicProcessor(UMassProcessor& Processor);\n\nprotected:\n\t// FGCObject interface\n\tvirtual void AddReferencedObjects(FReferenceCollector& Collector) override;\n\tvirtual FString GetReferencerName() const override\n\t{\n\t\treturn TEXT(\"FMassProcessingPhaseManager\");\n\t}\n\t// End of FGCObject interface\n\n\tvoid EnableTickFunctions(const UWorld& World);\n\n\t/** Creates phase processors instances for each declared phase name, based on MassEntitySettings */\n\tvoid CreatePhases();\n\n\tfriend FMassProcessingPhase;\n\n\t/** \n\t *  Called by the given Phase at the very start of its execution function (the FMassProcessingPhase::ExecuteTick),\n\t *  even before the FMassProcessingPhase.OnPhaseStart broadcast delegate\n\t */\n\tvoid OnPhaseStart(const FMassProcessingPhase& Phase);\n\n\t/**\n\t *  Called by the given Phase at the very end of its execution function (the FMassProcessingPhase::ExecuteTick),\n\t *  after the FMassProcessingPhase.OnPhaseEnd broadcast delegate\n\t */\n\tvoid OnPhaseEnd(FMassProcessingPhase& Phase);\n\n\tvoid OnNewArchetype(const FMassArchetypeHandle& NewArchetype);\n\nprotected:\t\n\tstruct FPhaseGraphBuildState\n\t{\n\t\tFMassProcessorDependencySolver::FResult LastResult;\n\t\tbool bNewArchetypes = true;\n\t\tbool bProcessorsNeedRebuild = true;\n\t\tbool bInitialized = false;\n\t};\n\n\tFMassProcessingPhase ProcessingPhases[(uint8)EMassProcessingPhase::MAX];\n\tFPhaseGraphBuildState ProcessingGraphBuildStates[(uint8)EMassProcessingPhase::MAX];\n\tTArray<FMassProcessingPhaseConfig> ProcessingPhasesConfig;\n\tTArray<TObjectPtr<UMassProcessor>> DynamicProcessors;\n\n\tTSharedPtr<FMassEntityManager> EntityManager;\n\n\tEMassProcessingPhase CurrentPhase = EMassProcessingPhase::MAX;\n\n\tTWeakObjectPtr<UObject> Owner;\n\n\tFDelegateHandle OnNewArchetypeHandle;\n\n\tEProcessorExecutionFlags ProcessorExecutionFlags = EProcessorExecutionFlags::None;\n\tbool bIsAllowedToTick = false;\n};\n",
      "lines": 240
    },
    {
      "file_path": "MassEntity\\Public\\MassProcessingTypes.h",
      "extension": ".h",
      "size_bytes": 5696,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"StructUtils/StructUtilsTypes.h\"\n#include \"StructUtils/InstancedStruct.h\"\n#include \"MassProcessingTypes.generated.h\"\n\n#ifndef MASS_DO_PARALLEL\n#define MASS_DO_PARALLEL !UE_SERVER\n#endif // MASS_DO_PARALLEL\n\n#define WITH_MASSENTITY_DEBUG (!(UE_BUILD_SHIPPING || UE_BUILD_SHIPPING_WITH_EDITOR || UE_BUILD_TEST) && WITH_STRUCTUTILS_DEBUG && 1)\n\nstruct FMassEntityManager;\nclass UMassProcessor;\nclass UMassCompositeProcessor;\nstruct FMassCommandBuffer;\n\nUENUM(meta = (Bitflags, UseEnumValuesAsMaskValuesInEditor = \"true\"))\nenum class EProcessorExecutionFlags : uint8\n{\n\tNone = 0 UMETA(Hidden),\n\tStandalone = 1 << 0,\n\tServer = 1 << 1,\n\tClient = 1 << 2,\n\tEditor = 1 << 3,\n\tEditorWorld = 1 << 4,\n\tAllNetModes = Standalone | Server | Client UMETA(Hidden),\n\tAllWorldModes = Standalone | Server | Client | EditorWorld UMETA(Hidden),\n\tAll = Standalone | Server | Client | Editor | EditorWorld UMETA(Hidden)\n};\nENUM_CLASS_FLAGS(EProcessorExecutionFlags);\n\nUSTRUCT()\nstruct FProcessorAuxDataBase\n{\n\tGENERATED_BODY()\n};\n\nUSTRUCT(BlueprintType)\nstruct MASSENTITY_API FMassProcessingContext\n{\n\tGENERATED_BODY()\n\n\tTSharedPtr<FMassEntityManager> EntityManager;\n\t\n\tUPROPERTY()\n\tfloat DeltaSeconds = 0.f;\n\n\tUPROPERTY()\n\tFInstancedStruct AuxData;\n\n\t/** \n\t * If set to \"true\" the MassExecutor will flush commands at the end of given execution function. \n\t * If \"false\" the caller is responsible for manually flushing the commands.\n\t */\n\tUPROPERTY()\n\tbool bFlushCommandBuffer = true; \n\t\t\n\tTSharedPtr<FMassCommandBuffer> CommandBuffer;\n\t\n\tFMassProcessingContext() = default;\n\tFMassProcessingContext(FMassEntityManager& InEntityManager, const float InDeltaSeconds);\n\tFMassProcessingContext(TSharedPtr<FMassEntityManager>& InEntityManager, const float InDeltaSeconds);\n\t~FMassProcessingContext();\n};\n\n/** \n *  Runtime-usable array of MassProcessor copies\n */\nUSTRUCT()\nstruct MASSENTITY_API FMassRuntimePipeline\n{\n\tGENERATED_BODY()\n\nprivate:\n\tUPROPERTY()\n\tTArray<TObjectPtr<UMassProcessor>> Processors;\n\n\tEProcessorExecutionFlags ExecutionFlags = EProcessorExecutionFlags::None;\n\npublic:\n\texplicit FMassRuntimePipeline(EProcessorExecutionFlags WorldExecutionFlags = EProcessorExecutionFlags::None)\n\t\t: ExecutionFlags(WorldExecutionFlags)\n\t{}\n\n\tvoid Reset();\n\tvoid Initialize(UObject& Owner);\n\t\n\t/** Creates runtime copies of the given UMassProcessors collection. */\n\tvoid SetProcessors(TArray<UMassProcessor*>&& InProcessors);\n\n\t/** Creates runtime copies of UMassProcessors given in InProcessors input parameter, using InOwner as new UMassProcessors' outer. */\n\tvoid CreateFromArray(TConstArrayView<const UMassProcessor*> InProcessors, UObject& InOwner);\n\n\t/** Calls CreateFromArray and calls Initialize on all processors afterwards. */\n\tvoid InitializeFromArray(TConstArrayView<const UMassProcessor*> InProcessors, UObject& InOwner);\n\t\n\t/** Creates runtime instances of UMassProcessors for each processor class given via InProcessorClasses. \n\t *  The instances will be created with InOwner as outer. */\n\tvoid InitializeFromClassArray(TConstArrayView<TSubclassOf<UMassProcessor>> InProcessorClasses, UObject& InOwner);\n\n\t/** Creates a runtime instance of every processors in the given InProcessors array. If a processor of that class\n\t *  already exists in Processors array it gets overridden. Otherwise it gets added to the end of the collection.*/\n\tvoid AppendOrOverrideRuntimeProcessorCopies(TConstArrayView<const UMassProcessor*> InProcessors, UObject& InOwner);\n\n\t/** Creates a runtime instance of every processors in the given array if there's no processor of that class in Processors already.\n\t *  Call this function when adding processors to an already configured FMassRuntimePipeline instance. If you're creating \n\t *  one from scratch calling any of the InitializeFrom* methods will be more efficient (and will produce same results)\n\t *  or call AppendOrOverrideRuntimeProcessorCopies.*/\n\tvoid AppendUniqueRuntimeProcessorCopies(TConstArrayView<const UMassProcessor*> InProcessors, UObject& InOwner);\n\n\t/** Adds InProcessor to Processors without any additional checks */\n\tvoid AppendProcessor(UMassProcessor& Processor);\n\n\t/** Creates an instance of ProcessorClass and adds it to Processors without any additional checks */\n\tvoid AppendProcessor(TSubclassOf<UMassProcessor> ProcessorClass, UObject& InOwner);\n\n\tvoid RemoveProcessor(UMassProcessor& InProcessor);\n\n\t/** goes through Processor looking for a UMassCompositeProcessor instance which GroupName matches the one given as the parameter */\n\tUMassCompositeProcessor* FindTopLevelGroupByName(const FName GroupName);\n\n\tbool HasProcessorOfExactClass(TSubclassOf<UMassProcessor> InClass) const;\n\tbool IsEmpty() const { return Processors.IsEmpty();}\n\n\tint32 Num() const { return Processors.Num(); }\n\tTConstArrayView<TObjectPtr<UMassProcessor>> GetProcessors() const { return Processors; }\n\tTArrayView<TObjectPtr<UMassProcessor>> GetMutableProcessors() { return Processors; }\n\n\tMASSENTITY_API friend uint32 GetTypeHash(const FMassRuntimePipeline& Instance);\n};\n\nUENUM()\nenum class EMassProcessingPhase : uint8\n{\n\tPrePhysics,\n\tStartPhysics,\n\tDuringPhysics,\n\tEndPhysics,\n\tPostPhysics,\n\tFrameEnd,\n\tMAX,\n};\n\nstruct FMassProcessorOrderInfo\n{\n\tenum class EDependencyNodeType : uint8\n\t{\n\t\tInvalid,\n\t\tProcessor,\n\t\tGroupStart,\n\t\tGroupEnd\n\t};\n\n\tFName Name = TEXT(\"\");\n\tUMassProcessor* Processor = nullptr;\n\tEDependencyNodeType NodeType = EDependencyNodeType::Invalid;\n\tTArray<FName> Dependencies;\n\tint32 SequenceIndex = INDEX_NONE;\n};\n",
      "lines": 162
    },
    {
      "file_path": "MassEntity\\Public\\MassProcessor.h",
      "extension": ".h",
      "size_bytes": 14786,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"MassEntityManager.h\"\n#include \"MassProcessingTypes.h\"\n#include \"Async/TaskGraphInterfaces.h\"\n#include \"MassCommandBuffer.h\"\n#include \"MassProcessor.generated.h\"\n\n\nstruct FMassProcessingPhaseConfig;\nclass UMassCompositeProcessor;\nstruct FMassDebugger;\n\nenum class EProcessorCompletionStatus : uint8\n{\n\tInvalid,\n\tThreaded,\n\tPostponed,\n\tDone\n};\n\nUSTRUCT()\nstruct FMassProcessorExecutionOrder\n{\n\tGENERATED_BODY()\n\n\t/** Determines which processing group this processor will be placed in. Leaving it empty (\"None\") means \"top-most group for my ProcessingPhase\" */\n\tUPROPERTY(EditAnywhere, Category = Processor, config)\n\tFName ExecuteInGroup = FName();\n\n\tUPROPERTY(EditAnywhere, Category = Processor, config)\n\tTArray<FName> ExecuteBefore;\n\n\tUPROPERTY(EditAnywhere, Category = Processor, config)\n\tTArray<FName> ExecuteAfter;\n};\n\n\nUCLASS(abstract, EditInlineNew, CollapseCategories, config = Mass, defaultconfig, ConfigDoNotCheckDefaults)\nclass MASSENTITY_API UMassProcessor : public UObject\n{\n\tGENERATED_BODY()\npublic:\n\tUMassProcessor();\n\texplicit UMassProcessor(const FObjectInitializer& ObjectInitializer);\n\n\tbool IsInitialized() const;\n\t/** Called to initialize the processor. Override to perform custom steps. The super implementation has to be called. */\n\tvirtual void Initialize(UObject& Owner);\n\tvirtual FGraphEventRef DispatchProcessorTasks(const TSharedPtr<FMassEntityManager>& EntityManager, FMassExecutionContext& ExecutionContext, const FGraphEventArray& Prerequisites = FGraphEventArray());\n\n\tEProcessorExecutionFlags GetExecutionFlags() const;\n\n\t/** Whether this processor should execute according the CurrentExecutionFlags parameters */\n\tbool ShouldExecute(const EProcessorExecutionFlags CurrentExecutionFlags) const;\n\tvoid CallExecute(FMassEntityManager& EntityManager, FMassExecutionContext& Context);\n\n\t/** \n\t * Controls whether there can be multiple instances of a given class in a single FMassRuntimePipeline and during \n\t * dependency solving. \n\t */\n\tbool ShouldAllowMultipleInstances() const;\n\n\tvoid DebugOutputDescription(FOutputDevice& Ar) const;\n\tvirtual void DebugOutputDescription(FOutputDevice& Ar, int32 Indent) const;\n\tvirtual FString GetProcessorName() const;\n\t\n\t//----------------------------------------------------------------------//\n\t// Ordering functions \n\t//----------------------------------------------------------------------//\n\t/** Indicates whether this processor can ever be pruned while considered for a phase processing graph. A processor\n\t *  can get pruned if none of its registered queries interact with archetypes instantiated at the moment of graph\n\t *  building. This can also happen for special processors that don't register any queries - if that's the case override \n\t *  this function to return an appropriate value\n\t *  @param bRuntimeMode indicates whether the pruning is being done for game runtime (true) or editor-time presentation (false) */\n\tvirtual bool ShouldAllowQueryBasedPruning(const bool bRuntimeMode = true) const;\n\n\tvirtual EMassProcessingPhase GetProcessingPhase() const;\n\tvirtual void SetProcessingPhase(EMassProcessingPhase Phase);\n\tbool DoesRequireGameThreadExecution() const;\n\t\n\tconst FMassProcessorExecutionOrder& GetExecutionOrder() const;\n\n\t/** By default,  fetches requirements declared entity queries registered via RegisterQuery. Processors can override \n\t *\tthis function to supply additional requirements */\n\tvirtual void ExportRequirements(FMassExecutionRequirements& OutRequirements) const;\n\n\tconst FMassSubsystemRequirements& GetProcessorRequirements() const;\n\n\t/** Adds Query to RegisteredQueries list. Query is required to be a member variable of this processor. Not meeting\n\t *  this requirement will cause check failure and the query won't be registered. */\n\tvoid RegisterQuery(FMassEntityQuery& Query);\n\n\tvoid MarkAsDynamic();\n\tbool IsDynamic() const;\n\n\tbool ShouldAutoAddToGlobalList() const;\n#if WITH_EDITOR\n\tbool ShouldShowUpInSettings() const;\n#endif // WITH_EDITOR\n\n\t/** Sets bAutoRegisterWithProcessingPhases. Setting it to true will result in this processor class being always \n\t * instantiated to be automatically evaluated every frame. @see FMassProcessingPhaseManager\n\t * Note that calling this function is only valid on CDOs. Calling it on a regular instance will fail an ensure and \n\t * have no other effect, i.e. CDO's value won't change */\n\tvoid SetShouldAutoRegisterWithGlobalList(const bool bAutoRegister);\n\n\tvoid GetArchetypesMatchingOwnedQueries(const FMassEntityManager& EntityManager, TArray<FMassArchetypeHandle>& OutArchetype);\n\tbool DoesAnyArchetypeMatchOwnedQueries(const FMassEntityManager& EntityManager);\n\t\n#if CPUPROFILERTRACE_ENABLED\n\tFString StatId;\n#endif\n\t\nprotected:\n\tvirtual void ConfigureQueries() PURE_VIRTUAL(UMassProcessor::ConfigureQueries);\n\tvirtual void PostInitProperties() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) PURE_VIRTUAL(UMassProcessor::Execute);\n\nprotected:\n\t/** Configures when this given processor can be executed in relation to other processors and processing groups, within its processing phase. */\n\tUPROPERTY(EditDefaultsOnly, Category = Processor, config)\n\tFMassProcessorExecutionOrder ExecutionOrder;\n\n\t/** Processing phase this processor will be automatically run as part of. Needs to be set before the processor gets\n\t *  registered with MassProcessingPhaseManager, otherwise it will have no effect. This property is usually read via\n\t *  a given class's CDO, so it's recommended to set it in the constructor. */\n\tUPROPERTY(EditDefaultsOnly, Category = Processor, config)\n\tEMassProcessingPhase ProcessingPhase = EMassProcessingPhase::PrePhysics;\n\n\t/** Whether this processor should be executed on StandAlone or Server or Client */\n\tUPROPERTY(EditAnywhere, Category = \"Pipeline\", meta = (Bitmask, BitmaskEnum = \"/Script/MassEntity.EProcessorExecutionFlags\"), config)\n\tuint8 ExecutionFlags;\n\n\t/** Configures whether this processor should be automatically included in the global list of processors executed every tick (see ProcessingPhase and ExecutionOrder). */\n\tUPROPERTY(EditDefaultsOnly, Category = Processor, config)\n\tuint8 bAutoRegisterWithProcessingPhases : 1 = true;\n\n\t/** Meant as a class property, make sure to set it in subclass' constructor. Controls whether there can be multiple\n\t *  instances of a given class in a single FMassRuntimePipeline and during dependency solving. */\n\tuint8 bAllowMultipleInstances : 1 = false;\n\nprivate:\n\t/**\n\t * Gets set to true when an instance of the processor gets added to the phase processing as a \"dynamic processor\".\n\t * Once set it's never expected to be cleared out to `false` thus the private visibility of the member variable.\n\t * A \"dynamic\" processor is a one that has bAutoRegisterWithProcessingPhases == false, meaning it's not automatically\n\t * added to the processing graph. Additionally, making processors dynamic allows one to have multiple instances\n\t * of processors of the same class. \n\t * @see MarkAsDynamic()\n\t * @see IsDynamic()\n\t */\n\tuint8 bIsDynamic : 1 = false;\n\n\t/** Used to track whether Initialized has been called. */\n\tuint8 bInitialized : 1 = false;\n\nprotected:\n\tUPROPERTY(EditDefaultsOnly, Category = Processor, config)\n\tuint8 bRequiresGameThreadExecution : 1 = false;\n\n#if WITH_EDITORONLY_DATA\n\t/** Used to permanently remove a given processor class from PipeSetting's listing. Used primarily for test-time \n\t *  processor classes, but can also be used by project-specific code to prune the processor list. */\n\tUPROPERTY(config)\n\tuint8 bCanShowUpInSettings : 1 = true;\n#endif // WITH_EDITORONLY_DATA\n\n\tfriend UMassCompositeProcessor;\n\tfriend FMassDebugger;\n\n\t/** A query representing elements this processor is accessing in Execute function outside of query execution */\n\tFMassSubsystemRequirements ProcessorRequirements;\n\nprivate:\n\t/** Stores processor's queries registered via RegisterQuery. \n\t *  @note that it's safe to store pointers here since RegisterQuery does verify that a given registered query is \n\t *  a member variable of a given processor */\n\tTArray<FMassEntityQuery*> OwnedQueries;\n};\n\n\nUCLASS()\nclass MASSENTITY_API UMassCompositeProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\n\tfriend FMassDebugger;\npublic:\n\tstruct FDependencyNode\n\t{\n\t\tFName Name;\n\t\tUMassProcessor* Processor = nullptr;\n\t\tTArray<int32> Dependencies;\n#if WITH_MASSENTITY_DEBUG\n\t\tint32 SequenceIndex = INDEX_NONE;\n#endif // WITH_MASSENTITY_DEBUG\n\t};\n\npublic:\n\tUMassCompositeProcessor();\n\n\tvoid SetChildProcessors(TArray<UMassProcessor*>&& InProcessors);\n\n\tvirtual void Initialize(UObject& Owner) override;\n\tvirtual void DebugOutputDescription(FOutputDevice& Ar, int32 Indent = 0) const override;\n\tvirtual void SetProcessingPhase(EMassProcessingPhase Phase) override;\n\n\tvoid SetGroupName(FName NewName);\n\tFName GetGroupName() const;\n\n\tvirtual void SetProcessors(TArrayView<UMassProcessor*> InProcessorInstances, const TSharedPtr<FMassEntityManager>& EntityManager = nullptr);\n\n\t/** \n\t * Builds flat processing graph that's being used for multithreading execution of hosted processors.\n\t */\n\tvirtual void BuildFlatProcessingGraph(TConstArrayView<FMassProcessorOrderInfo> SortedProcessors);\n\n\t/**\n\t * Adds processors in InOutOrderedProcessors to ChildPipeline. \n\t * Note that this operation is non-destructive for the existing processors - the ones of classes found in InOutOrderedProcessors \n\t * will be retained and used instead of the instances provided via InOutOrderedProcessors. Respective entries in InOutOrderedProcessors\n\t * will be updated to reflect the reuse.\n\t * The described behavior however is available only for processors with bAllowMultipleInstances == false.\n\t */\n\tvoid UpdateProcessorsCollection(TArrayView<FMassProcessorOrderInfo> InOutOrderedProcessors, EProcessorExecutionFlags InWorldExecutionFlags = EProcessorExecutionFlags::None);\n\n\t/** adds SubProcessor to an appropriately named group. If RequestedGroupName == None then SubProcessor\n\t *  will be added directly to ChildPipeline. If not then the indicated group will be searched for in ChildPipeline \n\t *  and if it's missing it will be created and AddGroupedProcessor will be called recursively */\n\tvoid AddGroupedProcessor(FName RequestedGroupName, UMassProcessor& SubProcessor);\n\n\tvirtual FGraphEventRef DispatchProcessorTasks(const TSharedPtr<FMassEntityManager>& EntityManager, FMassExecutionContext& ExecutionContext, const FGraphEventArray& Prerequisites = FGraphEventArray()) override;\n\n\tbool IsEmpty() const;\n\n\tvirtual FString GetProcessorName() const override;\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\t/** RequestedGroupName can indicate a multi-level group name, like so: A.B.C\n\t *  We need to extract the highest-level group name ('A' in the example), and see if it already exists. \n\t *  If not, create it. \n\t *  @param RequestedGroupName name of the group for which we want to find or create the processor.\n\t *  @param OutRemainingGroupName contains the group name after cutting the high-level group. In the used example it\n\t *    will contain \"B.C\". This value is then used to recursively create subgroups */\n\tUMassCompositeProcessor* FindOrAddGroupProcessor(FName RequestedGroupName, FString* OutRemainingGroupName = nullptr);\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, Category=Mass)\n\tFMassRuntimePipeline ChildPipeline;\n\n\t/** Group name that will be used when resolving processor dependencies and grouping */\n\tUPROPERTY()\n\tFName GroupName;\n\n\tTArray<FDependencyNode> FlatProcessingGraph;\n\n\tstruct FProcessorCompletion\n\t{\n\t\tFGraphEventRef CompletionEvent;\n\t\tEProcessorCompletionStatus Status = EProcessorCompletionStatus::Invalid;\n\n\t\tbool IsDone() const \n\t\t{\n\t\t\treturn Status == EProcessorCompletionStatus::Done || (CompletionEvent.IsValid() && CompletionEvent->IsComplete());\n\t\t}\n\n\t\tvoid Wait()\n\t\t{\n\t\t\tif (CompletionEvent.IsValid())\n\t\t\t{\n\t\t\t\tCompletionEvent->Wait();\n\t\t\t}\n\t\t}\n\t};\n\tTArray<FProcessorCompletion> CompletionStatus;\n\n\t//-----------------------------------------------------------------------------\n\t// DEPRECATED\n\t//-----------------------------------------------------------------------------\npublic:\n\tUE_DEPRECATED(5.3, \"Populate is deprecated. Please use UpdateProcessorsCollection instead.\")\n\tvoid Populate(TConstArrayView<FMassProcessorOrderInfo> OrderedProcessors);\n};\n\n\n//-----------------------------------------------------------------------------\n// UMassProcessor inlines\n//-----------------------------------------------------------------------------\ninline bool UMassProcessor::IsInitialized() const\n{\n\treturn bInitialized;\n}\n\ninline EProcessorExecutionFlags UMassProcessor::GetExecutionFlags() const\n{\n\treturn static_cast<EProcessorExecutionFlags>(ExecutionFlags);\n}\n\ninline bool UMassProcessor::ShouldExecute(const EProcessorExecutionFlags CurrentExecutionFlags) const\n{\n\treturn (GetExecutionFlags() & CurrentExecutionFlags) != EProcessorExecutionFlags::None;\n}\n\ninline bool UMassProcessor::ShouldAllowMultipleInstances() const\n{\n\treturn bAllowMultipleInstances;\n}\n\ninline void UMassProcessor::DebugOutputDescription(FOutputDevice& Ar) const\n{\n\tDebugOutputDescription(Ar, 0);\n}\n\ninline bool UMassProcessor::DoesRequireGameThreadExecution() const\n{\n\treturn bRequiresGameThreadExecution;\n}\n\t\ninline const FMassProcessorExecutionOrder& UMassProcessor::GetExecutionOrder() const\n{\n\treturn ExecutionOrder;\n}\n\ninline const FMassSubsystemRequirements& UMassProcessor::GetProcessorRequirements() const\n{\n\treturn ProcessorRequirements;\n}\n\ninline void UMassProcessor::MarkAsDynamic()\n{\n\tbIsDynamic = true;\n}\n\ninline bool UMassProcessor::IsDynamic() const\n{\n\treturn bIsDynamic != 0;\n}\n\ninline bool UMassProcessor::ShouldAutoAddToGlobalList() const\n{\n\treturn bAutoRegisterWithProcessingPhases;\n}\n\n#if WITH_EDITOR\ninline bool UMassProcessor::ShouldShowUpInSettings() const\n{\n\treturn ShouldAutoAddToGlobalList() || bCanShowUpInSettings;\n}\n#endif // WITH_EDITOR\n\n//-----------------------------------------------------------------------------\n// UMassCompositeProcessor inlines\n//-----------------------------------------------------------------------------\ninline FName UMassCompositeProcessor::GetGroupName() const\n{\n\treturn GroupName;\n}\n\ninline bool UMassCompositeProcessor::IsEmpty() const\n{\n\treturn ChildPipeline.IsEmpty();\n}\n",
      "lines": 369
    },
    {
      "file_path": "MassEntity\\Public\\MassProcessorDependencySolver.h",
      "extension": ".h",
      "size_bytes": 7711,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessingTypes.h\"\n#include \"MassEntityTypes.h\"\n#include \"MassArchetypeTypes.h\"\n#include \"Containers/StaticArray.h\"\n\n\nclass UMassProcessor;\n\nnamespace EMassAccessOperation\n{\n\tconstexpr uint32 Read = 0;\n\tconstexpr uint32 Write = 1;\n\tconstexpr uint32 MAX = 2;\n};\n\ntemplate<typename T>\nstruct TMassExecutionAccess\n{\n\tT Read;\n\tT Write;\n\n\tT& operator[](const uint32 OpIndex)\n\t{\n\t\tcheck(OpIndex <= EMassAccessOperation::MAX);\n\t\treturn OpIndex == EMassAccessOperation::Read ? Read : Write;\n\t}\n\n\tconst T& operator[](const uint32 OpIndex) const\n\t{\n\t\tcheck(OpIndex <= EMassAccessOperation::MAX);\n\t\treturn OpIndex == EMassAccessOperation::Read ? Read : Write;\n\t}\n\n\tTConstArrayView<T> AsArrayView() const { return MakeArrayView(&Read, 2); }\n\n\tbool IsEmpty() const { return Read.IsEmpty() && Write.IsEmpty(); }\n};\n\n/** \n * TMassExecutionAccess specialization for FMassConstSharedFragmentBitSet to enforce lack of access (not needed) and\n * no \"Write\" component (conceptually doesn't make sense).\n */\ntemplate<>\nstruct TMassExecutionAccess<FMassConstSharedFragmentBitSet>\n{\n\tFMassConstSharedFragmentBitSet Read;\n\tTConstArrayView<FMassConstSharedFragmentBitSet> AsArrayView() const \n\t{ \n\t\treturn MakeArrayView(&Read, 1); \n\t}\n\tbool IsEmpty() const \n\t{ \n\t\treturn Read.IsEmpty(); \n\t}\n};\n\nstruct MASSENTITY_API FMassExecutionRequirements\n{\n\tvoid Append(const FMassExecutionRequirements& Other);\n\tvoid CountResourcesUsed();\n\tint32 GetTotalBitsUsedCount();\n\tbool IsEmpty() const;\n\tFMassArchetypeCompositionDescriptor AsCompositionDescriptor() const;\n\n\tTMassExecutionAccess<FMassFragmentBitSet> Fragments;\n\tTMassExecutionAccess<FMassChunkFragmentBitSet> ChunkFragments;\n\tTMassExecutionAccess<FMassSharedFragmentBitSet> SharedFragments;\n\tTMassExecutionAccess<FMassConstSharedFragmentBitSet> ConstSharedFragments;\n\tTMassExecutionAccess<FMassExternalSubsystemBitSet> RequiredSubsystems;\n\tFMassTagBitSet RequiredAllTags;\n\tFMassTagBitSet RequiredAnyTags;\n\tFMassTagBitSet RequiredNoneTags;\n\tint32 ResourcesUsedCount = INDEX_NONE;\n};\n\nstruct FMassProcessorDependencySolver\n{\nprivate:\n\tstruct FNode\n\t{\n\t\tFNode(const FName InName, UMassProcessor* InProcessor, const int32 InNodeIndex = INDEX_NONE) \n\t\t\t: Name(InName), Processor(InProcessor), NodeIndex(InNodeIndex)\n\t\t{}\n\n\t\tbool IsGroup() const { return Processor == nullptr; }\n\t\tvoid IncreaseWaitingNodesCount(TArrayView<FNode> InAllNodes);\n\n\t\tFName Name = TEXT(\"\");\n\t\tUMassProcessor* Processor = nullptr;\n\t\tTArray<int32> OriginalDependencies;\n\t\tTArray<int32> TransientDependencies;\n\t\tTArray<FName> ExecuteBefore;\n\t\tTArray<FName> ExecuteAfter;\n\t\tFMassExecutionRequirements Requirements;\n\t\tint32 NodeIndex = INDEX_NONE;\n\t\t/** indicates how often given node can be found in dependencies sequence for other nodes  */\n\t\tint32 TotalWaitingNodes = 0;\n\t\t/** \n\t\t * indicates how deep within dependencies graph this give node is, or in other words, what's the longest sequence \n\t\t * from this node to a dependency-less \"parent\" node \n\t\t */\n\t\tint32 SequencePositionIndex = 0;\n\t\tTArray<int32> SubNodeIndices;\n\t\tTArray<FMassArchetypeHandle> ValidArchetypes;\n\t};\n\n\tstruct FResourceUsage\n\t{\n\t\tFResourceUsage(const TArray<FNode>& InAllNodes);\n\n\t\tbool CanAccessRequirements(const FMassExecutionRequirements& TestedRequirements, const TArray<FMassArchetypeHandle>& InArchetypes) const;\n\t\tvoid SubmitNode(const int32 NodeIndex, FNode& InOutNode);\n\n\tprivate:\n\t\tstruct FResourceUsers\n\t\t{\n\t\t\tTArray<int32> Users;\n\t\t};\n\t\t\n\t\tstruct FResourceAccess\n\t\t{\n\t\t\tTArray<FResourceUsers> Access;\n\t\t};\n\t\t\n\t\tFMassExecutionRequirements Requirements;\n\t\tTMassExecutionAccess<FResourceAccess> FragmentsAccess;\n\t\tTMassExecutionAccess<FResourceAccess> ChunkFragmentsAccess;\n\t\tTMassExecutionAccess<FResourceAccess> SharedFragmentsAccess;\n\t\tTMassExecutionAccess<FResourceAccess> RequiredSubsystemsAccess;\n\t\tTConstArrayView<FNode> AllNodesView;\n\n\t\ttemplate<typename TBitSet>\n\t\tvoid HandleElementType(TMassExecutionAccess<FResourceAccess>& ElementAccess\n\t\t\t, const TMassExecutionAccess<TBitSet>& TestedRequirements, FMassProcessorDependencySolver::FNode& InOutNode, const int32 NodeIndex);\n\n\t\ttemplate<typename TBitSet>\n\t\tstatic bool CanAccess(const TMassExecutionAccess<TBitSet>& StoredElements, const TMassExecutionAccess<TBitSet>& TestedElements);\n\n\t\t/** Determines whether any of the Elements' (i.e. Fragment, Tag,...) users operate on any of the archetypes given via InArchetypes */\n\t\tbool HasArchetypeConflict(TMassExecutionAccess<FResourceAccess> ElementAccess, const TArray<FMassArchetypeHandle>& InArchetypes) const;\n\t};\n\npublic:\n\t/** Optionally returned by ResolveDependencies and contains information about processors that have been pruned and \n\t *  other potentially useful bits. To be used in a transient fashion. */\n\tstruct FResult\n\t{\n\t\tFString DependencyGraphFileName;\n\t\tTArray<TSubclassOf<UMassProcessor>> PrunedProcessorClasses;\n\t\tint32 MaxSequenceLength = 0;\n\t\tuint32 ArchetypeDataVersion = 0;\n\n\t\tvoid Reset()\n\t\t{\n\t\t\tPrunedProcessorClasses.Reset();\n\t\t\tMaxSequenceLength = 0;\n\t\t\tArchetypeDataVersion = 0;\n\t\t}\n\t};\n\n\tMASSENTITY_API FMassProcessorDependencySolver(TArrayView<UMassProcessor* const> InProcessors, const bool bIsGameRuntime = true);\n\tMASSENTITY_API void ResolveDependencies(TArray<FMassProcessorOrderInfo>& OutResult, TSharedPtr<FMassEntityManager> EntityManager = nullptr, FResult* InOutOptionalResult = nullptr);\n\n\tMASSENTITY_API static void CreateSubGroupNames(FName InGroupName, TArray<FString>& SubGroupNames);\n\n\t/** Determines whether the dependency solving that produced InResult will produce different results if run with a given EntityManager */\n\tstatic bool IsResultUpToDate(const FResult& InResult, TSharedPtr<FMassEntityManager> EntityManager);\n\n\tbool IsSolvingForSingleThread() const { return bSingleThreadTarget; }\n\nprotected:\n\t// note that internals are protected rather than private to support unit testing\n\n\t/**\n\t * Traverses InOutIndicesRemaining in search of the first RootNode's node that has no dependencies left. Once found \n\t * the node's index gets added to OutNodeIndices, removed from dependency lists from all other nodes and the function \n\t * quits.\n\t * @return 'true' if a dependency-less node has been found and added to OutNodeIndices; 'false' otherwise.\n\t */\n\tbool PerformSolverStep(FResourceUsage& ResourceUsage, TArray<int32>& InOutIndicesRemaining, TArray<int32>& OutNodeIndices);\n\t\n\tint32 CreateNodes(UMassProcessor& Processor);\n\tvoid BuildDependencies();\n\tvoid Solve(TArray<FMassProcessorOrderInfo>& OutResult);\n\tvoid LogNode(const FNode& Node, int Indent = 0);\n\t\n\t// @todo due to fundamental change to how nodes are organized the graph generation needs reimplementation\n\t// friend struct FDumpGraphDependencyUtils;\n\t// void DumpGraph(FArchive& LogFile) const;\n\n\tTArrayView<UMassProcessor* const> Processors;\n\tbool bAnyCyclesDetected = false;\n\t/**\n\t * indicates whether we're generating processor order to be run in single- or multi-threaded environment (usually\n\t * this meas Dedicated Server vs Any other configuration). In Single-Threaded mode we can skip a bunch of expensive, \n\t * fine tunning tests.\n\t * @Note: currently the value depends on MASS_DO_PARALLEL and there's no way to configure it otherwise, but there's \n\t * nothing inherently stopping us from letting users configure it.\n\t */\n\tconst bool bSingleThreadTarget = bool(!MASS_DO_PARALLEL);\n\tconst bool bGameRuntime = true;\n\tFString DependencyGraphFileName;\n\tTArray<FNode> AllNodes;\n\tTMap<FName, int32> NodeIndexMap;\n};",
      "lines": 209
    },
    {
      "file_path": "MassEntity\\Public\\MassRequirementAccessDetector.h",
      "extension": ".h",
      "size_bytes": 2214,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessingTypes.h\"\n#if WITH_MASSENTITY_DEBUG\n#include \"Containers/ArrayView.h\"\n#include \"MassEntityQuery.h\"\n#include \"Misc/MTAccessDetector.h\"\n\nstruct MASSENTITY_API FMassRequirementAccessDetector\n{\n\tvoid Initialize();\n\tvoid RequireAccess(const FMassEntityQuery& Query);\n\tvoid ReleaseAccess(const FMassEntityQuery& Query);\n\nprivate:\n\tusing FDetectorMethod = bool (FRWAccessDetector::*)() const;\n\ttemplate<typename TBitSet>\n\tvoid Operation(const TBitSet& BitSet, FDetectorMethod Op)\n\t{\n\t\tTArray<const UStruct*> Types;\n\t\tBitSet.ExportTypes(Types);\n\t\tfor (const UStruct* Type : Types)\n\t\t{\n\t\t\tif (TSharedRef<FRWAccessDetector>* Detector = Detectors.Find(Type))\n\t\t\t{\n\t\t\t\tFRWAccessDetector& DetectorRef = Detector->Get();\n\t\t\t\t(DetectorRef.*Op)();\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid Aquire(TConstArrayView<FMassFragmentRequirementDescription> Requirements)\n\t{\n\t\tfor (const FMassFragmentRequirementDescription& Req : Requirements)\n\t\t{\n\t\t\tif (Req.Presence != EMassFragmentPresence::None)\n\t\t\t{\n\t\t\t\tif (Req.AccessMode == EMassFragmentAccess::ReadWrite)\n\t\t\t\t{\n\t\t\t\t\tDetectors.Find(Req.StructType)->Get().AcquireWriteAccess();\n\t\t\t\t}\n\t\t\t\telse if (Req.AccessMode == EMassFragmentAccess::ReadOnly)\n\t\t\t\t{\n\t\t\t\t\tDetectors.Find(Req.StructType)->Get().AcquireReadAccess();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid Release(TConstArrayView<FMassFragmentRequirementDescription> Requirements)\n\t{\n\t\tfor (const FMassFragmentRequirementDescription& Req : Requirements)\n\t\t{\n\t\t\tif (Req.Presence != EMassFragmentPresence::None)\n\t\t\t{\n\t\t\t\tif (Req.AccessMode == EMassFragmentAccess::ReadWrite)\n\t\t\t\t{\n\t\t\t\t\tDetectors.Find(Req.StructType)->Get().ReleaseWriteAccess();\n\t\t\t\t}\n\t\t\t\telse if (Req.AccessMode == EMassFragmentAccess::ReadOnly)\n\t\t\t\t{\n\t\t\t\t\tDetectors.Find(Req.StructType)->Get().ReleaseReadAccess();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @Note the function is not thread-safe and meant to be only called internally on game thread (see FMassRequirementAccessDetector::Initialize) */\n\tvoid AddDetectors(const FStructTracker& StructTracker);\n\n\tTMap<const UStruct*, TSharedRef<FRWAccessDetector>> Detectors;\n};\n#endif // WITH_MASSENTITY_DEBUG",
      "lines": 75
    },
    {
      "file_path": "MassEntity\\Public\\MassRequirements.h",
      "extension": ".h",
      "size_bytes": 22624,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassRequirements.generated.h\"\n\nstruct FMassDebugger;\nstruct FMassArchetypeHandle;\nstruct FMassExecutionRequirements;\nstruct FMassRequirementAccessDetector;\n\nUENUM()\nenum class EMassFragmentAccess : uint8\n{\n\t/** no binding required */\n\tNone, \n\n\t/** We want to read the data for the fragment */\n\tReadOnly,\n\n\t/** We want to read and write the data for the fragment */\n\tReadWrite,\n\n\tMAX\n};\n\nUENUM()\nenum class EMassFragmentPresence : uint8\n{\n\t/** All of the required fragments must be present */\n\tAll,\n\n\t/** One of the required fragments must be present */\n\tAny,\n\n\t/** None of the required fragments can be present */\n\tNone,\n\n\t/** If fragment is present we'll use it, but it missing stop processing of a given archetype */\n\tOptional,\n\n\tMAX\n};\n\n\nstruct MASSENTITY_API FMassFragmentRequirementDescription\n{\n\tconst UScriptStruct* StructType = nullptr;\n\tEMassFragmentAccess AccessMode = EMassFragmentAccess::None;\n\tEMassFragmentPresence Presence = EMassFragmentPresence::Optional;\n\npublic:\n\tFMassFragmentRequirementDescription(){}\n\tFMassFragmentRequirementDescription(const UScriptStruct* InStruct, const EMassFragmentAccess InAccessMode, const EMassFragmentPresence InPresence)\n\t\t: StructType(InStruct)\n\t\t, AccessMode(InAccessMode)\n\t\t, Presence(InPresence)\n\t{\n\t\tcheck(InStruct);\n\t}\n\n\tbool RequiresBinding() const { return (AccessMode != EMassFragmentAccess::None); }\n\tbool IsOptional() const { return (Presence == EMassFragmentPresence::Optional || Presence == EMassFragmentPresence::Any); }\n\n\t/** these functions are used for sorting. See FScriptStructSortOperator */\n\tint32 GetStructureSize() const\n\t{\n\t\treturn StructType->GetStructureSize();\n\t}\n\n\tFName GetFName() const\n\t{\n\t\treturn StructType->GetFName();\n\t}\n};\n\n/**\n *  FMassSubsystemRequirements is a structure that declares runtime subsystem access type given calculations require.\n */\nUSTRUCT()\nstruct MASSENTITY_API FMassSubsystemRequirements\n{\n\tGENERATED_BODY()\n\n\tfriend FMassDebugger;\n\tfriend FMassRequirementAccessDetector;\n\n\ttemplate<typename T>\n\tFMassSubsystemRequirements& AddSubsystemRequirement(const EMassFragmentAccess AccessMode)\n\t{\n\t\tcheck(AccessMode != EMassFragmentAccess::None && AccessMode != EMassFragmentAccess::MAX);\n\n\t\t// Compilation errors here like: 'GameThreadOnly': is not a member of 'TMassExternalSubsystemTraits<USmartObjectSubsystem>\n\t\t// indicate that there is a missing header that defines the subsystem's trait or that you need to define one for that subsystem type.\n\t\t// @see \"MassExternalSubsystemTraits.h\" for details\n\n\t\tswitch (AccessMode)\n\t\t{\n\t\tcase EMassFragmentAccess::ReadOnly:\n\t\t\tRequiredConstSubsystems.Add<T>();\n\t\t\tbRequiresGameThreadExecution |= TMassExternalSubsystemTraits<T>::GameThreadOnly;\n\t\t\tbreak;\n\t\tcase EMassFragmentAccess::ReadWrite:\n\t\t\tRequiredMutableSubsystems.Add<T>();\n\t\t\tbRequiresGameThreadExecution |= TMassExternalSubsystemTraits<T>::GameThreadOnly;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcheck(false);\n\t\t}\n\n\t\treturn *this;\n\t}\n\n\tFMassSubsystemRequirements& AddSubsystemRequirement(const TSubclassOf<USubsystem> SubsystemClass, const EMassFragmentAccess AccessMode, const bool bGameThreadOnly = true)\n\t{\n\t\tcheck(AccessMode != EMassFragmentAccess::None && AccessMode != EMassFragmentAccess::MAX);\n\n\t\tswitch (AccessMode)\n\t\t{\n\t\tcase EMassFragmentAccess::ReadOnly:\n\t\t\tRequiredConstSubsystems.Add(**SubsystemClass);\n\t\t\tbRequiresGameThreadExecution |= bGameThreadOnly;\n\t\t\tbreak;\n\t\tcase EMassFragmentAccess::ReadWrite:\n\t\t\tRequiredMutableSubsystems.Add(**SubsystemClass);\n\t\t\tbRequiresGameThreadExecution |= bGameThreadOnly;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcheck(false);\n\t\t}\n\n\t\treturn *this;\n\t}\n\n\tvoid Reset();\n\n\tconst FMassExternalSubsystemBitSet& GetRequiredConstSubsystems() const { return RequiredConstSubsystems; }\n\tconst FMassExternalSubsystemBitSet& GetRequiredMutableSubsystems() const { return RequiredMutableSubsystems; }\n\tbool IsEmpty() const { return RequiredConstSubsystems.IsEmpty() && RequiredMutableSubsystems.IsEmpty(); }\n\n\tbool DoesRequireGameThreadExecution() const { return bRequiresGameThreadExecution; }\n\tvoid ExportRequirements(FMassExecutionRequirements& OutRequirements) const;\n\nprotected:\n\tFMassExternalSubsystemBitSet RequiredConstSubsystems;\n\tFMassExternalSubsystemBitSet RequiredMutableSubsystems;\n\nprivate:\n\tbool bRequiresGameThreadExecution = false;\n};\n\n/** \n *  FMassFragmentRequirements is a structure that describes properties required of an archetype that's a subject of calculations.\n */\nUSTRUCT()\nstruct MASSENTITY_API FMassFragmentRequirements\n{\n\tGENERATED_BODY()\n\n\tfriend FMassDebugger;\n\tfriend FMassRequirementAccessDetector;\n\npublic:\n\tFMassFragmentRequirements(){}\n\tFMassFragmentRequirements(std::initializer_list<UScriptStruct*> InitList);\n\tFMassFragmentRequirements(TConstArrayView<const UScriptStruct*> InitList);\n\n\tFMassFragmentRequirements& AddRequirement(const UScriptStruct* FragmentType, const EMassFragmentAccess AccessMode, const EMassFragmentPresence Presence = EMassFragmentPresence::All)\n\t{\n\t\tcheckf(FragmentRequirements.FindByPredicate([FragmentType](const FMassFragmentRequirementDescription& Item){ return Item.StructType == FragmentType; }) == nullptr\n\t\t\t, TEXT(\"Duplicated requirements are not supported. %s already present\"), *GetNameSafe(FragmentType));\n\t\t\n\t\tif (Presence != EMassFragmentPresence::None)\n\t\t{\n\t\t\tFragmentRequirements.Emplace(FragmentType, AccessMode, Presence);\n\t\t}\n\n\t\tswitch (Presence)\n\t\t{\n\t\tcase EMassFragmentPresence::All:\n\t\t\tRequiredAllFragments.Add(*FragmentType);\n\t\t\tbreak;\n\t\tcase EMassFragmentPresence::Any:\n\t\t\tRequiredAnyFragments.Add(*FragmentType);\n\t\t\tbreak;\n\t\tcase EMassFragmentPresence::Optional:\n\t\t\tRequiredOptionalFragments.Add(*FragmentType);\n\t\t\tbreak;\n\t\tcase EMassFragmentPresence::None:\n\t\t\tRequiredNoneFragments.Add(*FragmentType);\n\t\t\tbreak;\n\t\t}\n\t\t// force recaching the next time this query is used or the following CacheArchetypes call.\n\t\tIncrementChangeCounter();\n\t\treturn *this;\n\t}\n\n\t/** FMassFragmentRequirements ref returned for chaining */\n\ttemplate<typename T>\n\tFMassFragmentRequirements& AddRequirement(const EMassFragmentAccess AccessMode, const EMassFragmentPresence Presence = EMassFragmentPresence::All)\n\t{\n\t\tcheckf(FragmentRequirements.FindByPredicate([](const FMassFragmentRequirementDescription& Item) { return Item.StructType == T::StaticStruct(); }) == nullptr\n\t\t\t, TEXT(\"Duplicated requirements are not supported. %s already present\"), *T::StaticStruct()->GetName());\n\n\t\tstatic_assert(TIsDerivedFrom<T, FMassFragment>::IsDerived, \"Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.\");\n\t\t\n\t\tif (Presence != EMassFragmentPresence::None)\n\t\t{\n\t\t\tFragmentRequirements.Emplace(T::StaticStruct(), AccessMode, Presence);\n\t\t}\n\t\t\n\t\tswitch (Presence)\n\t\t{\n\t\tcase EMassFragmentPresence::All:\n\t\t\tRequiredAllFragments.Add<T>();\n\t\t\tbreak;\n\t\tcase EMassFragmentPresence::Any:\n\t\t\tRequiredAnyFragments.Add<T>();\n\t\t\tbreak;\n\t\tcase EMassFragmentPresence::Optional:\n\t\t\tRequiredOptionalFragments.Add<T>();\n\t\t\tbreak;\n\t\tcase EMassFragmentPresence::None:\n\t\t\tRequiredNoneFragments.Add<T>();\n\t\t\tbreak;\n\t\t}\n\t\t// force recaching the next time this query is used or the following CacheArchetypes call.\n\t\tIncrementChangeCounter();\n\t\treturn *this;\n\t}\n\n\tvoid AddTagRequirement(const UScriptStruct& TagType, const EMassFragmentPresence Presence)\n\t{\n\t\tcheckf(int(Presence) != int(EMassFragmentPresence::MAX), TEXT(\"MAX presence is not a valid value for AddTagRequirement\"));\n\t\tswitch (Presence)\n\t\t{\n\t\tcase EMassFragmentPresence::All:\n\t\t\tRequiredAllTags.Add(TagType);\n\t\t\tbreak;\n\t\tcase EMassFragmentPresence::Any:\n\t\t\tRequiredAnyTags.Add(TagType);\n\t\t\tbreak;\n\t\tcase EMassFragmentPresence::None:\n\t\t\tRequiredNoneTags.Add(TagType);\n\t\t\tbreak;\n\t\tcase EMassFragmentPresence::Optional:\n\t\t\tRequiredOptionalTags.Add(TagType);\n\t\t\tbreak;\n\t\t}\n\t\tIncrementChangeCounter();\n\t}\n\n\ttemplate<typename T>\n\tFMassFragmentRequirements& AddTagRequirement(const EMassFragmentPresence Presence)\n\t{\n\t\tcheckf(int(Presence) != int(EMassFragmentPresence::MAX), TEXT(\"MAX presence is not a valid value for AddTagRequirement\"));\n\t\tstatic_assert(TIsDerivedFrom<T, FMassTag>::IsDerived, \"Given struct doesn't represent a valid tag type. Make sure to inherit from FMassFragment or one of its child-types.\");\n\t\tswitch (Presence)\n\t\t{\n\t\t\tcase EMassFragmentPresence::All:\n\t\t\t\tRequiredAllTags.Add<T>();\n\t\t\t\tbreak;\n\t\t\tcase EMassFragmentPresence::Any:\n\t\t\t\tRequiredAnyTags.Add<T>();\n\t\t\t\tbreak;\n\t\t\tcase EMassFragmentPresence::None:\n\t\t\t\tRequiredNoneTags.Add<T>();\n\t\t\t\tbreak;\n\t\t\tcase EMassFragmentPresence::Optional:\n\t\t\t\tRequiredOptionalTags.Add<T>();\n\t\t\t\tbreak;\n\t\t}\n\t\tIncrementChangeCounter();\n\t\treturn *this;\n\t}\n\n\t/** actual implementation in specializations */\n\ttemplate<EMassFragmentPresence Presence> \n\tFMassFragmentRequirements& AddTagRequirements(const FMassTagBitSet& TagBitSet)\n\t{\n\t\tstatic_assert(Presence == EMassFragmentPresence::None || Presence == EMassFragmentPresence::All || Presence == EMassFragmentPresence::Any\n\t\t\t, \"The only valid values for AddTagRequirements are All, Any and None\");\n\t\treturn *this;\n\t}\n\n\t/** Clears given tags out of all collected requirements, including negative ones */\n\tFMassFragmentRequirements& ClearTagRequirements(const FMassTagBitSet& TagsToRemoveBitSet);\n\n\ttemplate<typename T>\n\tFMassFragmentRequirements& AddChunkRequirement(const EMassFragmentAccess AccessMode, const EMassFragmentPresence Presence = EMassFragmentPresence::All)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassChunkFragment>::IsDerived, \"Given struct doesn't represent a valid chunk fragment type. Make sure to inherit from FMassChunkFragment or one of its child-types.\");\n\t\tcheckf(ChunkFragmentRequirements.FindByPredicate([](const FMassFragmentRequirementDescription& Item) { return Item.StructType == T::StaticStruct(); }) == nullptr\n\t\t\t, TEXT(\"Duplicated requirements are not supported. %s already present\"), *T::StaticStruct()->GetName());\n\t\tcheckf(Presence != EMassFragmentPresence::Any, TEXT(\"\\'Any\\' is not a valid Presence value for AddChunkRequirement.\"));\n\n\t\tswitch (Presence)\n\t\t{\n\t\t\tcase EMassFragmentPresence::All:\n\t\t\t\tRequiredAllChunkFragments.Add<T>();\n\t\t\t\tChunkFragmentRequirements.Emplace(T::StaticStruct(), AccessMode, Presence);\n\t\t\t\tbreak;\n\t\t\tcase EMassFragmentPresence::Optional:\n\t\t\t\tRequiredOptionalChunkFragments.Add<T>();\n\t\t\t\tChunkFragmentRequirements.Emplace(T::StaticStruct(), AccessMode, Presence);\n\t\t\t\tbreak;\n\t\t\tcase EMassFragmentPresence::None:\n\t\t\t\tRequiredNoneChunkFragments.Add<T>();\n\t\t\t\tbreak;\n\t\t}\n\t\tIncrementChangeCounter();\n\t\treturn *this;\n\t}\n\n\ttemplate<typename T>\n\tFMassFragmentRequirements& AddConstSharedRequirement(const EMassFragmentPresence Presence = EMassFragmentPresence::All)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassConstSharedFragment>::IsDerived, \"Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.\");\n\t\tcheckf(ConstSharedFragmentRequirements.FindByPredicate([](const FMassFragmentRequirementDescription& Item) { return Item.StructType == T::StaticStruct(); }) == nullptr\n\t\t\t, TEXT(\"Duplicated requirements are not supported. %s already present\"), *T::StaticStruct()->GetName());\n\t\tcheckf(Presence != EMassFragmentPresence::Any, TEXT(\"\\'Any\\' is not a valid Presence value for AddConstSharedRequirement.\"));\n\n\t\tswitch (Presence)\n\t\t{\n\t\tcase EMassFragmentPresence::All:\n\t\t\tRequiredAllConstSharedFragments.Add<T>();\n\t\t\tConstSharedFragmentRequirements.Emplace(T::StaticStruct(), EMassFragmentAccess::ReadOnly, Presence);\n\t\t\tbreak;\n\t\tcase EMassFragmentPresence::Optional:\n\t\t\tRequiredOptionalConstSharedFragments.Add<T>();\n\t\t\tConstSharedFragmentRequirements.Emplace(T::StaticStruct(), EMassFragmentAccess::ReadOnly, Presence);\n\t\t\tbreak;\n\t\tcase EMassFragmentPresence::None:\n\t\t\tRequiredNoneConstSharedFragments.Add<T>();\n\t\t\tbreak;\n\t\t}\n\t\tIncrementChangeCounter();\n\t\treturn *this;\n\t}\n\n\tFMassFragmentRequirements& AddConstSharedRequirement(const UScriptStruct* FragmentType, const EMassFragmentPresence Presence = EMassFragmentPresence::All)\n\t{\n\t\tif (!ensureMsgf(FragmentType->IsChildOf(FMassConstSharedFragment::StaticStruct())\n\t\t\t, TEXT(\"Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.\")))\n\t\t{\n\t\t\treturn *this;\n\t\t}\n\n\t\tcheckf(ConstSharedFragmentRequirements.FindByPredicate([FragmentType](const FMassFragmentRequirementDescription& Item) { return Item.StructType == FragmentType; }) == nullptr\n\t\t\t, TEXT(\"Duplicated requirements are not supported. %s already present\"), *FragmentType->GetName());\n\t\tcheckf(Presence != EMassFragmentPresence::Any, TEXT(\"\\'Any\\' is not a valid Presence value for AddConstSharedRequirement.\"));\n\n\t\tswitch (Presence)\n\t\t{\n\t\tcase EMassFragmentPresence::All:\n\t\t\tRequiredAllConstSharedFragments.Add(*FragmentType);\n\t\t\tConstSharedFragmentRequirements.Emplace(FragmentType, EMassFragmentAccess::ReadOnly, Presence);\n\t\t\tbreak;\n\t\tcase EMassFragmentPresence::Optional:\n\t\t\tRequiredOptionalConstSharedFragments.Add(*FragmentType);\n\t\t\tConstSharedFragmentRequirements.Emplace(FragmentType, EMassFragmentAccess::ReadOnly, Presence);\n\t\t\tbreak;\n\t\tcase EMassFragmentPresence::None:\n\t\t\tRequiredNoneConstSharedFragments.Add(*FragmentType);\n\t\t\tbreak;\n\t\t}\n\t\tIncrementChangeCounter();\n\t\treturn *this;\n\t}\n\n\ttemplate<typename T>\n\tFMassFragmentRequirements& AddSharedRequirement(const EMassFragmentAccess AccessMode, const EMassFragmentPresence Presence = EMassFragmentPresence::All)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassSharedFragment>::IsDerived, \"Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.\");\n\t\tcheckf(SharedFragmentRequirements.FindByPredicate([](const FMassFragmentRequirementDescription& Item) { return Item.StructType == T::StaticStruct(); }) == nullptr\n\t\t\t, TEXT(\"Duplicated requirements are not supported. %s already present\"), *T::StaticStruct()->GetName());\n\t\tcheckf(Presence != EMassFragmentPresence::Any, TEXT(\"\\'Any\\' is not a valid Presence value for AddSharedRequirement.\"));\n\n\t\tswitch (Presence)\n\t\t{\n\t\tcase EMassFragmentPresence::All:\n\t\t\tRequiredAllSharedFragments.Add<T>();\n\t\t\tSharedFragmentRequirements.Emplace(T::StaticStruct(), AccessMode, Presence);\n\t\t\tif (AccessMode == EMassFragmentAccess::ReadWrite)\n\t\t\t{\n\t\t\t\tbRequiresGameThreadExecution |= TMassSharedFragmentTraits<T>::GameThreadOnly;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EMassFragmentPresence::Optional:\n\t\t\tRequiredOptionalSharedFragments.Add<T>();\n\t\t\tSharedFragmentRequirements.Emplace(T::StaticStruct(), AccessMode, Presence);\n\t\t\tif (AccessMode == EMassFragmentAccess::ReadWrite)\n\t\t\t{\n\t\t\t\tbRequiresGameThreadExecution |= TMassSharedFragmentTraits<T>::GameThreadOnly;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EMassFragmentPresence::None:\n\t\t\tRequiredNoneSharedFragments.Add<T>();\n\t\t\tbreak;\n\t\t}\n\t\tIncrementChangeCounter();\n\t\treturn *this;\n\t}\n\n\tvoid Reset();\n\n\t/** \n\t * The function validates requirements we make for queries. See the FMassFragmentRequirements struct description for details.\n\t * Even though the code of the function is non trivial the consecutive calls will be essentially free due to the result \n\t * being cached (note that the caching gets invalidated if the composition changes).\n\t * @return whether this query's requirements follow the rules.\n\t */\n\tbool CheckValidity() const;\n\n\tTConstArrayView<FMassFragmentRequirementDescription> GetFragmentRequirements() const { return FragmentRequirements; }\n\tTConstArrayView<FMassFragmentRequirementDescription> GetChunkFragmentRequirements() const { return ChunkFragmentRequirements; }\n\tTConstArrayView<FMassFragmentRequirementDescription> GetConstSharedFragmentRequirements() const { return ConstSharedFragmentRequirements; }\n\tTConstArrayView<FMassFragmentRequirementDescription> GetSharedFragmentRequirements() const { return SharedFragmentRequirements; }\n\tconst FMassFragmentBitSet& GetRequiredAllFragments() const { return RequiredAllFragments; }\n\tconst FMassFragmentBitSet& GetRequiredAnyFragments() const { return RequiredAnyFragments; }\n\tconst FMassFragmentBitSet& GetRequiredOptionalFragments() const { return RequiredOptionalFragments; }\n\tconst FMassFragmentBitSet& GetRequiredNoneFragments() const { return RequiredNoneFragments; }\n\tconst FMassTagBitSet& GetRequiredAllTags() const { return RequiredAllTags; }\n\tconst FMassTagBitSet& GetRequiredAnyTags() const { return RequiredAnyTags; }\n\tconst FMassTagBitSet& GetRequiredNoneTags() const { return RequiredNoneTags; }\n\tconst FMassTagBitSet& GetRequiredOptionalTags() const { return RequiredOptionalTags; }\n\tconst FMassChunkFragmentBitSet& GetRequiredAllChunkFragments() const { return RequiredAllChunkFragments; }\n\tconst FMassChunkFragmentBitSet& GetRequiredOptionalChunkFragments() const { return RequiredOptionalChunkFragments; }\n\tconst FMassChunkFragmentBitSet& GetRequiredNoneChunkFragments() const { return RequiredNoneChunkFragments; }\n\tconst FMassSharedFragmentBitSet& GetRequiredAllSharedFragments() const { return RequiredAllSharedFragments; }\n\tconst FMassSharedFragmentBitSet& GetRequiredOptionalSharedFragments() const { return RequiredOptionalSharedFragments; }\n\tconst FMassSharedFragmentBitSet& GetRequiredNoneSharedFragments() const { return RequiredNoneSharedFragments; }\n\tconst FMassConstSharedFragmentBitSet& GetRequiredAllConstSharedFragments() const { return RequiredAllConstSharedFragments; }\n\tconst FMassConstSharedFragmentBitSet& GetRequiredOptionalConstSharedFragments() const { return RequiredOptionalConstSharedFragments; }\n\tconst FMassConstSharedFragmentBitSet& GetRequiredNoneConstSharedFragments() const { return RequiredNoneConstSharedFragments; }\n\n\tbool IsEmpty() const;\n\tbool HasPositiveRequirements() const { return bHasPositiveRequirements; }\n\tbool HasNegativeRequirements() const { return bHasNegativeRequirements; }\n\tbool HasOptionalRequirements() const { return bHasOptionalRequirements; }\n\n\tbool DoesArchetypeMatchRequirements(const FMassArchetypeHandle& ArchetypeHandle) const;\n\tbool DoesArchetypeMatchRequirements(const FMassArchetypeCompositionDescriptor& ArchetypeComposition) const;\n\tbool DoesMatchAnyOptionals(const FMassArchetypeCompositionDescriptor& ArchetypeComposition) const;\n\n\tbool DoesRequireGameThreadExecution() const { return bRequiresGameThreadExecution; }\n\tvoid ExportRequirements(FMassExecutionRequirements& OutRequirements) const;\n\nprotected:\n\tvoid SortRequirements();\n\n\tFORCEINLINE void IncrementChangeCounter() \n\t{ \n\t\t++IncrementalChangesCount; \n\t\tbPropertiesCached = false;\n\t}\n\tvoid ConsumeIncrementalChangesCount() { IncrementalChangesCount = 0; }\n\tbool HasIncrementalChanges() const{ return IncrementalChangesCount > 0; }\n\nprotected:\n\tfriend FMassRequirementAccessDetector;\n\n\tTArray<FMassFragmentRequirementDescription> FragmentRequirements;\n\tTArray<FMassFragmentRequirementDescription> ChunkFragmentRequirements;\n\tTArray<FMassFragmentRequirementDescription> ConstSharedFragmentRequirements;\n\tTArray<FMassFragmentRequirementDescription> SharedFragmentRequirements;\n\tFMassTagBitSet RequiredAllTags;\n\tFMassTagBitSet RequiredAnyTags;\n\tFMassTagBitSet RequiredNoneTags;\n\t/**\n\t * note that optional tags have meaning only if there are no other strict requirements, i.e. everything is optional,\n\t * so we're looking for anything matching any of the optionals (both tags as well as fragments).\n\t */\n\tFMassTagBitSet RequiredOptionalTags;\n\tFMassFragmentBitSet RequiredAllFragments;\n\tFMassFragmentBitSet RequiredAnyFragments;\n\tFMassFragmentBitSet RequiredOptionalFragments;\n\tFMassFragmentBitSet RequiredNoneFragments;\n\tFMassChunkFragmentBitSet RequiredAllChunkFragments;\n\tFMassChunkFragmentBitSet RequiredOptionalChunkFragments;\n\tFMassChunkFragmentBitSet RequiredNoneChunkFragments;\n\tFMassSharedFragmentBitSet RequiredAllSharedFragments;\n\tFMassSharedFragmentBitSet RequiredOptionalSharedFragments;\n\tFMassSharedFragmentBitSet RequiredNoneSharedFragments;\n\tFMassConstSharedFragmentBitSet RequiredAllConstSharedFragments;\n\tFMassConstSharedFragmentBitSet RequiredOptionalConstSharedFragments;\n\tFMassConstSharedFragmentBitSet RequiredNoneConstSharedFragments;\n\nprivate:\n\tFORCEINLINE void CachePropreties() const;\n\tmutable uint16 bPropertiesCached : 1 = false;\n\tmutable uint16 bHasPositiveRequirements : 1 = false;\n\tmutable uint16 bHasNegativeRequirements : 1 = false;\n\t/** \n\t * Indicates that the requirements specify only optional elements, which means any composition having any one of \n\t * the optional elements will be accepted. Note that RequiredNone* requirements are handled separately and if specified \n\t * still need to be satisfied.\n\t */\n\t//mutable uint16 bOptionalsOnly : 1 = false;\n\tmutable uint16 bHasOptionalRequirements : 1 = false;\n\n\tuint16 IncrementalChangesCount = 0;\n\n\tbool bRequiresGameThreadExecution = false;\n};\n\ntemplate<>\nFORCEINLINE FMassFragmentRequirements& FMassFragmentRequirements::AddTagRequirements<EMassFragmentPresence::All>(const FMassTagBitSet& TagBitSet)\n{\n\tRequiredAllTags += TagBitSet;\n\t// force recaching the next time this query is used or the following CacheArchetypes call.\n\tIncrementChangeCounter();\n\treturn *this;\n}\n\ntemplate<>\nFORCEINLINE FMassFragmentRequirements& FMassFragmentRequirements::AddTagRequirements<EMassFragmentPresence::Any>(const FMassTagBitSet& TagBitSet)\n{\n\tRequiredAnyTags += TagBitSet;\n\t// force recaching the next time this query is used or the following CacheArchetypes call.\n\tIncrementChangeCounter();\n\treturn *this;\n}\n\ntemplate<>\nFORCEINLINE FMassFragmentRequirements& FMassFragmentRequirements::AddTagRequirements<EMassFragmentPresence::None>(const FMassTagBitSet& TagBitSet)\n{\n\tRequiredNoneTags += TagBitSet;\n\t// force recaching the next time this query is used or the following CacheArchetypes call.\n\tIncrementChangeCounter();\n\treturn *this;\n}\n\ntemplate<>\nFORCEINLINE FMassFragmentRequirements& FMassFragmentRequirements::AddTagRequirements<EMassFragmentPresence::Optional>(const FMassTagBitSet& TagBitSet)\n{\n\tRequiredOptionalTags += TagBitSet;\n\t// force recaching the next time this query is used or the following CacheArchetypes call.\n\tIncrementChangeCounter();\n\treturn *this;\n}\n",
      "lines": 542
    },
    {
      "file_path": "MassEntity\\Public\\MassSettings.h",
      "extension": ".h",
      "size_bytes": 977,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Engine/DeveloperSettings.h\"\n#include \"MassSettings.generated.h\"\n\n\n/** \n * A common parrent for Mass's per-module settings. Classes extending this class will automatically get registered \n * with- and show under Mass settings in Project Settings.\n */\nUCLASS(Abstract, config = Mass, defaultconfig, collapseCategories)\nclass MASSENTITY_API UMassModuleSettings : public UObject\n{\n\tGENERATED_BODY()\nprotected:\n\tvirtual void PostInitProperties() override;\n};\n\n\nUCLASS(config = Mass, defaultconfig, DisplayName = \"Mass\", AutoExpandCategories = \"Mass\")\nclass MASSENTITY_API UMassSettings : public UDeveloperSettings\n{\n\tGENERATED_BODY()\n\npublic:\n\tvoid RegisterModuleSettings(UMassModuleSettings& SettingsCDO);\n\npublic:\n\tUPROPERTY(VisibleAnywhere, Category = \"Mass\", NoClear, EditFixedSize, meta = (EditInline))\n\tTMap<FName, TObjectPtr<UMassModuleSettings>> ModuleSettings;\n};\n",
      "lines": 33
    },
    {
      "file_path": "MassEntity\\Public\\MassSubsystemAccess.h",
      "extension": ".h",
      "size_bytes": 7947,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassRequirements.h\"\n#include \"Subsystems/EngineSubsystem.h\"\n#include \"Subsystems/GameInstanceSubsystem.h\"\n#include \"Subsystems/LocalPlayerSubsystem.h\"\n#include \"Subsystems/WorldSubsystem.h\"\n#include \"Engine/LocalPlayer.h\"\n#include \"Engine/GameInstance.h\"\n\n#if WITH_EDITOR\n#include \"Editor.h\"\n#include \"EditorSubsystem.h\"\n#else\n#include \"Engine/Engine.h\"\n#endif // WITH_EDITOR\n\n\nstruct MASSENTITY_API FMassSubsystemAccess\n{\n\texplicit FMassSubsystemAccess(UWorld* InWorld = nullptr);\n\n\t//////////////////////////////////////////////////////////////////////////\n\t// Statically-typed subsystems\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tT* GetMutableSubsystem()\n\t{\n\t\tconst uint32 SystemIndex = FMassExternalSubsystemBitSet::GetTypeIndex<T>();\n\t\tif (ensure(MutableSubsystemsBitSet.IsBitSet(SystemIndex)))\n\t\t{\n\t\t\treturn GetSubsystemInternal<T>(SystemIndex);\n\t\t}\n\n\t\treturn nullptr;\n\t}\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tT& GetMutableSubsystemChecked()\n\t{\n\t\tT* InstancePtr = GetMutableSubsystem<T>();\n\t\tcheck(InstancePtr);\n\t\treturn *InstancePtr;\n\t}\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tconst T* GetSubsystem()\n\t{\n\t\tconst uint32 SystemIndex = FMassExternalSubsystemBitSet::GetTypeIndex<T>();\n\t\tif (ensure(ConstSubsystemsBitSet.IsBitSet(SystemIndex) || MutableSubsystemsBitSet.IsBitSet(SystemIndex)))\n\t\t{\n\t\t\treturn GetSubsystemInternal<T>(SystemIndex);\n\t\t}\n\t\treturn nullptr;\n\t}\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tconst T& GetSubsystemChecked()\n\t{\n\t\tconst T* InstancePtr = GetSubsystem<T>();\n\t\tcheck(InstancePtr);\n\t\treturn *InstancePtr;\n\t}\n\n\t//////////////////////////////////////////////////////////////////////////\n\t// UClass-provided subsystems\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tT* GetMutableSubsystem(const TSubclassOf<USubsystem> SubsystemClass)\n\t{\n\t\tconst uint32 SystemIndex = FMassExternalSubsystemBitSet::GetTypeIndex(**SubsystemClass);\n\t\tif (ensure(MutableSubsystemsBitSet.IsBitSet(SystemIndex)))\n\t\t{\n\t\t\treturn GetSubsystemInternal<T>(SystemIndex, SubsystemClass);\n\t\t}\n\n\t\treturn nullptr;\n\t}\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tT& GetMutableSubsystemChecked(const TSubclassOf<USubsystem> SubsystemClass)\n\t{\n\t\tT* InstancePtr = GetMutableSubsystem<T>(SubsystemClass);\n\t\tcheck(InstancePtr);\n\t\treturn *InstancePtr;\n\t}\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tconst T* GetSubsystem(const TSubclassOf<USubsystem> SubsystemClass)\n\t{\n\t\tconst uint32 SystemIndex = FMassExternalSubsystemBitSet::GetTypeIndex(**SubsystemClass);\n\t\tif (ensure(ConstSubsystemsBitSet.IsBitSet(SystemIndex) || MutableSubsystemsBitSet.IsBitSet(SystemIndex)))\n\t\t{\n\t\t\treturn GetSubsystemInternal<T>(SystemIndex, SubsystemClass);\n\t\t}\n\t\treturn nullptr;\n\t}\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tconst T& GetSubsystemChecked(const TSubclassOf<USubsystem> SubsystemClass)\n\t{\n\t\tconst T* InstancePtr = GetSubsystem<T>(SubsystemClass);\n\t\tcheck(InstancePtr);\n\t\treturn *InstancePtr;\n\t}\n\n\t//////////////////////////////////////////////////////////////////////////\n\t// remaining API\n\n\tbool CacheSubsystemRequirements(const FMassSubsystemRequirements& SubsystemRequirements);\n\tvoid SetSubsystemRequirements(const FMassSubsystemRequirements& SubsystemRequirements);\n\n\tvoid GetSubsystemRequirementBits(FMassExternalSubsystemBitSet& OutConstSubsystemsBitSet, FMassExternalSubsystemBitSet& OutMutableSubsystemsBitSet)\n\t{\n\t\tOutConstSubsystemsBitSet = ConstSubsystemsBitSet;\n\t\tOutMutableSubsystemsBitSet = MutableSubsystemsBitSet;\n\t}\n\n\tvoid SetSubsystemRequirementBits(const FMassExternalSubsystemBitSet& InConstSubsystemsBitSet, const FMassExternalSubsystemBitSet& InMutableSubsystemsBitSet)\n\t{\n\t\tConstSubsystemsBitSet = InConstSubsystemsBitSet;\n\t\tMutableSubsystemsBitSet = InMutableSubsystemsBitSet;\n\t}\n\n\ttemplate<typename T>\n\tstatic constexpr bool DoesRequireWorld()\n\t{\n\t\tconstexpr bool bIsWorldSubsystem = TIsDerivedFrom<T, UWorldSubsystem>::IsDerived;\n\t\tconstexpr bool bIsGameInstanceSubsystem = TIsDerivedFrom<T, UGameInstanceSubsystem>::IsDerived;\n\t\tconstexpr bool bIsLocalPlayerSubsystem = TIsDerivedFrom<T, ULocalPlayerSubsystem>::IsDerived;\n\n\t\treturn (bIsWorldSubsystem || bIsGameInstanceSubsystem || bIsLocalPlayerSubsystem);\n\t}\n\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tstatic T* FetchSubsystemInstance(UWorld* World)\n\t{\n\t\tcheck(World);\n\t\tif constexpr (TIsDerivedFrom<T, UWorldSubsystem>::IsDerived)\n\t\t{\n\t\t\treturn UWorld::GetSubsystem<T>(World);\n\t\t}\n\t\telse if constexpr (TIsDerivedFrom<T, UGameInstanceSubsystem>::IsDerived)\n\t\t{\n\t\t\treturn UGameInstance::GetSubsystem<T>(World->GetGameInstance());\n\t\t}\n\t\telse if constexpr (TIsDerivedFrom<T, ULocalPlayerSubsystem>::IsDerived)\n\t\t{\n\t\t\t// note that this default implementation will work only for the first player in a local-coop game\n\t\t\t// to customize this behavior specialize the FetchSubsystemInstance template function for the type you need. \n\t\t\treturn ULocalPlayer::GetSubsystem<T>(World->GetFirstLocalPlayerFromController());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcheckf(false, TEXT(\"FMassSubsystemAccess::FetchSubsystemInstance: Unhandled world-related USubsystem class %s\"), *T::StaticClass()->GetName());\n\t\t}\n\t}\n\t\n\ttemplate<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>\n\tstatic T* FetchSubsystemInstance()\n\t{\n\t\tif constexpr (TIsDerivedFrom<T, UEngineSubsystem>::IsDerived)\n\t\t{\n\t\t\treturn GEngine->GetEngineSubsystem<T>();\n\t\t}\n#if WITH_EDITOR\n\t\telse if constexpr (TIsDerivedFrom<T, UEditorSubsystem>::IsDerived)\n\t\t{\n\t\t\treturn GEditor->GetEditorSubsystem<T>();\n\t\t}\n#endif // WITH_EDITOR\n\t\telse\n\t\t{\n\t\t\tcheckf(false, TEXT(\"FMassSubsystemAccess::FetchSubsystemInstance: Unhandled world-less USubsystem class %s\"), *T::StaticClass()->GetName());\n\t\t}\n\t}\n\n\tstatic USubsystem* FetchSubsystemInstance(UWorld* World, TSubclassOf<USubsystem> SubsystemClass);\n\nprotected:\n\ttemplate<typename T>\n\tT* GetSubsystemInternal(const uint32 SystemIndex)\n\t{\n\t\tif (UNLIKELY(Subsystems.IsValidIndex(SystemIndex) == false))\n\t\t{\n\t\t\tSubsystems.AddZeroed(Subsystems.Num() - SystemIndex + 1);\n\t\t}\n\n\t\tT* SystemInstance = (T*)Subsystems[SystemIndex];\n\t\tif (SystemInstance == nullptr)\n\t\t{\n\t\t\tif constexpr (DoesRequireWorld<T>())\n\t\t\t{\n\t\t\t\tSystemInstance = FetchSubsystemInstance<std::remove_const_t<T>>(World.Get());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystemInstance = FetchSubsystemInstance<std::remove_const_t<T>>();\n\t\t\t}\n\t\t\tSubsystems[SystemIndex] = SystemInstance;\n\t\t}\n\t\treturn SystemInstance;\n\t}\n\n\ttemplate<typename T>\n\tT* GetSubsystemInternal(const uint32 SystemIndex, const TSubclassOf<USubsystem> SubsystemClass)\n\t{\n\t\tif (UNLIKELY(Subsystems.IsValidIndex(SystemIndex) == false))\n\t\t{\n\t\t\tSubsystems.AddZeroed(Subsystems.Num() - SystemIndex + 1);\n\t\t}\n\n\t\tUSubsystem* SystemInstance = (T*)Subsystems[SystemIndex];\n\t\tif (SystemInstance == nullptr)\n\t\t{\n\t\t\tSystemInstance = FetchSubsystemInstance(World.Get(), SubsystemClass);\n\t\t\tSubsystems[SystemIndex] = SystemInstance;\n\t\t}\n\t\treturn Cast<T>(SystemInstance);\n\t}\n\n\tbool CacheSubsystem(const uint32 SystemIndex);\n\n\tFMassExternalSubsystemBitSet ConstSubsystemsBitSet;\n\tFMassExternalSubsystemBitSet MutableSubsystemsBitSet;\n\tTArray<USubsystem*> Subsystems;\n\tTWeakObjectPtr<UWorld> World;\n};\n",
      "lines": 231
    },
    {
      "file_path": "MassEntity\\Public\\MassSubsystemBase.h",
      "extension": ".h",
      "size_bytes": 3295,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Subsystems/WorldSubsystem.h\"\n#include \"MassSubsystemBase.generated.h\"\n\n\nnamespace UE::Mass::Subsystems\n{\n\tstruct FInitializationState\n\t{\n\t\tuint8 bInitializeCalled : 1 = false;\n\t\tuint8 bPostInitializeCalled : 1 = false;\n\t\tuint8 bOnWorldBeginPlayCalled : 1 = false;\n\t};\n}\n\n/** \n * The sole responsibility of this world subsystem class is to serve functionality common to all \n * Mass-related UWorldSubsystem-based subsystems, like whether the subsystems should get created at all. \n */\nUCLASS(Abstract)\nclass MASSENTITY_API UMassSubsystemBase : public UWorldSubsystem\n{\n\tGENERATED_BODY()\n\npublic:\n\tstatic bool AreRuntimeMassSubsystemsAllowed(UObject* Outer);\n\tUE::Mass::Subsystems::FInitializationState GetInitializationState() const { return InitializationState; }\n\nprotected:\n\t//~USubsystem interface\n\tvirtual bool ShouldCreateSubsystem(UObject* Outer) const override;\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\tvirtual void PostInitialize() override;\n\tvirtual void Deinitialize() override;\n\tvirtual void OnWorldBeginPlay(UWorld& InWorld) override;\n\t//~End of USubsystem interface\n\n\t/**\n\t * Needs to be called in Initialize for subsystems we want to behave properly when dynamically added after UWorld::BeginPlay\n\t * (for example via GameplayFeatureActions). This is required for subsystems relying on their PostInitialize and/or OnWorldBeginPlay called.\n\t */\n\tvoid HandleLateCreation();\n\n\t/**\n\t * Tracks which initialization function had already been called. Requires the child classes to call Super implementation\n\t * for their Initialize, PostInitialize, Deinitialize and OnWorldBeginPlayCalled overrides\n\t */\n\tUE::Mass::Subsystems::FInitializationState InitializationState;\n};\n\n/**\n * The sole responsibility of this tickable world subsystem class is to serve functionality common to all\n * Mass-related UTickableWorldSubsystem-based subsystems, like whether the subsystems should get created at all.\n */\nUCLASS(Abstract)\nclass MASSENTITY_API UMassTickableSubsystemBase : public UTickableWorldSubsystem\n{\n\tGENERATED_BODY()\n\npublic:\n\tUE::Mass::Subsystems::FInitializationState GetInitializationState() const { return InitializationState; }\n\nprotected:\n\t//~USubsystem interface\n\tvirtual bool ShouldCreateSubsystem(UObject* Outer) const override;\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\tvirtual void PostInitialize() override;\n\tvirtual void Deinitialize() override;\n\tvirtual void OnWorldBeginPlay(UWorld& InWorld) override;\n\t//~End of USubsystem interface\n\n\t/**\n\t * Needs to be called in Initialize for subsystems we want to behave properly when dynamically added after UWorld::BeginPlay\n\t * (for example via GameplayFeatureActions). This is required for subsystems relying on their PostInitialize and/or OnWorldBeginPlay called.\n\t */\n\tvoid HandleLateCreation();\n\nprivate:\n\t/** \n\t * Tracks which initialization function had already been called. Requires the child classes to call Super implementation\n\t * for their Initialize, PostInitialize, Deinitialize and OnWorldBeginPlayCalled overrides\n\t */\n\tUE::Mass::Subsystems::FInitializationState InitializationState;\n};\n",
      "lines": 87
    },
    {
      "file_path": "MassGameplay\\MassActors\\Public\\IMassActorsModule.h",
      "extension": ".h",
      "size_bytes": 1113,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n * The public interface to this module.  In most cases, this interface is only public to sibling modules \n * within this plugin.\n */\nclass IMassActorsModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t * Singleton-like access to this module's interface.  This is just for convenience!\n\t * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t *\n\t * @return Returns singleton instance, loading the module on demand if needed\n\t */\n\tstatic inline IMassActorsModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassActorsModule>( \"MassActors\" );\n\t}\n\n\t/**\n\t * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t *\n\t * @return True if the module is loaded and ready to use\n\t */\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassActors\" );\n\t}\n};\n\n",
      "lines": 40
    },
    {
      "file_path": "MassGameplay\\MassActors\\Public\\MassActorHelper.h",
      "extension": ".h",
      "size_bytes": 1574,
      "content": "// Copyright Epic Games, Inc.All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n\nclass UScriptStruct;\nclass AActor;\n\nnamespace UE::MassActor\n{\n\t/** \n\t * Finds the entity associated with Actor and adds TagType to it,\n\t * @return true if successful, false otherwise (see log for details)\n\t */\n\tbool MASSACTORS_API AddEntityTagToActor(const AActor& Actor, const UScriptStruct& TagType);\n\n\t/**\n\t * Finds the entity associated with Actor and adds TagType to it,\n\t * @return true if successful, false otherwise (see log for details)\n\t */\n\ttemplate<typename TagType>\n\tbool AddEntityTagToActor(const AActor& Actor)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<TagType, FMassTag>::IsDerived, \"Given struct doesn't represent a valid tag type.\");\n\t\treturn AddEntityTagToActor(Actor, *TagType::StaticStruct());\n\t}\n\n\t/**\n\t * Finds the entity associated with Actor and remove TagType from its composition\n\t * @return true if successful, false otherwise (see log for details)\n\t */\n\tbool MASSACTORS_API RemoveEntityTagFromActor(const AActor& Actor, const UScriptStruct& TagType);\n\n\t/**\n\t * Finds the entity associated with Actor and remove TagType from its composition\n\t * @return true if successful, false otherwise (see log for details)\n\t */\n\ttemplate<typename TagType>\n\tbool RemoveEntityTagFromActor(const AActor& Actor)\n\t{\n\t\tstatic_assert(TIsDerivedFrom<TagType, FMassTag>::IsDerived, \"Given struct doesn't represent a valid tag type.\");\n\t\treturn RemoveEntityTagFromActor(Actor, *TagType::StaticStruct());\n\t}\n} // namespace UE::MassActor\n",
      "lines": 45
    },
    {
      "file_path": "MassGameplay\\MassActors\\Public\\MassActorPoolableInterface.h",
      "extension": ".h",
      "size_bytes": 742,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"UObject/Interface.h\"\n\n#include \"MassActorPoolableInterface.generated.h\"\n\nUINTERFACE(Blueprintable)\nclass MASSACTORS_API UMassActorPoolableInterface : public UInterface\n{\n\tGENERATED_UINTERFACE_BODY()\n};\n\nclass MASSACTORS_API IMassActorPoolableInterface : public IInterface\n{\n\tGENERATED_IINTERFACE_BODY()\n\npublic:\n\n\tUFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category=\"Mass|Actor Pooling\")\n\tbool CanBePooled();\n\n\tUFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category=\"Mass|Actor Pooling\")\n\tvoid PrepareForPooling();\n\n\tUFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category=\"Mass|Actor Pooling\")\n\tvoid PrepareForGame();\n};",
      "lines": 29
    },
    {
      "file_path": "MassGameplay\\MassActors\\Public\\MassActorSpawnerSubsystem.h",
      "extension": ".h",
      "size_bytes": 11927,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"StructUtils/InstancedStruct.h\"\n#include \"IndexedHandle.h\"\n#include \"Delegates/Delegate.h\"\n#include \"MassCommonTypes.h\"\n#include \"Templates/SubclassOf.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MassSubsystemBase.h\"\n\n#include \"MassActorSpawnerSubsystem.generated.h\"\n\n\nclass ULevel; \nstruct FActorSpawnParameters;\n\n// Handle for an actor spawning request\nUSTRUCT()\nstruct MASSACTORS_API FMassActorSpawnRequestHandle : public FIndexedHandleBase\n{\n\tGENERATED_BODY()\n\n\tFMassActorSpawnRequestHandle() = default;\n\n\t/** @note passing INDEX_NONE as index will make this handle Invalid */\n\tFMassActorSpawnRequestHandle(const int32 InIndex, const uint32 InSerialNumber) : FIndexedHandleBase(InIndex, InSerialNumber)\n\t{\n\t}\n};\n\n// Managing class of spawning requests handles\ntypedef FIndexedHandleManager<FMassActorSpawnRequestHandle, true/*bOptimizeHandleReuse*/> FMassEntityHandleManager_ActorSpawnRequest;\n\n\nDECLARE_DELEGATE_TwoParams(FMassActorPreSpawnDelegate, const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest);\nenum class EMassActorSpawnRequestAction : uint8\n{\n\tKeep, // Will leave spawning request in the queue and it will be users job to call RemoveActorSpawnRequest\n\tRemove, // Will remove the spawning request from the queue once the callback ends\n};\nDECLARE_DELEGATE_RetVal_TwoParams(EMassActorSpawnRequestAction, FMassActorPostSpawnDelegate, const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest);\n\nUENUM()\nenum class ESpawnRequestStatus : uint8\n{\n\tNone, // Not in the queue to be spawn\n\tPending, // Still in the queue to be spawn\n\tProcessing, // in the process of spawning the actor\n\tSucceeded, // Successfully spawned the actor\n\tFailed, // Error while spawning the actor\n\tRetryPending, // Failed spawn request that are being retried (lower priority)\n};\n\n/**\n * Base class for all spawn request\n */\nUSTRUCT()\nstruct MASSACTORS_API FMassActorSpawnRequest\n{\n\tGENERATED_BODY()\npublic:\n\t/** The actual mass agent handle corresponding to the actor to spawn */\n\tFMassEntityHandle MassAgent;\n\n\t/** The template BP actor to spawn */\n\tUPROPERTY(Transient)\n\tTSubclassOf<AActor> Template;\n\n\t/** The location of where to spawn that actor */\n\tFTransform\tTransform;\n\n\t/** Priority of this spawn request in comparison with the others, the lower the value is, the higher the priority is */\n\tfloat Priority = MAX_FLT;\n\n\t/** Delegate that will be called just before the spawning an actor, giving the chance to the processor to prepare it */\n\tFMassActorPreSpawnDelegate ActorPreSpawnDelegate;\n\n\t/** \n\t * Delegate that will be called once the spawning is done. Note that it will be called regardless of whether \n\t * the spawning was successful. \n\t */\n\tFMassActorPostSpawnDelegate ActorPostSpawnDelegate;\n\n\t/** The current status of the spawn request */\n\tESpawnRequestStatus SpawnStatus = ESpawnRequestStatus::None;\n\n\t/** The pointer to the actor once it is spawned */\n\tUPROPERTY(Transient)\n\tTObjectPtr<AActor> SpawnedActor = nullptr;\n\n\t/** Internal request serial number (used to cycle through next spawning request) */\n\tuint32 SerialNumber = 0;\n\n\t/** Requested world time seconds */\n\tdouble RequestedTime = 0.;\n\n\t/** If set, will be used to name the spawned character */\n\tFGuid Guid;\n\n\tvoid Reset()\n\t{\n\t\tMassAgent = FMassEntityHandle();\n\t\tTemplate = nullptr;\n\t\tPriority = MAX_FLT;\n\t\tActorPreSpawnDelegate.Unbind();\n\t\tActorPostSpawnDelegate.Unbind();\n\t\tSpawnStatus = ESpawnRequestStatus::None;\n\t\tSpawnedActor = nullptr;\n\t\tSerialNumber = 0;\n\t\tRequestedTime = 0.0f;\n\t}\n\n\tbool IsFinished() const { return SpawnStatus == ESpawnRequestStatus::Failed || SpawnStatus == ESpawnRequestStatus::Succeeded; }\n};\n\n/**\n * A subsystem managing spawning of actors for all mass subsystems\n */\nUCLASS(transient)\nclass MASSACTORS_API UMassActorSpawnerSubsystem : public UMassSubsystemBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\t// USubsystem BEGIN\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\tvirtual void Deinitialize() override;\n\t// USubsystem END\n\npublic:\n\tstatic void AddReferencedObjects(UObject* InThis, FReferenceCollector& Collector);\n\n\t/** Request an actor to spawn\n\t * Note: If you do not provide a spawn delegate, the requester is responsible to remove the request by hand.\n\t * It will be auto removed after the execution of the spawn delegate.\n\t * @param InSpawnRequest the spawn request parameters, You can provide any type of UStruct as long at it derives from FMassActorSpawnRequest. This let you add more spawning information.\n\t */\n\ttemplate< typename T, typename = typename TEnableIf<TIsDerivedFrom<typename TRemoveReference<T>::Type, FMassActorSpawnRequest>::IsDerived, void>::Type >\n\tFMassActorSpawnRequestHandle RequestActorSpawn(const T& InSpawnRequest)\n\t{\n\t\treturn RequestActorSpawnInternal(FConstStructView::Make(InSpawnRequest));\n\t}\n\n\t/**\n\t * Process a valid spawn request indicated by given handle. Can be used to force instant-spawn of an actor provided \n\t * a valid handle is obtained by calling RequestActorSpawn first. \n\t * @return indicates the status of processed spawn request, with ESpawnRequestStatus::None indicating that \"something \n\t *\twent wrong\" and spawning request has not been processed. \n\t */\n\t[[nodiscard]] ESpawnRequestStatus ProcessSpawnRequest(const FMassActorSpawnRequestHandle SpawnRequestHandle);\n\n\t/** \n\t * Similar to the other ProcessSpawnRequest flavor, but with SpawnRequestView and SpawnRequest already provided. \n\t */\n\t[[nodiscard]] ESpawnRequestStatus ProcessSpawnRequest(const FMassActorSpawnRequestHandle SpawnRequestHandle, FStructView SpawnRequestView, FMassActorSpawnRequest& SpawnRequest);\n\n\t/** Retries a failed spawn request\n\t * @param SpawnRequestHandle the spawn request handle to retry\n\t */\n\tvoid RetryActorSpawnRequest(const FMassActorSpawnRequestHandle SpawnRequestHandle);\n\n\t/**\n\t * Removes a spawn request\n\t * The only time a spawn request cannot be removed is when its state is processing\n\t * Also spawn requests are auto removed if you provided a spawn delegate after it was being executed.\n\t * @param SpawnRequestHandle [IN/OUT] the spawn request handle to remove\n\t * @return true if successfully removed the request\n\t */\n\tbool RemoveActorSpawnRequest(FMassActorSpawnRequestHandle& SpawnRequestHandle);\n\n\t/**\n\t * Returns the stored spawn request from the handle, useful to update the transform\n\t * @param SpawnRequestHandle the spawn request handle to get the request from\n\t * @return The spawn request cast in the provided template argument\n\t */\n\ttemplate<typename T>\n\tconst T& GetSpawnRequest(const FMassActorSpawnRequestHandle SpawnRequestHandle) const\n\t{\n\t\tcheck(SpawnRequestHandleManager.IsValidHandle(SpawnRequestHandle));\n\t\tcheck(SpawnRequests.IsValidIndex(SpawnRequestHandle.GetIndex()));\n\t\treturn SpawnRequests[SpawnRequestHandle.GetIndex()].Get<T>();\n\t}\n\n\t/**\n\t * Returns the stored spawn request from the handle, useful to update the transform\n\t * @param SpawnRequestHandle the spawn request handle to get the request from\n\t * @return The spawn request cast in the provided template argument\n\t */\n\ttemplate<typename T> \n\tT& GetMutableSpawnRequest(const FMassActorSpawnRequestHandle SpawnRequestHandle)\n\t{\n\t\tcheck(SpawnRequestHandleManager.IsValidHandle(SpawnRequestHandle));\n\t\tcheck(SpawnRequests.IsValidIndex(SpawnRequestHandle.GetIndex()));\n\t\treturn SpawnRequests[SpawnRequestHandle.GetIndex()].GetMutable<T>();\n\t}\n\n\tbool IsSpawnRequestHandleValid(const FMassActorSpawnRequestHandle SpawnRequestHandle) const\n\t{\n\t\treturn SpawnRequestHandleManager.IsValidHandle(SpawnRequestHandle);\n\t}\n\n\t/**\n\t * Destroy an actor \n\t * @param Actor to destroy\n\t * @param bImmediate to do the destruction immediately, otherwise will be queued up for later\n\t */\n\tvirtual void DestroyActor(AActor* Actor, bool bImmediate = false);\n\t\n\tvoid EnableActorPooling();\n\tvoid DisableActorPooling();\n\tbool IsActorPoolingEnabled();\n\n\tvoid ReleaseAllResources();\n\nprotected:\n\t/** \n\t * Provides consistent way of conditional destroying Actor within World. The actual destruction depends on Actor's state\n\t * and whether it belongs to World\n\t */\n\tstatic void ConditionalDestroyActor(UWorld& World, AActor& ActorToDestroy);\n\n\t/** Called at the start of the PrePhysics mass processing phase and calls ProcessPendingSpawningRequest */ \n\tvoid OnPrePhysicsPhaseStarted(const float DeltaSeconds);\n\t\n\t/** Called at the end of the PrePhysics mass processing phase and calls ProcessPendingDestruction */ \n\tvoid OnPrePhysicsPhaseFinished(const float DeltaSeconds); \n\t\n\t/** \n\t *  Retrieve what would be the next best spawning request to spawn, can be overridden to have different logic\n\t *  Default implementation is the first valid request in the list, no interesting logic yet\n\t *  @param InOutHandleIndex used to start the search in subsequent locations. Also the index ensures the same handle \n\t *    won't get returned twice in a row. InOutHandleIndex being INDEX_NONE indicates this is the first run, so all \n\t *    handles are to be considered. If it's a  valid index then we iterate all but one to not even consider the \n\t *    handle indicated by InOutHandleIndex.\n\t *  @return the next best handle to spawn. \n\t */\n\tvirtual FMassActorSpawnRequestHandle GetNextRequestToSpawn(int32& InOutHandleIndex) const;\n\n\tvirtual ESpawnRequestStatus SpawnOrRetrieveFromPool(FConstStructView SpawnRequestView, TObjectPtr<AActor>& OutSpawnedActor);\n\n\t/** Actual code that will spawn the actor, overridable by subclass if need to be.\n\t *  @return spawned actor if succeeded. */\n\tvirtual ESpawnRequestStatus SpawnActor(FConstStructView SpawnRequestView, TObjectPtr<AActor>& OutSpawnedActor, FActorSpawnParameters& InOutSpawnParameters) const;\n\n\tTObjectPtr<AActor> FindActorByName(const FName ActorName, ULevel* OverrideLevel) const;\n\n\t/** Go through the spawning request and spawn them until we reach the budget \n\t * @param MaxTimeSlicePerTick is the budget in seconds allowed to do spawning */\n\tvoid ProcessPendingSpawningRequest(const double MaxTimeSlicePerTick);\n\n\t/** Go through the queued actors to destroy and destroy them until we reach the budget\n\t * @param MaxTimeSlicePerTick is the budget in seconds allowed to do destruction */\n\tvoid ProcessPendingDestruction(const double MaxTimeSlicePerTick);\n\n\t/** Try releasing this actor to pool if possible \n\t * @param Actor to release to the bool\n\t * @return true if the actor was actually released to the pool */\n\tvirtual bool ReleaseActorToPool(AActor* Actor);\n\n\t/** Internal generic request actor spawn to make sure the request derives from FMassActorSpawnRequest \n\t *  @param SpawnRequest the spawn request parameters, We are allowing any type of spawn request, let's store it internally as a FInstancedStruct. This parameter is the FStructView over provide user struct */\n\tFMassActorSpawnRequestHandle RequestActorSpawnInternal(const FConstStructView SpawnRequest);\n\nprotected:\n\n\tUPROPERTY()\n\tTArray<FInstancedStruct> SpawnRequests;\n\n\tUPROPERTY()\n\tTArray<TObjectPtr<AActor>> ActorsToDestroy;\n\n\tUPROPERTY()\n\tTArray<TObjectPtr<AActor>> DeactivatedActorsToDestroy;\n\n\tbool bActorPoolingEnabled = true;\n\n\tTMap<TSubclassOf<AActor>, TArray<TObjectPtr<AActor>>> PooledActors;\n\n\tFMassEntityHandleManager_ActorSpawnRequest SpawnRequestHandleManager;\n\n\tstd::atomic<uint32> RequestSerialNumberCounter;\n\n\tmutable int32 NumActorSpawned = 0;\n\tmutable int32 NumActorPooled = 0;\n\n\tint32 StartingHandleIndex = INDEX_NONE;\n\npublic:\n\tUE_DEPRECATED(5.4, \"This flavor of GetNextRequestToSpawn is deprecated. Use the alternative taking an int32& parameter\")\n\tvirtual FMassActorSpawnRequestHandle GetNextRequestToSpawn() const final;\n};\n",
      "lines": 293
    },
    {
      "file_path": "MassGameplay\\MassActors\\Public\\MassActorSubsystem.h",
      "extension": ".h",
      "size_bytes": 8390,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"Engine/ActorInstanceHandle.h\"\n#include \"MassCommonFragments.h\"\n#include \"Misc/MTAccessDetector.h\"\n#include \"UObject/ObjectKey.h\"\n#include \"MassSubsystemBase.h\"\n#include \"MassActorSubsystem.generated.h\"\n\nstruct FMassEntityHandle;\nclass AActor;\nstruct FMassEntityManager;\nclass UMassActorSubsystem;\n\nUSTRUCT()\nstruct MASSACTORS_API FMassGuidFragment : public FObjectWrapperFragment\n{\n\tGENERATED_BODY()\n\n\tFGuid Guid;\n};\n\n/**\n * Fragment to store the instanced actor handle of a mass entity if it needs one.\n */\nUSTRUCT()\nstruct MASSACTORS_API FMassActorInstanceFragment : public FMassFragment\n{\n\tGENERATED_BODY();\n\n\tFMassActorInstanceFragment() = default;\n\texplicit FMassActorInstanceFragment(const FActorInstanceHandle& InHandle)\n\t\t: Handle(InHandle)\n\t{\n\t}\n\n\tUPROPERTY()\n\tFActorInstanceHandle Handle;\n};\n\nnamespace UE::Mass::Signals\n{\n\t/** Signal use when the actor instance handle is set or cleared in the associated fragment. */\n\tconst FName ActorInstanceHandleChanged = FName(TEXT(\"ActorInstanceHandleChanged\"));\n}\n\n/**\n * Fragment to save the actor pointer of a mass entity if it exists\n */\nUSTRUCT()\nstruct MASSACTORS_API FMassActorFragment : public FObjectWrapperFragment\n{\n\tGENERATED_BODY()\n\n\tenum class EActorAccess\n\t{\n\t\tOnlyWhenAlive, // Only return an actor pointer if the actor is alive. This is the default.\n\t\tIncludePendingKill, // Return an actor pointer even if the actor is marked for destruction.\n\t\tIncludeUnreachable // Return an actor pointer even if the actor is unreachable. This implies it's being destroyed.\n\t};\n\n\t/**\n\t * Set the actor associated to a mass agent, will also keep the map back in MassActorSubsystem up to date.\n\t * @param MassAgent to associated with the actor\n\t * @param InActor the actor associated with the mass agent\n\t * @param bInIsOwnedByMass tell whether the actors was spawned by mass(MassVisualization) or externally(ReplicatedActors)\n\t */\n\tvoid SetAndUpdateHandleMap(const FMassEntityHandle MassAgent, AActor* InActor, const bool bInIsOwnedByMass);\n\n\t/** \n\t * Resets the actor pointed by this fragment, will also keep the map back in UMassActorSubsystem up to date \n\t * @param CachedActorSubsystem if provided will be used directly, otherwise an instance of UMassActorSubsystem will \n\t *\tbe deduced from Actor's world (at additional runtime cost)\n\t */\n\tvoid ResetAndUpdateHandleMap(UMassActorSubsystem* CachedActorSubsystem = nullptr);\n\n\t/**\n\t * Set the actor associated to a mass agent, will NOT keep map back in MassActorSubsystem up to date.\n\t * The user needs to do the map update by hand.\n\t * Useful in multithreaded environment, to queue the update of the map inside a deferred command\n\t * @param MassAgent to associated with the actor\n\t * @param InActor the actor associated with the mass agent\n\t * @param bInIsOwnedByMass tell whether the actors was spawned by mass(MassVisualization) or externally(ReplicatedActors)\n\t */\n\tvoid SetNoHandleMapUpdate(const FMassEntityHandle MassAgent, AActor* InActor, const bool bInIsOwnedByMass);\n\n\t/** Resets the actor pointed by this fragment, will NOT keep map back in MassActorSubsystem up to date.\n\t * The user needs to do the map update by hand.\n\t * Useful in multithreaded environment, to queue the update of the map inside a deferred command\n\t */\n\tvoid ResetNoHandleMapUpdate();\n\n\n\t/** @return none const pointer to the actor\t*/\n\tFORCEINLINE AActor* GetMutable() { return Actor.Get(); }\n\tAActor* GetMutable(EActorAccess Access);\n\n\t/** @return none const pointer to the actor\tonly if owned by mass */\n\tFORCEINLINE AActor* GetOwnedByMassMutable() { return bIsOwnedByMass ? Actor.Get() : nullptr; }\n\n\t/** @return none const pointer to the actor\tonly if owned by mass */\n\tFORCEINLINE const AActor* Get() const { return Actor.Get(); }\n\tconst AActor* Get(EActorAccess Access) const;\n\n\t/** @return if the actor is owned by mass */\n\tFORCEINLINE bool IsOwnedByMass() const { return bIsOwnedByMass; }\n\n\t/** @return if the actor is a valid pointer */\n\tFORCEINLINE bool IsValid() const { return Actor.IsValid(); }\n\nprivate:\n\t// made visible for debugging purposes. It will show up in Mass's gameplay debugger category when viewing fragment details\n\tUPROPERTY(VisibleAnywhere, Category=\"Mass\", Transient)\n\tTWeakObjectPtr<AActor> Actor;\n\n\t/** Ownership of the actor */\n\tbool bIsOwnedByMass = false;\n};\n\nstruct MASSACTORS_API FMassActorManager : public TSharedFromThis<FMassActorManager>\n{\npublic:\n\texplicit FMassActorManager(const TSharedPtr<FMassEntityManager>& EntityManager, UObject* InOwner = nullptr);\n\n\t/** Get mass handle from an actor */\n\tFMassEntityHandle GetEntityHandleFromActor(const TObjectKey<const AActor> Actor);\n\n\t/** Set the mass handle associated to an actor */\n\tvoid SetHandleForActor(const TObjectKey<const AActor> Actor, const FMassEntityHandle Handle);\n\n\t/** Remove entry associated to an actor */\n\tvoid RemoveHandleForActor(const TObjectKey<const AActor> Actor);\n\n\t/** Get an actor pointer from a mass handle */\n\tAActor* GetActorFromHandle(const FMassEntityHandle Handle, \n\t\tFMassActorFragment::EActorAccess Access = FMassActorFragment::EActorAccess::OnlyWhenAlive) const;\n\n\t/** \n\t *  Removes the connection between Actor and the given entity. Does all the required book keeping \n\t *  (as opposed to straight up RemoveHandleForActor call). If the Handle doesn't match Actor no action is taken.\n\t */\n\tvoid DisconnectActor(const TObjectKey<const AActor> Actor, const FMassEntityHandle Handle);\n\nprotected:\n\n\tTMap<TObjectKey<const AActor>, FMassEntityHandle> ActorHandleMap;\n\tUE_MT_DECLARE_RW_ACCESS_DETECTOR(ActorHandleMapDetector);\n\t\n\tTSharedPtr<FMassEntityManager> EntityManager;\n\n\t/** Points at an UObject hosting this instance of the FMassActorManager. It's fine for this to be null. */\n\tTWeakObjectPtr<UObject> Owner;\n};\n\n/**\n * A subsystem managing communication between Actors and Mass\n */\nUCLASS()\nclass MASSACTORS_API UMassActorSubsystem : public UMassSubsystemBase\n{\n\tGENERATED_BODY()\n\npublic:\n\t/** Get mass handle from an actor */\n\tinline FMassEntityHandle GetEntityHandleFromActor(const TObjectKey<const AActor> Actor);\n\n\t/** Set the mass handle associated to an actor */\n\tinline void SetHandleForActor(const TObjectKey<const AActor> Actor, const FMassEntityHandle Handle);\n\n\t/** Remove entry associated to an actor */\n\tinline void RemoveHandleForActor(const TObjectKey<const AActor> Actor);\n\n\t/** Get an actor pointer from a mass handle */\n\tinline AActor* GetActorFromHandle(const FMassEntityHandle Handle,\n\t\tFMassActorFragment::EActorAccess Access = FMassActorFragment::EActorAccess::OnlyWhenAlive) const;\n\n\t/** \n\t *  Removes the connection between Actor and the given entity. Does all the required book keeping \n\t *  (as opposed to straight up RemoveHandleForActor call). If the Handle doesn't match Actor no action is taken.\n\t */\n\tinline void DisconnectActor(const TObjectKey<const AActor> Actor, const FMassEntityHandle Handle);\n\nprotected:\n\t// USubsystem BEGIN\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\tvirtual void Deinitialize() override;\n\t// USubsystem END\n\t\n\tTSharedPtr<FMassActorManager> ActorManager;\n};\n\ntemplate<>\nstruct TMassExternalSubsystemTraits<UMassActorSubsystem> final\n{\n\tenum\n\t{\n\t\tGameThreadOnly = false\n\t};\n};\n\n/**\n * UMassActorSubsystem's inlines\n */\nFMassEntityHandle UMassActorSubsystem::GetEntityHandleFromActor(const TObjectKey<const AActor> Actor)\n{\n\treturn ActorManager->GetEntityHandleFromActor(Actor);\n}\n\nvoid UMassActorSubsystem::SetHandleForActor(const TObjectKey<const AActor> Actor, const FMassEntityHandle Handle)\n{\n\tActorManager->SetHandleForActor(Actor, Handle);\n}\n\nvoid UMassActorSubsystem::RemoveHandleForActor(const TObjectKey<const AActor> Actor)\n{\n\tActorManager->RemoveHandleForActor(Actor);\n}\n\nAActor* UMassActorSubsystem::GetActorFromHandle(const FMassEntityHandle Handle,\n\tFMassActorFragment::EActorAccess Access) const\n{\n\treturn ActorManager->GetActorFromHandle(Handle, Access);\n}\n\nvoid UMassActorSubsystem::DisconnectActor(const TObjectKey<const AActor> Actor, const FMassEntityHandle Handle) \n{ \n\treturn ActorManager->DisconnectActor(Actor, Handle); \n}\n\n",
      "lines": 232
    },
    {
      "file_path": "MassGameplay\\MassActors\\Public\\MassActorTypes.h",
      "extension": ".h",
      "size_bytes": 164,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Logging/LogMacros.h\"\n\n\nDECLARE_LOG_CATEGORY_EXTERN(LogMassActor, Warning, All);\n",
      "lines": 8
    },
    {
      "file_path": "MassGameplay\\MassActors\\Public\\MassAgentComponent.h",
      "extension": ".h",
      "size_bytes": 6124,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Components/ActorComponent.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassEntityTemplate.h\"\n#include \"MassEntityConfigAsset.h\"\n#include \"MassAgentComponent.generated.h\"\n\n\nUENUM()\nenum class EAgentComponentState : uint8\n{\n\tNone, // Default starting state\n\n\t// States of actors needing mass entity creation\n\tEntityPendingCreation, // Actor waiting for entity creation\n\tEntityCreated, // Actor with a created entity\n\n\t// States are for Actor driven by Mass (puppet) needing fragments initialization\n\tPuppetPendingInitialization, // Puppet actor queued for fragments initialization\n\tPuppetInitialized, // Puppet actor with all initialized fragments\n\tPuppetPaused, // Puppet actor with all fragments removed \n\tPuppetPendingReplication, // Replicated puppet actor waiting for NetID\n\tPuppetReplicatedOrphan, // Replicated puppet actor not associated to a MassAgent\n};\n\n\n/** \n *  There are two primary use cases for this component:\n *  1. If placed on an AActor blueprint it lets the user specify additional fragments that will be created for \n *     entities spawned based on this given blueprint. \n *  2. If present on an actor in the world it makes it communicate with the MassSimulation which will create an \n *     entity representing given actor. Use case 1) will also be applicable in this case. The component is unregistered by \n *     default and requires manual enabling via a 'Enable' call.\n * \n *  @todo use case 2) is currently sitting in a shelved CL of mine. Will be worked on next.\n */\nUCLASS(Blueprintable, ClassGroup = Mass, meta = (BlueprintSpawnableComponent), hidecategories = (Sockets, Collision))\nclass MASSACTORS_API UMassAgentComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\n\tUMassAgentComponent();\n\nprotected:\n\tvirtual void OnRegister() override;\n\tvirtual void OnUnregister() override;\n\n#if WITH_EDITOR\n\tvirtual void PostInitProperties() override;\n\tvirtual void PostLoad() override;\n#endif // WITH_EDITOR\n\npublic:\n\t// Support poolable mass agents going into stasis\n\tvoid RegisterWithAgentSubsystem();\n\tvoid UnregisterWithAgentSubsystem();\n\tbool IsReadyForPooling() const;\n\n\t/** @todo to enforce encapsulation we could make this protected and have a UMassAgentSubsystem friend. I'm not sure I like it though. */\n\n\t/** Methods handling the state for actors that needs mass entity creation*/\n\tFMassEntityHandle GetEntityHandle() const { return AgentHandle; }\n\tvoid SetEntityHandle(const FMassEntityHandle NewHandle);\n\tvoid ClearEntityHandle();\n\tvoid EntityCreationPending();\n\tvoid EntityCreationAborted();\n\tbool IsEntityPendingCreation() const { return (State == EAgentComponentState::EntityPendingCreation); }\n\n\t/** Methods handling the state of puppet actors that needs fragments initialization */\n\tvoid SetPuppetHandle(const FMassEntityHandle NewHandle);\n\tvoid PuppetInitializationPending();\n\tvoid PuppetInitializationDone();\n\tvoid PuppetInitializationAborted();\n\tvoid PuppetUnregistrationDone();\n\tbool IsPuppetPendingInitialization() const { return (State == EAgentComponentState::PuppetPendingInitialization); }\n\tbool IsPuppetReplicationPending() const { return (State == EAgentComponentState::PuppetPendingReplication); }\n\tbool IsPuppet() const { return State == EAgentComponentState::PuppetInitialized || State == EAgentComponentState::PuppetPendingInitialization || State == EAgentComponentState::PuppetPaused; }\n\t/**\n\t * Re-adds/Removes all puppet fragments added on the mass agent\n\t * This is only supported in Puppet flow\n\t * @param bPause true to pause or false to unpause\n\t */\n\tvoid PausePuppet(const bool bPause);\n\t/* @return boolean whether this component was paused via PausePuppet method */\n\tbool IsPuppetPaused() const { return State == EAgentComponentState::PuppetPaused; }\n\n\t/** Methods handling the state of a server replicated puppet */\n\tvoid PuppetReplicationPending();\n\tvoid SetReplicatedPuppetHandle(FMassEntityHandle NewHandle);\n\tvoid ClearReplicatedPuppetHandle();\n\tvoid MakePuppetAReplicatedOrphan();\n\n\tFMassEntityTemplateID GetTemplateID() const { return TemplateID; }\n\n\tconst FMassEntityConfig& GetEntityConfig() const { return EntityConfig; }\n\tvoid SetEntityConfig(const FMassEntityConfig& InEntityConfig);\n\n\tconst FMassArchetypeCompositionDescriptor& GetPuppetSpecificAddition() const { return PuppetSpecificAddition; }\n\tFMassArchetypeCompositionDescriptor& GetMutablePuppetSpecificAddition() { return PuppetSpecificAddition; }\n\n\t/** Registers the component with the owner effectively turning it on. Calling it multiple times won't break anything  */\n\tUFUNCTION(BlueprintCallable, Category = Mass)\n\tvoid Enable();\n\n\t/** Registers the component with the owner effectively turning it off */\n\tUFUNCTION(BlueprintCallable, Category = Mass)\n\tvoid Disable();\n\n\tUFUNCTION(BlueprintCallable, Category = Mass)\n\tvoid KillEntity(const bool bDestroyActor);\n\n\t//~ Begin UObject Interface\n\tvirtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n\t//~ End UObject Interface\n\n\tFMassNetworkID GetNetID() const\n\t{\n\t\treturn NetID;\n\t}\n\n\tUFUNCTION()\n\tvirtual void OnRep_NetID();\n\nprotected:\n\n\tvoid SwitchToState(EAgentComponentState NewState);\n\tvoid SetEntityHandleInternal(const FMassEntityHandle NewHandle);\n\tvoid ClearEntityHandleInternal();\n\tvoid DebugCheckStateConsistency();\n\n\t/**\n\t *  Contains all the fragments added to the entity during puppet's initialization. Required for clean up when\n\t *  despawning puppet while the entity remains alive.\n\t */\n\tFMassArchetypeCompositionDescriptor PuppetSpecificAddition;\n\n\tUPROPERTY(EditAnywhere, Category = \"Mass\")\n\tFMassEntityConfig EntityConfig;\n\t\n\tFMassEntityHandle AgentHandle;\n\tFMassEntityTemplateID TemplateID;\n\n\tEAgentComponentState State;\n\n\tUPROPERTY(replicatedUsing = OnRep_NetID)\n\tFMassNetworkID NetID;\n\t\n#if WITH_EDITORONLY_DATA\n\tUPROPERTY(EditAnywhere, Category = \"Mass\")\n\tuint32 bAutoRegisterInEditorMode : 1;\n#endif // WITH_EDITORONLY_DATA\n};\n",
      "lines": 157
    },
    {
      "file_path": "MassGameplay\\MassActors\\Public\\MassAgentSubsystem.h",
      "extension": ".h",
      "size_bytes": 5343,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassProcessingTypes.h\"\n#include \"MassEntityTemplate.h\"\n#include \"MassSubsystemBase.h\"\n#include \"MassAgentSubsystem.generated.h\"\n\nclass AActor;\nstruct FMassEntityManager;\nclass UMassSpawnerSubsystem;\nclass UMassAgentComponent;\nclass UMassSimulationSubsystem;\nclass UMassAgentSubsystem;\nclass UMassAgentComponent;\nclass UMassReplicationSubsystem;\n\nnamespace UE::MassActor\n{\n\tDECLARE_MULTICAST_DELEGATE_OneParam(FMassAgentComponentDelegate, const UMassAgentComponent& /*AgentComponent*/);\n\n} // UE::MassActor\n\nUSTRUCT()\nstruct MASSACTORS_API FMassAgentInitializationQueue\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY()\n\tTArray<TObjectPtr<UMassAgentComponent>> AgentComponents;\n};\n\n/**\n * A subsystem managing communication between Actors and Mass\n */\nUCLASS()\nclass MASSACTORS_API UMassAgentSubsystem : public UMassSubsystemBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\t// USubsystem BEGIN\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\tvirtual void Deinitialize() override;\n\t// USubsystem END\n\npublic:\n\t/** Registers given AgentComp with the Mass Simulation, including creation of a FMassEntityHandle using \n\t *  UMassAgentComponent.LWComponentList to determine the Archetype to use. */\n\tFMassEntityTemplateID RegisterAgentComponent(UMassAgentComponent& AgentComp);\n\n\t/** Called for AgentComp that has already been registered with the Agent Manager to notify it that AgentComp's \n\t *  Mass-relevant properties had changed, most notably its fragment composition. The Agent Manager will update \n\t *  the information on Mass side potentially reallocating the associated entity to a different archetype */\n\tvoid UpdateAgentComponent(const UMassAgentComponent& AgentComp);\n\n\t/**\n\t * Removes given AgentComp instance from the system. If there's an entity created with the AgentComp\n\t *  instance then it will be destroyed.\n\t * @param AgentComp the component to unregister from the system\n\t */\n\t void UnregisterAgentComponent(UMassAgentComponent& AgentComp);\n\n\t /**\n\t  * Same as UnregisterAgentComponent, but on top of that it tells the system it will never register again\n\t  * @param AgentComp the component to shutdown from the system\n\t  */\n\t void ShutdownAgentComponent(UMassAgentComponent& AgentComp);\n\n\t/** lets the system know given agent is a puppet (an unreal-side representation of a mass entity) */\n\tvoid MakePuppet(UMassAgentComponent& AgentComp);\n\n\t/**\n\t * Notifies that this MassAgentComponent is now replicated with a valid NetID\n\t * @param AgentComp that is now replicated\n\t */\n\tvoid NotifyMassAgentComponentReplicated(UMassAgentComponent& AgentComp);\n\n\t/**\n\t * Notifies that this MassAgentComponent is now associated to a mass entity\n\t * @param AgentComp that is now associated to a mass entity\n\t */\n\tvoid NotifyMassAgentComponentEntityAssociated(const UMassAgentComponent& AgentComp) const;\n\n\t/**\n\t * Notifies that this MassAgentComponent is now detaching from its mass entity\n\t * @param AgentComp that is detaching from its mass entity\n\t */\n\tvoid NotifyMassAgentComponentEntityDetaching(const UMassAgentComponent& AgentComp) const;\n\n\t/**\n\t * @return The delegate of when MassAgentComponent gets associated to a mass entity\n\t */\n\tUE::MassActor::FMassAgentComponentDelegate& GetOnMassAgentComponentEntityAssociated()\n\t{\n\t\treturn OnMassAgentComponentEntityAssociated;\n\t}\n\n\t/**\n\t * @return The delegate of when MassAgentComponent is detaching from its mass entity\n\t */\n\tUE::MassActor::FMassAgentComponentDelegate& GetOnMassAgentComponentEntityDetaching()\n\t{\n\t\treturn OnMassAgentComponentEntityDetaching;\n\t}\n\nprotected:\n\t/** \n\t * Processes PendingAgentEntities to initialize fragments of recently created agent entities and PendingPuppets \n\t * to create and initialize puppet-specific fragments \n\t */\n\tvoid HandlePendingInitialization();\n\n\t/** Bound to UMassSimulationSubsystem.OnProcessingPhaseStartedDelegate and called before every processing phase start */\n\tvoid OnProcessingPhaseStarted(const float DeltaSeconds, const EMassProcessingPhase Phase);\n\n\t/** Callback registered to the replication manager when a mass agent is added to the replication (client only) */\n\tvoid OnMassAgentAddedToReplication(FMassNetworkID NetID, FMassEntityHandle Entity);\n\n\t/** Callback registered to the replication manager when a mass agent is removed from the replication (client only) */\n\tvoid OnMassAgentRemovedFromReplication(FMassNetworkID NetID, FMassEntityHandle Entity);\n\nprotected:\n\tTSharedPtr<FMassEntityManager> EntityManager;\n\n\tUPROPERTY()\n\tTObjectPtr<UMassSpawnerSubsystem> SpawnerSystem;\n\n\tUPROPERTY()\n\tTObjectPtr<UMassSimulationSubsystem> SimulationSystem;\n\n\tUPROPERTY()\n\tTMap<FMassEntityTemplateID, FMassAgentInitializationQueue> PendingAgentEntities;\n\n\tUPROPERTY()\n\tTMap<FMassEntityTemplateID, FMassAgentInitializationQueue> PendingPuppets;\n\n\tUPROPERTY()\n\tTObjectPtr<UMassReplicationSubsystem> ReplicationSubsystem;\n\n\tUPROPERTY()\n\tTMap<FMassNetworkID, TObjectPtr<UMassAgentComponent>> ReplicatedAgentComponents;\n\n\tUE::MassActor::FMassAgentComponentDelegate OnMassAgentComponentEntityAssociated;\n\tUE::MassActor::FMassAgentComponentDelegate OnMassAgentComponentEntityDetaching;\n};\n",
      "lines": 148
    },
    {
      "file_path": "MassGameplay\\MassActors\\Public\\MassAgentTraits.h",
      "extension": ".h",
      "size_bytes": 2337,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"MassEntityTraitBase.h\"\n#include \"MassTranslator.h\"\n#include \"MassAgentTraits.generated.h\"\n\nclass USceneComponent;\n\nUCLASS(Abstract)\nclass MASSACTORS_API UMassAgentSyncTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tEMassTranslationDirection GetSyncDirection() const { return SyncDirection; }\n\tvoid SetSyncDirection(const EMassTranslationDirection NewDirection) { SyncDirection = NewDirection; }\n\nprotected:\n\tUPROPERTY(EditAnywhere, Category = Mass)\n\tEMassTranslationDirection SyncDirection = EMassTranslationDirection::BothWays;\n};\n\n/** The trait initializes the entity with actor capsule component's radius. In addition, if bSyncTransform is true \n *  the trait keeps actor capsule component's and entity's transforms in sync. */\nUCLASS(BlueprintType, EditInlineNew, CollapseCategories, meta = (DisplayName = \"Agent Capsule Collision Sync\"))\nclass MASSACTORS_API UMassAgentCapsuleCollisionSyncTrait : public UMassAgentSyncTrait\n{\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\n\tUPROPERTY(EditAnywhere, Category = Mass)\n\tbool bSyncTransform = true;\n};\n\nUCLASS(BlueprintType, EditInlineNew, CollapseCategories, meta = (DisplayName = \"Agent Movement Sync\"))\nclass MASSACTORS_API UMassAgentMovementSyncTrait : public UMassAgentSyncTrait\n{\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n};\n\nUCLASS(BlueprintType, EditInlineNew, CollapseCategories, meta = (DisplayName = \"Agent Orientation Sync\"))\nclass MASSACTORS_API UMassAgentOrientationSyncTrait : public UMassAgentSyncTrait\n{\n\tGENERATED_BODY()\n\n\tprotected:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n};\n\nUCLASS(BlueprintType, EditInlineNew, CollapseCategories, meta = (DisplayName = \"Agent Feet Location Sync\"))\nclass MASSACTORS_API UMassAgentFeetLocationSyncTrait : public UMassAgentSyncTrait\n{\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n};\n\n",
      "lines": 66
    },
    {
      "file_path": "MassGameplay\\MassActors\\Public\\Translators\\MassCapsuleComponentTranslators.h",
      "extension": ".h",
      "size_bytes": 1926,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassCommonFragments.h\"\n#include \"MassTranslator.h\"\n#include \"MassCapsuleComponentTranslators.generated.h\"\n\n\nclass UCapsuleComponent;\nstruct FAgentRadiusFragment;\n\nUSTRUCT()\nstruct FCapsuleComponentWrapperFragment : public FObjectWrapperFragment\n{\n\tGENERATED_BODY()\n\tTWeakObjectPtr<UCapsuleComponent> Component;\n};\n\n/**\n * @todo TBD\n * I'm a bit on a fence regarding having separate tags per copy direction. My concern is that we can end up with a very \n * dispersed entity population spread across multiple archetypes storing a small number of entities each. An alternative\n * would be to have a property on the Wrapper fragment, but that doesn't sit well with me either, since that data would be \n * essentially static, meaning it will (in most cases) never change for a given entity, and we could waste a lot of time \n * iterating over fragments just to check that specific value.\n */\nUSTRUCT()\nstruct FMassCapsuleTransformCopyToMassTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\nUCLASS()\nclass MASSACTORS_API UMassCapsuleTransformToMassTranslator : public UMassTranslator\n{\n\tGENERATED_BODY()\npublic:\n\tUMassCapsuleTransformToMassTranslator();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\t\n\n\tFMassEntityQuery EntityQuery;\n};\n\nUSTRUCT()\nstruct FMassCapsuleTransformCopyToActorTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\nUCLASS()\nclass MASSACTORS_API UMassTransformToActorCapsuleTranslator : public UMassTranslator\n{\n\tGENERATED_BODY()\npublic:\n\tUMassTransformToActorCapsuleTranslator();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};\n",
      "lines": 66
    },
    {
      "file_path": "MassGameplay\\MassActors\\Public\\Translators\\MassCharacterMovementTranslators.h",
      "extension": ".h",
      "size_bytes": 2361,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassCommonFragments.h\"\n#include \"MassTranslator.h\"\n#include \"MassObserverProcessor.h\"\n#include \"MassCharacterMovementTranslators.generated.h\"\n\nclass UCharacterMovementComponent;\n\nUSTRUCT()\nstruct FCharacterMovementComponentWrapperFragment : public FObjectWrapperFragment\n{\n\tGENERATED_BODY()\n\tTWeakObjectPtr<UCharacterMovementComponent> Component;\n};\n\nUSTRUCT()\nstruct FMassCharacterMovementCopyToMassTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\nUCLASS()\nclass MASSACTORS_API UMassCharacterMovementToMassTranslator : public UMassTranslator\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassCharacterMovementToMassTranslator();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};\n\nUSTRUCT()\nstruct FMassCharacterMovementCopyToActorTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\n\nUCLASS()\nclass MASSACTORS_API UMassCharacterMovementToActorTranslator : public UMassTranslator\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassCharacterMovementToActorTranslator();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};\n\n\nUSTRUCT()\nstruct FMassCharacterOrientationCopyToMassTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\nUCLASS()\nclass MASSACTORS_API UMassCharacterOrientationToMassTranslator : public UMassTranslator\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassCharacterOrientationToMassTranslator();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};\n\nUSTRUCT()\nstruct FMassCharacterOrientationCopyToActorTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\n\nUCLASS()\nclass MASSACTORS_API UMassCharacterOrientationToActorTranslator : public UMassTranslator\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassCharacterOrientationToActorTranslator();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};\n",
      "lines": 104
    },
    {
      "file_path": "MassGameplay\\MassActors\\Public\\Translators\\MassSceneComponentLocationTranslator.h",
      "extension": ".h",
      "size_bytes": 1332,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassCommonFragments.h\"\n#include \"MassTranslator.h\"\n#include \"MassSceneComponentLocationTranslator.generated.h\"\n\n\nUSTRUCT()\nstruct FMassSceneComponentWrapperFragment : public FObjectWrapperFragment\n{\n\tGENERATED_BODY()\n\tTWeakObjectPtr<USceneComponent> Component;\n};\n\nUSTRUCT()\nstruct FMassSceneComponentLocationCopyToMassTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\nUCLASS()\nclass MASSACTORS_API UMassSceneComponentLocationToMassTranslator : public UMassTranslator\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassSceneComponentLocationToMassTranslator();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};\n\n\nUSTRUCT()\nstruct FMassSceneComponentLocationCopyToActorTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\nUCLASS()\nclass MASSACTORS_API UMassSceneComponentLocationToActorTranslator : public UMassTranslator\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassSceneComponentLocationToActorTranslator();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};",
      "lines": 58
    },
    {
      "file_path": "MassGameplay\\MassActors\\Public\\Translators\\MassTranslators_BehaviorTree.h",
      "extension": ".h",
      "size_bytes": 822,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassTranslator.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassTranslators_BehaviorTree.generated.h\"\n\n//////////////////////////////////////////////////////////////////////////\nclass UBehaviorTreeComponent;\n\nUSTRUCT()\nstruct FDataFragment_BehaviorTreeComponentWrapper : public FObjectWrapperFragment\n{\n\tGENERATED_BODY()\n\tTWeakObjectPtr<UBehaviorTreeComponent> Component;\n};\n\nUCLASS()\nclass MASSACTORS_API UMassTranslator_BehaviorTree : public UMassTranslator\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassTranslator_BehaviorTree();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override {}\n\n\tFMassEntityQuery EntityQuery;\n};\n",
      "lines": 32
    },
    {
      "file_path": "MassGameplay\\MassCommon\\Public\\IMassCommonModule.h",
      "extension": ".h",
      "size_bytes": 1113,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n * The public interface to this module.  In most cases, this interface is only public to sibling modules \n * within this plugin.\n */\nclass IMassCommonModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t * Singleton-like access to this module's interface.  This is just for convenience!\n\t * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t *\n\t * @return Returns singleton instance, loading the module on demand if needed\n\t */\n\tstatic inline IMassCommonModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassCommonModule>( \"MassCommon\" );\n\t}\n\n\t/**\n\t * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t *\n\t * @return True if the module is loaded and ready to use\n\t */\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassCommon\" );\n\t}\n};\n\n",
      "lines": 40
    },
    {
      "file_path": "MassGameplay\\MassCommon\\Public\\MassCommonFragments.h",
      "extension": ".h",
      "size_bytes": 1186,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_2\n#include \"AI/Navigation/NavigationTypes.h\"\n#endif //UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_2\n#include \"MassCommonFragments.generated.h\"\n\n\nUSTRUCT()\nstruct MASSCOMMON_API FTransformFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tFTransformFragment() = default;\n\tFTransformFragment(const FTransform& InTransform) \n\t: Transform(InTransform)\n\t{}\n\n\tconst FTransform& GetTransform() const { return Transform; }\n\tvoid SetTransform(const FTransform& InTransform) { Transform = InTransform; }\n\tFTransform& GetMutableTransform() { return Transform; }\n\nprotected:\n\tUPROPERTY(Transient)\n\tFTransform Transform;\n};\n\nUSTRUCT()\nstruct MASSCOMMON_API FAgentRadiusFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\tUPROPERTY(EditAnywhere, Category = \"\")\n\tfloat Radius = 40.f;\n};\n\n/** This is a common type for all the wrappers pointing at UObjects used to copy data from them or set data based on\n *\tMass simulation..\n */\nUSTRUCT()\nstruct FObjectWrapperFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n};\n",
      "lines": 46
    },
    {
      "file_path": "MassGameplay\\MassCommon\\Public\\MassCommonTypes.h",
      "extension": ".h",
      "size_bytes": 6979,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassProcessingTypes.h\"\n#include \"StructUtils/InstancedStruct.h\"\n#include \"SequentialID.h\"\n#include \"MassCommonTypes.generated.h\"\n\n#define WITH_MASSGAMEPLAY_DEBUG (!(UE_BUILD_SHIPPING || UE_BUILD_SHIPPING_WITH_EDITOR || UE_BUILD_TEST) && WITH_MASSENTITY_DEBUG && 1)\n\nclass UStaticMesh;\nclass UMaterialInterface;\n\nnamespace UE::Mass::ProcessorGroupNames\n{\n\tconst FName UpdateWorldFromMass = FName(TEXT(\"UpdateWorldFromMass\"));\n\tconst FName SyncWorldToMass = FName(TEXT(\"SyncWorldToMass\"));\n\tconst FName Behavior = FName(TEXT(\"Behavior\"));\n\tconst FName Tasks = FName(TEXT(\"Tasks\"));\n\tconst FName Avoidance = FName(TEXT(\"Avoidance\"));\n\tconst FName Movement = FName(TEXT(\"Movement\"));\n}\n\nUSTRUCT()\nstruct FMassNetworkID : public FSequentialIDBase\n{\n\tGENERATED_BODY()\n\n\tFMassNetworkID() = default;\n\texplicit FMassNetworkID(uint32 InID) : FSequentialIDBase(InID) {}\n};\n\n/** Float encoded in int16, 1cm accuracy. */\nUSTRUCT()\nstruct MASSCOMMON_API FMassInt16Real\n{\n\tGENERATED_BODY()\n\n\tFMassInt16Real() = default;\n\t\n\texplicit FMassInt16Real(const float InValue)\n\t{\n\t\tSet(InValue);\n\t}\n\t\n\tvoid Set(const float InValue)\n\t{\n\t\tValue = (int16)FMath::Clamp(FMath::RoundToInt32(InValue), -(int32)MAX_int16, (int32)MAX_int16);\n\t}\n\n\tfloat Get() const\n\t{\n\t\treturn (float)Value;\n\t}\n\n\tbool operator<(const FMassInt16Real RHS) const { return Value < RHS.Value; }\n\tbool operator<=(const FMassInt16Real RHS) const { return Value <= RHS.Value; }\n\tbool operator>(const FMassInt16Real RHS) const { return Value > RHS.Value; }\n\tbool operator>=(const FMassInt16Real RHS) const { return Value >= RHS.Value; }\n\tbool operator==(const FMassInt16Real RHS) const { return Value == RHS.Value; }\n\tbool operator!=(const FMassInt16Real RHS) const { return Value != RHS.Value; }\n\t\nprotected:\n\tUPROPERTY(Transient)\n\tint16 Value = 0;\n};\n\n/** Float encoded in int16, 10cm accuracy. */\nUSTRUCT()\nstruct MASSCOMMON_API FMassInt16Real10\n{\n\tGENERATED_BODY()\n\n\tstatic constexpr float Scale = 0.1f;\n\t\n\tFMassInt16Real10() = default;\n\t\n\texplicit FMassInt16Real10(const float InValue)\n\t{\n\t\tSet(InValue);\n\t}\n\t\n\tvoid Set(const float InValue)\n\t{\n\t\tValue = (int16)FMath::Clamp(FMath::RoundToInt32(InValue * Scale), -(int32)MAX_int16, (int32)MAX_int16);\n\t}\n\n\tfloat Get() const\n\t{\n\t\treturn (float)Value / Scale;\n\t}\n\n\tbool operator<(const FMassInt16Real10 RHS) const { return Value < RHS.Value; }\n\tbool operator<=(const FMassInt16Real10 RHS) const { return Value <= RHS.Value; }\n\tbool operator>(const FMassInt16Real10 RHS) const { return Value > RHS.Value; }\n\tbool operator>=(const FMassInt16Real10 RHS) const { return Value >= RHS.Value; }\n\tbool operator==(const FMassInt16Real10 RHS) const { return Value == RHS.Value; }\n\tbool operator!=(const FMassInt16Real10 RHS) const { return Value != RHS.Value; }\n\nprotected:\n\tUPROPERTY(Transient)\n\tint16 Value = 0;\n};\n\n/** Vector which components are in range [-1..1], encoded in signed bytes. */\nUSTRUCT()\nstruct MASSCOMMON_API FMassSnorm8Vector\n{\n\tGENERATED_BODY()\n\n\tstatic constexpr float Scale = (float)MAX_int8;   \n\n\tFMassSnorm8Vector() = default;\n\t\n\texplicit FMassSnorm8Vector(const FVector& InVector)\n\t{\n\t\tSet(InVector);\n\t}\n\t\n\tvoid Set(const FVector& InVector)\n\t{\n\t\tX = (int8)FMath::Clamp(FMath::RoundToInt32(InVector.X * Scale), -(int32)MAX_int8, (int32)MAX_int8);\n\t\tY = (int8)FMath::Clamp(FMath::RoundToInt32(InVector.Y * Scale), -(int32)MAX_int8, (int32)MAX_int8);\n\t\tZ = (int8)FMath::Clamp(FMath::RoundToInt32(InVector.Z * Scale), -(int32)MAX_int8, (int32)MAX_int8);\n\t}\n\n\tFVector Get() const\n\t{\n\t\treturn FVector(X / Scale, Y / Scale, Z / Scale);\n\t}\n\nprotected:\n\tUPROPERTY(Transient)\n\tint8 X = 0;\n\n\tUPROPERTY(Transient)\n\tint8 Y = 0;\n\n\tUPROPERTY(Transient)\n\tint8 Z = 0;\n};\n\n/** Vector2D which components are in range [-1..1], encoded in signed bytes. */\nUSTRUCT()\nstruct MASSCOMMON_API FMassSnorm8Vector2D\n{\n\tGENERATED_BODY()\n\n\tstatic constexpr float Scale = (float)MAX_int8;\n\n\tFMassSnorm8Vector2D() = default;\n\n\texplicit FMassSnorm8Vector2D(const FVector2D& InVector)\n\t{\n\t\tSet(InVector);\n\t}\n\t\n\texplicit FMassSnorm8Vector2D(const FVector& InVector)\n\t{\n\t\tSet(FVector2D(InVector));\n\t}\n\n\tvoid Set(const FVector2D& InVector)\n\t{\n\t\tX = (int8)FMath::Clamp(FMath::RoundToInt32(InVector.X * Scale), -(int32)MAX_int8, (int32)MAX_int8);\n\t\tY = (int8)FMath::Clamp(FMath::RoundToInt32(InVector.Y * Scale), -(int32)MAX_int8, (int32)MAX_int8);\n\t}\n\n\tFVector2D Get() const\n\t{\n\t\treturn FVector2D(X / Scale, Y / Scale);\n\t}\n\n\tFVector GetVector(const float InZ = 0.0f) const\n\t{\n\t\treturn FVector(X / Scale, Y / Scale, InZ);\n\t}\n\t\nprotected:\n\tUPROPERTY(Transient)\n\tint8 X = 0;\n\n\tUPROPERTY(Transient)\n\tint8 Y = 0;\n};\n\n/** Real in range [0..1], encoded in signed bytes. */\nUSTRUCT()\nstruct MASSCOMMON_API FMassUnorm8Real\n{\n\tGENERATED_BODY()\n\n\tstatic constexpr float Scale = MAX_uint8;\n\n\tFMassUnorm8Real() = default;\n\n\texplicit FMassUnorm8Real(const float InValue)\n\t{\n\t\tSet(InValue);\n\t}\n\n\tvoid Set(const float InValue)\n\t{\n\t\tValue = (int8)FMath::Clamp(FMath::RoundToInt32(InValue * Scale), 0, (int32)MAX_uint8);\n\t}\n\n\tfloat Get() const\n\t{\n\t\treturn (Value / Scale);\n\t}\n\nprotected:\n\tUPROPERTY(Transient)\n\tuint8 Value = 0;\n};\n\n/** Vector encoded in int16, 1cm accuracy. */\nUSTRUCT()\nstruct MASSCOMMON_API FMassInt16Vector\n{\n\tGENERATED_BODY()\n\n\tFMassInt16Vector() = default;\n\tFMassInt16Vector(const FVector& InVector)\n\t{\n\t\tSet(InVector);\n\t}\n\t\n\tvoid Set(const FVector& InVector)\n\t{\n\t\tX = (int16)FMath::Clamp(FMath::RoundToInt32(InVector.X), -(int32)MAX_int16, (int32)MAX_int16);\n\t\tY = (int16)FMath::Clamp(FMath::RoundToInt32(InVector.Y), -(int32)MAX_int16, (int32)MAX_int16);\n\t\tZ = (int16)FMath::Clamp(FMath::RoundToInt32(InVector.Z), -(int32)MAX_int16, (int32)MAX_int16);\n\t}\n\n\tFVector Get() const\n\t{\n\t\treturn FVector(X, Y, Z);\n\t}\n\nprotected:\n\tUPROPERTY(Transient)\n\tint16 X = 0;\n\n\tUPROPERTY(Transient)\n\tint16 Y = 0;\n\n\tUPROPERTY(Transient)\n\tint16 Z = 0;\n};\n\n/** Vector2D encoded in int16, 1cm accuracy. */\nUSTRUCT()\nstruct MASSCOMMON_API FMassInt16Vector2D\n{\n\tGENERATED_BODY()\n\n\tFMassInt16Vector2D() = default;\n\tFMassInt16Vector2D(const FVector2D& InVector)\n\t{\n\t\tSet(InVector);\n\t}\n\tFMassInt16Vector2D(const FVector& InVector)\n\t{\n\t\tSet(FVector2D(InVector));\n\t}\n\t\n\tvoid Set(const FVector2D& InVector)\n\t{\n\t\tX = (int16)FMath::Clamp(FMath::RoundToInt32(InVector.X), -(int32)MAX_int16, (int32)MAX_int16);\n\t\tY = (int16)FMath::Clamp(FMath::RoundToInt32(InVector.Y), -(int32)MAX_int16, (int32)MAX_int16);\n\t}\n\n\tFVector2D Get() const\n\t{\n\t\treturn FVector2D(X, Y);\n\t}\n\n\tFVector GetVector(const float InZ = 0.0f) const\n\t{\n\t\treturn FVector(X, Y, InZ);\n\t}\n\nprotected:\n\tUPROPERTY(Transient)\n\tint16 X = 0;\n\n\tUPROPERTY(Transient)\n\tint16 Y = 0;\n};\n",
      "lines": 292
    },
    {
      "file_path": "MassGameplay\\MassCommon\\Public\\MassCommonUtils.h",
      "extension": ".h",
      "size_bytes": 1536,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassCommonTypes.h\"\n#include \"Containers/Array.h\"\n#include \"Containers/Queue.h\"\n\nnamespace UE::Mass::Utils\n{\n\t/** \n\t * Creates a TArray of entities based on the given EntitiesQueue. Note that it's the caller's responsibility to \n\t * ensure EntitiesCount > 0, otherwise the function will fail a check (with explosive results).\n\t */\n\tMASSCOMMON_API TArray<FMassEntityHandle> EntityQueueToArray(TQueue<FMassEntityHandle, EQueueMode::Mpsc>& EntitiesQueue, const int32 EntitiesCount);\n\n#if !UE_BUILD_SHIPPING\n\n\t/**\n\t * If this is true, then the mass systems should strive to be as deterministic as possible, this will also enable the fixed random seed\n\t * Currently maps to FApp::bUseFixedSeed\n\t */\n\tMASSCOMMON_API bool IsDeterministic();\n\n\t/**\n\t * If IsDeterministic() returns true, then this function will return the value of ai.massrepresentation.OverrideRandomSeed in place of InSeed\n\t */\n\tMASSCOMMON_API int32 OverrideRandomSeedForTesting(int32 InSeed);\n\n\t/**\n\t * If IsDeterministic() returns true, then this function will return the value of ai.massrepresentation.OverrideRandomSeed in place of FMath::Rand()\n\t */\n\tMASSCOMMON_API int32 GenerateRandomSeed();\n\n#else\n\n\tFORCEINLINE constexpr bool IsDeterministic() { return false; }\n\n\tFORCEINLINE int32 OverrideRandomSeedForTesting(int32 InSeed) { return InSeed; }\n\n\tFORCEINLINE int32 GenerateRandomSeed() { return FMath::Rand(); }\n#endif\n\n} // namespace UE::Mass::Utils",
      "lines": 44
    },
    {
      "file_path": "MassGameplay\\MassCommon\\Public\\MassGameplaySettings.h",
      "extension": ".h",
      "size_bytes": 473,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassSettings.h\"\n#include \"MassGameplaySettings.generated.h\"\n\n\nUCLASS(config = Mass, defaultconfig, DisplayName = \"Mass Gameplay\")\nclass MASSCOMMON_API UMassGameplaySettings : public UMassModuleSettings\n{\n\tGENERATED_BODY()\n\npublic:\n\n\tUPROPERTY(EditAnywhere, config, Category = Debug, meta = (ConsoleVariable = \"mass.debug.VLogSpawnLocations\"))\n\tbool bLogSpawnLocations = true;\n};\n",
      "lines": 18
    },
    {
      "file_path": "MassGameplay\\MassCommon\\Public\\RandomSequence.h",
      "extension": ".h",
      "size_bytes": 3000,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreTypes.h\"\n\n/**\n * Helper functions to get a random number in a sequence based on Fibonacci hashing.\n * The random numbers are uniformly distributed.\n *\n * In contrast to FRandomStream, where each call to a random function will return new random number,\n * these functions will always return the same value for the same input.\n * That is UE::RandomSequence::FRand(42) is always 0.575462.\n *\n * This is useful for randomizing behaviors or appearances, where an entity index can be used to get a random value,\n * without having to store the actual value:\n *\n *   const float PreferredSpeed = UE::RandomSequence::FRandRange(EntityId.Index, MinSpeed, MaxSpeed);\n * \n * If multiple values are needed, different parts of the sequence can be used by offsetting the index:\n *\n *   const int32 HatIndex = UE::RandomSequence::RandHelper(EntityId.Index + 31, 0, Hats.Num());\n *   const int32 GroomIndex = UE::RandomSequence::RandHelper(EntityId.Index + 1021, Grooms.Num());\n */\n\nnamespace UE::RandomSequence\n{\n\t/**\n\t * @return 32 bit fibonacci hash at specified index.\n\t */\n\tFORCEINLINE uint32 FibonacciHash(const int32 SeqIndex)\n\t{\n\t\tconstexpr uint32 K = 2654435769u; // 2^32 / phi (golden ratio)\n\t\t// Offset the sequence by 1, so that index 0 is not always 0.\n\t\treturn (uint32)(SeqIndex + 1) * K;\n\t}\n\t\n\t/**\n\t * Helper function to return random float.\n\t * @return A random number in [0..1]\n\t */\n\tFORCEINLINE float FRand(const int32 SeqIndex)\n\t{\n\t\tfloat Result;\n\t\t*(uint32*)&Result = 0x3F800000U | (FibonacciHash(SeqIndex) >> 9);\n\t\treturn Result - 1.0f; \n\t}\n\n\t/**\n\t * Helper function to return random int on specified range.\n\t * @return A random number in [0..A)\n\t */\n\tFORCEINLINE int32 RandHelper(const int32 SeqIndex, const int32 A)\n\t{\n\t\treturn (int32)(((int64)FibonacciHash(SeqIndex) * (int64)A) >> 32);\n\t}\n\n\t/** \n\t * Helper function to return random int in specified range.\n\t * @return A random number >= Min and <= Max\n\t */\n\tFORCEINLINE int32 RandRange(const int32 SeqIndex, const int32 InMin, const int32 InMax)\n\t{\n\t\tconst int32 Range = (InMax - InMin) + 1;\n\t\treturn InMin + RandHelper(SeqIndex, Range);\n\t}\n\t\n\t/** \n\t * Helper function to return random float in specified range.\n\t * @return A random number >= Min and <= Max\n\t */\n\tFORCEINLINE float FRandRange(const int32 SeqIndex, const float InMin, const float InMax)\n\t{\n\t\treturn InMin + (InMax - InMin) * FRand(SeqIndex);\n\t}\n\n\t/** \n\t * Helper function to return random float in specified range.\n\t * @return A random number >= Min and <= Max\n\t */\n\tFORCEINLINE float RandRange(const int32 SeqIndex, const float InMin, const float InMax)\n\t{\n\t\treturn FRandRange(SeqIndex, InMin, InMax);\n\t}\n\n\tUE_DEPRECATED(5.4, \"Please use the correctly spelled version FibonacciHash()\")\n\tFORCEINLINE uint32 FibocciHash(const int32 SeqIndex)\n\t{\n\t\treturn FibonacciHash(SeqIndex);\n\t}\n}; // UE::RandomSequence",
      "lines": 91
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Public\\MassEQS.h",
      "extension": ".h",
      "size_bytes": 217,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Modules/ModuleManager.h\"\n\nDECLARE_LOG_CATEGORY_EXTERN(LogMassEQS, Log, All);\n\nclass FMassEQSModule : public IModuleInterface\n{\n};\n",
      "lines": 11
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Public\\MassEQSBlueprintLibrary.h",
      "extension": ".h",
      "size_bytes": 4424,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Kismet/BlueprintFunctionLibrary.h\"\n\n#include \"MassEntityTypes.h\"\n#include \"MassEQSTypes.h\"\n#include \"MassEQSUtils.h\"\n\n#include \"MassEQSBlueprintLibrary.generated.h\"\n\nclass UEnvQueryInstanceBlueprintWrapper;\nstruct FEnvQueryResult;\n\n/** Wrapper for Blueprints to be able to parse MassEntityInfo to use functions defined in UMassEQSBlueprintLibrary */\nUSTRUCT(Blueprintable, BlueprintType, meta = (DisplayName = \"Mass Entity Info\"))\nstruct FMassEnvQueryEntityInfoBlueprintWrapper\n{\n    GENERATED_BODY()\n\npublic:\n\tFMassEnvQueryEntityInfoBlueprintWrapper() = default;\n\tFMassEnvQueryEntityInfoBlueprintWrapper(FMassEnvQueryEntityInfo InEntityInfo)\n\t\t: EntityInfo(InEntityInfo)\n\t{\n\t}\n\n\tFORCEINLINE FVector GetCachedEntityPosition() const { return EntityInfo.CachedTransform.GetLocation(); }\n\tFORCEINLINE FMassEntityHandle GetEntityHandle() const { return EntityInfo.EntityHandle; }\n\tFORCEINLINE void SetEntityHandle(FMassEntityHandle Handle) { EntityInfo.EntityHandle = Handle; }\n\n\tconst FMassEnvQueryEntityInfo& GetEntityInfo() const { return EntityInfo; };\n\tinline bool operator==(const FMassEnvQueryEntityInfoBlueprintWrapper& Other) const { return GetEntityInfo() == Other.GetEntityInfo(); }\n\nprivate:\n\tFMassEnvQueryEntityInfo EntityInfo;\n\n};\n\n/** Function library for interfacing with EntityInfo inside blueprints. */\nUCLASS()\nclass UMassEQSBlueprintLibrary : public UBlueprintFunctionLibrary\n{\n    GENERATED_UCLASS_BODY()\n\npublic:\n\t\n\t//----------------------------------------------------------------------//\n\t// Commands\n\t//----------------------------------------------------------------------//\n\n\t/** Sends the input Signal to the Entity defined by EntityInfo.EntityHandle using the UMassSignalSubsystem. */\n\tUFUNCTION(BlueprintCallable, Category = \"MassEnvQuery|Commands\")\n\tstatic void SendSignalToEntity(const AActor* Owner, const FMassEnvQueryEntityInfoBlueprintWrapper& EntityInfo, const FName Signal);\n\n\t//----------------------------------------------------------------------//\n\t// Utils\n\t//----------------------------------------------------------------------//\n\n\tUFUNCTION(BlueprintCallable, BlueprintPure, Category = \"MassEnvQuery|Utils\")\n\tstatic FORCEINLINE FString EntityToString(const FMassEnvQueryEntityInfoBlueprintWrapper& EntityInfo){ return EntityInfo.GetEntityHandle().DebugGetDescription(); }\n\n\tUFUNCTION(BlueprintCallable, BlueprintPure, Category = \"MassEnvQuery|Utils\")\n\tstatic FORCEINLINE FVector GetCachedEntityPosition(const FMassEnvQueryEntityInfoBlueprintWrapper& EntityInfo) { return EntityInfo.GetCachedEntityPosition(); }\n\n\tUFUNCTION(BlueprintCallable, BlueprintPure, Category = \"MassEnvQuery|Utils\")\n\tstatic FVector GetCurrentEntityPosition(const AActor* Owner, const FMassEnvQueryEntityInfoBlueprintWrapper& EntityInfo);\n\n\t/** Custom comparison function, as the Blueprint Equals did not seem to work. */\n\tUFUNCTION(BlueprintCallable, BlueprintPure, Category = \"MassEnvQuery|Utils\")\n\tstatic FORCEINLINE bool EntityComparison(const FMassEnvQueryEntityInfoBlueprintWrapper& A, const FMassEnvQueryEntityInfoBlueprintWrapper& B) { return A == B; }\n\n\t/** Custom array-contains function, as the Blueprint version did not seem to work. */\n\tUFUNCTION(BlueprintCallable, BlueprintPure, Category = \"MassEnvQuery|Utils\")\n\tstatic bool ContainsEntity(const TArray<FMassEnvQueryEntityInfoBlueprintWrapper>& EntityList, const FMassEnvQueryEntityInfoBlueprintWrapper& EntityInfo);\n\n\t/** Outputs an array filled with resulting EntityInfos. Note that it makes sense only if ItemType is a EnvQueryItemType_MassEntityHandle-derived type. */\n\tUFUNCTION(BlueprintCallable, Category = \"AI|EQS\")\n\tstatic TArray<FMassEnvQueryEntityInfoBlueprintWrapper> GetEnviromentQueryResultAsEntityInfo(const UEnvQueryInstanceBlueprintWrapper* QueryInstance);\n\nprivate:\n\t/** Get result and immediately convert to EntityInfoBlueprintWrapper to skip an extra copy step */\n\tstatic FMassEnvQueryEntityInfoBlueprintWrapper GetItemAsEntityInfoBPWrapper(const FEnvQueryResult* QueryResult, int32 Index);\n\n\t/** Get result array and convert each EntityInfo to EntityInfoBlueprintWrapper along the way to skip extra copy steps */\n\tstatic void GetAllAsEntityInfoBPWrappers(const FEnvQueryResult* QueryResult, TArray<FMassEnvQueryEntityInfoBlueprintWrapper>& OutEntityInfo);\n};",
      "lines": 88
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Public\\MassEQSSubsystem.h",
      "extension": ".h",
      "size_bytes": 3626,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Containers/Queue.h\"\n\n#include \"EnvironmentQuery/EnvQueryNode.h\"\n#include \"MassEQSTypes.h\"\n\n#include \"MassSubsystemBase.h\"\n\n#include \"MassEQSSubsystem.generated.h\"\n\n/**\n * Subsystem for sending UMassEQSGenerator and UMassEQSTest requests to Mass Processors, \n * and for returning the results back to EQS. \n */\nUCLASS()\nclass UMassEQSSubsystem : public UMassSubsystemBase\n{\n\tGENERATED_BODY()\n\t/** Queue holding UniquePtrs to the data required for each Request */\n\tusing FRequestQueue = TQueue<TUniquePtr<FMassEQSRequestData>>;\n\npublic:\n\t/** Push new Request into RequestQueue */\n\tFMassEQSRequestHandle PushRequest(const FEnvQueryInstance& QueryInstance, const int32 RequestQueueIndex, TUniquePtr<FMassEQSRequestData>&& Request);\n\n\t/** Dequeue next Request off the RequestQueue, removing it from the queue, and transferring ownership of UniquePtr */\n\tTUniquePtr<FMassEQSRequestData> PopRequest(const int32 RequestQueueIndex);\n\n\t/** Send results from a finished/processed request to be stored in this subsystem */\n\tvoid SubmitResults(FMassEQSRequestHandle RequestHandle, TUniquePtr<FMassEQSRequestData>&& Result);\n\t/** Try to Acquire the results from a request from the QueryInstance, if it is available. */\n\tTUniquePtr<FMassEQSRequestData> TryAcquireResults(FMassEQSRequestHandle RequestHandle);\n\n\t/** Returns the index into RequestQueues for the input class */\n\tint32 GetRequestQueueIndex(TSubclassOf<UEnvQueryNode> RequestClass);\n\n\t/**\n\t * If Request in RequestQueue -> Remove from Queue\n\t * If Result in Results -> Remove from Results\n\t * Otherwise, Request is currently being processed -> Log this ID as Cancelled, and ignore result when submitted.\n\t */\n\tvoid CancelRequest(FMassEQSRequestHandle RequestHandle);\n\n\t/** Finalization step for Handle Management */\n\t void FinalizeRequest(FMassEQSRequestHandle RequestHandle);\n\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\tvirtual void Deinitialize() override;\n\nprotected:\n\t/**\n\t * Mapping from Class of requester, to index into RequestQueues.\n\t * Each Class that extends UMassEQSGenerator or UMassEQSTest \n\t * can be a requester, this will store a Queue for each of these types.\n\t * @see PostInitialize()\n\t */\n\tTMap<TSubclassOf<UEnvQueryNode>, int32> RequestQueueLookup = {};\n\t/**\n\t * Array of Queues holding each Request. \n\t * TQueue does not support copy/assignment, which TMap requires.\n\t * This is the reason the TQueues are stored in a separate Array.\n\t */\n\tTArray<FRequestQueue> RequestQueues = {};\n\t/** \n\t * The detector only guards the extension of RequestQueues array. Modifying specific elements is not guarded since \n\t * those are a thread safe queues.\n\t */\n\tUE_MT_DECLARE_RW_ACCESS_DETECTOR(RequestAccessDetector);\n\n\t/** Holds results for finished Query */\n\tTMap<FMassEQSRequestHandle, TUniquePtr<FMassEQSRequestData>> Results;\n\tUE_MT_DECLARE_RW_ACCESS_DETECTOR(ResultAccessDetector);\n\n\tFIndexedHandleManagerBase<FMassEQSRequestHandle, int32, uint32, true> HandleManager;\n\n\t/** \n\t * Holds all RequestHandles of requests who have been canceled, and not yet submitted.\n\t * Once this request is submitted, we will ignore the results.\n\t */\n\tTArray<FMassEQSRequestHandle> CancelledRequests;\n\n\t/** Used to ignore request cancellation after subsystem is De-Initialized */\n\tbool bIsInitialized = false;\n};\n\ntemplate<>\nstruct TMassExternalSubsystemTraits<UMassEQSSubsystem> final\n{\n\tenum\n\t{\n\t\tGameThreadOnly = false,\n\t\tThreadSafeRead = true,\n\t\tThreadSafeWrite = true,\n\t};\n};",
      "lines": 98
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Public\\MassEQSTypes.h",
      "extension": ".h",
      "size_bytes": 5080,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"IndexedHandle.h\"\n#include \"MassEntityTypes.h\"\n\n#include \"MassEQSTypes.generated.h\"\n\nstruct FEnvQueryInstance;\nstruct FMassEQSRequestHandle;\nclass UMassEQSSubsystem;\n\n/** Contents of EnvQueryItemType_MassEntityHandle\n *  @see EnvQueryItemType_MassEntityHandle\n */\nUSTRUCT()\nstruct FMassEnvQueryEntityInfo\n{\n\tGENERATED_BODY()\n\n\tFMassEnvQueryEntityInfo() = default;\n\tFMassEnvQueryEntityInfo(int32 Index, int32 SerialNumber, const FTransform& Transform);\n\n\tFMassEntityHandle EntityHandle;\n\t/** Cached Transform from time of acquisition allows EnvQueryItemType_MassEntityHandle to implement UEnvQueryItemType_VectorBase */\n\tFTransform CachedTransform;\n\n\tinline bool operator==(const FMassEnvQueryEntityInfo& Other) const { return EntityHandle == Other.EntityHandle; }\n};\n\n/**\n * Provides a Unique Handle for incoming MassEQS Requests\n */\nUSTRUCT()\nstruct FMassEQSRequestHandle : public FIndexedHandleBase\n{\n\tGENERATED_BODY()\n\tFMassEQSRequestHandle() = default;\n\tFMassEQSRequestHandle(int32 InIndex, uint32 InSerialNumber) : FIndexedHandleBase(InIndex, InSerialNumber)\n\t{\n\t}\n\n\tFString ToString() const;\n\n\tstatic FMassEQSRequestHandle Invalid;\n};\n\n/** To be extended to hold any data which needs to be transferred between EQS and Mass for a given Request. */\nstruct FMassEQSRequestData\n{\n\tFMassEQSRequestData() = default;\n\tFMassEQSRequestData(FMassEQSRequestHandle Handle)\n\t\t: RequestHandle(Handle)\n\t{\n\t}\n\n\t/** Unique ID that MassEQSSubsystem's HandleManager has assigned to this Request */\n\tFMassEQSRequestHandle RequestHandle = FMassEQSRequestHandle::Invalid;\n\n\t/** EntityHandles to run this request on. Used for Tests. */\n\tTArray<FMassEntityHandle> EntityHandles;\n};\n\n/** Interface for sending and receiving EQS Requests to and from MassEQSSubsystem */\nUINTERFACE()\nclass UMassEQSRequestInterface : public UInterface\n{\n\tGENERATED_BODY()\n};\n\n/** Interface for sending and receiving EQS Requests to and from MassEQSSubsystem utilizing a MassEQSRequestHandler */\nclass IMassEQSRequestInterface\n{\n\tGENERATED_BODY()\npublic:\n\n\t/**\n\t * Stores relevant information for managing requests sent to MassEQSSubsystem.\n\t * Provides generic functionality for Sending, Receiving, and Canceling these requests.\n\t * Any class who implements IMassEQSRequestInterface should have one of these.\n\t */\n\tstruct FMassEQSRequestHandler\n\t{\n\t\t/**\n\t\t * Called when an EnvQueryInstance is trying to run a Generator or Test who implements this.\n\t\t * If this Request has not yet been sent (IE. RequestID == 0u) then we will send this request\n\t\t * Otherwise, if this Request was already sent (IE. RequestID > 0u) then we will call TryAcquireResults on the input MassEnvRequestInterface.\n\t\t * @param QueryInstance - The EnvQueryInstance sending/receiving this request\n\t\t * @param MassEQSRequestInterface - The Interface used to call this,\n\t\t * @return A unique ID that the QueryInstance can hold on to in order to later retrieve this request result.\n\t\t */\n\t\tvoid SendOrRecieveRequest(FEnvQueryInstance& QueryInstance, const IMassEQSRequestInterface& MassEQSRequestInterface);\n\n\t\t/** Cancel request if currently ongoing. */\n\t\tvoid CancelRequest() const;\n\n\t\t/** Reset RequestID to 0 and RequestStartTime to -1.f */\n\t\tvoid Reset();\n\n\t\tFORCEINLINE bool IsPendingResults() const { return RequestHandle.IsValid(); }\n\n\t\t// Handle for request in MassEQSSubsystem.\n\t\tFMassEQSRequestHandle RequestHandle = FMassEQSRequestHandle::Invalid;\n\t\t// Cached MassEQSSubsystem pointer for interacting with this subsystem\n\t\tTObjectPtr<UMassEQSSubsystem> MassEQSSubsystem = nullptr;\n\t\t// The point in time that an ongoing request was sent, -1 if none have been sent.\n\t\tfloat RequestStartTime = -1.f;\n\t\t// The max amount of time allowed for this request. CancelRequest will be called if this is used after this time has elapsed.\n\t\tfloat MaxRequestTime = DefaultMaxRequestTime;\n\n\t\tint32 CachedRequestQueueIndex = -1;\n\n\t\tFMassEQSRequestHandler() = default;\n\t\t~FMassEQSRequestHandler();\n\n\tprotected:\n\t\tstatic constexpr float DefaultMaxRequestTime = 5.f;\n\t};\n\n\n\t/**\n\t * Called inside RequestProcessing, in order to create a copy of the relevant data for this Request.\n\t * @param QueryInstance - The EnvQueryInstance that owns this Generator\n\t * @return A UniquePtr to the Data-Copy created.\n\t */\n\tvirtual TUniquePtr<FMassEQSRequestData> GetRequestData(FEnvQueryInstance& QueryInstance) const = 0;\n\n\t/**\n\t * Get StaticClass of the ImplementingClass. Implementer of this Interface must provide this so we can use\n\t * the correct StaticClass inside RequestProcessing.\n\t * Implementation should just be StaticClass() called in derived class.\n\t */\n\tvirtual UClass* GetRequestClass() const = 0;\n\n\t/**\n\t * Called when EnvQueryInstance is checking to try to complete its request.\n\t * @param QueryInstance - The EnvQueryInstance that owns this Generator\n\t */\n\tvirtual bool TryAcquireResults(FEnvQueryInstance& QueryInstance) const = 0;\n};",
      "lines": 141
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Public\\MassEQSUtils.h",
      "extension": ".h",
      "size_bytes": 1891,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"HAL/Platform.h\"\n#include \"MassEQSTypes.h\"\n\nstruct FEnvQueryResult;\nstruct FEnvQueryInstance;\nstruct FMassEnvQueryEntityInfo;\nstruct FMassEntityHandle;\nstruct FMassEntityHandle;\nstruct FMassEQSRequestData;\n\n/** Holds Utility functions for Mass EQS Needs */\nstruct FMassEQSUtils\n{\n\n\t/** Returns the Item stored in QueryInstance/QueryResult Items[Index] as EntityInfo */\n\tstatic FMassEnvQueryEntityInfo GetItemAsEntityInfo(const FEnvQueryInstance& QueryInstance, int32 Index);\n\tstatic FMassEnvQueryEntityInfo GetItemAsEntityInfo(const FEnvQueryResult& QueryResult, int32 Index);\n\n\t/** Returns all Items stored in QueryInstance/QueryResult as EntityInfo */\n\tstatic void GetAllAsEntityInfo(const FEnvQueryInstance& QueryInstance, TArray<FMassEnvQueryEntityInfo>& OutEntityInfo);\n\tstatic void GetAllAsEntityInfo(const FEnvQueryResult& QueryResult, TArray<FMassEnvQueryEntityInfo>& OutEntityInfo);\n\n\t/** Extracts all EntityHandles out of an array of EntityInfo */\n\tstatic void GetEntityHandles(const TArray<FMassEnvQueryEntityInfo>& EntityInfo, TArray<FMassEntityHandle>& OutHandles);\n\tstatic void GetAllAsEntityHandles(const FEnvQueryInstance& QueryInstance, TArray<FMassEntityHandle>& OutHandles);\n\n\t/**\n\t * Used in MassEnvQueryProcessors, to cast generic FMassEQSRequestData to its corresponding child class.\n\t * If InPtr is not null, then this Cast should never fail.\n\t */\n\ttemplate<typename RequestDataType>\n\tstatic FORCEINLINE RequestDataType* TryAndEnsureCast(TUniquePtr<FMassEQSRequestData>& InPtr)\n\t{\n\t\tif (!InPtr)\n\t\t{\n\t\t\treturn nullptr;\n\t\t}\n\n\t\tRequestDataType* OutPtr = static_cast<RequestDataType*>(InPtr.Get());\n\t\tensureMsgf(OutPtr, TEXT(\"RequestData was pushed to MassEQSSubsystem, but corresponding child RequestData was not found.\"));\n\n\t\treturn OutPtr;\n\t}\n};\n",
      "lines": 48
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Public\\Generators\\MassEnvQueryGenerator.h",
      "extension": ".h",
      "size_bytes": 1539,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"EnvironmentQuery/EnvQueryGenerator.h\"\n#include \"MassEQSTypes.h\"\n\n#include \"MassEnvQueryGenerator.generated.h\"\n\n/** Generator that will send its work to MassEQSSubsystem in order to be processed in a Mass Processor */\nUCLASS(EditInlineNew, Abstract, meta = (Category = \"Generators\"), MinimalAPI)\nclass UMassEnvQueryGenerator : public UEnvQueryGenerator, public IMassEQSRequestInterface\n{\n\tGENERATED_UCLASS_BODY()\npublic:\n\t/** \n\t * This will send this Generator Request to MassEQSSubsystem the first time it is called,\n\t * and Try to complete Generation with the Result from MassEQSSubsystem on subsequent calls.\n\t*/\n\tvirtual void GenerateItems(FEnvQueryInstance& QueryInstance) const final;\n\n\tvirtual FORCEINLINE bool IsCurrentlyRunningAsync() const final { return MassEQSRequestHandler.IsPendingResults(); }\n\n\t// To be implemented by child class:\n\t// Begin IMassEQSRequestInterface\n\tvirtual TUniquePtr<FMassEQSRequestData> GetRequestData(FEnvQueryInstance& QueryInstance) const override PURE_VIRTUAL(UMassEnvQueryGenerator::GetRequestData, return nullptr;);\n\tvirtual UClass* GetRequestClass() const override PURE_VIRTUAL(UMassEnvQueryGenerator::GetRequestData, return nullptr;);\n\tvirtual bool TryAcquireResults(FEnvQueryInstance& QueryInstance) const override PURE_VIRTUAL(UMassEnvQueryGenerator::TryAcquireResults, return false;);\n\t// ~IMassEQSRequestInterface\n\nprotected:\n\tmutable FMassEQSRequestHandler MassEQSRequestHandler;\n};",
      "lines": 33
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Public\\Generators\\MassEnvQueryGenerator_MassEntityHandles.h",
      "extension": ".h",
      "size_bytes": 2150,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"DataProviders/AIDataProvider.h\"\n#include \"Generators/MassEnvQueryGenerator.h\"\n#include \"MassEQSTypes.h\"\n\n#include \"MassEnvQueryGenerator_MassEntityHandles.generated.h\"\n\nstruct FMassEnvQueryEntityInfo;\n\n/**\n * Generator to be sent to MassEQSSubsystem for processing on Mass.\n * This will Generate UEnvQueryItemType_MassEntityHandles within SearchRadius of any ContextPositions.\n * Set SearchRadius to a value <= 0 in order to get all EntityHandles who have an FTransformFragment.\n */\nUCLASS(meta = (DisplayName = \"Mass Entity Handles\"), MinimalAPI)\nclass UMassEnvQueryGenerator_MassEntityHandles : public UMassEnvQueryGenerator\n{\n\tGENERATED_UCLASS_BODY()\n\npublic:\n\t// Begin IMassEQSRequestInterface\n\tvirtual TUniquePtr<FMassEQSRequestData> GetRequestData(FEnvQueryInstance& QueryInstance) const override;\n\tvirtual UClass* GetRequestClass() const override { return StaticClass(); }\n\t\n\tvirtual bool TryAcquireResults(FEnvQueryInstance& QueryInstance) const override;\n\t// ~IMassEQSRequestInterface\n\nprotected:\n\t/** Any Entity who is within SearchRadius of any SearchCenter will be acquired */\n\tUPROPERTY(EditDefaultsOnly, Category=Generator)\n\tFAIDataProviderFloatValue SearchRadius;\n\n\t/** Context of query */\n\tUPROPERTY(EditAnywhere, Category=Generator)\n\tTSubclassOf<UEnvQueryContext> SearchCenter = nullptr;\n};\n\n/** Data required to be sent to Mass for processing this Generator Request */\nstruct FMassEQSRequestData_MassEntityHandles : public FMassEQSRequestData\n{\n\tFMassEQSRequestData_MassEntityHandles(const TArray<FVector>& InContextPositions, const float InSearchRadius)\n\t\t: ContextPositions(InContextPositions)\n\t\t, SearchRadius(InSearchRadius)\n\t{\n\t}\n\n\tTArray<FVector> ContextPositions;\n\tfloat SearchRadius;\n};\n\nstruct FMassEnvQueryResultData_MassEntityHandles: public FMassEQSRequestData\n{\n\tFMassEnvQueryResultData_MassEntityHandles(TArray<FMassEnvQueryEntityInfo>&& InGeneratedEntityInfo)\n\t\t: GeneratedEntityInfo(MoveTemp(InGeneratedEntityInfo))\n\t{\n\t}\n\n\tTArray<FMassEnvQueryEntityInfo> GeneratedEntityInfo;\n};",
      "lines": 62
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Public\\Items\\EnvQueryItemType_MassEntityHandle.h",
      "extension": ".h",
      "size_bytes": 1017,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEQSTypes.h\"\n#include \"EnvironmentQuery/Items/EnvQueryItemType_VectorBase.h\"\n#include \"EnvQueryItemType_MassEntityHandle.generated.h\"\n\n/** \n * EnvQueryType representing a MassEntity. Additionally stores a Cached Transform of the Entity at the\n * time of acquisition, in order to use in the implemented UEnvQueryItemType_VectorBase functions.\n */\nUCLASS(meta = (DisplayName = \"Mass Entity Handles Item Type\"), MinimalAPI)\nclass UEnvQueryItemType_MassEntityHandle : public UEnvQueryItemType_VectorBase\n{\n\tGENERATED_BODY()\n\npublic:\n\ttypedef FMassEnvQueryEntityInfo FValueType;\n\n\tUEnvQueryItemType_MassEntityHandle();\n\n\tstatic const FMassEnvQueryEntityInfo& GetValue(const uint8* RawData);\n\tstatic void SetValue(uint8* RawData, const FMassEnvQueryEntityInfo& Value);\n\n\tvirtual FVector GetItemLocation(const uint8* RawData) const override;\n\tvirtual FRotator GetItemRotation(const uint8* RawData) const override;\n};\n",
      "lines": 28
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Public\\Processors\\MassEnvQueryGeneratorProcessor_MassEntityHandles.h",
      "extension": ".h",
      "size_bytes": 753,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Processors/MassEnvQueryProcessorBase.h\"\n#include \"MassEnvQueryGeneratorProcessor_MassEntityHandles.generated.h\"\n\n/** Processor for completing MassEQSSubsystem Requests sent from UMassEnvQueryGenerator_MassEntityHandles */\nUCLASS(meta = (DisplayName = \"Mass Entity Handles Generator Processor\"))\nclass UMassEnvQueryGeneratorProcessor_MassEntityHandles : public UMassEnvQueryProcessorBase\n{\n\tGENERATED_BODY()\npublic:\n\tUMassEnvQueryGeneratorProcessor_MassEntityHandles();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};",
      "lines": 21
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Public\\Processors\\MassEnvQueryProcessorBase.h",
      "extension": ".h",
      "size_bytes": 590,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessor.h\"\n#include \"MassEnvQueryProcessorBase.generated.h\"\n\nclass UEnvQueryNode;\n\n/** Processor for completing MassEQSSubsystem Requests sent from UMassEnvQueryTest_MassEntityTags */\nUCLASS(Abstract, meta = (DisplayName = \"Mass EQS Processor Base\"))\nclass UMassEnvQueryProcessorBase : public UMassProcessor\n{\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void Initialize(UObject& Owner);\n\t\n\tTSubclassOf<UEnvQueryNode> CorrespondingRequestClass = nullptr;\n\tint32 CachedRequestQueryIndex = -1;\n};",
      "lines": 21
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Public\\Processors\\MassEnvQueryTestProcessor_MassEntityTags.h",
      "extension": ".h",
      "size_bytes": 822,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Processors/MassEnvQueryProcessorBase.h\"\n#include \"MassEnvQueryTestProcessor_MassEntityTags.generated.h\"\n\n/** Processor for completing MassEQSSubsystem Requests sent from UMassEnvQueryTest_MassEntityTags */\nUCLASS(meta = (DisplayName = \"Mass Entity Tags Test Processor\"))\nclass UMassEnvQueryTestProcessor_MassEntityTags : public UMassEnvQueryProcessorBase\n{\n\tGENERATED_BODY()\npublic:\n\tUMassEnvQueryTestProcessor_MassEntityTags();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\tvirtual bool ShouldAllowQueryBasedPruning(const bool bRuntimeMode = true) const override { return false; }\n\n\tFMassEntityQuery EntityQuery;\n};",
      "lines": 22
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Public\\Tests\\MassEnvQueryTest.h",
      "extension": ".h",
      "size_bytes": 1437,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"EnvironmentQuery/EnvQueryTest.h\"\n#include \"MassEQSTypes.h\"\n\n#include \"MassEnvQueryTest.generated.h\"\n\n/** Test that will send its work to MassEQSSubsystem in order to be processed in a Mass Processor */\nUCLASS(EditInlineNew, Abstract, meta = (Category = \"Tests\"), MinimalAPI)\nclass UMassEnvQueryTest : public UEnvQueryTest, public IMassEQSRequestInterface\n{\n\tGENERATED_UCLASS_BODY()\npublic:\n\t/**\n\t * This will send this Test Request to MassEQSSubsystem the first time it is called,\n\t * and Try to complete Testing with the Result from MassEQSSubsystem on subsequent calls.\n\t */\n\tvirtual void RunTest(FEnvQueryInstance& QueryInstance) const final;\n\tvirtual FORCEINLINE bool IsCurrentlyRunningAsync() const final { return MassEQSRequestHandler.IsPendingResults(); }\n\n\t// Begin IMassEQSRequestInterface\n\tvirtual TUniquePtr<FMassEQSRequestData> GetRequestData(FEnvQueryInstance& QueryInstance) const override PURE_VIRTUAL(UMassEnvQueryTest::GetRequestData, return nullptr;)\n\tvirtual UClass* GetRequestClass() const override PURE_VIRTUAL(UMassEnvQueryTest::GetRequestClass, return nullptr;);\n\n\tvirtual bool TryAcquireResults(FEnvQueryInstance& QueryInstance) const override PURE_VIRTUAL(UMassEnvQueryTest::GetRequestData, return false;)\n\t// ~IMassEQSRequestInterface\n\nprotected:\n\tmutable FMassEQSRequestHandler MassEQSRequestHandler;\n};",
      "lines": 32
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Public\\Tests\\MassEnvQueryTest_MassEntityTags.h",
      "extension": ".h",
      "size_bytes": 2556,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Tests/MassEnvQueryTest.h\"\n#include \"MassEnvQueryTest_MassEntityTags.generated.h\"\n\nstruct FInstancedStruct;\nstruct FMassEntityHandle;\n\n/** Different modes that this Test can be run in */\nUENUM(BlueprintType)\nenum class EMassEntityTagsTestMode : uint8\n{\n\tAny = 0\tUMETA(DisplayName = \"Any Tags\", Tooltip = \"Filter will require just one of the tags to be present on the Entity.\"),\n\tAll\t\tUMETA(DisplayName = \"All Tags\", Tooltip = \"Filter will require All of the tags to be present on the Entity.\"),\n\tNone\tUMETA(DisplayName = \"None of the Tags\", Tooltip = \"Filter will require that none of the tags are present on the Entity.\")\n};\n\n/**\n * Test to be sent to MassEQSSubsystem for processing on Mass.\n * This will test the Entities in the QueryInstance based on the MassTags they have in comparison to the input Tags, and the TagTestMode selected.\n */\nUCLASS(MinimalAPI)\nclass UMassEnvQueryTest_MassEntityTags : public UMassEnvQueryTest\n{\n\tGENERATED_UCLASS_BODY()\npublic:\n\t// Begin IMassEQSRequestInterface\n\tvirtual TUniquePtr<FMassEQSRequestData> GetRequestData(FEnvQueryInstance& QueryInstance) const override;\n\tvirtual UClass* GetRequestClass() const override { return StaticClass(); }\n\n\tvirtual bool TryAcquireResults(FEnvQueryInstance& QueryInstance) const override;\n\t// ~IMassEQSRequestInterface\n\nprotected:\n\tvirtual FText GetDescriptionTitle() const override;\n\tvirtual FText GetDescriptionDetails() const override;\n\n\tUPROPERTY(EditAnywhere, Category = \"MassEntityTagsTest\")\n\tEMassEntityTagsTestMode TagTestMode = EMassEntityTagsTestMode::All;\n\n\tUPROPERTY(EditAnywhere, Category = \"MassEntityTagsTest\", meta = (BaseStruct = \"/Script/MassEntity.MassTag\", ExcludeBaseStruct))\n\tTArray<FInstancedStruct> Tags;\n};\n\n/** Data required to be sent to Mass for processing this Test Request */\nstruct FMassEQSRequestData_MassEntityTags : public FMassEQSRequestData\n{\n\tFMassEQSRequestData_MassEntityTags(EMassEntityTagsTestMode InTagTestMode, TArray<FInstancedStruct> InTags)\n\t\t: TagTestMode(InTagTestMode)\n\t\t, Tags(InTags)\n\t{\n\t}\n\tEMassEntityTagsTestMode TagTestMode;\n\tTArray<FInstancedStruct> Tags;\n};\n\n/** Data required to be sent to Mass for processing this Test Request */\nstruct FMassEnvQueryResultData_MassEntityTags : public FMassEQSRequestData\n{\n\tFMassEnvQueryResultData_MassEntityTags(TMap<FMassEntityHandle, bool>&& InResultMap)\n\t\t: ResultMap(MoveTemp(InResultMap))\n\t{\n\t}\n\n\tTMap<FMassEntityHandle, bool> ResultMap;\n};",
      "lines": 68
    },
    {
      "file_path": "MassGameplay\\MassGameplayDebug\\Public\\AssignDebugVisProcessor.h",
      "extension": ".h",
      "size_bytes": 582,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassObserverProcessor.h\"\n#include \"AssignDebugVisProcessor.generated.h\"\n\n\nclass UMassDebugVisualizationComponent;\nstruct FSimDebugVisFragment;\n\nUCLASS()\nclass MASSGAMEPLAYDEBUG_API UAssignDebugVisProcessor : public UMassObserverProcessor\n{\n\tGENERATED_BODY()\npublic:\n\tUAssignDebugVisProcessor();\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\nprotected:\n\tFMassEntityQuery EntityQuery;\n};\n",
      "lines": 23
    },
    {
      "file_path": "MassGameplay\\MassGameplayDebug\\Public\\DebugVisLocationProcessor.h",
      "extension": ".h",
      "size_bytes": 1123,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessor.h\"\n#include \"DebugVisLocationProcessor.generated.h\"\n\nclass UMassDebugVisualizationComponent;\nstruct FSimDebugVisFragment;\n\nUCLASS()\nclass MASSGAMEPLAYDEBUG_API UDebugVisLocationProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUDebugVisLocationProcessor();\n\t\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};\n\n//----------------------------------------------------------------------//\n// new one \n//----------------------------------------------------------------------//\n//class UMassDebugger;\n\nUCLASS()\nclass MASSGAMEPLAYDEBUG_API UMassProcessor_UpdateDebugVis : public UMassProcessor\n{\n\tGENERATED_BODY()\npublic:\n\tUMassProcessor_UpdateDebugVis();\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\nprotected:\n\tFMassEntityQuery EntityQuery;\n};\n\n",
      "lines": 43
    },
    {
      "file_path": "MassGameplay\\MassGameplayDebug\\Public\\IMassGameplayDebugModule.h",
      "extension": ".h",
      "size_bytes": 1148,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n * The public interface to this module.  In most cases, this interface is only public to sibling modules \n * within this plugin.\n */\nclass IMassGameplayDebugModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t * Singleton-like access to this module's interface.  This is just for convenience!\n\t * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t *\n\t * @return Returns singleton instance, loading the module on demand if needed\n\t */\n\tstatic inline IMassGameplayDebugModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassGameplayDebugModule>( \"MassGameplayDebug\" );\n\t}\n\n\t/**\n\t * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t *\n\t * @return True if the module is loaded and ready to use\n\t */\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassGameplayDebug\" );\n\t}\n};\n\n",
      "lines": 40
    },
    {
      "file_path": "MassGameplay\\MassGameplayDebug\\Public\\MassDebuggerSubsystem.h",
      "extension": ".h",
      "size_bytes": 2598,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassGameplayDebugTypes.h\"\n#include \"MassSubsystemBase.h\"\n#include \"MassDebuggerSubsystem.generated.h\"\n\n\nclass UMassDebugVisualizationComponent;\nclass AMassDebugVisualizer;\n\nUCLASS()\nclass MASSGAMEPLAYDEBUG_API UMassDebuggerSubsystem : public UMassSubsystemBase\n{\n\tGENERATED_BODY()\npublic:\n\tstruct FShapeDesc\n\t{\n\t\tFVector Location = {}; // no init on purpose, value will come from constructor\n\t\tfloat Size = {};\n\t\tFShapeDesc(const FVector InLocation, const float InSize) : Location(InLocation), Size(InSize) {}\n\t};\n\n\t// Methods to optimize the collection of data to only when category is enabled\n\tbool IsCollectingData() const { return bCollectingData; }\n\tvoid SetCollectingData() { bCollectingData = true; }\n\tvoid DataCollected() { bCollectingData = false; }\n\n\tvoid AddShape(EMassEntityDebugShape Shape, FVector Location, float Size) { Shapes[uint8(Shape)].Add(FShapeDesc(Location, Size)); }\n\tconst TArray<FShapeDesc>* GetShapes() const { return Shapes; }\n\tvoid ResetDebugShapes();\n\n\tFMassEntityHandle GetSelectedEntity() const { return SelectedEntity; }\n\tvoid SetSelectedEntity(const FMassEntityHandle InSelectedEntity);\n\n\tvoid AppendSelectedEntityInfo(const FString& Info);\n\tconst FString& GetSelectedEntityInfo() const { return SelectedEntityDetails; }\n\t\n\t/** Fetches the UMassDebugVisualizationComponent owned by lazily created DebugVisualizer */\n\tUMassDebugVisualizationComponent* GetVisualizationComponent();\n\n#if WITH_EDITORONLY_DATA\n\tAMassDebugVisualizer& GetOrSpawnDebugVisualizer(UWorld& InWorld);\n#endif\n\nprotected:\n\t// USubsystem BEGIN\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\tvirtual void Deinitialize() override;\n\t// USubsystem END\n\t\n\tvoid OnProcessingPhaseStarted(const float DeltaSeconds);\n\tvoid PreTickProcessors();\n\tvoid OnEntitySelected(const FMassEntityManager& EntityManager, const FMassEntityHandle EntityHandle);\n\nprotected:\n\tbool bCollectingData = false;\n\n\tTArray<FShapeDesc> Shapes[uint8(EMassEntityDebugShape::MAX)];\n\tTArray<FMassEntityHandle> Entities;\n\tTArray<FVector> Locations;\n\tFMassEntityHandle SelectedEntity;\n\tFString SelectedEntityDetails;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<UMassDebugVisualizationComponent> VisualizationComponent;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<AMassDebugVisualizer> DebugVisualizer;\n\n\tFDelegateHandle OnEntitySelectedHandle;\n};\n\n\ntemplate<>\nstruct TMassExternalSubsystemTraits<UMassDebuggerSubsystem> final\n{\n\tenum\n\t{\n\t\tGameThreadOnly = true\n\t};\n};",
      "lines": 83
    },
    {
      "file_path": "MassGameplay\\MassGameplayDebug\\Public\\MassDebugVisualizationComponent.h",
      "extension": ".h",
      "size_bytes": 1388,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassGameplayDebugTypes.h\"\n#include \"Components/ActorComponent.h\"\n#include \"MassDebugVisualizationComponent.generated.h\"\n\n\nclass UHierarchicalInstancedStaticMeshComponent;\n\n/** meant to be created procedurally and owned by an AMassDebugVisualizer instance. Will ensure if placed on a different type of actor */\nUCLASS()\nclass MASSGAMEPLAYDEBUG_API UMassDebugVisualizationComponent : public UActorComponent\n{\n\tGENERATED_BODY()\npublic:\n#if WITH_EDITORONLY_DATA\n\t/**  will create Owner's \"visual components\" only it they're missing or out of sync with VisualDataTable */\n\tvoid ConditionallyConstructVisualComponent();\n\tvoid DirtyVisuals();\n\tint32 AddDebugVisInstance(const uint16 VisualType);\n\t/** returns index to the newly created VisualDataTable entry */\n\tuint16 AddDebugVisType(const FAgentDebugVisualization& Data);\n\tTArrayView<UHierarchicalInstancedStaticMeshComponent* const> GetVisualDataISMCs() { return MakeArrayView(VisualDataISMCs); }\n\n\tvoid Clear();\nprotected:\n\tvirtual void PostInitProperties() override;\n\tvoid ConstructVisualComponent();\n\nprotected:\n\n\tUPROPERTY(Transient)\n\tTArray<FAgentDebugVisualization> VisualDataTable;\n\n\tUPROPERTY(Transient)\n\tTArray<TObjectPtr<UHierarchicalInstancedStaticMeshComponent>> VisualDataISMCs;\n#endif // WITH_EDITORONLY_DATA\n};\n",
      "lines": 40
    },
    {
      "file_path": "MassGameplay\\MassGameplayDebug\\Public\\MassDebugVisualizationTrait.h",
      "extension": ".h",
      "size_bytes": 645,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassEntityTraitBase.h\"\n#include \"MassGameplayDebugTypes.h\"\n#include \"MassDebugVisualizationTrait.generated.h\"\n\n\nUCLASS(meta = (DisplayName = \"Debug Visualization\"))\nclass MASSGAMEPLAYDEBUG_API UMassDebugVisualizationTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\n#if WITH_EDITORONLY_DATA\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Spawn\")\n\tFAgentDebugVisualization DebugShape;\n#endif // WITH_EDITORONLY_DATA\n};\n",
      "lines": 23
    },
    {
      "file_path": "MassGameplay\\MassGameplayDebug\\Public\\MassDebugVisualizer.h",
      "extension": ".h",
      "size_bytes": 657,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"GameFramework/Actor.h\"\n#include \"MassDebugVisualizer.generated.h\"\n\n\nUCLASS(NotPlaceable, Transient)\nclass MASSGAMEPLAYDEBUG_API AMassDebugVisualizer : public AActor\n{\n\tGENERATED_BODY()\npublic:\n\tAMassDebugVisualizer();\n\n#if WITH_EDITORONLY_DATA\n\t/** If this function is callable we guarantee the debug vis component to exist*/\n\tclass UMassDebugVisualizationComponent& GetDebugVisComponent() const { return *DebugVisComponent; }\n\nprotected:\n\tUPROPERTY()\n\tTObjectPtr<class UMassDebugVisualizationComponent> DebugVisComponent;\n#endif // WITH_EDITORONLY_DATA\n};\n",
      "lines": 24
    },
    {
      "file_path": "MassGameplay\\MassGameplayDebug\\Public\\MassGameplayDebugTypes.h",
      "extension": ".h",
      "size_bytes": 2882,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/ObjectMacros.h\"\n#include \"Logging/LogMacros.h\"\n#include \"Engine/DataTable.h\"\n#include \"MassEntityTypes.h\"\n#include \"MassSpawnerTypes.h\"\n#include \"MassGameplayDebugTypes.generated.h\"\n\n\nDECLARE_LOG_CATEGORY_EXTERN(LogMassDebug, Warning, All);\n\n#if WITH_EDITORONLY_DATA\nclass UBillboardComponent;\n#endif // WITH_EDITORONLY_DATA\nclass UStaticMesh;\nclass UMaterialInterface;\n\n#if WITH_MASSGAMEPLAY_DEBUG\nnamespace UE::Mass::Debug\n{\n\t/**\n\t * Fetches entity handles and their locations for entities indicated by index range as set by\n\t * mass.debug.SetDebugEntityRange or mass.debug.DebugEntity console commands.\n\t */\n\tMASSGAMEPLAYDEBUG_API extern void GetDebugEntitiesAndLocations(const FMassEntityManager& EntitySubsystem, TArray<FMassEntityHandle>& OutEntities, TArray<FVector>& OutLocations);\n\tMASSGAMEPLAYDEBUG_API extern FMassEntityHandle ConvertEntityIndexToHandle(const FMassEntityManager& EntitySubsystem, const int32 EntityIndex);\n} // namespace UE::Mass::Debug\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\nUSTRUCT()\nstruct FSimDebugDataRow : public FTableRowBase\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, Category = Debug)\n\tTObjectPtr<UStaticMesh> Mesh = nullptr;\n\n\tUPROPERTY(EditAnywhere, Category = Debug)\n\tTObjectPtr<UMaterialInterface> MaterialOverride = nullptr;\n\n\tUPROPERTY(EditAnywhere, Category = Debug)\n\tfloat Scale = 1.f;\n};\n\nUSTRUCT()\nstruct FSimDebugVisFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\tint32 InstanceIndex = INDEX_NONE;\n\tint16 VisualType = INDEX_NONE;\n};\n\nUENUM()\nenum class EMassEntityDebugShape : uint8\n{\n\tBox,\n\tCone,\n\tCylinder,\n\tCapsule,\n\tMAX\n};\n\nUSTRUCT()\nstruct FDataFragment_DebugVis : public FMassFragment\n{\n\tGENERATED_BODY()\n\tUPROPERTY(EditAnywhere, Category = Debug)\n\tEMassEntityDebugShape Shape = EMassEntityDebugShape::Box;\n};\n\nUSTRUCT()\nstruct FMassDebuggableTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\nUSTRUCT()\nstruct FAgentDebugVisualization : public FTableRowBase\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Debug\")\n\tTObjectPtr<UStaticMesh> Mesh = nullptr;\n\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Debug\")\n\tTObjectPtr<UMaterialInterface> MaterialOverride = nullptr;\n\n\t/** Near cull distance to override default value for that agent type */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Debug\")\n\tuint32 VisualNearCullDistance = 5000;\n\n\t/** Far cull distance to override default value for that agent type */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Debug\")\n\tuint32 VisualFarCullDistance = 7500;\n\n\t/** If Mesh is not set this WireShape will be used for debug drawing via GameplayDebugger */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Debug\")\n\tEMassEntityDebugShape WireShape = EMassEntityDebugShape::Box;\n};\n",
      "lines": 103
    },
    {
      "file_path": "MassGameplay\\MassGameplayEditor\\Public\\IMassGameplayEditor.h",
      "extension": ".h",
      "size_bytes": 274,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Toolkits/AssetEditorToolkit.h\"\n\n\n/** Mass Editor public interface */\nclass MASSGAMEPLAYEDITOR_API IMassGameplayEditor : public FAssetEditorToolkit\n{\npublic:\n};\n",
      "lines": 13
    },
    {
      "file_path": "MassGameplay\\MassGameplayEditor\\Public\\MassActorEditorSubsystem.h",
      "extension": ".h",
      "size_bytes": 525,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"EditorSubsystem.h\"\n#include \"MassActorEditorSubsystem.generated.h\"\n\n\nstruct FMassActorManager;\n\nUCLASS()\nclass MASSGAMEPLAYEDITOR_API UMassActorEditorSubsystem : public UEditorSubsystem\n{\n\tGENERATED_BODY()\n\npublic:\n\tFMassActorManager& GetMutableActorManager() { return *ActorManager.Get(); }\n\nprotected:\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\n\tTSharedPtr<FMassActorManager> ActorManager;\n};\n",
      "lines": 23
    },
    {
      "file_path": "MassGameplay\\MassGameplayEditor\\Public\\MassGameplayEditorModule.h",
      "extension": ".h",
      "size_bytes": 513,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma  once\n\n#include \"Modules/ModuleInterface.h\"\n\n/**\n* The public interface to this module\n*/\nclass MASSGAMEPLAYEDITOR_API FMassGameplayEditorModule : public IModuleInterface\n{\npublic:\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n\nprotected:\n\tvoid RegisterSectionMappings();\n};\n\n#if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_3\n#include \"CoreMinimal.h\"\n#include \"Toolkits/AssetEditorToolkit.h\"\n#endif\n",
      "lines": 23
    },
    {
      "file_path": "MassGameplay\\MassGameplayEditor\\Public\\MassTraitRepository.h",
      "extension": ".h",
      "size_bytes": 3066,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTemplateRegistry.h\"\n#include \"EditorSubsystem.h\"\n#include \"MassEntitySubsystem.h\"\n#include \"StructUtils/StructView.h\"\n#include \"MassDebugger.h\"\n#include \"MassTraitRepository.generated.h\"\n\nclass UMassEntityTraitBase;\nclass UWorld;\n\nnamespace UE::Mass::Editor\n{\n\textern MASSGAMEPLAYEDITOR_API TConstArrayView<FName> GetTraitsNameAddingElements(const FName ElementName);\n}\n\nstruct FMassTraitInspectionContext\n{\n\tstruct FInvestigationContext : public FMassEntityTemplateBuildContext\n\t{\n\t\tusing Super = FMassEntityTemplateBuildContext;\n\t\texplicit FInvestigationContext(FMassEntityTemplateData& InTemplate);\n\t\tvoid SetTrait(const UMassEntityTraitBase& Trait);\n\t};\n\n\tFMassTraitInspectionContext();\n\n\tFMassEntityTemplateData EntityTemplate;\n\tFInvestigationContext BuildContext;\n};\n\n/** \n * Subsystem to store information about Mass traits so that we can make helpful suggestions to users like which\n * traits supply a fragment they need.\n * It also serves to post trait validation information and fix options to the MessageLog.\n */\nUCLASS()\nclass MASSGAMEPLAYEDITOR_API UMassTraitRepository : public UEditorSubsystem\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tstatic UWorld* GetInvestigationWorld();\n\n\tTConstArrayView<FName> GetTraitsNameAddingElements(const FName ElementName);\n\tTWeakObjectPtr<UClass> GetTraitClass(const FName TraitClassName) const;\n\nprotected:\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\tvirtual void Deinitialize() override;\n\n#if WITH_MASSENTITY_DEBUG\n\t/** \n\t * Note that the function does nothing until InitRepository is called. This is done to avoid collecting trait\n\t * data until it's actually necessary.\n\t */\n\tvoid OnNewTraitType(UMassEntityTraitBase& Trait);\n\n\tvoid OnDebugEvent(const FName EventName, FConstStructView Payload, EMassDebugMessageSeverity SeverityOverride);\n#endif // WITH_MASSENTITY_DEBUG\n\t/** \n\t * The method gathers all existing trait classes and processed them. We don't do that on subsystem's init since\n\t * very often the data won't be needed during the given editor run. We call the function lazily the first time \n\t * the data is needed.\n\t */\n\tvoid InitRepository();\n\n\tFDelegateHandle OnNewTraitTypeHandle;\n\tstruct FTraitAndElements\n\t{\n\t\tTWeakObjectPtr<UClass> TraitClass;\n\t\tTArray<FName> ElementNames;\n\t};\n\tTMap<FName, FTraitAndElements> TraitClassNameToDataMap;\n\tTMap<FName, TArray<FName>> ElementTypeToTraitMap;\n\n\n\t/** the World we use to host all the subsystems required to process traits */\n\tUPROPERTY()\n\tTObjectPtr<UWorld> InvestigationWorld;\n\n\t/** We initialize the repository's data lazily and this property indicates whether it has been already done. */\n\tbool bIsRepositoryInitialized;\n\n\tstatic TWeakObjectPtr<UWorld> GlobalInvestigationWorld;\n};\n\n\nUCLASS()\nclass UMassDebugEntitySubsystem : public UMassEntitySubsystem\n{\n\tGENERATED_BODY()\n\t\n\tvirtual bool ShouldCreateSubsystem(UObject* Outer) const override;\n};\n",
      "lines": 98
    },
    {
      "file_path": "MassGameplay\\MassGameplayExternalTraits\\Public\\IMassGameplayExternalTraitsModule.h",
      "extension": ".h",
      "size_bytes": 1167,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n * The public interface to this module.  In most cases, this interface is only public to sibling modules \n * within this plugin.\n */\nclass IMassGameplayExternalTraitsModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t * Singleton-like access to this module's interface.  This is just for convenience!\n\t * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t *\n\t * @return Returns singleton instance, loading the module on demand if needed\n\t */\n\tstatic inline IMassGameplayExternalTraitsModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassGameplayExternalTraitsModule>( \"MassGameplayExternalTraits\" );\n\t}\n\n\t/**\n\t * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t *\n\t * @return True if the module is loaded and ready to use\n\t */\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassGameplayExternalTraits\" );\n\t}\n};\n\n",
      "lines": 39
    },
    {
      "file_path": "MassGameplay\\MassGameplayExternalTraits\\Public\\MassGameplayExternalTraits.h",
      "extension": ".h",
      "size_bytes": 1062,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassExternalSubsystemTraits.h\"\n\n/**\n * The point of this module and header is to have a common place for all the non-Mass subsystems MassGameplay modules\n * are using. This is the most convenient way to ensure we define these only once. The Mass code declaring the system \n * below as requirements (for example MassEntityQuery's requirements) need to include this header. Otherwise \n * a compilation error concerning TMassExternalSubsystemTraits will be generated by the compiler.\n */\n\nclass USmartObjectSubsystem;\ntemplate<>\nstruct TMassExternalSubsystemTraits<USmartObjectSubsystem> final\n{\n\tenum\n\t{\n\t\tGameThreadOnly = false\n\t};\n};\n\nclass UZoneGraphSubsystem;\ntemplate<>\nstruct TMassExternalSubsystemTraits<UZoneGraphSubsystem> final\n{\n\tenum\n\t{\n\t\tGameThreadOnly = false\n\t};\n};\n\nclass UZoneGraphAnnotationSubsystem;\ntemplate<>\nstruct TMassExternalSubsystemTraits<UZoneGraphAnnotationSubsystem> final\n{\n\tenum\n\t{\n\t\tGameThreadOnly = false\n\t};\n};\n",
      "lines": 42
    },
    {
      "file_path": "MassGameplay\\MassGameplayTestSuite\\Public\\MassGameplayTestSuiteModule.h",
      "extension": ".h",
      "size_bytes": 1022,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleManager.h\"\n\n/**\n* The public interface to this module\n*/\nclass IMassGameplayTestSuiteModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t* Singleton-like access to this module's interface.  This is just for convenience!\n\t* Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t*\n\t* @return Returns singleton instance, loading the module on demand if needed\n\t*/\n\tstatic inline IMassGameplayTestSuiteModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassGameplayTestSuiteModule>(\"MassGameplayTestSuite\");\n\t}\n\n\t/**\n\t* Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t*\n\t* @return True if the module is loaded and ready to use\n\t*/\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded(\"MassGameplayTestSuite\");\n\t}\n};\n\n",
      "lines": 37
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Public\\IMassLODModule.h",
      "extension": ".h",
      "size_bytes": 1098,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n * The public interface to this module.  In most cases, this interface is only public to sibling modules \n * within this plugin.\n */\nclass IMassLODModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t * Singleton-like access to this module's interface.  This is just for convenience!\n\t * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t *\n\t * @return Returns singleton instance, loading the module on demand if needed\n\t */\n\tstatic inline IMassLODModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassLODModule>( \"MassLOD\" );\n\t}\n\n\t/**\n\t * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t *\n\t * @return True if the module is loaded and ready to use\n\t */\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassLOD\" );\n\t}\n};\n\n",
      "lines": 40
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Public\\MassLODCalculator.h",
      "extension": ".h",
      "size_bytes": 43001,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassLODLogic.h\"\n#include \"MassLODUtils.h\"\n#include \"DrawDebugHelpers.h\"\n#include \"VisualLogger/VisualLogger.h\"\n/**\n * Helper struct to calculate LOD for each agent and maximize count per LOD\n *   Requires TViewerInfoFragment fragment collected by the TMassLODCollector.\n *   Stores information in TLODFragment fragment.\n*/\ntemplate <typename FLODLogic = FLODDefaultLogic >\nstruct TMassLODCalculator : public FMassLODBaseLogic\n{\n\tTMassLODCalculator()\n\t\t: FMassLODBaseLogic(/*bShouldBuildFrustumData=*/FLODLogic::bDoVisibilityLogic)\n\t{}\n\n\t/**\n\t * Initializes the LOD calculator, needed to be called once at initialization time\n\t * @Param InBaseLODDistance distances used to calculate LOD\n\t * @Param InBufferHysteresisOnFOVRatio distance hysteresis used to calculate LOD\n\t * @Param InLODMaxCount the maximum count for each LOD - Supports nullptr being passed in now and will put INT_MAX everywhere by default\n\t * @Param InLODMaxCountPerViewer the maximum count for each LOD per viewer (Only when FLODLogic::bMaximizeCountPerViewer is enabled)\n\t * @Param InVisibleDistanceToFrustum is the distance from the frustum to start considering this entity is visible (Only when FLODLogic::bDoVisibilityLogic is enabled)\n\t * @Param InVisibleDistanceToFrustumHysteresis once visible, what extra distance the entity need to be before considered not visible anymore (Only when FLODLogic::bDoVisibilityLogic is enabled)\n\t * @Param InVisibleLODDistance the maximum count for each LOD per viewer (Only when FLODLogic::bDoVisibilityLogic is enabled)\n\t */\n\tvoid Initialize(const float InBaseLODDistance[EMassLOD::Max], \n\t\t\t\t\tconst float InBufferHysteresisOnDistanceRatio, \n\t\t\t\t\tconst int32 InLODMaxCount[EMassLOD::Max], \n\t\t\t\t\tconst int32 InLODMaxCountPerViewer[EMassLOD::Max] = nullptr,\n\t\t\t\t\tconst float InVisibleDistanceToFrustum = 0.0f,\n\t\t\t\t\tconst float InVisibleDistanceToFrustumHysteresis = 0.0f,\n\t\t\t\t\tconst float InVisibleLODDistance[EMassLOD::Max] = nullptr);\n\n\t/**\n\t * Prepares execution for the current frame, needed to be called before every execution\n\t * @Param Viewers is the array of all the known viewers\n\t */\n\tvoid PrepareExecution(TConstArrayView<FViewerInfo> Viewers);\n\n\t/**\n\t * Calculate LOD, called for each entity chunks\n\t * Use next method when FLODLogic::bStoreInfoPerViewer is enabled\n\t * @Param Context of the chunk execution\n\t * @Param ViewersInfoList is the source information fragment for LOD calculation\n\t * @Param LODList is the fragment where calculation are stored\n\t */\n\ttemplate <typename TViewerInfoFragment,\n\t\t\t  typename TLODFragment,\n\t\t\t  bool bCalculateLocalViewers = FLODLogic::bLocalViewersOnly,\n\t\t\t  bool bCalculateVisibility = FLODLogic::bDoVisibilityLogic>\n\tFORCEINLINE void CalculateLOD(FMassExecutionContext& Context,\n\t\t\t\t\t  \t\t\t  TConstArrayView<TViewerInfoFragment> ViewersInfoList,\n\t\t\t\t\t  \t\t\t  TArrayView<TLODFragment> LODList)\n\t{\n\t\tCalculateLOD<TViewerInfoFragment,\n\t\t\tTLODFragment,\n\t\t\t/*TPerViewerInfoFragment*/void*,\n\t\t\tbCalculateLocalViewers,\n\t\t\tbCalculateVisibility,\n\t\t\t/*bCalculateLODPerViewer*/false,\n\t\t\t/*bCalculateVisibilityPerViewer*/false,\n\t\t\t/*bMaximizeCountPerViewer*/false>(Context, ViewersInfoList, LODList, TConstArrayView<void*>());\n\t}\n\n\t/**\n\t * Calculate LOD, called for each entity chunks\n\t * Use this version when FLODLogic::bStoreInfoPerViewer is enabled\n\t * It calculates a LOD per viewer and needs information per viewer via PerViewerInfoList fragments\n\t * @Param Context of the chunk execution\n\t * @Param ViewersInfoList is the source information fragment for LOD calculation\n\t * @Param LODList is the fragment where calculation are stored\n\t * @Param PerViewerInfoList is the Per viewer source information\n\t */\n\ttemplate <typename TViewerInfoFragment,\n\t\t\t  typename TLODFragment,\n\t\t\t  typename TPerViewerInfoFragment,\n\t\t\t  bool bCalculateLocalViewers = FLODLogic::bLocalViewersOnly,\n\t\t\t  bool bCalculateVisibility = FLODLogic::bDoVisibilityLogic,\n\t\t\t  bool bCalculateLODPerViewer = FLODLogic::bCalculateLODPerViewer,\n\t\t\t  bool bCalculateVisibilityPerViewer = FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer,\n\t\t\t  bool bMaximizeCountPerViewer = FLODLogic::bMaximizeCountPerViewer>\n\tvoid CalculateLOD(FMassExecutionContext& Context,\n\t\t\t\t\t  TConstArrayView<TViewerInfoFragment> ViewersInfoList,\n\t\t\t\t\t  TArrayView<TLODFragment> LODList,\n\t\t\t\t\t  TConstArrayView<TPerViewerInfoFragment> PerViewerInfoList);\n\n\t/**\n\t * Adjust LOD distances by clamping them to respect the maximum LOD count\n\t * @Return true if any LOD distances clamping was done\n\t */\n\ttemplate <bool bCalculateVisibility = FLODLogic::bDoVisibilityLogic,\n\t\t\t  bool bCalculateVisibilityPerViewer = FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer,\n\t\t\t  bool bMaximizeCountPerViewer = FLODLogic::bMaximizeCountPerViewer>\n\tbool AdjustDistancesFromCount();\n\n\t/**\n\t * Adjust LOD from newly adjusted distances, only needed to be called when AdjustDistancesFromCount return true, called for each entity chunks\n\t * Use next method when FLODLogic::bStoreInfoPerViewer is enabled\n\t * @Param Context of the chunk execution\n\t * @Param ViewersInfoList is the source information fragment for LOD calculation\n\t * @Param LODList is the fragment where calculation are stored\n\t */\n\ttemplate <typename TViewerInfoFragment, \n\t\t\t  typename TLODFragment,\n\t\t\t  bool bCalculateLocalViewers = FLODLogic::bLocalViewersOnly,\n\t\t\t  bool bCalculateVisibility = FLODLogic::bDoVisibilityLogic>\n\tFORCEINLINE void AdjustLODFromCount(FMassExecutionContext& Context,\n\t\t\t\t\t\t\t\t\t\tTConstArrayView<TViewerInfoFragment> ViewersInfoList,\n\t\t\t\t\t\t\t\t\t\tTArrayView<TLODFragment> LODList)\n\t{\n\t\tAdjustLODFromCount<TViewerInfoFragment,\n\t\t\tTLODFragment,\n\t\t\t/*TPerViewerInfoFragment*/void*,\n\t\t\tbCalculateLocalViewers,\n\t\t\tbCalculateVisibility,\n\t\t\t/*bCalculateLODPerViewer*/false,\n\t\t\t/*bCalculateVisibilityPerViewer*/false,\n\t\t\t/*bMaximizeCountPerViewer*/false>(Context, ViewersInfoList, LODList, TConstArrayView<void*>());\n\t}\n\n\n\t/**\n\t * Adjust LOD from newly adjusted distances, only needed to be called when AdjustDistancesFromCount return true, called for each entity chunks\n\t * Use this version when FLODLogic::bStoreInfoPerViewer is enabled\n\t * It calculates a LOD per viewer and needs information per viewer via PerViewerInfoList fragments\n\t * @Param Context of the chunk execution\n\t * @Param ViewersInfoList is the source information fragment for LOD calculation\n\t * @Param LODList is the fragment where calculation are stored\n\t * @Param PerViewerInfoList is the Per viewer source information\n\t */\n\ttemplate <typename TViewerInfoFragment,\n\t\t\t  typename TLODFragment,\n\t\t\t  typename TPerViewerInfoFragment,\n\t\t\t  bool bCalculateLocalViewers = FLODLogic::bLocalViewersOnly,\n\t\t\t  bool bCalculateVisibility = FLODLogic::bDoVisibilityLogic,\n\t\t\t  bool bCalculateLODPerViewer = FLODLogic::bCalculateLODPerViewer,\n\t\t\t  bool bCalculateVisibilityPerViewer = FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer,\n\t\t\t  bool bMaximizeCountPerViewer = FLODLogic::bMaximizeCountPerViewer>\n\tvoid AdjustLODFromCount(FMassExecutionContext& Context,\n\t\t\t\t\t\t\tTConstArrayView<TViewerInfoFragment> ViewersInfoList,\n\t\t\t\t\t\t\tTArrayView<TLODFragment> LODList,\n\t\t\t\t\t\t\tTConstArrayView<TPerViewerInfoFragment> PerViewerInfoList);\n\n\t/**\n\t * Turn Off all LOD, called for each entity chunks\n\t * @Param Context of the chunk execution\n\t * @Param LODList is the fragment where calculation are stored\n\t */\n\ttemplate <typename TLODFragment>\n\tvoid ForceOffLOD(FMassExecutionContext& Context, TArrayView<TLODFragment> LODList);\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\t/**\n\t * Debug draw the current state of each agent as a color coded square\n\t * @Param Context of the chunk execution\n\t * @Param LODList is the fragment where calculation are stored\n\t * @Param LocationList is the fragment transforms of the entities\n\t * @Param World where the debug display should be drawn\n\t */\n\ttemplate <typename TLODFragment, typename TTransformFragment>\n\tvoid DebugDisplayLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TConstArrayView<TTransformFragment> LocationList, UWorld* World);\n\n\t/**\n\t * Debug draw the current state of each agent as a color coded square, within MaxLODSignificance range\n\t * @Param Context of the chunk execution\n\t * @Param LODList is the fragment where calculation are stored\n\t * @Param LocationList is the fragment transforms of the entities\n\t * @Param World where the debug display should be drawn\n\t * @Param MaxLODSignificance is the max allowed value of LODList[i].LODSignificance for an agent's state to debug draw\n\t */\n\ttemplate <typename TLODFragment, typename TTransformFragment>\n\tvoid DebugDisplaySignificantLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TConstArrayView<TTransformFragment> LocationList, UWorld* World, float MaxLODSignificance);\n\n\t/**\n\t * Add Visual Log entries for the current state of each agent as a color coded location\n\t * @Param Context of the chunk execution\n\t * @Param LODList is the fragment where calculation are stored\n\t * @Param LocationList is the fragment transforms of the entities\n\t * @Param World where the debug display should be drawn\n\t */\n\ttemplate <typename TLODFragment, typename TTransformFragment>\n\tvoid VisLogLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TConstArrayView<TTransformFragment> LocationList, UObject* LogOwner);\n\n\t/**\n\t * Add Visual Log entries for the current state of each agent as a color coded location, within MaxLODSignificance range\n\t * @Param Context of the chunk execution\n\t * @Param LODList is the fragment where calculation are stored\n\t * @Param LocationList is the fragment transforms of the entities\n\t * @Param World where the debug display should be drawn\n\t * @Param MaxLODSignificance is the max allowed value of LODList[i].LODSignificance for an agent's state to vislog\n\t */\n\ttemplate <typename TLODFragment, typename TTransformFragment>\n\tvoid VisLogSignificantLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TConstArrayView<TTransformFragment> LocationList, UObject* LogOwner, float MaxLODSignificance);\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t/**\n\t * Return the maximum distance at which the LOD will be turn off\n\t */\n\t float GetMaxLODDistance() const { return MaxLODDistance; }\n\nprotected:\n\n\tstruct FMassLODRuntimeData\n\t{\n\t\t/** Reset values to default */\n\t\tvoid Reset(const TStaticArray<float, EMassLOD::Max>& InBaseLODDistance, const TStaticArray<float, EMassLOD::Max>& InVisibleLODDistance)\n\t\t{\n\t\t\t// Reset the AdjustedLODDistances as they might have been changed by the max count calculation previous frame\n\t\t\tfor (int32 LODDistIdx = 0; LODDistIdx < EMassLOD::Max; LODDistIdx++)\n\t\t\t{\n\t\t\t\tAdjustedBaseLODDistance[LODDistIdx] = InBaseLODDistance[LODDistIdx];\n\t\t\t\tAdjustedBaseLODDistanceSq[LODDistIdx] = FMath::Square(AdjustedBaseLODDistance[LODDistIdx]);\n\t\t\t\tif (FLODLogic::bDoVisibilityLogic)\n\t\t\t\t{\n\t\t\t\t\tAdjustedVisibleLODDistance[LODDistIdx] = InVisibleLODDistance[LODDistIdx];\n\t\t\t\t\tAdjustedVisibleLODDistanceSq[LODDistIdx] = FMath::Square(AdjustedVisibleLODDistance[LODDistIdx]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tFMemory::Memzero(BaseBucketCounts);\n\t\t\tif (FLODLogic::bDoVisibilityLogic)\n\t\t\t{\n\t\t\t\tFMemory::Memzero(VisibleBucketCounts);\n\t\t\t}\n\t\t}\n\n\t\t/** Distance where each LOD becomes relevant (Squared and Normal) */\n\t\tTStaticArray<float, EMassLOD::Max> AdjustedBaseLODDistanceSq;\n\t\tTStaticArray<float, EMassLOD::Max> AdjustedVisibleLODDistanceSq;\n\t\tTStaticArray<float, EMassLOD::Max> AdjustedBaseLODDistance;\n\t\tTStaticArray<float, EMassLOD::Max> AdjustedVisibleLODDistance;\n\n\t\t/** Count of entities in each subdivision */\n\t\tTStaticArray< TStaticArray<int32, UE::MassLOD::MaxBucketsPerLOD>, EMassLOD::Max > BaseBucketCounts;\n\t\tTStaticArray< TStaticArray<int32, UE::MassLOD::MaxBucketsPerLOD>, EMassLOD::Max > VisibleBucketCounts;\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\t/* Last calculation count per LOD */\n\t\tTStaticArray<int32, EMassLOD::Max> LastCalculatedLODCount;\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t};\n\n\n\ttemplate <bool bCalculateVisibility, bool bCalculateLODSignificance>\n\tfloat AccumulateCountInRuntimeData(const EMassLOD::Type LOD, const float ViewerDistanceSq, const bool bIsVisible, FMassLODRuntimeData& Data) const;\n\n\ttemplate <bool bCalculateVisibility>\n\tbool AdjustDistancesFromCountForRuntimeData(const TStaticArray<int32, EMassLOD::Max>& MaxCount, FMassLODRuntimeData& RuntimeData) const;\n\n\ttemplate<bool bCalculateVisibility>\n\tEMassLOD::Type ComputeLODFromSettings(const EMassLOD::Type PrevLOD, const float DistanceToViewerSq, const bool bIsVisible, bool* bIsInAVisibleRange, const FMassLODRuntimeData& Data) const;\n\n\tbool CalculateVisibility(const bool bWasVisible, const float DistanceToFrustum) const;\n\n\t/** LOD distances */\n\tTStaticArray<float, EMassLOD::Max> BaseLODDistance;\n\tTStaticArray<float, EMassLOD::Max> VisibleLODDistance;\n\n\t/** MaxCount total */\n\tTStaticArray<int32, EMassLOD::Max> LODMaxCount;\n\n\t/** MaxCount total per viewers*/\n\tTStaticArray<int32, EMassLOD::Max> LODMaxCountPerViewer;\n\n\t/** Ratio for Buffer Distance Hysteresis */\n\tfloat BufferHysteresisOnDistanceRatio = 0.1f;\n\n\t/** How far away from frustum does this entities are considered visible */\n\tfloat VisibleDistanceToFrustum = 0.0f;\n\n\t/** Once visible how much further than distance to frustum does the entities need to be before being consider not visible */\n\tfloat VisibleDistanceToFrustumWithHysteresis = 0.0f;\n\n\t/** The size of each subdivision per LOD (LOD Size/MaxBucketsPerLOD) */\n\tTStaticArray<float, EMassLOD::Max> BaseBucketSize;\n\tTStaticArray<float, EMassLOD::Max> VisibleBucketSize;\n\n\t/** Maximum LOD Distance  */\n\tfloat MaxLODDistance = 0.0f;\n\n\t/** Runtime data for LOD calculation */\n\tFMassLODRuntimeData RuntimeData;\n\n\t/** Runtime data for each viewer specific LOD calculation, used only when bMaximizeCountPerViewer is true */\n\tTArray<FMassLODRuntimeData> RuntimeDataPerViewer;\n};\n\ntemplate <typename FLODLogic>\nvoid TMassLODCalculator<FLODLogic>::Initialize(const float InBaseLODDistance[EMassLOD::Max],\n\t\t\t\t\t\t\t\t\t\t\t   const float InBufferHysteresisOnDistanceRatio,\n\t\t\t\t\t\t\t\t\t\t\t   const int32 InLODMaxCount[EMassLOD::Max],\n\t\t\t\t\t\t\t\t\t\t\t   const int32 InLODMaxCountPerViewer[EMassLOD::Max] /*= nullptr*/,\n\t\t\t\t\t\t\t\t\t\t\t   const float InVisibleDistanceToFrustum /*= 0.0f*/,\n\t\t\t\t\t\t\t\t\t\t\t   const float InVisibleDistanceToFrustumHysteresis /*= 0.0f*/,\n\t\t\t\t\t\t\t\t\t\t\t   const float InVisibleLODDistance[EMassLOD::Max] /*= nullptr*/ )\n{\n\tstatic_assert(!FLODLogic::bCalculateLODPerViewer || FLODLogic::bStoreInfoPerViewer, \"Need to enable store info per viewer to be able to calculate LOD per viewer\");\n\tstatic_assert(!FLODLogic::bMaximizeCountPerViewer || FLODLogic::bCalculateLODPerViewer, \"Need to enable CalculatedLODPerviewer in order to maximize count per viewer\");\n\n\tcheckf(FLODLogic::bMaximizeCountPerViewer == (InLODMaxCountPerViewer != nullptr), TEXT(\"Missmatched between expected parameter InLODMaxCountPerViewer and LOD logic trait bMaximizeCountPerViewer.\"));\n\tcheckf(FLODLogic::bDoVisibilityLogic == (InVisibleLODDistance != nullptr), TEXT(\"Missmatched between expected parameter InVisibleLODDistance and LOD logic trait bDoVisibilityLogic.\"));\n\n\t// Make a copy of all the settings\n\tfor (int x = 0; x < EMassLOD::Max; x++)\n\t{\n\t\tBaseLODDistance[x] = InBaseLODDistance[x];\n\t\t\n\t\t// @todo Treat InLODMaxCount as a possible nullptr by default for this Initialize function, would need to come as an option from FLODLogic as well\n\t\tLODMaxCount[x] = (InLODMaxCount != nullptr) ? InLODMaxCount[x] : INT_MAX;\n\t\tif (FLODLogic::bDoVisibilityLogic && InVisibleLODDistance)\n\t\t{\n\t\t\tVisibleLODDistance[x] = InVisibleLODDistance[x];\n\t\t}\n\t\tif (FLODLogic::bMaximizeCountPerViewer && InLODMaxCountPerViewer)\n\t\t{\n\t\t\tLODMaxCountPerViewer[x] = InLODMaxCountPerViewer[x];\n\t\t}\n\t}\n\n\t// Some values should always be constant\n\tBaseLODDistance[EMassLOD::High] = 0.0f;\n\tBaseBucketSize[EMassLOD::Off] = FLT_MAX;\n\tVisibleLODDistance[EMassLOD::High] = 0.0f;\n\tVisibleBucketSize[EMassLOD::Off] = FLT_MAX;\n\tLODMaxCount[EMassLOD::Off] = INT_MAX;\n\tLODMaxCountPerViewer[EMassLOD::Off] = INT_MAX;\n\tBufferHysteresisOnDistanceRatio = InBufferHysteresisOnDistanceRatio;\n\n\t// Calculate the size for each LOD buckets\n\tfloat BasePrevLODDistance = BaseLODDistance[0];\n\tfloat VisiblePrevLODDistance = VisibleLODDistance[0];\n\tfor (int32 LODDistIdx = 1; LODDistIdx < EMassLOD::Max; LODDistIdx++)\n\t{\n\t\tBaseBucketSize[LODDistIdx - 1] = (BaseLODDistance[LODDistIdx] - BasePrevLODDistance) / UE::MassLOD::MaxBucketsPerLOD;\n\t\tBasePrevLODDistance = BaseLODDistance[LODDistIdx];\n\n\t\tif (FLODLogic::bDoVisibilityLogic)\n\t\t{\n\t\t\tVisibleBucketSize[LODDistIdx - 1] = (VisibleLODDistance[LODDistIdx] - VisiblePrevLODDistance) / UE::MassLOD::MaxBucketsPerLOD;\n\t\t\tVisiblePrevLODDistance = VisibleLODDistance[LODDistIdx];\n\t\t}\n\t}\n\n\t// Assuming that off is the farthest distance, calculate the max LOD distance\n\tMaxLODDistance = !FLODLogic::bDoVisibilityLogic || BaseLODDistance[EMassLOD::Off] >= VisibleLODDistance[EMassLOD::Off] ? BaseLODDistance[EMassLOD::Off] : VisibleLODDistance[EMassLOD::Off];\n\n\t// Distance to frustum settings\n\tVisibleDistanceToFrustum = InVisibleDistanceToFrustum;\n\tVisibleDistanceToFrustumWithHysteresis = InVisibleDistanceToFrustum + InVisibleDistanceToFrustumHysteresis;\n}\n\ntemplate <typename FLODLogic>\nbool TMassLODCalculator<FLODLogic>::CalculateVisibility(const bool bWasVisible, const float DistanceToFrustum) const\n{\n\treturn DistanceToFrustum < (bWasVisible ? VisibleDistanceToFrustumWithHysteresis : VisibleDistanceToFrustum);\n}\n\ntemplate <typename FLODLogic>\nvoid TMassLODCalculator<FLODLogic>::PrepareExecution(TConstArrayView<FViewerInfo> ViewersInfo)\n{\n\tCacheViewerInformation(ViewersInfo);\n\n\tif (FLODLogic::bMaximizeCountPerViewer)\n\t{\n\t\tRuntimeDataPerViewer.SetNum(Viewers.Num());\n\t\tfor (int ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)\n\t\t{\n\t\t\t// Reset viewer data\n\t\t\tif (Viewers[ViewerIdx].Handle.IsValid())\n\t\t\t{\n\t\t\t\tRuntimeDataPerViewer[ViewerIdx].Reset(BaseLODDistance, VisibleLODDistance);\n\t\t\t}\n\t\t}\n\t}\n\n\tRuntimeData.Reset(BaseLODDistance, VisibleLODDistance);\n}\n\n\ntemplate <typename FLODLogic>\ntemplate <bool bCalculateVisibility, bool bCalculateLODSignificance>\nfloat TMassLODCalculator<FLODLogic>::AccumulateCountInRuntimeData(const EMassLOD::Type LOD, const float ViewerDistanceSq, const bool bIsVisible, FMassLODRuntimeData& Data) const\n{\n\tTStaticArray< TStaticArray<int32, UE::MassLOD::MaxBucketsPerLOD>, EMassLOD::Max>& BucketCounts = bCalculateVisibility && bIsVisible ? Data.VisibleBucketCounts : Data.BaseBucketCounts;\n\n\t// Cumulate LOD in buckets for Max LOD count calculation\n\tif (LOD == EMassLOD::Off)\n\t{\n\t\t// A single bucket for Off LOD\n\t\tBucketCounts[EMassLOD::Off][0]++;\n\t\tif (bCalculateLODSignificance)\n\t\t{\n\t\t\treturn float(EMassLOD::Off);\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst TStaticArray<float, EMassLOD::Max>& BucketSize = bCalculateVisibility && bIsVisible ? VisibleBucketSize : BaseBucketSize;\n\t\tconst TStaticArray<float, EMassLOD::Max>& AdjustedLODDistance = bCalculateVisibility && bIsVisible ? Data.AdjustedVisibleLODDistance : Data.AdjustedBaseLODDistance;\n\n\t\tconst int32 LODDistIdx = (int32)LOD;\n\n\t\t// Need to clamp as the Sqrt is not precise enough and always end up with floating calculation errors\n\t\tconst int32 BucketIdx = FMath::Clamp((int32)((FMath::Sqrt(ViewerDistanceSq) - AdjustedLODDistance[LODDistIdx]) / BucketSize[LODDistIdx]), 0, UE::MassLOD::MaxBucketsPerLOD - 1);\n\t\tBucketCounts[LODDistIdx][BucketIdx]++;\n\n\t\tif (bCalculateLODSignificance)\n\t\t{\n\t\t\t// Derive significance from LODDistIdx combined with BucketIdx\n\t\t\tconst float PartialLODSignificance = float(BucketIdx) / float(UE::MassLOD::MaxBucketsPerLOD);\n\t\t\treturn float(LODDistIdx) + PartialLODSignificance;\n\t\t}\n\t}\n\treturn 0.0f;\n}\n\ntemplate <typename FLODLogic>\ntemplate <typename TViewerInfoFragment, typename TLODFragment, typename TPerViewerInfoFragment,\n\t\t  bool bCalculateLocalViewers, bool bCalculateVisibility, bool bCalculateLODPerViewer, bool bCalculateVisibilityPerViewer,bool bMaximizeCountPerViewer>\nvoid TMassLODCalculator<FLODLogic>::CalculateLOD(FMassExecutionContext& Context, \n\t\t\t\t\t\t\t\t\t\t\t\t TConstArrayView<TViewerInfoFragment> ViewersInfoList, \n\t\t\t\t\t\t\t\t\t\t\t\t TArrayView<TLODFragment> LODList, \n\t\t\t\t\t\t\t\t\t\t\t\t TConstArrayView<TPerViewerInfoFragment> PerViewerInfoList)\n{\n\tstatic_assert(!bCalculateVisibility || FLODLogic::bDoVisibilityLogic, \"FLODLogic must have bDoVisibilityLogic enabled to calculate visibility.\");\n\tstatic_assert(!bCalculateLODPerViewer || FLODLogic::bCalculateLODPerViewer, \"FLODLogic must have bCalculateLODPerViewer enabled to calculate LOD Per viewer.\");\n\tstatic_assert(!bCalculateVisibilityPerViewer || (FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer), \"FLODLogic must have bDoVisibilityLogic and bStoreInfoPerViewer enabled to calculate visibility per viewer.\");\n\tstatic_assert(!bMaximizeCountPerViewer || FLODLogic::bMaximizeCountPerViewer, \"FLODLogic must have bMaximizeCountPerViewer enabled to maximize count per viewer.\");\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\tif (UE::MassLOD::Debug::bLODCalculationsPaused)\n\t{\n\t\treturn;\n\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\tconst int32 NumEntities = Context.GetNumEntities();\n\tfor (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t{\n\t\t// Calculate the LOD purely upon distances\n\t\tconst TViewerInfoFragment& EntityViewersInfo = ViewersInfoList[EntityIdx];\n\t\tTLODFragment& EntityLOD = LODList[EntityIdx];\n\t\tconst float ClosestDistanceToFrustum = GetClosestDistanceToFrustum<bCalculateVisibility>(EntityViewersInfo, FLT_MAX);\n\t\tconst EMassVisibility PrevVisibility = GetVisibility<bCalculateVisibility>(EntityLOD, EMassVisibility::Max);\n\t\tconst bool bIsVisibleByAViewer = CalculateVisibility(PrevVisibility == EMassVisibility::CanBeSeen, ClosestDistanceToFrustum);\n\t\tbool bIsInAVisibleRange = false;\n\n\t\t// Find new LOD\n\t\tEntityLOD.PrevLOD = EntityLOD.LOD;\n\t\tEntityLOD.LOD = ComputeLODFromSettings<bCalculateVisibility>(EntityLOD.PrevLOD, EntityViewersInfo.ClosestViewerDistanceSq, bIsVisibleByAViewer, &bIsInAVisibleRange, RuntimeData);\n\n\t\t// Set visibility\n\t\tSetPrevVisibility<bCalculateVisibility>(EntityLOD, PrevVisibility);\n\t\tSetVisibility<bCalculateVisibility>(EntityLOD, bIsInAVisibleRange ? (bIsVisibleByAViewer ? EMassVisibility::CanBeSeen : EMassVisibility::CulledByFrustum) : EMassVisibility::CulledByDistance);\n\n\t\t// Accumulate in buckets\n\t\tconst float LODSignificance = AccumulateCountInRuntimeData<bCalculateVisibility, FLODLogic::bCalculateLODSignificance>(EntityLOD.LOD, EntityViewersInfo.ClosestViewerDistanceSq, bIsVisibleByAViewer, RuntimeData);\n\t\tSetLODSignificance<FLODLogic::bCalculateLODSignificance>(EntityLOD, LODSignificance);\n\n\t\t// Do per viewer logic if asked for\n\t\tif (bCalculateLODPerViewer || bCalculateVisibilityPerViewer)\n\t\t{\n\t\t\tconst TPerViewerInfoFragment& EntityPerViewerInfo = PerViewerInfoList[EntityIdx];\n\n\t\t\tSetLODPerViewerNum<bCalculateLODPerViewer>(EntityLOD, Viewers.Num());\n\t\t\tSetPrevLODPerViewerNum<bCalculateLODPerViewer>(EntityLOD, Viewers.Num());\n\t\t\tSetVisibilityPerViewerNum<bCalculateVisibilityPerViewer>(EntityLOD, Viewers.Num());\n\t\t\tSetPrevVisibilityPerViewerNum<bCalculateVisibilityPerViewer>(EntityLOD, Viewers.Num());\n\n\t\t\tfor (int ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)\n\t\t\t{\n\t\t\t\tconst FViewerLODInfo& Viewer = Viewers[ViewerIdx];\n\t\t\t\tif (Viewer.bClearData)\n\t\t\t\t{\n\t\t\t\t\tSetLODPerViewer<bCalculateLODPerViewer>(EntityLOD, ViewerIdx, EMassLOD::Max);\n\t\t\t\t\tSetPrevLODPerViewer<bCalculateLODPerViewer>(EntityLOD, ViewerIdx, EMassLOD::Max);\n\t\t\t\t\tSetPrevVisibilityPerViewer<bCalculateVisibilityPerViewer>(EntityLOD, ViewerIdx, EMassVisibility::Max);\n\t\t\t\t\tSetVisibilityPerViewer<bCalculateVisibilityPerViewer>(EntityLOD, ViewerIdx, EMassVisibility::Max);\n\t\t\t\t}\n\n\t\t\t\t// Check to see if we want only local viewer only\n\t\t\t\tif (bCalculateLocalViewers && !Viewer.bLocal)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (Viewer.Handle.IsValid())\n\t\t\t\t{\n\t\t\t\t\tconst float DistanceToFrustum = GetDistanceToFrustum<bCalculateVisibilityPerViewer>(EntityPerViewerInfo, ViewerIdx, FLT_MAX);\n\t\t\t\t\tconst EMassVisibility PrevVisibilityPerViewer = GetVisibilityPerViewer<bCalculateVisibilityPerViewer>(EntityLOD, ViewerIdx, EMassVisibility::Max);\n\t\t\t\t\tconst bool bIsVisibleByViewer = CalculateVisibility(PrevVisibilityPerViewer == EMassVisibility::CanBeSeen, DistanceToFrustum);\n\t\t\t\t\tbool bIsInVisibleRange = false;\n\n\t\t\t\t\tif (bCalculateLODPerViewer)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst float DistanceToViewerSq = GetDistanceToViewerSq<bCalculateLODPerViewer>(EntityPerViewerInfo, ViewerIdx, FLT_MAX);\n\t\t\t\t\t\tconst EMassLOD::Type PrevLODPerViewer = GetLODPerViewer<bCalculateLODPerViewer>(EntityLOD, ViewerIdx, EntityLOD.LOD);\n\n\t\t\t\t\t\t// Find new LOD\n\t\t\t\t\t\tconst EMassLOD::Type LODPerViewer = ComputeLODFromSettings<bCalculateVisibilityPerViewer>(PrevLODPerViewer, DistanceToViewerSq, bIsInVisibleRange, &bIsInAVisibleRange, RuntimeData);\n\n\t\t\t\t\t\t// Set Per viewer LOD\n\t\t\t\t\t\tSetPrevLODPerViewer<bCalculateLODPerViewer>(EntityLOD, ViewerIdx, PrevLODPerViewer);\n\t\t\t\t\t\tSetLODPerViewer<bCalculateLODPerViewer>(EntityLOD, ViewerIdx, LODPerViewer);\n\n\t\t\t\t\t\tif (bMaximizeCountPerViewer)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Accumulate in buckets\n\t\t\t\t\t\t\tAccumulateCountInRuntimeData<bCalculateVisibilityPerViewer, false>(LODPerViewer, DistanceToViewerSq, bIsInVisibleRange, RuntimeDataPerViewer[ViewerIdx]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set visibility\n\t\t\t\t\tSetPrevVisibilityPerViewer<bCalculateVisibilityPerViewer>(EntityLOD, ViewerIdx, bIsInAVisibleRange ? (bIsVisibleByAViewer ? EMassVisibility::CanBeSeen : EMassVisibility::CulledByFrustum) : EMassVisibility::CulledByDistance);\n\t\t\t\t\tSetVisibilityPerViewer<bCalculateVisibilityPerViewer>(EntityLOD, ViewerIdx, PrevVisibilityPerViewer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ntemplate <typename FLODLogic>\ntemplate <bool bCalculateVisibility>\nbool TMassLODCalculator<FLODLogic>::AdjustDistancesFromCountForRuntimeData(const TStaticArray<int32, EMassLOD::Max>& MaxCount, FMassLODRuntimeData& Data) const\n{\n\tint32 Count = 0;\n\tint32 ProcessingLODIdx = EMassLOD::High;\n\n\tbool bNeedAdjustments = false;\n\n\t// Go through all LOD can start counting from the high LOD\n\tfor (int32 BucketLODIdx = 0; BucketLODIdx < EMassLOD::Max - 1; ++BucketLODIdx)\n\t{\n\t\t// Switch to next LOD if we have not reach the max\n\t\tif (ProcessingLODIdx < BucketLODIdx)\n\t\t{\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\t\t// Save the count of this LOD for this frame\n\t\t\tData.LastCalculatedLODCount[ProcessingLODIdx] = Count;\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t\t\t// Switch to next LOD\n\t\t\tProcessingLODIdx = BucketLODIdx;\n\n\t\t\t// Restart the count\n\t\t\tCount = 0;\n\t\t}\n\n\t\t// Count entities through all buckets of this LOD\n\t\tfor (int32 BucketIdx = 0; BucketIdx < UE::MassLOD::MaxBucketsPerLOD; ++BucketIdx)\n\t\t{\n\t\t\tif (bCalculateVisibility)\n\t\t\t{\n\t\t\t\t// Do visible count first to prioritize them over none visible for that bucket idx\n\t\t\t\tCount += Data.VisibleBucketCounts[BucketLODIdx][BucketIdx];\n\n\t\t\t\twhile (Count > MaxCount[ProcessingLODIdx])\n\t\t\t\t{\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\t\t\t\t// Save the count of this LOD for this frame\n\t\t\t\t\tData.LastCalculatedLODCount[ProcessingLODIdx] = Count - Data.VisibleBucketCounts[BucketLODIdx][BucketIdx];\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t\t\t\t\t// Switch to next LOD\n\t\t\t\t\tProcessingLODIdx++;\n\n\t\t\t\t\t// Adjust distance for this LOD\n\t\t\t\t\tData.AdjustedBaseLODDistance[ProcessingLODIdx] = BaseLODDistance[BucketLODIdx] + (static_cast<float>(BucketIdx) * BaseBucketSize[BucketLODIdx]);\n\t\t\t\t\tData.AdjustedBaseLODDistanceSq[ProcessingLODIdx] = FMath::Square(Data.AdjustedBaseLODDistance[ProcessingLODIdx]);\n\t\t\t\t\tData.AdjustedVisibleLODDistance[ProcessingLODIdx] = VisibleLODDistance[BucketLODIdx] + (static_cast<float>(BucketIdx) * VisibleBucketSize[BucketLODIdx]);\n\t\t\t\t\tData.AdjustedVisibleLODDistanceSq[ProcessingLODIdx] = FMath::Square(Data.AdjustedVisibleLODDistance[ProcessingLODIdx]);\n\n\t\t\t\t\t// Check if we are done\n\t\t\t\t\tif (ProcessingLODIdx == EMassLOD::Off)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Start the next LOD count with the bucket count that made it go over\n\t\t\t\t\tCount = Data.VisibleBucketCounts[BucketLODIdx][BucketIdx];\n\n\t\t\t\t\tbNeedAdjustments = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add base count\n\t\t\tCount += Data.BaseBucketCounts[BucketLODIdx][BucketIdx];\n\n\t\t\t// Check if the count is going over max\n\t\t\twhile (Count > MaxCount[ProcessingLODIdx])\n\t\t\t{\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\t\t\t// Save the count of this LOD for this frame\n\t\t\t\tData.LastCalculatedLODCount[ProcessingLODIdx] = Count - Data.BaseBucketCounts[BucketLODIdx][BucketIdx];\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t\t\t\t// Switch to next LOD\n\t\t\t\tProcessingLODIdx++;\n\n\t\t\t\t// Adjust distance for this LOD\n\t\t\t\tData.AdjustedBaseLODDistance[ProcessingLODIdx] = BaseLODDistance[BucketLODIdx] + (static_cast<float>(BucketIdx) * BaseBucketSize[BucketLODIdx]);\n\t\t\t\tData.AdjustedBaseLODDistanceSq[ProcessingLODIdx] = FMath::Square(Data.AdjustedBaseLODDistance[ProcessingLODIdx]);\n\t\t\t\tif (bCalculateVisibility)\n\t\t\t\t{\n\t\t\t\t\tData.AdjustedVisibleLODDistance[ProcessingLODIdx] = VisibleLODDistance[BucketLODIdx] + (static_cast<float>(BucketIdx + 1) * VisibleBucketSize[BucketLODIdx]);\n\t\t\t\t\tData.AdjustedVisibleLODDistanceSq[ProcessingLODIdx] = FMath::Square(Data.AdjustedVisibleLODDistance[ProcessingLODIdx]);\n\t\t\t\t}\n\n\t\t\t\t// Check if we are done\n\t\t\t\tif (ProcessingLODIdx == EMassLOD::Off)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// Start the next LOD count with the bucket count that made it go over\n\t\t\t\tCount = Data.BaseBucketCounts[BucketLODIdx][BucketIdx];\n\n\t\t\t\tbNeedAdjustments = true;\n\t\t\t}\n\t\t}\n\t}\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\tif (ProcessingLODIdx < EMassLOD::Max - 1)\n\t{\n\t\t// Save the count of this LOD for this frame\n\t\tData.LastCalculatedLODCount[ProcessingLODIdx] = Count;\n\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\treturn bNeedAdjustments;\n}\n\n\ntemplate <typename FLODLogic>\ntemplate <bool bCalculateVisibility, bool bCalculateVisibilityPerViewer, bool bMaximizeCountPerViewer>\nbool TMassLODCalculator<FLODLogic>::AdjustDistancesFromCount()\n{\n\tstatic_assert(!bCalculateVisibility || FLODLogic::bDoVisibilityLogic, \"FLODLogic must have bDoVisibilityLogic enabled to calculate visibility.\");\n\tstatic_assert(!bCalculateVisibilityPerViewer || (FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer), \"FLODLogic must have bDoVisibilityLogic and bStoreInfoPerViewer enabled to calculate visibility per viewer.\");\n\tstatic_assert(!bMaximizeCountPerViewer || FLODLogic::bMaximizeCountPerViewer, \"FLODLogic must have bMaximizeCountPerViewer enabled to maximize count per viewer.\");\n\n\tbool bDistanceAdjusted = false;\n\tif (bMaximizeCountPerViewer)\n\t{\n\t\tfor (int ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)\n\t\t{\n\t\t\tif (!Viewers[ViewerIdx].Handle.IsValid())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbDistanceAdjusted |= AdjustDistancesFromCountForRuntimeData<bCalculateVisibilityPerViewer>(LODMaxCountPerViewer, RuntimeDataPerViewer[ViewerIdx]);\n\t\t}\n\t}\n\n\tbDistanceAdjusted |= AdjustDistancesFromCountForRuntimeData<bCalculateVisibility>(LODMaxCount, RuntimeData);\n\treturn bDistanceAdjusted;\n}\n\ntemplate <typename FLODLogic>\ntemplate <typename TViewerInfoFragment, typename TLODFragment, typename TPerViewerInfoFragment,\n\t\t  bool bCalculateLocalViewers, bool bCalculateVisibility, bool bCalculateLODPerViewer, bool bCalculateVisibilityPerViewer, bool bMaximizeCountPerViewer>\nvoid TMassLODCalculator<FLODLogic>::AdjustLODFromCount(FMassExecutionContext& Context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   TConstArrayView<TViewerInfoFragment> ViewersInfoList,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   TArrayView<TLODFragment> LODList,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   TConstArrayView<TPerViewerInfoFragment> PerViewerInfoList)\n{\n\tstatic_assert(!bCalculateVisibility || FLODLogic::bDoVisibilityLogic, \"FLODLogic must have bDoVisibilityLogic enabled to calculate visibility.\");\n\tstatic_assert(!bCalculateLODPerViewer || FLODLogic::bCalculateLODPerViewer, \"FLODLogic must have bCalculateLODPerViewer enabled to calculate LOD Per viewer.\");\n\tstatic_assert(!bCalculateVisibilityPerViewer || (FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer), \"FLODLogic must have bDoVisibilityLogic and bStoreInfoPerViewer enabled to calculate visibility per viewer.\");\n\tstatic_assert(!bMaximizeCountPerViewer || FLODLogic::bMaximizeCountPerViewer, \"FLODLogic must have bMaximizeCountPerViewer enabled to maximize count per viewer.\");\n\n\tconst int32 NumEntities = Context.GetNumEntities();\n\t// Adjust LOD for each viewer and remember the new highest\n\tfor (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t{\n\t\tconst TViewerInfoFragment& EntityViewersInfo = ViewersInfoList[EntityIdx];\n\t\tTLODFragment& EntityLOD = LODList[EntityIdx];\n\t\tEMassLOD::Type HighestViewerLOD = EMassLOD::Off;\n\t\tif (bMaximizeCountPerViewer)\n\t\t{\n\t\t\tconst TPerViewerInfoFragment& EntityPerViewerInfo = PerViewerInfoList[EntityIdx];\n\n\t\t\tfor (int ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)\n\t\t\t{\n\t\t\t\tconst FViewerLODInfo& Viewer = Viewers[ViewerIdx];\n\t\t\t\tif (!Viewer.Handle.IsValid())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Check to see if we want only local viewer only\n\t\t\t\tif (bCalculateLocalViewers && !Viewer.bLocal)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst float DistanceToViewerSq = GetDistanceToViewerSq<bMaximizeCountPerViewer>(EntityPerViewerInfo, ViewerIdx, FLT_MAX);\n\t\t\t\t// Using the prev visibility here as it was already updated for this frame in the CalculateLOD method and we want the previous one\n\t\t\t\tconst bool bIsVisibleByViewer = GetPrevVisibilityPerViewer<bCalculateVisibilityPerViewer>(EntityLOD, ViewerIdx, EMassVisibility::Max) == EMassVisibility::CanBeSeen;\n\t\t\t\tEMassLOD::Type LODPerViewer = GetLODPerViewer<bCalculateLODPerViewer>(EntityLOD, ViewerIdx, EntityLOD.LOD);\n\n\t\t\t\tLODPerViewer = ComputeLODFromSettings<bCalculateVisibilityPerViewer>(LODPerViewer, DistanceToViewerSq, bIsVisibleByViewer, nullptr, RuntimeDataPerViewer[ViewerIdx]);\n\n\t\t\t\tif (LODPerViewer < HighestViewerLOD)\n\t\t\t\t{\n\t\t\t\t\tHighestViewerLOD = LODPerViewer;\n\t\t\t\t}\n\n\t\t\t\tSetLODPerViewer<bCalculateLODPerViewer>(EntityLOD, ViewerIdx, LODPerViewer);\n\t\t\t}\n\t\t}\n\n\t\t// Using the prev visibility here as it was already updated for this frame in the CalculateLOD method and we want the previous one\n\t\tconst bool bIsVisibleByAViewer = GetPrevVisibility<bCalculateVisibility>(EntityLOD, EMassVisibility::Max) == EMassVisibility::CanBeSeen;\n\t\tEMassLOD::Type NewLOD = ComputeLODFromSettings<bCalculateVisibility>(EntityLOD.PrevLOD, EntityViewersInfo.ClosestViewerDistanceSq, bIsVisibleByAViewer, nullptr, RuntimeData);\n\n\t\t// Maybe the highest of all the viewers is now lower than the global entity LOD, make sure to update it accordingly\n\t\tif (bMaximizeCountPerViewer && NewLOD > HighestViewerLOD)\n\t\t{\n\t\t\tNewLOD = HighestViewerLOD;\n\t\t}\n\t\tif (EntityLOD.LOD != NewLOD)\n\t\t{\n\t\t\tEntityLOD.LOD = NewLOD;\n\t\t\tif (FLODLogic::bCalculateLODSignificance)\n\t\t\t{\n\t\t\t\tfloat LODSignificance = 0.f;\n\t\t\t\tif (NewLOD == EMassLOD::Off)\n\t\t\t\t{\n\t\t\t\t\tLODSignificance = float(EMassLOD::Off);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tconst TStaticArray<float, EMassLOD::Max>& AdjustedLODDistance = bCalculateVisibility && bIsVisibleByAViewer ? RuntimeData.AdjustedVisibleLODDistance : RuntimeData.AdjustedBaseLODDistance;\n\n\t\t\t\t\t// Need to clamp as the Sqrt is not precise enough and always end up with floating calculation errors\n\t\t\t\t\tconst float DistanceBetweenLODThresholdAndEntity = FMath::Max(FMath::Sqrt(EntityViewersInfo.ClosestViewerDistanceSq) - AdjustedLODDistance[NewLOD], 0.f);\n\n\t\t\t\t\t// Derive significance from distance between viewer and where the agent stands between both LOD threshold\n\t\t\t\t\tconst float AdjustedDistanceBetweenCurrentLODAndNext = AdjustedLODDistance[NewLOD + 1] - AdjustedLODDistance[NewLOD];\n\t\t\t\t\tconst float PartialLODSignificance = DistanceBetweenLODThresholdAndEntity / AdjustedDistanceBetweenCurrentLODAndNext;\n\t\t\t\t\tLODSignificance = float(NewLOD) + PartialLODSignificance;\n\t\t\t\t}\n\n\t\t\t\tSetLODSignificance<FLODLogic::bCalculateLODSignificance>(EntityLOD, LODSignificance);\n\t\t\t}\n\t\t}\n\t}\n}\n\ntemplate <typename FLODLogic>\ntemplate <typename TLODFragment>\nvoid TMassLODCalculator<FLODLogic>::ForceOffLOD(FMassExecutionContext& Context, TArrayView<TLODFragment> LODList)\n{\n\tconst int32 NumEntities = Context.GetNumEntities();\n\tfor (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t{\n\t\tTLODFragment& EntityLOD = LODList[EntityIdx];\n\n\t\t// Force off LOD\n\t\tEntityLOD.PrevLOD = EntityLOD.LOD;\n\t\tEntityLOD.LOD = EMassLOD::Off;\n\n\t\t// Set visibility as not calculated\n\t\tSetPrevVisibility<FLODLogic::bDoVisibilityLogic>(EntityLOD, EMassVisibility::Max);\n\t\tSetVisibility<FLODLogic::bDoVisibilityLogic>(EntityLOD, EMassVisibility::Max);\n\n\t\tif (FLODLogic::bStoreInfoPerViewer)\n\t\t{\n\t\t\tfor (int ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)\n\t\t\t{\n\t\t\t\tif (!Viewers[ViewerIdx].Handle.IsValid())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tSetLODPerViewer<FLODLogic::bCalculateLODPerViewer>(EntityLOD, ViewerIdx, EMassLOD::Off);\n\t\t\t\tSetPrevLODPerViewer<FLODLogic::bCalculateLODPerViewer>(EntityLOD, ViewerIdx, EMassLOD::Off);\n\t\t\t\tSetPrevVisibilityPerViewer<FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer>(EntityLOD, ViewerIdx, EMassVisibility::Max);\n\t\t\t\tSetVisibilityPerViewer<FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer>(EntityLOD, ViewerIdx, EMassVisibility::Max);\n\t\t\t}\n\t\t}\n\n\t\tSetLODSignificance<FLODLogic::bCalculateLODSignificance>(EntityLOD, float(EMassLOD::Off));\n\t}\n}\n\n#if WITH_MASSGAMEPLAY_DEBUG\ntemplate <typename FLODLogic>\ntemplate <typename TLODFragment, typename TTransformFragment>\nvoid TMassLODCalculator<FLODLogic>::DebugDisplayLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TConstArrayView<TTransformFragment> LocationList, UWorld* World)\n{\n\tconst int32 NumEntities = Context.GetNumEntities();\n\tfor (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t{\n\t\tconst TTransformFragment& EntityLocation = LocationList[EntityIdx];\n\t\tconst TLODFragment& EntityLOD = LODList[EntityIdx];\n\t\tint32 LODIdx = (int32)EntityLOD.LOD;\n\t\tDrawDebugSolidBox(World, EntityLocation.GetTransform().GetLocation() + FVector(0.0f, 0.0f, 120.0f), FVector(25.0f), UE::MassLOD::LODColors[LODIdx]);\n\t}\n}\n\ntemplate <typename FLODLogic>\ntemplate <typename TLODFragment, typename TTransformFragment>\nvoid TMassLODCalculator<FLODLogic>::DebugDisplaySignificantLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TConstArrayView<TTransformFragment> LocationList, UWorld* World, const float MaxLODSignificance)\n{\n\tconst int32 NumEntities = Context.GetNumEntities();\n\tfor (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t{\n\t\tconst TLODFragment& EntityLOD = LODList[EntityIdx];\n\t\tif (EntityLOD.LODSignificance <= MaxLODSignificance)\n\t\t{\n\t\t\tconst TTransformFragment& EntityLocation = LocationList[EntityIdx];\n\t\t\tint32 LODIdx = (int32)EntityLOD.LOD;\n\t\t\tDrawDebugSolidBox(World, EntityLocation.GetTransform().GetLocation() + FVector(0.0f, 0.0f, 120.0f), FVector(25.0f), UE::MassLOD::LODColors[LODIdx]);\n\t\t}\n\t}\n}\n\ntemplate <typename FLODLogic>\ntemplate <typename TLODFragment, typename TTransformFragment>\nvoid TMassLODCalculator<FLODLogic>::VisLogLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TConstArrayView<TTransformFragment> LocationList, UObject* LogOwner)\n{\n#if ENABLE_VISUAL_LOG\n\tconst int32 NumEntities = Context.GetNumEntities();\n\tfor (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t{\n\t\tconst TTransformFragment& EntityLocation = LocationList[EntityIdx];\n\t\tconst TLODFragment& EntityLOD = LODList[EntityIdx];\n\t\tint32 LODIdx = (int32)EntityLOD.LOD;\n\t\tUE_VLOG_LOCATION(LogOwner, LogMassLOD, Verbose, EntityLocation.GetTransform().GetLocation(), 20.0f, UE::MassLOD::LODColors[LODIdx], TEXT(\"%s %d\"), *Context.GetEntity(EntityIdx).DebugGetDescription(), LODIdx);\n\t}\n#endif\n}\n\ntemplate <typename FLODLogic>\ntemplate <typename TLODFragment, typename TTransformFragment>\nvoid TMassLODCalculator<FLODLogic>::VisLogSignificantLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TConstArrayView<TTransformFragment> LocationList, UObject* LogOwner, const float MaxLODSignificance)\n{\n#if ENABLE_VISUAL_LOG\n\tconst int32 NumEntities = Context.GetNumEntities();\n\tfor (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t{\n\t\tconst TLODFragment& EntityLOD = LODList[EntityIdx];\n\t\tif (EntityLOD.LODSignificance <= MaxLODSignificance)\n\t\t{\n\t\t\tconst TTransformFragment& EntityLocation = LocationList[EntityIdx];\n\t\t\tint32 LODIdx = (int32)EntityLOD.LOD;\n\t\t\tUE_VLOG_LOCATION(LogOwner, LogMassLOD, Verbose, EntityLocation.GetTransform().GetLocation(), 20, UE::MassLOD::LODColors[LODIdx], TEXT(\"%s %d\"), *Context.GetEntity(EntityIdx).DebugGetDescription(), LODIdx);\n\t\t}\n\t}\n#endif\n}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\ntemplate <typename FLODLogic>\ntemplate<bool bCalculateVisibility>\nEMassLOD::Type TMassLODCalculator<FLODLogic>::ComputeLODFromSettings(const EMassLOD::Type PrevLOD, const float DistanceToViewerSq, const bool bIsVisible, bool* bIsInAVisibleRange, const FMassLODRuntimeData& Data) const\n{\n\tconst TStaticArray<float, EMassLOD::Max>& AdjustedLODDistanceSq = bCalculateVisibility && bIsVisible ? Data.AdjustedVisibleLODDistanceSq : Data.AdjustedBaseLODDistanceSq;\n\tint32 LODDistIdx = EMassLOD::Max - 1;\n\tfor (; LODDistIdx > 0; LODDistIdx--)\n\t{\n\t\tif (DistanceToViewerSq >= AdjustedLODDistanceSq[LODDistIdx])\n\t\t{\n\t\t\t// Validate that we allow going to a single higher LOD level after considering an extended buffer hysteresis on distance for the LOD level we are about to quit to prevent oscillating LOD states\n\t\t\tif (PrevLOD != EMassLOD::Max && (PrevLOD - (EMassLOD::Type)LODDistIdx) == 1)\n\t\t\t{\n\t\t\t\tconst TStaticArray<float, EMassLOD::Max>& AdjustedLODDistance = bCalculateVisibility && bIsVisible ? Data.AdjustedVisibleLODDistance : Data.AdjustedBaseLODDistance;\n\t\t\t\tfloat HysteresisDistance = FMath::Lerp(AdjustedLODDistance[LODDistIdx], AdjustedLODDistance[LODDistIdx + 1], 1.f - BufferHysteresisOnDistanceRatio);\n\t\t\t\tif (DistanceToViewerSq >= FMath::Square(HysteresisDistance))\n\t\t\t\t{\n\t\t\t\t\t// Keep old\n\t\t\t\t\tLODDistIdx = PrevLOD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tEMassLOD::Type NewLOD = (EMassLOD::Type)LODDistIdx;\n\tif(bCalculateVisibility && bIsInAVisibleRange)\n\t{\n\t\t*bIsInAVisibleRange = bIsVisible ? (NewLOD != EMassLOD::Off) : (DistanceToViewerSq < Data.AdjustedVisibleLODDistanceSq[EMassLOD::Off]);\n\t}\n\n\treturn NewLOD;\n}",
      "lines": 895
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Public\\MassLODCollector.h",
      "extension": ".h",
      "size_bytes": 6210,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassLODLogic.h\"\n#include \"MassExecutionContext.h\"\n#include \"DrawDebugHelpers.h\"\n\n\n\n/**\n * Helper struct to collect needed information on each agent that will be needed later for LOD calculation\n *   Requires TTransformFragment fragment.\n *   Stores information in TViewerInfoFragment fragment.\n */\ntemplate <typename FLODLogic = FLODDefaultLogic >\nstruct TMassLODCollector : public FMassLODBaseLogic\n{\n\tTMassLODCollector()\n\t\t: FMassLODBaseLogic(/*bShouldBuildFrustumData=*/FLODLogic::bDoVisibilityLogic)\n\t{}\n\n\t/**\n\t * Prepares execution for the current frame, needed to be called before every execution\n\t * @Param Viewers is the array of all the known viewers\n\t */\n\tvoid PrepareExecution(TConstArrayView<FViewerInfo> Viewers);\n\n\t/**\n\t * Collects the information for LOD calculation, called for each entity chunks\n\t * Use next method when FLODLogic::bStoreInfoPerViewer is enabled\n\t * @Param Context of the chunk execution\n\t * @Param TransformList is the fragment transforms of the entities\n\t * @Param ViewersInfoList is the fragment where to store source information for LOD calculation\n\t */\n\ttemplate <typename TTransformFragment, \n\t\t\t  typename TViewerInfoFragment,\n\t\t\t  bool bCollectLocalViewers = FLODLogic::bLocalViewersOnly,\n\t\t\t  bool bCollectDistanceToFrustum = FLODLogic::bDoVisibilityLogic>\n\tFORCEINLINE void CollectLODInfo(FMassExecutionContext& Context, \n\t\t\t\t\t\t\t\t\tTConstArrayView<TTransformFragment> TransformList, \n\t\t\t\t\t\t\t\t\tTArrayView<TViewerInfoFragment> ViewersInfoList)\n\t{\n\t\tCollectLODInfo<TTransformFragment,\n\t\t\tTViewerInfoFragment,\n\t\t\t/*TPerViewerInfoFragment*/void*,\n\t\t\tbCollectLocalViewers,\n\t\t\tbCollectDistanceToFrustum,\n\t\t\t/*bCollectDistancePerViewer*/false,\n\t\t\t/*bCollectDistanceToFrustumPerViewer*/false>(Context, TransformList, ViewersInfoList, TArrayView<void*>());\n\t}\n\n\n\t/**\n\t * Collects the information for LOD calculation, called for each entity chunks\n\t * Use this version when FLODLogic::bStoreInfoPerViewer is enabled\n\t * It collects information per viewer into the PerViewerInfoList fragments\n\t * @Param Context of the chunk execution\n\t * @Param TransformList is the fragment transforms of the entities\n\t * @Param ViewersInfoList is the fragment where to store source information for LOD calculation\n\t * @Param PerViewerInfoList is the per viewer information\n\t */\n\ttemplate <typename TTransformFragment,\n\t\t\t  typename TViewerInfoFragment,\n\t\t\t  typename TPerViewerInfoFragment,\n\t\t\t  bool bCollectLocalViewers = FLODLogic::bLocalViewersOnly,\n\t\t\t  bool bCollectDistanceToFrustum = FLODLogic::bDoVisibilityLogic,\n\t\t\t  bool bCollectDistancePerViewer = FLODLogic::bStoreInfoPerViewer,\n\t\t\t  bool bCollectDistanceToFrustumPerViewer = FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer>\n\tvoid CollectLODInfo(FMassExecutionContext& Context, \n\t\t\t\t\t\tTConstArrayView<TTransformFragment> TransformList, \n\t\t\t\t\t\tTArrayView<TViewerInfoFragment> ViewersInfoList, \n\t\t\t\t\t\tTArrayView<TPerViewerInfoFragment> PerViewerInfoList);\n};\n\ntemplate <typename FLODLogic>\nvoid TMassLODCollector<FLODLogic>::PrepareExecution(TConstArrayView<FViewerInfo> ViewersInfo)\n{\n\tCacheViewerInformation(ViewersInfo);\n}\n\ntemplate <typename FLODLogic>\ntemplate <typename TTransformFragment, \n\t\t  typename TViewerInfoFragment, \n\t\t  typename TPerViewerInfoFragment,\n\t\t  bool bCollectLocalViewers,\n\t\t  bool bCollectDistanceToFrustum,\n\t\t  bool bCollectDistancePerViewer,\n\t\t  bool bCollectDistanceToFrustumPerViewer>\nvoid TMassLODCollector<FLODLogic>::CollectLODInfo(FMassExecutionContext& Context, \n\t\t\t\t\t\t\t\t\t\t\t\t  TConstArrayView<TTransformFragment> TransformList, \n\t\t\t\t\t\t\t\t\t\t\t\t  TArrayView<TViewerInfoFragment> ViewersInfoList, \n\t\t\t\t\t\t\t\t\t\t\t\t  TArrayView<TPerViewerInfoFragment> PerViewerInfoList)\n{\n\tstatic TPerViewerInfoFragment DummyFragment;\n\tconst int32 NumEntities = Context.GetNumEntities();\n\tfor (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t{\n\t\tfloat ClosestViewerDistanceSq = FLT_MAX;\n\t\tfloat ClosestDistanceToFrustum = FLT_MAX;\n\t\tconst TTransformFragment& EntityTransform = TransformList[EntityIdx];\n\t\tTViewerInfoFragment& EntityViewerInfo = ViewersInfoList[EntityIdx];\n\t\tTPerViewerInfoFragment& EntityInfoPerViewer = FLODLogic::bStoreInfoPerViewer ? PerViewerInfoList[EntityIdx] : DummyFragment;\n\n\t\tSetDistanceToViewerSqNum<bCollectDistancePerViewer>(EntityInfoPerViewer, Viewers.Num());\n\t\tSetDistanceToFrustumNum<bCollectDistanceToFrustumPerViewer>(EntityInfoPerViewer, Viewers.Num());\n\t\tfor (int ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)\n\t\t{\n\t\t\tconst FViewerLODInfo& Viewer = Viewers[ViewerIdx];\n\t\t\tif (Viewer.bClearData)\n\t\t\t{\n\t\t\t\tSetDistanceToViewerSq<bCollectDistancePerViewer>(EntityInfoPerViewer, ViewerIdx, FLT_MAX);\n\t\t\t\tSetDistanceToFrustum<bCollectDistanceToFrustumPerViewer>(EntityInfoPerViewer, ViewerIdx, FLT_MAX);\n\t\t\t}\n\n\t\t\t// Check to see if we want only local viewer only\n\t\t\tif (bCollectLocalViewers && !Viewer.bLocal)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (Viewer.Handle.IsValid())\n\t\t\t{\n\t\t\t\tconst FVector& EntityLocation = EntityTransform.GetTransform().GetLocation();\n\t\t\t\tconst FVector ViewerToEntity = EntityLocation - Viewer.Location;\n\t\t\t\tconst float DistanceToViewerSq = static_cast<float>(ViewerToEntity.SizeSquared()); // float precision is acceptable for LOD\n\t\t\t\tif (ClosestViewerDistanceSq > DistanceToViewerSq)\n\t\t\t\t{\n\t\t\t\t\tClosestViewerDistanceSq = DistanceToViewerSq;\n\t\t\t\t}\n\t\t\t\tSetDistanceToViewerSq<bCollectDistancePerViewer>(EntityInfoPerViewer, ViewerIdx, DistanceToViewerSq);\n\n\t\t\t\tif constexpr (bCollectDistanceToFrustum)\n\t\t\t\t{\n\t\t\t\t\tconst float DistanceToFrustum = Viewer.Frustum.DistanceTo(EntityLocation);\n\t\t\t\t\tSetDistanceToFrustum<bCollectDistanceToFrustumPerViewer>(EntityInfoPerViewer, ViewerIdx, DistanceToFrustum);\n\t\t\t\t\tif (ClosestDistanceToFrustum > DistanceToFrustum)\n\t\t\t\t\t{\n\t\t\t\t\t\tClosestDistanceToFrustum = DistanceToFrustum;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEntityViewerInfo.ClosestViewerDistanceSq = ClosestViewerDistanceSq;\n\t\tSetClosestDistanceToFrustum<bCollectDistanceToFrustum>(EntityViewerInfo, ClosestDistanceToFrustum);\n\t}\n}",
      "lines": 147
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Public\\MassLODCollectorProcessor.h",
      "extension": ".h",
      "size_bytes": 1611,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassProcessor.h\"\n#include \"MassLODCollector.h\"\n\n#include \"MassLODCollectorProcessor.generated.h\"\n\nstruct FMassGenericCollectorLogic : public FLODDefaultLogic\n{\n\tenum\n\t{\n\t\tbDoVisibilityLogic = true,\n\t};\n};\n\n/*\n * LOD collector which combines collection of LOD information for both Viewer and Simulation LODing when possible.\n */\nUCLASS(meta = (DisplayName = \"LOD Collector\"))\nclass MASSLOD_API UMassLODCollectorProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassLODCollectorProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\ttemplate <bool bLocalViewersOnly>\n\tvoid CollectLODForChunk(FMassExecutionContext& Context);\n\n\ttemplate <bool bLocalViewersOnly>\n\tvoid ExecuteInternal(FMassEntityManager& EntityManager, FMassExecutionContext& Context);\n\n\tTMassLODCollector<FMassGenericCollectorLogic> Collector;\n\n\t// Queries for visualization and simulation calculation\n\t/** All entities that are in visible range and are On LOD*/\n\tFMassEntityQuery EntityQuery_VisibleRangeAndOnLOD;\n\t/** All entities that are in visible range but are Off LOD */\n\tFMassEntityQuery EntityQuery_VisibleRangeOnly;\n\t/** All entities that are NOT in visible range but are On LOD */\n\tFMassEntityQuery EntityQuery_OnLODOnly;\n\t/** All entities that are Not in visible range and are at Off LOD */\n\tFMassEntityQuery EntityQuery_NotVisibleRangeAndOffLOD;\n};\n",
      "lines": 51
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Public\\MassLODDistanceCollectorProcessor.h",
      "extension": ".h",
      "size_bytes": 1731,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassProcessor.h\"\n#include \"MassLODCollector.h\"\n#include \"MassLODLogic.h\"\n#include \"MassLODDistanceCollectorProcessor.generated.h\"\n\n/*\n * LOD Distance collector which combines collection of LOD information for both Viewer and Simulation LODing.\n * This collector cares only about the entities' distance to LOD viewer location, nothing else. \n * Matches MassDistanceLODProcessor logic which uses the same Calculator LODLogic\n */\nUCLASS(meta = (DisplayName = \"LOD Distance Collector\"))\nclass MASSLOD_API UMassLODDistanceCollectorProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassLODDistanceCollectorProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\ttemplate <bool bLocalViewersOnly>\n\tvoid CollectLODForChunk(FMassExecutionContext& Context);\n\n\ttemplate <bool bLocalViewersOnly>\n\tvoid ExecuteInternal(FMassEntityManager& EntityManager, FMassExecutionContext& Context);\n\n\tTMassLODCollector<FMassDistanceLODLogic> Collector;\n\n\t// Queries for visualization and simulation calculation\n\t/** All entities that are in relevant range and are On LOD*/\n\tFMassEntityQuery EntityQuery_RelevantRangeAndOnLOD;\n\t/** All entities that are in relevant range but are Off LOD */\n\tFMassEntityQuery EntityQuery_RelevantRangeOnly;\n\t/** All entities that are NOT in relevant range but are On LOD */\n\tFMassEntityQuery EntityQuery_OnLODOnly;\n\t/** All entities that are Not in relevant range and are at Off LOD */\n\tFMassEntityQuery EntityQuery_NotRelevantRangeAndOffLOD;\n};\n",
      "lines": 45
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Public\\MassLODFragments.h",
      "extension": ".h",
      "size_bytes": 6644,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassLODTypes.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassLODFragments.generated.h\"\n\nUSTRUCT()\nstruct MASSLOD_API FMassHighLODTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\nUSTRUCT()\nstruct MASSLOD_API FMassMediumLODTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\nUSTRUCT()\nstruct MASSLOD_API FMassLowLODTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\nUSTRUCT()\nstruct MASSLOD_API FMassOffLODTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\n/*\n * Data fragment to store the calculated distances to viewers\n */\nUSTRUCT()\nstruct MASSLOD_API FMassViewerInfoFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\t// Closest viewer distance\n\tUPROPERTY()\n\tfloat ClosestViewerDistanceSq = FLT_MAX;\n\n\t// Closest distance to frustum\n\tUPROPERTY()\n\tfloat ClosestDistanceToFrustum = FLT_MAX;\n};\n\nUSTRUCT()\nstruct MASSLOD_API FMassVariableTickChunkFragment : public FMassChunkFragment\n{\n\tGENERATED_BODY();\n\n\tbool ShouldTickThisFrame() const\n\t{\n\t\treturn bShouldTickThisFrame;\n\t}\n\n\tfloat GetTimeUntilNextTick() const\n\t{\n\t\treturn TimeUntilNextTick;\n\t}\n\n\tint32 GetLastChunkSerialModificationNumber() const\n\t{\n\t\treturn LastChunkSerialModificationNumber;\n\t}\n\n\tEMassLOD::Type GetLOD() const\n\t{\n\t\treturn LOD;\n\t}\n\n\tvoid SetLOD(EMassLOD::Type InLOD)\n\t{\n\t\tcheckf(LOD == EMassLOD::Max, TEXT(\"Chunk LOD should never change, it is allowed to only set it once\"))\n\t\tLOD = InLOD;\n\t}\n\n\tvoid Update(const bool bInShouldTickThisFrame, const float InTimeUntilNextTick, int32 ChunkSerialModificationNumber)\n\t{\n\t\tbShouldTickThisFrame = bInShouldTickThisFrame;\n\t\tTimeUntilNextTick = InTimeUntilNextTick;\n\t\tLastChunkSerialModificationNumber = ChunkSerialModificationNumber;\n\t}\n\nprivate:\n\tUPROPERTY()\n\tbool bShouldTickThisFrame = true;\n\n\tUPROPERTY()\n\tTEnumAsByte<EMassLOD::Type> LOD = EMassLOD::Max;\n\n\tUPROPERTY()\n\tfloat TimeUntilNextTick = 0.0f;\n\n\tUPROPERTY()\n\tint32 LastChunkSerialModificationNumber = INDEX_NONE;\n};\n\nUSTRUCT()\nstruct FMassCollectLODViewerInfoTag : public FMassTag\n{\n\tGENERATED_BODY();\n};\n\n/*\n * Tag to use to trigger the collector processor that uses the LODCollector without Visibility Logic, so strictly based of distance\n */\nUSTRUCT()\nstruct FMassCollectDistanceLODViewerInfoTag : public FMassTag\n{\n\tGENERATED_BODY();\n};\n\nUSTRUCT()\nstruct MASSLOD_API FMassVisibilityCanBeSeenTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\nUSTRUCT()\nstruct MASSLOD_API FMassVisibilityCulledByFrustumTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\nUSTRUCT()\nstruct MASSLOD_API FMassVisibilityCulledByDistanceTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\nUSTRUCT()\nstruct MASSLOD_API FMassVisualizationChunkFragment : public FMassChunkFragment\n{\n\tGENERATED_BODY();\n\n\t/**\n\t * Fetched existing chunk fragment to know if there is a possibility of a an entity that is visible\n\t * In the case that there is not chunk information, we cannot assume that all entities are not visible.\n\t *\n\t * @param Context of the execution from the entity sub system\n\t * @return true if there is a possibility that the chunk contains a visible entity\n\t */\n\tstatic bool AreAnyEntitiesVisibleInChunk(const FMassExecutionContext& Context)\n\t{\n\t\treturn Context.GetChunkFragment<FMassVisualizationChunkFragment>().AreAnyEntitiesVisible();\n\t}\n\n\t/**\n\t * Returns if there could be a visible entities in that chunk\n\t *\n\t * @return true if that is the case\n\t */\n\tbool AreAnyEntitiesVisible() const\n\t{\n\t\treturn (Visibility != EMassVisibility::CulledByDistance && Visibility != EMassVisibility::CulledByFrustum) || bContainsNewlyVisibleEntity;\n\t}\n\n\t/**\n\t * IsChunkHandledThisFrame\n\t *\n\t * This function is used by LOD collector query chunk filters to check that visual LOD will be updated this frame. \n\t * It defaults to false (no LOD update), if visualization chunk fragment is NOT present.\n\t * \n\t * @param Context of the execution from the entity sub system\n\t * @return true if the visual LOD will be updated this frame\n\t */\n\tstatic bool IsChunkHandledThisFrame(const FMassExecutionContext& Context)\n\t{\n\t\tconst FMassVisualizationChunkFragment* ChunkFragment = Context.GetChunkFragmentPtr<FMassVisualizationChunkFragment>();\n\t\treturn ChunkFragment != nullptr && ChunkFragment->ShouldUpdateVisualization();\n\t}\n\n\t/**\n\t * ShouldUpdateVisualizationForChunk\n\t * \n\t * This function is used by query chunk filters in processors that require variable visual LOD update. \n\t * It defaults to true (always updating) if visualization chunk fragment is NOT present.\n\t *\n\t * @param Context of the execution from the entity sub system\n\t * @return true if the chunk should update the visual this frame\n\t */\n\tstatic bool ShouldUpdateVisualizationForChunk(const FMassExecutionContext& Context)\n\t{\n\t\tconst FMassVisualizationChunkFragment* ChunkFragment = Context.GetChunkFragmentPtr<FMassVisualizationChunkFragment>();\n\t\treturn ChunkFragment == nullptr || ChunkFragment->ShouldUpdateVisualization();\n\t}\n\n\t/**\n\t * Representation type of all currently visible entities are always updated\n\t * But as an optimization, we use a frequency check on the not visible one.\n\t *\n\t * @return true if we should update the representation type for this chunk\n\t */\n\tbool ShouldUpdateVisualization() const\n\t{\n\t\treturn Visibility != EMassVisibility::CulledByDistance || DeltaTime <= 0.0f;\n\t}\n\n\tvoid SetContainsNewlyVisibleEntity(bool bInContainsNewlyVisibleEntity)\n\t{\n\t\tif (bInContainsNewlyVisibleEntity)\n\t\t{\n\t\t\tcheckfSlow(Visibility != EMassVisibility::CanBeSeen, TEXT(\"Something is not adding up, how can an entity be newly visible in a can be seen chunk?\"));\n\t\t\tbContainsNewlyVisibleEntity = true;\n\t\t}\n\t}\n\n\tvoid SetVisibility(const EMassVisibility InVisibility)\n\t{\n\t\tcheckf(Visibility == EMassVisibility::Max, TEXT(\"Chunk visibility should never change, it is allowed to only set it once\"));\n\t\tVisibility = InVisibility;\n\t}\n\n\tEMassVisibility GetVisibility() const\n\t{\n\t\treturn Visibility;\n\t}\n\n\tfloat GetDeltaTime() const\n\t{\n\t\treturn DeltaTime;\n\t}\n\n\tvoid Update(float InDeltaTime)\n\t{\n\t\tbContainsNewlyVisibleEntity = false;\n\t\tDeltaTime = InDeltaTime;\n\t}\n\nprotected:\n\n\t/** Visibility of the current chunk, should never change */\n\tUPROPERTY()\n\tEMassVisibility Visibility = EMassVisibility::Max;\n\n\t/** Not visible chunks, might contains entity that are newly visible and not yet moved. */\n\tUPROPERTY()\n\tbool bContainsNewlyVisibleEntity = true;\n\n\t/** Not visible chunks delta time until next update */\n\tUPROPERTY()\n\tfloat DeltaTime = 0;\n};\n",
      "lines": 247
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Public\\MassLODLogic.h",
      "extension": ".h",
      "size_bytes": 8266,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassLODSubsystem.h\"\n#include \"Containers/StaticArray.h\"\n#include \"ConvexVolume.h\"\n\n\n#define DECLARE_CONDITIONAL_MEMBER_ACCESSORS( Condition, MemberType, MemberName ) \\\ntemplate <bool Condition, typename TemplateClass> static FORCEINLINE typename TEnableIf< Condition, MemberType>::Type Get##MemberName(TemplateClass& Obj, MemberType DefaultValue) { return Obj.MemberName; } \\\ntemplate <bool Condition, typename TemplateClass> static FORCEINLINE typename TEnableIf<!Condition, MemberType>::Type Get##MemberName(TemplateClass& Obj, MemberType DefaultValue) { return DefaultValue; } \\\ntemplate <bool Condition, typename TemplateClass> static FORCEINLINE void Set##MemberName(TemplateClass& Obj, typename TEnableIf< Condition, MemberType>::Type Value) { Obj.MemberName = Value; } \\\ntemplate <bool Condition, typename TemplateClass> static FORCEINLINE void Set##MemberName(TemplateClass& Obj, typename TEnableIf<!Condition, MemberType>::Type Value) {}\n\n#define DECLARE_CONDITIONAL_MEMBER_ARRAY_ACCESSORS( Condition, MemberType, MemberName ) \\\ntemplate <bool Condition, typename TemplateClass> static FORCEINLINE void Set##MemberName##Num(TemplateClass& Obj, typename TEnableIf< Condition, int32>::Type Num) { Obj.MemberName.SetNum(Num); } \\\ntemplate <bool Condition, typename TemplateClass> static FORCEINLINE void Set##MemberName##Num(TemplateClass& Obj, typename TEnableIf<!Condition, int32>::Type Num) {} \\\ntemplate <bool Condition, typename TemplateClass> static FORCEINLINE typename TEnableIf< Condition, MemberType>::Type Get##MemberName(TemplateClass& Obj, int32 Index, MemberType DefaultValue) { return Obj.MemberName[Index]; } \\\ntemplate <bool Condition, typename TemplateClass> static FORCEINLINE typename TEnableIf<!Condition, MemberType>::Type Get##MemberName(TemplateClass& Obj, int32 Index, MemberType DefaultValue) { return DefaultValue; } \\\ntemplate <bool Condition, typename TemplateClass> static FORCEINLINE void Set##MemberName(TemplateClass& Obj, int32 Index, typename TEnableIf< Condition, MemberType>::Type Value) { Obj.MemberName[Index] = Value; } \\\ntemplate <bool Condition, typename TemplateClass> static FORCEINLINE void Set##MemberName(TemplateClass& Obj, int32 Index, typename TEnableIf<!Condition, MemberType>::Type Value) {}\n\n/**\n * Traits for LOD logic calculation behaviors\n */\nstruct FLODDefaultLogic\n{\n\tenum\n\t{\n\t\tbStoreInfoPerViewer = false, // Enable to store all calculated information per viewer\n\t\tbCalculateLODPerViewer = false, // Enable to calculate and store the result LOD per viewer in the FMassLODResultInfo::LODPerViewer and FMassLODResultInfo::PrevLODPerViewer, requires bStoreInfoPerViewer to be true as well.\n\t\tbMaximizeCountPerViewer = false, // Enable to maximize count per viewer, requires a valid InLODMaxCountPerViewer parameter during initialization of TMassLODCalculator.\n\t\tbDoVisibilityLogic = false, // Enable to calculate visibility and apply its own LOD distances. Requires a valid InVisibleLODDistance parameter during initialization of TMassLODCalculator.\n\t\tbCalculateLODSignificance = false, // Enable to calculate and set the a more precise LOD floating point significance in member FMassLODResultInfo::LODSignificance.\n\t\tbLocalViewersOnly = false, // Enable to calculate LOD from LocalViewersOnly, otherwise will be done on all viewers.\n\t};\n};\n\nstruct FMassSimulationLODLogic : public FLODDefaultLogic\n{\n};\n\nstruct FMassRepresentationLODLogic : public FLODDefaultLogic\n{\n\tenum\n\t{\n\t\tbDoVisibilityLogic = true,\n\t\tbCalculateLODSignificance = true,\n\t\tbLocalViewersOnly = true,\n\t};\n};\n\nstruct FMassCombinedLODLogic : public FLODDefaultLogic\n{\n\tenum\n\t{\n\t\tbDoVisibilityLogic = true,\n\t\tbCalculateLODSignificance = true,\n\t\tbLocalViewersOnly = true,\n\t};\n};\n\n/** Simplest version of RepresentationLODLogic strictly based on Distance to Viewer\n *\tCompared to FMassRepresentationLODLogic, we:\n *\t* Do not care about doing the Visibility Logic\n *\t* For now we will keep the Significance computation as it could allow for finer grained control later on\n*/\nstruct FMassDistanceLODLogic : public FLODDefaultLogic\n{\n\tenum\n\t{\n\t\tbCalculateLODSignificance = true,\n\t\tbLocalViewersOnly = true,\n\t};\n};\n\n/**\n * TMassLODCollector outputs\n *\nstruct FMassViewerInfoFragment\n{\n\t// Closest viewer distance  (Always needed)\n\tfloat ClosestViewerDistanceSq;\n\n\t// Square distances to each valid viewers (Required when FLODLogic::bStoreInfoPerViewer is enabled)\n\tTArray<float> DistanceToViewerSq;\n};\n\nstruct FMassInfoPerViewerFragment\n{\n\t// Square distances to each valid viewers (Required when FLODLogic::bStoreInfoPerViewer is enabled)\n\tTArray<float> DistanceToViewerSq;\n\n\t// Distances to each valid viewers frustums (Required when FLODLogic::bDoVisibilityLogic and FLODLogic::bStoreInfoPerViewer are enabled)\n\tTArray<float> DistanceToFrustum;\n};\n\n*/\n\n/**\n * TMassLODCalculator outputs\n *\n struct FMassLODFragment\n{\n\t// LOD information\n\tTEnumAsByte<EMassLOD::Type> LOD;\n\tTEnumAsByte<EMassLOD::Type> PrevLOD;\n\n\t// Visibility information (Required when FLODLogic::bDoVisibilityLogic is enabled)\n\tEMassVisibility Visibility;\n\tEMassVisibility PrevVisibility\n\n\t// Floating point LOD value, scaling from 0 to 3, 0 highest LOD and 3 being completely off LOD \n\t// (Required only when FLODLogic::bCalculateLODSignificance is enabled)\n\tfloat LODSignificance = 0.0f; // \n\n\t// Per viewer LOD information (Required when FLODLogic::bCalculateLODPerViewer is enabled)\n\tTArray<EMassLOD::Type> LODPerViewer;\n\tTArray<EMassLOD::Type> PrevLODPerViewer;\n\n\t// Visibility information per viewer (Required when FLODLogic::bDoVisibilityLogic and FLODLogicbStoreInfoPerViewer are enabled)\n\tTArray<EMassVisibility> VisibilityPerViewer;\n\tTArray<EMassVisibility> PrevVisibilityPerViewer;\n}\n*/\n\n/**\n * TMassLODTickRateController outputs\n *\n struct FMassVariableTickFragment\n{\n\t// Accumulated DeltaTime\n\tfloat DeltaTime = 0.0f;\n\tfloat LastTickedTime = 0.0f;\n};\n*/\n\nstruct FViewerLODInfo\n{\n\t/* Boolean indicating the viewer is local or not */\n\tbool bLocal = false;\n\n\t/* Boolean indicating the viewer data needs to be cleared */\n\tbool bClearData = false;\n\n\t/** The handle to the viewer */\n\tFMassViewerHandle Handle;\n\n\t/** Viewer location and looking direction */\n\tFVector Location;\n\tFVector Direction;\n\n\t/** Viewer frustum (will not include near and far planes) */\n\tFConvexVolume Frustum;\n};\n\n/**\n * Base struct for the LOD calculation helpers\n */\nstruct MASSLOD_API FMassLODBaseLogic\n{\n\tFMassLODBaseLogic(bool bShouldBuildFrustumData)\n\t\t: bBuildFrustumData(bShouldBuildFrustumData)\n\t{}\n\nprotected:\n\tvoid CacheViewerInformation(TConstArrayView<FViewerInfo> ViewerInfos);\n\n\t/** Per viewer LOD information conditional fragment accessors */\n\tDECLARE_CONDITIONAL_MEMBER_ARRAY_ACCESSORS(Condition, EMassLOD::Type, LODPerViewer);\n\tDECLARE_CONDITIONAL_MEMBER_ARRAY_ACCESSORS(Condition, EMassLOD::Type, PrevLODPerViewer);\n\n\t/** LOD Significance conditional fragment accessors */\n\tDECLARE_CONDITIONAL_MEMBER_ACCESSORS(Condition, float, LODSignificance);\n\n\t/** Visibility conditional fragment accessors */\n\tDECLARE_CONDITIONAL_MEMBER_ACCESSORS(Condition, float, ClosestDistanceToFrustum);\n\tDECLARE_CONDITIONAL_MEMBER_ACCESSORS(Condition, EMassVisibility, Visibility);\n\tDECLARE_CONDITIONAL_MEMBER_ACCESSORS(Condition, EMassVisibility, PrevVisibility);\n\n\t/** Per viewer distance conditional fragment accessors */\n\tDECLARE_CONDITIONAL_MEMBER_ARRAY_ACCESSORS(Condition, float, DistanceToViewerSq);\n\n\t/** Per viewer visibility conditional fragment accessors */\n\tDECLARE_CONDITIONAL_MEMBER_ARRAY_ACCESSORS(Condition, float, DistanceToFrustum);\n\tDECLARE_CONDITIONAL_MEMBER_ARRAY_ACCESSORS(Condition, EMassVisibility, VisibilityPerViewer);\n\tDECLARE_CONDITIONAL_MEMBER_ARRAY_ACCESSORS(Condition, EMassVisibility, PrevVisibilityPerViewer);\n\n\tTArray<FViewerLODInfo> Viewers;\n\nprivate:\n\t/** \n\t * Setting to false will prevent costly FViewerLODInfo.Frustum creation. Makes sense only if that data is not required.\n\t * Note that this property is not expected to be changed at runtime.\n\t */\n\tbool bBuildFrustumData = true;\n};",
      "lines": 198
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Public\\MassLODSubsystem.h",
      "extension": ".h",
      "size_bytes": 8284,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassCommonTypes.h\"\n#include \"MassProcessor.h\"\n#include \"IndexedHandle.h\"\n#include \"MassLODTypes.h\"\n#include \"MassSubsystemBase.h\"\n#include \"MassExternalSubsystemTraits.h\"\n#include \"MassLODSubsystem.generated.h\"\n\nclass UMassLODSubsystem;\nclass AActor;\nclass APlayerController;\n\n/*\n * Handle that lets you reference the concept of a viewer\n */\nUSTRUCT()\nstruct MASSLOD_API FMassViewerHandle : public FIndexedHandleBase\n{\n\tGENERATED_BODY()\n\n\tfriend class UMassLODSubsystem;\n};\n\nUSTRUCT()\nstruct FViewerInfo\n{\n\tGENERATED_BODY()\n\n\tFViewerInfo() = default;\nPRAGMA_DISABLE_DEPRECATION_WARNINGS\n\tFViewerInfo(const FViewerInfo& Other) = default;\nPRAGMA_ENABLE_DEPRECATION_WARNINGS\n\n\tUPROPERTY(transient)\n\tTObjectPtr<AActor> ActorViewer = nullptr;\n\t\n\tFName StreamingSourceName;\n\n#if WITH_EDITOR\n\tint8 EditorViewportClientIndex = INDEX_NONE;\n#endif // WITH_EDITOR\n\n\tFMassViewerHandle Handle;\n\tuint32 HashValue = 0;\n\n\tFVector Location;\n\tFRotator Rotation;\n\tfloat FOV = 90.0f;\n\tfloat AspectRatio = 16.0f / 9.0f;\n\n\tbool bEnabled = true;\n\n\tvoid Reset();\n\n\tbool IsLocal() const;\n\n\tMASSLOD_API APlayerController* GetPlayerController() const;\nprivate:\n\tUE_DEPRECATED_FORGAME(5.4, \"PlayerController member variable has been deprecated in favor of more generic ActorViewer. Use that instead.\")\n\tTObjectPtr<APlayerController> PlayerController = nullptr;\n};\n\nUE_DEPRECATED(5.3, \"FOnViewerAdded is deprecated. Use UMassLODSubsystem::FOnViewerAdded instead.\")\nDECLARE_MULTICAST_DELEGATE_ThreeParams(FOnViewerAdded, FMassViewerHandle ViewerHandle, APlayerController* PlayerController, FName StreamingSourceName);\nUE_DEPRECATED(5.3, \"FOnViewerRemoved is deprecated. Use UMassLODSubsystem::FOnViewerRemoved instead.\")\nDECLARE_MULTICAST_DELEGATE_ThreeParams(FOnViewerRemoved, FMassViewerHandle ViewerHandle, APlayerController* PlayerController, FName StreamingSourceName);\n\n/*\n * Manager responsible to manage and synchronized available viewers\n */\nUCLASS(config = Mass, defaultconfig)\nclass MASSLOD_API UMassLODSubsystem : public UMassSubsystemBase\n{\n\tGENERATED_BODY()\n\n\tDECLARE_MULTICAST_DELEGATE_OneParam(FOnViewerAdded, const FViewerInfo& ViewerInfo);\n\tDECLARE_MULTICAST_DELEGATE_OneParam(FOnViewerRemoved, const FViewerInfo& ViewerInfo);\n\npublic:\n\t/** Checks the validity of a viewer handle */\n\tbool IsValidViewer(const FMassViewerHandle& ViewerHandle) const { return GetValidViewerIdx(ViewerHandle) != INDEX_NONE; }\n\n\t/** Returns the index of the viewer if valid, otherwise INDEX_NONE is return */\n\tint32 GetValidViewerIdx(const FMassViewerHandle& ViewerHandle) const;\n\n\t/** Returns the array of viewers */\n\tconst TArray<FViewerInfo>& GetViewers() const { return Viewers; }\n\n\t/** Synchronize the viewers if not done this frame and returns the updated array */\n\tconst TArray<FViewerInfo>& GetSynchronizedViewers();\n\n\t/** Returns viewer handle from the PlayerController pointer */\n\tFMassViewerHandle GetViewerHandleFromActor(const AActor& Actor) const;\n\n\t/** Returns viewer handle from the streaming source name */\n\tFMassViewerHandle GetViewerHandleFromStreamingSource(const FName StreamingSourceName) const;\n\n\t/** Returns PlayerController pointer from the viewer handle */\n\tAPlayerController* GetPlayerControllerFromViewerHandle(const FMassViewerHandle& ViewerHandle) const;\n\n\t/** Returns the delegate called when new viewer are added to the list */\n\tFOnViewerAdded& GetOnViewerAddedDelegate() { return OnViewerAddedDelegate;  }\n\n\t/** Returns the delegate called when viewer are removed from the list */\n\tFOnViewerRemoved& GetOnViewerRemovedDelegate() { return OnViewerRemovedDelegate; }\n\n\tvoid RegisterActorViewer(AActor& ActorViewer);\n\tvoid UnregisterActorViewer(AActor& ActorViewer);\n\n\tbool IsUsingPlayerPawnLocationInsteadOfCamera() const { return bUsePlayerPawnLocationInsteadOfCamera; }\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\tvoid DebugSetGatherPlayers(const bool bInValue) { bGatherPlayerControllers = bInValue; }\n\tvoid DebugSetUsePlayerPawnLocationInsteadOfCamera(const bool bInValue) { bUsePlayerPawnLocationInsteadOfCamera = bInValue; }\n\tvoid DebugUnregisterActorViewer();\n#endif\n\nprotected:\n\t// USubsystem BEGIN\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\tvirtual void Deinitialize() override;\n\t// USubsystem END\n\n\t/** Called at the start of the PrePhysics mass processing phase and calls SynchronizeViewers */ \n\tvoid OnPrePhysicsPhaseStarted(float DeltaTime);\n\n\t/** Synchronizes the viewers from the engine PlayerController list */\n\tvoid SynchronizeViewers();\n\n\tUE_DEPRECATED(5.3, \"AddViewer has been deprecated. Use AddPlayerViewer or AddStreamingSourceViewer instead\")\n\tvoid AddViewer(APlayerController* PlayerController, FName StreamingSourceName = NAME_None);\n\n\t/** Adds the given player as a viewer to the list and sends notification about addition */\n\tvoid AddPlayerViewer(APlayerController& PlayerController);\n\n\t/** Adds the given streaming source as a viewer to the list and sends notification about addition */\n\tvoid AddStreamingSourceViewer(const FName StreamingSourceName);\n\n\tvoid AddActorViewer(AActor& ActorViewer);\n\n#if WITH_EDITOR\n\t/** Adds the editor viewport client (identified via an index) as a viewer to the list and sends notification about addition */\n\tvoid AddEditorViewer(const int32 HashValue, const int32 ClientIndex);\n#endif // WITH_EDITOR\n\n\t/** Removes a viewer to the list and send notification about removal */\n\tvoid RemoveViewer(const FMassViewerHandle& ViewerHandle);\n\n\t/** Returns the next new viewer serial number */\n\tuint32 GetNextViewerSerialNumber() { return ViewerSerialNumberCounter++; }\n\n\t/** Player controller EndPlay callback, removing viewers from the list */\n\tUFUNCTION()\n\tvoid OnPlayerControllerEndPlay(AActor* Actor, EEndPlayReason::Type EndPlayReason);\n\nprotected:\n\t/** If true, all PlayerControllers will be gathered as viewers for LOD calculations. */\n\tUPROPERTY(EditDefaultsOnly, Category = \"Mass|LOD\", config)\n\tuint8 bGatherPlayerControllers : 1 = true;\n\n\t/** If true, all streaming sources will be gathered as viewers for LOD calculations. */\n\tUPROPERTY(EditDefaultsOnly, Category = \"Mass|LOD\", config)\n\tuint8 bGatherStreamingSources : 1 = true;\n\n\t/** Whether using non-player actors as LOD Viewers is supported. */\n\tUPROPERTY(EditDefaultsOnly, Category = \"Mass|LOD\", config)\n\tuint8 bAllowNonPlayerViwerActors : 1 = true;\n\n\t/** \n\t * If set to true will prefer to use Player-owned Pawn's location and rotation over Player's camera as the viewer's \n\t * location and rotation.\n\t * Note that this works best with distance-only LOD and can introduce subtle inaccuracies if Frustum-based LOD is being used. \n\t */\n\tUPROPERTY(EditDefaultsOnly, Category = \"Mass|LOD\", config)\n\tuint8 bUsePlayerPawnLocationInsteadOfCamera : 1 = false;\n\nprivate:\n\t/** Removes a viewer to the list and send notification about removal */\n\tvoid RemoveViewerInternal(const FMassViewerHandle& ViewerHandle);\n\n\t/** The actual array of viewer's information*/\n\tUPROPERTY(Transient)\n\tTArray<FViewerInfo> Viewers;\n\n\t/** The map that do reverse look up to get ViewerHandle */\n\tUPROPERTY(Transient)\n\tTMap<uint32, FMassViewerHandle> ViewerMap;\n\n\tUPROPERTY(Transient)\n\tTArray<TObjectPtr<AActor>> RegisteredActorViewers;\n\n\tuint64 LastSynchronizedFrame = 0;\n\n\t/** Viewer serial number counter */\n\tuint32 ViewerSerialNumberCounter = 0;\n\n#if WITH_EDITOR\n\tbool bUseEditorLevelViewports = false;\n\tbool bIgnorePlayerControllersDueToSimulation = false;\n#endif // WITH_EDITOR\n\n\t/** Free list of indices in the sparse viewer array */\n\tTArray<int32> ViewerFreeIndices;\n\n\t/** Delegates to notify anyone who needs to know about viewer changes */\n\tFOnViewerAdded OnViewerAddedDelegate;\n\tFOnViewerRemoved OnViewerRemovedDelegate;\n\npublic:\n\tUE_DEPRECATED(5.4, \"GetViewerHandleFromPlayerController is deprecated. Use more teneric GetViewerHandleFromActor\")\n\tFMassViewerHandle GetViewerHandleFromPlayerController(const APlayerController* PlayerController) const;\n};\n\ntemplate<>\nstruct TMassExternalSubsystemTraits<UMassLODSubsystem> final\n{\n\tenum\n\t{\n\t\tGameThreadOnly = true\n\t};\n};\n",
      "lines": 225
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Public\\MassLODTickRateController.h",
      "extension": ".h",
      "size_bytes": 7704,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassLODLogic.h\"\n#include \"MassLODUtils.h\"\n#include \"MassCommonUtils.h\"\n#include \"MassCommandBuffer.h\"\n\n/**\n * Helper struct to control LOD tick rate for each agent, \n * It will add a fragment tag to group the agent of the same LOD together, that way the user can do tick rate logic per chunk.\n */\ntemplate <typename TVariableTickChunkFragment, typename FLODLogic = FLODDefaultLogic >\nstruct TMassLODTickRateController : public FMassLODBaseLogic\n{\npublic:\n\tTMassLODTickRateController()\n\t\t: FMassLODBaseLogic(/*bShouldBuildFrustumData=*/false)\n\t{}\n\n\t/**\n\t * Initializes the LOD trick rate controller, needed to be called once at initialization time (Only when FLODLogic::bDoVariableTickRate is enabled)\n\t * @Param InTickRate the rate at which entities should be ticked per \n\t * @Param bInShouldSpreadFirstUpdate over the period specified in InTickRate parameter\n\t */\n\tvoid Initialize(const float InTickRate[EMassLOD::Max], const bool bInShouldSpreadFirstUpdate = false);\n\n\t/**\n\t * Retrieve if it is needed to calculate the LOD for this chunk\n\t *\n\t * @return if the LOD needs to be calculated\n\t */\n\tbool ShouldCalculateLODForChunk(const FMassExecutionContext& Context) const;\n\n\t/**\n\t * Retrieve if it is needed to adjust LOD from the newly calculated count for this chunk\n\t * \n\t * @return if the LOD needs to be adjusted\n\t */\n\tbool ShouldAdjustLODFromCountForChunk(const FMassExecutionContext& Context) const;\n\n\t/**\n\t * Updates tick rate for this chunk and its entities\n\t * @param Context of the chunk execution \n\t * @param LODList is the fragment where calculation are stored \n\t * @param Time of the simulation to use for this update\n\t * @return bool return if the chunk should be tick this frame\n\t */\n\ttemplate <typename TLODFragment, typename TVariableTickRateFragment>\n\tbool UpdateTickRateFromLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TArrayView<TVariableTickRateFragment> TickRateList, const double Time);\n\n\tfriend FORCEINLINE uint32 GetTypeHash(const TMassLODTickRateController<TVariableTickChunkFragment, FLODLogic>& SharedFragmentInstance)\n\t{\n\t\treturn HashCombineFast(GetTypeHash(SharedFragmentInstance.TickRates), uint32(SharedFragmentInstance.bShouldSpreadFirstUpdate));\n\t}\n\nprotected:\n\n\t/** Tick rate for each LOD */\n\tTStaticArray<float, EMassLOD::Max> TickRates;\n\n\t/* Whether or not to spread the first update over the period specified in tick rate member for its LOD */\n\tbool bShouldSpreadFirstUpdate = false;\n};\n\ntemplate <typename TVariableTickChunkFragment, typename FLODLogic>\nvoid TMassLODTickRateController<TVariableTickChunkFragment, FLODLogic>::Initialize(const float InTickRates[EMassLOD::Max], const bool bInShouldSpreadFirstUpdate/* = false*/)\n{\n\tcheckf(InTickRates, TEXT(\"You need to provide tick rate values to use this class.\"));\n\n\t// Make a copy of all the settings\n\tfor (int x = 0; x < EMassLOD::Max; x++)\n\t{\n\t\tTickRates[x] = InTickRates[x];\n\t}\n\n\tbShouldSpreadFirstUpdate = bInShouldSpreadFirstUpdate;\n}\n\ntemplate <typename TVariableTickChunkFragment, typename FLODLogic>\nbool TMassLODTickRateController<TVariableTickChunkFragment, FLODLogic>::ShouldCalculateLODForChunk(const FMassExecutionContext& Context) const\n{\n\t// EMassLOD::Off does not need to handle max count, so we can use ticking rate for them if available\n\tconst FMassVariableTickChunkFragment& ChunkData = Context.GetChunkFragment<TVariableTickChunkFragment>();\n\treturn ChunkData.GetLOD() != EMassLOD::Off || ChunkData.ShouldTickThisFrame();\n}\n\ntemplate <typename TVariableTickChunkFragment, typename FLODLogic>\nbool TMassLODTickRateController<TVariableTickChunkFragment, FLODLogic>::ShouldAdjustLODFromCountForChunk(const FMassExecutionContext& Context) const\n{\n\t// EMassLOD::Off does not need to handle max count, so we can skip it\n\tconst FMassVariableTickChunkFragment& ChunkData = Context.GetChunkFragment<TVariableTickChunkFragment>();\n\treturn ChunkData.GetLOD() != EMassLOD::Off;\n}\n\ntemplate <typename TVariableTickChunkFragment, typename FLODLogic>\ntemplate <typename TLODFragment, typename TVariableTickRateFragment>\nbool TMassLODTickRateController<TVariableTickChunkFragment, FLODLogic>::UpdateTickRateFromLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TArrayView<TVariableTickRateFragment> TickRateList, const double Time)\n{\n\tbool bShouldTickThisFrame = true;\n\tbool bWasChunkTicked = true;\n\tconst float DeltaTime = Context.GetDeltaTimeSeconds();\n\tbool bFirstUpdate = false;\n\n\tFMassVariableTickChunkFragment& ChunkData = Context.GetMutableChunkFragment<TVariableTickChunkFragment>();\n\tEMassLOD::Type ChunkLOD = ChunkData.GetLOD();\n\tif (ChunkLOD == EMassLOD::Max)\n\t{\n\t\t// The LOD on the chunk fragment data isn't set yet, let see if the Archetype has an LOD tag and set it on the ChunkData\n\t\tChunkLOD = UE::MassLOD::GetLODFromArchetype(Context);\n\t\tChunkData.SetLOD(ChunkLOD);\n\t\tbFirstUpdate = bShouldSpreadFirstUpdate;\n\t}\n\telse\n\t{\n\t\tcheckfSlow(UE::MassLOD::IsLODTagSet(Context, ChunkLOD), TEXT(\"Expecting the same LOD as what we saved in the chunk data, maybe external code is modifying the tags\"))\n\t}\n\n\tif (ChunkLOD != EMassLOD::Max)\n\t{\n\t\tfloat TimeUntilNextTick = ChunkData.GetTimeUntilNextTick();\n\t\tbWasChunkTicked = ChunkData.ShouldTickThisFrame();\n\n\t\tconst int32 LastChunkSerialModificationNumber = ChunkData.GetLastChunkSerialModificationNumber();\n\t\tconst int32 ChunkSerialModificationNumber = Context.GetChunkSerialModificationNumber();\n\n\t\t// Prevent the chunk modification tracking logic to trigger a tick until we actually tick from the first update tick calculation\n\t\tint32 NewChunkSerialModificationNumber = (LastChunkSerialModificationNumber == INDEX_NONE) ? INDEX_NONE : ChunkSerialModificationNumber;\n\n\t\tconst float TickRate = TickRates[ChunkLOD];\n\t\tif (bFirstUpdate)\n\t\t{\n\t\t\t// @todo: Add some randomization for deterministic runs too. The randomization is used to distribute the infrequent ticks evenly on different frames.\n\t\t\tTimeUntilNextTick = UE::Mass::Utils::IsDeterministic() ? TickRate * 0.5f : FMath::RandRange(0.0f, TickRate);\n\t\t}\n\t\telse if(bWasChunkTicked)\n\t\t{\n\t\t\t// Reset DeltaTime if we ticked last frame and start tracking chunk modifications\n\t\t\t// @todo: Add some randomization for deterministic runs too. The randomization is used to distribute the infrequent ticks evenly on different frames.\n\t\t\tTimeUntilNextTick = UE::Mass::Utils::IsDeterministic() ? TickRate : (TickRate * (1.0f + FMath::RandRange(-0.1f, 0.1f)));\n\t\t\tNewChunkSerialModificationNumber = ChunkSerialModificationNumber;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Decrement delta time\n\t\t\tTimeUntilNextTick -= DeltaTime;\n\t\t}\n\n\t\t// Should we tick this frame?\n\t\tbShouldTickThisFrame = TimeUntilNextTick <= 0.0f || LastChunkSerialModificationNumber != NewChunkSerialModificationNumber;\n\t\tChunkData.Update(bShouldTickThisFrame, TimeUntilNextTick, NewChunkSerialModificationNumber);\n\t}\n\n\tif (bWasChunkTicked)\n\t{\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tfor (int32 Index = 0; Index < NumEntities; ++Index)\n\t\t{\n\t\t\tconst TLODFragment& EntityLOD = LODList[Index];\n\t\t\tTVariableTickRateFragment& TickRate = TickRateList[Index];\n\t\t\tTickRate.DeltaTime = TickRate.LastTickedTime != 0.0 ? static_cast<float>(Time - TickRate.LastTickedTime) : DeltaTime;\n\t\t\tTickRate.LastTickedTime = Time;\n\t\t\tif (EntityLOD.LOD != ChunkLOD)\n\t\t\t{\n\t\t\t\tconst FMassEntityHandle Entity = Context.GetEntity(Index);\n\t\t\t\tUE::MassLOD::PushSwapTagsCommand(Context.Defer(), Entity, ChunkLOD, EntityLOD.LOD);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn bShouldTickThisFrame;\n}\n",
      "lines": 173
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Public\\MassLODTrait.h",
      "extension": ".h",
      "size_bytes": 1480,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassEntityTraitBase.h\"\n#include \"MassSimulationLOD.h\"\n\n#include \"MassLODTrait.generated.h\"\n\nUCLASS(meta = (DisplayName = \"LODCollector\"))\nclass MASSLOD_API UMassLODCollectorTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n};\n\n// Simplest version of UMassLODCollectorTrait that will ensure collection strictly based on Distance from Viewer\nUCLASS(meta = (DisplayName = \"DistanceLODCollector\"))\nclass MASSLOD_API UMassDistanceLODCollectorTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n};\n\nUCLASS(meta = (DisplayName = \"SimulationLOD\"))\nclass MASSLOD_API UMassSimulationLODTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(Category = \"Config\", EditAnywhere)\n\tFMassSimulationLODParameters Params;\n\n\tUPROPERTY(Category = \"Config\", EditAnywhere)\n\tbool bEnableVariableTicking = false;\n\n\tUPROPERTY(Category = \"Config\", EditAnywhere, meta = (EditCondition = \"bEnableVariableTicking\", EditConditionHides))\n\tFMassSimulationVariableTickParameters VariableTickParams;\n\nprotected:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n};\n",
      "lines": 45
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Public\\MassLODTypes.h",
      "extension": ".h",
      "size_bytes": 1539,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"Containers/StaticArray.h\"\n#include \"MassEntityManager.h\"\n\n#include \"MassLODTypes.generated.h\"\n\n/** Debug option to allow multiple viewers per controller. Useful for testing and profiling purposes */\n#define UE_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER 0\n\n#define UE_ALLOW_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER (UE_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER && !UE_BUILD_SHIPPING)\n\nnamespace UE::MassLOD\n{\n#if UE_ALLOW_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER\n\tconstexpr int32 DebugNumberViewersPerController = 50;\n#endif // UE_ALLOW_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER\n\n\tconstexpr int32 MaxBucketsPerLOD = 250;\n\n\textern MASSLOD_API FColor LODColors[];\n} // UE::MassLOD\n\nnamespace UE::Mass::ProcessorGroupNames\n{\n\tconst FName LODCollector = FName(TEXT(\"LODCollector\"));\n\tconst FName LOD = FName(TEXT(\"LOD\"));\n}\n\n// We are not using enum class here because we are doing so many arithmetic operation and comparison on them \n// that it is not worth polluting int32 casts everywhere in the code.\nUENUM()\nnamespace EMassLOD\n{\n\tenum Type : int\n\t{\n\t\tHigh,\n\t\tMedium,\n\t\tLow,\n\t\tOff,\n\t\tMax\n\t};\n}\n\n\nUENUM()\nenum class EMassVisibility : uint8\n{\n\tCanBeSeen, // Not too far and within camera frustum\n\tCulledByFrustum, // Not in camera frustum but within visibility distance\n\tCulledByDistance, // Too far whether in or out of frustum\n\tMax\n};",
      "lines": 56
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Public\\MassLODUtils.h",
      "extension": ".h",
      "size_bytes": 2689,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassEntityManager.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassLODFragments.h\"\n#include \"Logging/LogMacros.h\"\n\nMASSLOD_API DECLARE_LOG_CATEGORY_EXTERN(LogMassLOD, Log, All);\n\nstruct FMassCommandBuffer;\n\nnamespace UE::MassLOD \n{\n\ninline EMassLOD::Type GetLODFromArchetype(const FMassExecutionContext& Context)\n{\n\tif (Context.DoesArchetypeHaveTag<FMassOffLODTag>())\n\t{\n\t\treturn EMassLOD::Off;\n\t}\n\tif (Context.DoesArchetypeHaveTag<FMassLowLODTag>())\n\t{\n\t\treturn EMassLOD::Low;\n\t}\n\tif (Context.DoesArchetypeHaveTag<FMassMediumLODTag>())\n\t{\n\t\treturn EMassLOD::Medium;\n\t}\n\tif (Context.DoesArchetypeHaveTag<FMassHighLODTag>())\n\t{\n\t\treturn EMassLOD::High;\n\t}\n\treturn EMassLOD::Max;\n}\n\ntemplate <EMassLOD::Type Level>\nstruct TMassLODTagForLevel\n{\n\ttypedef FMassOffLODTag FTag;\n};\n\ntemplate<>\nstruct TMassLODTagForLevel<EMassLOD::High>\n{\n\ttypedef FMassHighLODTag FTag;\n};\n\ntemplate<>\nstruct TMassLODTagForLevel<EMassLOD::Medium>\n{\n\ttypedef FMassMediumLODTag FTag;\n};\n\ntemplate<>\nstruct TMassLODTagForLevel<EMassLOD::Low>\n{\n\ttypedef FMassLowLODTag FTag;\n};\n\n\ninline const UScriptStruct* GetLODTagFromLOD(EMassLOD::Type LOD)\n{\n\tswitch (LOD)\n\t{\n\t\tcase EMassLOD::High:\n\t\t\treturn TMassLODTagForLevel<EMassLOD::High>::FTag::StaticStruct();\n\t\tcase EMassLOD::Medium:\n\t\t\treturn TMassLODTagForLevel<EMassLOD::Medium>::FTag::StaticStruct();\n\t\tcase EMassLOD::Low:\n\t\t\treturn TMassLODTagForLevel<EMassLOD::Low>::FTag::StaticStruct();\n\t\tcase EMassLOD::Off:\n\t\t\treturn TMassLODTagForLevel<EMassLOD::Off>::FTag::StaticStruct();\n\t\tdefault:\n\t\t\tcheckf(false, TEXT(\"Unsupported LOD Type\"));\n\t\tcase EMassLOD::Max:\n\t\t\treturn nullptr;\n\t}\n}\n\ninline bool IsLODTagSet(const FMassExecutionContext& Context, EMassLOD::Type LOD)\n{\n\tswitch (LOD)\n\t{\n\t\tcase EMassLOD::High:\n\t\t\treturn Context.DoesArchetypeHaveTag<FMassHighLODTag>();\n\t\tcase EMassLOD::Medium:\n\t\t\treturn Context.DoesArchetypeHaveTag<FMassMediumLODTag>();\n\t\tcase EMassLOD::Low:\n\t\t\treturn Context.DoesArchetypeHaveTag<FMassLowLODTag>();\n\t\tcase EMassLOD::Off:\n\t\t\treturn Context.DoesArchetypeHaveTag<FMassOffLODTag>();\n\t\tdefault:\n\t\t\tcheckf(false, TEXT(\"Unsupported LOD Type\"));\n\t\tcase EMassLOD::Max:\n\t\t\treturn false;\n\t}\n}\n\nvoid MASSLOD_API PushSwapTagsCommand(FMassCommandBuffer& CommandBuffer, const FMassEntityHandle Entity, const EMassLOD::Type PrevLOD, const EMassLOD::Type NewLOD);\n\n#if WITH_MASSGAMEPLAY_DEBUG\nnamespace Debug \n{\n\tMASSLOD_API extern bool bLODCalculationsPaused;\n} // UE::MassLOD::Debug\n#endif // WITH_MASSGAMEPLAY_DEBUG\n} // UE::MassLOD",
      "lines": 110
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Public\\MassSimulationLOD.h",
      "extension": ".h",
      "size_bytes": 6409,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessor.h\"\n#include \"MassLODCollector.h\"\n#include \"MassLODCalculator.h\"\n#include \"MassLODTickRateController.h\"\n#include \"MassLODLogic.h\"\n#include \"MassEntityTypes.h\"\n#include \"MassLODFragments.h\"\n\n#include \"MassSimulationLOD.generated.h\"\n\nUSTRUCT()\nstruct MASSLOD_API FMassSimulationLODFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\t/** Saved closest ViewerDistance */\n\tfloat ClosestViewerDistanceSq = FLT_MAX;\n\n\t/**LOD information */\n\tTEnumAsByte<EMassLOD::Type> LOD = EMassLOD::Max;\n\n\t/** Previous LOD information*/\n\tTEnumAsByte<EMassLOD::Type> PrevLOD = EMassLOD::Max;\n};\n\nUSTRUCT()\nstruct MASSLOD_API FMassSimulationVariableTickFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\t/** Accumulated delta time to use upon next tick */\n\tdouble LastTickedTime = 0.;\n\tfloat DeltaTime = 0.0f;\n};\n\nUSTRUCT()\nstruct MASSLOD_API FMassSimulationVariableTickChunkFragment : public FMassVariableTickChunkFragment\n{\n\tGENERATED_BODY();\n\n\t/**\n\t * IsChunkHandledThisFrame\n\t * \n\t * This function is used by LOD collector query chunk filters to check if the Simulation LOD will be updated this frame.\n\t * It defaults to false (no LOD update), if simulation variable tick chunk fragment is NOT present.\n\t * \n\t * @return true if the simulation LOD will be updated this frame\n\t */\n\tstatic bool IsChunkHandledThisFrame(const FMassExecutionContext& Context)\n\t{\n\t\tconst FMassSimulationVariableTickChunkFragment* ChunkFragment = Context.GetChunkFragmentPtr<FMassSimulationVariableTickChunkFragment>();\n\t\treturn ChunkFragment != nullptr && ChunkFragment->ShouldTickThisFrame();\n\t}\n\n\t/**\n\t * ShouldTickChunkThisFrame\n\t * \n\t * This function is used by query chunk filters in processors that require variable rate ticking based on LOD.\n\t * It defaults to true (always ticking) if simulation variable tick chunk fragment is NOT present.\n\t * \n\t * @return if the chunk should be ticked this frame\n\t */\n\tstatic bool ShouldTickChunkThisFrame(const FMassExecutionContext& Context)\n\t{\n\t\tconst FMassSimulationVariableTickChunkFragment* ChunkFragment = Context.GetChunkFragmentPtr<FMassSimulationVariableTickChunkFragment>();\n\t\treturn ChunkFragment == nullptr || ChunkFragment->ShouldTickThisFrame();\n\t}\n\n\tstatic EMassLOD::Type GetChunkLOD(const FMassExecutionContext& Context)\n\t{\n\t\tconst FMassSimulationVariableTickChunkFragment* ChunkFragment = Context.GetChunkFragmentPtr<FMassSimulationVariableTickChunkFragment>();\n\t\treturn ChunkFragment ? ChunkFragment->GetLOD() : EMassLOD::High;\n\t}\n\n};\n\nUSTRUCT()\nstruct MASSLOD_API FMassSimulationLODParameters : public FMassConstSharedFragment\n{\n\tGENERATED_BODY()\n\n\tFMassSimulationLODParameters();\n\n\t/** Distance where each LOD becomes relevant */\n\tUPROPERTY(EditAnywhere, Category = \"LOD\", config)\n\tfloat LODDistance[EMassLOD::Max];\n\n\t/** Hysteresis percentage on delta between the LOD distances */\n\tUPROPERTY(EditAnywhere, Category = \"LOD\", meta = (ClampMin = \"0.0\", UIMin = \"0.0\"), config)\n\tfloat BufferHysteresisOnDistancePercentage = 10.0f;\n\n\t/** Maximum limit of entity per LOD */\n\tUPROPERTY(EditAnywhere, Category = \"LOD\", config)\n\tint32 LODMaxCount[EMassLOD::Max];\n\n\t/** If true, will set the associated LOD tag on the entity */\n\tUPROPERTY(EditAnywhere, Category = \"LOD\", config)\n\tbool bSetLODTags = false;\n};\n\nUSTRUCT()\nstruct MASSLOD_API FMassSimulationVariableTickParameters : public FMassConstSharedFragment\n{\n\tGENERATED_BODY()\n\n\tFMassSimulationVariableTickParameters();\n\n\t/** Rate in seconds at which entities should update when in this LOD */\n\tUPROPERTY(EditAnywhere, Category = \"VariableTick\", config)\n\tfloat TickRates[EMassLOD::Max];\n\n\t/** If true, will spread the first simulation update over TickRate period */\n\tUPROPERTY(EditAnywhere, Category = \"VariableTick\", config)\n\tbool bSpreadFirstSimulationUpdate = false;\n};\n\nUSTRUCT()\nstruct MASSLOD_API FMassSimulationLODSharedFragment : public FMassSharedFragment\n{\n\tGENERATED_BODY()\n\n\tFMassSimulationLODSharedFragment() = default;\n\tFMassSimulationLODSharedFragment(const FMassSimulationLODParameters& LODParams);\n\n\t/** Runtime data for matching the simulation LOD parameters */\n\tTMassLODCalculator<FMassSimulationLODLogic> LODCalculator;\n\tbool bHasAdjustedDistancesFromCount = false;\n};\n\nUSTRUCT()\nstruct MASSLOD_API FMassSimulationVariableTickSharedFragment : public FMassSharedFragment\n{\n\tGENERATED_BODY()\n\n\tFMassSimulationVariableTickSharedFragment() = default;\n\tFMassSimulationVariableTickSharedFragment(const FMassSimulationVariableTickParameters& TickRateParams);\n\n\t/** Runtime data for matching the simulation tick rate parameters */\n\tTMassLODTickRateController<FMassSimulationVariableTickChunkFragment, FMassSimulationLODLogic> LODTickRateController;\n\n\tstatic bool ShouldCalculateLODForChunk(const FMassExecutionContext& Context)\n\t{\n\t\tif (const FMassSimulationVariableTickSharedFragment* TickRateSharedFragment = Context.GetSharedFragmentPtr<FMassSimulationVariableTickSharedFragment>())\n\t\t{\n\t\t\treturn TickRateSharedFragment->LODTickRateController.ShouldCalculateLODForChunk(Context);\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic bool ShouldAdjustLODFromCountForChunk(const FMassExecutionContext& Context)\n\t{\n\t\tif (const FMassSimulationVariableTickSharedFragment* TickRateSharedFragment = Context.GetSharedFragmentPtr<FMassSimulationVariableTickSharedFragment>())\n\t\t{\n\t\t\treturn TickRateSharedFragment->LODTickRateController.ShouldAdjustLODFromCountForChunk(Context);\n\t\t}\n\t\treturn true;\n\t}\n};\n\nUCLASS(meta = (DisplayName = \"Simulation LOD\"))\nclass MASSLOD_API UMassSimulationLODProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassSimulationLODProcessor();\n\nprotected:\n\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tvoid CalculateLODForConfig(FMassEntityManager& EntityManager, FMassExecutionContext& Context, FMassSimulationLODParameters& LODParams);\n\n\tFMassEntityQuery EntityQuery;\n\tFMassEntityQuery EntityQueryCalculateLOD;\n\tFMassEntityQuery EntityQueryAdjustDistances;\n\tFMassEntityQuery EntityQueryVariableTick;\n\tFMassEntityQuery EntityQuerySetLODTag;\n\n\tUPROPERTY(config, EditDefaultsOnly, Category=\"Mass\")\n\tbool bDoAdjustmentFromCount = true;\n};\n",
      "lines": 187
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Public\\IMassMovementModule.h",
      "extension": ".h",
      "size_bytes": 1123,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n * The public interface to this module.  In most cases, this interface is only public to sibling modules \n * within this plugin.\n */\nclass IMassMovementModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t * Singleton-like access to this module's interface.  This is just for convenience!\n\t * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t *\n\t * @return Returns singleton instance, loading the module on demand if needed\n\t */\n\tstatic inline IMassMovementModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassMovementModule>( \"MassMovement\" );\n\t}\n\n\t/**\n\t * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t *\n\t * @return True if the module is loaded and ready to use\n\t */\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassMovement\" );\n\t}\n};\n\n",
      "lines": 40
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Public\\MassMovementDelegates.h",
      "extension": ".h",
      "size_bytes": 420,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n\nnamespace UE::MassMovement::Delegates\n{\n#if WITH_EDITOR\n\t/** Called when movement names have changed (UI update). */\n\tDECLARE_MULTICAST_DELEGATE(FOnMassMovementNamesChanged);\n\textern MASSMOVEMENT_API FOnMassMovementNamesChanged OnMassMovementNamesChanged;\n#endif // WITH_EDITOR\n} // UE::MassMovement::Delegates\n",
      "lines": 14
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Public\\MassMovementFragments.h",
      "extension": ".h",
      "size_bytes": 3095,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassMovementTypes.h\"\n#include \"RandomSequence.h\"\n#include \"MassMovementFragments.generated.h\"\n\nUSTRUCT()\nstruct MASSMOVEMENT_API FMassVelocityFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tFVector Value = FVector::ZeroVector;\n};\n\nUSTRUCT()\nstruct MASSMOVEMENT_API FMassForceFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tFVector Value = FVector::ZeroVector;\n};\n\nUSTRUCT()\nstruct MASSMOVEMENT_API FMassMovementParameters : public FMassConstSharedFragment\n{\n\tGENERATED_BODY()\n\n\tFMassMovementParameters GetValidated() const\n\t{\n\t\tFMassMovementParameters Copy = *this;\n\t\tCopy.Update();\n\t\treturn Copy;\n\t}\n\n\t/** Updates internal values for faster desired speed generation. */\n\tvoid Update();\n\n\t/** Generates desired speed based on style and unique id. The id is used deterministically assign a specific speed range. */\n\tfloat GenerateDesiredSpeed(const FMassMovementStyleRef& Style, const int32 UniqueId) const\n\t{\n\t\tfloat DesiredSpeed = DefaultDesiredSpeed;\n\t\tfloat DesiredSpeedVariance = DefaultDesiredSpeedVariance;\n\t\t\n\t\tconst FMassMovementStyleParameters* StyleParams = MovementStyles.FindByPredicate([&Style](const FMassMovementStyleParameters& Config)\n\t\t\t{\n\t\t\t\treturn Config.Style.ID == Style.ID;\n\t\t\t});\n\t\t\n\t\tif (StyleParams != nullptr)\n\t\t{\n\t\t\tconst float Prob = UE::RandomSequence::FRand(UniqueId);\n\t\t\tfor (const FMassMovementStyleSpeedParameters& Speed : StyleParams->DesiredSpeeds)\n\t\t\t{\n\t\t\t\tif (Prob < Speed.ProbabilityThreshold)\n\t\t\t\t{\n\t\t\t\t\tDesiredSpeed = Speed.Speed;\n\t\t\t\t\tDesiredSpeedVariance = Speed.Variance;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn DesiredSpeed * UE::RandomSequence::RandRange(UniqueId, 1.0f - DesiredSpeedVariance, 1.0f + DesiredSpeedVariance);;\n\t}\n\t\n\t/** Maximum speed (cm/s). */\n\tUPROPERTY(EditAnywhere, Category = \"Movement\", meta = (ClampMin = \"0\", ForceUnits=\"cm/s\"))\n\tfloat MaxSpeed = 200.f;\n\n\t/** 200..600 Smaller steering maximum acceleration makes the steering more \\\"calm\\\" but less opportunistic, may not find solution, or gets stuck. */\n\tUPROPERTY(config, EditAnywhere, Category = \"Movement\", meta = (UIMin = 0.0, ClampMin = 0.0, ForceUnits=\"cm/s^2\"))\n\tfloat MaxAcceleration = 250.f;\n\n\t/** Default desired speed (cm/s). */\n\tUPROPERTY(EditAnywhere, Category = \"Movement\", meta = (ClampMin = \"0\", ForceUnits=\"cm/s\"))\n\tfloat DefaultDesiredSpeed = 140.f;\n\n\t/** How much default desired speed is varied randomly. */\n\tUPROPERTY(EditAnywhere, Category = \"Movement\", meta = (ClampMin = \"0\", ClampMax = \"1\"))\n\tfloat DefaultDesiredSpeedVariance = 0.1f;\n\n\t/** The time it takes the entity position to catchup to the requested height. */\n\tUPROPERTY(EditAnywhere, Category = \"Movement\", meta = (ClampMin = \"0.0\", ForceUnits=\"s\"))\n\tfloat HeightSmoothingTime = 0.2f;\n\n\t/** List of supported movement styles for this configuration. */\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tTArray<FMassMovementStyleParameters> MovementStyles;\n};\n",
      "lines": 93
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Public\\MassMovementSettings.h",
      "extension": ".h",
      "size_bytes": 1007,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"MassSettings.h\"\n#include \"MassMovementTypes.h\"\n#include \"MassMovementSettings.generated.h\"\n\nUCLASS(config = Mass, defaultconfig, meta = (DisplayName = \"Mass Movement\"))\nclass MASSMOVEMENT_API UMassMovementSettings : public UMassModuleSettings\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassMovementSettings(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());\n\t\n\tstatic const UMassMovementSettings* Get()\n\t{\n\t\treturn GetDefault<UMassMovementSettings>();\n\t}\n\n\tTConstArrayView<FMassMovementStyle> GetMovementStyles() const { return MovementStyles; }\n\tconst FMassMovementStyle* GetMovementStyleByID(const FGuid ID) const; \n\t\nprivate:\n\n#if WITH_EDITOR\n\tvirtual void PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent) override;\n#endif\n\n\tUPROPERTY(EditAnywhere, config, Category = Movement);\n    TArray<FMassMovementStyle> MovementStyles;\n};\n",
      "lines": 34
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Public\\MassMovementTypes.h",
      "extension": ".h",
      "size_bytes": 2458,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreTypes.h\"\n#include \"MassMovementTypes.generated.h\"\n\nnamespace UE::MassMovement\n{\n\textern MASSMOVEMENT_API int32 bFreezeMovement;\n};\n\n/** Reference to movement style in MassMovementSettings. */\nUSTRUCT()\nstruct MASSMOVEMENT_API FMassMovementStyleRef\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tFName Name;\n\n\tUPROPERTY(EditAnywhere, Category = \"Movement\", meta = (IgnoreForMemberInitializationTest, EditCondition = \"false\", EditConditionHides))\n\tFGuid ID;\n};\n\n/** Describes movement style name. */\nUSTRUCT()\nstruct MASSMOVEMENT_API FMassMovementStyle\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tFName Name;\n\n\tUPROPERTY(EditAnywhere, Category = \"Movement\", meta = (IgnoreForMemberInitializationTest, EditCondition = \"false\", EditConditionHides))\n\tFGuid ID;\n};\n\n/**\n * Movement style consists of multiple speeds which are assigned to agents based on agents unique ID.\n * Same speed is assigned consistently for the same ID.\n */\nUSTRUCT()\nstruct MASSMOVEMENT_API FMassMovementStyleSpeedParameters\n{\n\tGENERATED_BODY()\n\n\t/** Desired speed */\n\tUPROPERTY(EditAnywhere, Category = \"Movement Style\", meta = (UIMin = 0.0, ClampMin = 0.0, ForceUnits=\"cm/s\"))\n\tfloat Speed = 140.0f;\n\n\t/** How much default desired speed is varied randomly. */\n\tUPROPERTY(EditAnywhere, Category = \"Movement Style\", meta = (ClampMin = 0.0, ClampMax = 1.0))\n\tfloat Variance = 0.1f;\n\n\t/** Probability to assign this speed. */\n\tUPROPERTY(EditAnywhere, Category = \"Movement Style\", meta = (UIMin = 1, ClampMin = 1, UIMax = 100, ClampMax = 100))\n\tfloat Probability = 1.0f;\n\n\t/** Probability threshold for this style, used to faster lookup. Update via FMassMovementConfig::Update(). */\n\tfloat ProbabilityThreshold = 0.0f;\n};\n\n/** Movement style parameters. A movement style abstracts movement properties for specific style. Behaviors can refer to specific styles when handling speeds. */\nUSTRUCT()\nstruct MASSMOVEMENT_API FMassMovementStyleParameters\n{\n\tGENERATED_BODY()\n\n\t/** Style of the movement */\n\tUPROPERTY(EditAnywhere, Category = \"Movement Style\")\n\tFMassMovementStyleRef Style;\n\n\t/** Array of desired speeds (cm/s) assigned to agents based on probability. */\n\tUPROPERTY(EditAnywhere, Category = \"Movement Style\")\n\tTArray<FMassMovementStyleSpeedParameters> DesiredSpeeds;\n};\n\n\n",
      "lines": 79
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Public\\Example\\MassSimpleMovementTrait.h",
      "extension": ".h",
      "size_bytes": 941,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassEntityTraitBase.h\"\n#include \"MassProcessor.h\"\n#include \"MassSimpleMovementTrait.generated.h\"\n\n\nUSTRUCT()\nstruct FMassSimpleMovementTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\n\nUCLASS(meta = (DisplayName = \"Simple Movement\"))\nclass MASSMOVEMENT_API UMassSimpleMovementTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n};\n\n\nUCLASS()\nclass MASSMOVEMENT_API UMassSimpleMovementProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\npublic:\n\tUMassSimpleMovementProcessor();\n\t\t\nprotected:\t\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};\n",
      "lines": 40
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Public\\Example\\MassVelocityRandomizerTrait.h",
      "extension": ".h",
      "size_bytes": 1744,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTraitBase.h\"\n#include \"MassObserverProcessor.h\"\n#include \"MassVelocityRandomizerTrait.generated.h\"\n\n\nclass UMassRandomVelocityInitializer;\n\nUCLASS(meta = (DisplayName = \"Velocity Randomizer\"))\nclass MASSMOVEMENT_API UMassVelocityRandomizerTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\n\t/** The speed is expressed in UnrealUnits per second, which usually translates to 0.01m/s */\n\tUPROPERTY(Category = \"Velocity\", EditAnywhere, meta = (UIMin = 0.0, ClampMin = 0.0))\n\tfloat MinSpeed = 0.f;\n\n\t/** The speed is expressed in UnrealUnits per second, which usually translates to 0.01m/s */\n\tUPROPERTY(Category = \"Velocity\", EditAnywhere, meta = (UIMin = 1.0, ClampMin = 1.0))\n\tfloat MaxSpeed = 200.f;\n\n\tUPROPERTY(Category = \"Velocity\", EditAnywhere)\n\tbool bSetZComponent = false;\n};\n\n\nUCLASS()\nclass MASSMOVEMENT_API UMassRandomVelocityInitializer : public UMassObserverProcessor\n{\n\tGENERATED_BODY()\npublic:\n\tUMassRandomVelocityInitializer();\n\n\tvoid SetParameters(const float InMinSpeed, const float InMaxSpeed, const bool bInSetZComponent);\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n\n\tUPROPERTY()\n\tfloat MinSpeed = 0.f;\n\n\t/** The default max is set to 0 to enforce explicit configuration via SetParameters call. */\n\tUPROPERTY()\n\tfloat MaxSpeed = 0.f;\n\n\tUPROPERTY()\n\tbool bSetZComponent = false;\n\tFRandomStream RandomStream;\n};\n",
      "lines": 58
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Public\\Movement\\MassMovementProcessors.h",
      "extension": ".h",
      "size_bytes": 614,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessor.h\"\n#include \"MassMovementProcessors.generated.h\"\n\n/**\n * Updates entities position based on force and velocity.\n * Not applied on Off-LOD entities.\n */\nUCLASS()\nclass MASSMOVEMENT_API UMassApplyMovementProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassApplyMovementProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\nprivate:\n\tFMassEntityQuery EntityQuery;\n};\n",
      "lines": 26
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Public\\Movement\\MassMovementTrait.h",
      "extension": ".h",
      "size_bytes": 542,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassEntityTraitBase.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassMovementTrait.generated.h\"\n\nUCLASS(meta = (DisplayName = \"Movement\"))\nclass MASSMOVEMENT_API UMassMovementTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\n\tUPROPERTY(Category=\"Movement\", EditAnywhere)\n\tFMassMovementParameters Movement;\n};\n",
      "lines": 19
    },
    {
      "file_path": "MassGameplay\\MassMovementEditor\\Public\\IMassMovementEditor.h",
      "extension": ".h",
      "size_bytes": 286,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Toolkits/AssetEditorToolkit.h\"\n\n/** MassMovement Editor public interface */\nclass MASSMOVEMENTEDITOR_API IMassMovementEditor : public FAssetEditorToolkit\n{\npublic:\n\n};\n\n\n",
      "lines": 15
    },
    {
      "file_path": "MassGameplay\\MassMovementEditor\\Public\\MassMovementEditorModule.h",
      "extension": ".h",
      "size_bytes": 613,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma  once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleManager.h\"\n#include \"AssetTypeCategories.h\"\n#include \"Toolkits/IToolkitHost.h\"\n#include \"Toolkits/AssetEditorToolkit.h\"\n\n\nclass IMassMovementEditor;\n\n/**\n* The public interface to this module\n*/\nclass MASSMOVEMENTEDITOR_API FMassMovementEditorModule : public IModuleInterface//, public IHasMenuExtensibility, public IHasToolBarExtensibility\n{\npublic:\n\t// Begin IModuleInterface\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n\nprivate:\n};\n",
      "lines": 25
    },
    {
      "file_path": "MassGameplay\\MassMovementEditor\\Public\\MassMovementPropertyUtils.h",
      "extension": ".h",
      "size_bytes": 2437,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"Editor.h\"\n#include \"PropertyHandle.h\"\n\n#define LOCTEXT_NAMESPACE \"MassMovementEditor\"\n\nnamespace UE::MassMovement::PropertyUtils\n{\n\n// Expects T is struct.\ntemplate<typename T>\nTOptional<T> GetValue(const TSharedPtr<IPropertyHandle>& ValueProperty)\n{\n\tif (!ValueProperty)\n\t{\n\t\treturn TOptional<T>();\n\t}\n\n\tFStructProperty* StructProperty = CastFieldChecked<FStructProperty>(ValueProperty->GetProperty());\n\tif (!StructProperty)\n\t{\n\t\treturn TOptional<T>();\n\t}\n\tif (StructProperty->Struct != TBaseStructure<T>::Get())\n\t{\n\t\treturn TOptional<T>();\n\t}\n\n\tT Value = T();\n\tbool bValueSet = false;\n\n\tTArray<void*> RawData;\n\tValueProperty->AccessRawData(RawData);\n\tfor (void* Data : RawData)\n\t{\n\t\tif (Data)\n\t\t{\n\t\t\tT CurValue = *reinterpret_cast<T*>(Data);\n\t\t\tif (!bValueSet)\n\t\t\t{\n\t\t\t\tbValueSet = true;\n\t\t\t\tValue = CurValue;\n\t\t\t}\n\t\t\telse if (CurValue != Value)\n\t\t\t{\n\t\t\t\t// Multiple values\n\t\t\t\treturn TOptional<T>();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TOptional<T>(Value);\n}\n\n// Expects T is struct.\ntemplate<typename T>\nvoid SetValue(TSharedPtr<IPropertyHandle>& ValueProperty, T NewValue, EPropertyValueSetFlags::Type Flags = 0)\n{\n\tif (!ValueProperty)\n\t{\n\t\treturn;\n\t}\n\n\tFStructProperty* StructProperty = CastFieldChecked<FStructProperty>(ValueProperty->GetProperty());\n\tif (!StructProperty)\n\t{\n\t\treturn;\n\t}\n\tif (StructProperty->Struct != TBaseStructure<T>::Get())\n\t{\n\t\treturn;\n\t}\n\n\tconst bool bTransactable = (Flags & EPropertyValueSetFlags::NotTransactable) == 0;\n\tbool bNotifiedPreChange = false;\n\tTArray<void*> RawData;\n\tValueProperty->AccessRawData(RawData);\n\tfor (void* Data : RawData)\n\t{\n\t\tif (Data)\n\t\t{\n\t\t\tif (!bNotifiedPreChange)\n\t\t\t{\n\t\t\t\tif (bTransactable && GEditor)\n\t\t\t\t{\n\t\t\t\t\tGEditor->BeginTransaction(FText::Format(LOCTEXT(\"SetPropertyValue\", \"Set {0}\"), ValueProperty->GetPropertyDisplayName()));\n\t\t\t\t}\n\t\t\t\tValueProperty->NotifyPreChange();\n\t\t\t\tbNotifiedPreChange = true;\n\t\t\t}\n\n\t\t\tT* Value = reinterpret_cast<T*>(Data);\n\t\t\t*Value = NewValue;\n\t\t}\n\t}\n\n\tif (bNotifiedPreChange)\n\t{\n\t\tValueProperty->NotifyPostChange(EPropertyChangeType::ValueSet);\n\t\tif (bTransactable && GEditor)\n\t\t{\n\t\t\tGEditor->EndTransaction();\n\t\t}\n\t}\n\n\tValueProperty->NotifyFinishedChangingProperties();\n}\n\n} // UE::MassMovement::PropertyUtils\n\n#undef LOCTEXT_NAMESPACE",
      "lines": 113
    },
    {
      "file_path": "MassGameplay\\MassMovementEditor\\Public\\MassMovementStyleRefDetails.h",
      "extension": ".h",
      "size_bytes": 1317,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"UnrealClient.h\"\n#include \"IPropertyTypeCustomization.h\"\n\nclass IPropertyHandle;\nclass SWidget;\n\n/**\n * Type customization for FMassMovementStyleRef.\n */\nclass FMassMovementStyleRefDetails : public IPropertyTypeCustomization\n{\npublic:\n\t/** Makes a new instance of this detail layout class for a specific detail view requesting it */\n\tstatic TSharedRef<IPropertyTypeCustomization> MakeInstance();\n\n\t/** IPropertyTypeCustomization interface */\n\tvirtual void CustomizeHeader(TSharedRef<IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils) override;\n\tvirtual void CustomizeChildren(TSharedRef<IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder& StructBuilder, IPropertyTypeCustomizationUtils& StructCustomizationUtils) override;\n\nprivate:\n\n\tvoid OnProfileComboChange(int32 Idx);\n\tTSharedRef<SWidget> OnGetProfileContent() const;\n\tFText GetCurrentProfileDesc() const;\n\n\tTSharedPtr<IPropertyHandle> NameProperty;\n\tTSharedPtr<IPropertyHandle> IDProperty;\n\tTSharedPtr<IPropertyHandle> LanesProperty;\n\n\tclass IPropertyUtilities* PropUtils = nullptr;\n\tTSharedPtr<IPropertyHandle> StructProperty;\n};",
      "lines": 35
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Public\\IMassReplicationModule.h",
      "extension": ".h",
      "size_bytes": 1138,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n * The public interface to this module.  In most cases, this interface is only public to sibling modules \n * within this plugin.\n */\nclass IMassReplicationModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t * Singleton-like access to this module's interface.  This is just for convenience!\n\t * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t *\n\t * @return Returns singleton instance, loading the module on demand if needed\n\t */\n\tstatic inline IMassReplicationModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassReplicationModule>( \"MassReplication\" );\n\t}\n\n\t/**\n\t * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t *\n\t * @return True if the module is loaded and ready to use\n\t */\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassReplication\" );\n\t}\n};\n\n",
      "lines": 40
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Public\\MassClientBubbleHandler.h",
      "extension": ".h",
      "size_bytes": 29115,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassCommonTypes.h\"\n#include \"MassReplicationTypes.h\"\n#include \"MassEntityManager.h\"\n#include \"Containers/ArrayView.h\"\n#include \"MassClientBubbleSerializerBase.h\"\n#include \"MassSpawnerSubsystem.h\"\n#include \"MassSpawnerTypes.h\"\n#include \"MassReplicationFragments.h\"\n#include \"MassReplicationSubsystem.h\"\n#include \"Engine/World.h\"\n#include \"MassEntityTemplate.h\"\n#include \"MassEntityView.h\"\n\n#include \"MassClientBubbleHandler.generated.h\"\n\nclass UWorld;\nstruct FMassEntityManager;\n\nnamespace UE::Mass::Replication\n{\n\tconstexpr float AgentRemoveInterval = 5.f;\n}; //namespace UE::Mass::Replication\n\n/**\n *  Base for fast array items. For replication of new entity types this type should be inherited from. FReplicatedAgentBase should also be inherited from\n *  and made a member variable of the FMassFastArrayItemBase derived struct, with the member variable called Agent.\n */\nUSTRUCT()\nstruct FMassFastArrayItemBase : public FFastArraySerializerItem\n{\n\tGENERATED_BODY()\n\n\tFMassFastArrayItemBase() = default;\n\tFMassFastArrayItemBase(FMassReplicatedAgentHandle InHandle)\n\t\t: Handle(InHandle)\n\t{};\n\n\tFMassReplicatedAgentHandle GetHandle() const { return Handle; }\n\nprotected:\n\t/** Only to be used on a server */\n\tUPROPERTY(NotReplicated)\n\tFMassReplicatedAgentHandle Handle;\n};\n\n/** Data that can be accessed from a FMassReplicatedAgentHandle on a server */\nstruct FMassAgentLookupData\n{\n\tFMassAgentLookupData(FMassEntityHandle InEntity, FMassNetworkID InNetID, int32 InAgentsIdx)\n\t\t: Entity(InEntity)\n\t\t, NetID(InNetID)\n\t\t, AgentsIdx(InAgentsIdx)\n\t{}\n\n\tvoid Invalidate()\n\t{\n\t\tEntity = FMassEntityHandle();\n\t\tNetID.Invalidate();\n\t\tAgentsIdx = INDEX_NONE;\n\t}\n\n\tbool IsValid() const\n\t{\n\t\treturn Entity.IsSet() && NetID.IsValid() && (AgentsIdx >= 0);\n\t}\n\n\tFMassEntityHandle Entity;\n\tFMassNetworkID NetID;\n\tint32 AgentsIdx  = INDEX_NONE;\n};\n\n/**\n *  Data that is stored when an agent is removed from the bubble, when it times out its safe enough to remove entries in EntityInfoMap.\n *  The idea is that any out of order adds and removes will happen after this time.\n */\nstruct FMassAgentRemoveData\n{\n\tFMassAgentRemoveData() = default;\n\tFMassAgentRemoveData(double InTimeLastRemoved)\n\t\t: TimeLastRemoved(InTimeLastRemoved)\n\t{}\n\n\tdouble TimeLastRemoved = 0.;\n};\n\n/**\n * Interface for the bubble handler classes. All the outside interaction with the FastArray logic should be done via the Handler interface\n * or derived classes where possible.\n * These virtual functions are either only called once each per frame on the client for a few struct instances\n * or called at startup / shutdown.\n */\nclass IClientBubbleHandlerInterface\n{\npublic:\n\tvirtual ~IClientBubbleHandlerInterface() {}\n\n\tvirtual void InitializeForWorld(UWorld& InWorld) = 0;\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\t/** These functions are processed internally by TClientBubbleHandlerBase */\n\tvirtual void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize) = 0;\n\tvirtual void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize) = 0;\n\tvirtual void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize) = 0;\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n\tvirtual void Reset() = 0;\n\tvirtual void UpdateAgentsToRemove() = 0;\n\n\tvirtual void Tick(float DeltaTime) = 0;\n\tvirtual void SetClientHandle(FMassClientHandle InClientHandle) = 0;\n\n\tvirtual void DebugValidateBubbleOnServer() = 0;\n\tvirtual void DebugValidateBubbleOnClient() = 0;\n};\n\n\n/** \n * Template client bubble functionality. Replication logic for specific agent types is provided by deriving from this class.\n * Interaction with the FMassClientBubbleSerializerBase and derived classes should be done from this class \n */\ntemplate<typename AgentArrayItem>\nclass TClientBubbleHandlerBase : public IClientBubbleHandlerInterface\n{\npublic:\n\ttemplate<typename T>\n\tfriend class TMassClientBubblePathHandler;\n\n\ttemplate<typename T>\n\tfriend class TMassClientBubbleTransformHandler;\n\n\ttypedef TFunctionRef<void(FMassEntityQuery&)> FAddRequirementsForSpawnQueryFunction;\n\ttypedef TFunctionRef<void(FMassExecutionContext&)> FCacheFragmentViewsForSpawnQueryFunction;\n\ttypedef TFunctionRef<void(const FMassEntityView&, const typename AgentArrayItem::FReplicatedAgentType&, const int32)> FSetSpawnedEntityDataFunction;\n\ttypedef TFunctionRef<void(const FMassEntityView&, const typename AgentArrayItem::FReplicatedAgentType&)> FSetModifiedEntityDataFunction;\n\n\t/** This must be called from outside before InitializeForWorld() is called. Its called from agent specific bubble implementations */\n\tvirtual void Initialize(TArray<AgentArrayItem>& InAgents, FMassClientBubbleSerializerBase& InSerializer);\n\n\tvirtual void InitializeForWorld(UWorld& InWorld) override;\n\n#if UE_REPLICATION_COMPILE_SERVER_CODE\n\tFMassReplicatedAgentHandle AddAgent(FMassEntityHandle Entity, typename AgentArrayItem::FReplicatedAgentType& Agent);\n\n\tbool RemoveAgent(FMassNetworkID NetID);\n\tbool RemoveAgent(FMassReplicatedAgentHandle AgentHandle);\n\tvoid RemoveAgentChecked(FMassReplicatedAgentHandle AgentHandle);\n\n\t/** Gets an agent safely */\n\tconst typename AgentArrayItem::FReplicatedAgentType* GetAgent(FMassReplicatedAgentHandle Handle) const;\n\n\t/** Faster version to get an agent that performs check()s for debugging */\n\tconst typename AgentArrayItem::FReplicatedAgentType& GetAgentChecked(FMassReplicatedAgentHandle Handle) const;\n\tconst TArray<AgentArrayItem>& GetAgents() const { return *Agents; }\n#endif //UE_REPLICATION_COMPILE_SERVER_CODE\n\nprotected:\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\n\tvirtual void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize) override;\n\n\t/** Called from TClientBubbleHandlerBase derived classes in PostReplicatedAd() */\n\tvoid PostReplicatedAddHelper(const TArrayView<int32> AddedIndices, FAddRequirementsForSpawnQueryFunction AddRequirementsForSpawnQuery\n\t\t, FCacheFragmentViewsForSpawnQueryFunction CacheFragmentViewsForSpawnQuery, FSetSpawnedEntityDataFunction SetSpawnedEntityData, FSetModifiedEntityDataFunction SetModifiedEntityData);\n\n\t/** used by PostReplicatedAddHelper */\n\tvoid PostReplicatedAddEntitiesHelper(const TArrayView<int32> AddedIndices, FAddRequirementsForSpawnQueryFunction AddRequirementsForSpawnQuery\n\t\t, FCacheFragmentViewsForSpawnQueryFunction CacheFragmentViewsForSpawnQuery, FSetSpawnedEntityDataFunction SetSpawnedEntityData);\n\n\n\t/** Called from TClientBubbleHandlerBase derived classes in PostReplicatedChange() */\n\tvoid PostReplicatedChangeHelper(const TArrayView<int32> ChangedIndices, FSetModifiedEntityDataFunction SetModifiedEntityData);\n#endif //UE_REPLICATION_COMPILE_SERVER_CODE\n\n#if UE_REPLICATION_COMPILE_SERVER_CODE\n\tvoid RemoveAgentImpl(FMassReplicatedAgentHandle Handle);\n#endif //UE_REPLICATION_COMPILE_SERVER_CODE\n\n\tvirtual void SetClientHandle(FMassClientHandle InClientHandle) override;\n\n\tvirtual void Reset() override;\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void UpdateAgentsToRemove() override;\n\n\tvirtual void DebugValidateBubbleOnClient() override;\n\tvirtual void DebugValidateBubbleOnServer() override;\n\nprotected:\n\t/** Pointer to the Agents array in the associated Serializer class */\n\tTArray<AgentArrayItem>* Agents = nullptr;\n\n\tFMassClientHandle ClientHandle;\n\n#if UE_REPLICATION_COMPILE_SERVER_CODE\n\tFMassReplicatedAgentHandleManager AgentHandleManager;\n\n\t/** Used to look up Agent data from a FMassReplicatedAgentHandle, the AgentsIdx member will be the Idx in to the Agents array */\n\tTArray<FMassAgentLookupData> AgentLookupArray;\n\n\tTMap<FMassNetworkID, FMassReplicatedAgentHandle> NetworkIDToAgentHandleMap;\n#endif //UE_REPLICATION_COMPILE_SERVER_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\t/**\n\t *  Data that is stored when an agent is removed from the bubble, when it times out its safe enough to remove entries in EntityInfoMap\n\t *  The idea is that any out of order adds and subsequent removes for this NetID will normally happen before FAgentRemoveData::TimeLastRemoved,\n\t *  Those that happen after will be on such a bad connection that it doest matter.\n\t */\n\tTMap<FMassNetworkID, FMassAgentRemoveData> AgentsRemoveDataMap;\n#endif //UE_REPLICATION_COMPILE_CLIENT_CODE\n\n\t/** Base class pointer to the associated Serializer class */\n\tFMassClientBubbleSerializerBase* Serializer = nullptr;\n};\n\ntemplate<typename AgentArrayItem>\nvoid TClientBubbleHandlerBase<AgentArrayItem>::Initialize(TArray<AgentArrayItem>& InAgents, FMassClientBubbleSerializerBase& InSerializer)\n{\n\tAgents = &InAgents;\n\tSerializer = &InSerializer;\n\tSerializer->SetClientHandler(*this);\n}\n\ntemplate<typename AgentArrayItem>\nvoid TClientBubbleHandlerBase<AgentArrayItem>::InitializeForWorld(UWorld& InWorld)\n{\n\tcheckf(Agents, TEXT(\"Agents not set up. Call Initialize() before InitializeForWorld() gets called\"));\n\tcheckf(Serializer, TEXT(\"Serializer not set up. Call Initialize() before InitializeForWorld() gets called\"));\n\n\tSerializer->InitializeForWorld(InWorld);\n}\n\n#if UE_REPLICATION_COMPILE_SERVER_CODE\ntemplate<typename AgentArrayItem>\nFMassReplicatedAgentHandle TClientBubbleHandlerBase<AgentArrayItem>::AddAgent(FMassEntityHandle Entity, typename AgentArrayItem::FReplicatedAgentType& Agent)\n{\n\tcheckf(Agent.GetNetID().IsValid(), TEXT(\"Agent.NetID must be valid!\"));\n\tcheckf(NetworkIDToAgentHandleMap.Find(Agent.GetNetID()) == nullptr, TEXT(\"Only add agents once\"));\n\n\tFMassReplicatedAgentHandle AgentHandle = AgentHandleManager.GetNextHandle();\n\n\tcheckf(AgentHandle.GetIndex() <= AgentLookupArray.Num(), TEXT(\"AgentHandle is out of sync with the AgentLookupArray Array!\"));\n\n\tconst int32 Idx = AgentHandle.GetIndex();\n\n\tif (Idx == AgentLookupArray.Num())\n\t{\n\t\tAgentLookupArray.Emplace(Entity, Agent.GetNetID(), (*Agents).Num());\n\t}\n\telse\n\t{\n\t\tcheckf(AgentLookupArray[Idx].IsValid() == false, TEXT(\"Agent being replaced must be Invalid (should have been removed first)!\"));\n\n\t\tAgentLookupArray[Idx] = FMassAgentLookupData(Entity, Agent.GetNetID(), (*Agents).Num());\n\t}\n\n\tAgentArrayItem& Item = (*Agents).Emplace_GetRef(Agent, AgentHandle);\n\tSerializer->MarkItemDirty(Item);\n\n\tNetworkIDToAgentHandleMap.Add(Agent.GetNetID(), AgentHandle);\n\n\treturn AgentHandle;\n}\n\ntemplate<typename AgentArrayItem>\nbool TClientBubbleHandlerBase<AgentArrayItem>::RemoveAgent(FMassNetworkID NetID)\n{\n\tconst FMassReplicatedAgentHandle* const AgentHandle = NetworkIDToAgentHandleMap.Find(NetID);\n\n\treturn (AgentHandle != nullptr) ? RemoveAgent(*AgentHandle) : false;\n}\n\ntemplate<typename AgentArrayItem>\nbool TClientBubbleHandlerBase<AgentArrayItem>::RemoveAgent(FMassReplicatedAgentHandle AgentHandle)\n{\n\tbool bRemoved = false;\n\n\tif (ensureMsgf(AgentHandleManager.IsValidHandle(AgentHandle), TEXT(\"FMassReplicatedAgentHandle should be Valid\")))\n\t{\n\t\tbRemoved = true;\n\t\tRemoveAgentImpl(AgentHandle);\n\t}\n\n\treturn bRemoved;\n}\n\ntemplate<typename AgentArrayItem>\nvoid TClientBubbleHandlerBase<AgentArrayItem>::RemoveAgentChecked(FMassReplicatedAgentHandle Handle)\n{\n\tcheckf(AgentHandleManager.IsValidHandle(Handle), TEXT(\"FMassReplicatedAgentHandle must be Valid\"));\n\tRemoveAgentImpl(Handle);\n}\n\ntemplate<typename AgentArrayItem>\nvoid TClientBubbleHandlerBase<AgentArrayItem>::RemoveAgentImpl(FMassReplicatedAgentHandle Handle)\n{\n\tFMassAgentLookupData& LookUpData = AgentLookupArray[Handle.GetIndex()];\n\tconst bool bDidSwap = LookUpData.AgentsIdx < ((*Agents).Num() - 1);\n\n\t(*Agents).RemoveAtSwap(LookUpData.AgentsIdx, EAllowShrinking::No);\n\n\tSerializer->MarkArrayDirty();\n\n\tverifyf(NetworkIDToAgentHandleMap.Remove(LookUpData.NetID) == 1, TEXT(\"Failed to find 1 matching NetID in NetworkIDToAgentHandleMap\"));\n\n\tif (bDidSwap)\n\t{\n\t\t//we need to change the AgentsIdx of the Lookup data free list for the item that was swapped\n\t\tconst FMassReplicatedAgentHandle HandleSwap = (*Agents)[LookUpData.AgentsIdx].GetHandle();\n\t\tcheckf(AgentHandleManager.IsValidHandle(HandleSwap), TEXT(\"Handle of the Agent we RemoveAtSwap with must be valid as its in the Agents array\"));\n\n\t\tFMassAgentLookupData& LookUpDataSwap = AgentLookupArray[HandleSwap.GetIndex()];\n\t\tLookUpDataSwap.AgentsIdx = LookUpData.AgentsIdx;\n\t\tcheckf(LookUpDataSwap.NetID.IsValid(), TEXT(\"NetID of item we are swaping with must be valid as its in the Agents array\"));\n\t}\n\n\tAgentHandleManager.RemoveHandle(Handle);\n\n\tLookUpData.Invalidate();\n}\n\ntemplate<typename AgentArrayItem>\nconst typename AgentArrayItem::FReplicatedAgentType* TClientBubbleHandlerBase<AgentArrayItem>::GetAgent(FMassReplicatedAgentHandle Handle) const\n{\n\tif (AgentHandleManager.IsValidHandle(Handle))\n\t{\n\t\tconst FMassAgentLookupData& LookUpData = AgentLookupArray[Handle.GetIndex()];\n\n\t\treturn &((*Agents)[LookUpData.AgentsIdx].Agent);\n\t}\n\treturn nullptr;\n}\n\ntemplate<typename AgentArrayItem>\nconst typename AgentArrayItem::FReplicatedAgentType& TClientBubbleHandlerBase<AgentArrayItem>::GetAgentChecked(FMassReplicatedAgentHandle Handle) const\n{\n\tcheck(AgentHandleManager.IsValidHandle(Handle));\n\n\tconst FMassAgentLookupData& LookUpData = AgentLookupArray[Handle.GetIndex()];\n\treturn (*Agents)[LookUpData.AgentsIdx].Agent;\n}\n#endif //UE_REPLICATION_COMPILE_SERVER_CODE\n\ntemplate<typename AgentArrayItem>\nvoid TClientBubbleHandlerBase<AgentArrayItem>::UpdateAgentsToRemove()\n{\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\tQUICK_SCOPE_CYCLE_COUNTER(MassProcessor_Replication_CalculateClientReplication);\n\n\tcheck(Serializer->GetWorld());\n\n\tUMassReplicationSubsystem* ReplicationSubsystem = Serializer->GetReplicationSubsystem();\n\tcheck(ReplicationSubsystem);\n\n\tconst double TimeRemove = Serializer->GetWorld()->GetRealTimeSeconds() - UE::Mass::Replication::AgentRemoveInterval;\n\n\t// @todo do this in a more efficient way, we may potentially be able to use ACK's and FReplicatedAgentBase::bRemovedFromServeSim\n\t// Check to see if we should free any EntityInfoMap entries, this is to avoid gradually growing EntityInfoMap perpetually\n\tfor (TMap<FMassNetworkID, FMassAgentRemoveData>::TIterator Iter = AgentsRemoveDataMap.CreateIterator(); Iter; ++Iter)\n\t{\n\t\tconst FMassAgentRemoveData& RemoveData = (*Iter).Value;\n\n\t\t// The idea here is that AgentRemoveInterval represents a reasonable amount of time that if an out of order add and remove come in after this that we don't care, as the accuracy of the simulation\n\t\t// must already be pretty awful.\n\t\tif (RemoveData.TimeLastRemoved < TimeRemove)\n\t\t{\n\t\t\tconst FMassNetworkID NetID = (*Iter).Key;\n\n\t\t\tReplicationSubsystem->RemoveFromEntityInfoMap(NetID);\n\t\t\tIter.RemoveCurrent();\n\t\t}\n\t}\n#endif //UE_REPLICATION_COMPILE_CLIENT_CODE\n}\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\ntemplate<typename AgentArrayItem>\nvoid TClientBubbleHandlerBase<AgentArrayItem>::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)\n{\n\tTArray<FMassEntityHandle> EntitiesToDestroy;\n\n\tUWorld* World = Serializer->GetWorld();\n\tcheck(World);\n\n\tUMassSpawnerSubsystem* SpawnerSubsystem = Serializer->GetSpawnerSubsystem();\n\tcheck(SpawnerSubsystem);\n\n\tUMassReplicationSubsystem* ReplicationSubsystem = Serializer->GetReplicationSubsystem();\n\tcheck(ReplicationSubsystem);\n\n\tfor (int32 Idx : RemovedIndices)\n\t{\n\t\tconst AgentArrayItem& RemovedItem = (*Agents)[Idx];\n\n\t\tFMassEntityHandle Entity = ReplicationSubsystem->ResetEntityIfValid(RemovedItem.Agent.GetNetID(), RemovedItem.ReplicationID);\n\n\t\t// Only remove the item if its currently Set / Valid and its the most recent ReplicationID. Stale removes after more recent adds are ignored\n\t\t// We do need to check the ReplicationID in this case\n\t\tif (Entity.IsSet())\n\t\t{\n\t\t\tEntitiesToDestroy.Add(Entity);\n\t\t\t\n\t\t\tcheck(AgentsRemoveDataMap.Find(RemovedItem.Agent.GetNetID()) == nullptr);\n\t\t\tAgentsRemoveDataMap.Add(RemovedItem.Agent.GetNetID(), FMassAgentRemoveData(World->GetRealTimeSeconds()));\n\t\t}\n\t}\n\n\tSpawnerSubsystem->DestroyEntities(EntitiesToDestroy);\n}\n#endif //UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\ntemplate<typename AgentArrayItem>\nvoid TClientBubbleHandlerBase<AgentArrayItem>::PostReplicatedAddHelper(const TArrayView<int32> AddedIndices, FAddRequirementsForSpawnQueryFunction AddRequirementsForSpawnQuery\n\t, FCacheFragmentViewsForSpawnQueryFunction CacheFragmentViewsForSpawnQuery, FSetSpawnedEntityDataFunction SetSpawnedEntityData, FSetModifiedEntityDataFunction SetModifiedEntityData)\n{\n\tFMassEntityManager& EntityManager = Serializer->GetEntityManagerChecked();\n\n\tUMassReplicationSubsystem* ReplicationSubsystem = Serializer->GetReplicationSubsystem();\n\tcheck(ReplicationSubsystem);\n\n\tTMap<FMassNetworkID, int32> AgentsToAddMap; //NetID to index in AgentsToAddArray\n\tAgentsToAddMap.Reserve(AddedIndices.Num());\n\n\tTArray<int32> AgentsToAddArray;\n\tAgentsToAddArray.Reserve(AddedIndices.Num());\n\n\tconst FMassReplicationEntityInfo* EntityInfo;\n\n\tfor (int32 Idx : AddedIndices)\n\t{\n\t\tconst AgentArrayItem& AddedItem = (*Agents)[Idx];\n\n\t\tswitch (ReplicationSubsystem->FindAndUpdateOrAddMassEntityInfo(AddedItem.Agent.GetNetID(), AddedItem.ReplicationID, EntityInfo))\n\t\t{\n\t\tcase UMassReplicationSubsystem::EFindOrAddMassEntityInfo::FoundOlderReplicationID:\n\t\t{\n\t\t\tAgentsRemoveDataMap.Remove(AddedItem.Agent.GetNetID());\n\n\t\t\t// If EntityData IsSet() it means we have had multiple Adds without a remove and we treat this add as modifying an existing agent.\n\t\t\tif (EntityInfo->Entity.IsSet())\n\t\t\t{\n\t\t\t\tFMassEntityView EntityView(EntityManager, EntityInfo->Entity);\n\n\t\t\t\tSetModifiedEntityData(EntityView, AddedItem.Agent);\n\t\t\t}\n\t\t\telse // This entity is not in the client simulation yet and needs adding.\n\t\t\t{\n\t\t\t\tconst int32* IdxInAgentsToAddArray = AgentsToAddMap.Find(AddedItem.Agent.GetNetID());\n\n\t\t\t\t// If IdxInAgentsToAddArray then we've had multiple Adds\n\t\t\t\tif (IdxInAgentsToAddArray)\n\t\t\t\t{\n\t\t\t\t\t// Adjust the existing AgentsToAddArray index\n\t\t\t\t\tAgentsToAddArray[*IdxInAgentsToAddArray] = Idx;\n\t\t\t\t}\n\t\t\t\telse // First time we've tried to add an entity with this FMassNetworkID this update\n\t\t\t\t{\t\n\t\t\t\t\tconst int32 IdxAdd = AgentsToAddArray.Add(Idx);\n\t\t\t\t\tAgentsToAddMap.Add(AddedItem.Agent.GetNetID(), IdxAdd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase UMassReplicationSubsystem::EFindOrAddMassEntityInfo::Added:\n\t\t{\n\t\t\tcheck(AgentsToAddMap.Find(AddedItem.Agent.GetNetID()) == nullptr);\n\n\t\t\tconst int32 IdxAdd = AgentsToAddArray.Add(Idx);\n\t\t\tAgentsToAddMap.Add(AddedItem.Agent.GetNetID(), IdxAdd);\n\t\t}\n\t\tbreak;\n\n\t\tcase UMassReplicationSubsystem::EFindOrAddMassEntityInfo::FoundNewerReplicationID:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcheckf(false, TEXT(\"Unhandled EFindOrAddMassEntityInfo type\"));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tPostReplicatedAddEntitiesHelper(AgentsToAddArray, AddRequirementsForSpawnQuery, CacheFragmentViewsForSpawnQuery, SetSpawnedEntityData);\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\ntemplate<typename AgentArrayItem>\nvoid TClientBubbleHandlerBase<AgentArrayItem>::PostReplicatedAddEntitiesHelper(const TArrayView<int32> AddedIndices, FAddRequirementsForSpawnQueryFunction AddRequirementsForSpawnQuery\n\t, FCacheFragmentViewsForSpawnQueryFunction CacheFragmentViewsForSpawnQuery, FSetSpawnedEntityDataFunction SetSpawnedEntityData)\n{\n\tcheck(Serializer);\n\n\tFMassEntityManager& EntityManager = Serializer->GetEntityManagerChecked();\n\n\tUMassSpawnerSubsystem* SpawnerSubsystem = Serializer->GetSpawnerSubsystem();\n\tcheck(SpawnerSubsystem);\n\n\tUMassReplicationSubsystem* ReplicationSubsystem = Serializer->GetReplicationSubsystem();\n\tcheck(ReplicationSubsystem);\n\n\tTMap<FMassEntityTemplateID, TArray<typename AgentArrayItem::FReplicatedAgentType*>> AgentsSpawnMap;\n\n\t// Group together Agents per TemplateID\n\tfor (int32 Idx : AddedIndices)\n\t{\n\t\ttypename AgentArrayItem::FReplicatedAgentType& Agent = (*Agents)[Idx].Agent;\n\n\t\tTArray<typename AgentArrayItem::FReplicatedAgentType*>& AgentsArray = AgentsSpawnMap.FindOrAdd(Agent.GetTemplateID());\n\t\tAgentsArray.Add(&Agent);\n\t}\n\n\t// Batch spawn per FMassEntityTemplateID\n\tfor (const TPair<FMassEntityTemplateID, TArray<typename AgentArrayItem::FReplicatedAgentType*>>& Item : AgentsSpawnMap)\n\t{\n\t\tconst FMassEntityTemplateID& TemplateID = Item.Key;\n\t\tconst TArray <typename AgentArrayItem::FReplicatedAgentType*>& AgentsSpawn = Item.Value;\n\n\t\tTArray<FMassEntityHandle> Entities;\n\n\t\tSpawnerSubsystem->SpawnEntities(TemplateID, AgentsSpawn.Num(), FStructView(), TSubclassOf<UMassProcessor>(), Entities);\n\n\t\tconst FMassEntityTemplate* MassEntityTemplate = SpawnerSubsystem->GetMassEntityTemplate(TemplateID);\n\t\tcheck(MassEntityTemplate);\n\t\tconst FMassArchetypeHandle& ArchetypeHandle = MassEntityTemplate->GetArchetype();\n\n\n\t\tFMassExecutionContext ExecContext(EntityManager);\n\t\tFMassEntityQuery Query;\n\n\t\tAddRequirementsForSpawnQuery(Query);\n\n\t\tQuery.AddRequirement<FMassNetworkIDFragment>(EMassFragmentAccess::ReadWrite);\n\n\t\tint32 AgentsSpawnIdx = 0;\n\n\t\tQuery.ForEachEntityChunk(FMassArchetypeEntityCollection(ArchetypeHandle, Entities, FMassArchetypeEntityCollection::NoDuplicates)\n\t\t\t\t\t\t\t\t, EntityManager, ExecContext, [&AgentsSpawn, &AgentsSpawnIdx, this, ReplicationSubsystem, &ExecContext, &CacheFragmentViewsForSpawnQuery, &SetSpawnedEntityData, &EntityManager](FMassExecutionContext& Context)\n\t\t\t{\n\t\t\t\tCacheFragmentViewsForSpawnQuery(ExecContext);\n\n\t\t\t\tconst TArrayView<FMassNetworkIDFragment> NetworkIDList = Context.GetMutableFragmentView<FMassNetworkIDFragment>();\n\n\t\t\t\tfor (int32 i = 0; i < Context.GetNumEntities(); ++i)\n\t\t\t\t{\n\t\t\t\t\tconst typename AgentArrayItem::FReplicatedAgentType& AgentSpawn = *AgentsSpawn[AgentsSpawnIdx];\n\t\t\t\t\tconst FMassEntityHandle Entity = Context.GetEntity(i);\n\n\t\t\t\t\tFMassNetworkIDFragment& NetIDFragment = NetworkIDList[i];\n\n\t\t\t\t\tNetIDFragment.NetID = AgentSpawn.GetNetID();\n\t\t\t\t\tReplicationSubsystem->SetEntity(NetIDFragment.NetID, Entity);\n\n\t\t\t\t\tFMassEntityView EntityView(EntityManager, Entity);\n\t\t\t\t\tSetSpawnedEntityData(EntityView, AgentSpawn, i);\n\n\t\t\t\t\t++AgentsSpawnIdx;\n\t\t\t\t}\n\t\t\t});\n\t}\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\ntemplate<typename AgentArrayItem>\nvoid TClientBubbleHandlerBase<AgentArrayItem>::PostReplicatedChangeHelper(const TArrayView<int32> ChangedIndices, FSetModifiedEntityDataFunction SetModifiedEntityData)\n{\n\tFMassEntityManager& EntityManager = Serializer->GetEntityManagerChecked();\n\n\tUMassReplicationSubsystem* ReplicationSubsystem = Serializer->GetReplicationSubsystem();\n\tcheck(ReplicationSubsystem);\n\n\t// Go through the changed Entities and update their Mass data\n\tfor (int32 Idx : ChangedIndices)\n\t{\n\t\tconst AgentArrayItem& ChangedItem = (*Agents)[Idx];\n\n\t\tconst FMassReplicationEntityInfo* EntityInfo = ReplicationSubsystem->FindMassEntityInfo(ChangedItem.Agent.GetNetID());\n\n\t\tcheckf(EntityInfo, TEXT(\"EntityInfo must be valid if the Agent has already been added (which it must have been to get PostReplicatedChange\"));\n\t\tcheckf(EntityInfo->ReplicationID >= ChangedItem.ReplicationID, TEXT(\"ReplicationID out of sync, this should never happen!\"));\n\n\t\t// Currently we don't think this should be needed, but are leaving it in for bomb proofing.\n\t\tif (ensure(EntityInfo->ReplicationID == ChangedItem.ReplicationID))\n\t\t{\n\t\t\tFMassEntityView EntityView(EntityManager, EntityInfo->Entity);\n\t\t\tSetModifiedEntityData(EntityView, ChangedItem.Agent);\n\t\t}\n\t}\n}\n#endif //UE_REPLICATION_COMPILE_CLIENT_CODE\n\ntemplate<typename AgentArrayItem>\nvoid TClientBubbleHandlerBase<AgentArrayItem>::SetClientHandle(FMassClientHandle InClientHandle)\n{\n\tClientHandle = InClientHandle;\n}\n\ntemplate<typename AgentArrayItem>\nvoid TClientBubbleHandlerBase<AgentArrayItem>::Reset()\n{\n\t(*Agents).Reset();\n\n#if UE_REPLICATION_COMPILE_SERVER_CODE\n\tAgentHandleManager.Reset();\n\tNetworkIDToAgentHandleMap.Reset();\n\tAgentLookupArray.Reset();\n#endif //UE_REPLICATION_COMPILE_SERVER_CODE\n}\n\ntemplate<typename AgentArrayItem>\nvoid TClientBubbleHandlerBase<AgentArrayItem>::Tick(float DeltaTime)\n{\n\tUWorld* World = Serializer->GetWorld();\n\tcheck(World);\n\n\tconst ENetMode NetMode = World->GetNetMode();\n\n\tif (NetMode != NM_Client)\n\t{\n\t\tDebugValidateBubbleOnServer();\n\t}\n\telse\n\t{\n\t\tDebugValidateBubbleOnClient();\n\n\t\tUpdateAgentsToRemove();\n\t}\n}\n\ntemplate<typename AgentArrayItem>\nvoid TClientBubbleHandlerBase<AgentArrayItem>::DebugValidateBubbleOnClient()\n{\n#if UE_ALLOW_DEBUG_REPLICATION\n\tconst FMassEntityManager& EntityManager = Serializer->GetEntityManagerChecked();\n\n\tUMassReplicationSubsystem* ReplicationSubsystem = Serializer->GetReplicationSubsystem();\n\tcheck(ReplicationSubsystem);\n\n\tfor (int32 Idx = 0; Idx < (*Agents).Num(); ++Idx)\n\t{\n\t\tconst AgentArrayItem& Item = (*Agents)[Idx];\n\t\tconst typename AgentArrayItem::FReplicatedAgentType& Agent = Item.Agent;\n\n\t\tcheck(Agent.GetTemplateID().IsValid());\n\t\tcheck(Agent.GetNetID().IsValid());\n\n\t\tconst FMassReplicationEntityInfo* EntityInfo = ReplicationSubsystem->FindMassEntityInfo(Agent.GetNetID());\n\t\tcheckf(EntityInfo, TEXT(\"There should always be an EntityInfoMap entry for Agents that are in the Agents array!\"));\n\n\t\tif (EntityInfo)\n\t\t{\n\t\t\tif (EntityInfo->ReplicationID == Item.ReplicationID)\n\t\t\t{\n\t\t\t\tconst bool bIsEntityValid = EntityManager.IsEntityValid(EntityInfo->Entity);\n\t\t\t\tcheckf(bIsEntityValid, TEXT(\"Must be valid entity if at latest ReplciationID\"));\n\n\t\t\t\tif (bIsEntityValid)\n\t\t\t\t{\n\t\t\t\t\tconst FMassNetworkIDFragment& FragmentNetID = EntityManager.GetFragmentDataChecked<FMassNetworkIDFragment>(EntityInfo->Entity);\n\n\t\t\t\t\tcheckf(FragmentNetID.NetID == Agent.GetNetID(), TEXT(\"Fragment and Agent NetID do not match!\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#if UE_ALLOW_DEBUG_SLOW_REPLICATION\n\tconst TMap<FMassNetworkID, FMassReplicationEntityInfo>& EntityInfoMap = ReplicationSubsystem->GetEntityInfoMap();\n\n\tfor (TMap<FMassNetworkID, FMassReplicationEntityInfo>::TConstIterator Iter = EntityInfoMap.CreateConstIterator(); Iter; ++Iter)\n\t{\n\t\tif (Iter->Value.Entity.IsSet())\n\t\t{\n\t\t\tcheckf(AgentsRemoveDataMap.Find(Iter->Key) == nullptr, TEXT(\"If Entity.IsSet() we should not have an entry in AgentsRemoveDataMap!\"));\n\t\t}\n\t}\n\n\tfor (TMap<FMassNetworkID, FMassAgentRemoveData>::TIterator Iter = AgentsRemoveDataMap.CreateIterator(); Iter; ++Iter)\n\t{\n\t\tconst FMassReplicationEntityInfo* EntityInfo = EntityInfoMap.Find(Iter->Key);\n\t\tcheck(EntityInfo);\n\n\t\tcheckf(EntityInfo->Entity.IsSet() == false, TEXT(\"AgentsRemoveDataMap NetIDs in EntityInfoMap should be !Entity.IsSet()\"));\n\t}\n#endif // UE_ALLOW_DEBUG_SLOW_REPLICATION\n\n#endif // UE_ALLOW_DEBUG_REPLICATION\n}\n\ntemplate<typename AgentArrayItem>\nvoid TClientBubbleHandlerBase<AgentArrayItem>::DebugValidateBubbleOnServer()\n{\n#if UE_ALLOW_DEBUG_REPLICATION\n\tusing namespace UE::Mass::Replication;\n\n\tconst FMassEntityManager& EntityManager = Serializer->GetEntityManagerChecked();\n\n\tfor (int32 OuterIdx = 0; OuterIdx < (*Agents).Num(); ++OuterIdx)\n\t{\n\t\tconst AgentArrayItem& OuterItem = (*Agents)[OuterIdx];\n\n\t\t//check there are no duplicate NetID's'\n\t\tif (OuterItem.Agent.GetNetID().IsValid())\n\t\t{\n\t\t\tfor (int32 InnerIdx = OuterIdx + 1; InnerIdx < (*Agents).Num(); ++InnerIdx)\n\t\t\t{\n\t\t\t\tconst AgentArrayItem& InnerItem = (*Agents)[InnerIdx];\n\n\t\t\t\tcheckf(InnerItem.Agent.GetNetID() != OuterItem.Agent.GetNetID(), TEXT(\"Repeated NetIDs in the server Agents array\"));\n\t\t\t}\n\t\t}\n\t\tcheckf(OuterItem.Agent.GetTemplateID().IsValid(), TEXT(\"Server Agent with Invalid TemplateID\"));\n\t\tcheckf(AgentHandleManager.IsValidHandle(OuterItem.GetHandle()), TEXT(\"Server Agent with Invalid Handle\"));\n\t\tcheckf(OuterItem.Agent.GetNetID().IsValid(), TEXT(\"Server Agent with Invalid NetID\"));\n\n\t\tconst FMassAgentLookupData& LookupData = AgentLookupArray[OuterItem.GetHandle().GetIndex()];\n\n\t\tcheckf(LookupData.AgentsIdx == OuterIdx, TEXT(\"Agent index must match lookup data!\"));\n\t\tcheckf(EntityManager.IsEntityValid(LookupData.Entity), TEXT(\"Must be valid entity\"));\n\n\t\tconst FMassNetworkIDFragment& FragmentNetID = EntityManager.GetFragmentDataChecked<FMassNetworkIDFragment>(LookupData.Entity);\n\n\t\tcheckf(FragmentNetID.NetID == OuterItem.Agent.GetNetID(), TEXT(\"Fragment and Agent NetID do not match!\"));\n\t\tcheckf(LookupData.NetID == OuterItem.Agent.GetNetID(), TEXT(\"LookupData and Agent NetID do not match!\"));\n\n\t\tconst FReplicationTemplateIDFragment& FragmentTemplateID = EntityManager.GetFragmentDataChecked<FReplicationTemplateIDFragment>(LookupData.Entity);\n\t\tcheckf(FragmentTemplateID.ID == OuterItem.Agent.GetTemplateID(), TEXT(\"Agent TemplateID different to Fragment!\"));\n\t}\n\n\tcheckf(AgentHandleManager.CalcNumUsedHandles() == (*Agents).Num(), TEXT(\"Num used Agent handles must be the same as the size of the agents array!\"));\n#endif // UE_ALLOW_DEBUG_REPLICATION\n}\n",
      "lines": 739
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Public\\MassClientBubbleInfoBase.h",
      "extension": ".h",
      "size_bytes": 1122,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"GameFramework/Info.h\"\n#include \"MassReplicationTypes.h\"\n#include \"Engine/World.h\"\n\n#include \"MassClientBubbleInfoBase.generated.h\"\n\nstruct FMassClientBubbleSerializerBase;\n\n/** The info actor base class that provides the actual replication */\nUCLASS()\nclass MASSREPLICATION_API AMassClientBubbleInfoBase : public AInfo\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMassClientBubbleInfoBase(const FObjectInitializer& ObjectInitializer);\n\n\tvoid SetClientHandle(FMassClientHandle InClientHandle);\n\nprotected:\n\tvirtual void PostInitProperties() override;\n\n\t// Called either on PostWorldInit() or PostInitProperties()\n\tvirtual void InitializeForWorld(UWorld& World);\n\n\tvirtual void BeginPlay() override;\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid OnPostWorldInit(UWorld* World, const UWorld::InitializationValues);\n\nprotected:\n\tFDelegateHandle OnPostWorldInitDelegateHandle;\n\tTArray<FMassClientBubbleSerializerBase*> Serializers;\n};\n",
      "lines": 40
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Public\\MassClientBubbleSerializerBase.h",
      "extension": ".h",
      "size_bytes": 2156,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Engine/NetSerialization.h\"\n#include \"MassReplicationTypes.h\"\n#include \"Net/Serialization/FastArraySerializer.h\"\n\n#include \"MassClientBubbleSerializerBase.generated.h\"\n\n\nclass UWorld;\nclass UMassSpawnerSubsystem;\nstruct FMassEntityManager;\nclass IClientBubbleHandlerInterface;\n\n/**\n * Classes derived from this will contain the IClientBubbleHandlerInterface derived class as well as the actual Fast Array.\n * This class mainly provides the base automation with the IClientBubbleHandlerInterface\n */\nUSTRUCT()\nstruct MASSREPLICATION_API FMassClientBubbleSerializerBase : public FFastArraySerializer\n{\n\tGENERATED_BODY()\n\npublic:\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\tvoid PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize) const;\n\tvoid PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize) const;\n\tvoid PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize) const;\n#endif //UE_REPLICATION_COMPILE_CLIENT_CODE\n\n\tvoid InitializeForWorld(UWorld& InWorld);\n\n\tUWorld* GetWorld() const { return World; }\n\tUMassSpawnerSubsystem* GetSpawnerSubsystem() const { return SpawnerSubsystem; }\n\tUMassReplicationSubsystem* GetReplicationSubsystem() const { return ReplicationSubsystem; }\n\tFMassEntityManager& GetEntityManagerChecked() const { check(EntityManager); return *EntityManager.Get(); }\n\n\tvoid SetClientHandler(IClientBubbleHandlerInterface& InClientHandler) { ClientHandler = &InClientHandler; }\n\tIClientBubbleHandlerInterface* GetClientHandler() const { return ClientHandler; }\n\n\tvoid ShutDown();\n\nprivate:\n\tUPROPERTY(Transient)\n\tTObjectPtr<UWorld> World = nullptr;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<UMassSpawnerSubsystem> SpawnerSubsystem = nullptr;\n\n\tTSharedPtr<FMassEntityManager> EntityManager;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<UMassReplicationSubsystem> ReplicationSubsystem = nullptr;\n\n\t/** Pointer to the IClientBubbleHandlerInterface derived class in the class derived from this one */\n\tIClientBubbleHandlerInterface* ClientHandler = nullptr;\n};\n",
      "lines": 60
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Public\\MassReplicationFragments.h",
      "extension": ".h",
      "size_bytes": 4834,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassCommonTypes.h\"\n#include \"MassReplicationTypes.h\"\n#include \"MassLODCollector.h\"\n#include \"MassLODCalculator.h\"\n\n#include \"MassReplicationFragments.generated.h\"\n\nclass AMassClientBubbleInfoBase;\nclass UMassReplicatorBase;\n\n/**\n *  Fragment type for the mass network id of a mass entity\n */\nUSTRUCT()\nstruct MASSREPLICATION_API FMassNetworkIDFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tFMassNetworkID NetID;\n};\n\n/**\n * Agent handle per client, these will be at TArray indices of the Client handles indicies (used as a free list array)\n */\nUSTRUCT()\nstruct MASSREPLICATION_API FMassReplicatedAgentFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tFMassReplicatedAgentData AgentData;\n};\n\n/*\n * Data fragment to store the calculated distances to viewers\n */\nUSTRUCT()\nstruct MASSREPLICATION_API FMassReplicationViewerInfoFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\t/** Closest viewer distance */\n\tfloat ClosestViewerDistanceSq;\n\n\t/** Distance between each viewer and entity */\n\tTArray<float> DistanceToViewerSq;\n};\n\nUSTRUCT()\nstruct MASSREPLICATION_API FMassReplicationLODFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\t/**LOD information */\n\tTEnumAsByte<EMassLOD::Type> LOD = EMassLOD::Max;\n\n\t/** Previous LOD information*/\n\tTEnumAsByte<EMassLOD::Type> PrevLOD = EMassLOD::Max;\n};\n\nUCLASS()\nclass MASSREPLICATION_API UMassNetworkIDFragmentInitializer : public UMassObserverProcessor\n{\n\tGENERATED_BODY()\npublic:\n\tUMassNetworkIDFragmentInitializer();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};\n\nUSTRUCT()\nstruct FMassReplicationParameters : public FMassConstSharedFragment\n{\n\tGENERATED_BODY()\npublic:\n\tFMassReplicationParameters();\n\n\t/** Distance where each LOD becomes relevant */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", config)\n\tfloat LODDistance[EMassLOD::Max];\n\n\t/** Hysteresis percentage on delta between the LOD distances */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", meta = (ClampMin = \"0.0\", UIMin = \"0.0\"), config)\n\tfloat BufferHysteresisOnDistancePercentage = 10.0f;\n\n\t/** Maximum limit of entity per LOD */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", config)\n\tint32 LODMaxCount[EMassLOD::Max];\n\n\t/** Maximum limit of entity per LOD per viewer */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", config)\n\tint32 LODMaxCountPerViewer[EMassLOD::Max];\n\n\t/** Distance where each LOD becomes relevant */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", config)\n\tfloat UpdateInterval[EMassLOD::Max];\n\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Replication\", config)\n\tTSubclassOf<AMassClientBubbleInfoBase> BubbleInfoClass;\n\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Replication\", config)\n\tTSubclassOf<UMassReplicatorBase> ReplicatorClass;\n\n};\n\nUSTRUCT()\nstruct FMassReplicationSharedFragment : public FMassSharedFragment\n{\n\tGENERATED_BODY()\npublic:\n\tFMassReplicationSharedFragment() = default;\n\tFMassReplicationSharedFragment(UMassReplicationSubsystem& ReplicationSubsystem, const FMassReplicationParameters& Params);\n\n\tFMassBubbleInfoClassHandle BubbleInfoClassHandle;\n\n\tFMassClientHandle CurrentClientHandle;\n\tTArray<FMassClientHandle> CachedClientHandles;\n\n\t//TODO review if we need to have this as a UPROPERTY at all and also if we can make this use a TInlineAllocator\n\t//Can not use TInlineAllocator with UPROPERTY()\n\tUPROPERTY(Transient)\n\tTArray<TObjectPtr<AMassClientBubbleInfoBase>> BubbleInfos;\n\n\tTMassLODCollector<FReplicationLODLogic> LODCollector;\n\tTMassLODCalculator<FReplicationLODLogic> LODCalculator;\n\tbool bHasAdjustedDistancesFromCount = false;\n\n\tbool bEntityQueryInitialized = false;\n\tFMassEntityQuery EntityQuery;\n\n\tUPROPERTY(Transient)\n\tmutable TObjectPtr<UMassReplicatorBase> CachedReplicator = nullptr;\n\n\ttemplate<typename T>\n\tT& GetTypedClientBubbleInfoChecked(FMassClientHandle Handle)\n\t{\n\t\tcheckSlow(BubbleInfos.IsValidIndex(Handle.GetIndex()));\n\n\t\tAMassClientBubbleInfoBase* BubbleInfo = BubbleInfos[Handle.GetIndex()];\n\n\t\tcheckSlow(BubbleInfo && Cast<T>(BubbleInfo) != nullptr);\n\n\t\treturn *static_cast<T*>(BubbleInfo);\n\t}\n};\n\n/** Cell location for replicated mass agents, used to fetch quickly the agents around each clients */\nUSTRUCT()\nstruct MASSREPLICATION_API FMassReplicationGridCellLocationFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\tFReplicationHashGrid2D::FCellLocation CellLoc;\n};\n\n/** Component Tag to tell if the entity is in the replication grid */\nUSTRUCT()\nstruct MASSREPLICATION_API FMassInReplicationGridTag : public FMassTag\n{\n\tGENERATED_BODY()\n};",
      "lines": 167
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Public\\MassReplicationGridProcessor.h",
      "extension": ".h",
      "size_bytes": 1261,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessor.h\"\n#include \"MassEntityQuery.h\"\n#include \"MassObserverProcessor.h\"\n\n#include \"MassReplicationGridProcessor.generated.h\"\n\nclass UMassReplicationSubsystem;\n\n/** Processor to update entity in the replication grid used to fetch entities close to clients */\nUCLASS()\nclass MASSREPLICATION_API UMassReplicationGridProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassReplicationGridProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\nprivate:\n\tFMassEntityQuery AddToGridEntityQuery;\n\tFMassEntityQuery UpdateGridEntityQuery;\n\tFMassEntityQuery RemoveFromGridEntityQuery;\n};\n\n/** Deinitializer processor to remove entity from the replication grid */\nUCLASS()\nclass MASSREPLICATION_API UMassReplicationGridRemoverProcessor : public UMassObserverProcessor\n{\n\tGENERATED_BODY()\n\n\tUMassReplicationGridRemoverProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};",
      "lines": 45
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Public\\MassReplicationProcessor.h",
      "extension": ".h",
      "size_bytes": 6191,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Engine/World.h\"\n#include \"MassProcessor.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassSimulationLOD.h\"\n#include \"MassReplicationTypes.h\"\n#include \"MassReplicationFragments.h\"\n#include \"MassSpawnerTypes.h\"\n#include \"MassProcessor.h\"\n#include \"MassReplicationSubsystem.h\"\n#include \"MassReplicationProcessor.generated.h\"\n\nclass UMassReplicationSubsystem;\nclass AMassClientBubbleInfoBase;\nclass UWorld;\n\n/** \n *  Base processor that handles replication and only runs on the server. You should derive from this per entity type (that require different replication processing). It and its derived classes \n *  query Mass entity fragments and set those values for replication when appropriate, using the MassClientBubbleHandler.\n */\nUCLASS()\nclass MASSREPLICATION_API UMassReplicationProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassReplicationProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Initialize(UObject& Owner) override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tvoid PrepareExecution(FMassEntityManager& EntityManager);\n\nprotected:\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<UMassReplicationSubsystem> ReplicationSubsystem = nullptr;\n\n\tFMassEntityQuery SyncClientData;\n\tFMassEntityQuery CollectViewerInfoQuery;\n\tFMassEntityQuery CalculateLODQuery;\n\tFMassEntityQuery AdjustLODDistancesQuery;\n\tFMassEntityQuery EntityQuery;\n};\n\n\nstruct FMassReplicationContext\n{\n\tFMassReplicationContext(UWorld& InWorld, const UMassLODSubsystem& InLODSubsystem, UMassReplicationSubsystem& InReplicationSubsystem)\n\t\t: World(InWorld)\n\t\t, LODSubsystem(InLODSubsystem)\n\t\t, ReplicationSubsystem(InReplicationSubsystem)\n\t{}\n\n\tUWorld& World;\n\tconst UMassLODSubsystem& LODSubsystem;\n\tUMassReplicationSubsystem& ReplicationSubsystem;\n};\n\nUCLASS(Abstract)\nclass MASSREPLICATION_API UMassReplicatorBase : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\t/**\n\t * Must override to add specific entity query requirements for replication\n\t * Usually we add replication processor handler requirements\n\t */\n\tvirtual void AddRequirements(FMassEntityQuery& EntityQuery) PURE_VIRTUAL(UMassReplicatorBase::ConfigureQueries, );\n\n\t/**\n\t * Must override to process the client replication\n\t * This methods should call CalculateClientReplication with the appropriate callback implementation\n\t */\n\tvirtual void ProcessClientReplication(FMassExecutionContext& Context, FMassReplicationContext& ReplicationContext) PURE_VIRTUAL(UMassReplicatorBase::ProcessClientReplication, );\n\nprotected:\n\t/**\n\t *  Implemented as straight template callbacks as when profiled this was faster than TFunctionRef. Its probably easier to pass Lamdas in to these\n\t *  but Functors can also be used as well as TFunctionRefs etc. Its also fairly straight forward to call member functions via some Lamda glue code\n\t */\n\ttemplate<typename AgentArrayItem, typename CacheViewsCallback, typename AddEntityCallback, typename ModifyEntityCallback, typename RemoveEntityCallback>\n\tstatic void CalculateClientReplication(FMassExecutionContext& Context, FMassReplicationContext& ReplicationContext, CacheViewsCallback&& CacheViews, AddEntityCallback&& AddEntity, ModifyEntityCallback&& ModifyEntity, RemoveEntityCallback&& RemoveEntity);\n};\n\ntemplate<typename AgentArrayItem, typename CacheViewsCallback, typename AddEntityCallback, typename ModifyEntityCallback, typename RemoveEntityCallback>\nvoid UMassReplicatorBase::CalculateClientReplication(FMassExecutionContext& Context, FMassReplicationContext& ReplicationContext, CacheViewsCallback&& CacheViews, AddEntityCallback&& AddEntity, ModifyEntityCallback&& ModifyEntity, RemoveEntityCallback&& RemoveEntity)\n{\n#if UE_REPLICATION_COMPILE_SERVER_CODE\n\n\tconst int32 NumEntities = Context.GetNumEntities();\n\n\tTConstArrayView<FMassNetworkIDFragment> NetworkIDList = Context.GetFragmentView<FMassNetworkIDFragment>();\n\tTArrayView<FMassReplicationLODFragment> ViewerLODList = Context.GetMutableFragmentView<FMassReplicationLODFragment>();\n\tTArrayView<FMassReplicatedAgentFragment> ReplicatedAgentList = Context.GetMutableFragmentView<FMassReplicatedAgentFragment>();\n\tTConstArrayView<FReplicationTemplateIDFragment> TemplateIDList = Context.GetFragmentView<FReplicationTemplateIDFragment>();\n\tFMassReplicationSharedFragment& RepSharedFragment = Context.GetMutableSharedFragment<FMassReplicationSharedFragment>();\n\n\tCacheViews(Context);\n\n\tconst double Time = ReplicationContext.World.GetRealTimeSeconds();\n\n\tfor (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t{\n\t\tFMassReplicatedAgentFragment& AgentFragment = ReplicatedAgentList[EntityIdx];\n\n\t\tconst FMassClientHandle& ClientHandle = RepSharedFragment.CurrentClientHandle;\n\t\tcheck(ClientHandle.IsValid());\n\n\t\tcheckSlow(RepSharedFragment.BubbleInfos[ClientHandle.GetIndex()] != nullptr);\n\n\t\tFMassReplicatedAgentData& AgentData = AgentFragment.AgentData;\n\n\t\tconst EMassLOD::Type LOD = ViewerLODList[EntityIdx].LOD;\n\n\t\tif (LOD < EMassLOD::Off)\n\t\t{\n\t\t\tAgentData.LOD = LOD;\n\n\t\t\t//if the handle isn't valid we need to add the agent\n\t\t\tif (!AgentData.Handle.IsValid())\n\t\t\t{\n\t\t\t\ttypename AgentArrayItem::FReplicatedAgentType ReplicatedAgent;\n\n\t\t\t\tconst FMassNetworkIDFragment& NetIDFragment = NetworkIDList[EntityIdx];\n\t\t\t\tconst FReplicationTemplateIDFragment& TemplateIDFragment = TemplateIDList[EntityIdx];\n\n\t\t\t\tReplicatedAgent.SetNetID(NetIDFragment.NetID);\n\t\t\t\tReplicatedAgent.SetTemplateID(TemplateIDFragment.ID);\n\n\t\t\t\tAgentData.Handle = AddEntity(Context, EntityIdx, ReplicatedAgent, ClientHandle);\n\n\t\t\t\tAgentData.LastUpdateTime = Time;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tModifyEntity(Context, EntityIdx, LOD, Time, AgentData.Handle, ClientHandle);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// as this is a fresh handle, if its valid then we can use the unsafe remove function\n\t\t\tif (AgentData.Handle.IsValid())\n\t\t\t{\n\t\t\t\tRemoveEntity(Context, AgentData.Handle, ClientHandle);\n\t\t\t\tAgentData.Invalidate();\n\t\t\t}\n\t\t}\n\t}\n#endif //UE_REPLICATION_COMPILE_SERVER_CODE\n}\n",
      "lines": 157
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Public\\MassReplicationSettings.h",
      "extension": ".h",
      "size_bytes": 672,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassSettings.h\"\n#include \"MassReplicationSettings.generated.h\"\n\nUCLASS(config = Mass, defaultconfig, meta = (DisplayName = \"Mass Replication\"))\nclass MASSREPLICATION_API UMassReplicationSettings : public UMassModuleSettings\n{\n\tGENERATED_BODY()\n\npublic:\n\tstatic const UMassReplicationSettings* Get()\n\t{\n\t\treturn GetDefault<UMassReplicationSettings>();\n\t}\n\n\tfloat GetReplicationGridCellSize() const\n\t{ \n\t\treturn ReplicationGridCellSize; \n\t}\n\t\nprivate:\n\n\tUPROPERTY(EditAnywhere, config, Category = Replication);\n\tfloat ReplicationGridCellSize = 5000.0f; // 50 meters;\n};\n",
      "lines": 28
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Public\\MassReplicationSubsystem.h",
      "extension": ".h",
      "size_bytes": 14464,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassCommonTypes.h\"\n#include \"MassEntityTypes.h\"\n#include \"MassReplicationTypes.h\"\n#include \"MassSubsystemBase.h\"\n\n#include \"MassReplicationSubsystem.generated.h\"\n\nstruct FMassEntityManager;\nclass UMassLODSubsystem;\nclass AMassClientBubbleInfoBase;\n\ntypedef TMap<FMassEntityHandle, FMassReplicatedAgentData> FMassReplicationAgentDataMap;\n\nstruct FMassClientReplicationInfo\n{\n\tvoid Reset()\n\t{\n\t\tHandles.Reset();\n\t\tHandledEntities.Reset();\n\t\tAgentsData.Reset();\n\t}\n\n\t/** Note this struct is constructed IsEmpty() == true */\n\tbool IsEmpty() const\n\t{\n\t\treturn (Handles.Num() == 0) && (HandledEntities.Num() == 0) && (AgentsData.Num() == 0);\n\t}\n\n\t/** Array of all the viewer of this client */\n\tTArray<FMassViewerHandle> Handles;\n\n\t/** Array of all the entities handled by this client \n\t  * This array might contains duplicates if there is more than one viewer per client as this concatenates the entities from all viewer of a client) */\n\tTArray<FMassEntityHandle> HandledEntities;\n\n\t/** The saved agent data of the entities handle by this client */\n\tFMassReplicationAgentDataMap AgentsData;\n};\n\nstruct FViewerClientPair\n{\n\tFViewerClientPair() = default;\n\n\tFViewerClientPair(FMassViewerHandle InViewerHandle, FMassClientHandle InClientHandle)\n\t\t: ViewerHandle(InViewerHandle)\n\t\t, ClientHandle(InClientHandle)\n\t{}\n\n\tbool operator== (FViewerClientPair Other) const { return ViewerHandle == Other.ViewerHandle && ClientHandle == Other.ClientHandle; }\n\n\tbool IsValid() const { return ViewerHandle.IsValid() && ClientHandle.IsValid(); }\n\tvoid Invalidate() { ViewerHandle.Invalidate(); ClientHandle.Invalidate(); }\n\n\tFMassViewerHandle ViewerHandle;\n\tFMassClientHandle ClientHandle;\n};\n\nUSTRUCT()\nstruct FMassClientBubbleInfoData\n{\n\tGENERATED_BODY()\n\n\tFMassClientBubbleInfoData() = default;\n\n\tFMassClientBubbleInfoData(TSubclassOf<AMassClientBubbleInfoBase> InBubbleClass)\n\t\t: BubbleClass(InBubbleClass)\n\t{}\n\n\t/** A free list array of AMassClientBubbleInfos. This is organised so the index is that of the client FMassClientHandle */\n\tUPROPERTY(Transient)\n\tTArray<TObjectPtr<AMassClientBubbleInfoBase>> Bubbles;\n\n\tUPROPERTY(Transient)\n\tTSubclassOf<AMassClientBubbleInfoBase> BubbleClass;\n};\n\nnamespace UE::MassReplication\n{\n\tDECLARE_MULTICAST_DELEGATE_TwoParams(FMassAgentDelegate, FMassNetworkID, FMassEntityHandle);\n\n} // UE::MassReplication\n\n/**\n *  Manages the creation of NetworkIDs, ClientBubbles and ClientReplicationInfo.\n *  NetworkIDs are per replicated Agent Entity and are unique and replicated between server and clients.\n *  ClientBubbles relate to the player controller that owns the parent UNetConnection to a Client machine.\n *  ClientReplicationInfo relate to all the player controllers that have a parent or child UNetConnection to a single Client machine (split screen etc).\n */\nUCLASS()\nclass MASSREPLICATION_API UMassReplicationSubsystem : public UMassSubsystemBase\n{\n\tGENERATED_BODY()\n\npublic:\n\n\tUMassReplicationSubsystem();\n\n\tenum class EFindOrAddMassEntityInfo : uint8\n\t{\n\t\tFoundOlderReplicationID,\n\t\tFoundNewerReplicationID,\n\t\tAdded,\n\t};\n\n\tbool IsBubbleClassHandleValid(FMassBubbleInfoClassHandle Handle) const\n\t{\n\t\treturn BubbleInfoArray.IsValidIndex(Handle.GetIndex());\n\t}\n\n\t/** Retrieve network id from Mass handle. */\n\tFMassNetworkID GetNetIDFromHandle(const FMassEntityHandle Handle) const;\n\n\tstatic inline FMassNetworkID GetNextAvailableMassNetID() { return FMassNetworkID(++CurrentNetMassCounter); }\n\n\tconst TArray<FMassClientHandle>& GetClientReplicationHandles() const { return ClientHandleManager.GetHandles(); }\n\n\tbool IsValidClientHandle(FMassClientHandle ClientHandle) const\n\t{\n\t\treturn ClientHandleManager.IsValidHandle(ClientHandle);\n\t}\n\n\t/** Gets the client bubble safely */\n\tAMassClientBubbleInfoBase* GetClientBubble(FMassBubbleInfoClassHandle BubbleClassHandle, FMassClientHandle ClientHandle) const\n\t{\n\t\tAMassClientBubbleInfoBase* ClientBubble = nullptr;\n\n\t\tif (IsBubbleClassHandleValid(BubbleClassHandle) && ClientHandleManager.IsValidHandle(ClientHandle))\n\t\t{\n\t\t\tClientBubble = BubbleInfoArray[BubbleClassHandle.GetIndex()].Bubbles[ClientHandle.GetIndex()];\n\t\t\tcheck(ClientBubble);\n\t\t}\n\t\treturn ClientBubble;\n\t}\n\n\t/** Get the client bubble. Faster version using check()s */\n\tAMassClientBubbleInfoBase* GetClientBubbleChecked(FMassBubbleInfoClassHandle BubbleClassHandle, FMassClientHandle ClientHandle) const\n\t{\n\t\tcheck(IsBubbleClassHandleValid(BubbleClassHandle));\n\t\tcheck(ClientHandleManager.IsValidHandle(ClientHandle));\n\t\tAMassClientBubbleInfoBase* ClientBubble = BubbleInfoArray[BubbleClassHandle.GetIndex()].Bubbles[ClientHandle.GetIndex()];\n\n\t\tcheck(ClientBubble);\n\t\treturn ClientBubble;\n\t}\n\n\t/** Gets the client bubble safely returning the template type */\n\ttemplate<typename TType>\n\tTType* GetTypedClientBubble(FMassBubbleInfoClassHandle BubbleClassHandle, FMassClientHandle ClientHandle) const\n\t{\n\t\treturn Cast<TType>(GetClientBubble(BubbleClassHandle, ClientHandle));\n\t}\n\n\t/** Gets the client bubble returning the template type. Faster version using check()s */\n\ttemplate<typename TType>\n\tTType* GetTypedClientBubbleChecked(FMassBubbleInfoClassHandle BubbleClassHandle, FMassClientHandle ClientHandle) const\n\t{\n\t\tAMassClientBubbleInfoBase* ClientBubble = GetClientBubbleChecked(BubbleClassHandle, ClientHandle);\n\t\tcheckSlow(Cast<TType>(ClientBubble) != nullptr);\n\n\t\treturn static_cast<TType *>(ClientBubble);\n\t}\n\n\t/** Gets the client replication info safely */\n\tconst FMassClientReplicationInfo* GetClientReplicationInfo(FMassClientHandle Handle) const\n\t{\n\t\treturn ClientHandleManager.IsValidHandle(Handle) ? &(ClientsReplicationInfo[Handle.GetIndex()]) : nullptr;\n\t}\n\n\t/** Gets the client replication info. Faster version using check()s */\n\tconst FMassClientReplicationInfo& GetClientReplicationInfoChecked(FMassClientHandle Handle) const\n\t{\n\t\tcheck(ClientHandleManager.IsValidHandle(Handle));\n\n\t\treturn ClientsReplicationInfo[Handle.GetIndex()];\n\t}\n\n\t/** Gets the client replication info. Faster version using check()s */\n\tFMassClientReplicationInfo* GetMutableClientReplicationInfo(FMassClientHandle Handle)\n\t{\n\t\treturn const_cast<FMassClientReplicationInfo*>(GetClientReplicationInfo(Handle));\n\t}\n\n\t/** Gets the client replication info. Faster version using check()s */\n\tFMassClientReplicationInfo& GetMutableClientReplicationInfoChecked(FMassClientHandle Handle)\n\t{\n\t\treturn *const_cast<FMassClientReplicationInfo*>(&GetClientReplicationInfoChecked(Handle));\n\t}\n\n\tvoid SynchronizeClientsAndViewers();\n\n\t/** \n\t * Registers BubbleInfoClass with the system. These are created one per client as clients join. This function can be called multiple times with\n\t * different BubbleInfoClass types (but not the same type), in that case each client will get multiple BubbleInfoClasses. This can be useful for \n\t * replicating different Entity types in different bubbles, although its also possible to have multiple TClientBubbleHandlerBase derived class\n\t * instances per BubbleInfoClass. This must not be called after AddClient or SynchronizeClientsAndViewers is called\n\t * @return FMassBubbleInfoClassHandle Handle to the BubbleInfoClass, this will be an invalid handle if its not been created\n\t */\n\tFMassBubbleInfoClassHandle RegisterBubbleInfoClass(const TSubclassOf<AMassClientBubbleInfoBase>& BubbleInfoClass);\n\n\t/** @return FMassBubbleInfoClassHandle Handle to the BubbleInfoClass, this will be an invalid handle if BubbleInfoClass can not be found */\n\tFMassBubbleInfoClassHandle GetBubbleInfoClassHandle(const TSubclassOf<AMassClientBubbleInfoBase>& BubbleInfoClass) const;\n\n\tconst FReplicationHashGrid2D& GetGrid() const { return ReplicationGrid; }\n\tFReplicationHashGrid2D& GetGridMutable() { return ReplicationGrid; }\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\n\t/** \n\t * Must be called immediately after an Entity is added to the simulation and after FindAndUpdateOrAddMassEntityInfo has been called\n\t */\n\tvoid SetEntity(const FMassNetworkID NetworkID, const FMassEntityHandle Entity);\n\n\t/** \n\t * Resets the item with NetworkID in the  EntityInfoMap if its currently Set / Valid and its the most recent ReplicationID. In this case the FMassEntityHandle that was reset is returned.\n\t * Otherwise FMassEntityHandle::IsSet() will be false on the returned FMassEntityHandle\n\t * Must be called after SetEntity and just before the Entity is removed on the client. This sets the Entity member of the AddToEntityInfoMap item to FMassEntityHandle so it will be not IsSet() \n\t */\n\tFMassEntityHandle ResetEntityIfValid(const FMassNetworkID NetworkID, int32 ReplicationID);\n\n\tvoid RemoveFromEntityInfoMap(const FMassNetworkID NetworkID);\n\n\t/** \n\t * Finds or adds an FMassReplicationEntityInfo to the EntityInfoMap for an Entity with NetWorkID. This will update the ReplicationID if an older one is found but it does not change the \n\t * FMassReplicationEntityInfo::Entity member. Returns whether we added an entry in EntityInfoMap, or if the found item has an older or newer ReplicationID than that that is passed in. \n\t * We shouldn't actually get an equal ReplicationID, but in this case we'll treat the existing EntityInfoMap entry as newer. SetEntity() must be called soon after this if the entity handle is !IsSet()\n\t * @param NetworkID ID of the entity we are looking up OutMassEntityInfo for\n\t * @param ReplicationID this is the ReplicationID of the FastArray item\n\t * @param OutMassEntityInfo retrieved or added FMassReplicationEntityInfo\n\t * @return EFindOrAddMassEntityInfo, result of the function call\n\t */\n\tEFindOrAddMassEntityInfo FindAndUpdateOrAddMassEntityInfo(const FMassNetworkID NetworkID, int32 ReplicationID, const FMassReplicationEntityInfo*& OutMassEntityInfo);\n\n\t/** \n\t * Finds the FMassReplicationEntityInfo for the Entity with NetworkID. NetworkID must be valid and nullptr is returned if we can't find it. Note FMassReplicationEntityInfo::IsSet() may be false,\n\t * in which case this Entity has been removed from the client simulation (but we are still storing the ReplicationID between Removes and Adds!\n\t */\n\tconst FMassReplicationEntityInfo* FindMassEntityInfo(const FMassNetworkID NetworkID) const;\n\n\tFMassEntityHandle FindEntity(const FMassNetworkID NetworkID) const;\n\n\tconst TMap<FMassNetworkID, FMassReplicationEntityInfo>& GetEntityInfoMap() const { return EntityInfoMap; }\n\n\tUE::MassReplication::FMassAgentDelegate& GetOnMassAgentAdded()\n\t{\n\t\treturn OnMassAgentAdded;\n\t}\n\n\tUE::MassReplication::FMassAgentDelegate& GetOnRemovingMassAgent()\n\t{\n\t\treturn OnRemovingMassAgent;\n\t}\n\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\nprotected:\n\t// USubsystem BEGIN\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\tvirtual void Deinitialize() override;\n\t// USubsystem END\n\t\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\tFMassReplicationEntityInfo* FindMassEntityInfoMutable(const FMassNetworkID NetworkID);\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n\t/** Adds a Client and sets up all the data relevant to the bubble. Where there are multiple viewers for\n\t *  one NetConnection only the parent net connection should be added here\n\t *  @param ViewerHandle handle to viewer to add as a client. This must be UMassLODSubsystem->IsValidViewer()\n\t *  @param InController associated with the viewer\n\t */\n\tvoid AddClient(FMassViewerHandle ViewerHandle, APlayerController& InController);\n\n\t/** Removes a Client and removes up all the data relevant to the bubble\n\t *  @param ClientHandle handle to client to remove. This must be ClientHandleManager.IsValidHandle()\n\t */\n\tvoid RemoveClient(FMassClientHandle ClientHandle);\n\n\t/** @return true if we should shrink the number of handles. */\n\tbool SynchronizeClients(const TArray<FViewerInfo>& Viewers);\n\tvoid SynchronizeClientViewers(const TArray<FViewerInfo>& Viewers);\n\n\tvoid DebugCheckArraysAreInSync();\n\nprotected:\n\tstatic uint32 CurrentNetMassCounter;\n\n\tTSharedPtr<FMassEntityManager> EntityManager;\n\n\t/** Clients free list FMassClientHandle manager, handles will to the indices of FMassClientReplicationData::ClientBubbles */\n\tFMassClientHandleManager ClientHandleManager;\n\n\tUPROPERTY(Transient)\n\tTArray<FMassClientBubbleInfoData> BubbleInfoArray;\n\n\t/** An Array of each Clients viewer handles (split screen players sharing the same client connections). \n\t *  This will include both the parent and child NetConnections per client.\n\t *\tThe array is organized so the array index is the same as the index of the client FMassClientHandle.\n\t */\n\tTArray<FMassClientReplicationInfo> ClientsReplicationInfo;\n\n\t/** A free list array of FViewerClientPairs. This is organized so the index is that of the FMassViewerHandle for fast lookup of the related FMassClientHandle. \n\t *  This only contains viewers that are also clients (ie only parent NetConnections not child ones).\n\t */\n\tTArray<FViewerClientPair> ViewerToClientHandleArray;\n\n\t/** A free list array of FViewerClientPairs. This is organized so the index is that of the FMassClientHandle.\n\t *  For fast lookup of the related FMassViewerHandle. This only contains viewers that are also clients (ie only parent NetConnections not child ones).\n\t */\n\tTArray<FViewerClientPair> ClientToViewerHandleArray;\n\n\tUPROPERTY()\n\tTObjectPtr<UWorld> World;\n\n\tUPROPERTY()\n\tTObjectPtr<UMassLODSubsystem> MassLODSubsystem;\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\tTMap<FMassNetworkID, FMassReplicationEntityInfo> EntityInfoMap;\n\n\t// @todo MassReplication consider batching these\n\t/** Broadcast just after a mass agent is added to the client simulation */\n\tUE::MassReplication::FMassAgentDelegate OnMassAgentAdded;\n\n\t/** Broadcast just before a mass agent is removed from the client simulation */\n\tUE::MassReplication::FMassAgentDelegate OnRemovingMassAgent;\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n\t/**\n\t * Used to make sure the FMassEntityHandle_ClientReplications are synchronized immediately before they are needed\n\t * @todo this comment is no longer accurate, needs fixing\n\t */\n\tuint64 LastSynchronizedFrame = 0;\n\n\tFReplicationHashGrid2D ReplicationGrid;\n};\n\ntemplate<>\nstruct TMassExternalSubsystemTraits<UMassReplicationSubsystem> final\n{\n\tenum\n\t{\n\t\tGameThreadOnly = false\n\t};\n};\n",
      "lines": 347
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Public\\MassReplicationTrait.h",
      "extension": ".h",
      "size_bytes": 562,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassEntityTraitBase.h\"\n#include \"MassReplicationFragments.h\"\n#include \"MassReplicationTrait.generated.h\"\n\n\nUCLASS(meta=(DisplayName=\"Replication\"))\nclass MASSREPLICATION_API UMassReplicationTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\npublic:\n\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Replication\")\n\tFMassReplicationParameters Params;\n};\n",
      "lines": 21
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Public\\MassReplicationTransformHandlers.h",
      "extension": ".h",
      "size_bytes": 9629,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassReplicationTypes.h\"\n#include \"MassEntityView.h\"\n#include \"MassClientBubbleHandler.h\"\n#include \"MassCommonFragments.h\"\n#include \"AIHelpers.h\"\n\n#include \"MassReplicationTransformHandlers.generated.h\"\n\nstruct FMassEntityQuery;\n\nnamespace UE::Mass::Replication\n{\n\tconstexpr float PositionReplicateTolerance = 1.f;\n\tconstexpr float YawReplicateTolerance = 0.004363323f;\n}; //namespace UE::Mass::Replication\n\n\n//////////////////////////////////////////////////////////////////////////// FReplicatedAgentPositionYawData ////////////////////////////////////////////////////////////////////////////\n/**\n * To replicate position and yaw make a member variable of this class in your FReplicatedAgentBase derived class. In the FReplicatedAgentBase derived class you must also provide an accessor function\n * FReplicatedAgentPathData& GetReplicatedPositionYawDataMutable().\n */\nUSTRUCT()\nstruct MASSREPLICATION_API FReplicatedAgentPositionYawData\n{\n\tGENERATED_BODY()\npublic:\n\t\n\tFReplicatedAgentPositionYawData()\n\t\t: Position(ForceInitToZero)\n\t{}\n\n\tvoid SetPosition(const FVector& InPosition) { Position = InPosition; }\n\tconst FVector& GetPosition() const { return Position; }\n\n\tvoid SetYaw(const float InYaw) { Yaw = InYaw; }\n\tfloat GetYaw() const { return Yaw; }\n\nprivate:\n\t\n\tUPROPERTY(Transient)\n\tFVector Position;\n\n\t/** Yaw in radians */\n\tUPROPERTY(Transient)\n\tfloat Yaw = 0;\n};\n\n//////////////////////////////////////////////////////////////////////////// TMassClientBubbleTransformHandler ////////////////////////////////////////////////////////////////////////////\n/**\n * To replicate Transforms make a member variable of this class in your TClientBubbleHandlerBase derived class. This class is a friend of TMassClientBubblePathHandler.\n * It is meant to have access to the protected data declared there.\n */\ntemplate<typename AgentArrayItem>\nclass TMassClientBubbleTransformHandler\n{\npublic:\n\tTMassClientBubbleTransformHandler(TClientBubbleHandlerBase<AgentArrayItem>& InOwnerHandler)\n\t\t: OwnerHandler(InOwnerHandler)\n\t{}\n\n#if UE_REPLICATION_COMPILE_SERVER_CODE\n\t/** Sets the position and yaw data in the client bubble on the server */\n\tvoid SetBubblePositionYawFromTransform(const FMassReplicatedAgentHandle Handle, const FTransform& Transform);\n\n\t// Another function  SetBubbleTransform() could be added here if required\n#endif // UE_REPLICATION_COMPILE_SERVER_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\t/**\n\t * When entities are spawned in Mass by the replication system on the client, a spawn query is used to set the data on the spawned entities.\n\t * The following functions are used to configure the query and then set the position and yaw data.\n\t */\n\tstatic void AddRequirementsForSpawnQuery(FMassEntityQuery& InQuery);\n\tvoid CacheFragmentViewsForSpawnQuery(FMassExecutionContext& InExecContext);\n\tvoid ClearFragmentViewsForSpawnQuery();\n\n\tvoid SetSpawnedEntityData(const int32 EntityIdx, const FReplicatedAgentPositionYawData& ReplicatedPathData) const;\n\n\t/** Call this when an Entity that has already been spawned is modified on the client */\n\tstatic void SetModifiedEntityData(const FMassEntityView& EntityView, const FReplicatedAgentPositionYawData& ReplicatedPathData);\n\n\t// We could easily add support replicating FReplicatedAgentTransformData here if required\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\nprotected:\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\tstatic void SetEntityData(FTransformFragment& TransformFragment, const FReplicatedAgentPositionYawData& ReplicatedPositionYawData);\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\nprotected:\n\tTArrayView<FTransformFragment> TransformList;\n\n\tTClientBubbleHandlerBase<AgentArrayItem>& OwnerHandler;\n};\n\n#if UE_REPLICATION_COMPILE_SERVER_CODE\ntemplate<typename AgentArrayItem>\nvoid TMassClientBubbleTransformHandler<AgentArrayItem>::SetBubblePositionYawFromTransform(const FMassReplicatedAgentHandle Handle, const FTransform& Transform)\n{\n\tcheck(OwnerHandler.AgentHandleManager.IsValidHandle(Handle));\n\n\tconst int32 AgentsIdx = OwnerHandler.AgentLookupArray[Handle.GetIndex()].AgentsIdx;\n\tbool bMarkDirty = false;\n\n\tAgentArrayItem& Item = (*OwnerHandler.Agents)[AgentsIdx];\n\n\tcheckf(Item.Agent.GetNetID().IsValid(), TEXT(\"Pos should not be updated on FCrowdFastArrayItem's that have an Invalid ID! First Add the Agent!\"));\n\n\t// GetReplicatedPositionYawDataMutable() must be defined in your FReplicatedAgentBase derived class\n\tFReplicatedAgentPositionYawData& ReplicatedPositionYaw = Item.Agent.GetReplicatedPositionYawDataMutable();\n\n\t// Only update the Pos and mark the item as dirty if it has changed more than the tolerance\n\tconst FVector Pos = Transform.GetLocation();\n\tif (!Pos.Equals(ReplicatedPositionYaw.GetPosition(), UE::Mass::Replication::PositionReplicateTolerance))\n\t{\n\t\tReplicatedPositionYaw.SetPosition(Pos);\n\t\tbMarkDirty = true;\n\t}\n\n\tconst float Yaw = static_cast<float>(FMath::DegreesToRadians(Transform.GetRotation().Rotator().Yaw));\n\n\t// Only update the Yaw and mark the item as dirty if it has changed more than the tolerance\n\tif (FMath::Abs(FMath::FindDeltaAngleRadians(Yaw, ReplicatedPositionYaw.GetYaw())) > UE::Mass::Replication::YawReplicateTolerance)\n\t{\n\t\tReplicatedPositionYaw.SetYaw(Yaw);\n\t\tbMarkDirty = true;\n\t}\n\n\tif (bMarkDirty)\n\t{\n\t\tOwnerHandler.Serializer->MarkItemDirty(Item);\n\t}\n\n}\n#endif //UE_REPLICATION_COMPILE_SERVER_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\ntemplate<typename AgentArrayItem>\nvoid TMassClientBubbleTransformHandler<AgentArrayItem>::AddRequirementsForSpawnQuery(FMassEntityQuery& InQuery)\n{\n\tInQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\ntemplate<typename AgentArrayItem>\nvoid TMassClientBubbleTransformHandler<AgentArrayItem>::CacheFragmentViewsForSpawnQuery(FMassExecutionContext& InExecContext)\n{\n\tTransformList = InExecContext.GetMutableFragmentView<FTransformFragment>();\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\ntemplate<typename AgentArrayItem>\nvoid TMassClientBubbleTransformHandler<AgentArrayItem>::ClearFragmentViewsForSpawnQuery()\n{\n\tTransformList = TArrayView<FTransformFragment>();\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\ntemplate<typename AgentArrayItem>\nvoid TMassClientBubbleTransformHandler<AgentArrayItem>::SetSpawnedEntityData(const int32 EntityIdx, const FReplicatedAgentPositionYawData& ReplicatedPositionYawData) const\n{\n\tFTransformFragment& TransformFragment = TransformList[EntityIdx];\n\n\tSetEntityData(TransformFragment, ReplicatedPositionYawData);\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\ntemplate<typename AgentArrayItem>\nvoid TMassClientBubbleTransformHandler<AgentArrayItem>::SetModifiedEntityData(const FMassEntityView& EntityView, const FReplicatedAgentPositionYawData& ReplicatedPositionYawData)\n{\n\tFTransformFragment& TransformFragment = EntityView.GetFragmentData<FTransformFragment>();\n\n\tSetEntityData(TransformFragment, ReplicatedPositionYawData);\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\ntemplate<typename AgentArrayItem>\nvoid TMassClientBubbleTransformHandler<AgentArrayItem>::SetEntityData(FTransformFragment& TransformFragment, const FReplicatedAgentPositionYawData& ReplicatedPositionYawData)\n{\n\tTransformFragment.GetMutableTransform().SetLocation(ReplicatedPositionYawData.GetPosition());\n\tTransformFragment.GetMutableTransform().SetRotation(FQuat(FVector::UpVector, ReplicatedPositionYawData.GetYaw()));\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n//////////////////////////////////////////////////////////////////////////// FMassReplicationProcessorTransformHandlerBase ////////////////////////////////////////////////////////////////////////////\n\nclass MASSREPLICATION_API FMassReplicationProcessorTransformHandlerBase\n{\npublic:\n\tstatic void AddRequirements(FMassEntityQuery& InQuery);\n\tvoid CacheFragmentViews(FMassExecutionContext& ExecContext);\n\nprotected:\n\tTArrayView<FTransformFragment> TransformList;\n};\n\n//////////////////////////////////////////////////////////////////////////// FMassReplicationProcessorPositionYawHandler ////////////////////////////////////////////////////////////////////////////\n/**\n * Used to replicate position and yaw by your UMassReplicationProcessorBase derived class. This class should only get used on the server.\n * @todo add #if UE_REPLICATION_COMPILE_SERVER_CODE\n */\nclass MASSREPLICATION_API FMassReplicationProcessorPositionYawHandler : public FMassReplicationProcessorTransformHandlerBase\n{\npublic:\n\tvoid AddEntity(const int32 EntityIdx, FReplicatedAgentPositionYawData& InOUtReplicatedPathData) const;\n\n\ttemplate<typename AgentArrayItem>\n\tvoid ModifyEntity(const FMassReplicatedAgentHandle Handle, const int32 EntityIdx, TMassClientBubbleTransformHandler<AgentArrayItem>& BubblePathHandler);\n};\n\ntemplate<typename AgentArrayItem>\nvoid FMassReplicationProcessorPositionYawHandler::ModifyEntity(const FMassReplicatedAgentHandle Handle, const int32 EntityIdx, TMassClientBubbleTransformHandler<AgentArrayItem>& BubbleTransformHandler)\n{\n\tconst FTransformFragment& TransformFragment = TransformList[EntityIdx];\n\n\tBubbleTransformHandler.SetBubblePositionYawFromTransform(Handle, TransformFragment.GetTransform());\n}",
      "lines": 227
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Public\\MassReplicationTypes.h",
      "extension": ".h",
      "size_bytes": 5587,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassCommonTypes.h\"\n#include \"MassLODSubsystem.h\"\n#include \"IndexedHandle.h\"\n#include \"MassEntityTemplate.h\"\n#include \"MassObserverProcessor.h\"\n#include \"MassLODLogic.h\"\n#include \"HierarchicalHashGrid2D.h\"\n\n#include \"MassReplicationTypes.generated.h\"\n\n\n/** Debug option to have bubbles on all player controllers in a stand alone game. This is especially useful for testing and profiling\n *  these systems. This will also disable the ClientsViewers functionality. If UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE is set \n *  UE_REPLICATION_COMPILE_SERVER_CODE will be defined as 1 so server only code is compiled in standalone builds. \n */ \n#ifndef UE_DEBUG_REPLICATION_BUBBLES_STANDALONE\n#define UE_DEBUG_REPLICATION_BUBBLES_STANDALONE 0\n#endif\n\n#if UE_DEBUG_REPLICATION_BUBBLES_STANDALONE && !UE_BUILD_SHIPPING && (UE_GAME || UE_EDITOR)\n#define UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE 1\n#else\n#define UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE 0\n#endif\n\n// WITH_SERVER_CODE is all builds except client only.\n#if WITH_SERVER_CODE\n#define UE_REPLICATION_COMPILE_SERVER_CODE 1\n#else\n#define UE_REPLICATION_COMPILE_SERVER_CODE 0\n#endif\n\n// If not a dedicated server build then we may need client code\n#if !UE_SERVER\n#define UE_REPLICATION_COMPILE_CLIENT_CODE 1\n#else\n#define UE_REPLICATION_COMPILE_CLIENT_CODE 0\n#endif\n\n#ifndef UE_DEBUG_SLOW_REPLICATION\n#define UE_DEBUG_SLOW_REPLICATION 0\n#endif\n\n#if UE_DEBUG_SLOW_REPLICATION && !UE_BUILD_SHIPPING\n#define UE_ALLOW_DEBUG_SLOW_REPLICATION 1\n#else\n#define UE_ALLOW_DEBUG_SLOW_REPLICATION 0\n#endif\n\n#ifndef UE_DEBUG_REPLICATION\n#define UE_DEBUG_REPLICATION 0\n#endif\n\n#if (UE_DEBUG_REPLICATION && !UE_BUILD_SHIPPING) || UE_ALLOW_DEBUG_SLOW_REPLICATION\n#define UE_ALLOW_DEBUG_REPLICATION 1\n#else\n#define UE_ALLOW_DEBUG_REPLICATION 0\n#endif\n\nclass UMassReplicationSubsystem;\n\nDECLARE_LOG_CATEGORY_EXTERN(LogMassReplication, Log, All);\n\n/** Handle of each Agent per Client (bubble), these handles are not consistent between different client bubbles.\n *  Using the compact handle here will make the memory footprint smaller and help the ECS system be more cache friendly.\n *\tTODO: in the long run we can probably use a non serial number handle here, I'd like to stick with the serial number for now though\n */\nUSTRUCT()\nstruct MASSREPLICATION_API FMassReplicatedAgentHandle : public FCompactIndexedHandleBase\n{\n\tGENERATED_BODY()\n\n\tFMassReplicatedAgentHandle() = default;\n\n\t/** @param InIndex - passing INDEX_NONE will make this handle Invalid */\n\tFMassReplicatedAgentHandle(int32 InIndex, uint32 InSerialNumber) : FCompactIndexedHandleBase(InIndex, InSerialNumber)\n\t{\n\t};\n};\n\ntypedef FCompactIndexedHandleManager<FMassReplicatedAgentHandle> FMassReplicatedAgentHandleManager;\n\n//Handle of each Client on the server. A Client is defined as a player controller with a non nullptr parent NetConnection\nUSTRUCT()\nstruct MASSREPLICATION_API FMassClientHandle : public FIndexedHandleBase\n{\n\tGENERATED_BODY()\n\n\tFMassClientHandle() = default;\n\n\t/** @param InIndex - passing INDEX_NONE will make this handle Invalid */\n\tFMassClientHandle(int32 InIndex, uint32 InSerialNumber) : FIndexedHandleBase(InIndex, InSerialNumber)\n\t{\n\t};\n};\n\ntypedef FIndexedHandleManager<FMassClientHandle> FMassClientHandleManager;\n\nUSTRUCT()\nstruct MASSREPLICATION_API FMassBubbleInfoClassHandle : public FSimpleIndexedHandleBase\n{\n\tGENERATED_BODY()\n\n\tFMassBubbleInfoClassHandle() = default;\n\n\t/** @param InIndex - passing INDEX_NONE will make this handle Invalid */\n\tFMassBubbleInfoClassHandle(int32 InIndex) : FSimpleIndexedHandleBase(InIndex)\n\t{\n\t};\n};\n\nUSTRUCT()\nstruct FReplicatedAgentBase\n{\n\tGENERATED_BODY()\n\n\tFReplicatedAgentBase() = default;\n\n\tFReplicatedAgentBase(FMassNetworkID InNetID, FMassEntityTemplateID InTemplateID)\n\t\t: NetID(InNetID)\n\t\t, TemplateID(InTemplateID)\n\t{}\n\n\tvoid SetNetID(FMassNetworkID InNetID) { NetID = InNetID; }\n\tFMassNetworkID GetNetID() const { return NetID; }\n\n\tvoid SetTemplateID(FMassEntityTemplateID InTemplateID) { TemplateID = InTemplateID; }\n\tFMassEntityTemplateID GetTemplateID() const { return TemplateID; }\n\nprivate:\n\tUPROPERTY()\n\tFMassNetworkID NetID;\n\n\tUPROPERTY()\n\tFMassEntityTemplateID TemplateID;\n};\n\nstruct FReplicationLODLogic : public FLODDefaultLogic\n{\n};\n\nstruct FMassReplicatedAgentData\n{\n\tvoid Invalidate()\n\t{\n\t\tHandle.Invalidate();\n\t\tLastUpdateTime = 0.;\n\t\tLOD = EMassLOD::Off;\n\t}\n\n\tFMassReplicatedAgentHandle Handle;\n\tdouble LastUpdateTime = 0.;\n\tEMassLOD::Type LOD = EMassLOD::Off;\n};\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n/** Data that can be accessed from a FMassNetworkID on a client */\nstruct FMassReplicationEntityInfo\n{\n\tFMassReplicationEntityInfo() = default;\n\tFMassReplicationEntityInfo(FMassEntityHandle InEntity, int32 InReplicationID)\n\t\t: Entity(InEntity)\n\t\t, ReplicationID(InReplicationID)\n\t{}\n\n\t/** If this is not IsSet() then the entity has been removed from the client simulation */\n\tFMassEntityHandle Entity; \n\n\t/** This is stored between removes and adds, however this item in the UMassReplicationSubsystem::EntityInfoMap will eventually get cleaned up if Entity.IsSet() == false for a fairly substantial length of time. */\n\tint32 ReplicationID = INDEX_NONE;\n};\n#endif //UE_REPLICATION_COMPILE_CLIENT_CODE\n\ntypedef THierarchicalHashGrid2D<2, 4, FMassEntityHandle> FReplicationHashGrid2D;\t// 2 levels of hierarchy, 4 ratio between levels",
      "lines": 178
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\IMassRepresentationModule.h",
      "extension": ".h",
      "size_bytes": 1153,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n * The public interface to this module.  In most cases, this interface is only public to sibling modules \n * within this plugin.\n */\nclass IMassRepresentationModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t * Singleton-like access to this module's interface.  This is just for convenience!\n\t * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t *\n\t * @return Returns singleton instance, loading the module on demand if needed\n\t */\n\tstatic inline IMassRepresentationModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassRepresentationModule>( \"MassRepresentation\" );\n\t}\n\n\t/**\n\t * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t *\n\t * @return True if the module is loaded and ready to use\n\t */\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassRepresentation\" );\n\t}\n};\n\n",
      "lines": 40
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassDistanceLODProcessor.h",
      "extension": ".h",
      "size_bytes": 1593,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassCommonFragments.h\"\n#include \"MassRepresentationFragments.h\"\n#include \"MassProcessor.h\"\n#include \"MassLODCalculator.h\"\n\n#include \"MassDistanceLODProcessor.generated.h\"\n\n\n/** \n * Tag required by Distance LOD Processor to update LOD information. Removing the tag allows to support temporary \n * disabling of processing for individual entities.\n */\nUSTRUCT()\nstruct MASSREPRESENTATION_API FMassDistanceLODProcessorTag : public FMassTag\n{\n\tGENERATED_BODY();\n};\n\nUCLASS()\nclass MASSREPRESENTATION_API UMassDistanceLODProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassDistanceLODProcessor();\n\nprotected:\n\n\t/** Configure the owned FMassEntityQuery instances to express processor's requirements */\n\tvirtual void ConfigureQueries() override;\n\n\t/** \n\t * Execution method for this processor \n\t * @param EntitySubsystem is the system to execute the lambdas on each entity chunk\n\t * @param Context is the execution context to be passed when executing the lambdas\n\t */\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\t\n\t/**\n\t * Forces Off LOD on all calculation\n\t * @param bForce to whether force or not Off LOD\n\t */\n\tvoid ForceOffLOD(bool bForce) { bForceOFFLOD = bForce; }\n\nprotected:\n\tFMassEntityQuery CloseEntityQuery;\n\tFMassEntityQuery FarEntityQuery;\n\tFMassEntityQuery DebugEntityQuery;\n\n\tbool bForceOFFLOD = false;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<const UScriptStruct> FilterTag = nullptr;\n};",
      "lines": 58
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassDistanceVisualizationTrait.h",
      "extension": ".h",
      "size_bytes": 2870,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassEntityTraitBase.h\"\n#include \"MassRepresentationTypes.h\"\n#include \"MassRepresentationFragments.h\"\n#include \"GameFramework/Actor.h\"\n\n#include \"MassDistanceVisualizationTrait.generated.h\"\n\nclass UMassRepresentationSubsystem;\nclass UMassRepresentationActorManagement;\nclass UMassProcessor;\n\n/** This class has been soft-deprecated. Use MassStationaryVisualizationTrait or MassMovableVisualizationTrait */\nUCLASS(meta=(DisplayName=\"DEPRECATED DistanceVisualization\"))\nclass MASSREPRESENTATION_API UMassDistanceVisualizationTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\npublic:\n\tUMassDistanceVisualizationTrait();\n\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\tvirtual void DestroyTemplate(const UWorld& World) const override;\n\n\t/** Instanced static mesh information for this agent */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tmutable FStaticMeshInstanceVisualizationDesc StaticMeshInstanceDesc;\n\n\t/** Actor class of this agent when spawned in high resolution*/\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tTSubclassOf<AActor> HighResTemplateActor;\n\n\t/** Actor class of this agent when spawned in low resolution*/\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tTSubclassOf<AActor> LowResTemplateActor;\n\n\t/** Allow subclasses to override the representation subsystem to use */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\", meta = (EditCondition = \"bCanModifyRepresentationSubsystemClass\"))\n\tTSubclassOf<UMassRepresentationSubsystem> RepresentationSubsystemClass;\n\n\t/** Configuration parameters for the representation processor */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tFMassRepresentationParameters Params;\n\n\t/** Configuration parameters for the Distance LOD processor */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tFMassDistanceLODParameters LODParams;\n\n\t/** If set to true will result in the visualization-related fragments being added to server-size entities as well.\n\t *  By default only the clients require visualization fragments */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tbool bAllowServerSideVisualization = false;\n\n#if WITH_EDITORONLY_DATA\n\t/** the property is marked like this to ensure it won't show up in UI */\n\tUPROPERTY(EditDefaultsOnly, Category = \"Mass|Visual\")\n\tbool bCanModifyRepresentationSubsystemClass = true;\n#endif // WITH_EDITORONLY_DATA\n\nprotected:\n\t/** \n\t * Controls whether StaticMeshInstanceDesc gets registered via FindOrAddStaticMeshDesc call. Setting it to `false` \n\t * can be useful for subclasses to avoid needlessly creating visualization data in RepresentationSubsystem, \n\t * data that will never be used.\n\t */\n\tbool bRegisterStaticMeshDesc = true;\n};\n",
      "lines": 69
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassMovableVisualizationTrait.h",
      "extension": ".h",
      "size_bytes": 419,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassVisualizationTrait.h\"\n#include \"MassMovableVisualizationTrait.generated.h\"\n\n\nUCLASS()\nclass MASSREPRESENTATION_API UMassMovableVisualizationTrait : public UMassVisualizationTrait\n{\n\tGENERATED_BODY()\npublic:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n};\n\t",
      "lines": 16
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassRepresentationActorManagement.h",
      "extension": ".h",
      "size_bytes": 7029,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassRepresentationActorManagement.generated.h\"\n\nstruct FMassActorSpawnRequestHandle;\nstruct FMassCommandBuffer;\nstruct FMassEntityManager;\nenum class EMassActorSpawnRequestAction : uint8;\nenum class EMassActorEnabledType : uint8;\nstruct FConstStructView;\nstruct FMassEntityHandle;\nstruct FMassActorFragment;\nstruct FMassRepresentationLODFragment;\nstruct FMassRepresentationFragment;\nclass UMassRepresentationSubsystem;\nclass UMassActorSubsystem;\n\nUCLASS()\nclass MASSREPRESENTATION_API UMassRepresentationActorManagement : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\n\t/**\n\t * Returns the spawn priority from the LOD\n\t * @param Representation is the type of enabling to do on this actor\n\t */\n\tvirtual float GetSpawnPriority(const FMassRepresentationLODFragment& Representation) const;\n\n\t/**\n\t * Returns an actor of the template type and setup fragments values from it\n\t * @param RepresentationSubsystem to use to get or spawn the actor\n\t * @param EntityManager associated to the mass agent\n\t * @param MassAgent is the handle to the associated mass agent\n\t * @param ActorInfo is the fragment where we are going to store the actor pointer\n\t * @param Transform is the spatial information about where to spawn the actor\n\t * @param TemplateActorIndex is the index of the type fetched with UMassRepresentationSubsystem::FindOrAddTemplateActor()\n\t * @param SpawnRequestHandle (in/out) In: previously requested spawn Out: newly requested spawn\n\t * @param Priority of this spawn request in comparison with the others, lower value means higher priority\n\t * @return the actor spawned\n\t */\n\tvirtual AActor* GetOrSpawnActor(UMassRepresentationSubsystem& RepresentationSubsystem, FMassEntityManager& EntityManager\n\t\t, const FMassEntityHandle MassAgent, const FTransform& Transform, const int16 TemplateActorIndex\n\t\t, FMassActorSpawnRequestHandle& InOutSpawnRequestHandle, const float Priority) const;\n\n\t/**\n\t * Enable/disable a spawned actor for a mass entity\n\t * @param EnabledType is the type of enabling to do on this actor\n\t * @param Actor is the actual actor to perform enabling type on\n\t * @param EntityIdx is the entity index currently processing\n\t * @param CommandBuffer to queue up anything that is thread sensitive\n\t */\n\tvirtual void SetActorEnabled(const EMassActorEnabledType EnabledType, AActor& Actor, const int32 EntityIdx, FMassCommandBuffer& CommandBuffer) const;\n\n\t/**\n\t * Teleports the actor at the specified transform by preserving its velocity and without collision.\n\t * The destination will be adjusted to fit an existing capsule.\n\t * @param Transform is the new actor's transform\n\t * @param Actor is the actual actor to teleport\n\t * @param CommandBuffer to queue up anything that is thread sensitive\n\t */\n\tvirtual void TeleportActor(const FTransform& Transform, AActor& Actor, FMassCommandBuffer& CommandBuffer) const;\n\n\n\t/**\n\t * Method that will be bound to a delegate called before the spawning of an actor to let the requester prepare it\n\t * @param SpawnRequestHandle the handle of the spawn request that is about to spawn\n\t * @param SpawnRequest of the actor that is about to spawn\n\t * @param EntityManager to use to retrieve the mass agent fragments\n\t */\n\tvirtual void OnPreActorSpawn(const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest, TSharedRef<FMassEntityManager> EntityManager) const;\n\n\t/**\n\t * Method that will be bound to a delegate used post-spawn to notify and let the requester configure the actor\n\t * @param SpawnRequestHandle the handle of the spawn request that was just spawned\n\t * @param SpawnRequest of the actor that just spawned\n\t * @param EntityManager to use to retrieve the mass agent fragments\n\t * @return The action to take on the spawn request, either keep it there or remove it.\n\t */\n\tvirtual EMassActorSpawnRequestAction OnPostActorSpawn(const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest, TSharedRef<FMassEntityManager> EntityManager) const;\n\n\t/**\n\t * Static methods to Release an actor or cancel its spawning (calls ReleaseAnyActorOrCancelAnySpawning)\n\t * WARNING: This method will destroy the associated actor in any and by the same fact might also move the entity into a new archetype.\n\t *          So any reference to fragment might become invalid.\n\t * @param EntityManager to use to retrieve the mass agent fragments\n\t * @param MassAgent is the handle to the associated mass agent\n\t * @return True if actor was release or spawning request was canceled\n\t */\n\tstatic void ReleaseAnyActorOrCancelAnySpawning(FMassEntityManager& EntityManager, const FMassEntityHandle MassAgent);\n\n\t/**\n\t * static Release an actor or cancel its spawning\n\t * WARNING: This method will destroy the associated actor in any and by the same fact might also move the entity into a new archetype.\n\t *          So any reference to fragment might become invalid if you are not within the pipe execution\n\t * @param RepresentationSubsystem to use to release any actors or cancel spawning requests\n\t * @param MassAgent is the handle to the associated mass agent\n\t * @param ActorInfo is the fragment where we are going to store the actor pointer\n\t * @param Representation fragment containing the current and previous visual state\n\t * @param ActorSubsystem passed over to FMassActorFragment::ResetAndUpdateHandleMap, used to avoid fetching the subsystem\n\t *\tfrom UWorld every time.\n\t */\n\tstatic void ReleaseAnyActorOrCancelAnySpawning(UMassRepresentationSubsystem& RepresentationSubsystem, const FMassEntityHandle MassAgent\n\t\t, FMassActorFragment& ActorInfo, FMassRepresentationFragment& Representation, UMassActorSubsystem* ActorSubsystem = nullptr);\n\n\tUE_DEPRECATED(5.4, \"This flavor of GetOrSpawnActor has been deprecated due to a defunct parameter, OutActorInfo, that was never being used.\")\n\tvirtual AActor* GetOrSpawnActor(UMassRepresentationSubsystem& RepresentationSubsystem, FMassEntityManager& EntityManager\n\t\t, const FMassEntityHandle MassAgent, FMassActorFragment&/* OutActorInfo*/, const FTransform& Transform, const int16 TemplateActorIndex\n\t\t, FMassActorSpawnRequestHandle& InOutSpawnRequestHandle, const float Priority) const final;\n\n\tUE_DEPRECATED(5.4, \"This flavor of OnPreActorSpawn has been deprecated in favor of the version using TSharedPtr<FMassEntityManager> as a parameter. Use that one instead.\")\n\tvirtual void OnPreActorSpawn(const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest, FMassEntityManager* EntityManager) const final;\n\n\tUE_DEPRECATED(5.4, \"This flavor of OnPostActorSpawn has been deprecated in favor of the version using TSharedPtr<FMassEntityManager> as a parameter. Use that one instead.\")\n\tvirtual EMassActorSpawnRequestAction OnPostActorSpawn(const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest, FMassEntityManager* EntityManager) const final;\n};",
      "lines": 119
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassRepresentationDebug.h",
      "extension": ".h",
      "size_bytes": 1300,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassCommonTypes.h\"\n#include \"Containers/ArrayView.h\"\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\nclass UWorld;\nstruct FColor;\nstruct FMassExecutionContext;\nstruct FMassRepresentationFragment;\nstruct FMassRepresentationLODFragment;\nstruct FTransformFragment;\n\nnamespace UE::Mass::Representation::Debug\n{\n\textern MASSREPRESENTATION_API FColor RepresentationColors[];\n\n\textern MASSREPRESENTATION_API int32 DebugRepresentation;\n\textern MASSREPRESENTATION_API float DebugRepresentationMaxSignificance;\n\n\textern MASSREPRESENTATION_API int32 DebugRepresentationLOD;\n\textern MASSREPRESENTATION_API float DebugRepresentationLODMaxSignificance;\n\n\tvoid DebugDisplayRepresentation(FMassExecutionContext& Context, TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList, TConstArrayView<FMassRepresentationFragment> RepresentationList, TConstArrayView<FTransformFragment> LocationList, UWorld* World);\n\n\tvoid VisLogRepresentation(FMassExecutionContext& Context, TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList, TConstArrayView<FMassRepresentationFragment> RepresentationList, TConstArrayView<FTransformFragment> LocationList, UObject* LogOwner);\n}\n\n#endif // WITH_MASSGAMEPLAY_DEBUG\n",
      "lines": 32
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassRepresentationFragments.h",
      "extension": ".h",
      "size_bytes": 10334,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassLODTypes.h\"\n#include \"MassEntityTypes.h\"\n#include \"MassEntityManager.h\"\n#include \"MassActorSpawnerSubsystem.h\"\n#include \"MassRepresentationTypes.h\"\n#include \"MassRepresentationActorManagement.h\"\n#include \"MassLODCalculator.h\"\n\n#include \"MassRepresentationFragments.generated.h\"\n\nclass UMassRepresentationSubsystem;\nclass UMassRepresentationActorManagement;\n\nUSTRUCT()\nstruct MASSREPRESENTATION_API FMassStaticRepresentationTag : public FMassTag\n{\n\tGENERATED_BODY(); \n};\n\nUSTRUCT()\nstruct MASSREPRESENTATION_API FMassRepresentationLODFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\t/** LOD information */\n\tUPROPERTY()\n\tTEnumAsByte<EMassLOD::Type> LOD = EMassLOD::Max;\n\n\tUPROPERTY()\n\tTEnumAsByte<EMassLOD::Type> PrevLOD = EMassLOD::Max;\n\n\t/** Visibility Info */\n\tUPROPERTY()\n\tEMassVisibility Visibility = EMassVisibility::Max;\n\n\tUPROPERTY()\n\tEMassVisibility PrevVisibility = EMassVisibility::Max;\n\n\t/** Value scaling from 0 to 3, 0 highest LOD we support and 3 being completely off LOD */\n\tUPROPERTY()\n\tfloat LODSignificance = 0.0f;\n};\n\nUSTRUCT()\nstruct MASSREPRESENTATION_API FMassRepresentationFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY()\n\tEMassRepresentationType CurrentRepresentation = EMassRepresentationType::None;\n\n\tUPROPERTY()\n\tEMassRepresentationType PrevRepresentation = EMassRepresentationType::None;\n\n\tUPROPERTY()\n\tint16 HighResTemplateActorIndex = INDEX_NONE;\n\n\tUPROPERTY()\n\tint16 LowResTemplateActorIndex = INDEX_NONE;\n\n\tUPROPERTY()\n\tFStaticMeshInstanceVisualizationDescHandle StaticMeshDescHandle;\n\n\tUPROPERTY()\n\tFMassActorSpawnRequestHandle ActorSpawnRequestHandle;\n\n\tUPROPERTY()\n\tFTransform PrevTransform;\n\n\t/** Value scaling from 0 to 3, 0 highest LOD we support and 3 being completely off LOD */\n\tUPROPERTY()\n\tfloat PrevLODSignificance = -1.0f;\n};\n\nUSTRUCT()\nstruct FMassRepresentationSubsystemSharedFragment : public FMassSharedFragment\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<UMassRepresentationSubsystem> RepresentationSubsystem = nullptr;\n};\n\ntemplate<>\nstruct TMassSharedFragmentTraits<FMassRepresentationSubsystemSharedFragment> final\n{\n\tenum\n\t{\n\t\tGameThreadOnly = true\n\t};\n};\n\n\nUSTRUCT()\nstruct FMassRepresentationParameters : public FMassConstSharedFragment\n{\n\tGENERATED_BODY()\n\n\tFMassRepresentationParameters() = default;\n\n\t/** Allow subclasses to override the representation actor management behavior */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\", meta = (EditCondition = \"bCanModifyRepresentationActorManagementClass\"))\n\tTSubclassOf<UMassRepresentationActorManagement> RepresentationActorManagementClass;\n\n\t/** What should be the representation of this entity for each specific LOD */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Representation\", config)\n\tEMassRepresentationType LODRepresentation[EMassLOD::Max] = { EMassRepresentationType::HighResSpawnedActor, EMassRepresentationType::LowResSpawnedActor, EMassRepresentationType::StaticMeshInstance, EMassRepresentationType::None };\n\n\t/** \n\t * If true, forces UMassRepresentationProcessor to override the WantedRepresentationType to actor representation whenever an external (non Mass owned)\n\t * actor is set on an entitie's FMassActorFragment fragment. If / when the actor fragment is reset, WantedRepresentationType resumes selecting the \n\t * appropriate representation for the current representation LOD.\n\t *\n\t * Useful for server-authoritative actor spawning to force actor representation on clients for replicated actors. \n\t */ \n\tUPROPERTY(EditAnywhere, Category = \"Mass|Representation\", config)\n\tuint8 bForceActorRepresentationForExternalActors : 1 = false;\n\n\t/** If true, LowRes actors will be kept around, disabled, whilst StaticMeshInstance representation is active */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Representation\", config)\n\tuint8 bKeepLowResActors : 1  = true;\n\n\t/** When switching to ISM keep the actor an extra frame, helps cover rendering glitches (i.e. occlusion query being one frame late) */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Representation\", config)\n\tuint8 bKeepActorExtraFrame : 1  = false;\n\n\t/** If true, will spread the first visualization update over the period specified in NotVisibleUpdateRate member */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Representation\", config)\n\tuint8 bSpreadFirstVisualizationUpdate : 1  = false;\n\n#if WITH_EDITORONLY_DATA\n\t/** the property is marked like this to ensure it won't show up in UI */\n\tUPROPERTY(EditDefaultsOnly, Category = \"Mass|Visual\")\n\tuint8 bCanModifyRepresentationActorManagementClass : 1 = true;\n#endif // WITH_EDITORONLY_DATA\n\n\t/** World Partition grid name to test collision against, default None will be the main grid */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Representation\", config)\n\tFName WorldPartitionGridNameContainingCollision;\n\n\t/** At what rate should the not visible entity be updated in seconds */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visualization\", config)\n\tfloat NotVisibleUpdateRate = 0.5f;\n\n\tinline void ComputeCachedValues() const;\n\n\t/** Default representation when unable to spawn an actor, gets calculated at initialization */\n\tUPROPERTY(Transient)\n\tmutable EMassRepresentationType CachedDefaultRepresentationType = EMassRepresentationType::None;\n\n\tUPROPERTY(Transient)\n\tmutable TObjectPtr<UMassRepresentationActorManagement> CachedRepresentationActorManagement = nullptr;\n};\n\ntemplate<>\nstruct TMassSharedFragmentTraits<FMassRepresentationParameters> final\n{\n\tenum\n\t{\n\t\tGameThreadOnly = true\n\t};\n};\n\n\ninline void FMassRepresentationParameters::ComputeCachedValues() const\n{\n\t// Calculate the default representation when actor isn't spawned yet.\n\tfor (int32 LOD = EMassLOD::High; LOD < EMassLOD::Max; LOD++)\n\t{\n\t\t// Find the first representation type after any actors\n\t\tif (LODRepresentation[LOD] == EMassRepresentationType::HighResSpawnedActor ||\n\t\t\tLODRepresentation[LOD] == EMassRepresentationType::LowResSpawnedActor)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tCachedDefaultRepresentationType = LODRepresentation[LOD];\n\t\tbreak;\n\t}\n\n\tCachedRepresentationActorManagement = RepresentationActorManagementClass.GetDefaultObject();\n\tif (CachedRepresentationActorManagement == nullptr)\n\t{\n\t\t// We should have warn about it in the traits.\n\t\tCachedRepresentationActorManagement = UMassRepresentationActorManagement::StaticClass()->GetDefaultObject<UMassRepresentationActorManagement>();\n\t}\n}\n\nUSTRUCT()\nstruct FMassVisualizationLODParameters : public FMassConstSharedFragment\n{\n\tGENERATED_BODY()\n\n\t/** Distances where each LOD becomes relevant */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", config)\n\tfloat BaseLODDistance[EMassLOD::Max] = { 0.f, 1000.f, 2500.f, 10000.f };\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", config)\n\tfloat VisibleLODDistance[EMassLOD::Max] = { 0.f, 2000.f, 4000.f, 15000.f };\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", meta = (ClampMin = \"0.0\", UIMin = \"0.0\"), config)\n\tfloat BufferHysteresisOnDistancePercentage = 10.0f;\n\n\t/** Maximum limit for each entity per LOD */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", config)\n\tint32 LODMaxCount[EMassLOD::Max] = {50, 100, 500, MAX_int32};\n\n\t/** Entities within this distance from frustum will be considered visible. Expressed in Unreal Units. */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", meta = (ClampMin = \"0.0\", UIMin = \"0.0\"), config)\n\tfloat DistanceToFrustum = 0.0f;\n\n\t/** Once visible how much further than DistanceToFrustum does the entities need to be before being cull again */\n\t/** \n\t * Once an entity is visible how far away from frustum does it need to get to lose \"visible\" state. \n\t * Expressed in Unreal Units and is added to DistanceToFrustum to arrive at the final value to be used for testing.\n\t */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", meta = (ClampMin = \"0.0\", UIMin = \"0.0\"), config)\n\tfloat DistanceToFrustumHysteresis = 0.0f;\n\n\t/** Filter these settings with specified tag */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", meta = (BaseStruct = \"/Script/MassEntity.MassTag\"))\n\tTObjectPtr<UScriptStruct> FilterTag = nullptr;\n};\n\nUSTRUCT()\nstruct FMassVisualizationLODSharedFragment : public FMassSharedFragment\n{\n\tGENERATED_BODY()\n\n\tFMassVisualizationLODSharedFragment() = default;\n\tFMassVisualizationLODSharedFragment(const FMassVisualizationLODParameters& LODParams);\n\n\tTMassLODCalculator<FMassRepresentationLODLogic> LODCalculator;\n\tbool bHasAdjustedDistancesFromCount = false;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<const UScriptStruct> FilterTag = nullptr;\n};\n\n/** Simplest version of LOD Calculation based strictly on Distance parameters \n *\tCompared to FMassVisualizationLODParameters, we:\n *\t* Only include a single set of LOD Distances (radial distance from viewer)\n *\t* we do not care about distance to Frustum\n *\t* we do not care about Max Count\n */\nUSTRUCT()\nstruct FMassDistanceLODParameters : public FMassConstSharedFragment\n{\n\tGENERATED_BODY()\n\n\t/** Distances where each LOD becomes relevant */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", config)\n\tfloat LODDistance[EMassLOD::Max] = { 0.f, 1000.f, 2500.f, 10000.f };\n\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", meta = (ClampMin = \"0.0\", UIMin = \"0.0\"), config)\n\tfloat BufferHysteresisOnDistancePercentage = 10.0f;\n\n\t/** Filter these settings with specified tag */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|LOD\", meta = (BaseStruct = \"/Script/MassEntity.MassTag\"))\n\tTObjectPtr<UScriptStruct> FilterTag = nullptr;\n};\n\n/** Simplest version of LOD Calculation based strictly on Distance parameters \n *\tCompared to FMassVisualizationLODSharedFragment, we:\n *\t* Cannot Adjust the Distance from count\n *\t* We care about a MassLODCalculator with a new LOD logic that excludes Visibility computation\n */\nUSTRUCT()\nstruct FMassDistanceLODSharedFragment : public FMassSharedFragment\n{\n\tGENERATED_BODY()\n\n\tFMassDistanceLODSharedFragment() = default;\n\tFMassDistanceLODSharedFragment(const FMassDistanceLODParameters& LODParams);\n\n\tTMassLODCalculator<FMassDistanceLODLogic> LODCalculator;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<const UScriptStruct> FilterTag = nullptr;\n};\n",
      "lines": 282
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassRepresentationProcessor.h",
      "extension": ".h",
      "size_bytes": 5765,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassLODFragments.h\"\n#include \"MassRepresentationFragments.h\"\n#include \"MassActorSpawnerSubsystem.h\"\n#include \"MassObserverProcessor.h\"\n\n#include \"MassRepresentationProcessor.generated.h\"\n\nclass UMassRepresentationSubsystem;\nclass UMassActorSubsystem;\nstruct FMassActorFragment;\n\n\nnamespace UE::Mass::Representation\n{\n\textern MASSREPRESENTATION_API int32 bAllowKeepActorExtraFrame;\n}\n\nUSTRUCT()\nstruct FMassRepresentationUpdateParams\n{\n\tGENERATED_BODY()\n\n\t/** \n\t * Controls whether UpdateRepresentation run will ask the RepresentationSubsystem whether the relevant world \n\t * collision has been already loaded while considering switching an entity to a actor-level representation. Note that\n\t * the test is unnecessary for static nor stationary entities.\n\t */\n\tUPROPERTY(config, EditDefaultsOnly, Category = \"Mass\")\n\tbool bTestCollisionAvailibilityForActorVisualization = true;\n};\n\nUCLASS(Abstract)\nclass MASSREPRESENTATION_API UMassRepresentationProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassRepresentationProcessor();\n\n\t/*\n\t * Update representation type for each entity, must be called within a ForEachEntityChunk\n\t * @param Context of the execution from the entity sub system\n\t */\n\tstatic void UpdateRepresentation(FMassExecutionContext& Context, const FMassRepresentationUpdateParams& Params);\n\nprotected:\n\n\t/** Configure the owned FMassEntityQuery instances to express processor's requirements */\n\tvirtual void ConfigureQueries() override;\n\n\t/** \n\t * Execution method for this processor \n\t * @param EntityManager is the system to execute the lambdas on each entity chunk\n\t * @param Context is the execution context to be passed when executing the lambdas\n\t */\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\t/**\n\t * Release the actor to the subsystem, will only release it the actor or spawn request matches the template actor\n\t * @param RepresentationSubsystem to use to release the actor or cancel the spawning\n\t * @param MassAgent is the handle to the associated mass agent\n\t * @param ActorInfo is the fragment where we are going to store the actor pointer\n\t * @param TemplateActorIndex is the index of the type to release\n\t * @param SpawnRequestHandle (in/out) In: previously requested spawn to cancel if any\n\t * @param CommandBuffer to queue up anything that is thread sensitive\n\t * @param bCancelSpawningOnly tell to only cancel the existing spawning request and to not release the associated actor it any.\n\t * @return if the actor was release or the spawning was canceled.\n\t */\n\tstatic bool ReleaseActorOrCancelSpawning(UMassRepresentationSubsystem& RepresentationSubsystem, UMassActorSubsystem* MassActorSubsystem\n\t\t, const FMassEntityHandle MassAgent, FMassActorFragment& ActorInfo, const int16 TemplateActorIndex, FMassActorSpawnRequestHandle& SpawnRequestHandle\n\t\t, FMassCommandBuffer& CommandBuffer, const bool bCancelSpawningOnly = false);\n\n\tFMassEntityQuery EntityQuery;\n\n\tUPROPERTY(config, EditDefaultsOnly, Category = \"Mass\")\n\tFMassRepresentationUpdateParams UpdateParams;\n};\n\n\t\n/**\n * Tag required by Visualization Processor to process given archetype. Removing the tag allows to support temporary\n * disabling of processing for individual entities of given archetype.\n */\nUSTRUCT()\nstruct MASSREPRESENTATION_API FMassVisualizationProcessorTag : public FMassTag\n{\n\tGENERATED_BODY();\n};\n\nUCLASS()\nclass MASSREPRESENTATION_API UMassVisualizationProcessor : public UMassRepresentationProcessor\n{\n\tGENERATED_BODY()\n\nprotected:\n\n\t/** Configure the owned FMassEntityQuery instances to express processor's requirements */\n\tvirtual void ConfigureQueries() override;\n\n\t/**\n\t * Execution method for this processor\n\t * @param EntityManager is the system to execute the lambdas on each entity chunk\n\t * @param Context is the execution context to be passed when executing the lambdas\n\t */\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\t/**\n\t * Updates chunk visibility info for later chunk logic optimization\n\t * @param Context of the execution from the entity sub system\n\t * @return The visualization chunk fragment\n\t */\n\tFMassVisualizationChunkFragment& UpdateChunkVisibility(FMassExecutionContext& Context) const;\n\n\t/**\n\t * Updates entity visibility tag for later chunk logic optimization\n\t * @param Entity of the entity to update visibility on\n\t * @param Representation fragment containing the current and previous visual state\n\t * @param RepresentationLOD fragment containing the visibility information\n\t * @param ChunkData is the visualization chunk fragment\n\t * @param CommandBuffer to queue up anything that is thread sensitive\n\t */\n\tstatic void UpdateEntityVisibility(const FMassEntityHandle Entity, const FMassRepresentationFragment& Representation, const FMassRepresentationLODFragment& RepresentationLOD, FMassVisualizationChunkFragment& ChunkData, FMassCommandBuffer& CommandBuffer);\n\n\t/**\n\t * Update representation and visibility for each entity, must be called within a ForEachEntityChunk\n\t * @param Context of the execution from the entity sub system\n\t */\n\tvoid UpdateVisualization(FMassExecutionContext& Context);\n};\n\n\nUCLASS()\nclass MASSREPRESENTATION_API UMassRepresentationFragmentDestructor : public UMassObserverProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassRepresentationFragmentDestructor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};",
      "lines": 149
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassRepresentationSubsystem.h",
      "extension": ".h",
      "size_bytes": 10549,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"GameFramework/Actor.h\"\n#include \"MassCommonTypes.h\"\n#include \"Misc/MTAccessDetector.h\"\n#include \"MassRepresentationTypes.h\"\n#include \"MassActorSpawnerSubsystem.h\"\n#include \"MassSubsystemBase.h\"\n#include \"MassRepresentationSubsystem.generated.h\"\n\nclass UMassVisualizationComponent;\nclass AMassVisualizer;\nstruct FStaticMeshInstanceVisualizationDesc;\nstruct FMassInstancedStaticMeshInfo;\nstruct FMassActorSpawnRequestHandle;\nclass UMassActorSpawnerSubsystem;\nclass UMassAgentComponent;\nstruct FMassEntityManager;\nenum class EMassProcessingPhase : uint8;\nclass UWorldPartitionSubsystem;\n\n/**\n * Subsystem responsible for all visual of mass agents, will handle actors spawning and static mesh instances\n */\nUCLASS()\nclass MASSREPRESENTATION_API UMassRepresentationSubsystem : public UMassSubsystemBase\n{\n\tGENERATED_BODY()\n\npublic:\n\t/** \n\t * Get the index of the static mesh visual type, will add a new one if does not exist  \n\t * @param Desc is the information for the static mesh that will be instantiated later via AddStaticMeshInstance()\n\t * @return The index of the static mesh type \n\t */\n\tFStaticMeshInstanceVisualizationDescHandle FindOrAddStaticMeshDesc(const FStaticMeshInstanceVisualizationDesc& Desc);\n\n\t/**\n\t * Creates a dedicated visual type described by host Desc and ties ISMComponent to it.\n\t * @note this is a helper function for a common \"single ISMComponent\" case. Calls AddVisualDescWithISMComponents under the hood.\n\t * @return The index of the visual type\n\t */\n\tFStaticMeshInstanceVisualizationDescHandle AddVisualDescWithISMComponent(const FStaticMeshInstanceVisualizationDesc& Desc, UInstancedStaticMeshComponent& ISMComponent);\n\n\t/**\n\t * Creates a dedicated visual type described by host Desc and ties given ISMComponents to it.\n\t * @return The index of the visual type\n\t */\n\tFStaticMeshInstanceVisualizationDescHandle AddVisualDescWithISMComponents(const FStaticMeshInstanceVisualizationDesc& Desc, TArrayView<TObjectPtr<UInstancedStaticMeshComponent>> ISMComponents);\n\n\t/**\n\t * Fetches FMassISMCSharedData indicated by DescriptionIndex, or nullptr if it's not a valid index\n\t */\n\tconst FMassISMCSharedData* GetISMCSharedDataForDescriptionIndex(const int32 DescriptionIndex) const;\n\n\t/**\n\t * Fetches FMassISMCSharedData indicated by an ISMC, or nullptr if the ISMC is not represented by any shared data.\n\t */\n\tconst FMassISMCSharedData* GetISMCSharedDataForInstancedStaticMesh(const UInstancedStaticMeshComponent* ISMC) const;\n\n\t/**\n\t * Removes the visualization data associated with the given ISM component. Note that this is safe to do only when\n\t * there are no entities relying on this data. No entity data patching will take place.\n\t * Note that the function will assert if there's more ISM components associated with given visualization. Also, in \n\t * that case RemoveVisualDescByIndex will be called under the hood. \n\t */\n\tUE_DEPRECATED(5.4, \"RemoveISMComponent has been deprecated in favor of RemoveVisualDescByIndex. Please use that instead.\")\n\tvoid RemoveISMComponent(UInstancedStaticMeshComponent& ISMComponent);\n\n\t/** \n\t * Removes all data associated with a given VisualizationIndex. Note that this is safe to do only if there are no\n\t * entities relying on this index. No entity data patching will take place.\n\t */\n\tvoid RemoveVisualDesc(const FStaticMeshInstanceVisualizationDescHandle VisualizationHandle);\n\n\t/** \n\t * @return the array of all the static mesh instance component information\n\t */\n\tFMassInstancedStaticMeshInfoArrayView GetMutableInstancedStaticMeshInfos();\n\n\t/** Mark render state of the static mesh instances dirty */\n\tvoid DirtyStaticMeshInstances();\n\n\t/** \n\t * Store the template actor uniquely and return an index to it \n\t * @param ActorClass is a template actor class we will need to spawn for an agent \n\t * @return The index of the template actor type\n\t */\n\tint16 FindOrAddTemplateActor(const TSubclassOf<AActor>& ActorClass);\n\n\t/** \n\t * Get or spawn an actor from the TemplateActorIndex\n\t * @param MassAgent is the handle to the associated mass agent\n\t * @param Transform where to create this actor\n\t * @param TemplateActorIndex is the index of the type fetched with FindOrAddTemplateActor()\n\t * @param SpawnRequestHandle [IN/OUT] IN: previously requested spawn OUT: newly requested spawn\n\t * @param Priority of this spawn request in comparison with the others, lower value means higher priority (optional)\n\t * @param ActorPreSpawnDelegate is an optional delegate called before the spawning of an actor\n\t * @param ActorPostSpawnDelegate is an optional delegate called once the actor is spawned\n\t * @return The spawned actor from the template actor type if ready\n\t */\n\tAActor* GetOrSpawnActorFromTemplate(const FMassEntityHandle MassAgent, const FTransform& Transform, const int16 TemplateActorIndex, FMassActorSpawnRequestHandle& InOutSpawnRequestHandle, float Priority = MAX_FLT,\n\t\tFMassActorPreSpawnDelegate ActorPreSpawnDelegate = FMassActorPreSpawnDelegate(), FMassActorPostSpawnDelegate ActorPostSpawnDelegate = FMassActorPostSpawnDelegate());\n\n\t/**\n\t * Cancel spawning request that is matching the TemplateActorIndex\n\t * @param MassAgent is the handle to the associated mass agent\n\t * @param TemplateActorIndex is the template type of the actor to release in case it was successfully spawned\n\t * @param SpawnRequestHandle [IN/OUT] previously requested spawn, gets invalidated as a result of this call.\n\t * @return True if spawning request was canceled\n\t */\n\tbool CancelSpawning(const FMassEntityHandle MassAgent, const int16 TemplateActorIndex, FMassActorSpawnRequestHandle & SpawnRequestHandle);\n\n\t/**\n\t * Release an actor that is matching the TemplateActorIndex\n\t * @param MassAgent is the handle to the associated mass agent\n\t * @param TemplateActorIndex is the template type of the actor to release in case it was successfully spawned\n\t * @param ActorToRelease is the actual actor to release if any\n\t * @param bImmediate means it needs to be done immediately and not queue for later\n\t * @return True if actor was released\n\t */\n\tbool ReleaseTemplateActor(const FMassEntityHandle MassAgent, const int16 TemplateActorIndex, AActor* ActorToRelease, bool bImmediate);\n\n\t/**\n\t * Release an actor or cancel its spawning if it is matching the TemplateActorIndex\n\t * @param MassAgent is the handle to the associated mass agent\n\t * @param TemplateActorIndex is the template type of the actor to release in case it was successfully spawned\n\t * @param ActorToRelease is the actual actor to release if any\n\t * @param SpawnRequestHandle [IN/OUT] previously requested spawn, gets invalidated as a result of this call.\n\t * @return True if actor was released or spawning request was canceled\n\t */\n\tbool ReleaseTemplateActorOrCancelSpawning(const FMassEntityHandle MassAgent, const int16 TemplateActorIndex, AActor* ActorToRelease, FMassActorSpawnRequestHandle& SpawnRequestHandle);\n\n\n\t/**\n\t * Compare if an actor matches the registered template actor\n\t * @param Actor to compare its class against the template\n\t * @param TemplateActorIndex is the template type of the actor to compare against\n\t * @return True if actor matches the template\n\t */\n\tbool DoesActorMatchTemplate(const AActor& Actor, const int16 TemplateActorIndex) const;\n\n\tTSubclassOf<AActor> GetTemplateActorClass(const int16 TemplateActorIndex);\n\n\tbool IsCollisionLoaded(const FName TargetGrid, const FTransform& Transform) const;\n\n\t/**\n\t * Responds to the FMassEntityTemplate getting destroyed, and releases reference to corresponding Actor in TemplateActors\n\t */\n\tvoid ReleaseTemplate(const TSubclassOf<AActor>& ActorClass);\n\n\t/**\n\t * Release all references to static meshes and template actors\n\t * Use with caution, all entities using this representation subsystem must be destroy otherwise they will point to invalid resources */\n\tvoid ReleaseAllResources();\n\n\tUMassActorSpawnerSubsystem* GetActorSpawnerSubsystem() const { return ActorSpawnerSubsystem; }\n\nprotected:\n\t// USubsystem BEGIN\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\tvirtual void Deinitialize() override;\n\t// USubsystem END\n\n\t/** Needed for batching the update of static mesh transform */\n\tvoid OnProcessingPhaseStarted(const float DeltaSeconds, const EMassProcessingPhase Phase) const;\n\n\tvoid OnMassAgentComponentEntityAssociated(const UMassAgentComponent& AgentComponent);\n\tvoid OnMassAgentComponentEntityDetaching(const UMassAgentComponent& AgentComponent);\n\n\tbool ReleaseTemplateActorInternal(const int16 TemplateActorIndex, AActor* ActorToRelease, bool bImmediate);\n\tbool CancelSpawningInternal(const int16 TemplateActorIndex, FMassActorSpawnRequestHandle& SpawnRequestHandle);\n\n\tstatic void AddReferencedObjects(UObject* InThis, FReferenceCollector& Collector);\n\nprotected:\n\n\tstruct FTemplateActorData\n\t{\n\t\tTSubclassOf<AActor> Actor;\n\t\tuint32 RefCount{0u};\n\t};\n\t\n\tstruct FTemplateActorEqualsPredicate\n\t{\n\t\tconst TSubclassOf<AActor>& ActorClass;\n\n\t\tFTemplateActorEqualsPredicate(const TSubclassOf<AActor>& ActorClass) : ActorClass(ActorClass) {}\n\n\t\tbool operator()(const FTemplateActorData& ActorData) const\n\t\t{\n\t\t\treturn ActorData.Actor == ActorClass;\n\t\t}\n\t};\n\n\t/** The array of all the template actors */\n\tTSparseArray<FTemplateActorData> TemplateActors;\n\tUE_MT_DECLARE_RW_ACCESS_DETECTOR(TemplateActorsMTAccessDetector);\n\n\t/** The component that handles all the static mesh instances */\n\tUPROPERTY(Transient)\n\tTObjectPtr<UMassVisualizationComponent> VisualizationComponent;\n\n\t/** The actor owning the above visualization component */\n\tUPROPERTY(Transient)\n\tTObjectPtr<AMassVisualizer> Visualizer;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<UMassActorSpawnerSubsystem> ActorSpawnerSubsystem;\n\n\tTSharedPtr<FMassEntityManager> EntityManager;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<UWorldPartitionSubsystem> WorldPartitionSubsystem;\n\n\t/** The time to wait before retrying a to spawn actor that failed */\n\tfloat RetryMovedDistanceSq = 1000000.0f;\n\n\t/** The distance a failed spawned actor needs to move before we retry */\n\tfloat RetryTimeInterval = 10.0f;\n\n\t/** Keeping track of all the mass agent this subsystem is responsible for spawning actors */\n\tTMap<FMassEntityHandle, int32> HandledMassAgents;\n};\n\ntemplate<>\nstruct TMassExternalSubsystemTraits<UMassRepresentationSubsystem> final\n{\n\tenum\n\t{\n\t\tGameThreadOnly = true\n\t};\n};\n",
      "lines": 235
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassRepresentationTypes.h",
      "extension": ".h",
      "size_bytes": 31182,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassLODTypes.h\"\n#include \"Engine/DataTable.h\"\n#include \"Misc/MTAccessDetector.h\"\n#include \"InstanceDataTypes.h\"\n#include \"Experimental/Containers/RobinHoodHashTable.h\"\n#include \"UObject/ObjectKey.h\"\n#include \"Components/InstancedStaticMeshComponent.h\"\n#include \"MassRepresentationTypes.generated.h\"\n\nclass UMaterialInterface;\nclass UStaticMesh;\nstruct FMassLODSignificanceRange;\nclass UMassVisualizationComponent;\n\nDECLARE_LOG_CATEGORY_EXTERN(LogMassRepresentation, Log, All);\n\nnamespace UE::Mass::ProcessorGroupNames\n{\n\tconst FName Representation = FName(TEXT(\"Representation\"));\n}\n\nusing FISMCSharedDataKey = TObjectKey<UInstancedStaticMeshComponent>;\n\nUENUM()\nenum class EMassRepresentationType : uint8\n{\n\tHighResSpawnedActor,\n\tLowResSpawnedActor,\n\tStaticMeshInstance,\n\tNone,\n};\n\nenum class EMassActorEnabledType : uint8\n{\n\tDisabled,\n\tLowRes,\n\tHighRes,\n};\n\nUSTRUCT()\nstruct MASSREPRESENTATION_API FMassStaticMeshInstanceVisualizationMeshDesc\n{\n\tGENERATED_BODY()\n\n\tFMassStaticMeshInstanceVisualizationMeshDesc();\n\t\n\t/** The static mesh visual representation */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tTObjectPtr<UStaticMesh> Mesh = nullptr;\n\n\t/**\n\t * Material overrides for the static mesh visual representation. \n\t * \n\t * Array indices correspond to material slot indices on the static mesh.\n\t */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tTArray<TObjectPtr<UMaterialInterface>> MaterialOverrides;\n\n\t/** The minimum inclusive LOD significance to start using this static mesh */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tfloat MinLODSignificance = float(EMassLOD::High);\n\n\t/** The maximum exclusive LOD significance to stop using this static mesh */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tfloat MaxLODSignificance = float(EMassLOD::Max);\n\n\t/** Controls whether the ISM can cast shadow or not */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tbool bCastShadows = false;\n\t\n\t/** Controls the mobility of the ISM */\n\tEComponentMobility::Type Mobility = EComponentMobility::Movable;\n\n\t/** InstancedStaticMeshComponent class to use to manage instances described by this struct instance */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tTSubclassOf<UInstancedStaticMeshComponent> ISMComponentClass;\n\n\tbool operator==(const FMassStaticMeshInstanceVisualizationMeshDesc& Other) const\n\t{\n\t\treturn Mesh == Other.Mesh && \n\t\t\tMaterialOverrides == Other.MaterialOverrides && \n\t\t\tFMath::IsNearlyEqual(MinLODSignificance, Other.MinLODSignificance, KINDA_SMALL_NUMBER) &&\n\t\t\tFMath::IsNearlyEqual(MaxLODSignificance, Other.MaxLODSignificance, KINDA_SMALL_NUMBER) &&\n\t\t\tbCastShadows == Other.bCastShadows && \n\t\t\tMobility == Other.Mobility;\n\t}\n\t\n\tfriend FORCEINLINE uint32 GetTypeHash(const FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc)\n\t{\n\t\tuint32 Hash = 0x0;\n\t\tHash = PointerHash(MeshDesc.Mesh, Hash);\n\t\tHash = HashCombine(GetTypeHash(MeshDesc.bCastShadows), Hash);\n\t\tHash = HashCombine(GetTypeHash(MeshDesc.Mobility), Hash);\n\t\tfor (UMaterialInterface* MaterialOverride : MeshDesc.MaterialOverrides)\n\t\t{\n\t\t\tif (MaterialOverride)\n\t\t\t{\n\t\t\t\tHash = PointerHash(MaterialOverride, Hash);\n\t\t\t}\n\t\t}\n\t\treturn Hash;\n\t}\n\n\t// convenience function for setting MinLODSinificance and MaxLODSinificance based on EMassLOD values\n\tvoid SetSignificanceRange(const EMassLOD::Type MinLOD, const EMassLOD::Type MaxLOD)\n\t{\n\t\tcheckSlow(MinLOD <= MaxLOD);\n\t\tMinLODSignificance = float(MinLOD);\n\t\tMaxLODSignificance = float(MaxLOD);\n\t}\n};\n\nUSTRUCT()\nstruct FStaticMeshInstanceVisualizationDesc : public FTableRowBase\n{\n\tGENERATED_BODY()\n\n\t/** \n\t * Mesh descriptions. These will be instanced together using the same transform for each, to \n\t * visualize the given agent.\n\t */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tTArray<FMassStaticMeshInstanceVisualizationMeshDesc> Meshes;\n\n\t/** Boolean to enable code to transform the static meshes if not align the mass agent transform */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tbool bUseTransformOffset = false;\n\n\t/** Transform to offset the static meshes if not align the mass agent transform */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\", meta=(EditCondition=\"bUseTransformOffset\"))\n\tFTransform TransformOffset;\n\n\tbool operator==(const FStaticMeshInstanceVisualizationDesc& Other) const\n\t{\n\t\treturn Meshes == Other.Meshes;\n\t}\n\n\tvoid Reset()\n\t{\n\t\tnew(this)FStaticMeshInstanceVisualizationDesc();\n\t}\n\n\t/** @return whether any of descriptions in Meshes is valid. This implies that empty Meshes will be treated as not valid.*/\n\tbool IsValid() const;\n};\n\n/** Handle for FStaticMeshInstanceVisualizationDesc's registered with UMassRepresentationSubsystem */\nUSTRUCT()\nstruct alignas(2) FStaticMeshInstanceVisualizationDescHandle\n{\n\tGENERATED_BODY()\n\n\tstatic constexpr uint16 InvalidIndex = TNumericLimits<uint16>::Max();\n\n\tFStaticMeshInstanceVisualizationDescHandle() = default;\n\n\texplicit FStaticMeshInstanceVisualizationDescHandle(uint16 InIndex)\n\t: Index(InIndex)\n\t{}\n\n\texplicit FStaticMeshInstanceVisualizationDescHandle(int32 InIndex) \n\t{\n\t\t// Handle special case INDEX_NONE = InvalidIndex\n\t\tif (InIndex == INDEX_NONE)\n\t\t{\n\t\t\tIndex = InvalidIndex;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcheckf(InIndex < static_cast<int32>(InvalidIndex), TEXT(\"Visualization description index InIndex %d is out of expected bounds (< %u)\"), InIndex, InvalidIndex);\n\t\t\tIndex = static_cast<uint16>(InIndex);\n\t\t}\n\t}\n\n\tFORCEINLINE int32 ToIndex() const\n\t{\n\t\treturn IsValid() ? Index : INDEX_NONE;\n\t}\n\n\tbool IsValid() const\n\t{\n\t\treturn Index != InvalidIndex;\n\t}\n\n\tbool operator==(const FStaticMeshInstanceVisualizationDescHandle& Other) const = default;\n\n\tUE_DEPRECATED(5.4, \"Referring to registered FStaticMeshInstanceVisualizationDesc's by raw int16 index has been deprecated. Please use strictly typed FStaticMeshInstanceVisualizationDescHandle instead.\")\n\toperator int16() const\n\t{\n\t\tif (!IsValid())\n\t\t{\n\t\t\treturn INDEX_NONE;\n\t\t}\n\t\treturn ensure(Index < TNumericLimits<int16>::Max()) ? static_cast<int16>(Index) : INDEX_NONE; \n\t}\n\nprivate:\n\n\tUPROPERTY()\n\tuint16 Index = InvalidIndex;\n\n\t// @todo: Add a version / serial number to protect against recycled handle reuse. Leaving this out for now to keep size down due to \n\t// prevalent use in FMassRepresentationFragment. Perhaps serial number could be formed from the referenced \n\t// FStaticMeshInstanceVisualizationDesc's hash.\n};\nstatic_assert(sizeof(FStaticMeshInstanceVisualizationDescHandle) == sizeof(uint16), \"FStaticMeshInstanceVisualizationDescHandle must be uint16 sized to ensure FMassRepresentationFragment memory isn't unexpectedly bloated\");\n\nclass UInstancedStaticMeshComponent;\n\n\nstruct MASSREPRESENTATION_API FMassISMCSharedData\n{\nPRAGMA_DISABLE_DEPRECATION_WARNINGS\n\tFMassISMCSharedData() \n\t\t: bRequiresExternalInstanceIDTracking(false)\n\t{\t\t\n\t}\n\n\texplicit FMassISMCSharedData(UInstancedStaticMeshComponent* InISMC, bool bInRequiresExternalInstanceIDTracking = false)\n\t\t: ISMC(InISMC), bRequiresExternalInstanceIDTracking(bInRequiresExternalInstanceIDTracking)\n\t{\n\t}\n\n\tFMassISMCSharedData(const FMassISMCSharedData& Other) = default;\n\tFMassISMCSharedData& operator=(const FMassISMCSharedData& Other) = default;\nPRAGMA_ENABLE_DEPRECATION_WARNINGS\n\n\tvoid SetISMComponent(UInstancedStaticMeshComponent& InISMC)\n\t{\n\t\tcheck(ISMC == nullptr && ISMComponentReferencesCount == 0);\n\t\tISMC = &InISMC;\n\t}\n\n\tUInstancedStaticMeshComponent* GetMutableISMComponent() { return ISMC; }\n\tconst UInstancedStaticMeshComponent* GetISMComponent() const { return ISMC; }\n\tint32 OnISMComponentReferenceStored() { return ++ISMComponentReferencesCount; }\n\tint32 OnISMComponentReferenceReleased() { ensure(ISMComponentReferencesCount >= 0); return --ISMComponentReferencesCount; }\n\n\tvoid ResetAccumulatedData()\n\t{\n\t\tUpdateInstanceIds.Reset();\n\t\tStaticMeshInstanceCustomFloats.Reset();\n\t\tStaticMeshInstanceTransforms.Reset();\n\t\tStaticMeshInstancePrevTransforms.Reset();\n\t\tRemoveInstanceIds.Reset();\n\t\tWriteIterator = 0;\n\t}\n\n\tvoid RemoveUpdatedInstanceIdsAtSwap(const int32 InstanceIDIndex)\n\t{\n\t\tUpdateInstanceIds.RemoveAtSwap(InstanceIDIndex, EAllowShrinking::No);\n\t\tStaticMeshInstanceTransforms.RemoveAtSwap(InstanceIDIndex, EAllowShrinking::No);\n\t\tStaticMeshInstancePrevTransforms.RemoveAtSwap(InstanceIDIndex, EAllowShrinking::No);\n\t\tif (StaticMeshInstanceCustomFloats.Num())\n\t\t{\n\t\t\tStaticMeshInstanceCustomFloats.RemoveAtSwap(InstanceIDIndex, EAllowShrinking::No);\n\t\t}\n\t}\n\n\tbool HasUpdatesToApply() const { return UpdateInstanceIds.Num() || RemoveInstanceIds.Num(); }\n\tTConstArrayView<FMassEntityHandle> GetUpdateInstanceIds() const { return UpdateInstanceIds; }\n\tTConstArrayView<FTransform> GetStaticMeshInstanceTransforms() const { return StaticMeshInstanceTransforms; }\n\t/** \n\t * this function is a flavor we need to interact with older engine API that's using TArray references. \n\t * Use GetStaticMeshInstanceTransforms instead whenever possible. \n\t */\n\tconst TArray<FTransform>& GetStaticMeshInstanceTransformsArray() const { return StaticMeshInstanceTransforms; }\n\tTConstArrayView<FTransform> GetStaticMeshInstancePrevTransforms() const { return StaticMeshInstancePrevTransforms; }\n\tTConstArrayView<FMassEntityHandle> GetRemoveInstanceIds() const { return RemoveInstanceIds; }\n\tTConstArrayView<float> GetStaticMeshInstanceCustomFloats() const { return StaticMeshInstanceCustomFloats; }\n\t\n\tbool RequiresExternalInstanceIDTracking() const { return bRequiresExternalInstanceIDTracking; }\n\n\tvoid Reset() \n\t{\n\t\t*this = FMassISMCSharedData();\n\t}\n\n\tusing FEntityToPrimitiveIdMap = Experimental::TRobinHoodHashMap<FMassEntityHandle, FPrimitiveInstanceId>;\n\n\tFEntityToPrimitiveIdMap& GetMutableEntityPrimitiveToIdMap() { return EntityHandleToPrimitiveIdMap; }\n\tconst FEntityToPrimitiveIdMap& GetEntityPrimitiveToIdMap() const { return EntityHandleToPrimitiveIdMap; }\n\n\tint16 GetComponentInstanceIdTouchCounter() const { return ComponentInstanceIdTouchCounter; }\n\nprotected:\n\tfriend FMassLODSignificanceRange;\n\tfriend UMassVisualizationComponent;\n\t/** Buffer holding current frame transforms for the static mesh instances, used to batch update the transforms */\n\tTArray<FMassEntityHandle> UpdateInstanceIds;\n\tTArray<FTransform> StaticMeshInstanceTransforms;\n\tTArray<FTransform> StaticMeshInstancePrevTransforms;\n\tTArray<FMassEntityHandle> RemoveInstanceIds;\n\n\t/** Buffer holding current frame custom floats for the static mesh instances, used to batch update the ISMs custom data */\n\tTArray<float> StaticMeshInstanceCustomFloats;\n\n\t// When initially adding to StaticMeshInstanceCustomFloats, can use the size as the write iterator, but on subsequent processors, we need to know where to start writing\n\tint32 WriteIterator = 0;\n\n\tUInstancedStaticMeshComponent* ISMC = nullptr;\n\tint32 ISMComponentReferencesCount = 0;\n\n\t/** \n\t * When set to true will result in MassVisualizationComponent manually perform Instance ID-related operations \n\t * instead of relying on ISMComponent's internal ID operations. \n\t * @note this mechanism has been added in preparation of changes to ISM component to change access to its internal \n\t *\tinstance ID logic. WIP as of Jun 17th 2023 \n\t */\n\tuint8 bRequiresExternalInstanceIDTracking : 1;\n\t\nprivate:\n\t/** Indicates that mutating changes, that can affect MassInstanceIdToComponentInstanceIdMap, have been performed.\n\t *\tCan be used to validate whether cached data stored in other placed needs to be re-cached. */\n\tuint16 ComponentInstanceIdTouchCounter = 0;\n\nprotected:\n\tFEntityToPrimitiveIdMap EntityHandleToPrimitiveIdMap;\n\n\tUE_DEPRECATED(5.4, \"RefCount is deprecated, use ISMComponentReferencesCount instead\")\n\tint32 RefCount = 0;\n\npublic:\n\tUE_DEPRECATED(5.4, \"StoreReference is deprecated, use OnISMComponentReferenceStored instead\")\n\tint32 StoreReference() { return OnISMComponentReferenceStored(); }\n\tUE_DEPRECATED(5.4, \"ReleaseReference is deprecated, use OnISMComponentReferenceReleased instead\")\n\tint32 ReleaseReference() { return OnISMComponentReferenceReleased(); }\n};\n\n\n/** \n * The container type hosting FMassISMCSharedData instances and supplying functionality of marking entries that require \n * instance-related operations (adding, removing). \n * \n * To get a FMassISMCSharedData instance to add operations to it call GetAndMarkDirty.\n * \n * Use FDirtyIterator to iterate over just the data that needs processing. \n * \n * @see UMassVisualizationComponent::EndVisualChanges for iteration\n * @see FMassLODSignificanceRange methods for performing dirtying operations\n */\nstruct FMassISMCSharedDataMap\n{\n\tstruct FDirtyIterator\n\t{\n\t\tfriend FMassISMCSharedDataMap;\n\t\texplicit FDirtyIterator(FMassISMCSharedDataMap& InContainer)\n\t\t\t: Container(InContainer), It(InContainer.GetDirtyArray())\n\t\t{\n\t\t\tif (It && It.GetValue() != bValueToCheck)\n\t\t\t{\n\t\t\t\t// will result in either setting IT to the first bInValue, or making bool(It) == false\n\t\t\t\t++(*this);\n\t\t\t}\n\t\t}\n\tpublic:\n\t\toperator bool() const { return bool(It); }\n\n\t\tFDirtyIterator& operator++()\n\t\t{\n\t\t\twhile (++It)\n\t\t\t{\n\t\t\t\tif (It.GetValue() == bValueToCheck)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\n\t\tFMassISMCSharedData& operator*() const\n\t\t{\n\t\t\treturn Container.GetAtIndex(It.GetIndex());\n\t\t}\n\n\t\tvoid ClearDirtyFlag()\n\t\t{\n\t\t\tIt.GetValue() = false;\n\t\t}\n\n\tprivate:\n\t\tFMassISMCSharedDataMap& Container;\n\t\tTBitArray<>::FIterator It;\n\t\tstatic constexpr bool bValueToCheck = true;\n\t};\n\n\tFMassISMCSharedData& GetAndMarkDirtyChecked(const FISMCSharedDataKey OwnerKey)\n\t{\n\t\tconst int32 DataIndex = Map[OwnerKey];\n\t\tDirtyData[DataIndex] = true;\n\t\treturn Data[DataIndex];\n\t}\n\n\tFMassISMCSharedData* GetAndMarkDirty(const FISMCSharedDataKey OwnerKey)\n\t{\n\t\tconst int32* DataIndex = Map.Find(OwnerKey);\n\t\tif (ensureMsgf(DataIndex, TEXT(\"%hs Failed to find OwnerKey %u\"), __FUNCTION__, *GetNameSafe(OwnerKey.ResolveObjectPtrEvenIfGarbage())))\n\t\t{\n\t\t\tDirtyData[*DataIndex] = true;\n\t\t\treturn &Data[*DataIndex];\n\t\t}\n\t\treturn nullptr;\n\t}\n\t\n\ttemplate<typename... TArgs>\n\tFMassISMCSharedData& FindOrAdd(const FISMCSharedDataKey OwnerKey, TArgs&&... InNewInstanceArgs)\n\t{\n\t\tconst int32* DataIndex = Map.Find(OwnerKey);\n\t\tif (DataIndex == nullptr)\n\t\t{\n\t\t\treturn Add(OwnerKey, Forward<TArgs>(InNewInstanceArgs)...);\n\t\t}\n\t\tcheck(Data.IsValidIndex(*DataIndex));\n\t\treturn Data[*DataIndex];\n\t}\n\n\tFMassISMCSharedData* Find(const FISMCSharedDataKey OwnerKey)\n\t{\n\t\tint32* DataIndex = Map.Find(OwnerKey);\n\t\treturn (DataIndex == nullptr || *DataIndex == INDEX_NONE) ? (FMassISMCSharedData*)nullptr : &Data[*DataIndex];\n\t}\n\n\ttemplate<typename... TArgs>\n\tFMassISMCSharedData& Add(const FISMCSharedDataKey OwnerKey, TArgs&&... InNewInstanceArgs)\n\t{\n\t\tconst int32 DataIndex = FreeIndices.Num() ? FreeIndices.Pop() : Data.Num();\n\t\tMap.Add(OwnerKey, DataIndex);\n\n\t\tif (DataIndex == Data.Num())\n\t\t{\n\t\t\tDirtyData.Add(false, DataIndex - DirtyData.Num() + 1);\n\t\t\tDirtyData[DataIndex] = true;\n\t\t\treturn Data.Add_GetRef(FMassISMCSharedData(Forward<TArgs>(InNewInstanceArgs)...));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDirtyData[DataIndex] = true;\n\t\t\tData[DataIndex] = FMassISMCSharedData(Forward<TArgs>(InNewInstanceArgs)...);\n\t\t\treturn Data[DataIndex];\n\t\t}\n\t}\n\n\tvoid Remove(const FISMCSharedDataKey OwnerKey)\n\t{\n\t\tint32 DataIndex = INDEX_NONE;\n\t\tif (ensure(Map.RemoveAndCopyValue(OwnerKey, DataIndex)))\n\t\t{\n\t\t\tDirtyData[DataIndex] = false;\n\t\t\tData[DataIndex].Reset();\n\t\t\tFreeIndices.Add(DataIndex);\n\t\t}\n\t}\n\n\tFMassISMCSharedData& GetAtIndex(const int32 DataIndex)\n\t{\n\t\treturn Data[DataIndex];\n\t}\n\t\n\tTBitArray<>& GetDirtyArray()\n\t{ \n\t\treturn DirtyData;\n\t}\n\n\t/** @return total number of entries in Data array. Note that some or all entries could be empty (i.e. already freed) */\n\tint32 Num() const\n\t{\n\t\treturn Data.Num();\n\t}\n\n\t/** @return number of non-empty entries in Data. */\n\tint32 NumValid() const\n\t{\n\t\treturn Data.Num() - FreeIndices.Num();\n\t}\n\n\tbool IsDirty(const int32 DataIndex) const\n\t{\n\t\treturn DirtyData[DataIndex];\n\t}\n\n\tbool IsEmpty() const\n\t{\n\t\treturn NumValid() == 0;\n\t}\n\n\tvoid Reset()\n\t{\n\t\t*this = FMassISMCSharedDataMap();\n\t}\n\n\tconst FMassISMCSharedData* GetDataForIndex(const int32 Index) const\n\t{\n\t\treturn Data.IsValidIndex(Index) ? &Data[Index] : nullptr;\n\t}\n\n\tconst FMassISMCSharedData* GetDataForKey(const FISMCSharedDataKey Key) const\n\t{\n\t\tconst int32* Index = Map.Find(Key);\n\t\treturn (Index && Data.IsValidIndex(*Index))\n\t\t\t? &Data[*Index]\n\t\t\t: nullptr;\n\t}\n\nprotected:\n\tTArray<FMassISMCSharedData> Data;\n\t/** Mapping from Owner (as FObjectKey) of data represented by FMassISMCSharedData to an index to Data */\n\tTMap<FISMCSharedDataKey, int32> Map;\n\t/** Indicates whether corresponding Data entry has any instance work assigned to it (instance addition or removal) */\n\tTBitArray<> DirtyData;\n\t/** Indices to Data that are available for reuse */\n\tTArray<int32> FreeIndices;\n\npublic:\n\tUE_DEPRECATED(5.5, \"Deprecated. Using hashes in Mass Visualization is being phased out. Use FISMCSharedDataKey instead.\")\n\tFMassISMCSharedData& GetAndMarkDirtyChecked(const uint32 Hash);\n\tUE_DEPRECATED(5.5, \"Deprecated. Using hashes in Mass Visualization is being phased out. Use FISMCSharedDataKey instead.\")\n\tFMassISMCSharedData* GetAndMarkDirty(const uint32 Hash);\t\n\ttemplate<typename... TArgs>\n\tUE_DEPRECATED(5.5, \"Deprecated. Using hashes in Mass Visualization is being phased out. Use FISMCSharedDataKey instead.\")\n\tFMassISMCSharedData& FindOrAdd(const uint32 Hash, TArgs&&... InNewInstanceArgs);\n\tUE_DEPRECATED(5.5, \"Deprecated. Using hashes in Mass Visualization is being phased out. Use FISMCSharedDataKey instead.\")\n\tFMassISMCSharedData* Find(const uint32 Hash);\n\ttemplate<typename... TArgs>\n\tUE_DEPRECATED(5.5, \"Deprecated. Using hashes in Mass Visualization is being phased out. Use FISMCSharedDataKey instead.\")\n\tFMassISMCSharedData& Add(const uint32 Hash, TArgs&&... InNewInstanceArgs);\n\tUE_DEPRECATED(5.5, \"Deprecated. Using hashes in Mass Visualization is being phased out. Use FISMCSharedDataKey instead.\")\n\tvoid Remove(const uint32 Hash);\n};\n\n\nUSTRUCT()\nstruct MASSREPRESENTATION_API FMassLODSignificanceRange\n{\n\tGENERATED_BODY()\npublic:\n\n\tvoid AddBatchedTransform(const FMassEntityHandle EntityHandle, const FTransform& Transform, const FTransform& PrevTransform, TConstArrayView<FISMCSharedDataKey> ExcludeStaticMeshRefs);\n\n\t// Adds the specified struct reinterpreted as custom floats to our custom data. Individual members of the specified struct should always fit into a float.\n\t// When adding any custom data, the custom data must be added for every instance.\n\ttemplate<typename InCustomDataType>\n\tvoid AddBatchedCustomData(InCustomDataType InCustomData, const TArray<FISMCSharedDataKey>& ExcludeStaticMeshRefs, int32 NumFloatsToPad = 0)\n\t{\n\t\tcheck(ISMCSharedDataPtr);\n\t\tstatic_assert((sizeof(InCustomDataType) % sizeof(float)) == 0, \"AddBatchedCustomData: InCustomDataType should have a total size multiple of sizeof(float), and have members that fit in a float's boundaries\");\n\t\tconst size_t StructSize = sizeof(InCustomDataType);\n\t\tconst size_t StructSizeInFloats = StructSize / sizeof(float);\n\t\tfor (int i = 0; i < StaticMeshRefs.Num(); i++)\n\t\t{\n\t\t\tif (ExcludeStaticMeshRefs.Contains(StaticMeshRefs[i]))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFMassISMCSharedData& SharedData = (*ISMCSharedDataPtr).GetAndMarkDirtyChecked(StaticMeshRefs[i]);\n\t\t\tconst int32 StartIndex = SharedData.StaticMeshInstanceCustomFloats.AddDefaulted(StructSizeInFloats + NumFloatsToPad);\n\t\t\tInCustomDataType* CustomData = reinterpret_cast<InCustomDataType*>(&SharedData.StaticMeshInstanceCustomFloats[StartIndex]);\n\t\t\t*CustomData = InCustomData;\n\t\t}\n\t}\n\n\tvoid AddBatchedCustomDataFloats(const TArray<float>& CustomFloats, const TArray<FISMCSharedDataKey>& ExcludeStaticMeshRefs);\n\n\t/** Single-instance version of AddBatchedCustomData when called to add entities (as opposed to modify existing ones).*/\n\tvoid AddInstance(const FMassEntityHandle EntityHandle, const FTransform& Transform);\n\n\tvoid RemoveInstance(const FMassEntityHandle EntityHandle);\n\n\tvoid WriteCustomDataFloatsAtStartIndex(int32 StaticMeshIndex, const TArrayView<float>& CustomFloats, const int32 FloatsPerInstance, const int32 StartIndex, const TArray<FISMCSharedDataKey>& ExcludeStaticMeshRefs);\n\n\t/** LOD Significance range */\n\tfloat MinSignificance;\n\tfloat MaxSignificance;\n\n\t/** The component handling these instances */\n\tTArray<FISMCSharedDataKey> StaticMeshRefs;\n\n\tFMassISMCSharedDataMap* ISMCSharedDataPtr = nullptr;\n\n\t//-----------------------------------------------------------------------------\n\t// DEPRECATED\n\t//-----------------------------------------------------------------------------\n\tUE_DEPRECATED(5.4, \"Deprecated in favor of new version taking FMassEntityHandle parameter instead of int32 to identify the entity. This deprecated function is now defunct.\")\n\tvoid AddBatchedTransform(const int32 InstanceId, const FTransform& Transform, const FTransform& PrevTransform, const TArray<uint32>& ExcludeStaticMeshRefs) {}\n\tUE_DEPRECATED(5.4, \"Deprecated in favor of new version taking FMassEntityHandle parameter instead of int32 to identify the entity. This deprecated function is now defunct.\")\n\tvoid AddInstance(const int32 InstanceId, const FTransform& Transform) {}\n\tUE_DEPRECATED(5.4, \"Deprecated in favor of new version taking FMassEntityHandle parameter instead of int32 to identify the entity. This deprecated function is now defunct.\")\n\tvoid RemoveInstance(const int32 InstanceId) {}\n\n};\n\nUSTRUCT()\nstruct MASSREPRESENTATION_API FMassInstancedStaticMeshInfo\n{\n\tGENERATED_BODY()\npublic:\n\n\tFMassInstancedStaticMeshInfo() = default;\n\n\texplicit FMassInstancedStaticMeshInfo(const FStaticMeshInstanceVisualizationDesc& InDesc)\n\t\t: Desc(InDesc)\n\t{\n\t}\n\n\t/** Clears out contents so that a given FMassInstancedStaticMeshInfo instance can be reused */\n\tvoid Reset();\n\n\tconst FStaticMeshInstanceVisualizationDesc& GetDesc() const\n\t{\n\t\treturn Desc;\n\t}\n\n\t/** Whether or not to transform the static meshes if not align the mass agent transform */\n\tbool ShouldUseTransformOffset() const { return Desc.bUseTransformOffset; }\n\tFTransform GetTransformOffset() const { return Desc.TransformOffset; }\n\n\tFORCEINLINE FMassLODSignificanceRange* GetLODSignificanceRange(float LODSignificance)\n\t{\n\t\tfor (FMassLODSignificanceRange& Range : LODSignificanceRanges)\n\t\t{\n\t\t\tif (LODSignificance >= Range.MinSignificance && LODSignificance < Range.MaxSignificance)\n\t\t\t{\n\t\t\t\treturn &Range;\n\t\t\t}\n\t\t}\n\t\treturn nullptr;\n\t}\n\n\tvoid AddBatchedTransform(const FMassEntityHandle EntityHandle, const FTransform& Transform, const FTransform& PrevTransform, const float LODSignificance, const float PrevLODSignificance = -1.0f)\n\t{\n\t\tif (FMassLODSignificanceRange* Range = GetLODSignificanceRange(LODSignificance))\n\t\t{\n\t\t\tRange->AddBatchedTransform(EntityHandle, Transform, PrevTransform, {});\n\t\t\tif(PrevLODSignificance >= 0.0f)\n\t\t\t{\n\t\t\t\tFMassLODSignificanceRange* PrevRange = GetLODSignificanceRange(PrevLODSignificance);\n\t\t\t\tif (ensureMsgf(PrevRange, TEXT(\"Couldn't find a valid LODSignificanceRange for PrevLODSignificance %f\"), PrevLODSignificance)\n\t\t\t\t\t&& PrevRange != Range)\n\t\t\t\t{\n\t\t\t\t\tPrevRange->AddBatchedTransform(EntityHandle, Transform, PrevTransform, Range->StaticMeshRefs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tFORCEINLINE void RemoveInstance(const FMassEntityHandle EntityHandle, const float LODSignificance)\n\t{\n\t\tif (FMassLODSignificanceRange* Range = GetLODSignificanceRange(LODSignificance))\n\t\t{\n\t\t\tRange->RemoveInstance(EntityHandle);\n\t\t}\n\t}\n\n\t// Adds the specified struct reinterpreted as custom floats to our custom data. Individual members of the specified struct should always fit into a float.\n\t// When adding any custom data, the custom data must be added for every instance.\n\ttemplate<typename InCustomDataType>\n\tvoid AddBatchedCustomData(InCustomDataType InCustomData, const float LODSignificance, const float PrevLODSignificance = -1.0f, int32 NumFloatsToPad = 0)\n\t{\n\t\tif (FMassLODSignificanceRange* Range = GetLODSignificanceRange(LODSignificance))\n\t\t{\n\t\t\tRange->AddBatchedCustomData(InCustomData, {}, NumFloatsToPad);\n\t\t\tif(PrevLODSignificance >= 0.0f)\n\t\t\t{\n\t\t\t\tFMassLODSignificanceRange* PrevRange = GetLODSignificanceRange(PrevLODSignificance);\n\t\t\t\tif (ensureMsgf(PrevRange, TEXT(\"Couldn't find a valid LODSignificanceRange for PrevLODSignificance %f\"), PrevLODSignificance)\n\t\t\t\t\t&& PrevRange != Range)\n\t\t\t\t{\n\t\t\t\t\tPrevRange->AddBatchedCustomData(InCustomData, Range->StaticMeshRefs, NumFloatsToPad);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tFORCEINLINE void AddBatchedCustomDataFloats(const TArray<float>& CustomFloats, const float LODSignificance, const float PrevLODSignificance = -1.0f)\n\t{\n\t\tif (FMassLODSignificanceRange* Range = GetLODSignificanceRange(LODSignificance))\n\t\t{\n\t\t\tRange->AddBatchedCustomDataFloats(CustomFloats, {});\n\t\t\tif(PrevLODSignificance >= 0.0f)\n\t\t\t{\n\t\t\t\tFMassLODSignificanceRange* PrevRange = GetLODSignificanceRange(PrevLODSignificance);\n\t\t\t\tif (ensureMsgf(PrevRange, TEXT(\"Couldn't find a valid LODSignificanceRange for PrevLODSignificance %f\"), PrevLODSignificance)\n\t\t\t\t\t&& PrevRange != Range)\n\t\t\t\t{\n\t\t\t\t\tPrevRange->AddBatchedCustomDataFloats(CustomFloats, Range->StaticMeshRefs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid WriteCustomDataFloatsAtStartIndex(int32 StaticMeshIndex, const TArrayView<float>& CustomFloats, const float LODSignificance, const int32 FloatsPerInstance, const int32 FloatStartIndex, const float PrevLODSignificance = -1.0f)\n\t{\n\t\tif (FMassLODSignificanceRange* Range = GetLODSignificanceRange(LODSignificance))\n\t\t{\n\t\t\tRange->WriteCustomDataFloatsAtStartIndex(StaticMeshIndex, CustomFloats, FloatsPerInstance, FloatStartIndex, {});\n\t\t\tif(PrevLODSignificance >= 0.0f)\n\t\t\t{\n\t\t\t\tFMassLODSignificanceRange* PrevRange = GetLODSignificanceRange(PrevLODSignificance);\n\t\t\t\tif (ensureMsgf(PrevRange, TEXT(\"Couldn't find a valid LODSignificanceRange for PrevLODSignificance %f\"), PrevLODSignificance)\n\t\t\t\t\t&& PrevRange != Range)\n\t\t\t\t{\n\t\t\t\t\tPrevRange->WriteCustomDataFloatsAtStartIndex(StaticMeshIndex, CustomFloats, FloatsPerInstance, FloatStartIndex, Range->StaticMeshRefs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid AddISMComponent(FMassISMCSharedData& SharedData)\n\t{\n\t\tif (ensure(SharedData.GetISMComponent()))\n\t\t{\n\t\t\tInstancedStaticMeshComponents.Add(SharedData.GetMutableISMComponent());\n\t\t\tSharedData.OnISMComponentReferenceStored();\n\t\t}\n\t}\n\n\tint32 GetLODSignificanceRangesNum() const { return LODSignificanceRanges.Num(); }\n\n\tbool IsValid() const\n\t{\n\t\treturn Desc.Meshes.Num() && InstancedStaticMeshComponents.Num() && LODSignificanceRanges.Num();\n\t}\n\nprotected:\n\n\t/** Destroy the visual instance */\n\tvoid ClearVisualInstance(UInstancedStaticMeshComponent& ISMComponent);\n\n\t/** Information about this static mesh which will represent all instances */\n\tUPROPERTY(VisibleAnywhere, Category = \"Mass/Debug\")\n\tFStaticMeshInstanceVisualizationDesc Desc;\n\n\t/** The components handling these instances */\n\tUPROPERTY(VisibleAnywhere, Category = \"Mass/Debug\")\n\tTArray<TObjectPtr<UInstancedStaticMeshComponent>> InstancedStaticMeshComponents;\n\n\tUPROPERTY(VisibleAnywhere, Category = \"Mass/Debug\")\n\tTArray<FMassLODSignificanceRange> LODSignificanceRanges;\n\n\tfriend class UMassVisualizationComponent;\n\n\t//-----------------------------------------------------------------------------\n\t// DEPRECATED\n\t//-----------------------------------------------------------------------------\n\tUE_DEPRECATED(5.5, \"Deprecated in flavor of the function taking the ISMComponent parameter. This version is not defunct\")\n\tvoid ClearVisualInstance(FMassISMCSharedDataMap& ISMCSharedData) {}\npublic:\n\tUE_DEPRECATED(5.4, \"Deprecated in flavor of new version taking FMassEntityHandle parameter instead of int32 to identify the entity. This deprecated function is now defunct.\")\n\tvoid AddBatchedTransform(const int32 InstanceId, const FTransform& Transform, const FTransform& PrevTransform, const float LODSignificance, const float PrevLODSignificance = -1.0f) {}\n\tUE_DEPRECATED(5.4, \"Deprecated in flavor of new version taking FMassEntityHandle parameter instead of int32 to identify the entity. This deprecated function is now defunct.\")\n\tvoid RemoveInstance(const int32 InstanceId, const float LODSignificance) {}\n};\n\n#if ENABLE_MT_DETECTOR\n\n#define MAKE_MASS_INSTANCED_STATIC_MESH_INFO_ARRAY_VIEW(ArrayView, AccessDetector) FMassInstancedStaticMeshInfoArrayView(ArrayView, AccessDetector)\nstruct FMassInstancedStaticMeshInfoArrayViewAccessDetector\n{\n\tFMassInstancedStaticMeshInfoArrayViewAccessDetector(TArrayView<FMassInstancedStaticMeshInfo> InInstancedStaticMeshInfos, const FRWRecursiveAccessDetector& InAccessDetector)\n\t\t: InstancedStaticMeshInfos(InInstancedStaticMeshInfos)\n\t\t, AccessDetector(&InAccessDetector)\n\t{\n\t\tUE_MT_ACQUIRE_WRITE_ACCESS(*AccessDetector);\n\t}\n\n\tFMassInstancedStaticMeshInfoArrayViewAccessDetector(FMassInstancedStaticMeshInfoArrayViewAccessDetector&& Other)\n\t\t: InstancedStaticMeshInfos(Other.InstancedStaticMeshInfos)\n\t\t, AccessDetector(Other.AccessDetector)\n\t{\n\t\tOther.AccessDetector = nullptr;\n\t}\n\tFMassInstancedStaticMeshInfoArrayViewAccessDetector(const FMassInstancedStaticMeshInfoArrayViewAccessDetector& Other) = delete;\n\tvoid operator=(const FMassInstancedStaticMeshInfoArrayViewAccessDetector& Other) = delete;\n\n\t~FMassInstancedStaticMeshInfoArrayViewAccessDetector()\n\t{\n\t\tif(AccessDetector)\n\t\t{\n\t\t\tUE_MT_RELEASE_WRITE_ACCESS(*AccessDetector);\n\t\t}\n\t}\n\n\tFORCEINLINE FMassInstancedStaticMeshInfo& operator[](int32 Index) const\n\t{\n\t\treturn InstancedStaticMeshInfos[Index];\n\t}\n\n\tbool IsValidIndex(const int32 Index) const\n\t{\n\t\treturn InstancedStaticMeshInfos.IsValidIndex(Index);\n\t}\n\nprivate:\n\tTArrayView<FMassInstancedStaticMeshInfo> InstancedStaticMeshInfos;\n\tconst FRWRecursiveAccessDetector* AccessDetector;\n};\n\ntypedef FMassInstancedStaticMeshInfoArrayViewAccessDetector FMassInstancedStaticMeshInfoArrayView;\n\n#else // ENABLE_MT_DETECTOR\n\n#define MAKE_MASS_INSTANCED_STATIC_MESH_INFO_ARRAY_VIEW(ArrayView, AccessDetector) ArrayView\n\ntypedef TArrayView<FMassInstancedStaticMeshInfo> FMassInstancedStaticMeshInfoArrayView;\n\n#endif // ENABLE_MT_DETECTOR\n\n//-----------------------------------------------------------------------------\n// DEPRECATED\n//-----------------------------------------------------------------------------\n\ntemplate<typename... TArgs>\nFMassISMCSharedData& FMassISMCSharedDataMap::FindOrAdd(const uint32 Hash, TArgs&&... InNewInstanceArgs)\n{\n\tstatic FMassISMCSharedData Dummy;\n\treturn Dummy;\n}\n\ntemplate<typename... TArgs>\nFMassISMCSharedData& FMassISMCSharedDataMap::Add(const uint32 Hash, TArgs&&... InNewInstanceArgs)\n{\n\tstatic FMassISMCSharedData Dummy;\n\treturn Dummy;\n}\n",
      "lines": 828
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassRepresentationUtils.h",
      "extension": ".h",
      "size_bytes": 2747,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassEntityManager.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassRepresentationTypes.h\"\n#include \"MassLODFragments.h\"\n\nstruct FMassCommandBuffer;\n\nnamespace UE::Mass::Representation\n{\n\ninline EMassVisibility GetVisibilityFromArchetype(const FMassExecutionContext& Context)\n{\n\tif (Context.DoesArchetypeHaveTag<FMassVisibilityCanBeSeenTag>())\n\t{\n\t\treturn EMassVisibility::CanBeSeen;\n\t}\n\tif (Context.DoesArchetypeHaveTag<FMassVisibilityCulledByFrustumTag>())\n\t{\n\t\treturn EMassVisibility::CulledByFrustum;\n\t}\n\tif (Context.DoesArchetypeHaveTag<FMassVisibilityCulledByDistanceTag>())\n\t{\n\t\treturn EMassVisibility::CulledByDistance;\n\t}\n\treturn EMassVisibility::Max;\n}\n\ntemplate <EMassVisibility Level>\nstruct TMassVisibilityTagForLevel\n{\n\ttypedef FMassTag FTag;\n};\n\ntemplate<>\nstruct TMassVisibilityTagForLevel<EMassVisibility::CanBeSeen>\n{\n\ttypedef FMassVisibilityCanBeSeenTag FTag;\n};\n\ntemplate<>\nstruct TMassVisibilityTagForLevel<EMassVisibility::CulledByFrustum>\n{\n\ttypedef FMassVisibilityCulledByFrustumTag FTag;\n};\n\ntemplate<>\nstruct TMassVisibilityTagForLevel<EMassVisibility::CulledByDistance>\n{\n\ttypedef FMassVisibilityCulledByDistanceTag FTag;\n};\n\ninline const UScriptStruct* GetTagFromVisibility(EMassVisibility Visibility)\n{\n\tswitch (Visibility)\n\t{\n\t\tcase EMassVisibility::CanBeSeen:\n\t\t\treturn TMassVisibilityTagForLevel<EMassVisibility::CanBeSeen>::FTag::StaticStruct();\n\t\tcase EMassVisibility::CulledByFrustum:\n\t\t\treturn TMassVisibilityTagForLevel<EMassVisibility::CulledByFrustum>::FTag::StaticStruct();\n\t\tcase EMassVisibility::CulledByDistance:\n\t\t\treturn TMassVisibilityTagForLevel<EMassVisibility::CulledByDistance>::FTag::StaticStruct();\n\t\tdefault:\n\t\t\tcheckf(false, TEXT(\"Unsupported visibility Type\"));\n\t\tcase EMassVisibility::Max:\n\t\t\treturn nullptr;\n\t}\n}\n\ninline bool IsVisibilityTagSet(const FMassExecutionContext& Context, EMassVisibility Visibility)\n{\n\tswitch (Visibility)\n\t{\n\t\tcase EMassVisibility::CanBeSeen:\n\t\t\treturn Context.DoesArchetypeHaveTag<FMassVisibilityCanBeSeenTag>();\n\t\tcase EMassVisibility::CulledByFrustum:\n\t\t\treturn Context.DoesArchetypeHaveTag<FMassVisibilityCulledByFrustumTag>();\n\t\tcase EMassVisibility::CulledByDistance:\n\t\t\treturn Context.DoesArchetypeHaveTag<FMassVisibilityCulledByDistanceTag>();\n\t\tdefault:\n\t\t\tcheckf(false, TEXT(\"Unsupported visibility Type\"));\n\t\tcase EMassVisibility::Max:\n\t\t\treturn false;\n\t}\n}\n\nvoid PushSwapTagsCommand(FMassCommandBuffer& CommandBuffer, const FMassEntityHandle Entity, const EMassVisibility PrevVisibility, const EMassVisibility NewVisibility);\n\n} // UE::Mass::Representation",
      "lines": 93
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassStationaryDistanceVisualizationTrait.h",
      "extension": ".h",
      "size_bytes": 730,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassDistanceVisualizationTrait.h\"\n#include \"MassStationaryDistanceVisualizationTrait.generated.h\"\n\n\nUCLASS()\nclass MASSREPRESENTATION_API UMassStationaryDistanceVisualizationTrait : public UMassDistanceVisualizationTrait\n{\n\tGENERATED_BODY()\npublic:\n\tUMassStationaryDistanceVisualizationTrait(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());\n\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\nprotected:\n#if WITH_EDITOR\n\tvirtual void PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent) override;\n#endif // WITH_EDITOR\n};\n",
      "lines": 22
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassStationaryISMRepresentationFragmentDestructor.h",
      "extension": ".h",
      "size_bytes": 694,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassObserverProcessor.h\"\n#include \"MassStationaryISMRepresentationFragmentDestructor.generated.h\"\n\n\n/** \n * This class is responsible for cleaning up ISM instances visualizing stationary entities\n */\nUCLASS()\nclass MASSREPRESENTATION_API UMassStationaryISMRepresentationFragmentDestructor : public UMassObserverProcessor\n{\n\tGENERATED_BODY()\npublic:\n\tUMassStationaryISMRepresentationFragmentDestructor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};\n",
      "lines": 24
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassStationaryISMSwitcherProcessor.h",
      "extension": ".h",
      "size_bytes": 1694,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassProcessor.h\"\n#include \"MassStationaryISMSwitcherProcessor.generated.h\"\n\n\nstruct FMassExecutionContext;\n\nnamespace UE::Mass::Signals\n{\n\tconst FName SwitchedToActor = FName(TEXT(\"SwitchedToActor\"));\n\tconst FName SwitchedToISM = FName(TEXT(\"SwitchedToISM\"));\n}\n\n/**\n * Tag required by UMassStationaryISMSwitcherProcessor to process given archetype. Removing the tag allows to support temporary\n * disabling of processing for individual entities of given archetype.\n */\nUSTRUCT()\nstruct MASSREPRESENTATION_API FMassStationaryISMSwitcherProcessorTag : public FMassTag\n{\n\tGENERATED_BODY();\n};\n\n/** \n * This processor's sole responsibility is to process all entities tagged with FMassStaticRepresentationTag\n * and check if they've switched to or away from EMassRepresentationType::StaticMeshInstance; and acordingly add or remove \n * the entity from the appropriate FMassInstancedStaticMeshInfoArrayView.\n */\nUCLASS()\nclass MASSREPRESENTATION_API UMassStationaryISMSwitcherProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassStationaryISMSwitcherProcessor(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());\n\n\tstatic void ProcessContext(FMassExecutionContext& Context);\n\nprotected:\n\t// UMassProcessor overrides begin\n\tvirtual void ConfigureQueries() override;\n\t// UMassProcessor overrides end\n\t// \n\t// UMassRepresentationProcessor overrides begin\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\t// UMassRepresentationProcessor overrides end\n\n\tFMassEntityQuery EntityQuery;\n};\n",
      "lines": 52
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassStationaryVisualizationTrait.h",
      "extension": ".h",
      "size_bytes": 690,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassVisualizationTrait.h\"\n#include \"MassStationaryVisualizationTrait.generated.h\"\n\n\nUCLASS()\nclass MASSREPRESENTATION_API UMassStationaryVisualizationTrait : public UMassVisualizationTrait\n{\n\tGENERATED_BODY()\npublic:\n\tUMassStationaryVisualizationTrait(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());\n\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\nprotected:\n#if WITH_EDITOR\n\tvirtual void PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent) override;\n#endif // WITH_EDITOR\n};\n",
      "lines": 22
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassUpdateISMProcessor.h",
      "extension": ".h",
      "size_bytes": 1531,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessor.h\"\n\n#include \"MassUpdateISMProcessor.generated.h\"\n\nclass UMassRepresentationSubsystem;\n\nstruct FMassInstancedStaticMeshInfo;\n\nUCLASS()\nclass MASSREPRESENTATION_API UMassUpdateISMProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassUpdateISMProcessor();\n\n\tstatic void UpdateISMTransform(FMassEntityHandle EntityHandle, FMassInstancedStaticMeshInfo& ISMInfo, const FTransform& Transform, const FTransform& PrevTransform, const float LODSignificance, const float PrevLODSignificance = -1.0f);\n\n\tUE_DEPRECATED(5.4, \"Deprecated in favor of new version taking FMassEntityHandle parameter instead of int32 to identify the entity. This deprecated function is now defunct.\")\n\tstatic void UpdateISMTransform(int32 EntityId, FMassInstancedStaticMeshInfo& ISMInfo, const FTransform& Transform, const FTransform& PrevTransform, const float LODSignificance, const float PrevLODSignificance = -1.0f) {}\n\n\nprotected:\n\n\t/** Configure the owned FMassEntityQuery instances to express processor's requirements */\n\tvirtual void ConfigureQueries() override;\n\n\t/**\n\t * Execution method for this processor\n\t * @param EntitySubsystem is the system to execute the lambdas on each entity chunk\n\t * @param Context is the execution context to be passed when executing the lambdas */\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};",
      "lines": 39
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassVisualizationComponent.h",
      "extension": ".h",
      "size_bytes": 7857,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassRepresentationTypes.h\"\n#include \"MassCommonTypes.h\"\n#include \"Components/ActorComponent.h\"\n#include \"MassRepresentationTypes.h\"\n#include \"Misc/MTAccessDetector.h\"\n\n#include \"MassVisualizationComponent.generated.h\"\n\n\nclass UInstancedStaticMeshComponent;\n\n/** \n * This component handles all the static mesh instances for a MassRepresentationProcessor and is an actor component off a MassVisualizer actor.\n * Meant to be created at runtime and owned by an MassVisualizer actor. Will ensure if placed on a different type of actor. \n */\nUCLASS()\nclass MASSREPRESENTATION_API UMassVisualizationComponent : public UActorComponent\n{\n\tGENERATED_BODY()\npublic:\n\n\t/** \n\t * Get the index of the visual type, will add a new one if does not exist\n\t * @param Desc is the information for the visual that will be instantiated later via AddVisualInstance()\n\t * @return The index of the visual type \n\t */\n\tFStaticMeshInstanceVisualizationDescHandle FindOrAddVisualDesc(const FStaticMeshInstanceVisualizationDesc& Desc);\n\n\t/** \n\t * Creates a dedicated visual type described by host Desc and ties ISMComponent to it.\n\t * @note this is a helper function for a common \"single ISMComponent\" case. Calls AddVisualDescWithISMComponents under the hood.\n\t * @return The index of the visual type \n\t */\n\tFStaticMeshInstanceVisualizationDescHandle AddVisualDescWithISMComponent(const FStaticMeshInstanceVisualizationDesc& Desc, UInstancedStaticMeshComponent& ISMComponent);\n\n\t/**\n\t * Creates a dedicated visual type described by host Desc and ties given ISMComponents to it.\n\t * @return The index of the visual type\n\t */\n\tFStaticMeshInstanceVisualizationDescHandle AddVisualDescWithISMComponents(const FStaticMeshInstanceVisualizationDesc& Desc, TArrayView<TObjectPtr<UInstancedStaticMeshComponent>> ISMComponents);\n\n\t/**\n\t * Fetches FMassISMCSharedData indicated by DescriptionIndex, or nullptr if it's not a valid index\n\t */\n\tconst FMassISMCSharedData* GetISMCSharedDataForDescriptionIndex(const int32 DescriptionIndex) const;\n\n\t/**\n\t * Fetches FMassISMCSharedData indicated by an ISMC, or nullptr if the ISMC is not represented by any shared data.\n\t */\n\tconst FMassISMCSharedData* GetISMCSharedDataForInstancedStaticMesh(const UInstancedStaticMeshComponent* ISMC) const;\n\n\t/** \n\t * Removes all the visualization data associated with the given ISM component. The function resolves the VisualizationIndex\n\t * associated with the given ISMComponent and calls RemoveVisualDescByIndex which will remove data on all ISMComponents\n\t * associated with the index. Note that this is safe to do only when there are no entities relying on this data. \n\t * No entity data patching will take place. \n\t */\n\tUE_DEPRECATED(5.4, \"RemoveISMComponent has been deprecated in favor of RemoveVisualDesc. Please use that instead.\")\n\tvoid RemoveISMComponent(UInstancedStaticMeshComponent& ISMComponent);\n\n\t/**\n\t * Removes all data associated with a given VisualizationIndex. Note that this is safe to do only if there are no\n\t * entities relying on this index. No entity data patching will take place.\n\t */\n\tUE_DEPRECATED(5.4, \"RemoveVisualDescByIndex has been deprecated in favor of RemoveVisualDesc. Please use that instead.\")\n\tvoid RemoveVisualDescByIndex(const int32 VisualizationIndex);\n\n\t/**\n\t * Removes all data associated with a given VisualizationIndex. Note that this is safe to do only if there are no\n\t * entities relying on this index. No entity data patching will take place.\n\t */\n\tvoid RemoveVisualDesc(const FStaticMeshInstanceVisualizationDescHandle VisualizationHandle);\n\n\t/** Get the array of all visual instance informations */\n\tFMassInstancedStaticMeshInfoArrayView GetMutableVisualInfos()\n\t{\n\t\tFMassInstancedStaticMeshInfoArrayView View = MAKE_MASS_INSTANCED_STATIC_MESH_INFO_ARRAY_VIEW(MakeArrayView(InstancedStaticMeshInfos), InstancedStaticMeshInfosDetector);\n\t\treturn MoveTemp(View);\n\t}\n\n\t/** Destroy all visual instances */\n \tvoid ClearAllVisualInstances();\n\n\t/** Dirty render state on all static mesh components */\n \tvoid DirtyVisuals();\n\n\t/** Signal the beginning of the static mesh instance changes, used to prepare the batching update of the static mesh instance transforms*/\n\tvoid BeginVisualChanges();\n\n\t/** Signal the end of the static mesh instance changes, used to batch apply the transforms on the static mesh instances*/\n\tvoid EndVisualChanges();\n\nprotected:\n\t/**\n\t * Process all removed IDs in FMassISMCSharedData and apply to the ISM component.\n\t */\n\tvoid ProcessRemoves(UInstancedStaticMeshComponent& ISMComponent, FMassISMCSharedData& SharedData, bool bUpdateNavigation = true);\n\t\n\t/** \n\t * Applies changes accumulated in SharedData while manually updating the Instance ID mapping. This approach is done in preparation \n\t * to upcoming ISM changes to keep the mapping management more secure (by making mapping private and fully component-owned).\n\t */\n\tvoid HandleChangesWithExternalIDTracking(UInstancedStaticMeshComponent& ISMComponent, FMassISMCSharedData& SharedData);\n\n\t/** Recreate all the static mesh components from the InstancedStaticMeshInfos */\n\tvoid ConstructStaticMeshComponents();\n\n\t/** Overridden to make sure this component is only added to a MassVisualizer actor */\n\tvirtual void PostInitProperties() override;\n\n\t/**\n\t * Creates LODSignificance ranges for all the meshes indicated by Info\n\t * @param ForcedStaticMeshRefKeys if not empty will be used when adding individual FMassStaticMeshInstanceVisualizationMeshDesc\n\t *\tinstances to LOD significance ranges.\n\t */\t\n\tvoid BuildLODSignificanceForInfo(FMassInstancedStaticMeshInfo& Info, TConstArrayView<UInstancedStaticMeshComponent*> StaticMeshRefKeys);\n\n\t/** Either adds an element to InstancedStaticMeshInfos or reuses an existing entry based on InstancedStaticMeshInfosFreeIndices*/\n\tFStaticMeshInstanceVisualizationDescHandle AddInstancedStaticMeshInfo(const FStaticMeshInstanceVisualizationDesc& Desc);\n\n\t/** The information of all the instanced static meshes. Make sure to use AddInstancedStaticMeshInfo to add elements to it */\n\tUPROPERTY(Transient)\n\tTArray<FMassInstancedStaticMeshInfo> InstancedStaticMeshInfos;\n\tUE_MT_DECLARE_RW_RECURSIVE_ACCESS_DETECTOR(InstancedStaticMeshInfosDetector);\n\n\t/** Indices to InstancedStaticMeshInfos that have been released and can be reused */\n\tTArray<FStaticMeshInstanceVisualizationDescHandle> InstancedStaticMeshInfosFreeIndices;\n\n\t/** Mapping from ISMComponent (indicated by FISMCSharedDataKey) to corresponding VisualDescHandle */\n\tTMap<FISMCSharedDataKey, FStaticMeshInstanceVisualizationDescHandle> ISMComponentMap;\n\n\tFMassISMCSharedDataMap ISMCSharedData;\n\n\t/** \n\t * Mapping FMassStaticMeshInstanceVisualizationMeshDesc hash to FMassISMCSharedData entries for all FMassStaticMeshInstanceVisualizationMeshDesc\n\t * that didn't come with ISMC explicitly provided. Used only for initialization.\n\t * Note that FMassStaticMeshInstanceVisualizationMeshDesc that were added with ISMComponents provided directly\n\t * (via AddVisualDescWithISMComponents call) will never make it to this map.\n\t */\n\tTMap<uint32, FISMCSharedDataKey> MeshDescToISMCMap;\n\n\t/** Indicies to InstancedStaticMeshInfos that need their SMComponent constructed */\n\tTArray<FStaticMeshInstanceVisualizationDescHandle> InstancedSMComponentsRequiringConstructing;\n\n\tUE_DEPRECATED(5.4, \"This flavor of BuildLODSignificanceForInfo is no longer supported and is defunct.\")\n\tvoid BuildLODSignificanceForInfo(FMassInstancedStaticMeshInfo& Info, const uint32 ForcedStaticMeshRefKey){}\n\n\tUE_DEPRECATED(5.5, \"This flavor of BuildLODSignificanceForInfo is no longer supported and is defunct.\")\n\tvoid BuildLODSignificanceForInfo(FMassInstancedStaticMeshInfo& Info) {}\n};\n",
      "lines": 154
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassVisualizationLODProcessor.h",
      "extension": ".h",
      "size_bytes": 1766,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassCommonFragments.h\"\n#include \"MassRepresentationFragments.h\"\n#include \"MassProcessor.h\"\n#include \"MassLODCalculator.h\"\n\n#include \"MassVisualizationLODProcessor.generated.h\"\n\n\n/** \n * Tag required by Visualization LOD Processor to update LOD information. Removing the tag allows to support temporary \n * disabling of processing for individual entities.\n */\nUSTRUCT()\nstruct MASSREPRESENTATION_API FMassVisualizationLODProcessorTag : public FMassTag\n{\n\tGENERATED_BODY();\n};\n\nUCLASS()\nclass MASSREPRESENTATION_API UMassVisualizationLODProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassVisualizationLODProcessor();\n\nprotected:\n\n\t/** Configure the owned FMassEntityQuery instances to express processor's requirements */\n\tvirtual void ConfigureQueries() override;\n\n\t/** \n\t * Execution method for this processor \n\t * @param EntitySubsystem is the system to execute the lambdas on each entity chunk\n\t * @param Context is the execution context to be passed when executing the lambdas\n\t */\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\t\n\t/**\n\t * Forces Off LOD on all calculation\n\t * @param bForce to whether force or not Off LOD\n\t */\n\tvoid ForceOffLOD(bool bForce) { bForceOFFLOD = bForce; }\n\nprotected:\n\tFMassEntityQuery CloseEntityQuery;\n\tFMassEntityQuery CloseEntityAdjustDistanceQuery;\n\tFMassEntityQuery FarEntityQuery;\n\tFMassEntityQuery DebugEntityQuery;\n\n\tbool bForceOFFLOD = false;\n\n\tUPROPERTY(Transient)\n\tTObjectPtr<const UScriptStruct> FilterTag = nullptr;\n\n\tUPROPERTY(config, EditDefaultsOnly, Category = \"Mass\")\n\tbool bDoAdjustmentFromCount = true;\n};",
      "lines": 62
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassVisualizationTrait.h",
      "extension": ".h",
      "size_bytes": 3672,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassEntityTraitBase.h\"\n#include \"MassRepresentationTypes.h\"\n#include \"MassRepresentationFragments.h\"\n#include \"GameFramework/Actor.h\"\n\n#include \"MassVisualizationTrait.generated.h\"\n\nclass UMassRepresentationSubsystem;\nclass UMassRepresentationActorManagement;\nclass UMassProcessor;\n\n/** This class has been soft-deprecated. Use MassStationaryVisualizationTrait or MassMovableVisualizationTrait */\nUCLASS(meta=(DisplayName=\"DEPRECATED Visualization\"))\nclass MASSREPRESENTATION_API UMassVisualizationTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\npublic:\n\tUMassVisualizationTrait();\n\n\t/** Instanced static mesh information for this agent */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tmutable FStaticMeshInstanceVisualizationDesc StaticMeshInstanceDesc;\n\n\t/** Actor class of this agent when spawned in high resolution*/\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tTSubclassOf<AActor> HighResTemplateActor;\n\n\t/** Actor class of this agent when spawned in low resolution*/\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tTSubclassOf<AActor> LowResTemplateActor;\n\n\t/** Allow subclasses to override the representation subsystem to use */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\", meta = (EditCondition = \"bCanModifyRepresentationSubsystemClass\"))\n\tTSubclassOf<UMassRepresentationSubsystem> RepresentationSubsystemClass;\n\n\t/** Configuration parameters for the representation processor */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tFMassRepresentationParameters Params;\n\n\t/** Configuration parameters for the visualization LOD processor */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tFMassVisualizationLODParameters LODParams;\n\n\t/** If set to true will result in the visualization-related fragments being added to server-size entities as well.\n\t *  By default only the clients require visualization fragments */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Visual\")\n\tbool bAllowServerSideVisualization = false;\n\n#if WITH_EDITORONLY_DATA\n\t/** the property is marked like this to ensure it won't show up in UI */\n\tUPROPERTY(EditDefaultsOnly, Category = \"Mass|Visual\")\n\tbool bCanModifyRepresentationSubsystemClass = true;\n#endif // WITH_EDITORONLY_DATA\n\nprotected:\n\t/** \n\t * Controls whether StaticMeshInstanceDesc gets registered via FindOrAddStaticMeshDesc call. Setting it to `false` \n\t * can be useful for subclasses to avoid needlessly creating visualization data in RepresentationSubsystem, \n\t * data that will never be used.\n\t */\n\tbool bRegisterStaticMeshDesc = true;\n\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\tvirtual bool ValidateTemplate(const FMassEntityTemplateBuildContext& BuildContext, const UWorld& World, FAdditionalTraitRequirements& OutTraitRequirements) const override;\n\n\t/** \n\t * Tests whether StaticMeshInstanceDesc is valid and if not cleans up InOutParamss of EMassRepresentationType::StaticMeshInstance\n\t * occurrences. \n\t * @param bStaticMeshDeterminedInvalid if StaticMeshInstanceDesc has already been determined invalid then bStaticMeshDeterminedInvalid\n\t *\tcan be set to `true` to skip the redundant check.\n\t */\n\tvirtual void SanitizeParams(FMassRepresentationParameters& InOutParams, const bool bStaticMeshDeterminedInvalid = false) const;\n\n\tvirtual void Serialize(FArchive& Ar) override;\n#if WITH_EDITOR\n\tvirtual void PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent) override;\n\tvirtual bool ValidateParams() const;\n#endif // WITH_EDITOR\n};\n",
      "lines": 83
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Public\\MassVisualizer.h",
      "extension": ".h",
      "size_bytes": 831,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"GameFramework/Actor.h\"\n#include \"MassVisualizer.generated.h\"\n\n\nclass UMassVisualizationComponent;\n\n/**\n * Actor holding the mass visual component responsible to handle the representation of the mass agent as the static mesh instances \n * There may be a separate instance of these for different types of Agents (Cars, NPC's etc)\n */\nUCLASS(NotPlaceable, Transient)\nclass MASSREPRESENTATION_API AMassVisualizer : public AActor\n{\n\tGENERATED_BODY()\npublic:\n\tAMassVisualizer();\n\n\t/** Visualization component is guaranteed to exist if this class is created */\n\tUMassVisualizationComponent& GetVisualizationComponent() const { return *VisComponent; }\n\nprotected:\n\tUPROPERTY()\n\tTObjectPtr<UMassVisualizationComponent> VisComponent;\n};\n",
      "lines": 28
    },
    {
      "file_path": "MassGameplay\\MassSignals\\Public\\IMassSignalsModule.h",
      "extension": ".h",
      "size_bytes": 1118,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n * The public interface to this module.  In most cases, this interface is only public to sibling modules \n * within this plugin.\n */\nclass IMassSignalsModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t * Singleton-like access to this module's interface.  This is just for convenience!\n\t * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t *\n\t * @return Returns singleton instance, loading the module on demand if needed\n\t */\n\tstatic inline IMassSignalsModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassSignalsModule>( \"MassSignals\" );\n\t}\n\n\t/**\n\t * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t *\n\t * @return True if the module is loaded and ready to use\n\t */\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassSignals\" );\n\t}\n};\n\n",
      "lines": 40
    },
    {
      "file_path": "MassGameplay\\MassSignals\\Public\\MassSignalProcessorBase.h",
      "extension": ".h",
      "size_bytes": 3917,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessor.h\"\n#include \"MassEntityManager.h\"\n#include \"MassSignalTypes.h\"\n#include \"Containers/StaticArray.h\"\n#include \"Misc/SpinLock.h\"\n#include \"MassSignalProcessorBase.generated.h\"\n\nclass UMassSignalSubsystem;\n\n/** \n * Processor for executing signals on each targeted entities\n * The derived classes only need to implement the method SignalEntities to actually received the raised signals for the entities they subscribed to \n */\nUCLASS(abstract)\nclass MASSSIGNALS_API UMassSignalProcessorBase : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassSignalProcessorBase(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());\n\nprotected:\n\tvirtual void BeginDestroy() override;\n\n\t/** Configure the owned FMassEntityQuery instances to express processor queries requirements */\n\tvirtual void ConfigureQueries() override {}\n\n\t/**\n\t * Actual method that derived class needs to implement to act on a signal that is raised for that frame\n\t * @param EntitySubsystem is the system to execute the lambdas on each entity chunk\n\t * @param Context is the execution context to be passed when executing the lambdas\n\t * @param EntitySignals Look up to retrieve for each entities their raised signal via GetSignalsForEntity\n\t */\n\t virtual void SignalEntities(FMassEntityManager& EntityManager, FMassExecutionContext& Context, FMassSignalNameLookup& EntitySignals) PURE_VIRTUAL(UMassSignalProcessorBase::SignalEntities, );\n\n\t/**\n\t * Callback that is being called when new signal is raised\n\t * @param SignalName is the name of the signal being raised\n\t * @param Entities are the targeted entities for this signal\n\t */\n\t virtual void OnSignalReceived(FName SignalName, TConstArrayView<FMassEntityHandle> Entities);\n\n\t/**\n\t * Execution method for this processor\n\t * @param EntitySubsystem is the system to execute the lambdas on each entity chunk\n\t * @param Context is the execution context to be passed when executing the lambdas\n\t */\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\t/** \n\t * We don't want signaling processors to be pruned by default, since that can mess up signal processing \n\t * just after processor's creation (might miss some signals initially).\n\t */\n\tvirtual bool ShouldAllowQueryBasedPruning(const bool bRuntimeMode = true) const override { return false; }\n\n\n\t/**\n\t * To receive notification about a particular signal, you need to subscribe to it.\n\t * @param SignalName is the name of the signal to receive notification about\n\t */\n\tvoid SubscribeToSignal(UMassSignalSubsystem& SignalSubsystem, const FName SignalName);\n\n\tFMassEntityQuery EntityQuery;\n\nprivate:\n\n\t/** Stores a range of indices in the SignaledEntities TArray of Entities and the associated signal name */\n\tstruct FEntitySignalRange\n\t{\n\t\tFName SignalName;\n\t\tint32 Begin = 0;\n\t\tint32 End = 0;\n\t\tbool bProcessed = false;\n\t};\n\n\tstruct FFrameReceivedSignals\n\t{\n\t\t/** Received signals are double buffered as we can receive new one while processing them */\n\t\tTArray<FEntitySignalRange> ReceivedSignalRanges;\n\n\t\t/** the list of all signaled entities, can contain duplicates */\n\t\tTArray<FMassEntityHandle> SignaledEntities;\n\t};\n\n\tstatic constexpr int BuffersCount = 2;\n\n\t/** Double buffer frame received signal as we can receive new signals as we are processing them */\n\tTStaticArray<FFrameReceivedSignals, BuffersCount> FrameReceivedSignals;\n\t\n\t/** Current frame buffer index of FrameReceivedSignals */\n\tint32 CurrentFrameBufferIndex = 0;\n\n\t/** Lookup used to store and retrieve signals per entity, only used during processing */\n\tFMassSignalNameLookup SignalNameLookup;\n\n\t/** List of all the registered signal names*/\n\tTArray<FName> RegisteredSignals;\n\n\tUE::FSpinLock ReceivedSignalLock;\n};\n\n",
      "lines": 105
    },
    {
      "file_path": "MassGameplay\\MassSignals\\Public\\MassSignalSubsystem.h",
      "extension": ".h",
      "size_bytes": 5009,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityManager.h\"\n#include \"MassSubsystemBase.h\"\n#include \"MassSignalSubsystem.generated.h\"\n\nnamespace UE::MassSignal \n{\n\tDECLARE_MULTICAST_DELEGATE_TwoParams(FSignalDelegate, FName /*SignalName*/, TConstArrayView<FMassEntityHandle> /*Entities*/);\n} // UE::MassSignal\n\n/**\n* A subsystem for handling Signals in Mass\n*/\nUCLASS()\nclass MASSSIGNALS_API UMassSignalSubsystem : public UMassTickableSubsystemBase\n{\n\tGENERATED_BODY()\n\t\npublic:\n\n\t/** \n\t * Retrieve the delegate dispatcher from the signal name\n\t * @param SignalName is the name of the signal to get the delegate dispatcher from\n\t */\n\tUE::MassSignal::FSignalDelegate& GetSignalDelegateByName(FName SignalName)\n\t{\n\t\treturn NamedSignals.FindOrAdd(SignalName);\n\t}\n\n\t/**\n\t * Inform a single entity of a signal being raised\n\t * @param SignalName is the name of the signal raised\n\t * @param Entity entity that should be informed that signal 'SignalName' was raised\n\t */\n\tvoid SignalEntity(FName SignalName, const FMassEntityHandle Entity);\n\n\t/**\n\t * Inform multiple entities of a signal being raised\n\t * @param SignalName is the name of the signal raised\n\t * @param Entities list of entities that should be informed that signal 'SignalName' was raised\n\t */\n\tvoid SignalEntities(FName SignalName, TConstArrayView<FMassEntityHandle> Entities);\n\n\t/**\n\t * Inform a single entity of a signal being raised in a certain amount of seconds\n\t * @param SignalName is the name of the signal raised\n\t * @param Entity entity that should be informed that signal 'SignalName' was raised\n\t * @param DelayInSeconds is the amount of time before signaling the entity\n\t */\n\tvoid DelaySignalEntity(FName SignalName, const FMassEntityHandle Entity, const float DelayInSeconds);\n\n \t/**\n\t * Inform multiple entities of a signal being raised in a certain amount of seconds\n\t * @param SignalName is the name of the signal raised\n\t * @param Entities being informed of the raised signal\n\t * @param DelayInSeconds is the amount of time before signaling the entities\n\t */\n\tvoid DelaySignalEntities(FName SignalName, TConstArrayView<FMassEntityHandle> Entities, const float DelayInSeconds);\n\n\t/**\n\t * Inform single entity of a signal being raised asynchronously using the Mass Command Buffer\n\t * @param Context is the Entity System execution context to push the async command\n\t * @param SignalName is the name of the signal raised\n\t * @param Entity entity that should be informed that signal 'SignalName' was raised\n\t */\n\tvoid SignalEntityDeferred(FMassExecutionContext& Context, FName SignalName, const FMassEntityHandle Entity);\n\n\t/**\n\t * Inform multiple entities of a signal being raised asynchronously using the Mass Command Buffer\n\t * @param Context is the Entity System execution context to push the async command\n\t * @param SignalName is the name of the signal raised\n\t * @param Entities list of entities that should be informed that signal 'SignalName' was raised\n\t */\n\tvoid SignalEntitiesDeferred(FMassExecutionContext& Context, FName SignalName, TConstArrayView<FMassEntityHandle> Entities);\n\n \t/**\n\t * Inform single entity of a signal being raised asynchronously using the Mass Command Buffer\n\t * @param Context is the Entity System execution context to push the async command\n\t * @param SignalName is the name of the signal raised\n\t * @param Entity entity that should be informed that signal 'SignalName' was raised\n\t * @param DelayInSeconds is the amount of time before signaling the entities\n\t */\n\tvoid DelaySignalEntityDeferred(FMassExecutionContext& Context, FName SignalName, const FMassEntityHandle Entity, const float DelayInSeconds);\n\n \t/**\n\t * Inform multiple entities of a signal being raised asynchronously using the Mass Command Buffer\n\t * @param Context is the Entity System execution context to push the async command\n\t * @param SignalName is the name of the signal raised\n\t * @param Entities being informed of that signal was raised\n\t * @param DelayInSeconds is the amount of time before signaling the entities\n\t */\n\tvoid DelaySignalEntitiesDeferred(FMassExecutionContext& Context, FName SignalName, TConstArrayView<FMassEntityHandle> Entities, const float DelayInSeconds);\n\nprotected:\n\t// USubsystem implementation Begin\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\tvirtual void Deinitialize() override;\n\t// USubsystem implementation End\t\n\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual TStatId GetStatId() const override;\n\n\tTMap<FName, UE::MassSignal::FSignalDelegate> NamedSignals;\n\n\tstruct FDelayedSignal\n\t{\n\t\tFName SignalName;\n\t\tTArray<FMassEntityHandle> Entities;\n\t\tdouble TargetTimestamp;\n\t};\n\n\tTArray<FDelayedSignal> DelayedSignals;\n\n\tUPROPERTY(transient)\n\tTObjectPtr<UWorld> CachedWorld;\n};\n\ntemplate<>\nstruct TMassExternalSubsystemTraits<UMassSignalSubsystem> final\n{\n\tenum\n\t{\n\t\tGameThreadOnly = false\n\t};\n};\n",
      "lines": 128
    },
    {
      "file_path": "MassGameplay\\MassSignals\\Public\\MassSignalTypes.h",
      "extension": ".h",
      "size_bytes": 1713,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Logging/LogMacros.h\"\n#include \"MassEntityManager.h\"\n//#include \"MassSignalTypes.generated.h\"\n\nDECLARE_LOG_CATEGORY_EXTERN(LogMassSignals, Log, All)\n\n\n/**\n * MassSignalNameLookup stores list of Signal names for each entity. The names are stored per entity as a bitmask,\n * you can allocate new name using GetOrAddSignalName(). This limits the names to 64.\n */\nstruct MASSSIGNALS_API FMassSignalNameLookup\n{\n\t/** Max number of names each entity can contain */\n\tstatic constexpr int32 MaxSignalNames = 64;\n\n\t/** \n\t * Retrieve if it is already registered or adds new signal to the lookup and return the bitflag for that Signal\n\t * @SignalName is the name of the signal to retrieve or add to the lookup.\n\t * @return bitflag describing the name, or 0 if max names is reached. \n\t */\n\tuint64 GetOrAddSignalName(const FName SignalName);\n\n\t/**\n\t * Adds specified Signal name bitflag to an entity \n\t * @param Entity is the entity where the signal has been raised\n\t * @param SignalFlag is the actual bitflag describing the signal\n\t */\n\tvoid AddSignalToEntity(const FMassEntityHandle Entity, const uint64 SignalFlag);\n\n\t/** \n\t * Retrieve for a specific entity the raised signal this frame\n\t * @return Array of signal names raised for this entity \n\t */\n\tvoid GetSignalsForEntity(const FMassEntityHandle Entity, TArray<FName>& OutSignals) const;\n\n\t/** Empties the name lookup and entity signals */\n\tvoid Reset();\n\nprotected:\n\t/** Array of Signal names */\n\tTArray<FName> SignalNames;\n\n\t/** Map from entity id to name bitmask */\n\tTMap<FMassEntityHandle, uint64> EntitySignals;\n};",
      "lines": 51
    },
    {
      "file_path": "MassGameplay\\MassSimulation\\Public\\IMassSimulationModule.h",
      "extension": ".h",
      "size_bytes": 1133,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n * The public interface to this module.  In most cases, this interface is only public to sibling modules \n * within this plugin.\n */\nclass IMassSimulationModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t * Singleton-like access to this module's interface.  This is just for convenience!\n\t * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t *\n\t * @return Returns singleton instance, loading the module on demand if needed\n\t */\n\tstatic inline IMassSimulationModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassSimulationModule>( \"MassSimulation\" );\n\t}\n\n\t/**\n\t * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t *\n\t * @return True if the module is loaded and ready to use\n\t */\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassSimulation\" );\n\t}\n};\n\n",
      "lines": 40
    },
    {
      "file_path": "MassGameplay\\MassSimulation\\Public\\MassSimulationSettings.h",
      "extension": ".h",
      "size_bytes": 2025,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassSettings.h\"\n#include \"MassSimulationSettings.generated.h\"\n\n#define GET_MASSSIMULATION_CONFIG_VALUE(a) (GetMutableDefault<UMassSimulationSettings>()->a)\n\n/**\n * Implements the settings for MassSimulation\n */\nUCLASS(config = Mass, defaultconfig, DisplayName = \"Mass Simulation\")\nclass MASSSIMULATION_API UMassSimulationSettings : public UMassModuleSettings\n{\n\tGENERATED_BODY()\n\npublic:\n\t/** The desired budget in seconds allowed to do actor spawning per frame */\n\tUPROPERTY(EditDefaultsOnly, Category = \"Runtime\", config)\n\tdouble DesiredActorSpawningTimeSlicePerTick = 0.0015;\n\n\t/** The desired budget in seconds allowed to do actor destruction per frame */\n\tUPROPERTY(EditDefaultsOnly, Category = \"Runtime\", config)\n\tdouble DesiredActorDestructionTimeSlicePerTick = 0.0005;\n\n\t/** \n\t * Whether the Entity Compaction is allowed. When enabled all the archetypes will be processed on a regular basis\n\t * and the entities will be moved around to optimize archetype chunk memory utilization. Note that this might not be\n\t * desired if your set up results in individual chunks being often not compatible due to the number and value of chunk \n\t * and shared fragments.\n\t */\n\tUPROPERTY(EditDefaultsOnly, Category = \"Runtime\", config)\n\tbool bEntityCompactionEnabled = true;\n\n\t/** The desired budget in seconds allowed to do entity compaction per frame */\n\tUPROPERTY(EditDefaultsOnly, Category = \"Runtime\", config)\n\tdouble DesiredEntityCompactionTimeSlicePerTick = 0.005;\n\n\t/** The time to wait before retrying to spawn an actor that previously failed, default 10 seconds */\n\tUPROPERTY(EditDefaultsOnly, Category = \"Runtime\", config)\n\tfloat DesiredActorFailedSpawningRetryTimeInterval = 5.0f;\n\n\t/** The distance a failed spawned actor needs to move before we retry, default 10 meters */\n\tUPROPERTY(EditDefaultsOnly, Category = \"Runtime\", config)\n\tfloat DesiredActorFailedSpawningRetryMoveDistance = 500.0f;\n};\n",
      "lines": 47
    },
    {
      "file_path": "MassGameplay\\MassSimulation\\Public\\MassSimulationSubsystem.h",
      "extension": ".h",
      "size_bytes": 3283,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"Delegates/IDelegateInstance.h\"\n#include \"MassProcessingTypes.h\"\n#include \"MassProcessingPhaseManager.h\"\n#include \"MassSubsystemBase.h\"\n#include \"MassSimulationSubsystem.generated.h\"\n\n\nstruct FMassEntityManager;\nclass IConsoleVariable;\n\nDECLARE_LOG_CATEGORY_EXTERN(LogMassSim, Log, All);\n\nUCLASS(config = Game, defaultconfig, MinimalAPI)\nclass UMassSimulationSubsystem : public UMassSubsystemBase\n{\n\tGENERATED_BODY()\npublic:\n\tDECLARE_MULTICAST_DELEGATE_OneParam(FOnSimulationStarted, UWorld* /*World*/);\n\t\n\tMASSSIMULATION_API UMassSimulationSubsystem(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());\n\n\tconst FMassProcessingPhaseManager& GetPhaseManager() const { return PhaseManager; }\n\n\tMASSSIMULATION_API FMassProcessingPhase::FOnPhaseEvent& GetOnProcessingPhaseStarted(const EMassProcessingPhase Phase);\n\tMASSSIMULATION_API FMassProcessingPhase::FOnPhaseEvent& GetOnProcessingPhaseFinished(const EMassProcessingPhase Phase);\n\tstatic FOnSimulationStarted& GetOnSimulationStarted() { return OnSimulationStarted; }\n\n\tMASSSIMULATION_API void RegisterDynamicProcessor(UMassProcessor& Processor);\n\tMASSSIMULATION_API void UnregisterDynamicProcessor(UMassProcessor& Processor);\n\n\tbool IsSimulationStarted() const { return bSimulationStarted; }\n\n\t/** @return whether hosted EntityManager is currently, actively being used for processing purposes. Equivalent to calling FMassEntityManager.IsProcessing() */\n\tMASSSIMULATION_API bool IsDuringMassProcessing() const;\n\n\t/** Starts/stops simulation ticking for all worlds, based on new `mass.SimulationTickingEnabled` cvar value */\n\tMASSSIMULATION_API static void HandleSimulationTickingEnabledCVarChange(IConsoleVariable*);\n\nprotected:\n\t// UWorldSubsystem BEGIN\n\tMASSSIMULATION_API virtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\tMASSSIMULATION_API virtual void PostInitialize() override;\n\tMASSSIMULATION_API virtual void OnWorldBeginPlay(UWorld& InWorld) override;\n\tMASSSIMULATION_API virtual void Deinitialize() override;\n\t// UWorldSubsystem END\n\tMASSSIMULATION_API virtual void BeginDestroy() override;\n\t\n\tMASSSIMULATION_API void RebuildTickPipeline();\n\n\tMASSSIMULATION_API void StartSimulation(UWorld& InWorld);\n\tMASSSIMULATION_API void StopSimulation();\n\n\tMASSSIMULATION_API void OnProcessingPhaseStarted(const float DeltaSeconds, const EMassProcessingPhase Phase) const;\n\n#if WITH_EDITOR\n\tMASSSIMULATION_API void OnPieBegin(const bool bIsSimulation);\n\tMASSSIMULATION_API void OnPieEnded(const bool bIsSimulation);\n\tMASSSIMULATION_API void OnMassEntitySettingsChange(const FPropertyChangedEvent& PropertyChangedEvent);\n#endif // WITH_EDITOR\n\nprotected:\n\n\tTSharedPtr<FMassEntityManager> EntityManager;\n\n\tFMassProcessingPhaseManager PhaseManager;\n\n\tinline static FOnSimulationStarted OnSimulationStarted={};\n\n\tUPROPERTY()\n\tFMassRuntimePipeline RuntimePipeline;\n\n\tfloat CurrentDeltaSeconds = 0.f;\n\tbool bTickInProgress = false;\n\tbool bSimulationStarted = false;\n\n#if WITH_EDITOR\n\tFDelegateHandle PieBeginEventHandle;\n\tFDelegateHandle PieEndedEventHandle;\n\n\tFDelegateHandle MassEntitySettingsChangeHandle;\n#endif // WITH_EDITOR\n};\n",
      "lines": 86
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Public\\IMassSmartObjectsModule.h",
      "extension": ".h",
      "size_bytes": 1143,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n * The public interface to this module.  In most cases, this interface is only public to sibling modules \n * within this plugin.\n */\nclass IMassSmartObjectsModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t * Singleton-like access to this module's interface.  This is just for convenience!\n\t * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t *\n\t * @return Returns singleton instance, loading the module on demand if needed\n\t */\n\tstatic inline IMassSmartObjectsModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassSmartObjectsModule>( \"MassSmartObjects\" );\n\t}\n\n\t/**\n\t * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t *\n\t * @return True if the module is loaded and ready to use\n\t */\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassSmartObjects\" );\n\t}\n};\n\n",
      "lines": 40
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Public\\MassSmartObjectBehaviorDefinition.h",
      "extension": ".h",
      "size_bytes": 2043,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassEntityView.h\"\n#include \"SmartObjectDefinition.h\"\n#include \"MassSmartObjectBehaviorDefinition.generated.h\"\n\nstruct FMassEntityManager;\nclass USmartObjectSubsystem;\nstruct FMassExecutionContext;\nstruct FTransformFragment;\nstruct FMassSmartObjectUserFragment;\n\n/**\n * Struct to pass around the required set of information to activate a mass behavior definition on a given entity.\n * Context must be created on stack and not kept around since EntityView validity is not guaranteed.\n */\nstruct MASSSMARTOBJECTS_API FMassBehaviorEntityContext\n{\n\tFMassBehaviorEntityContext() = delete;\n\n\tFMassBehaviorEntityContext(const FMassEntityView InEntityView, USmartObjectSubsystem& InSubsystem)\n\t\t: EntityView(InEntityView)\n\t\t, SmartObjectSubsystem(InSubsystem)\n\t{}\n\n\tconst FMassEntityView EntityView;\n\tUSmartObjectSubsystem& SmartObjectSubsystem;\n};\n\n/**\n * Base class for MassAIBehavior definitions. This is the type of definitions that MassEntity queries will look for.\n * Definition subclass can parameterized its associated behavior by overriding method Activate.\n */\nUCLASS(EditInlineNew)\nclass MASSSMARTOBJECTS_API USmartObjectMassBehaviorDefinition : public USmartObjectBehaviorDefinition\n{\n\tGENERATED_BODY()\n\npublic:\n\t/** This virtual method allows subclasses to configure the MassEntity based on their parameters (e.g. Add fragments) */\n\tvirtual void Activate(FMassCommandBuffer& CommandBuffer, const FMassBehaviorEntityContext& EntityContext) const;\n\n\t/** This virtual method allows subclasses to update the MassEntity on interaction deactivation (e.g. Remove fragments) */\n\tvirtual void Deactivate(FMassCommandBuffer& CommandBuffer, const FMassBehaviorEntityContext& EntityContext) const;\n\n\t/**\n\t * Indicates the amount of time the Massentity\n\t * will execute its behavior when reaching the smart object.\n\t */\n\tUPROPERTY(EditDefaultsOnly, Category = SmartObject)\n\tfloat UseTime;\n};\n",
      "lines": 55
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Public\\MassSmartObjectFragments.h",
      "extension": ".h",
      "size_bytes": 1366,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassSmartObjectTypes.h\"\n#include \"MassSmartObjectRequest.h\"\n#include \"SmartObjectRuntime.h\"\n#include \"MassSmartObjectFragments.generated.h\"\n\n/** Fragment used by an entity to be able to interact with smart objects */\nUSTRUCT()\nstruct MASSSMARTOBJECTS_API FMassSmartObjectUserFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\t/** Tags describing the smart object user. */\n\tUPROPERTY(Transient)\n\tFGameplayTagContainer UserTags;\n\n\t/** Claim handle for the currently active smart object interaction. */\n\tUPROPERTY(Transient)\n\tFSmartObjectClaimHandle InteractionHandle;\n\n\t/** Status of the current active smart object interaction. */\n\tUPROPERTY(Transient)\n\tEMassSmartObjectInteractionStatus InteractionStatus = EMassSmartObjectInteractionStatus::Unset;\n\n\t/**\n\t * World time in seconds before which the user is considered in cooldown and\n\t * won't look for new interactions (value of 0 indicates no cooldown).\n\t */\n\tUPROPERTY(Transient)\n\tdouble InteractionCooldownEndTime = 0.;\n};\n\n/** Fragment used to process time based smartobject interactions */\nUSTRUCT()\nstruct MASSSMARTOBJECTS_API FMassSmartObjectTimedBehaviorFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(Transient)\n\tfloat UseTime = 0.f;\n};",
      "lines": 45
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Public\\MassSmartObjectHandler.h",
      "extension": ".h",
      "size_bytes": 6644,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassSmartObjectRequest.h\"\n#include \"MassSmartObjectTypes.h\"\n\nstruct FMassEntityManager;\nclass UMassSignalSubsystem;\nclass USmartObjectSubsystem;\nstruct FMassExecutionContext;\nstruct FMassEntityHandle;\nstruct FMassSmartObjectUserFragment;\nstruct FTransformFragment;\nstruct FSmartObjectClaimHandle;\nstruct FSmartObjectHandle;\nstruct FZoneGraphCompactLaneLocation;\nenum class ESmartObjectSlotState : uint8;\n\n/**\n * Mediator struct that encapsulates communication between SmartObjectSubsystem and Mass.\n * This object is meant to be created and used in method scope to guarantee subsystems validity.\n */\nstruct MASSSMARTOBJECTS_API FMassSmartObjectHandler\n{\n\t/**\n\t * FMassSmartObjectHandler constructor\n\t * @param InEntitySubsystem is the entity subsystem that the smart object should belong to\n\t * @param InExecutionContext is the current execution context of the entity subsystem\n\t * @param InSmartObjectSubsystem is the smart object subsystem\n\t * @param InSignalSubsystem is the mass signal subsystem to use to send signal to affected entities\n\t */\n\tFMassSmartObjectHandler(FMassEntityManager& InEntityManager, FMassExecutionContext& InExecutionContext, USmartObjectSubsystem& InSmartObjectSubsystem, UMassSignalSubsystem& InSignalSubsystem)\n\t\t: EntityManager(InEntityManager)\n\t\t, ExecutionContext(InExecutionContext)\n\t\t, SmartObjectSubsystem(InSmartObjectSubsystem)\n\t\t, SignalSubsystem(InSignalSubsystem)\n\t{\n\t}\n\n\t/**\n\t * Creates an async request to build a list of compatible smart objects\n\t * around the provided location. The caller must poll using the request id\n\t * to know when the reservation can be done.\n\t * @param RequestingEntity Entity requesting the candidates list\n\t * @param Location The center of the query\n\t * @return Request identifier that can be used to try claiming a result once available\n\t */\n\t[[nodiscard]] FMassSmartObjectRequestID FindCandidatesAsync(const FMassEntityHandle RequestingEntity, const FGameplayTagContainer& UserTags, const FGameplayTagQuery& ActivityRequirements, const FVector& Location) const;\n\n\t/**\n\t * Creates an async request to build a list of compatible smart objects\n\t * around the provided lane location. The caller must poll using the request id\n\t * to know when the reservation can be done.\n\t * @param RequestingEntity Entity requesting the candidates list\n\t * @param LaneLocation The lane location as reference for the query\n\t * @return Request identifier that can be used to try claiming a result once available\n\t */\n\t[[nodiscard]] FMassSmartObjectRequestID FindCandidatesAsync(const FMassEntityHandle RequestingEntity, const FGameplayTagContainer& UserTags, const FGameplayTagQuery& ActivityRequirements, const FZoneGraphCompactLaneLocation& LaneLocation) const;\n\n\t/**\n\t * Provides the result of a previously created request from FindCandidatesAsync to indicate if it has been processed\n\t * and the results can be used by ClaimCandidate.\n\t * @param RequestID A valid request identifier (method will ensure otherwise)\n\t * @return The current request's result, nullptr if request not ready yet.\n\t */\n\t[[nodiscard]] const FMassSmartObjectCandidateSlots* GetRequestCandidates(const FMassSmartObjectRequestID& RequestID) const;\n\n\t/**\n\t * Deletes the request associated to the specified identifier\n\t * @param RequestID A valid request identifier (method will ensure otherwise)\n\t */\n\tvoid RemoveRequest(const FMassSmartObjectRequestID& RequestID) const;\n\n\t/**\n\t * Claims the first available smart object from the provided candidates.\n\t * @param Entity MassEntity associated to the user fragment\n\t * @param User Fragment of the user claiming\n\t * @param Candidates Candidate slots to choose from.\n\t * @param ClaimPriority Claim priority, a slot claimed at lower priority can be claimed by higher priority (unless already in use).\n\t * @return Whether the slot has been successfully claimed or not\n\t */\n\t[[nodiscard]] FSmartObjectClaimHandle ClaimCandidate(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const FMassSmartObjectCandidateSlots& Candidates, ESmartObjectClaimPriority ClaimPriority = ESmartObjectClaimPriority::Normal) const;\n\n\t/**\n\t * Claims the first available slot holding any type of USmartObjectMassBehaviorDefinition in the smart object\n\t * associated to the provided identifier.\n\t * @param Entity MassEntity associated to the user fragment\n\t * @param User Fragment of the user claiming\n\t * @param RequestResult A valid smart object request result (method will ensure otherwise)\n\t * @param ClaimPriority Claim priority, a slot claimed at lower priority can be claimed by higher priority (unless already in use).\n\t * @return Whether the slot has been successfully claimed or not\n\t */\n\t[[nodiscard]] FSmartObjectClaimHandle ClaimSmartObject(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const FSmartObjectRequestResult& RequestResult, ESmartObjectClaimPriority ClaimPriority = ESmartObjectClaimPriority::Normal) const;\n\n\t/**\n\t * Activates the mass gameplay behavior associated to the previously claimed smart object.\n\t * @param Entity MassEntity associated to the user fragment\n\t * @param User Fragment of the user claiming\n\t * @param ClaimHandle claimed smart object slot to use.\n\t * @param Transform Fragment holding the transform of the user claiming\n\t * @return Whether the slot has been successfully claimed or not\n\t */\n\tbool StartUsingSmartObject(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const FSmartObjectClaimHandle ClaimHandle) const;\n\n\t/**\n\t * Deactivates the mass gameplay behavior started using StartUsingSmartObject.\n\t * @param Entity MassEntity associated to the user fragment\n\t * @param User Fragment of the user claiming\n\t * @param NewStatus Reason of the deactivation.\n\t */\n\tvoid StopUsingSmartObject(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const EMassSmartObjectInteractionStatus NewStatus) const;\n\n\t/**\n\t * Releases a claimed/in-use smart object and update user fragment.\n\t * @param Entity MassEntity associated to the user fragment\n\t * @param User Fragment of the user claiming\n\t * @param ClaimHandle claimed smart object slot to release.\n\t */\n\tvoid ReleaseSmartObject(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const FSmartObjectClaimHandle ClaimHandle) const;\n\nprivate:\n\tFMassEntityManager& EntityManager;\n\tFMassExecutionContext& ExecutionContext;\n\tUSmartObjectSubsystem& SmartObjectSubsystem;\n\tUMassSignalSubsystem& SignalSubsystem;\n};\n",
      "lines": 127
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Public\\MassSmartObjectProcessor.h",
      "extension": ".h",
      "size_bytes": 2126,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassObserverProcessor.h\"\n#include \"MassProcessor.h\"\n#include \"MassSmartObjectProcessor.generated.h\"\n\nclass UMassSignalSubsystem;\nclass UZoneGraphAnnotationSubsystem;\n\n/** Processor that builds a list of candidates objects for each users. */\nUCLASS()\nclass MASSSMARTOBJECTS_API UMassSmartObjectCandidatesFinderProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassSmartObjectCandidatesFinderProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\t/** Extents used to perform the spatial query in the octree for world location queries. */\n\tUPROPERTY(EditDefaultsOnly, Category = SmartObject, config)\n\tfloat SearchExtents = 5000.f;\n\n\t/** Query to fetch and process requests to find smart objects using spacial query around a given world location. */\n\tFMassEntityQuery WorldRequestQuery;\n\n\t/** Query to fetch and process requests to find smart objects on zone graph lanes. */\n\tFMassEntityQuery LaneRequestQuery;\n};\n\n/** Processor for time based user's behavior that waits x seconds then releases its claim on the object */\nUCLASS()\nclass MASSSMARTOBJECTS_API UMassSmartObjectTimedBehaviorProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\npublic:\n\tUMassSmartObjectTimedBehaviorProcessor();\n\nprotected:\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\tvirtual void ConfigureQueries() override;\n\n\tFMassEntityQuery EntityQuery;\n};\n\n/** Deinitializer processor to unregister slot invalidation callback when SmartObjectUser fragment gets removed */\nUCLASS()\nclass MASSSMARTOBJECTS_API UMassSmartObjectUserFragmentDeinitializer : public UMassObserverProcessor\n{\n\tGENERATED_BODY()\n\n\tUMassSmartObjectUserFragmentDeinitializer();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n};",
      "lines": 64
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Public\\MassSmartObjectRegistration.h",
      "extension": ".h",
      "size_bytes": 4226,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassObserverProcessor.h\"\n#include \"MassSignalProcessorBase.h\"\n#include \"SmartObjectTypes.h\"\n#include \"MassSmartObjectRegistration.generated.h\"\n\nclass USmartObjectDefinition;\n\n/** Mass Tag applied on entities with FFSmartObjectRegistrationFragment that need to create smart objects */\nUSTRUCT()\nstruct MASSSMARTOBJECTS_API FMassInActiveSmartObjectsRangeTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n\n/** Mass Fragment storing the handle associated to the created smart object */\nUSTRUCT()\nstruct MASSSMARTOBJECTS_API FSmartObjectRegistrationFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY()\n\tTWeakObjectPtr<USmartObjectDefinition> Asset;\n\n\tUPROPERTY()\n\tFSmartObjectHandle Handle;\n};\n\n/**\n * Processor that signals entities with FSmartObjectRegistration and FMassActorInstanceFragment fragments\n * when the a given tag or fragment is added to an entity.\n * @see FSmartObjectRegistrationFragment\n * @see FMassActorInstanceFragment\n */\nUCLASS(Abstract)\nclass UMassSmartObjectInitializerBase : public UMassObserverProcessor\n{\n\tGENERATED_BODY()\npublic:\n\tUMassSmartObjectInitializerBase();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n\tFName Signal;\n};\n\n/**\n * Processor that signals entities with FSmartObjectRegistration and FMassActorInstanceFragment fragments\n * when the a given tag or fragment is removed from an entity.\n * @see FSmartObjectRegistrationFragment\n * @see FMassActorInstanceFragment\n */\nUCLASS(Abstract)\nclass UMassSmartObjectDeinitializerBase : public UMassObserverProcessor\n{\n\tGENERATED_BODY()\npublic:\n\tUMassSmartObjectDeinitializerBase();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n\tFName Signal;\n};\n\n/**\n * Signals entities with UE::Mass::Signals::SmartObjectActivationChanged when 'FMassInActiveSmartObjectsRangeTag' is added.\n */\nUCLASS()\nclass UMassActiveSmartObjectInitializer : public UMassSmartObjectInitializerBase\n{\n\tGENERATED_BODY()\npublic:\n\tUMassActiveSmartObjectInitializer();\n};\n\n/**\n * Signals entities with UE::Mass::Signals::SmartObjectActivationChanged when 'FMassInActiveSmartObjectsRangeTag' is removed.\n */\nUCLASS()\nclass UMassActiveSmartObjectDeinitializer : public UMassSmartObjectDeinitializerBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassActiveSmartObjectDeinitializer();\n};\n\n/**\n * Signals entities with UE::Mass::Signals::ActorInstanceHandleChanged when 'FMassActorInstanceFragment' is added.\n */\nUCLASS()\nclass UMassActorInstanceHandleInitializer : public UMassSmartObjectInitializerBase\n{\n\tGENERATED_BODY()\npublic:\n\tUMassActorInstanceHandleInitializer();\n};\n\n/**\n * Signals entities with UE::Mass::Signals::ActorInstanceHandleChanged when 'FMassActorInstanceFragment' is removed.\n */\nUCLASS()\nclass UMassActorInstanceHandleDeinitializer : public UMassSmartObjectDeinitializerBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassActorInstanceHandleDeinitializer();\n};\n\n/**\n * Signal based processor that creates and destroys the smart object instance associated to an entity based\n * on valid FSmartObjectRegistration and FMassActorInstance fragments.\n * The registration is processed on the following events:\n * \t UE::Mass::Signals::ActorInstanceHandleChanged\n * \t UE::Mass::Signals::SmartObjectActivationChanged\n * @see FFSmartObjectRegistrationFragment\n */\nUCLASS()\nclass UMassActiveSmartObjectSignalProcessor : public UMassSignalProcessorBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassActiveSmartObjectSignalProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Initialize(UObject& Owner) override;\n\tvirtual void SignalEntities(FMassEntityManager& EntityManager, FMassExecutionContext& Context, FMassSignalNameLookup& /*Unused*/) override;\n\nprivate:\n\tFMassEntityQuery InsideSmartObjectActiveRangeQuery;\n\tFMassEntityQuery OutsideSmartObjectActiveRangeQuery;\n};",
      "lines": 144
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Public\\MassSmartObjectRequest.h",
      "extension": ".h",
      "size_bytes": 3570,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"SmartObjectSubsystem.h\"\n#include \"MassEntityTypes.h\"\n#include \"ZoneGraphTypes.h\"\n#include \"Containers/StaticArray.h\"\n#include \"MassSmartObjectRequest.generated.h\"\n\n/**\n * Structure that represents a potential smart object slot for a MassEntity during the search\n */\nUSTRUCT()\nstruct MASSSMARTOBJECTS_API FSmartObjectCandidateSlot\n{\n\tGENERATED_BODY()\n\n\tFSmartObjectCandidateSlot() = default;\n\tFSmartObjectCandidateSlot(const FSmartObjectRequestResult InResult, const float InCost)\t: Result(InResult), Cost(InCost) {}\n\n\tUPROPERTY(Transient)\n\tFSmartObjectRequestResult Result;\n\n\tUPROPERTY(Transient)\n\tfloat Cost = 0.f;\n};\n\n/**\n * Identifier associated to a request for smart object candidates. We use a 1:1 match\n * with an FMassEntityHandle since all requests are batched together using the EntitySubsystem.\n */\nUSTRUCT()\nstruct MASSSMARTOBJECTS_API FMassSmartObjectRequestID\n{\n\tGENERATED_BODY()\n\n\tFMassSmartObjectRequestID() = default;\n\texplicit FMassSmartObjectRequestID(const FMassEntityHandle InEntity) : Entity(InEntity) {}\n\n\tbool IsSet() const { return Entity.IsSet(); }\n\tvoid Reset() { Entity.Reset(); }\n\n\texplicit operator FMassEntityHandle() const { return Entity; }\n\nprivate:\n\tUPROPERTY(Transient)\n\tFMassEntityHandle Entity;\n};\n\n/**\n * Struct that holds status and results of a candidate finder request\n */\nUSTRUCT(BlueprintType)\nstruct MASSSMARTOBJECTS_API FMassSmartObjectCandidateSlots\n{\n\tGENERATED_BODY()\n\n\tvoid Reset()\n\t{\n\t\tNumSlots = 0;\n\t}\n\t\n\tstatic constexpr uint32 MaxNumCandidates = 4;\n\tTStaticArray<FSmartObjectCandidateSlot, MaxNumCandidates> Slots;\n\n\tUPROPERTY(Transient)\n\tuint8 NumSlots = 0;\n};\n\n/**\n * Fragment that holds the result of a request to find candidates.\n */\nUSTRUCT()\nstruct MASSSMARTOBJECTS_API FMassSmartObjectRequestResultFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(Transient)\n\tFMassSmartObjectCandidateSlots Candidates;\n\n\tUPROPERTY(Transient)\n\tbool bProcessed = false;\n};\n\n/**\n * Fragment used to build a list potential smart objects to use. Once added to an entity\n * this will be processed by the candidates finder processor to fill a SmartObjectCandidates\n * fragment that could then be processed by the reservation processor\n */\nUSTRUCT()\nstruct MASSSMARTOBJECTS_API FMassSmartObjectWorldLocationRequestFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(Transient)\n\tFVector SearchOrigin = FVector::ZeroVector;\n\n\tUPROPERTY(Transient)\n\tFMassEntityHandle RequestingEntity;\n\n\tUPROPERTY(Transient)\n\tFGameplayTagContainer UserTags;\n\n\tUPROPERTY(Transient)\n\tFGameplayTagQuery ActivityRequirements;\n};\n\n/**\n * Fragment used to build a list potential smart objects to use. Once added to an entity\n * this will be processed by the candidates finder processor to fill a SmartObjectCandidates\n * fragment that could then be processed by the reservation processor\n */\nUSTRUCT()\nstruct MASSSMARTOBJECTS_API FMassSmartObjectLaneLocationRequestFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tFZoneGraphCompactLaneLocation CompactLaneLocation;\n\n\tUPROPERTY(Transient)\n\tFMassEntityHandle RequestingEntity;\n\n\tUPROPERTY(Transient)\n\tFGameplayTagContainer UserTags;\n\n\tUPROPERTY(Transient)\n\tFGameplayTagQuery ActivityRequirements;\n};\n\n/**\n * Special tag to mark processed requests\n */\nUSTRUCT()\nstruct MASSSMARTOBJECTS_API FMassSmartObjectCompletedRequestTag : public FMassTag\n{\n\tGENERATED_BODY()\n};\n",
      "lines": 138
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Public\\MassSmartObjectSettings.h",
      "extension": ".h",
      "size_bytes": 1188,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n#include \"ZoneGraphTypes.h\"\n#include \"MassSettings.h\"\n#include \"MassSmartObjectSettings.generated.h\"\n\n#if WITH_EDITOR\n/** Called when annotation tag settings changed. */\nDECLARE_MULTICAST_DELEGATE(FOnAnnotationSettingsChanged);\n#endif\n\n/**\n * Settings for the MassSmartObject module.\n */\nUCLASS(config = Plugins, defaultconfig, DisplayName = \"Mass SmartObject\")\nclass MASSSMARTOBJECTS_API UMassSmartObjectSettings : public UMassModuleSettings\n{\n\tGENERATED_BODY()\n\npublic:\n#if WITH_EDITOR\n\tmutable FOnAnnotationSettingsChanged OnAnnotationSettingsChanged;\n#endif\n\n\t/** Tag used to indicate that smart objects are associated to a lane for queries using lanes. */\n\tUPROPERTY(EditDefaultsOnly, Category = ZoneGraph, config)\n\tFZoneGraphTag SmartObjectTag;\n\n\t/** Extents used to find precomputed entry points to reach a smart object from a zone graph lane. */\n\tUPROPERTY(EditDefaultsOnly, Category = ZoneGraph, config)\n\tfloat SearchExtents = 500.f;\n\nprotected:\n\n#if WITH_EDITOR\n\tvirtual void PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent) override;\n#endif\n};\n",
      "lines": 39
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Public\\MassSmartObjectTypes.h",
      "extension": ".h",
      "size_bytes": 2521,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTypes.h\"\n#include \"MassSmartObjectTypes.generated.h\"\n\nnamespace UE::Mass::Signals\n{\n\tconst FName SmartObjectRequestCandidates = FName(TEXT(\"SmartObjectRequestCandidates\"));\n\tconst FName SmartObjectCandidatesReady = FName(TEXT(\"SmartObjectCandidatesReady\"));\n\tconst FName SmartObjectInteractionDone = FName(TEXT(\"SmartObjectInteractionDone\"));\n\tconst FName SmartObjectInteractionAborted = FName(TEXT(\"SmartObjectInteractionAborted\"));\n}\n\nUENUM()\nenum class EMassSmartObjectInteractionStatus: uint8\n{\n\tUnset,\n    InProgress,\t\t\t// Claimed and Behavior activated\n    BehaviorCompleted,\t// Behavior is completed but task still running (not updated yet)\n\tTaskCompleted,\t\t// Task has been notified that behavior is completed and completes\n    Aborted\t\t\t\t// Task and Behavior were aborted\n};\n\n/**\n * Struct that can be used to pass data to the find or filtering methods.\n * Properties will be used as external data to fill values expected by the world condition schema\n * specified by the smart object definition.\n *\t\te.g. FilterSlotsBySelectionConditions(SlotHandles, FConstStructView::Make(FSmartObjectMassEntityUserData(Entity)));\n *\n * It can be inherited from to provide additional data to another world condition schema inheriting\n * from USmartObjectWorldConditionSchema.\n *\te.g.\n *\t\tUCLASS()\n *\t\tclass USmartObjectWorldConditionExtendedSchema : public USmartObjectWorldConditionSchema\n *\t\t{\n *\t\t\t...\n *\t\t\tUSmartObjectWorldConditionExtendedSchema(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)\n *\t\t\t{\n *\t\t\t\tOtherEntityRef = AddContextDataDesc(TEXT(\"OtherEntity\"), FMassEntityHandle::StaticStruct(), EWorldConditionContextDataType::Dynamic);\n *\t\t\t}\n *\t\t\t\n *\t\t\tFWorldConditionContextDataRef OtherEntityRef;\n *\t\t};\n *\n *\t\tUSTRUCT()\n *\t\tstruct FSmartObjectMassEntityExtendedUserData : public FSmartObjectMassEntityUserData\n *\t\t{\n *\t\t\tUPROPERTY()\n *\t\t\tFMassEntityHandle OtherEntity;\n *\t\t}\n *\n * The struct can also be used to be added to a Smart Object slot when it gets claimed.\n *\t\te.g. Claim(SlotHandle, FConstStructView::Make(FSmartObjectMassEntityUserData(Entity)));\n */\nUSTRUCT()\nstruct FSmartObjectMassEntityUserData\n{\n\tGENERATED_BODY()\n\n\tFSmartObjectMassEntityUserData() = default;\n\texplicit FSmartObjectMassEntityUserData(const FMassEntityHandle InEntityHandle) : UserEntity(InEntityHandle) {}\n\n\tUPROPERTY()\n\tFMassEntityHandle UserEntity;\n};",
      "lines": 67
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Public\\MassSmartObjectUserTrait.h",
      "extension": ".h",
      "size_bytes": 716,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityTraitBase.h\"\n#include \"GameplayTagContainer.h\"\n#include \"MassSmartObjectUserTrait.generated.h\"\n\n/**\n * Trait to allow an entity to interact with SmartObjects\n */\nUCLASS(meta = (DisplayName = \"SmartObject User\"))\nclass MASSSMARTOBJECTS_API UMassSmartObjectUserTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\n\t/** Tags describing the SmartObject user. Used when searching smart objects. */\n\tUPROPERTY(EditAnywhere, Category = Parameter)\n\tFGameplayTagContainer UserTags;\n};\n",
      "lines": 23
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Public\\SmartObjectZoneAnnotations.h",
      "extension": ".h",
      "size_bytes": 4736,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"SmartObjectTypes.h\"\n#include \"ZoneGraphAnnotationComponent.h\"\n#include \"ZoneGraphTypes.h\"\n#include \"SmartObjectZoneAnnotations.generated.h\"\n\nclass AZoneGraphData;\nclass USmartObjectSubsystem;\n\n/** Struct to keep track of a SmartObject entry point on a given lane. */\nUSTRUCT()\nstruct FSmartObjectLaneLocation\n{\n\tGENERATED_BODY()\n\n\tFSmartObjectLaneLocation() = default;\n\tFSmartObjectLaneLocation(const FSmartObjectHandle InObjectHandle, const int32 InLaneIndex, const float InDistanceAlongLane)\n        : ObjectHandle(InObjectHandle)\n        , LaneIndex(InLaneIndex)\n        , DistanceAlongLane(InDistanceAlongLane)\n\t{\n\t}\n\n\tUPROPERTY()\n\tFSmartObjectHandle ObjectHandle;\n\n\tUPROPERTY()\n\tint32 LaneIndex = INDEX_NONE;\n\n\tUPROPERTY()\n\tfloat DistanceAlongLane = 0.0f;\n};\n\n/**\n * Struct to store indices to all entry points on a given lane.\n * Used as a container wrapper to be able to use in a TMap.\n */\nUSTRUCT()\nstruct FSmartObjectLaneLocationIndices\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(VisibleAnywhere, Category = SmartObject)\n\tTArray<int32> SmartObjectLaneLocationIndices;\n};\n\n/** Per ZoneGraphData smart object look up data. */\nUSTRUCT()\nstruct FSmartObjectAnnotationData\n{\n\tGENERATED_BODY()\n\n\t/** @return True if this entry is valid (associated to a valid zone graph data), false otherwise. */\n\tbool IsValid() const { return DataHandle.IsValid(); }\n\n\t/** Reset all internal data. */\n\tvoid Reset()\n\t{\n\t\tDataHandle = {};\n\t\tAffectedLanes.Reset();\n\t\tSmartObjectLaneLocations.Reset();\n\t\tSmartObjectToLaneLocationIndexLookup.Reset();\n\t\tLaneToLaneLocationIndicesLookup.Reset();\n\t}\n\n\t/** Handle of the ZoneGraphData that this smart object annotation data is associated to */\n\tUPROPERTY(VisibleAnywhere, Category = SmartObject)\n\tFZoneGraphDataHandle DataHandle;\n\n\tUPROPERTY(VisibleAnywhere, Category = SmartObject)\n\tTArray<int32> AffectedLanes;\n\n\tUPROPERTY(VisibleAnywhere, Category = SmartObject)\n\tTArray<FSmartObjectLaneLocation> SmartObjectLaneLocations;\n\n\tUPROPERTY(VisibleAnywhere, Category = SmartObject)\n\tTMap<FSmartObjectHandle, int32> SmartObjectToLaneLocationIndexLookup;\n\n\tUPROPERTY(VisibleAnywhere, Category = SmartObject)\n\tTMap<int32, FSmartObjectLaneLocationIndices> LaneToLaneLocationIndicesLookup;\n\n\tbool bInitialTaggingCompleted = false;\n};\n\n/**\n * ZoneGraph annotations for smart objects\n */\nUCLASS(ClassGroup = AI, BlueprintType, meta = (BlueprintSpawnableComponent))\nclass MASSSMARTOBJECTS_API USmartObjectZoneAnnotations : public UZoneGraphAnnotationComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tconst FSmartObjectAnnotationData* GetAnnotationData(FZoneGraphDataHandle DataHandle) const;\n\tTOptional<FSmartObjectLaneLocation> GetSmartObjectLaneLocation(const FZoneGraphDataHandle DataHandle, const FSmartObjectHandle SmartObjectHandle) const;\n\nprotected:\n\tvirtual void PostSubsystemsInitialized() override;\n\tvirtual FZoneGraphTagMask GetAnnotationTags() const override;\n\tvirtual void TickAnnotation(const float DeltaTime, FZoneGraphAnnotationTagContainer& BehaviorTagContainer) override;\n\n\tvirtual void PostZoneGraphDataAdded(const AZoneGraphData& ZoneGraphData) override;\n\tvirtual void PreZoneGraphDataRemoved(const AZoneGraphData& ZoneGraphData) override;\n\n#if UE_ENABLE_DEBUG_DRAWING\n\tvirtual void DebugDraw(FZoneGraphAnnotationSceneProxy* DebugProxy) override;\n#endif // UE_ENABLE_DEBUG_DRAWING\n\n\t/** Filter specifying which lanes the behavior is applied to. */\n\tUPROPERTY(EditAnywhere, Category = SmartObject)\n\tFZoneGraphTagFilter AffectedLaneTags;\n\n\t/** Entry points graph for each ZoneGraphData. */\n\tUPROPERTY(VisibleAnywhere, Category = SmartObject)\n\tTArray<FSmartObjectAnnotationData> SmartObjectAnnotationDataArray;\n\n\t/** Tag to mark the lanes that offers smart objects. */\n\tUPROPERTY(VisibleAnywhere, Category = SmartObject)\n\tFZoneGraphTag BehaviorTag;\n\n#if WITH_EDITOR\n\tvirtual void PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent) override;\n\tvirtual void OnUnregister() override;\n\n\tvoid RebuildForSingleGraph(FSmartObjectAnnotationData& Data, const FZoneGraphStorage& Storage);\n\tvoid RebuildForAllGraphs();\n\n\tFDelegateHandle OnAnnotationSettingsChangedHandle;\n\tFDelegateHandle OnGraphDataChangedHandle;\n\tFDelegateHandle OnMainCollectionChangedHandle;\n\tFDelegateHandle OnMainCollectionDirtiedHandle;\n#endif // WITH_EDITOR\n\n#if WITH_EDITORONLY_DATA\n\tvirtual void Serialize(FArchive& Ar) override;\n\tbool bRebuildAllGraphsRequested = false;\n#endif\n\n\t/** Cached SmartObjectSubsystem */\n\tUPROPERTY(Transient)\n\tTObjectPtr<USmartObjectSubsystem> SmartObjectSubsystem = nullptr;\n};\n",
      "lines": 145
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Public\\IMassSpawnerModule.h",
      "extension": ".h",
      "size_bytes": 1118,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n#include \"Modules/ModuleManager.h\"\n\n\n/**\n * The public interface to this module.  In most cases, this interface is only public to sibling modules \n * within this plugin.\n */\nclass IMassSpawnerModule : public IModuleInterface\n{\n\npublic:\n\n\t/**\n\t * Singleton-like access to this module's interface.  This is just for convenience!\n\t * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n\t *\n\t * @return Returns singleton instance, loading the module on demand if needed\n\t */\n\tstatic inline IMassSpawnerModule& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IMassSpawnerModule>( \"MassSpawner\" );\n\t}\n\n\t/**\n\t * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n\t *\n\t * @return True if the module is loaded and ready to use\n\t */\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded( \"MassSpawner\" );\n\t}\n};\n\n",
      "lines": 40
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Public\\MassAssortedFragmentsTrait.h",
      "extension": ".h",
      "size_bytes": 897,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"CoreMinimal.h\"\n#include \"MassEntityTraitBase.h\"\n#include \"StructUtils/InstancedStruct.h\"\n#include \"MassAssortedFragmentsTrait.generated.h\"\n\n/**\n* Mass Agent Feature which appends a list of specified fragments.  \n*/\nUCLASS(meta=(DisplayName=\"Assorted Fragments\"))\nclass MASSSPAWNER_API UMassAssortedFragmentsTrait : public UMassEntityTraitBase\n{\n\tGENERATED_BODY()\n\nprotected:\n\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;\n\n\tUPROPERTY(Category=\"Mass\", EditAnywhere, meta = (BaseStruct = \"/Script/MassEntity.MassFragment\", ExcludeBaseStruct))\n\tTArray<FInstancedStruct> Fragments;\n\n\tUPROPERTY(Category=\"Mass\", EditAnywhere, meta = (BaseStruct = \"/Script/MassEntity.MassTag\", ExcludeBaseStruct))\n\tTArray<FInstancedStruct> Tags;\n};\n",
      "lines": 27
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Public\\MassEntityConfigAsset.h",
      "extension": ".h",
      "size_bytes": 7297,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"CoreMinimal.h\"\n#include \"Engine/DataAsset.h\"\n#include \"MassEntityTemplate.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"MassEntityConfigAsset.generated.h\"\n\nclass UMassEntityConfigAsset;\nclass UMassEntityTraitBase;\n\n/**\n * Describes a Mass agent to spawn. The struct can be embedded to allow last minute changes to the agent (i.e. for debugging).\n * The agent config describes a unique list of features which are used to create an entity template.\n * Derived configs can override parent features.\n */\nUSTRUCT()\nstruct MASSSPAWNER_API FMassEntityConfig\n{\n\tfriend class UMassTemplateRegistry;\n\n\tGENERATED_BODY()\n\n\tFMassEntityConfig();\n\tFMassEntityConfig(UObject& InOwner);\n\n\t/** Create entity template based on the features included in this config.\n\t *  @param World in which we are creating the template.\n\t */\n\tconst FMassEntityTemplate& GetOrCreateEntityTemplate(const UWorld& World) const;\n\n\tvoid DestroyEntityTemplate(const UWorld& World) const;\n\n\t/** \n\t * Fetches the EntityTemplate for given World, fails a check if one cannot be found.\n\t */\n\tconst FMassEntityTemplate& GetEntityTemplateChecked(const UWorld& World) const;\n\n\t/** @return Parent config */\n\tconst UMassEntityConfigAsset* GetParent() const { return Parent; }\n\n\tvoid SetParentAsset(const UMassEntityConfigAsset& InParent) { Parent = &InParent; }\n\t\n\t/** @return View to the array of features defined on this config */\n\tTConstArrayView<UMassEntityTraitBase*> GetTraits() const { return Traits; }\n\n\t/** Looks for a trait of the indicated type, accepting all child classes as well, unless bExactMatch == true */\n\tconst UMassEntityTraitBase* FindTrait(TSubclassOf<UMassEntityTraitBase> TraitClass, const bool bExactMatch = false) const\n\t{\n\t\treturn FindTraitInternal(TraitClass, bExactMatch);\n\t}\n\n\t/** Adds Trait to the collection of traits hosted by this FMassEntityConfig instance */\n\tvoid AddTrait(UMassEntityTraitBase& Trait);\n\n\t/** Validates if the entity template is well built */\n\tbool ValidateEntityTemplate(const UWorld& World);\n\n\tvoid SetOwner(UObject& InOwner) { ConfigOwner = &InOwner; }\n\n\tUE_DEPRECATED(5.3, \"This flavor of GetOrCreateEntityTemplate is deprecated. Use the one without the ConfigOwner parameter (now a property of the FMassEntityConfig itself)\")\n\tconst FMassEntityTemplate& GetOrCreateEntityTemplate(const UWorld& World, const UObject& ConfigOwner) const;\n\n\tUE_DEPRECATED(5.3, \"This flavor of DestroyEntityTemplate is deprecated. Use the one without the ConfigOwner parameter (now a property of the FMassEntityConfig itself)\")\n\tvoid DestroyEntityTemplate(const UWorld& World, const UObject& ConfigOwner) const;\n\n\tUE_DEPRECATED(5.3, \"This flavor of GetEntityTemplateChecked is deprecated. Use the one without the ConfigOwner parameter (now a property of the FMassEntityConfig itself)\")\n\tconst FMassEntityTemplate& GetEntityTemplateChecked(const UWorld& World, const UObject& ConfigOwner) const;\n\n\tUE_DEPRECATED(5.3, \"This flavor of ValidateEntityTemplate is deprecated. Use the one without the ConfigOwner parameter (now a property of the FMassEntityConfig itself)\")\n\tbool ValidateEntityTemplate(const UWorld& World, const UObject& ConfigOwner);\n\n\tbool IsEmpty() const { return Parent == nullptr && Traits.Num() == 0; }\n\n\tconst FGuid& GetGuid() const { return ConfigGuid; }\n\t\n#if WITH_EDITOR\n\t/** Needs to be called when the given config is being duplicated - ensured the ConfigGuid remains unique */\n\tvoid PostDuplicate(bool bDuplicateForPIE);\n\n\tUMassEntityTraitBase* FindMutableTrait(TSubclassOf<UMassEntityTraitBase> TraitClass, const bool bExactMatch = false);\n#endif // WITH_EDITOR\n\t\nprotected:\n\t/** Combines traits based on the config hierarchy and returns list of unique traits */\n\tvoid GetCombinedTraits(TArray<UMassEntityTraitBase*>& OutTraits) const;\n\n\t/** Looks for a trait of the indicated type, accepting all child classes as well, unless bExactMatch == true */\n\tUMassEntityTraitBase* FindTraitInternal(TSubclassOf<UMassEntityTraitBase> TraitClass, const bool bExactMatch = false) const;\n\n\t/** Combines traits based on the config hierarchy and returns list of unique traits */\n\tUE_DEPRECATED(5.3, \"This flavor of GetCombinedTraits is deprecated. Use the one without the ConfigOwner parameter (now a property of the FMassEntityConfig itself)\")\n\tvoid GetCombinedTraits(TArray<UMassEntityTraitBase*>& OutTraits, TArray<const UObject*>& Visited, const UObject& ConfigOwner) const;\n\n\t/** Reference to parent config asset */\n\tUPROPERTY(Category = \"Derived Traits\", EditAnywhere)\n\tTObjectPtr<const UMassEntityConfigAsset> Parent = nullptr;\n\n\t/** Array of unique traits of this config */\n\tUPROPERTY(Category = \"Traits\", EditAnywhere, Instanced)\n\tTArray<TObjectPtr<UMassEntityTraitBase>> Traits;\n\n\tUPROPERTY(transient)\n\tTObjectPtr<UObject> ConfigOwner = nullptr;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category=\"Mass\", meta = (IgnoreForMemberInitializationTest))\n\tFGuid ConfigGuid;\n\nprivate:\n\tvoid GetCombinedTraitsInternal(TArray<UMassEntityTraitBase*>& OutTraits, TArray<const UObject*>& Visited) const;\n\tconst FMassEntityTemplate* GetEntityTemplateInternal(const UWorld& World, FMassEntityTemplateID& TemplateIDOut) const;\n};\n\n/**\n * Agent Config asset allows to create shared configs that can be used as base for derived configs.\n * The asset can be used as is i.e. on a spawner, or you can use FMassEntityConfig to allow last minute changes at use site.\n */\nUCLASS(BlueprintType)\nclass MASSSPAWNER_API UMassEntityConfigAsset : public UDataAsset\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassEntityConfigAsset()\n\t\t: Config(*this)\n\t{}\n\n\t/** @return Agent config stored in this asset */\n\tconst FMassEntityConfig& GetConfig() const { return Config; }\n\n\t/** @return Mutable agent config stored in this asset */\n\tFMassEntityConfig& GetMutableConfig() { return Config; }\n\n\tconst FMassEntityTemplate& GetOrCreateEntityTemplate(const UWorld& World) const\n\t{\n\t\treturn Config.GetOrCreateEntityTemplate(World);\n\t}\n\n\tvoid DestroyEntityTemplate(const UWorld& World) const\n\t{\n\t\tConfig.DestroyEntityTemplate(World);\n\t}\n\n\t/** Looks for a trait of the indicated type, accepting all child classes as well, unless bExactMatch == true */\n\tconst UMassEntityTraitBase* FindTrait(TSubclassOf<UMassEntityTraitBase> TraitClass, const bool bExactMatch = false) const\n\t{\n\t\treturn Config.FindTrait(TraitClass, bExactMatch);\n\t}\n\n#if WITH_EDITOR\n\t/** Called upon asset's dupllication. Ensured the underlying config's ConfigGuid remains unique */\n\tvirtual void PostDuplicate(bool bDuplicateForPIE) override;\n\n\tUFUNCTION(CallInEditor, Category = \"Entity Config\")\n\tvoid ValidateEntityConfig();\n\n\t/**\n\t * Returns a mutable instance of given trait class. If an instance of the given class can be found in\n\t * the hosted FMassEntityConfig then that instance is returned. Otherwise one will be created, added to\n\t * the FMassEntityConfig and returned.\n\t */\n\tUMassEntityTraitBase* AddTrait(TSubclassOf<UMassEntityTraitBase> TraitClass);\n#endif // WITH_EDITOR\n\nprotected:\n\t/** The config described in this asset. */\n\tUPROPERTY(Category = \"Entity Config\", EditAnywhere)\n\tFMassEntityConfig Config;\n};",
      "lines": 172
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Public\\MassEntityEQSSpawnPointsGenerator.h",
      "extension": ".h",
      "size_bytes": 1253,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"CoreMinimal.h\"\n#include \"MassEntitySpawnDataGeneratorBase.h\"\n#include \"EnvironmentQuery/EnvQueryTypes.h\"\n#include \"MassEntityEQSSpawnPointsGenerator.generated.h\"\n\n/**\n * Describes the SpawnPoints Generator when we want to leverage the points given by an EQS Query\n */\nUCLASS(BlueprintType, meta=(DisplayName=\"EQS SpawnPoints Generator\"))\nclass MASSSPAWNER_API UMassEntityEQSSpawnPointsGenerator : public UMassEntitySpawnDataGeneratorBase\n{\t\n\tGENERATED_BODY()\n\npublic:\n\tUMassEntityEQSSpawnPointsGenerator();\n\t\n\tvirtual void Generate(UObject& QueryOwner, TConstArrayView<FMassSpawnedEntityType> EntityTypes, int32 Count, FFinishedGeneratingSpawnDataSignature& FinishedGeneratingSpawnPointsDelegate) const override;\n\nprotected:\n\n#if WITH_EDITOR\n\tvirtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;\n#endif\n\n\tvoid OnEQSQueryFinished(TSharedPtr<FEnvQueryResult> EQSResult, TArray<FMassEntitySpawnDataGeneratorResult> Results, FFinishedGeneratingSpawnDataSignature FinishedGeneratingSpawnPointsDelegate) const;\n\n\tUPROPERTY(Category = \"Query\", EditAnywhere)\n\tFEQSParametrizedQueryExecutionRequest EQSRequest;\n};\n",
      "lines": 33
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Public\\MassEntitySpawnDataGeneratorBase.h",
      "extension": ".h",
      "size_bytes": 2985,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"CoreMinimal.h\"\n#include \"StructUtils/InstancedStruct.h\"\n#include \"MassSpawnerTypes.h\"\n#include \"MassEntitySpawnDataGeneratorBase.generated.h\"\n\nclass UMassEntityConfigAsset;\nclass UMassProcessor;\n\n/**\n * The result of the spawn point generator.\n */\nUSTRUCT()\nstruct FMassEntitySpawnDataGeneratorResult\n{\n\tGENERATED_BODY()\n\n\t// Spawn data that is passed to the InitSpawnDataProcessor. E.g. the data could contain array of locations, one for each entity.\n\tUPROPERTY()\n\tFInstancedStruct SpawnData;\n\t\n\t// Processor that understands how to apply SpawnData to the spawned entities. \n\tUPROPERTY()\n\tTSubclassOf<UMassProcessor> SpawnDataProcessor;\n\n\t// Processors that are run for all entities after they entities for a MassSpawner are initialized.\n\tUPROPERTY()\n\tTArray<TSubclassOf<UMassProcessor>> PostSpawnProcessors;\n\n\t// Index in the EntityTypes array passed to Generate().\n\tUPROPERTY()\n\tint32 EntityConfigIndex = INDEX_NONE;\n\n\t// Number of entities to spawn.\n\tUPROPERTY()\n\tint32 NumEntities = 0;\n};\n\n\nDECLARE_DELEGATE_OneParam(FFinishedGeneratingSpawnDataSignature, TConstArrayView<FMassEntitySpawnDataGeneratorResult>);\n\n/**\n * Base class for Mass Entity Spawn Points Generator.\n * A Mass Spawn Points Generator can be of several type (EQS, ZoneGraph, Volume, Area, etc.)\n * The concept is to override the GenerateSpawnPoints() method and requesting a certain number of Spawn Point Locations to the method.\n */\nUCLASS(Abstract, Blueprintable, EditInlineNew)\nclass MASSSPAWNER_API UMassEntitySpawnDataGeneratorBase : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\n\t/** Generate \"Count\" number of SpawnPoints and return as a list of position\n\t * @param Count of point to generate\n\t * @param FinishedGeneratingSpawnPointsDelegate is the callback to call once the generation is done\n\t */\n\tvirtual void Generate(UObject& QueryOwner, TConstArrayView<FMassSpawnedEntityType> EntityTypes, int32 Count, FFinishedGeneratingSpawnDataSignature& FinishedGeneratingSpawnPointsDelegate) const PURE_VIRTUAL(UMassEntitySpawnDataGeneratorBase::GenerateSpawnPoints, );\n\n\t/** Populates empty generator results from EntityTypes based on the provided proportions. \n\t * @param SpawnCount How many entities to distributed among the EntityTypes\n\t * @param EntityTypes Types of entities to generate data for.\n\t * @param OutResults Generator result for each entity type that had > 0 entities assigned to it.\n\t */\n\tvoid BuildResultsFromEntityTypes(const int32 SpawnCount, TConstArrayView<FMassSpawnedEntityType> EntityTypes, TArray<FMassEntitySpawnDataGeneratorResult>& OutResults) const;\n\nprotected:\n\tint32 GetRandomSelectionSeed() const { return bUseCustomSeed ? RandomSelectionSeed : GFrameNumber; }\n\n\tUPROPERTY(Category = \"Query\", EditAnywhere, meta=(EditCondition=\"bUseCustomSeed\"))\n\tint32 RandomSelectionSeed = 0;\n\n\tUPROPERTY()\n\tuint8 bUseCustomSeed : 1;\n};\n",
      "lines": 78
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Public\\MassEntityTemplate.h",
      "extension": ".h",
      "size_bytes": 14344,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessingTypes.h\"\n#include \"MassEntityManager.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassTranslator.h\"\n#include \"Templates/SharedPointer.h\"\n#include \"Misc/Guid.h\"\n#include \"Hash/CityHash.h\"\n#include \"MassEntityTemplate.generated.h\"\n\n\nclass UMassEntityTraitBase;\nstruct FMassEntityView;\nstruct FMassEntityTemplateIDFactory;\nstruct FMassEntityTemplate;\n\n\n//ID of the template an entity is using\nUSTRUCT()\nstruct MASSSPAWNER_API FMassEntityTemplateID\n{\n\tGENERATED_BODY()\n\n\tFMassEntityTemplateID() \n\t\t: FlavorHash(0), TotalHash(InvalidHash)\n\t{}\n\nprivate:\n\tfriend FMassEntityTemplateIDFactory;\n\t// use FMassEntityTemplateIDFactory to access this constructor flavor\n\texplicit FMassEntityTemplateID(const FGuid& InGuid, const int32 InFlavorHash = 0)\n\t\t: ConfigGuid(InGuid), FlavorHash(InFlavorHash)\n\t{\n\t\t const uint64 GuidHash = CityHash64((char*)&ConfigGuid, sizeof(FGuid));\n\t\t TotalHash = CityHash128to64({GuidHash, (uint64)InFlavorHash});\n\t}\n\npublic:\n\tuint64 GetHash64() const \n\t{\n\t\treturn TotalHash;\n\t}\n\t\n\tvoid Invalidate()\n\t{\n\t\tTotalHash = InvalidHash;\n\t}\n\n\tbool operator==(const FMassEntityTemplateID& Other) const\n\t{\n\t\treturn (TotalHash == Other.TotalHash);\n\t}\n\t\n\tbool operator!=(const FMassEntityTemplateID& Other) const\n\t{\n\t\treturn !(*this == Other);\n\t}\n\n\t/** \n\t * Note that since the function is 32-hashing a 64-bit value it's not guaranteed to produce globally unique values.\n\t * But also note that it's still fine to use FMassEntityTemplateID as a TMap key type, since TMap is using 32bit hash\n\t * to assign buckets rather than identify individual values.\n\t */\n\tfriend uint32 GetTypeHash(const FMassEntityTemplateID& TemplateID)\n\t{\n\t\treturn GetTypeHash(TemplateID.TotalHash);\n\t}\n\n\tbool IsValid() const { return (TotalHash != InvalidHash); }\n\n\tFString ToString() const;\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, Category=\"Mass\")\n\tFGuid ConfigGuid;\n\n\tUPROPERTY()\n\tuint32 FlavorHash;\n\n\tUPROPERTY()\n\tuint64 TotalHash;\n\nprivate:\n\tstatic constexpr uint64 InvalidHash = 0;\n};\n\n\n/** \n * Serves as data used to define and build finalized FMassEntityTemplate instances. Describes composition and initial\n * values of fragments for entities created with this data, and lets users modify and extend the data. Once finalized as \n * FMassEntityTemplate the data will become immutable. \n */\nUSTRUCT()\nstruct MASSSPAWNER_API FMassEntityTemplateData\n{\n\tGENERATED_BODY()\n\n\ttypedef TFunction<void(UObject& /*Owner*/, FMassEntityView& /*EntityView*/, const EMassTranslationDirection /*CurrentDirection*/)> FObjectFragmentInitializerFunction;\n\n\tFMassEntityTemplateData() = default;\n\texplicit FMassEntityTemplateData(const FMassEntityTemplate& InFinalizedTemplate);\n\n\tbool IsEmpty() const { return Composition.IsEmpty(); }\n\n\tTConstArrayView<FObjectFragmentInitializerFunction> GetObjectFragmentInitializers() const { return ObjectInitializers; }\n\tconst FString& GetTemplateName() const { return TemplateName; }\n\tconst FMassArchetypeCompositionDescriptor& GetCompositionDescriptor() const { return Composition; }\n\tconst FMassArchetypeSharedFragmentValues& GetSharedFragmentValues() const { return SharedFragmentValues; }\n\tTConstArrayView<FInstancedStruct> GetInitialFragmentValues() const { return InitialFragmentValues; }\n\n\tTArray<FMassEntityTemplateData::FObjectFragmentInitializerFunction>& GetMutableObjectFragmentInitializers() { return ObjectInitializers; }\n\n\tvoid SetTemplateName(const FString& Name) { TemplateName = Name; }\n\t\n\ttemplate<typename T>\n\tvoid AddFragment()\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassFragment>::IsDerived, \"Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.\");\n\t\tComposition.Fragments.Add<T>();\n\t}\n\n\tvoid AddFragment(const UScriptStruct& FragmentType)\n\t{\n\t\tcheckf(FragmentType.IsChildOf(FMassFragment::StaticStruct()), TEXT(\"Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.\"));\n\t\tComposition.Fragments.Add(FragmentType);\n\t}\n\n\t// @todo this function is doing nothing if a given fragment's initial value has already been created. This seems inconsistent with the other AddFragment functions (especially AddFragment_GetRef).\n\tvoid AddFragment(FConstStructView Fragment)\n\t{\n\t\tconst UScriptStruct* FragmentType = Fragment.GetScriptStruct();\n\t\tcheckf(FragmentType && FragmentType->IsChildOf(FMassFragment::StaticStruct()), TEXT(\"Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.\"));\n\t\tif (!Composition.Fragments.Contains(*FragmentType))\n\t\t{\n\t\t\tComposition.Fragments.Add(*FragmentType);\n\t\t\tInitialFragmentValues.Emplace(Fragment);\n\t\t}\n\t\telse if (!InitialFragmentValues.ContainsByPredicate(FStructTypeEqualOperator(FragmentType)))\n\t\t{\n\t\t\tInitialFragmentValues.Emplace(Fragment);\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tT& AddFragment_GetRef()\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassFragment>::IsDerived, \"Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.\");\n\t\tif (!Composition.Fragments.Contains<T>())\n\t\t{\n\t\t\tComposition.Fragments.Add<T>();\n\t\t}\n\t\telse if (FInstancedStruct* Fragment = InitialFragmentValues.FindByPredicate(FStructTypeEqualOperator(T::StaticStruct())))\n\t\t{\n\t\t\treturn Fragment->template GetMutable<T>();\n\t\t}\n\n\t\t// Add a default initial fragment value\n\t\treturn InitialFragmentValues.Emplace_GetRef(T::StaticStruct()).template GetMutable<T>();\n\t}\n\n\ttemplate<typename T>\n\tT* GetMutableFragment()\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassFragment>::IsDerived, \"Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.\");\n\t\tFInstancedStruct* Fragment = InitialFragmentValues.FindByPredicate(FStructTypeEqualOperator(T::StaticStruct()));\n\t\treturn Fragment ? &Fragment->template GetMutable<T>() : (T*)nullptr;\n\t}\n\n\ttemplate<typename T>\n\tvoid AddTag()\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassTag>::IsDerived, \"Given struct doesn't represent a valid mass tag type. Make sure to inherit from FMassTag or one of its child-types.\");\n\t\tComposition.Tags.Add<T>();\n\t}\n\t\n\tvoid AddTag(const UScriptStruct& TagType)\n\t{\n\t\tcheckf(TagType.IsChildOf(FMassTag::StaticStruct()), TEXT(\"Given struct doesn't represent a valid mass tag type. Make sure to inherit from FMassTag or one of its child-types.\"));\n\t\tComposition.Tags.Add(TagType);\n\t}\n\n\ttemplate<typename T>\n\tvoid RemoveTag()\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassTag>::IsDerived, \"Given struct doesn't represent a valid mass tag type. Make sure to inherit from FMassTag or one of its child-types.\");\n\t\tComposition.Tags.Remove<T>();\n\t}\n\n\tvoid RemoveTag(const UScriptStruct& TagType)\n\t{\n\t\tcheckf(TagType.IsChildOf(FMassTag::StaticStruct()), TEXT(\"Given struct doesn't represent a valid mass tag type. Make sure to inherit from FMassTag or one of its child-types.\"));\n\t\tComposition.Tags.Remove(TagType);\n\t}\n\n\tconst FMassTagBitSet& GetTags() const { return Composition.Tags; }\n\tFMassTagBitSet& GetMutableTags() { return Composition.Tags; }\n\n\ttemplate<typename T>\n\tvoid AddChunkFragment()\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassChunkFragment>::IsDerived, \"Given struct doesn't represent a valid chunk fragment type. Make sure to inherit from FMassChunkFragment or one of its child-types.\");\n\t\tComposition.ChunkFragments.Add<T>();\n\t}\n\n\tvoid AddConstSharedFragment(const FConstSharedStruct& SharedFragment)\n\t{\n\t\tconst UScriptStruct* FragmentType = SharedFragment.GetScriptStruct();\n\t\tif(ensureMsgf(FragmentType && FragmentType->IsChildOf(FMassConstSharedFragment::StaticStruct()), TEXT(\"Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.\")))\n\t\t{\n\t\t\tif (!Composition.ConstSharedFragments.Contains(*FragmentType))\n\t\t\t{\n\t\t\t\tComposition.ConstSharedFragments.Add(*FragmentType);\n\t\t\t\tSharedFragmentValues.AddConstSharedFragment(SharedFragment);\n\t\t\t}\n#if DO_ENSURE\n\t\t\telse\n\t\t\t{\n\t\t\t\tconst FConstSharedStruct* Struct = SharedFragmentValues.GetConstSharedFragments().FindByPredicate(FStructTypeEqualOperator(SharedFragment));\n\t\t\t\tensureMsgf(Struct && *Struct == SharedFragment, TEXT(\"Adding 2 different const shared fragment of the same type is not allowed\"));\n\n\t\t\t}\n#endif // DO_ENSURE\n\t\t}\n\t}\n\n\tvoid AddSharedFragment(const FSharedStruct& SharedFragment)\n\t{\n\t\tconst UScriptStruct* FragmentType = SharedFragment.GetScriptStruct();\n\t\tif(ensureMsgf(FragmentType && FragmentType->IsChildOf(FMassSharedFragment::StaticStruct()), TEXT(\"Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.\")))\n\t\t{\n\t\t\tif (!Composition.SharedFragments.Contains(*FragmentType))\n\t\t\t{\n\t\t\t\tComposition.SharedFragments.Add(*FragmentType);\n\t\t\t\tSharedFragmentValues.AddSharedFragment(SharedFragment);\n\t\t\t}\n\t#if DO_ENSURE\n\t\t\telse\n\t\t\t{\n\t\t\t\tconst FSharedStruct* Struct = SharedFragmentValues.GetSharedFragments().FindByPredicate(FStructTypeEqualOperator(SharedFragment));\n\t\t\t\tensureMsgf(Struct && *Struct == SharedFragment, TEXT(\"Adding 2 different shared fragment of the same type is not allowed\"));\n\n\t\t\t}\n\t#endif // DO_ENSURE\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tbool HasFragment() const\n\t{\n\t\treturn Composition.Fragments.Contains<T>();\n\t}\n\t\n\tbool HasFragment(const UScriptStruct& ScriptStruct) const\n\t{\n\t\treturn Composition.Fragments.Contains(ScriptStruct);\n\t}\n\n\ttemplate<typename T>\n\tbool HasTag() const\n\t{\n\t\treturn Composition.Tags.Contains<T>();\n\t}\n\n\ttemplate<typename T>\n\tbool HasChunkFragment() const\n\t{\n\t\treturn Composition.ChunkFragments.Contains<T>();\n\t}\n\n\ttemplate<typename T>\n\tbool HasSharedFragment() const\n\t{\n\t\treturn Composition.SharedFragments.Contains<T>();\n\t}\n\n\tbool HasSharedFragment(const UScriptStruct& ScriptStruct) const\n\t{\n\t\treturn Composition.SharedFragments.Contains(ScriptStruct);\n\t}\n\n\ttemplate<typename T>\n\tbool HasConstSharedFragment() const\n\t{\n\t\treturn Composition.ConstSharedFragments.Contains<T>();\n\t}\n\n\tbool HasConstSharedFragment(const UScriptStruct& ScriptStruct) const\n\t{\n\t\treturn Composition.ConstSharedFragments.Contains(ScriptStruct);\n\t}\n\n\tvoid Sort()\n\t{\n\t\tSharedFragmentValues.Sort();\n\t}\n\n\t/** Compares contents of two archetypes (this and Other). Returns whether both are equivalent.\n\t *  @Note that the function can be slow, depending on how elaborate the template is. This function is meant for debugging purposes. */\n\tbool SlowIsEquivalent(const FMassEntityTemplateData& Other) const;\n\n\tFMassArchetypeCreationParams& GetArchetypeCreationParams() { return CreationParams; }\n\t\nprotected:\n\tFMassArchetypeCompositionDescriptor Composition;\n\tFMassArchetypeSharedFragmentValues SharedFragmentValues;\n\n\t// Initial fragment values, this is not part of the archetype as it is the spawner job to set them.\n\tTArray<FInstancedStruct> InitialFragmentValues;\n\n\t// These functions will be called to initialize entity's UObject-based fragments\n\tTArray<FObjectFragmentInitializerFunction> ObjectInitializers;\n\n\tFMassArchetypeCreationParams CreationParams;\n\n\tFString TemplateName;\n};\n\n/**\n * A finalized and const wrapper for FMassEntityTemplateData, associated with a Mass archetype and template ID. \n * Designed to never be changed. If a change is needed a copy of the hosted FMassEntityTemplateData needs to be made and \n * used to create another finalized FMassEntityTemplate (via FMassEntityTemplateManager).\n */\nstruct MASSSPAWNER_API FMassEntityTemplate final : public TSharedFromThis<FMassEntityTemplate> \n{\n\tfriend TSharedFromThis<FMassEntityTemplate>;\n\n\tFMassEntityTemplate() = default;\n\tFMassEntityTemplate(const FMassEntityTemplateData& InData, FMassEntityManager& EntityManager, FMassEntityTemplateID InTemplateID);\n\tFMassEntityTemplate(FMassEntityTemplateData&& InData, FMassEntityManager& EntityManager, FMassEntityTemplateID InTemplateID);\n\n\t/** InArchetype is expected to be valid. The function will crash-check it. */\n\tvoid SetArchetype(const FMassArchetypeHandle& InArchetype);\n\tconst FMassArchetypeHandle& GetArchetype() const { return Archetype; }\n\n\tbool IsValid() const { return Archetype.IsValid(); }\n\n\tvoid SetTemplateID(FMassEntityTemplateID InTemplateID) { TemplateID = InTemplateID; }\n\tFMassEntityTemplateID GetTemplateID() const { return TemplateID; }\n\n\tFString DebugGetDescription(FMassEntityManager* EntityManager = nullptr) const;\n\tFString DebugGetArchetypeDescription(FMassEntityManager& EntityManager) const;\n\n\tstatic TSharedRef<FMassEntityTemplate> MakeFinalTemplate(FMassEntityManager& EntityManager, FMassEntityTemplateData&& TempTemplateData, FMassEntityTemplateID InTemplateID);\n\n\t//-----------------------------------------------------------------------------\n\t// FMassEntityTemplateData getters\n\t//-----------------------------------------------------------------------------\n\tFORCEINLINE TConstArrayView<FMassEntityTemplateData::FObjectFragmentInitializerFunction> GetObjectFragmentInitializers() const { return TemplateData.GetObjectFragmentInitializers(); }\n\tFORCEINLINE const FString& GetTemplateName() const { return TemplateData.GetTemplateName(); }\n\tFORCEINLINE const FMassArchetypeCompositionDescriptor& GetCompositionDescriptor() const { return TemplateData.GetCompositionDescriptor(); }\n\tFORCEINLINE const FMassArchetypeSharedFragmentValues& GetSharedFragmentValues() const { return TemplateData.GetSharedFragmentValues(); }\n\tFORCEINLINE TConstArrayView<FInstancedStruct> GetInitialFragmentValues() const { return TemplateData.GetInitialFragmentValues(); }\n\n\tconst FMassEntityTemplateData& GetTemplateData() const { return TemplateData; }\n\nprivate:\n\tFMassEntityTemplateData TemplateData;\n\tFMassArchetypeHandle Archetype;\n\tFMassEntityTemplateID TemplateID;\n};\n\n\nstruct MASSSPAWNER_API FMassEntityTemplateIDFactory\n{\n\tstatic FMassEntityTemplateID Make(const FGuid& ConfigGuid);\n\tstatic FMassEntityTemplateID MakeFlavor(const FMassEntityTemplateID& SourceTemplateID, const int32 Flavor);\n};\n",
      "lines": 370
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Public\\MassEntityTemplateRegistry.h",
      "extension": ".h",
      "size_bytes": 14437,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/Object.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassEntityTemplate.h\"\n#include \"MassTranslator.h\"\n#include \"MassEntityTemplateRegistry.generated.h\"\n\n#define ENSURE_SUPPORTED_TRAIT_OPERATION() ensureMsgf(bBuildInProgress == false, TEXT(\"This method is not expected to be called as \"\\\n\t\"part of trait's BuildTemplate call. Traits are not supposed to add elements based on other traits due to arbitrary trait ordering.\"));\n\nclass UWorld;\nclass UMassEntityTraitBase;\n\nUSTRUCT()\nstruct MASSSPAWNER_API FMassMissingTraitMessage\n{\n\tGENERATED_BODY()\n\n#if WITH_EDITORONLY_DATA\n\texplicit FMassMissingTraitMessage(const UMassEntityTraitBase* InRequestingTrait = nullptr, const UStruct* InMissingType = nullptr, const UMassEntityTraitBase* InRemovedByTrait = nullptr)\n\t\t: RequestingTrait(InRequestingTrait), MissingType(InMissingType), RemovedByTrait(InRemovedByTrait)\n\t{}\n\n\tconst UMassEntityTraitBase* RequestingTrait = nullptr;\n\tconst UStruct* MissingType = nullptr;\n\t// if set indicates that the missing type has been explicitly removed by given trait.\n\tconst UMassEntityTraitBase* RemovedByTrait = nullptr;\n#endif // WITH_EDITORONLY_DATA\n};\n\nUSTRUCT()\nstruct MASSSPAWNER_API FMassDuplicateElementsMessage\n{\n\tGENERATED_BODY()\n#if WITH_EDITORONLY_DATA\n\tconst UMassEntityTraitBase* DuplicatingTrait = nullptr;\n\tconst UMassEntityTraitBase* OriginalTrait = nullptr;\n\tconst UStruct* Element = nullptr;\n#endif // WITH_EDITORONLY_DATA\n};\n\n#if WITH_EDITORONLY_DATA\nnamespace UE::Mass::Debug\n{\n\textern MASSSPAWNER_API const FName TraitFailedValidation;\n\textern MASSSPAWNER_API const FName TraitIgnored;\n}\n#endif // WITH_EDITORONLY_DATA\n\nenum class EFragmentInitialization : uint8\n{\n\tDefaultInitializer,\n\tNoInitializer\n};\n\nstruct FMassEntityTemplateBuildContext\n{\n\texplicit FMassEntityTemplateBuildContext(FMassEntityTemplateData& InTemplate, FMassEntityTemplateID InTemplateID = FMassEntityTemplateID())\n\t\t: TemplateData(InTemplate)\n\t\t, TemplateID(InTemplateID)\n\t{}\n\n\tvoid SetTemplateName(const FString& Name)\n\t{\n\t\tTemplateData.SetTemplateName(Name);\n\t}\n\n\t//----------------------------------------------------------------------//\n\t// Fragments \n\t//----------------------------------------------------------------------//\n\ttemplate<typename T>\n\tT& AddFragment_GetRef()\n\t{\n\t\tTypeAdded(*T::StaticStruct());\n\t\treturn TemplateData.AddFragment_GetRef<T>();\n\t}\n\n\ttemplate<typename T>\n\tvoid AddFragment()\n\t{\n\t\tTypeAdded(*T::StaticStruct());\n\t\tTemplateData.AddFragment<T>();\n\t}\n\n\tvoid AddFragment(FConstStructView InFragment)\n\t{ \n\t\tcheckf(InFragment.GetScriptStruct(), TEXT(\"Expecting a valid fragment type\"));\n\t\tTypeAdded(*InFragment.GetScriptStruct());\n\t\tTemplateData.AddFragment(InFragment);\n\t}\n\n\ttemplate<typename T>\n\tvoid AddTag()\n\t{\n\t\t// Tags can be added by multiple traits, so they do not follow the same rules as fragments\n\t\tTemplateData.AddTag<T>();\n\t\tTypeAdded(*T::StaticStruct());\n\t}\n\n\tvoid AddTag(const UScriptStruct& TagType)\n\t{\n\t\t// Tags can be added by multiple traits, so they do not follow the same rules as fragments\n\t\tTemplateData.AddTag(TagType);\n\t\tTypeAdded(TagType);\n\t}\n\n\ttemplate<typename T>\n\tvoid AddChunkFragment()\n\t{\n\t\tTypeAdded(*T::StaticStruct());\n\t\tTemplateData.AddChunkFragment<T>();\n\t}\n\n\tvoid AddConstSharedFragment(const FConstSharedStruct& InSharedFragment)\n\t{\n\t\tcheckf(InSharedFragment.GetScriptStruct(), TEXT(\"Expecting a valide shared fragment type\"));\n\t\tTypeAdded(*InSharedFragment.GetScriptStruct());\n\t\tTemplateData.AddConstSharedFragment(InSharedFragment);\n\t}\n\n\tvoid AddSharedFragment(const FSharedStruct& InSharedFragment)\n\t{\n\t\tcheckf(InSharedFragment.GetScriptStruct(), TEXT(\"Expecting a valide shared fragment type\"));\n\t\tTypeAdded(*InSharedFragment.GetScriptStruct());\n\t\tTemplateData.AddSharedFragment(InSharedFragment);\n\t}\n\n\t/**\n\t * Removes given tag from collected data. More precisely: it will store the information and apply upon template creation (an optimization). \n\t * WARNING: use with caution and only in cases where you know for certain what the given tag does and which processors rely on it.\n\t *\t\tUsing this functionality makes most sense for removing tags that specifically mean that entities having it are to be\n\t *\t\tprocessed by a given processor.\n\t */\n\tvoid RemoveTag(const UScriptStruct& TagType)\n\t{\n\t\tcheckf(TagType.IsChildOf(FMassTag::StaticStruct()), TEXT(\"Given struct doesn't represent a valid mass tag type. Make sure to inherit from FMassTag or one of its child-types.\"));\n\t\tRemovedTypes.Add({&TagType\n#if WITH_EDITORONLY_DATA\n\t\t\t, TraitsData.Last().Trait\n#endif // WITH_EDITORONLY_DATA\n\t\t});\n\t}\n\n\ttemplate<typename T>\n\tvoid RemoveTag()\n\t{\n\t\tRemoveTag(*T::StaticStruct());\n\t}\n\n\ttemplate<typename T>\n\tT* GetFragment()\n\t{\n\t\treturn TemplateData.GetMutableFragment<T>();\n\t}\n\n\ttemplate<typename T>\n\tbool HasFragment() const\n\t{\n\t\tENSURE_SUPPORTED_TRAIT_OPERATION();\n\t\treturn TemplateData.HasFragment<T>();\n\t}\n\t\n\tbool HasFragment(const UScriptStruct& ScriptStruct) const\n\t{\n\t\tENSURE_SUPPORTED_TRAIT_OPERATION();\n\t\treturn TemplateData.HasFragment(ScriptStruct);\n\t}\n\n\ttemplate<typename T>\n\tbool HasTag() const\n\t{\n\t\treturn TemplateData.HasTag<T>();\n\t}\n\n\ttemplate<typename T>\n\tbool HasChunkFragment() const\n\t{\n\t\tENSURE_SUPPORTED_TRAIT_OPERATION();\n\t\treturn TemplateData.HasChunkFragment<T>();\n\t}\n\n\ttemplate<typename T>\n\tbool HasSharedFragment() const\n\t{\n\t\tENSURE_SUPPORTED_TRAIT_OPERATION();\n\t\treturn TemplateData.HasSharedFragment<T>();\n\t}\n\n\tbool HasSharedFragment(const UScriptStruct& ScriptStruct) const\n\t{\n\t\tENSURE_SUPPORTED_TRAIT_OPERATION();\n\t\treturn TemplateData.HasSharedFragment(ScriptStruct);\n\t}\n\n\ttemplate<typename T>\n\tbool HasConstSharedFragment() const\n\t{\n\t\tENSURE_SUPPORTED_TRAIT_OPERATION();\n\t\treturn TemplateData.HasConstSharedFragment<T>();\n\t}\n\n\tbool HasConstSharedFragment(const UScriptStruct& ScriptStruct) const\n\t{\n\t\tENSURE_SUPPORTED_TRAIT_OPERATION();\n\t\treturn TemplateData.HasConstSharedFragment(ScriptStruct);\n\t}\n\n\t//----------------------------------------------------------------------//\n\t// Translators\n\t//----------------------------------------------------------------------//\n\ttemplate<typename T>\n\tvoid AddTranslator()\n\t{\n\t\tTypeAdded(*T::StaticClass());\n\t\tGetDefault<T>()->AppendRequiredTags(TemplateData.GetMutableTags());\n\t}\n\n\t//----------------------------------------------------------------------//\n\t// Dependencies\n\t//----------------------------------------------------------------------//\n\ttemplate<typename T>\n\tvoid RequireFragment()\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassTag>::IsDerived == false, \"Given struct type is a valid fragment type.\");\n\t\tAddDependency(T::StaticStruct());\n\t}\n\n\ttemplate<typename T>\n\tvoid RequireTag()\n\t{\n\t\tstatic_assert(TIsDerivedFrom<T, FMassTag>::IsDerived, \"Given struct type is not a valid tag type.\");\n\t\tAddDependency(T::StaticStruct());\n\t}\n\n\tvoid AddDependency(const UStruct* Dependency)\n\t{\n\t\tTraitsData.Last().TypesRequired.Add(Dependency);\n\t}\n\n\t//----------------------------------------------------------------------//\n\t// Template access\n\t//----------------------------------------------------------------------//\n\tFMassEntityTemplateID GetTemplateID() const { return TemplateID; }\n\tTArray<FMassEntityTemplateData::FObjectFragmentInitializerFunction>& GetMutableObjectFragmentInitializers() { return TemplateData.GetMutableObjectFragmentInitializers(); }\n\n\t//----------------------------------------------------------------------//\n\t// Build methods\n\t//----------------------------------------------------------------------//\n\n\t/**\n\t * Builds context from a list of traits\n\t * @param Traits is the list of all the traits to build an entity\n\t * @param World owning the MassEntitySubsystem for which the entity template is built\n\t * @return true if there were no validation errors\n\t */\n\tbool BuildFromTraits(TConstArrayView<UMassEntityTraitBase*> Traits, const UWorld& World);\n\n\t/** \n\t * The method that allows to distinguish between regular context use (using traits to build templates) and \n\t * the \"data investigation\" mode (used for debugging and authoring purposes). Utilize this function to \n\t * avoid UWorld-specific operations (like getting subsystems). This method should also be used when a trait \n\t * contains conditional logic - in that case it's required for the trait to add all the types that are potentially\n\t * added at runtime (even if seemingly conflicting information will be added). \n\t * \n\t * @return whether this context is in data inspection mode.\n\t */\n#if WITH_EDITORONLY_DATA\n\tbool IsInspectingData() const\n\t{\n\t\treturn bIsInspectingData;\n\t}\n#else\n\tconstexpr bool IsInspectingData() const\n\t{\n\t\treturn false;\n\t}\n#endif\n\n#if WITH_EDITORONLY_DATA\n\tvoid EnableDataInvestigationMode()\n\t{\n\t\tcheckf(TemplateData.IsEmpty(), TEXT(\"Marking a FMassEntityTemplateBuildContext as being in 'investigation mode` is only supported before the context is first used.\"));\n\t\tbIsInspectingData = true;\n\t}\n#endif // WITH_EDITORONLY_DATA\n\n\nprotected:\n\n\t/**\n\t * Validate the build context for fragment trait ownership and trait fragment missing dependency\n\t * @param World owning the MassEntitySubsystem for which the entity template is validated against\n\t * @return true if there were no validation errors\n\t */\n\tbool ValidateBuildContext(const UWorld& World);\n\n\tvoid TypeAdded(const UStruct& Type)\n\t{\n\t\tcheckf(TraitsData.Num(), TEXT(\"Adding elements to the build context before BuildFromTraits or SetTraitBeingProcessed was called is unsupported\"));\n\t\tTraitsData.Last().TypesAdded.Add(&Type);\n\t}\n\n\t/** \n\t * Return true if the given trait can be used. The function will fail if a trait instance of the given class has already \n\t * been processed. The function will also fail the very same trait instance is used multiple times.\n\t * Note that it's ok for Trait to be nullptr to indicate the subsequent additions to the build context are procedural\n\t * in nature and are not associated with any traits. In that case it's ok to have multiple SetTraitBeingProcessed(nullptr)\n\t * calls.\n\t */\n\tMASSSPAWNER_API bool SetTraitBeingProcessed(const UMassEntityTraitBase* Trait);\n\n\tvoid ResetBuildTimeData()\n\t{\n\t\tTraitsData.Reset();\n\t\tTraitsProcessed.Reset();\n\t\tIgnoredTraits.Reset();\n\t\tRemovedTypes.Reset();\n\t\tbBuildInProgress = false;\n\t}\n\n\tstruct FTraitData\n\t{\n\t\tconst UMassEntityTraitBase* Trait = nullptr;\n\t\tTArray<const UStruct*> TypesAdded;\n\t\tTArray<const UStruct*> TypesRequired;\n\t};\n\tTArray<FTraitData> TraitsData;\n\tTSet<const UMassEntityTraitBase*> TraitsProcessed;\n\tTSet<const UMassEntityTraitBase*> IgnoredTraits;\n\n\tstruct FRemovedType\n\t{\n\t\tconst UStruct* TypeRemoved = nullptr;\n#if WITH_EDITOR\n\t\tconst UMassEntityTraitBase* Remover = nullptr;\n#endif // WITH_EDITOR\n\t\tbool operator==(const FRemovedType& Other) const\n\t\t{\n\t\t\treturn TypeRemoved == Other.TypeRemoved;\n\t\t}\n\t};\n\t/**\n\t * These tags will be removed from the resulting entity template\n\t * @see RemoveTag for more details\n\t */\n\tTArray<FRemovedType> RemovedTypes;\n\n\tbool bBuildInProgress = false;\n\n\tFMassEntityTemplateData& TemplateData;\n\tFMassEntityTemplateID TemplateID;\n\n#if WITH_EDITORONLY_DATA\nprivate:\n\t/**\n\t * This being set to `true` indicates that the context is being used to gather information, not to create actual\n\t * entity templates.\n\t */\n\tbool bIsInspectingData = false;\n#endif // WITH_EDITORONLY_DATA\n};\n\n/** \n * Represents a repository storing all the FMassEntityTemplate that have been created and registered as part of FMassEntityConfig\n * processing or via custom code (like we do in InstancedActors plugin).\n */\nstruct MASSSPAWNER_API FMassEntityTemplateRegistry\n{\n\t// @todo consider TFunction instead\n\tDECLARE_DELEGATE_ThreeParams(FStructToTemplateBuilderDelegate, const UWorld* /*World*/, const FConstStructView /*InStructInstance*/, FMassEntityTemplateBuildContext& /*BuildContext*/);\n\n\texplicit FMassEntityTemplateRegistry(UObject* InOwner = nullptr);\n\n\t/** Initializes and stores the EntityManager the templates will be associated with. Needs to be called before any template operations.\n\t *  Note that the function will only let users set the EntityManager once. Once it's set the subsequent calls will\n\t *  have no effect. If attempting to set a different EntityManaget an ensure will trigger. */\n\tvoid Initialize(const TSharedPtr<FMassEntityManager>& InEntityManager);\n\n\tvoid ShutDown();\n\n\tUWorld* GetWorld() const;\n\n\tstatic FStructToTemplateBuilderDelegate& FindOrAdd(const UScriptStruct& DataType);\n\n\t/** Removes all the cached template instances */\n\tvoid DebugReset();\n\n\tconst TSharedRef<FMassEntityTemplate>* FindTemplateFromTemplateID(FMassEntityTemplateID TemplateID) const;\n\n\t/**\n\t * Adds a template based on TemplateData\n\t */\n\tconst TSharedRef<FMassEntityTemplate>& FindOrAddTemplate(FMassEntityTemplateID TemplateID, FMassEntityTemplateData&& TemplateData);\n\n\tUE_DEPRECATED(5.3, \"We no longer support fething mutable templates from the TemplateRegistry. Stored templates are considered const.\")\n\tFMassEntityTemplate* FindMutableTemplateFromTemplateID(FMassEntityTemplateID TemplateID);\n\n\tUE_DEPRECATED(5.3, \"CreateTemplate is no longer available. Use FindOrAddTemplate instead.\")\n\tFMassEntityTemplate& CreateTemplate(const uint32 HashLookup, FMassEntityTemplateID TemplateID);\n\n\tvoid DestroyTemplate(FMassEntityTemplateID TemplateID);\n\n\tUE_DEPRECATED(5.3, \"InitializeEntityTemplate is no longer available. Use FindOrAddTemplate instead.\")\n\tvoid InitializeEntityTemplate(FMassEntityTemplate& InOutTemplate) const;\n\n\tFMassEntityManager& GetEntityManagerChecked() { check(EntityManager); return *EntityManager; }\n\nprotected:\n\tstatic TMap<const UScriptStruct*, FStructToTemplateBuilderDelegate> StructBasedBuilders;\n\n\tTMap<FMassEntityTemplateID, TSharedRef<FMassEntityTemplate>> TemplateIDToTemplateMap;\n\n\t/** \n\t * EntityManager the hosted templates are associated with. Storing instead of fetching at runtime to ensure all \n\t *\ttemplates are tied to the same EntityManager\n\t */\n\tTSharedPtr<FMassEntityManager> EntityManager;\n\n\tTWeakObjectPtr<UObject> Owner;\n};\n\n#undef ENSURE_SUPPORTED_TRAIT_OPERATION\n",
      "lines": 426
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Public\\MassEntityTraitBase.h",
      "extension": ".h",
      "size_bytes": 3645,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassEntityTraitBase.generated.h\"\n\nstruct FMassEntityTemplateBuildContext;\n\n/**\n * Base class for Mass Entity Traits.\n * An entity trait is a set of fragments that create a logical trait tha makes sense to end use (i.e. replication, visualization).\n * The template building method allows to configure some fragments based on properties or cached values.\n * For example, a fragment can be added based on a referenced asset, or some memory hungry settings can be\n * cached and just and index stored on a fragment.\n */\nUCLASS(Abstract, BlueprintType, EditInlineNew, CollapseCategories)\nclass MASSSPAWNER_API UMassEntityTraitBase : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\t/** \n\t * This is a type wrapping an existing TArray to limit how users can interact with the contained data. \n\t * We essentially limit users to just adding elements, no other operations.\n\t */\n\tstruct FAdditionalTraitRequirements\n\t{\n\t\texplicit FAdditionalTraitRequirements(TArray<const UStruct*>& InTargetContainer)\n\t\t\t: TargetContainer(InTargetContainer)\n\t\t{\n\t\t}\n\t\t\n\t\t// Copying constructor and assignment deleted to prevent users storing copies of the type, \n\t\t// which wouldn't be safe due to this type hosting a reference to an array that can go out of scope.\n\t\tFAdditionalTraitRequirements(const FAdditionalTraitRequirements&) = delete;\n\t\tFAdditionalTraitRequirements& operator=(const FAdditionalTraitRequirements&) = delete;\n\n\t\tFAdditionalTraitRequirements& Add(const UScriptStruct* RequiredType)\n\t\t{\n\t\t\tTargetContainer.Add(RequiredType);\n\t\t\treturn *this;\n\t\t}\n\n\tprivate:\n\t\tTArray<const UStruct*>& TargetContainer;\n\t};\n\n\n\t/** Appends items into the entity template required for the trait. */\n\tvirtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const PURE_VIRTUAL(UMassEntityTraitBase::BuildTemplate, return; );\n\n\tUE_DEPRECATED(5.5, \"This flavor of DestroyTemplate has been deprecated, use the version taking the World parameter\")\n\tvirtual void DestroyTemplate() const;\n\n\tvirtual void DestroyTemplate(const UWorld& World) const {}\n\n\t/**\n\t * Called once all traits have been processed and fragment requirements have been checked. Override this function\n\t * to perform additional Trait's configuration validation. Returning `false` will indicate that the trait instance\n\t * is not happy with the validation results - this result will be treated as an error.\n\t * @param OutTraitRequirements contains requirements declared by this trait and gives ValidateTemplate a chance to add \n\t *\t\tto the dependencies based on the state of BuildContext, which by this point should contain all the elements \n\t *\t\tadded by all the relevant traits.\n\t * @return whether the validation was successful\n\t */\n\tvirtual bool ValidateTemplate(const FMassEntityTemplateBuildContext& BuildContext, const UWorld& World, FAdditionalTraitRequirements& OutTraitRequirements) const;\n\t\n\tUE_DEPRECATED(5.5, \"This flavor of ValidateTemplate is deprecated. Use the three-parameter one instead.\")\n\tvirtual bool ValidateTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const;\n\n#if WITH_EDITOR\n\tDECLARE_MULTICAST_DELEGATE_OneParam(FOnNewTraitType, UMassEntityTraitBase&);\n\tstatic FOnNewTraitType& GetOnNewTraitTypeEvent()\n\t{\n\t\treturn OnNewTraitTypeEvent;\n\t}\n\nprotected:\n\tvirtual void PostInitProperties() override;\n\nprivate:\n\tstatic FOnNewTraitType OnNewTraitTypeEvent;\n#endif // WITH_EDITOR\n};\n\n#if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_5\n#include \"CoreMinimal.h\"\n#endif\n",
      "lines": 88
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Public\\MassEntityZoneGraphSpawnPointsGenerator.h",
      "extension": ".h",
      "size_bytes": 1416,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"CoreMinimal.h\"\n#include \"MassEntitySpawnDataGeneratorBase.h\"\n#include \"ZoneGraphTypes.h\"\n\n#include \"MassEntityZoneGraphSpawnPointsGenerator.generated.h\"\n\nclass AZoneGraphData;\n\n/**\n * Describes the SpawnPoints Generator when we want to spawn directly on Zone Graph\n */\nUCLASS(BlueprintType, meta=(DisplayName=\"ZoneGraph SpawnPoints Generator\"))\nclass MASSSPAWNER_API UMassEntityZoneGraphSpawnPointsGenerator : public UMassEntitySpawnDataGeneratorBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tvirtual void Generate(UObject& QueryOwner, TConstArrayView<FMassSpawnedEntityType> EntityTypes, int32 Count, FFinishedGeneratingSpawnDataSignature& FinishedGeneratingSpawnPointsDelegate) const override;\n\nprotected:\n\tvoid GeneratePointsForZoneGraphData(const ::AZoneGraphData& ZoneGraphData, TArray<FVector>& Locations, const FRandomStream& RandomStream) const;\n\n\t/** Tags to filter which lane to use to generate points on */\n\tUPROPERTY(EditAnywhere, Category = \"ZoneGraph Generator Config\")\n\tFZoneGraphTagFilter TagFilter;\n\n\t/** Minimum gap for spawning entities on a given lanes */\n\tUPROPERTY(EditAnywhere, Category = \"ZoneGraph Generator Config\")\n\tfloat MinGap = 100;\n\n\t/** Maximum gap for spawning entities on a given lanes */\n\tUPROPERTY(EditAnywhere, Category = \"ZoneGraph Generator Config\")\n\tfloat MaxGap = 300;\n};\n",
      "lines": 38
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Public\\MassSpawner.h",
      "extension": ".h",
      "size_bytes": 5401,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"MassSpawnerTypes.h\"\n#include \"MassEntitySpawnDataGeneratorBase.h\"\n#include \"MassSpawner.generated.h\"\n\n\nstruct FStreamableHandle;\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FMassSpawnerOnSpawningFinishedEvent);\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FMassSpawnerOnDespawningFinishedEvent);\n\n/** A spawner you can put on a map and configure it to spawn different things */\nUCLASS(hidecategories = (Object, Actor, Input, Rendering, LOD, Cooking, Collision, HLOD, Partition))\nclass MASSSPAWNER_API AMassSpawner : public AActor\n{\n\tGENERATED_BODY()\npublic:\n\tAMassSpawner();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n\tvirtual void PostLoad() override;\n\tvirtual void PostRegisterAllComponents() override;\n\tvirtual void BeginDestroy() override;\n\npublic:\n#if WITH_EDITOR\n\tUFUNCTION(BlueprintCallable, CallInEditor, Category = \"Debug\")\n\tvoid DEBUG_Spawn();\n\n\t/** Remove all the entities */\n\tUFUNCTION(BlueprintCallable, CallInEditor, Category = \"Debug\")\n\tvoid DEBUG_Clear();\n#endif // WITH_EDITOR\n\nprotected:\n#if WITH_EDITOR\n\tvirtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;\n#endif // WITH_EDITOR\n\n\tvoid RegisterEntityTemplates();\n\npublic:\n\t/**\n\t * Starts the spawning of all the agent types of this spawner\n\t */\n\tUFUNCTION(BlueprintCallable, Category = \"Spawning\")\n\tvoid DoSpawning();\n\n\t/**\n\t * Despawn all mass agent that was spawned by this spawner\n\t */\n\tUFUNCTION(BlueprintCallable, Category = \"Spawning\")\n\tvoid DoDespawning();\n\n\t/**\n\t * Despawn all mass agent that was spawned by this spawner, except EntitiesToIgnore.\n\t *\n\t * Any EntitiesToIgnore previously spawned by this spawner will remain spawned and tracked by this spawner.   \n\t */\n\tvoid DoDespawning(TConstArrayView<FMassEntityHandle> EntitiesToIgnore);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Spawning\")\n\tvoid ClearTemplates();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Spawning\")\n\tvoid UnloadConfig();\n\n\t/**\n\t * If given entity has been spawned by this MassSpawner instance then it will get destroyed and all the book keeping \n\t * updated. Otherwise the call has no effect.\n\t * @return true if the entity got removed. False otherwise.\n\t */\n\tbool DespawnEntity(const FMassEntityHandle Entity);\n\n\t/**\n\t * Scales the spawning counts\n\t * @param Scale is the number to multiply the all counts of each agent types \n\t */\n\tUFUNCTION(BlueprintCallable, Category = \"Spawning\")\n\tvoid ScaleSpawningCount(float Scale) { SpawningCountScale = Scale; }\n\n\tUFUNCTION(BlueprintCallable, Category = \"Spawning\")\n\tint32 GetCount() const;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Spawning\")\n\tfloat GetSpawningCountScale() const;\n\n\t/** Called once DoSpawning completes and all entities have been spawned. */\n\tUPROPERTY(BlueprintAssignable)\n\tFMassSpawnerOnSpawningFinishedEvent OnSpawningFinishedEvent;\n\n\t/** Called once DoDespawning completes and all mass agents spawned by this spawner have been despawned. */\n\tUPROPERTY(BlueprintAssignable)\n\tFMassSpawnerOnDespawningFinishedEvent OnDespawningFinishedEvent; \n\nprotected:\n\tvoid OnPostWorldInit(UWorld* World, const UWorld::InitializationValues);\n\tvoid SpawnGeneratedEntities(TConstArrayView<FMassEntitySpawnDataGeneratorResult> Results);\n\tvoid OnSpawnDataGenerationFinished(TConstArrayView<FMassEntitySpawnDataGeneratorResult> Results, FMassSpawnDataGenerator* FinishedGenerator);\n\n\tint32 GetSpawnCount() const;\n\tUMassProcessor* GetPostSpawnProcessor(TSubclassOf<UMassProcessor> ProcessorClass);\n\nprotected:\n\n\tstruct FSpawnedEntities\n\t{\n\t\tFMassEntityTemplateID TemplateID;\n\t\tTArray<FMassEntityHandle> Entities;\n\t};\n\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Spawn\")\n\tint32 Count;\n\n\t/** Array of entity types to spawn. These define which entities to spawn. */\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category = \"Mass|Spawn\")\n\tTArray<FMassSpawnedEntityType> EntityTypes;\n\n\t/** Array of entity spawn generators. These define where to spawn entities. */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Spawn\")\n\tTArray<FMassSpawnDataGenerator> SpawnDataGenerators;\n\n\tUPROPERTY(Category = \"Mass|Spawn\", EditAnywhere)\n\tuint32 bAutoSpawnOnBeginPlay : 1;\n\n\t/** By default TickSchematics will be appended to the simulation's schematics. If this property is set to true the\n\t *  TickSchematics will override the original simulation schematics */\n\tUPROPERTY(Category = \"Mass|Simulation\", EditAnywhere)\n\tuint32 bOverrideSchematics : 1;\n\n\tUPROPERTY()\n\tTArray<TObjectPtr<UMassProcessor>> PostSpawnProcessors;\n\n\t/** Scale of the spawning count */\n\tUPROPERTY(EditAnywhere, Category = \"Mass|Spawn\")\n\tfloat SpawningCountScale = 1.0f;\n\n\tFDelegateHandle SimulationStartedHandle;\n\n\tFDelegateHandle OnPostWorldInitDelegateHandle;\n\n\tTArray<FSpawnedEntities> AllSpawnedEntities;\n\t\n\tTArray<FMassEntitySpawnDataGeneratorResult> AllGeneratedResults;\n\t\n\tTSharedPtr<FStreamableHandle> StreamingHandle;\n\n#if WITH_EDITORONLY_DATA\nprivate:\n\tUPROPERTY()\n\tTObjectPtr<UBillboardComponent> SpriteComponent;\n#endif // WITH_EDITORONLY_DATA\n };\n\nnamespace UE::MassSpawner\n{\n\tMASSSPAWNER_API extern float ScalabilitySpawnDensityMultiplier;\n}\n\n",
      "lines": 166
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Public\\MassSpawnerSubsystem.h",
      "extension": ".h",
      "size_bytes": 2943,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassEntityManager.h\"\n#include \"StructUtils/InstancedStruct.h\"\n#include \"MassSubsystemBase.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"MassSpawnerSubsystem.generated.h\"\n\nstruct FMassEntityManager;\nstruct FMassEntityTemplate;\nstruct FInstancedStruct;\nstruct FStructView;\nstruct FMassEntityTemplateID;\nclass UMassSimulationSubsystem;\n\nUCLASS()\nclass MASSSPAWNER_API UMassSpawnerSubsystem : public UMassSubsystemBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassSpawnerSubsystem();\n\n\t/** Spawns entities of the kind described by the given EntityTemplate. The spawned entities are fully initialized\n\t *  meaning the EntityTemplate.InitializationPipeline gets run for all spawned entities.\n\t *  @param EntityTemplate template to use for spawning entities\n\t *  @param NumberToSpawn number of entities to spawn\n\t *  @param OutEntities where the IDs of created entities get added. Note that the contents of OutEntities get overridden by the function.\n\t *  @return true if spawning was successful, false otherwise. In case of failure see logs for more details. */\n\tvoid SpawnEntities(const FMassEntityTemplate& EntityTemplate, const uint32 NumberToSpawn, TArray<FMassEntityHandle>& OutEntities);\n\n\tvoid SpawnEntities(FMassEntityTemplateID TemplateID, const uint32 NumberToSpawn, FConstStructView SpawnData, TSubclassOf<UMassProcessor> InitializerClass, TArray<FMassEntityHandle>& OutEntities);\n\n\tvoid DestroyEntities(TConstArrayView<FMassEntityHandle> Entities);\n\n\tUE_DEPRECATED(5.3, \"This flavor of DestroyEntities has been deprecated. Use the one without the FMassEntityTemplateID parameter\")\n\tvoid DestroyEntities(const FMassEntityTemplateID TemplateID, TConstArrayView<FMassEntityHandle> Entities)\n\t{\n\t\tDestroyEntities(Entities);\n\t}\n\n\tconst FMassEntityTemplateRegistry& GetTemplateRegistryInstance() const { return TemplateRegistryInstance; }\n\tFMassEntityTemplateRegistry& GetMutableTemplateRegistryInstance() { return TemplateRegistryInstance; }\n\n\tconst FMassEntityTemplate* GetMassEntityTemplate(FMassEntityTemplateID TemplateID) const;\n\n\tFMassEntityManager& GetEntityManagerChecked()\n\t{\n\t\tcheck(EntityManager.IsValid());\n\t\treturn *EntityManager.Get();\n\t}\n\nprotected:\n\t// UWorldSubsystem BEGIN\n\tvirtual void Initialize(FSubsystemCollectionBase& Collection) override;\n\tvirtual void Deinitialize() override;\n\t// UWorldSubsystem END\n\n\tvoid DoSpawning(const FMassEntityTemplate& EntityTemplate, const int32 NumToSpawn, FConstStructView SpawnData, TSubclassOf<UMassProcessor> InitializerClass, TArray<FMassEntityHandle>& OutEntities);\n\n\tUMassProcessor* GetSpawnDataInitializer(TSubclassOf<UMassProcessor> InitializerClass);\n\n\tUPROPERTY()\n\tTArray<TObjectPtr<UMassProcessor>> SpawnDataInitializers;\n\n\tTSharedPtr<FMassEntityManager> EntityManager;\n\n\tFMassEntityTemplateRegistry TemplateRegistryInstance;\n};\n\n",
      "lines": 72
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Public\\MassSpawnerTypes.h",
      "extension": ".h",
      "size_bytes": 3220,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"Logging/LogMacros.h\"\n#include \"MassEntityTemplate.h\"\n#include \"MassSpawnerTypes.generated.h\"\n\n\nDECLARE_LOG_CATEGORY_EXTERN(LogMassSpawner, Warning, All);\n\nclass APawn;\nclass UCurveFloat;\nclass UMassEntityConfigAsset;\nclass UMassEntitySpawnDataGeneratorBase;\nclass UMassEntityTraitBase;\n\nnamespace UE::MassSpawner\n{\n\tMASSSPAWNER_API uint32 HashTraits(TConstArrayView<UMassEntityTraitBase*> CombinedTraits);\n}\n\nUSTRUCT()\nstruct FMassTransformsSpawnData\n{\n\tGENERATED_BODY()\n\n\tFMassTransformsSpawnData()\n\t: bRandomize(true)\n\t{}\n\n\t// declaring the type used to be able to statically test it against other types \n\tusing FTransformsContainerType = TArray<FTransform>;\n\tFTransformsContainerType Transforms;\n\t\n\t// When true, Transforms will be assigned to entities as if pre-shuffled. \n\t// If Transforms >= Entities, this provides the best chance for a good spread of entity transforms \n\t// and transforms choices will be guaranteed unique. If Transforms < Entities, the same \n\t// transform will be used for multiple entities and a warning logged.\n\t//\n\t// When false, Transforms will be assigned in order to spawned entities.\n\tbool bRandomize : 1;\n};\n\n/**\n * Describes an entity type to spawn.\n */\nUSTRUCT(BlueprintType)\nstruct FMassSpawnedEntityType\n{\n\tGENERATED_BODY()\n\n\t/** Asset that describes the entity */\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category = \"Mass|Spawn\")\n\tTSoftObjectPtr<UMassEntityConfigAsset> EntityConfig;\n\n\t/** Proportion of the count that should be this agent type, (the proportions will be normalized with other sibling agent types) */\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category = \"Mass|Spawn\", meta = (ClampMin = 0.0f, UIMin = 0.0f))\n\tfloat Proportion = 1.0f;\n\t\n\tbool IsLoaded() const { return EntityConfigPtr != nullptr; }\n\n\tvoid UnloadEntityConfig()\n\t{\n\t\tEntityConfigPtr = nullptr;\n\t\tEntityConfig.ResetWeakPtr();\n\t}\n\n\tMASSSPAWNER_API const UMassEntityConfigAsset* GetEntityConfig() const;\n\tMASSSPAWNER_API UMassEntityConfigAsset* GetEntityConfig();\n\nprivate:\n\tUPROPERTY(Transient)\n\tmutable TObjectPtr<UMassEntityConfigAsset> EntityConfigPtr = nullptr;\n};\n\nUSTRUCT(BlueprintType)\nstruct FMassSpawnDataGenerator\n{\n\tGENERATED_BODY()\n\n\t/** The Generator to use to generate the spawn the points */\n\tUPROPERTY()\n\tTSubclassOf<UMassEntitySpawnDataGeneratorBase> GeneratorClass;\n\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Instanced, Category = \"Mass|Generator\")\n\tTObjectPtr<UMassEntitySpawnDataGeneratorBase> GeneratorInstance = nullptr;\n\n\t/** Proportion of the spawn points that should be generated by this generator, (the proportions will be normalized with other sibling generators) */\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category = \"Mass|Generator\", meta = (ClampMin = 0.0f, UIMin = 0.0f))\n\tfloat Proportion = 1.0f;\n\n\t/** Runtime value to know if we received the generated data for this generator */\n\tbool bDataGenerated = false;\n};\n\nUSTRUCT()\nstruct MASSSPAWNER_API FReplicationTemplateIDFragment : public FMassFragment\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(Transient)\n\tFMassEntityTemplateID ID;\n};\n",
      "lines": 104
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Public\\MassSpawnLocationProcessor.h",
      "extension": ".h",
      "size_bytes": 529,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once \n\n#include \"MassProcessor.h\"\n#include \"MassSpawnLocationProcessor.generated.h\"\n\nUCLASS()\nclass MASSSPAWNER_API UMassSpawnLocationProcessor : public UMassProcessor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMassSpawnLocationProcessor();\n\nprotected:\n\tvirtual void ConfigureQueries() override;\n\tvirtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;\n\n\tFMassEntityQuery EntityQuery;\n\tFRandomStream RandomStream;\n};\n",
      "lines": 22
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Public\\MassTranslator.h",
      "extension": ".h",
      "size_bytes": 1590,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"MassProcessor.h\"\n#include \"MassEntityTypes.h\"\n#include \"MassTranslator.generated.h\"\n\n\nUENUM()\nenum class EMassTranslationDirection : uint8\n{\n\tNone = 0,\n\tInitializationOnly = 1,\n\tActorToMass = 1 << 1,\n\tMassToActor = 1 << 2,\n\tBothWays = ActorToMass | MassToActor\n};\nENUM_CLASS_FLAGS(EMassTranslationDirection);\n\n/** \n *  A class that's responsible for translation between UObjects and Mass. A translator knows how to initialize \n *  fragments related to the UClass that the given translator cares about. It can also be used at runtime to \n *  copy values from UObjects to fragments and back.\n */\nUCLASS(abstract)\nclass MASSSPAWNER_API UMassTranslator : public UMassProcessor\n{\n\tGENERATED_BODY()\n\nprotected:\n\tUMassTranslator();\npublic:\n\t/** Fetches the FMassTag-derived types required by this Translator. And entity needs these tags to be \n\t *  processed by this Translator instance. \n\t * \n\t *  @todo might want this function on the MassProcessor level. TBD\n\t * \n\t *  @param OutTagTypes tag types will be appended to this array. No uniqueness checks are performed. */\n\tvoid AppendRequiredTags(FMassTagBitSet& InOutTags) const { InOutTags += RequiredTags; }\n\nprotected:\n\tvoid AddRequiredTagsToQuery(FMassEntityQuery& EntityQuery);\n\nprotected:\n\t/** These are the tag fragments expected by this translator that let other code (like entity traits) hint to \n\t *  the system which translators they'd want their entity to be processed by. */\n\tFMassTagBitSet RequiredTags;\n};\n",
      "lines": 49
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\MassBehaviorSettings.cpp",
      "extension": ".cpp",
      "size_bytes": 605,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassBehaviorSettings.h\"\n\n//----------------------------------------------------------------------//\n// UMassBehaviorSettings\n//----------------------------------------------------------------------//\n\nUMassBehaviorSettings::UMassBehaviorSettings(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n\t// Default values.\n\tMaxActivationsPerLOD[EMassLOD::High] = 100;\n\tMaxActivationsPerLOD[EMassLOD::Medium] = 100;\n\tMaxActivationsPerLOD[EMassLOD::Low] = 100;\n\tMaxActivationsPerLOD[EMassLOD::Off] = 100;\n}\n",
      "lines": 17
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\MassAIBehaviorModule.cpp",
      "extension": ".cpp",
      "size_bytes": 789,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CoreMinimal.h\"\n#include \"IMassAIBehaviorModule.h\"\n\n\nclass FMassAIBehaviorModule : public IMassAIBehaviorModule\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nIMPLEMENT_MODULE(FMassAIBehaviorModule, MassAIBehavior)\n\n\n\nvoid FMassAIBehaviorModule::StartupModule()\n{\n\t// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)\n}\n\n\nvoid FMassAIBehaviorModule::ShutdownModule()\n{\n\t// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n\t// we call this function before unloading the module.\n}\n\n\n\n",
      "lines": 31
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\MassAIBehaviorTypes.cpp",
      "extension": ".cpp",
      "size_bytes": 131,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassAIBehaviorTypes.h\"\n\nDEFINE_LOG_CATEGORY(LogMassBehavior);\n\n",
      "lines": 6
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\MassComponentHitSubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 5312,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassComponentHitSubsystem.h\"\n\n#include \"GameFramework/Pawn.h\"\n#include \"MassAgentComponent.h\"\n#include \"MassAgentSubsystem.h\"\n#include \"MassSignalSubsystem.h\"\n#include \"MassSimulationSubsystem.h\"\n#include \"Components/CapsuleComponent.h\"\n\nnamespace UE::MassComponentHit\n{\n\nbool bOnlyProcessHitsFromPlayers = true;\n\nFAutoConsoleVariableRef ConsoleVariables[] =\n{\n\tFAutoConsoleVariableRef(\n\t\tTEXT(\"ai.mass.OnlyProcessHitsFromPlayers\"),\n\t\tbOnlyProcessHitsFromPlayers,\n\t\tTEXT(\"Activates extra filtering to ignore hits from actors that are not controlled by the player.\"),\n\t\tECVF_Cheat)\n};\n\n} // UE::MassComponentHit\n\nvoid UMassComponentHitSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tSuper::Initialize(Collection);\n\tCollection.InitializeDependency<UMassSimulationSubsystem>();\n\n\tSignalSubsystem = Collection.InitializeDependency<UMassSignalSubsystem>();\n\tcheckfSlow(SignalSubsystem != nullptr, TEXT(\"MassSignalSubsystem is required\"));\n\n\tAgentSubsystem = Collection.InitializeDependency<UMassAgentSubsystem>();\n\tcheckfSlow(AgentSubsystem != nullptr, TEXT(\"MassAgentSubsystem is required\"));\n\n\tAgentSubsystem->GetOnMassAgentComponentEntityAssociated().AddLambda([this](const UMassAgentComponent& AgentComponent)\n\t{\n\t\tif (UCapsuleComponent* CapsuleComponent = AgentComponent.GetOwner()->FindComponentByClass<UCapsuleComponent>())\n\t\t{\n\t\t\tRegisterForComponentHit(AgentComponent.GetEntityHandle(), *CapsuleComponent);\n\t\t}\n\t});\n\n\tAgentSubsystem->GetOnMassAgentComponentEntityDetaching().AddLambda([this](const UMassAgentComponent& AgentComponent)\n\t{\n\t\tif (UCapsuleComponent* CapsuleComponent = AgentComponent.GetOwner()->FindComponentByClass<UCapsuleComponent>())\n\t\t{\n\t\t\tUnregisterForComponentHit(AgentComponent.GetEntityHandle(), *CapsuleComponent);\n\t\t}\n\t});\n}\n\nvoid UMassComponentHitSubsystem::Deinitialize()\n{\n\tcheckfSlow(AgentSubsystem != nullptr, TEXT(\"MassAgentSubsystem must have be set during initialization\"));\n\tAgentSubsystem->GetOnMassAgentComponentEntityAssociated().RemoveAll(this);\n\tAgentSubsystem->GetOnMassAgentComponentEntityDetaching().RemoveAll(this);\n\n\tSuper::Deinitialize();\n}\n\nvoid UMassComponentHitSubsystem::RegisterForComponentHit(const FMassEntityHandle Entity, UCapsuleComponent& CapsuleComponent)\n{\n\tEntityToComponentMap.Add(Entity, &CapsuleComponent);\n\tComponentToEntityMap.Add(&CapsuleComponent, Entity);\n\tCapsuleComponent.OnComponentHit.AddDynamic(this, &UMassComponentHitSubsystem::OnHitCallback);\n}\n\nvoid UMassComponentHitSubsystem::UnregisterForComponentHit(const FMassEntityHandle Entity, UCapsuleComponent& CapsuleComponent)\n{\n\tEntityToComponentMap.Remove(Entity);\n\tComponentToEntityMap.Remove(&CapsuleComponent);\n\tCapsuleComponent.OnComponentHit.RemoveAll(this);\n}\n\nvoid UMassComponentHitSubsystem::OnHitCallback(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tconst UWorld* World = GetWorld();\n\tcheck(World);\n\tconst FMassEntityHandle Entity = ComponentToEntityMap.FindChecked(HitComp);\n\tFMassEntityHandle* OtherEntity = ComponentToEntityMap.Find(OtherComp);\n\n\tbool bProcessHit = (OtherEntity != nullptr && OtherEntity->IsSet());\n\tif (bProcessHit && UE::MassComponentHit::bOnlyProcessHitsFromPlayers)\n\t{\n\t\tconst APawn* HitActorAsPawn = (HitComp != nullptr) ? Cast<APawn>(HitComp->GetOwner()) : nullptr;\n\t\tconst APawn* OtherAsPawn = Cast<APawn>(OtherActor);\n\t\tbProcessHit = (HitActorAsPawn != nullptr && HitActorAsPawn->IsPlayerControlled()) || (OtherAsPawn != nullptr && OtherAsPawn->IsPlayerControlled());\n\t}\n\n\tconst double CurrentTime = World->GetTimeSeconds();\n\n\t// If new hit result comes during this duration, it will be merged to existing one.\n\tconstexpr double HitResultMergeDuration = 1.;\n\tif (bProcessHit)\n\t{\n\t\tFMassHitResult* ExistingHitResult = HitResults.Find(Entity);\n\t\tif (ExistingHitResult)\n\t\t{\n\t\t\tconst double TimeSinceLastHit = CurrentTime - ExistingHitResult->LastFilteredHitTime;\n\t\t\tif (TimeSinceLastHit < HitResultMergeDuration)\n\t\t\t{\n\t\t\t\tExistingHitResult->LastFilteredHitTime = CurrentTime;\n\t\t\t\tbProcessHit = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bProcessHit)\n\t{\n\t\tHitResults.Add(Entity, {*OtherEntity, CurrentTime});\n\n\t\tcheckfSlow(SignalSubsystem != nullptr, TEXT(\"MassSignalSubsystem must have be set during initialization\"));\n\t\tSignalSubsystem->SignalEntity(UE::Mass::Signals::HitReceived, Entity);\n\t}\n}\n\nconst FMassHitResult* UMassComponentHitSubsystem::GetLastHit(const FMassEntityHandle Entity) const\n{\n\treturn HitResults.Find(Entity);\n}\n\nvoid UMassComponentHitSubsystem::Tick(float DeltaTime)\n{\n\tconst UWorld* World = GetWorld();\n\tcheck(World);\n\n\tconst double CurrentTime = World->GetTimeSeconds();\n\tconstexpr double HitResultDecayDuration = 1.;\n\t\n\tfor (auto Iter = HitResults.CreateIterator(); Iter; ++Iter)\n\t{\n\t\tconst FMassHitResult& HitResult = Iter.Value();\n\t\tconst double ElapsedTime = CurrentTime - HitResult.LastFilteredHitTime;\n\t\tif (ElapsedTime > HitResultDecayDuration)\n\t\t{\n\t\t\tIter.RemoveCurrent();\n\t\t}\n\t}\n}\n\nTStatId UMassComponentHitSubsystem::GetStatId() const\n{\n\tRETURN_QUICK_DECLARE_CYCLE_STAT(UMassComponentHitSubsystem, STATGROUP_Tickables);\n}\n",
      "lines": 148
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\MassLookAtFragments.cpp",
      "extension": ".cpp",
      "size_bytes": 2868,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassLookAtFragments.h\"\n#include \"ZoneGraphSubsystem.h\"\n#include \"ZoneGraphTypes.h\"\n#include \"Curves/BezierUtilities.h\"\n\nFVector FMassLookAtTrajectoryFragment::GetPointAtDistanceExtrapolated(const float DistanceAlongPath) const\n{\n\tif (NumPoints == 0)\n\t{\n\t\treturn FVector::ZeroVector;\n\t}\n\n\tif (NumPoints == 1)\n\t{\n\t\tconst float ExtrapolatedDistance = DistanceAlongPath - Points[0].DistanceAlongLane.Get();\n\t\tconst FMassLookAtTrajectoryPoint& Point = Points[0];\n\t\treturn Point.Position + FVector(Point.Tangent.Get() * ExtrapolatedDistance, 0.0f);\n\t}\n\n\t// Extrapolate along tangents if out of bounds.\n\tconst float StartDistance = Points[0].DistanceAlongLane.Get();\n\tif (DistanceAlongPath < StartDistance)\n\t{\n\t\tconst float ExtrapolatedDistance = DistanceAlongPath - StartDistance;\n\t\tconst FMassLookAtTrajectoryPoint& Point = Points[0];\n\t\treturn Point.Position + FVector(Point.Tangent.Get() * ExtrapolatedDistance, 0.0f);\n\t}\n\n\tconst int32 LastPointIndex = NumPoints - 1;\n\tconst float EndDistance = Points[LastPointIndex].DistanceAlongLane.Get();\n\tif (DistanceAlongPath > EndDistance)\n\t{\n\t\tconst float ExtrapolatedDistance = DistanceAlongPath - EndDistance;\n\t\tconst FMassLookAtTrajectoryPoint& Point = Points[LastPointIndex];\n\t\treturn Point.Position + FVector(Point.Tangent.Get() * ExtrapolatedDistance, 0.0f);\n\t}\n\n\tcheck(NumPoints >= 2);\n\n\t// Find segment \n\tint32 SegmentIndex = 0;\n\twhile (SegmentIndex < ((int32)NumPoints - 2))\n\t{\n\t\tconst float SegmentEndDistance = Points[SegmentIndex + 1].DistanceAlongLane.Get();\n\t\tif (DistanceAlongPath < SegmentEndDistance)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tSegmentIndex++;\n\t}\n\n\tcheck(SegmentIndex >= 0 && SegmentIndex <= (int32)NumPoints - 2);\n\n\t// Interpolate\n\tconst FMassLookAtTrajectoryPoint& StartPoint = Points[SegmentIndex];\n\tconst FMassLookAtTrajectoryPoint& EndPoint = Points[SegmentIndex + 1];\n\n\tconst float SegStartDistance = StartPoint.DistanceAlongLane.Get();\n\tconst float SegEndDistance = EndPoint.DistanceAlongLane.Get();\n\tconst float SegLength = SegEndDistance - SegStartDistance;\n\tconst float InvSegLength = SegLength > KINDA_SMALL_NUMBER ? 1.0f / SegLength : 0.0f;\n\tconst float T = FMath::Clamp((DistanceAlongPath - SegStartDistance) * InvSegLength, 0.0f, 1.0f);\n\n\t// 1/3 third is used to create smooth bezier curve. On linear segments 1/3 will result linear interpolation.\n\tconst FVector::FReal TangentDistance = FVector::Dist(StartPoint.Position, EndPoint.Position) / 3.;\n\tconst FVector StartControlPoint = StartPoint.Position + StartPoint.Tangent.GetVector() * TangentDistance;\n\tconst FVector EndControlPoint = EndPoint.Position - EndPoint.Tangent.GetVector() * TangentDistance;\n\n\treturn UE::CubicBezier::Eval(StartPoint.Position, StartControlPoint, EndControlPoint, EndPoint.Position, T);\n}\n",
      "lines": 72
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\MassLookAtProcessors.cpp",
      "extension": ".cpp",
      "size_bytes": 23484,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassLookAtProcessors.h\"\n#include \"MassEntityView.h\"\n#include \"MassAIBehaviorTypes.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassLookAtFragments.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassNavigationFragments.h\"\n#include \"MassNavigationSubsystem.h\"\n#include \"MassRepresentationFragments.h\"\n#include \"Math/UnrealMathUtility.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"ZoneGraphSubsystem.h\"\n#include \"ZoneGraphQuery.h\"\n#include \"Curves/BezierUtilities.h\"\n#include \"Algo/RandomShuffle.h\"\n#include \"Engine/World.h\"\n#include \"MassLODFragments.h\"\n#include \"MassGameplayExternalTraits.h\"\n#include \"MassDebugger.h\"\n\n\n#define UNSAFE_FOR_MT 1\n\nnamespace UE::MassBehavior\n{\n\tnamespace Tweakables\n\t{\n\t\tfloat TrajectoryLookAhead = 600.f;\n\t}\n\n\tFAutoConsoleVariableRef CVars[] =\n\t{\n\t\tFAutoConsoleVariableRef(TEXT(\"ai.mass.LookAt.TrajectoryLookAhead\"), Tweakables::TrajectoryLookAhead,\n\t\t\t\t\t\t\t\tTEXT(\"Distance (in cm) further along the look at trajectory (based on current path) to lookat while moving.\"), ECVF_Cheat),\n\t};\n\n\t\n\t// Clamps direction vector to a cone specified by the cone angle along X-axis\n\tFVector ClampDirectionToXAxisCone(const FVector Direction, const float ConeAngle)\n\t{\n\t\tFVector::FReal ConeSin = 0., ConeCos = 0.;\n\t\tFMath::SinCos(&ConeSin, &ConeCos, ConeAngle);\n\t\t\n\t\tconst FVector::FReal AngleCos = Direction.X; // Same as FVector::DotProduct(FVector::ForwardVector, Direction);\n\t\tif (AngleCos < ConeCos)\n\t\t{\n\t\t\tconst FVector::FReal DistToRimSq = FMath::Square(Direction.Y) + FMath::Square(Direction.Z);\n\t\t\tconst FVector::FReal InvDistToRim = DistToRimSq > KINDA_SMALL_NUMBER ? (1. / FMath::Sqrt(DistToRimSq)) : 0.;\n\t\t\treturn FVector(ConeCos, Direction.Y * InvDistToRim * ConeSin, Direction.Z * InvDistToRim * ConeSin);\n\t\t}\n\t\t\n\t\treturn Direction;\n\t}\n\n\tfloat GazeEnvelope(const float GazeTime, const float GazeDuration, const EMassLookAtGazeMode Mode)\n\t{\n\t\tif (GazeDuration < KINDA_SMALL_NUMBER || Mode == EMassLookAtGazeMode::None)\n\t\t{\n\t\t\treturn 0.0f;\n\t\t}\n\n\t\tif (Mode == EMassLookAtGazeMode::Constant)\n\t\t{\n\t\t\treturn 1.0;\n\t\t}\n\n\t\t// @todo: mae configurable\n\t\tconst float SustainTime = GazeDuration * 0.25f;\n\t\tconst float DecayTime = GazeDuration * 0.45f;\n\t\t\n\t\tif (GazeTime < SustainTime)\n\t\t{\n\t\t\treturn 1.0f;\n\t\t}\n\t\tif (GazeTime > DecayTime)\n\t\t{\n\t\t\treturn 0.0f;\n\t\t}\n\t\t\n\t\tconst float Duration = FMath::Max(KINDA_SMALL_NUMBER, DecayTime - SustainTime);\n\t\tconst float NormTime = FMath::Clamp((GazeTime - SustainTime) / Duration, 0.0f, 1.0f);\n\t\treturn 1.0f - NormTime;\n\t}\n\n}// namespace UE::MassBehavior\n\n\n//----------------------------------------------------------------------//\n// UMassLookAtProcessor\n//----------------------------------------------------------------------//\nUMassLookAtProcessor::UMassLookAtProcessor()\n\t: EntityQuery_Conditional(*this)\n{\n\tExecutionFlags = (int32)(EProcessorExecutionFlags::Client | EProcessorExecutionFlags::Standalone);\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Tasks;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Representation);\n}\n\nvoid UMassLookAtProcessor::ConfigureQueries()\n{\n\tEntityQuery_Conditional.AddRequirement<FMassLookAtFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery_Conditional.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery_Conditional.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery_Conditional.AddRequirement<FMassZoneGraphLaneLocationFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tEntityQuery_Conditional.AddRequirement<FMassLookAtTrajectoryFragment>(EMassFragmentAccess::ReadWrite, EMassFragmentPresence::Optional);\n\tEntityQuery_Conditional.AddRequirement<FMassZoneGraphShortPathFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tEntityQuery_Conditional.AddTagRequirement<FMassMediumLODTag>(EMassFragmentPresence::None);\n\tEntityQuery_Conditional.AddTagRequirement<FMassLowLODTag>(EMassFragmentPresence::None);\n\tEntityQuery_Conditional.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);\n\tEntityQuery_Conditional.AddChunkRequirement<FMassVisualizationChunkFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery_Conditional.SetChunkFilter(&FMassVisualizationChunkFragment::AreAnyEntitiesVisibleInChunk);\n\tEntityQuery_Conditional.AddSubsystemRequirement<UMassNavigationSubsystem>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery_Conditional.AddSubsystemRequirement<UZoneGraphSubsystem>(EMassFragmentAccess::ReadOnly);\n}\n\nvoid UMassLookAtProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tQUICK_SCOPE_CYCLE_COUNTER(LookAtProcessor_Run);\n\n\tconst double CurrentTime = GetWorld()->GetTimeSeconds();\n\n\tEntityQuery_Conditional.ForEachEntityChunk(EntityManager, Context, [this, &EntityManager, CurrentTime](FMassExecutionContext& Context)\n\t\t{\n\t\t\tconst UMassNavigationSubsystem& MassNavSystem = Context.GetSubsystemChecked<UMassNavigationSubsystem>();\n\t\t\tconst UZoneGraphSubsystem& ZoneGraphSubsystem = Context.GetSubsystemChecked<UZoneGraphSubsystem>();\n\n\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\tconst TArrayView<FMassLookAtFragment> LookAtList = Context.GetMutableFragmentView<FMassLookAtFragment>();\n\t\t\tconst TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();\n\t\t\tconst TConstArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetFragmentView<FMassMoveTargetFragment>();\n\t\t\tconst TConstArrayView<FMassZoneGraphLaneLocationFragment> ZoneGraphLocationList = Context.GetFragmentView<FMassZoneGraphLaneLocationFragment>();\n\t\t\tconst TConstArrayView<FMassZoneGraphShortPathFragment> ShortPathList = Context.GetFragmentView<FMassZoneGraphShortPathFragment>();\n\t\t\tconst TArrayView<FMassLookAtTrajectoryFragment> LookAtTrajectoryList = Context.GetMutableFragmentView<FMassLookAtTrajectoryFragment>();\n\n\t\t\tfor (int32 i = 0; i < NumEntities; ++i)\n\t\t\t{\n\t\t\t\tFMassLookAtFragment& LookAt = LookAtList[i];\n\t\t\t\tconst FMassMoveTargetFragment& MoveTarget = MoveTargetList[i];\n\t\t\t\tconst FTransformFragment& TransformFragment = TransformList[i];\n\n\t\t\t\tconst bool bHasLookAtTrajectory = ZoneGraphLocationList.Num() > 0 && LookAtTrajectoryList.Num() > 0 && ShortPathList.Num() > 0;\n\n\t\t\t\tbool bDisplayDebug = false;\n\t\t\t\tconst FMassEntityHandle Entity = Context.GetEntity(i);\n\t#if WITH_MASSGAMEPLAY_DEBUG\n\t\t\t\tFColor EntityColor = FColor::White;\n\t\t\t\tbDisplayDebug = UE::Mass::Debug::IsDebuggingEntity(Entity, &EntityColor);\n\t#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t\t\t\t// Update gaze target when current cycle is finished.\n\t\t\t\tif (LookAt.RandomGazeMode != EMassLookAtGazeMode::None)\n\t\t\t\t{\n\t\t\t\t\tconst double TimeSinceUpdate = CurrentTime - LookAt.GazeStartTime;\n\t\t\t\t\tif (TimeSinceUpdate >= LookAt.GazeDuration)\n\t\t\t\t\t{\n\t\t\t\t\t\tFindNewGazeTarget(MassNavSystem, EntityManager, CurrentTime, TransformFragment.GetTransform(), LookAt);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Update specific look at mode.\n\t\t\t\tLookAt.Direction = FVector::ForwardVector;\n\n\t\t\t\tswitch (LookAt.LookAtMode)\n\t\t\t\t{\n\t\t\t\tcase EMassLookAtMode::LookForward:\n\t\t\t\t\t// Empty, forward set already above.\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase EMassLookAtMode::LookAlongPath:\n\t\t\t\t\tif (bHasLookAtTrajectory)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst FMassZoneGraphLaneLocationFragment& ZoneGraphLocation = ZoneGraphLocationList[i];\n\t\t\t\t\t\tFMassLookAtTrajectoryFragment& LookAtTrajectory = LookAtTrajectoryList[i];\n\n\t\t\t\t\t\tif (MoveTarget.GetCurrentActionID() != LookAt.LastSeenActionID)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst FMassZoneGraphLaneLocationFragment& LaneLocation = ZoneGraphLocationList[i];\n\t\t\t\t\t\t\tconst FMassZoneGraphShortPathFragment& ShortPath = ShortPathList[i];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tBuildTrajectory(ZoneGraphSubsystem, LaneLocation, ShortPath, Entity, bDisplayDebug, LookAtTrajectory);\n\t\t\t\t\t\t\tLookAt.LastSeenActionID = MoveTarget.GetCurrentActionID();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tUpdateLookAtTrajectory(TransformFragment.GetTransform(), ZoneGraphLocation, LookAtTrajectory, bDisplayDebug, LookAt);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase EMassLookAtMode::LookAtEntity:\n\t\t\t\t\tUpdateLookAtTrackedEntity(EntityManager, TransformFragment.GetTransform(), bDisplayDebug, LookAt);\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Apply gaze\n\t\t\t\tif (LookAt.RandomGazeMode != EMassLookAtGazeMode::None)\n\t\t\t\t{\n\t\t\t\t\tconst float TimeSinceUpdate = FloatCastChecked<float>(CurrentTime - LookAt.GazeStartTime, /* Precision */ 1./64.);\n\t\t\t\t\tconst float GazeStrength = UE::MassBehavior::GazeEnvelope(TimeSinceUpdate, LookAt.GazeDuration, LookAt.RandomGazeMode);\n\n\t\t\t\t\tif (GazeStrength > KINDA_SMALL_NUMBER)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst bool bHasTarget = UpdateGazeTrackedEntity(EntityManager, TransformFragment.GetTransform(), bDisplayDebug, LookAt);\n\n\t\t\t\t\t\tif (bHasTarget)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Treat target gaze as absolute direction.\n\t\t\t\t\t\t\tLookAt.Direction = FMath::Lerp(LookAt.Direction, LookAt.GazeDirection, GazeStrength).GetSafeNormal();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Treat random offset as relative direction.\n\t\t\t\t\t\t\tconst FQuat GazeRotation = FQuat::FindBetweenNormals(FVector::ForwardVector, FMath::Lerp(FVector::ForwardVector, LookAt.GazeDirection, GazeStrength).GetSafeNormal());\n\t\t\t\t\t\t\tLookAt.Direction = GazeRotation.RotateVector(LookAt.Direction);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Clamp\n\t\t\t\tLookAt.Direction = UE::MassBehavior::ClampDirectionToXAxisCone(LookAt.Direction, FMath::DegreesToRadians(AngleThresholdInDegrees));\n\n\t#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT\n\t\t\t\tif (bDisplayDebug)\n\t\t\t\t{\n\t\t\t\t\tconst FVector Origin = TransformFragment.GetTransform().GetLocation() + FVector(0.f,0.f,DebugZOffset);\n\t\t\t\t\tconst FVector Dest = Origin + 100.f*TransformFragment.GetTransform().TransformVector(LookAt.Direction);\n\t\t\t\t\tUE_VLOG_ARROW(this, LogMassBehavior, Display, Origin, Dest, EntityColor, TEXT(\"\"));\n\t\t\t\t}\n\t#endif // WITH_MASSGAMEPLAY_DEBUG\n\t\t\t}\n\t\t});\n}\n\nvoid UMassLookAtProcessor::FindNewGazeTarget(const UMassNavigationSubsystem& MassNavSystem, const FMassEntityManager& EntityManager, const double CurrentTime, const FTransform& Transform, FMassLookAtFragment& LookAt) const\n{\n\tconst FNavigationObstacleHashGrid2D& ObstacleGrid = MassNavSystem.GetObstacleGrid();\n\tconst FMassEntityHandle LastTrackedEntity = LookAt.GazeTrackedEntity;\n\t\n\tLookAt.GazeTrackedEntity.Reset();\n\tLookAt.GazeDirection = FVector::ForwardVector;\n\n\t// Search for potential targets in front\n\tbool bTargetFound = false;\n\tif (LookAt.bRandomGazeEntities)\n\t{\n\t\tconst float CosAngleThreshold = FMath::Cos(FMath::DegreesToRadians(AngleThresholdInDegrees));\n\t\tconst FVector Extent(QueryExtent, QueryExtent, QueryExtent);\n\t\tconst FVector QueryOrigin = Transform.TransformPosition(FVector(0.5f*QueryExtent, 0.f, 0.f));\n\t\tconst FBox QueryBox = FBox(QueryOrigin - 0.5f*Extent, QueryOrigin + 0.5f*Extent);\n\n\t\tTArray<FNavigationObstacleHashGrid2D::ItemIDType> NearbyEntities;\n\t\tNearbyEntities.Reserve(16);\n\t\tObstacleGrid.Query(QueryBox, NearbyEntities);\n\n\t\t// We'll pick the first entity that passes, this ensure that it's random one.\n\t\tAlgo::RandomShuffle(NearbyEntities);\n\n\t\tconst FVector Location = Transform.GetLocation();\n\t\t\n\t\tfor (const FNavigationObstacleHashGrid2D::ItemIDType NearbyEntity : NearbyEntities)\n\t\t{\n\t\t\t// This can happen if we remove entities in the system.\n\t\t\tif (!EntityManager.IsEntityValid(NearbyEntity.Entity))\n\t\t\t{\n\t\t\t\tUE_LOG(LogMassBehavior, VeryVerbose, TEXT(\"Nearby entity is invalid, skipped.\"));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Do not select same target twice in a row.\n\t\t\tif (NearbyEntity.Entity == LastTrackedEntity)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFMassEntityView EntityView(EntityManager, NearbyEntity.Entity);\n\t\t\tif (!EntityView.HasTag<FMassLookAtTargetTag>())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// TargetTag is added through the LookAtTargetTrait and Transform was added with it\n\t\t\tconst FTransformFragment& TargetTransform = EntityView.GetFragmentData<FTransformFragment>();\n\t\t\tconst FVector TargetLocation = TargetTransform.GetTransform().GetLocation();\n\t\t\tFVector Direction = (TargetLocation - Location).GetSafeNormal();\n\t\t\tDirection = Transform.InverseTransformVector(Direction);\n\n\t\t\tconst bool bIsTargetInView = FVector::DotProduct(FVector::ForwardVector, Direction) > CosAngleThreshold;\n\t\t\tif (bIsTargetInView)\n\t\t\t{\n\t\t\t\tLookAt.GazeDirection = Direction;\n\t\t\t\tLookAt.GazeTrackedEntity = NearbyEntity.Entity;\n\t\t\t\tbTargetFound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Allow to pick entities out of view if they are moving towards us.\n\t\t\tif (const FMassVelocityFragment* Velocity = EntityView.GetFragmentDataPtr<FMassVelocityFragment>())\n\t\t\t{\n\t\t\t\tconst FVector MoveDirection = Transform.InverseTransformVector(Velocity->Value.GetSafeNormal());\n\t\t\t\t\n\t\t\t\tconst bool bIsTargetMovingTowards = FVector::DotProduct(MoveDirection, -Direction) > CosAngleThreshold; // Direction negated as it is from the agent to target, and we want target to agent. \n\t\t\t\tif (bIsTargetMovingTowards)\n\t\t\t\t{\n\t\t\t\t\tLookAt.GazeDirection = Direction;\n\t\t\t\t\tLookAt.GazeTrackedEntity = NearbyEntity.Entity;\n\t\t\t\t\tbTargetFound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n\t// If no gaze target found, use random angle if specified.\n\tif (!bTargetFound)\n\t{\n\t\tconst FRotator Rot(FMath::FRandRange(-(float)LookAt.RandomGazePitchVariation, (float)LookAt.RandomGazePitchVariation),FMath::FRandRange(-(float)LookAt.RandomGazeYawVariation, (float)LookAt.RandomGazeYawVariation), 0.f);\n\t\tLookAt.GazeDirection = UE::MassBehavior::ClampDirectionToXAxisCone(Rot.Vector(), FMath::DegreesToRadians(AngleThresholdInDegrees));\n\t}\n\n\t// @todo: This does not currently carry over time. It's intentional, since there might be big gaps between updates.\n\tLookAt.GazeStartTime = CurrentTime;\n\tLookAt.GazeDuration = FMath::FRandRange(FMath::Max(Duration - DurationVariation, 0.f), Duration + DurationVariation);\n}\n\nvoid UMassLookAtProcessor::UpdateLookAtTrajectory(const FTransform& Transform, const FMassZoneGraphLaneLocationFragment& ZoneGraphLocation,\n\t\t\t\t\t\t\t\t\t\t\t\t  const FMassLookAtTrajectoryFragment& LookAtTrajectory, const bool bDisplayDebug, FMassLookAtFragment& LookAt) const\n{\n\tif (LookAtTrajectory.NumPoints > 0 && LookAtTrajectory.LaneHandle == ZoneGraphLocation.LaneHandle)\n\t{\n\t\t// Look at anticipated position in the future when moving.\n\t\tconst float LookAheadDistanceAlongPath = ZoneGraphLocation.DistanceAlongLane + UE::MassBehavior::Tweakables::TrajectoryLookAhead * (LookAtTrajectory.bMoveReverse ? -1.0f : 1.0f);\n\n\t\t// Calculate lookat direction to the anticipated position.\n\t\tconst FVector AnticipatedPosition = LookAtTrajectory.GetPointAtDistanceExtrapolated(LookAheadDistanceAlongPath);\n\t\tconst FVector AgentPosition = Transform.GetLocation();\n\t\tconst FVector NewGlobalDirection = (AnticipatedPosition - AgentPosition).GetSafeNormal();\n\t\tLookAt.Direction = Transform.InverseTransformVector(NewGlobalDirection);\n\t\tLookAt.Direction.Z = 0.0f;\n\t\t\t\t\t\t\n#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT\n\t\tif (bDisplayDebug)\n\t\t{\n\t\t\tconst FVector ZOffset(0.f,0.f,DebugZOffset);\n\t\t\tUE_VLOG_SEGMENT_THICK(this, LogMassBehavior, Display, AgentPosition + ZOffset, AgentPosition + ZOffset + 100.f * NewGlobalDirection, FColor::White, /*Thickness*/3, TEXT(\"LookAt Trajectory\"));\n\t\t}\n#endif\n\t}\n}\n\nvoid UMassLookAtProcessor::UpdateLookAtTrackedEntity(const FMassEntityManager& EntityManager, const FTransform& Transform, const bool bDisplayDebug, FMassLookAtFragment& LookAt) const\n{\n\t// Update direction toward target\n\tif (EntityManager.IsEntityValid(LookAt.TrackedEntity))\n\t{\n\t\tif (const FTransformFragment* TargetTransform = EntityManager.GetFragmentDataPtr<FTransformFragment>(LookAt.TrackedEntity))\n\t\t{\n\t\t\tconst FVector AgentPosition = Transform.GetLocation();\n\t\t\tconst FVector NewGlobalDirection = (TargetTransform->GetTransform().GetLocation() - AgentPosition).GetSafeNormal();\n\t\t\tLookAt.Direction = Transform.InverseTransformVector(NewGlobalDirection);\n\n#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT\n\t\t\tif (bDisplayDebug)\n\t\t\t{\n\t\t\t\tconst FVector ZOffset(0.f,0.f,DebugZOffset);\n\t\t\t\tUE_VLOG_SEGMENT_THICK(this, LogMassBehavior, Display, AgentPosition + ZOffset, AgentPosition + ZOffset + 100.f * NewGlobalDirection, FColor::White, /*Thickness*/3, TEXT(\"LookAt Track\"));\n\t\t\t}\n#endif\n\t\t}\n\t}\n}\n\nbool UMassLookAtProcessor::UpdateGazeTrackedEntity(const FMassEntityManager& EntityManager, const FTransform& Transform, const bool bDisplayDebug, FMassLookAtFragment& LookAt) const\n{\n\tbool bHasTarget = false;\n\t\n\t// Update direction toward gaze target\n\tif (LookAt.GazeTrackedEntity.IsSet() && EntityManager.IsEntityValid(LookAt.GazeTrackedEntity))\n\t{\n\t\tif (const FTransformFragment* TargetTransform = EntityManager.GetFragmentDataPtr<FTransformFragment>(LookAt.GazeTrackedEntity))\n\t\t{\n\t\t\tconst FVector AgentPosition = Transform.GetLocation();\n\t\t\tconst FVector NewGlobalDirection = (TargetTransform->GetTransform().GetLocation() - AgentPosition).GetSafeNormal();\n\t\t\tLookAt.GazeDirection = Transform.InverseTransformVector(NewGlobalDirection);\n\n\t\t\tbHasTarget = true;\n\t\t\t\n#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT\n\t\t\tif (bDisplayDebug)\n\t\t\t{\n\t\t\t\tconst FVector ZOffset(0.f,0.f,DebugZOffset);\n\t\t\t\tUE_VLOG_SEGMENT_THICK(this, LogMassBehavior, Display, AgentPosition + ZOffset, AgentPosition + ZOffset + 100.f * NewGlobalDirection, FColor(160,160,160), /*Thickness*/3, TEXT(\"Gaze Track\"));\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\treturn bHasTarget;\n}\n\nvoid UMassLookAtProcessor::BuildTrajectory(const UZoneGraphSubsystem& ZoneGraphSubsystem, const FMassZoneGraphLaneLocationFragment& LaneLocation, const FMassZoneGraphShortPathFragment& ShortPath,\n\t\t\t\t\t\t\t\t\t\t\tconst FMassEntityHandle Entity, const bool bDisplayDebug, FMassLookAtTrajectoryFragment& LookAtTrajectory)\n{\n\tLookAtTrajectory.Reset();\n\n\tif (ShortPath.NumPoints < 2)\n\t{\n\t\treturn;\n\t}\n\n\tLookAtTrajectory.bMoveReverse = ShortPath.bMoveReverse;\n\tLookAtTrajectory.LaneHandle = LaneLocation.LaneHandle;\n\n\tconst float NextLaneLookAheadDistance = UE::MassBehavior::Tweakables::TrajectoryLookAhead;\n\t\n\t// Initialize the look at trajectory from the current path.\n\tconst FMassZoneGraphPathPoint& FirstPathPoint = ShortPath.Points[0];\n\tconst FMassZoneGraphPathPoint& LastPathPoint = ShortPath.Points[ShortPath.NumPoints - 1];\n\tensure(LookAtTrajectory.AddPoint(FirstPathPoint.Position, FirstPathPoint.Tangent.Get(), FirstPathPoint.DistanceAlongLane.Get()));\n\tensure(LookAtTrajectory.AddPoint(LastPathPoint.Position, LastPathPoint.Tangent.Get(), LastPathPoint.DistanceAlongLane.Get()));\n\n\t// If the path will lead to next lane, add a point from next lane too.\n\tif (ShortPath.NextLaneHandle.IsValid())\n\t{\n\t\tconst FZoneGraphStorage* ZoneGraphStorage = ZoneGraphSubsystem.GetZoneGraphStorage(LaneLocation.LaneHandle.DataHandle);\n\t\tif (ZoneGraphStorage != nullptr)\n\t\t{\n\t\t\tif (ShortPath.NextExitLinkType == EZoneLaneLinkType::Outgoing)\n\t\t\t{\n\t\t\t\tFZoneGraphLaneLocation Location;\n\t\t\t\tUE::ZoneGraph::Query::CalculateLocationAlongLane(*ZoneGraphStorage, ShortPath.NextLaneHandle, NextLaneLookAheadDistance, Location);\n\n\t\t\t\tensure(LookAtTrajectory.AddPoint(Location.Position, FVector2D(Location.Tangent), LastPathPoint.DistanceAlongLane.Get() + Location.DistanceAlongLane));\n\t\t\t}\n\t\t\telse if (ShortPath.NextExitLinkType == EZoneLaneLinkType::Incoming)\n\t\t\t{\n\t\t\t\tfloat LaneLength = 0.0f;\n\t\t\t\tUE::ZoneGraph::Query::GetLaneLength(*ZoneGraphStorage, ShortPath.NextLaneHandle, LaneLength);\n\n\t\t\t\tFZoneGraphLaneLocation Location;\n\t\t\t\tUE::ZoneGraph::Query::CalculateLocationAlongLane(*ZoneGraphStorage, ShortPath.NextLaneHandle, LaneLength - NextLaneLookAheadDistance, Location);\n\n\t\t\t\t// Moving backwards, reverse tangent and distance.\n\t\t\t\tensure(LookAtTrajectory.bMoveReverse);\n\t\t\t\tensure(LookAtTrajectory.AddPoint(Location.Position, FVector2D(-Location.Tangent), LastPathPoint.DistanceAlongLane.Get() - (LaneLength - Location.DistanceAlongLane)));\n\t\t\t}\n\t\t\telse if (ShortPath.NextExitLinkType == EZoneLaneLinkType::Adjacent)\n\t\t\t{\n\t\t\t\t// No extra point\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tensureMsgf(false, TEXT(\"Unhandle NextExitLinkType type %s\"), *UEnum::GetValueAsString(ShortPath.NextExitLinkType));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUE_CVLOG(bDisplayDebug, this, LogMassBehavior, Error, TEXT(\"%s Could not find ZoneGraph storage for lane %s.\"),\n\t\t\t\t*Entity.DebugGetDescription(), *LaneLocation.LaneHandle.ToString());\n\t\t}\t\t\t\t\n\t}\n\n\t// Ensure that the points are always in ascending distance order (it is, in case of reverse path).\n\tif (LookAtTrajectory.NumPoints > 1 && LookAtTrajectory.bMoveReverse)\n\t{\n\t\tensureMsgf(LookAtTrajectory.Points[0].DistanceAlongLane.Get() >= LookAtTrajectory.Points[LookAtTrajectory.NumPoints - 1].DistanceAlongLane.Get(),\n\t\t\tTEXT(\"Expecting trajectory 0 (%.1f) >= %d (%.1f)\"), LookAtTrajectory.Points[0].DistanceAlongLane.Get(),\n\t\t\tLookAtTrajectory.NumPoints - 1, LookAtTrajectory.Points[LookAtTrajectory.NumPoints - 1].DistanceAlongLane.Get());\n\t\t\n\t\tAlgo::Reverse(LookAtTrajectory.Points.GetData(), LookAtTrajectory.NumPoints);\n\t\t// Tangents needs to be reversed when the trajectory is reversed.\n\t\tfor (uint8 PointIndex = 0; PointIndex < LookAtTrajectory.NumPoints; PointIndex++)\n\t\t{\n\t\t\tLookAtTrajectory.Points[PointIndex].Tangent.Set(-LookAtTrajectory.Points[PointIndex].Tangent.Get());\n\t\t}\n\t}\n\n#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT\n\tif (bDisplayDebug)\n\t{\n\t\tconst FVector ZOffset(0,0,35);\n\t\t\n\t\tfor (uint8 PointIndex = 0; PointIndex < LookAtTrajectory.NumPoints - 1; PointIndex++)\n\t\t{\n\t\t\tconst FMassLookAtTrajectoryPoint& CurrPoint = LookAtTrajectory.Points[PointIndex];\n\t\t\tconst FMassLookAtTrajectoryPoint& NextPoint = LookAtTrajectory.Points[PointIndex + 1];\n\n\t\t\t// Trajectory\n\t\t\tconst FVector StartPoint = CurrPoint.Position;\n\t\t\tconst FVector StartForward = CurrPoint.Tangent.GetVector();\n\t\t\tconst FVector EndPoint = NextPoint.Position;\n\t\t\tconst FVector EndForward = NextPoint.Tangent.GetVector();\n\t\t\tconst FVector::FReal TangentDistance = FVector::Dist(StartPoint, EndPoint) / 3.;\n\t\t\tconst FVector StartControlPoint = StartPoint + StartForward * TangentDistance;\n\t\t\tconst FVector EndControlPoint = EndPoint - EndForward * TangentDistance;\n\n\t\t\tstatic constexpr int32 NumTicks = 6;\n\t\t\tstatic constexpr float DeltaT = 1.0f / NumTicks;\n\t\t\t\n\t\t\tFVector PrevPoint = StartPoint;\n\t\t\tfor (int32 j = 0; j < NumTicks; j++)\n\t\t\t{\n\t\t\t\tconst float T = static_cast<float>(j + 1) * DeltaT;\n\t\t\t\tconst FVector Point = UE::CubicBezier::Eval(StartPoint, StartControlPoint, EndControlPoint, EndPoint, T);\n\t\t\t\tUE_VLOG_SEGMENT_THICK(this, LogMassBehavior, Display, PrevPoint + ZOffset, Point + ZOffset, FColor::White, /*Thickness*/3, TEXT(\"\"));\n\t\t\t\tPrevPoint = Point;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (uint8 PointIndex = 0; PointIndex < LookAtTrajectory.NumPoints; PointIndex++)\n\t\t{\n\t\t\tconst FMassLookAtTrajectoryPoint& CurrPoint = LookAtTrajectory.Points[PointIndex];\n\t\t\tconst FVector CurrBase = CurrPoint.Position + ZOffset * 1.1f;\n\t\t\t// Tangents\n\t\t\tUE_VLOG_SEGMENT_THICK(this, LogMassBehavior, Display, CurrBase, CurrBase + CurrPoint.Tangent.GetVector() * 100.0f, FColorList::Grey, /*Thickness*/1,\n\t\t\t\tTEXT(\"D:%.1f\"), CurrPoint.DistanceAlongLane.Get());\n\t\t}\n\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n}\n\n#undef UNSAFE_FOR_MT",
      "lines": 527
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\MassLookAtTargetTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 422,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassLookAtTargetTrait.h\"\n#include \"MassLookAtFragments.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassEntityTemplateRegistry.h\"\n\nvoid UMassLookAtTargetTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tBuildContext.AddTag<FMassLookAtTargetTag>();\n\tBuildContext.AddFragment<FTransformFragment>();\n}\n",
      "lines": 12
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\MassLookAtTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 394,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassLookAtTrait.h\"\n#include \"MassLookAtFragments.h\"\n#include \"MassEntityTemplateRegistry.h\"\n\nvoid UMassLookAtTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tBuildContext.AddFragment<FMassLookAtFragment>();\n\tBuildContext.AddFragment<FMassLookAtTrajectoryFragment>();\n}\n",
      "lines": 11
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\MassStateTreeExecutionContext.cpp",
      "extension": ".cpp",
      "size_bytes": 5090,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassStateTreeExecutionContext.h\"\n#include \"MassStateTreeTypes.h\"\n#include \"MassEntityManager.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassSignalSubsystem.h\"\n#include \"MassEntityView.h\"\n#include \"Engine/World.h\"\n#include \"ProfilingDebugging/CsvProfiler.h\"\n\nnamespace UE::MassBehavior\n{\nbool CollectExternalData(const FStateTreeExecutionContext& Context, const UStateTree* StateTree, TArrayView<const FStateTreeExternalDataDesc> ExternalDataDescs, TArrayView<FStateTreeDataView> OutDataViews)\n{\n\tCSV_SCOPED_TIMING_STAT_EXCLUSIVE(StateTreeProcessorCollectExternalData);\n\t\n\tconst FMassStateTreeExecutionContext& MassContext = static_cast<const FMassStateTreeExecutionContext&>(Context); \n\tconst FMassEntityManager& EntityManager = MassContext.GetEntityManager();\n\tconst UWorld* World = MassContext.GetWorld();\n\t\n\tbool bFoundAll = true;\n\tconst FMassEntityView EntityView(EntityManager, MassContext.GetEntity());\n\n\tcheck(ExternalDataDescs.Num() == OutDataViews.Num());\n\n\tfor (int32 Index = 0; Index < ExternalDataDescs.Num(); Index++)\n\t{\n\t\tconst FStateTreeExternalDataDesc& DataDesc = ExternalDataDescs[Index];\n\t\tif (DataDesc.Struct == nullptr)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (DataDesc.Struct->IsChildOf(FMassFragment::StaticStruct()))\n\t\t{\n\t\t\tconst UScriptStruct* ScriptStruct = Cast<const UScriptStruct>(DataDesc.Struct);\n\t\t\tFStructView Fragment = EntityView.GetFragmentDataStruct(ScriptStruct);\n\t\t\tif (Fragment.IsValid())\n\t\t\t{\n\t\t\t\tOutDataViews[Index] = FStateTreeDataView(Fragment);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (DataDesc.Requirement == EStateTreeExternalDataRequirement::Required)\n\t\t\t\t{\n\t\t\t\t\tUE_LOG(LogMass, Error, TEXT(\"Missing Fragment: %s\"), *GetNameSafe(ScriptStruct));\n\n\t\t\t\t\t// Note: Not breaking here, so that we can validate all missing ones in one go.\n\t\t\t\t\tbFoundAll = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (DataDesc.Struct->IsChildOf(FMassSharedFragment::StaticStruct()))\n\t\t{\n\t\t\tconst UScriptStruct* ScriptStruct = Cast<const UScriptStruct>(DataDesc.Struct);\n\t\t\tFStructView Fragment = EntityView.GetSharedFragmentDataStruct(ScriptStruct);\n\t\t\tif (Fragment.IsValid())\n\t\t\t{\n\t\t\t\tOutDataViews[Index] = FStateTreeDataView(Fragment.GetScriptStruct(), Fragment.GetMemory());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (DataDesc.Requirement == EStateTreeExternalDataRequirement::Required)\n\t\t\t\t{\n\t\t\t\t\tUE_LOG(LogMass, Error, TEXT(\"Missing Shared Fragment: %s\"), *GetNameSafe(ScriptStruct));\n\n\t\t\t\t\t// Note: Not breaking here, so that we can validate all missing ones in one go.\n\t\t\t\t\tbFoundAll = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (DataDesc.Struct->IsChildOf(FMassConstSharedFragment::StaticStruct()))\n\t\t{\n\t\t\tconst UScriptStruct* ScriptStruct = Cast<const UScriptStruct>(DataDesc.Struct);\n\t\t\tFConstStructView Fragment = EntityView.GetConstSharedFragmentDataStruct(ScriptStruct);\n\t\t\tif (Fragment.IsValid())\n\t\t\t{\n\t\t\t\tOutDataViews[Index] = FStateTreeDataView(Fragment.GetScriptStruct(), const_cast<uint8*>(Fragment.GetMemory()));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (DataDesc.Requirement == EStateTreeExternalDataRequirement::Required)\n\t\t\t\t{\n\t\t\t\t\tUE_LOG(LogMass, Error, TEXT(\"Missing Const Shared Fragment: %s\"), *GetNameSafe(ScriptStruct));\n\n\t\t\t\t\t// Note: Not breaking here, so that we can validate all missing ones in one go.\n\t\t\t\t\tbFoundAll = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (DataDesc.Struct && DataDesc.Struct->IsChildOf(UWorldSubsystem::StaticClass()))\n\t\t{\n\t\t\tconst TSubclassOf<UWorldSubsystem> SubClass = Cast<UClass>(const_cast<UStruct*>(ToRawPtr(DataDesc.Struct)));\n\t\t\tUWorldSubsystem* Subsystem = World->GetSubsystemBase(SubClass);\n\t\t\tif (Subsystem)\n\t\t\t{\n\t\t\t\tOutDataViews[Index] = FStateTreeDataView(Subsystem);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (DataDesc.Requirement == EStateTreeExternalDataRequirement::Required)\n\t\t\t\t{\n\t\t\t\t\tUE_LOG(LogMass, Error, TEXT(\"Missing Subsystem: %s\"), *GetNameSafe(SubClass));\n\n\t\t\t\t\t// Note: Not breaking here, so that we can validate all missing ones in one go.\n\t\t\t\t\tbFoundAll = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn bFoundAll;\n}\n\n}; // UE::MassBehavior\n\nFMassStateTreeExecutionContext::FMassStateTreeExecutionContext(UObject& InOwner, const UStateTree& InStateTree, FStateTreeInstanceData& InInstanceData,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   FMassEntityManager& InEntityManager, UMassSignalSubsystem& InSignalSubsystem, FMassExecutionContext& InContext)\n\t: FStateTreeExecutionContext(InOwner, InStateTree, InInstanceData, FOnCollectStateTreeExternalData::CreateStatic(UE::MassBehavior::CollectExternalData))\n\t, EntityManager(&InEntityManager)\n\t, SignalSubsystem(&InSignalSubsystem)\n\t, EntitySubsystemExecutionContext(&InContext)\n{\n}\n\nvoid FMassStateTreeExecutionContext::BeginDelayedTransition(const FStateTreeTransitionDelayedState& DelayedState)\n{\n\tif (SignalSubsystem != nullptr && Entity.IsSet())\n\t{\n\t\t// Tick again after the games time has passed to see if the condition still holds true.\n\t\tSignalSubsystem->DelaySignalEntity(UE::Mass::Signals::DelayedTransitionWakeup, Entity, DelayedState.TimeLeft + KINDA_SMALL_NUMBER);\n\t}\n}\n",
      "lines": 134
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\MassStateTreeProcessors.cpp",
      "extension": ".cpp",
      "size_bytes": 15655,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassStateTreeProcessors.h\"\n#include \"StateTree.h\"\n#include \"MassStateTreeExecutionContext.h\"\n#include \"MassEntityView.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassNavigationTypes.h\"\n#include \"MassSimulationLOD.h\"\n#include \"MassComponentHitTypes.h\"\n#include \"MassSmartObjectTypes.h\"\n#include \"MassZoneGraphAnnotationTypes.h\"\n#include \"MassStateTreeSubsystem.h\"\n#include \"MassSignalSubsystem.h\"\n#include \"ProfilingDebugging/CsvProfiler.h\"\n#include \"Engine/World.h\"\n#include \"MassBehaviorSettings.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassDebugger.h\"\n\n\nCSV_DEFINE_CATEGORY(StateTreeProcessor, true);\n\nnamespace UE::MassBehavior\n{\n\ntemplate<typename TFunc>\nvoid ForEachEntityInChunk(\n\tFMassExecutionContext& Context,\n\tFMassEntityManager& EntityManager,\n\tUMassSignalSubsystem& SignalSubsystem,\n\tUMassStateTreeSubsystem& MassStateTreeSubsystem,\n\tTFunc&& Callback)\n{\n\tconst TArrayView<FMassStateTreeInstanceFragment> StateTreeInstanceList = Context.GetMutableFragmentView<FMassStateTreeInstanceFragment>();\n\tconst FMassStateTreeSharedFragment& SharedStateTree = Context.GetConstSharedFragment<FMassStateTreeSharedFragment>();\n\n\t// Assuming that all the entities share same StateTree, because they all should have the same storage fragment.\n\tconst int32 NumEntities = Context.GetNumEntities();\n\tcheck(NumEntities > 0);\n\t\n\tconst UStateTree* StateTree = SharedStateTree.StateTree;\n\n\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; EntityIndex++)\n\t{\n\t\tconst FMassEntityHandle Entity = Context.GetEntity(EntityIndex);\n\t\tFMassStateTreeInstanceFragment& StateTreeFragment = StateTreeInstanceList[EntityIndex];\n\t\tFStateTreeInstanceData* InstanceData = MassStateTreeSubsystem.GetInstanceData(StateTreeFragment.InstanceHandle);\n\t\tif (InstanceData != nullptr)\n\t\t{\n\t\t\tFMassStateTreeExecutionContext StateTreeContext(MassStateTreeSubsystem, *StateTree, *InstanceData, EntityManager, SignalSubsystem, Context);\n\t\t\tStateTreeContext.SetEntity(Entity);\n\n\t\t\t// Make sure all required external data are set.\n\t\t\t{\n\t\t\t\tCSV_SCOPED_TIMING_STAT_EXCLUSIVE(StateTreeProcessorExternalDataValidation);\n\t\t\t\t// TODO: disable this when not in debug.\n\t\t\t\tif (!ensureMsgf(StateTreeContext.AreContextDataViewsValid(), TEXT(\"StateTree will not execute due to missing external data.\")))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCallback(StateTreeContext, StateTreeFragment);\n\t\t}\n\t}\n}\n\n} // UE::MassBehavior\n\n\n//----------------------------------------------------------------------//\n// UMassStateTreeFragmentDestructor\n//----------------------------------------------------------------------//\nUMassStateTreeFragmentDestructor::UMassStateTreeFragmentDestructor()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)(EProcessorExecutionFlags::Standalone | EProcessorExecutionFlags::Server);\n\tObservedType = FMassStateTreeInstanceFragment::StaticStruct();\n\tOperation = EMassObservedOperation::Remove;\n\tbRequiresGameThreadExecution = true;\n}\n\nvoid UMassStateTreeFragmentDestructor::Initialize(UObject& Owner)\n{\n\tSignalSubsystem = UWorld::GetSubsystem<UMassSignalSubsystem>(Owner.GetWorld());\n\tSuper::Initialize(Owner);\n}\n\nvoid UMassStateTreeFragmentDestructor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassStateTreeInstanceFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddConstSharedRequirement<FMassStateTreeSharedFragment>();\n\tEntityQuery.AddSubsystemRequirement<UMassStateTreeSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassStateTreeFragmentDestructor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tif (SignalSubsystem == nullptr)\n\t{\n\t\treturn;\n\t}\n\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context,\n\t\t[&EntityManager, SignalSubsystem = SignalSubsystem](FMassExecutionContext& Context)\n\t\t{\n\t\t\tUMassStateTreeSubsystem& MassStateTreeSubsystem = Context.GetMutableSubsystemChecked<UMassStateTreeSubsystem>();\n\t\t\tconst TArrayView<FMassStateTreeInstanceFragment> StateTreeInstanceList = Context.GetMutableFragmentView<FMassStateTreeInstanceFragment>();\n\t\t\tconst FMassStateTreeSharedFragment& SharedStateTree = Context.GetConstSharedFragment<FMassStateTreeSharedFragment>();\n\n\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\n\t\t\tUE::MassBehavior::ForEachEntityInChunk(Context, EntityManager, *SignalSubsystem, MassStateTreeSubsystem,\n\t\t\t\t[](FMassStateTreeExecutionContext& StateTreeExecutionContext, FMassStateTreeInstanceFragment& StateTreeFragment)\n\t\t\t\t{\n\t\t\t\t\t// Stop the tree instance\n\t\t\t\t\tStateTreeExecutionContext.Stop();\n\t\t\t\t});\n\n\t\t\t// Free the StateTree instance memory\n\t\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; EntityIndex++)\n\t\t\t{\n\t\t\t\tFMassStateTreeInstanceFragment& StateTreeInstance = StateTreeInstanceList[EntityIndex];\n\t\t\t\tif (StateTreeInstance.InstanceHandle.IsValid())\n\t\t\t\t{\n\t\t\t\t\tMassStateTreeSubsystem.FreeInstanceData(StateTreeInstance.InstanceHandle);\n\t\t\t\t\tStateTreeInstance.InstanceHandle = FMassStateTreeInstanceHandle();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n}\n\n//----------------------------------------------------------------------//\n// UMassStateTreeActivationProcessor\n//----------------------------------------------------------------------//\nUMassStateTreeActivationProcessor::UMassStateTreeActivationProcessor()\n\t: EntityQuery(*this)\n{\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LOD);\n\tExecutionOrder.ExecuteBefore.Add(UE::Mass::ProcessorGroupNames::Behavior);\n\tbRequiresGameThreadExecution = true; // due to UMassStateTreeSubsystem RW access\n}\n\nvoid UMassStateTreeActivationProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassStateTreeInstanceFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddConstSharedRequirement<FMassStateTreeSharedFragment>();\n\tEntityQuery.AddTagRequirement<FMassStateTreeActivatedTag>(EMassFragmentPresence::None);\n\tEntityQuery.AddChunkRequirement<FMassSimulationVariableTickChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tEntityQuery.AddSubsystemRequirement<UMassStateTreeSubsystem>(EMassFragmentAccess::ReadWrite);\n\n\tProcessorRequirements.AddSubsystemRequirement<UMassSignalSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassStateTreeActivationProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tUMassSignalSubsystem& SignalSubsystem = Context.GetMutableSubsystemChecked<UMassSignalSubsystem>();\n\n\tconst UMassBehaviorSettings* BehaviorSettings = GetDefault<UMassBehaviorSettings>();\n\tcheck(BehaviorSettings);\n \n\t// StateTree processor relies on signals to be ticked but we need an 'initial tick' to set the tree in the proper state.\n\t// The initializer provides that by sending a signal to all new entities that use StateTree.\n\tconst double TimeInSeconds = EntityManager.GetWorld()->GetTimeSeconds();\n\n\tTArray<FMassEntityHandle> EntitiesToSignal;\n\tint32 ActivationCounts[EMassLOD::Max] {0,0,0,0};\n\t\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context,\n\t\t[&EntitiesToSignal, &ActivationCounts, SignalSubsystem = &SignalSubsystem, &EntityManager, MaxActivationsPerLOD = BehaviorSettings->MaxActivationsPerLOD, TimeInSeconds](FMassExecutionContext& Context)\n\t\t{\n\t\t\tUMassStateTreeSubsystem& MassStateTreeSubsystem = Context.GetMutableSubsystemChecked<UMassStateTreeSubsystem>();\n\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\t// Check if we already reached the maximum for this frame\n\t\t\tconst EMassLOD::Type ChunkLOD = FMassSimulationVariableTickChunkFragment::GetChunkLOD(Context);\n\t\t\tif (ActivationCounts[ChunkLOD] > MaxActivationsPerLOD[ChunkLOD])\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tActivationCounts[ChunkLOD] += NumEntities;\n\n\t\t\tconst TArrayView<FMassStateTreeInstanceFragment> StateTreeInstanceList = Context.GetMutableFragmentView<FMassStateTreeInstanceFragment>();\n\t\t\tconst FMassStateTreeSharedFragment& SharedStateTree = Context.GetConstSharedFragment<FMassStateTreeSharedFragment>();\n\n\t\t\t// Allocate and initialize the StateTree instance memory\n\t\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; EntityIndex++)\n\t\t\t{\n\t\t\t\tFMassStateTreeInstanceFragment& StateTreeInstance = StateTreeInstanceList[EntityIndex];\n\t\t\t\tStateTreeInstance.InstanceHandle = MassStateTreeSubsystem.AllocateInstanceData(SharedStateTree.StateTree);\n\t\t\t}\n\t\t\t\n\t\t\t// Start StateTree. This may do substantial amount of work, as we select and enter the first state.\n\t\t\tUE::MassBehavior::ForEachEntityInChunk(Context, EntityManager, *SignalSubsystem, MassStateTreeSubsystem,\n\t\t\t\t[TimeInSeconds](FMassStateTreeExecutionContext& StateTreeExecutionContext, FMassStateTreeInstanceFragment& StateTreeFragment)\n\t\t\t\t{\n\t\t\t\t\t// Start the tree instance\n\t\t\t\t\tStateTreeExecutionContext.Start();\n\t\t\t\t\tStateTreeFragment.LastUpdateTimeInSeconds = TimeInSeconds;\n\t\t\t\t});\n\n\t\t\t// Adding a tag on each entities to remember we have sent the state tree initialization signal\n\t\t\tEntitiesToSignal.Reserve(EntitiesToSignal.Num() + NumEntities);\n\t\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; EntityIndex++)\n\t\t\t{\n\t\t\t\tconst FMassStateTreeInstanceFragment& StateTreeInstance = StateTreeInstanceList[EntityIndex];\n\t\t\t\tif (StateTreeInstance.InstanceHandle.IsValid())\n\t\t\t\t{\n\t\t\t\t\tconst FMassEntityHandle Entity = Context.GetEntity(EntityIndex);\n\t\t\t\t\tContext.Defer().AddTag<FMassStateTreeActivatedTag>(Entity);\n\t\t\t\t\tEntitiesToSignal.Add(Entity);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\n\t// Signal all entities inside the consolidated list\n\tif (EntitiesToSignal.Num())\n\t{\n\t\tSignalSubsystem.SignalEntities(UE::Mass::Signals::StateTreeActivate, EntitiesToSignal);\n\t}\n}\n\n//----------------------------------------------------------------------//\n// UMassStateTreeProcessor\n//----------------------------------------------------------------------//\nUMassStateTreeProcessor::UMassStateTreeProcessor(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n\tbRequiresGameThreadExecution = true;\n\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Behavior;\n\n\t// `Behavior` doesn't run on clients but `Tasks` do.\n\t// We define the dependencies here so task won't need to set their dependency on `Behavior`,\n\t// but only on `SyncWorldToMass`\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::SyncWorldToMass);\n\tExecutionOrder.ExecuteBefore.Add(UE::Mass::ProcessorGroupNames::Tasks);\n}\n\nvoid UMassStateTreeProcessor::Initialize(UObject& Owner)\n{\n\tSuper::Initialize(Owner);\n\n\tUMassSignalSubsystem* SignalSubsystem = UWorld::GetSubsystem<UMassSignalSubsystem>(Owner.GetWorld());\n\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::StateTreeActivate);\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::LookAtFinished);\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::NewStateTreeTaskRequired);\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::StandTaskFinished);\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::DelayedTransitionWakeup);\n\n\t// @todo MassStateTree: add a way to register/unregister from enter/exit state (need reference counting)\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::SmartObjectRequestCandidates);\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::SmartObjectCandidatesReady);\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::SmartObjectInteractionDone);\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::SmartObjectInteractionAborted);\n\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::FollowPointPathStart);\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::FollowPointPathDone);\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::CurrentLaneChanged);\n\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::AnnotationTagsChanged);\n\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::HitReceived);\n\n\t// @todo MassStateTree: move this to its game plugin when possible\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::ContextualAnimTaskFinished);\n}\n\nvoid UMassStateTreeProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassStateTreeInstanceFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddConstSharedRequirement<FMassStateTreeSharedFragment>();\n\tEntityQuery.AddSubsystemRequirement<UMassStateTreeSubsystem>(EMassFragmentAccess::ReadWrite);\n\n\tProcessorRequirements.AddSubsystemRequirement<UMassSignalSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassStateTreeProcessor::SignalEntities(FMassEntityManager& EntityManager, FMassExecutionContext& Context, FMassSignalNameLookup& EntitySignals)\n{\n\tUMassSignalSubsystem& SignalSubsystem = Context.GetMutableSubsystemChecked<UMassSignalSubsystem>();\n\t\n\tQUICK_SCOPE_CYCLE_COUNTER(StateTreeProcessor_Run);\n\tCSV_SCOPED_TIMING_STAT_EXCLUSIVE(StateTreeProcessorExecute);\n\n\tconst double TimeInSeconds = EntityManager.GetWorld()->GetTimeSeconds();\n\n\tTArray<FMassEntityHandle> EntitiesToSignal;\n\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context,\n\t\t[this, &TimeInSeconds, &EntitiesToSignal, &EntityManager, SignalSubsystem = &SignalSubsystem, &EntitySignals](FMassExecutionContext& Context)\n\t\t{\n\t\t\t// Keep stats regarding the amount of tree instances ticked per frame\n\t\t\tCSV_CUSTOM_STAT(StateTreeProcessor, NumTickedStateTree, Context.GetNumEntities(), ECsvCustomStatOp::Accumulate);\n\n\t\t\tUMassStateTreeSubsystem& MassStateTreeSubsystem = Context.GetMutableSubsystemChecked<UMassStateTreeSubsystem>();\n\n\t\t\tUE::MassBehavior::ForEachEntityInChunk(Context, EntityManager, *SignalSubsystem, MassStateTreeSubsystem,\n\t\t\t\t[TimeInSeconds, &EntitiesToSignal, &EntitySignals, &MassStateTreeSubsystem]\n\t\t\t\t(FMassStateTreeExecutionContext& StateTreeExecutionContext, FMassStateTreeInstanceFragment& StateTreeFragment)\n\t\t\t\t{\n\t\t\t\t\t// Compute adjusted delta time\n\t\t\t\t\tconst float AdjustedDeltaTime = FloatCastChecked<float>(TimeInSeconds - StateTreeFragment.LastUpdateTimeInSeconds, /* Precision */ 1./256.);\n\t\t\t\t\tStateTreeFragment.LastUpdateTimeInSeconds = TimeInSeconds;\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\t\t\t\tconst FMassEntityHandle Entity = StateTreeExecutionContext.GetEntity();\n\t\t\t\t\tif (UE::Mass::Debug::IsDebuggingEntity(Entity))\n\t\t\t\t\t{\n\t\t\t\t\t\tTArray<FName> Signals;\n\t\t\t\t\t\tEntitySignals.GetSignalsForEntity(Entity, Signals);\n\t\t\t\t\t\tFString SignalsString;\n\t\t\t\t\t\tfor (const FName& SignalName : Signals)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!SignalsString.IsEmpty())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSignalsString += TEXT(\", \");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tSignalsString += SignalName.ToString();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tUE_VLOG_UELOG(&MassStateTreeSubsystem, LogStateTree, Log, TEXT(\"%s: Ticking StateTree because of signals: %s\"), *Entity.DebugGetDescription(), *SignalsString);\n\t\t\t\t\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t\t\t\t\t// Tick the tree instance\n\t\t\t\t\tStateTreeExecutionContext.Tick(AdjustedDeltaTime);\n\n\t\t\t\t\t// When last tick status is different than \"Running\", the state tree need to be tick again\n\t\t\t\t\t// For performance reason, tick again to see if we could find a new state right away instead of waiting the next frame.\n\t\t\t\t\tif (StateTreeExecutionContext.GetLastTickStatus() != EStateTreeRunStatus::Running)\n\t\t\t\t\t{\n\t\t\t\t\t\tStateTreeExecutionContext.Tick(0.0f);\n\n\t\t\t\t\t\t// Could not find new state yet, try again next frame\n\t\t\t\t\t\tif (StateTreeExecutionContext.GetLastTickStatus() != EStateTreeRunStatus::Running)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tEntitiesToSignal.Add(StateTreeExecutionContext.GetEntity());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t});\n\n\tif (EntitiesToSignal.Num())\n\t{\n\t\tSignalSubsystem.SignalEntities(UE::Mass::Signals::NewStateTreeTaskRequired, EntitiesToSignal);\n\t}\n}\n",
      "lines": 346
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\MassStateTreeSchema.cpp",
      "extension": ".cpp",
      "size_bytes": 1215,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassStateTreeSchema.h\"\n#include \"MassEntityTypes.h\"\n#include \"MassStateTreeTypes.h\"\n#include \"StateTreeConditionBase.h\"\n#include \"StateTreeConsiderationBase.h\"\n#include \"Subsystems/WorldSubsystem.h\"\n\nbool UMassStateTreeSchema::IsStructAllowed(const UScriptStruct* InScriptStruct) const\n{\n\t// Only allow Mass evals and tasks,and common conditions.\n\treturn InScriptStruct->IsChildOf(FMassStateTreeEvaluatorBase::StaticStruct())\n\t\t\t|| InScriptStruct->IsChildOf(FStateTreeEvaluatorCommonBase::StaticStruct())\n\t\t\t|| InScriptStruct->IsChildOf(FMassStateTreeTaskBase::StaticStruct())\n\t\t\t|| InScriptStruct->IsChildOf(FStateTreeConditionBase::StaticStruct())\n\t\t\t|| InScriptStruct->IsChildOf(FStateTreeConsiderationBase::StaticStruct());\n}\n\nbool UMassStateTreeSchema::IsExternalItemAllowed(const UStruct& InStruct) const\n{\n\t// Allow only WorldSubsystems and fragments as external data.\n\treturn InStruct.IsChildOf(UWorldSubsystem::StaticClass())\n\t\t\t|| InStruct.IsChildOf(FMassFragment::StaticStruct())\n\t\t\t|| InStruct.IsChildOf(FMassSharedFragment::StaticStruct())\n\t\t\t|| InStruct.IsChildOf(FMassConstSharedFragment::StaticStruct());\n}\n",
      "lines": 27
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\MassStateTreeSubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 1150,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassStateTreeSubsystem.h\"\n#include \"StateTree.h\"\n#include \"Engine/Engine.h\"\n\n\nvoid UMassStateTreeSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tSuper::Initialize(Collection);\n}\n\nFMassStateTreeInstanceHandle UMassStateTreeSubsystem::AllocateInstanceData(const UStateTree* StateTree)\n{\n\tif (StateTree == nullptr)\n\t{\n\t\treturn FMassStateTreeInstanceHandle();\n\t}\n\t\n\tint32 Index = 0;\n\tif (InstanceDataFreelist.Num() > 0)\n\t{\n\t\tIndex = InstanceDataFreelist.Pop();\n\t}\n\telse\n\t{\n\t\tIndex = InstanceDataArray.Num();\n\t\tInstanceDataArray.AddDefaulted();\n\t}\n\n\tFMassStateTreeInstanceDataItem& Item = InstanceDataArray[Index];\n\tItem.InstanceData.Reset();\n\t\n\treturn FMassStateTreeInstanceHandle::Make(Index, Item.Generation);\n}\n\nvoid UMassStateTreeSubsystem::FreeInstanceData(const FMassStateTreeInstanceHandle Handle)\n{\n\tif (!IsValidHandle(Handle))\n\t{\n\t\treturn;\n\t}\n\n\tFMassStateTreeInstanceDataItem& Item = InstanceDataArray[Handle.GetIndex()];\n\tItem.InstanceData.Reset();\n\tItem.Generation++;\n\n\tInstanceDataFreelist.Add(Handle.GetIndex());\n}\n",
      "lines": 49
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\MassStateTreeTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 4872,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassStateTreeTrait.h\"\n#include \"MassStateTreeFragments.h\"\n#include \"MassStateTreeSubsystem.h\"\n#include \"MassAIBehaviorTypes.h\"\n#include \"StateTree.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"Engine/World.h\"\n#include \"MassEntityUtils.h\"\n\n\nvoid UMassStateTreeTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tFMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(World);\n\n\tUMassStateTreeSubsystem* MassStateTreeSubsystem = World.GetSubsystem<UMassStateTreeSubsystem>();\n\tif (!MassStateTreeSubsystem && !BuildContext.IsInspectingData())\n\t{\n\t\tUE_VLOG(&World, LogMassBehavior, Error, TEXT(\"Failed to get Mass StateTree Subsystem.\"));\n\t\treturn;\n\t}\n\n\tif (!StateTree && !BuildContext.IsInspectingData())\n\t{\n\t\tUE_VLOG(MassStateTreeSubsystem, LogMassBehavior, Error, TEXT(\"StateTree asset is not set or unavailable.\"));\n\t\treturn;\n\t}\n\tif (StateTree != nullptr && !BuildContext.IsInspectingData() && !StateTree->IsReadyToRun())\n\t{\n\t\tUE_VLOG(MassStateTreeSubsystem, LogMassBehavior, Error, TEXT(\"StateTree asset is ready to run.\"));\n\t\treturn;\n\t}\n\n\tFMassStateTreeSharedFragment SharedStateTree;\n\tSharedStateTree.StateTree = StateTree;\n\t\n\tconst FConstSharedStruct StateTreeFragment = EntityManager.GetOrCreateConstSharedFragment(SharedStateTree);\n\tBuildContext.AddConstSharedFragment(StateTreeFragment);\n\n\tBuildContext.AddFragment<FMassStateTreeInstanceFragment>();\n}\n\nbool UMassStateTreeTrait::ValidateTemplate(const FMassEntityTemplateBuildContext& BuildContext, const UWorld& World, FAdditionalTraitRequirements& OutTraitRequirements) const\n{\n\tUMassStateTreeSubsystem* MassStateTreeSubsystem = World.GetSubsystem<UMassStateTreeSubsystem>();\n\tif (!MassStateTreeSubsystem)\n\t{\n\t\tUE_VLOG(&World, LogMassBehavior, Error, TEXT(\"Failed to get Mass StateTree Subsystem.\"));\n\t\treturn false;\n\t}\n\n\tif (!StateTree)\n\t{\n\t\tUE_VLOG(MassStateTreeSubsystem, LogMassBehavior, Error, TEXT(\"StateTree asset is not set or unavailable.\"));\n\t\treturn false;\n\t}\n\n\t// Make sure all the required subsystems can be found.\n\tbool bIssuesFound = false;\n\tfor (const FStateTreeExternalDataDesc& ItemDesc : StateTree->GetExternalDataDescs())\n\t{\n\t\tif (ensure(ItemDesc.Struct) && ItemDesc.Requirement == EStateTreeExternalDataRequirement::Required)\n\t\t{\n\t\t\tif (ItemDesc.Struct->IsChildOf(UWorldSubsystem::StaticClass()))\n\t\t\t{\n\t\t\t\tif (BuildContext.IsInspectingData() == false)\n\t\t\t\t{\n\t\t\t\t\tconst TSubclassOf<UWorldSubsystem> SubClass = Cast<UClass>(const_cast<UStruct*>(ToRawPtr(ItemDesc.Struct)));\n\t\t\t\t\tUSubsystem* Subsystem = World.GetSubsystemBase(SubClass);\n\t\t\t\t\tUE_CVLOG_ALWAYS_UELOG(!Subsystem, MassStateTreeSubsystem, LogMassBehavior, Error, TEXT(\"StateTree %s: Could not find required subsystem %s\"), *GetNameSafe(StateTree), *GetNameSafe(ItemDesc.Struct));\n\t\t\t\t\tbIssuesFound = bIssuesFound || !Subsystem;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ItemDesc.Struct->IsChildOf(FMassFragment::StaticStruct()))\n\t\t\t{\n\t\t\t\tconst UScriptStruct& FragmentType = *CastChecked<UScriptStruct>(ItemDesc.Struct);\n\t\t\t\tif (BuildContext.HasFragment(FragmentType) == false)\n\t\t\t\t{\n\t\t\t\t\tOutTraitRequirements.Add(&FragmentType);\n\t\t\t\t\tUE_VLOG_ALWAYS_UELOG(MassStateTreeSubsystem, LogMassBehavior, Error, TEXT(\"StateTree %s: Could not find required fragment %s\"), *GetNameSafe(StateTree), *GetNameSafe(ItemDesc.Struct));\n\t\t\t\t\tbIssuesFound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ItemDesc.Struct->IsChildOf(FMassSharedFragment::StaticStruct()))\n\t\t\t{\n\t\t\t\tconst UScriptStruct& FragmentType = *CastChecked<UScriptStruct>(ItemDesc.Struct);\n\t\t\t\tif (BuildContext.HasSharedFragment(FragmentType) == false)\n\t\t\t\t{\n\t\t\t\t\tOutTraitRequirements.Add(&FragmentType);\n\t\t\t\t\tUE_VLOG_ALWAYS_UELOG(MassStateTreeSubsystem, LogMassBehavior, Error, TEXT(\"StateTree %s: Could not find required shared fragment %s\"), *GetNameSafe(StateTree), *GetNameSafe(ItemDesc.Struct));\n\t\t\t\t\tbIssuesFound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ItemDesc.Struct->IsChildOf(FMassConstSharedFragment::StaticStruct()))\n\t\t\t{\n\t\t\t\tconst UScriptStruct& FragmentType = *CastChecked<UScriptStruct>(ItemDesc.Struct);\n\t\t\t\tif (BuildContext.HasConstSharedFragment(FragmentType) == false)\n\t\t\t\t{\n\t\t\t\t\tOutTraitRequirements.Add(&FragmentType);\n\t\t\t\t\tUE_VLOG_ALWAYS_UELOG(MassStateTreeSubsystem, LogMassBehavior, Error, TEXT(\"StateTree %s: Could not find required const shared fragment %s\"), *GetNameSafe(StateTree), *GetNameSafe(ItemDesc.Struct));\n\t\t\t\t\tbIssuesFound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tUE_VLOG_ALWAYS_UELOG(MassStateTreeSubsystem, LogMassBehavior, Error, TEXT(\"StateTree %s: Unsupported requirement %s\"), *GetNameSafe(StateTree), *GetNameSafe(ItemDesc.Struct));\n\t\t\t\tbIssuesFound = true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn !bIssuesFound;\n}\n",
      "lines": 115
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\MassStateTreeTypes.cpp",
      "extension": ".cpp",
      "size_bytes": 89,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassStateTreeTypes.h\"\n\n",
      "lines": 4
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\MassZoneGraphAnnotationFragments.cpp",
      "extension": ".cpp",
      "size_bytes": 2114,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassZoneGraphAnnotationFragments.h\"\n#include \"MassEntityManager.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassSimulationLOD.h\"\n#include \"MassDebugger.h\"\n\n\nnamespace UE::Mass::ZoneGraphAnnotations\n{\n// Update interval range for periodic annotation tag update.\nstatic const float MinUpdateInterval = 0.25f;\nstatic const float MaxUpdateInterval = 0.5f;\n\n// Update interval range for periodic annotation tag update for Off LOD.\nstatic const float OffLODMinUpdateInterval = 1.905f;\nstatic const float OffLODMaxUpdateInterval = 2.10f;\n\n} // UE::Mass::ZoneGraphAnnotations\n\n//----------------------------------------------------------------------//\n//  FMassZoneGraphAnnotationVariableTickChunkFragment\n//----------------------------------------------------------------------//\n\nbool FMassZoneGraphAnnotationVariableTickChunkFragment::UpdateChunk(FMassExecutionContext& Context)\n{\n\tFMassZoneGraphAnnotationVariableTickChunkFragment& ChunkFrag = Context.GetMutableChunkFragment<FMassZoneGraphAnnotationVariableTickChunkFragment>();\n\tChunkFrag.TimeUntilNextTick -= Context.GetDeltaTimeSeconds();\n\tif (!ChunkFrag.bInitialized)\n\t{\n\t\tconst bool bOffLOD = FMassSimulationVariableTickChunkFragment::GetChunkLOD(Context) == EMassLOD::Off;\n\t\tChunkFrag.TimeUntilNextTick = FMath::RandRange(0.0f, bOffLOD ? UE::Mass::ZoneGraphAnnotations::OffLODMaxUpdateInterval : UE::Mass::ZoneGraphAnnotations::MaxUpdateInterval);\n\t\tChunkFrag.bInitialized = true;\n\t}\n\telse\n\t{\n\t\tChunkFrag.TimeUntilNextTick -= Context.GetDeltaTimeSeconds();\n\t}\n\t\n\tif (ChunkFrag.TimeUntilNextTick <= 0.0f)\n\t{\n\t\tconst bool bOffLOD = FMassSimulationVariableTickChunkFragment::GetChunkLOD(Context) == EMassLOD::Off;\n\t\tChunkFrag.TimeUntilNextTick = FMath::RandRange(\n\t\t\tbOffLOD ? UE::Mass::ZoneGraphAnnotations::OffLODMinUpdateInterval : UE::Mass::ZoneGraphAnnotations::MinUpdateInterval, \n\t\t\tbOffLOD ? UE::Mass::ZoneGraphAnnotations::OffLODMaxUpdateInterval : UE::Mass::ZoneGraphAnnotations::MaxUpdateInterval);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n",
      "lines": 52
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\MassZoneGraphAnnotationProcessors.cpp",
      "extension": ".cpp",
      "size_bytes": 7667,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassZoneGraphAnnotationProcessors.h\"\n#include \"MassAIBehaviorTypes.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"MassZoneGraphAnnotationFragments.h\"\n#include \"MassZoneGraphAnnotationTypes.h\"\n#include \"MassGameplayExternalTraits.h\"\n#include \"ZoneGraphTypes.h\"\n#include \"ZoneGraphAnnotationSubsystem.h\"\n#include \"MassSignalSubsystem.h\"\n#include \"MassSimulationLOD.h\"\n#include \"MassExecutionContext.h\"\n#include \"Engine/World.h\"\n\n//----------------------------------------------------------------------//\n//  UMassZoneGraphAnnotationTagsInitializer\n//----------------------------------------------------------------------//\nUMassZoneGraphAnnotationTagsInitializer::UMassZoneGraphAnnotationTagsInitializer()\n\t: EntityQuery(*this)\n{\n\tObservedType = FMassZoneGraphAnnotationFragment::StaticStruct();\n\tOperation = EMassObservedOperation::Add;\n}\n\nvoid UMassZoneGraphAnnotationTagsInitializer::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassZoneGraphAnnotationFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassZoneGraphLaneLocationFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddSubsystemRequirement<UZoneGraphAnnotationSubsystem>(EMassFragmentAccess::ReadOnly);\n}\n\nvoid UMassZoneGraphAnnotationTagsInitializer::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tconst UZoneGraphAnnotationSubsystem& ZoneGraphAnnotationSubsystem = Context.GetSubsystemChecked<UZoneGraphAnnotationSubsystem>();\n\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tconst TArrayView<FMassZoneGraphAnnotationFragment> AnnotationTagsList = Context.GetMutableFragmentView<FMassZoneGraphAnnotationFragment>();\n\t\tconst TConstArrayView<FMassZoneGraphLaneLocationFragment> LaneLocationList = Context.GetFragmentView<FMassZoneGraphLaneLocationFragment>();\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tFMassZoneGraphAnnotationFragment& AnnotationTags = AnnotationTagsList[EntityIndex];\n\t\t\tconst FMassZoneGraphLaneLocationFragment& LaneLocation = LaneLocationList[EntityIndex];\n\n\t\t\tif (!LaneLocation.LaneHandle.IsValid())\n\t\t\t{\n\t\t\t\tAnnotationTags.Tags = FZoneGraphTagMask::None;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAnnotationTags.Tags = ZoneGraphAnnotationSubsystem.GetAnnotationTags(LaneLocation.LaneHandle);\n\t\t\t}\n\t\t}\n\t});\n}\n\n//----------------------------------------------------------------------//\n//  UMassZoneGraphAnnotationTagUpdateProcessor\n//----------------------------------------------------------------------//\nUMassZoneGraphAnnotationTagUpdateProcessor::UMassZoneGraphAnnotationTagUpdateProcessor()\n{\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::UpdateAnnotationTags;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::SyncWorldToMass);\n\tExecutionOrder.ExecuteBefore.Add(UE::Mass::ProcessorGroupNames::Behavior);\n}\n\nvoid UMassZoneGraphAnnotationTagUpdateProcessor::Initialize(UObject& Owner)\n{\n\tSuper::Initialize(Owner);\n\n\tUMassSignalSubsystem* SignalSubsystem = UWorld::GetSubsystem<UMassSignalSubsystem>(Owner.GetWorld());\n\tif (ensureMsgf(SignalSubsystem, TEXT(\"Expecting to run this processor with UMassSignalSubsystem available\")))\n\t{\n\t\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::CurrentLaneChanged);\n\t}\n}\n\nvoid UMassZoneGraphAnnotationTagUpdateProcessor::ConfigureQueries()\n{\n\tSuper::ConfigureQueries();\n\tEntityQuery.AddRequirement<FMassZoneGraphAnnotationFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassZoneGraphLaneLocationFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddChunkRequirement<FMassZoneGraphAnnotationVariableTickChunkFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddChunkRequirement<FMassSimulationVariableTickChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tEntityQuery.AddSubsystemRequirement<UZoneGraphAnnotationSubsystem>(EMassFragmentAccess::ReadWrite);\n\n\tProcessorRequirements.AddSubsystemRequirement<UMassSignalSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassZoneGraphAnnotationTagUpdateProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tTransientEntitiesToSignal.Reset();\n\n\t// Calling super will update the signals, and call SignalEntities() below.\n\tSuper::Execute(EntityManager, Context);\n\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\t// Periodically update tags.\n\t\tif (!FMassZoneGraphAnnotationVariableTickChunkFragment::UpdateChunk(Context))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tUZoneGraphAnnotationSubsystem& ZoneGraphAnnotationSubsystem = Context.GetMutableSubsystemChecked<UZoneGraphAnnotationSubsystem>();\n\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tconst TArrayView<FMassZoneGraphAnnotationFragment> AnnotationTagsList = Context.GetMutableFragmentView<FMassZoneGraphAnnotationFragment>();\n\t\tconst TConstArrayView<FMassZoneGraphLaneLocationFragment> LaneLocationList = Context.GetFragmentView<FMassZoneGraphLaneLocationFragment>();\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tFMassZoneGraphAnnotationFragment& AnnotationTags = AnnotationTagsList[EntityIndex];\n\t\t\tconst FMassZoneGraphLaneLocationFragment& LaneLocation = LaneLocationList[EntityIndex];\n\n\t\t\tUpdateAnnotationTags(ZoneGraphAnnotationSubsystem, AnnotationTags, LaneLocation, Context.GetEntity(EntityIndex));\n\t\t}\n\t});\n\n\tif (TransientEntitiesToSignal.Num())\n\t{\n\t\tUMassSignalSubsystem& SignalSubsystem = Context.GetMutableSubsystemChecked<UMassSignalSubsystem>();\n\t\tSignalSubsystem.SignalEntities(UE::Mass::Signals::AnnotationTagsChanged, TransientEntitiesToSignal);\n\t}\n}\n\nvoid UMassZoneGraphAnnotationTagUpdateProcessor::UpdateAnnotationTags(UZoneGraphAnnotationSubsystem& ZoneGraphAnnotationSubsystem, FMassZoneGraphAnnotationFragment& AnnotationTags, const FMassZoneGraphLaneLocationFragment& LaneLocation, const FMassEntityHandle Entity)\n{\n\tconst FZoneGraphTagMask OldTags = AnnotationTags.Tags;\n\n\tif (LaneLocation.LaneHandle.IsValid())\n\t{\n\t\tAnnotationTags.Tags = ZoneGraphAnnotationSubsystem.GetAnnotationTags(LaneLocation.LaneHandle);\n\t}\n\telse\n\t{\n\t\tAnnotationTags.Tags = FZoneGraphTagMask::None;\n\t}\n\n\tif (OldTags != AnnotationTags.Tags)\n\t{\n\t\tTransientEntitiesToSignal.Add(Entity);\n\t}\n}\n\nvoid UMassZoneGraphAnnotationTagUpdateProcessor::SignalEntities(FMassEntityManager& EntityManager, FMassExecutionContext& Context, FMassSignalNameLookup&)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tUZoneGraphAnnotationSubsystem& ZoneGraphAnnotationSubsystem = Context.GetMutableSubsystemChecked<UZoneGraphAnnotationSubsystem>();\n\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tconst TConstArrayView<FMassZoneGraphLaneLocationFragment> LaneLocationList = Context.GetFragmentView<FMassZoneGraphLaneLocationFragment>();\n\t\tconst TArrayView<FMassZoneGraphAnnotationFragment> AnnotationTagsList = Context.GetMutableFragmentView<FMassZoneGraphAnnotationFragment>();\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tFMassZoneGraphAnnotationFragment& AnnotationTags = AnnotationTagsList[EntityIndex];\n\t\t\tconst FMassZoneGraphLaneLocationFragment& LaneLocation = LaneLocationList[EntityIndex];\n\n\t\t\tUpdateAnnotationTags(ZoneGraphAnnotationSubsystem, AnnotationTags, LaneLocation, Context.GetEntity(EntityIndex));\n\t\t}\n\t});\n}\n",
      "lines": 167
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\MassZoneGraphAnnotationTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 495,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassZoneGraphAnnotationTrait.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"Engine/World.h\"\n#include \"MassZoneGraphAnnotationFragments.h\"\n\nvoid UMassZoneGraphAnnotationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tBuildContext.AddFragment<FMassZoneGraphAnnotationFragment>();\n\tBuildContext.AddChunkFragment<FMassZoneGraphAnnotationVariableTickChunkFragment>();\n}\n",
      "lines": 12
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\Conditions\\ZoneGraphTagConditions.cpp",
      "extension": ".cpp",
      "size_bytes": 3306,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Conditions/ZoneGraphTagConditions.h\"\n#include \"StateTreeExecutionContext.h\"\n#include \"StateTreeLinker.h\"\n#if WITH_EDITOR\n#include \"ZoneGraphSettings.h\"\n#endif// WITH_EDITOR\n\n#if WITH_EDITOR\n#define LOCTEXT_NAMESPACE \"StateTreeEditor\"\n\nnamespace UE::MassBehavior::ZoneGraph\n{\n\tFText GetTagName(const FZoneGraphTag Tag)\n\t{\n\t\tconst UZoneGraphSettings* ZoneGraphSettings = GetDefault<UZoneGraphSettings>();\n\t\tcheck(ZoneGraphSettings);\n\t\tTConstArrayView<FZoneGraphTagInfo> TagInfos = ZoneGraphSettings->GetTagInfos();\n\t\t\n\t\tfor (const FZoneGraphTagInfo& TagInfo : TagInfos)\n\t\t{\n\t\t\tif (TagInfo.Tag == Tag)\n\t\t\t{\n\t\t\t\treturn FText::FromName(TagInfo.Name);\n\t\t\t}\n\t\t}\n\t\treturn FText::GetEmpty();\n\t}\n\n\tFText GetTagMaskName(const FZoneGraphTagMask TagMask)\n\t{\n\t\tconst UZoneGraphSettings* ZoneGraphSettings = GetDefault<UZoneGraphSettings>();\n\t\tcheck(ZoneGraphSettings);\n\t\tTConstArrayView<FZoneGraphTagInfo> TagInfos = ZoneGraphSettings->GetTagInfos();\n\n\t\tTArray<FText> Names;\n\t\tfor (const FZoneGraphTagInfo& Info : TagInfos)\n\t\t{\n\t\t\tif (TagMask.Contains(Info.Tag))\n\t\t\t{\n\t\t\t\tif (Info.IsValid())\n\t\t\t\t{\n\t\t\t\t\tNames.Add(FText::FromName(Info.Name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (Names.Num() == 0)\n\t\t{\n\t\t\treturn LOCTEXT(\"EmptyMask\", \"(Empty)\");\n\t\t}\n\t\t\n\t\tif (Names.Num() > 2)\n\t\t{\n\t\t\tNames.SetNum(2);\n\t\t\tNames.Add(FText::FromString(TEXT(\"...\")));\n\t\t}\n\t\t\n\t\treturn FText::Join(FText::FromString(TEXT(\", \")), Names);\n\t}\n\n\tFText GetMaskOperatorText(const EZoneLaneTagMaskComparison Operator)\n\t{\n\t\tswitch (Operator)\n\t\t{\n\t\tcase EZoneLaneTagMaskComparison::Any:\n\t\t\treturn LOCTEXT(\"ContainsAny\", \"Any\");\n\t\tcase EZoneLaneTagMaskComparison::All:\n\t\t\treturn LOCTEXT(\"ContainsAll\", \"All\");\n\t\tcase EZoneLaneTagMaskComparison::Not:\n\t\t\treturn LOCTEXT(\"ContainsNot\", \"Not\");\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn FText::FromString(TEXT(\"??\"));\n\t}\n\n}\n\n#endif// WITH_EDITOR\n\n\n//----------------------------------------------------------------------//\n//  FZoneGraphTagFilterCondition\n//----------------------------------------------------------------------//\n\nbool FZoneGraphTagFilterCondition::TestCondition(FStateTreeExecutionContext& Context) const\n{\n\tconst FInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\treturn Filter.Pass(InstanceData.Tags) ^ bInvert;\n}\n\n\n//----------------------------------------------------------------------//\n//  FZoneGraphTagMaskCondition\n//----------------------------------------------------------------------//\n\nbool FZoneGraphTagMaskCondition::TestCondition(FStateTreeExecutionContext& Context) const\n{\n\tconst FInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\treturn InstanceData.Left.CompareMasks(InstanceData.Right, Operator) ^ bInvert;\n}\n\n\n//----------------------------------------------------------------------//\n//  FZoneGraphTagCondition\n//----------------------------------------------------------------------//\n\nbool FZoneGraphTagCondition::TestCondition(FStateTreeExecutionContext& Context) const\n{\n\tconst FInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\treturn (InstanceData.Left == InstanceData.Right) ^ bInvert;\n}\n\n\n#if WITH_EDITOR\n#undef LOCTEXT_NAMESPACE\n#endif // WITH_EDITOR\n",
      "lines": 118
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\Evaluators\\MassComponentHitEvaluator.cpp",
      "extension": ".cpp",
      "size_bytes": 1619,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Evaluators/MassComponentHitEvaluator.h\"\n#include \"MassAIBehaviorTypes.h\"\n#include \"MassComponentHitSubsystem.h\"\n#include \"MassStateTreeExecutionContext.h\"\n#include \"Engine/World.h\"\n#include \"StateTreeLinker.h\"\n\n\nbool FMassComponentHitEvaluator::Link(FStateTreeLinker& Linker)\n{\n\tLinker.LinkExternalData(ComponentHitSubsystemHandle);\n\n\treturn true;\n}\n\nvoid FMassComponentHitEvaluator::Tick(FStateTreeExecutionContext &Context, const float DeltaTime) const\n{\n\t// Look for recent hits\n\tUMassComponentHitSubsystem& HitSubsystem = Context.GetExternalData(ComponentHitSubsystemHandle);\n\tconst FMassHitResult* HitResult = HitSubsystem.GetLastHit(static_cast<FMassStateTreeExecutionContext&>(Context).GetEntity());\n\n\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\t\n\t// LastHitEntity is not reset intentionally, so that it's available the duration of the behavior reacting to it.\n\tInstanceData.bGotHit = false;\n\n\t// If the hit is very recent, set the got hit, and update last hit entity.\n\tif (HitResult != nullptr)\n\t{\n\t\t// @todo: This is a bit of a kludge to expose an event to StateTree.\n\t\tconst UWorld* World = Context.GetWorld();\n\t\tcheck(World);\n\t\tconst double CurrentTime = World->GetTimeSeconds();\n\t\tconst double TimeSinceHit = CurrentTime - HitResult->HitTime;\n\t\tconstexpr double HitEventDuration = 0.1;\n\t\tif (TimeSinceHit < HitEventDuration)\n\t\t{\n\t\t\tMASSBEHAVIOR_LOG(VeryVerbose, TEXT(\"Got hit\"));\n\t\t\tInstanceData.bGotHit = true;\n\t\t\tInstanceData.LastHitEntity = HitResult->OtherEntity;\n\t\t}\n\t}\n}\n",
      "lines": 45
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\Evaluators\\MassZoneGraphAnnotationEvaluator.cpp",
      "extension": ".cpp",
      "size_bytes": 843,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Evaluators/MassZoneGraphAnnotationEvaluator.h\"\n#include \"MassStateTreeExecutionContext.h\"\n#include \"MassZoneGraphAnnotationFragments.h\"\n#include \"StateTreeLinker.h\"\n\n\nFMassZoneGraphAnnotationEvaluator::FMassZoneGraphAnnotationEvaluator()\n{\n}\n\nbool FMassZoneGraphAnnotationEvaluator::Link(FStateTreeLinker& Linker)\n{\n\tLinker.LinkExternalData(AnnotationTagsFragmentHandle);\n\n\treturn true;\n}\n\nvoid FMassZoneGraphAnnotationEvaluator::Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const\n{\n\tconst FMassZoneGraphAnnotationFragment& AnnotationTagsFragment = Context.GetExternalData(AnnotationTagsFragmentHandle);\n\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\tInstanceData.AnnotationTags = AnnotationTagsFragment.Tags;\n}\n",
      "lines": 25
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\Tasks\\MassClaimSmartObjectTask.cpp",
      "extension": ".cpp",
      "size_bytes": 5522,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Tasks/MassClaimSmartObjectTask.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassAIBehaviorTypes.h\"\n#include \"MassSignalSubsystem.h\"\n#include \"MassSmartObjectHandler.h\"\n#include \"MassSmartObjectFragments.h\"\n#include \"MassStateTreeExecutionContext.h\"\n#include \"MassNavigationFragments.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"MassZoneGraphNavigationUtils.h\"\n#include \"Engine/World.h\"\n#include \"StateTreeLinker.h\"\n\n//----------------------------------------------------------------------//\n// FMassClaimSmartObjectTask\n//----------------------------------------------------------------------//\n\nFMassClaimSmartObjectTask::FMassClaimSmartObjectTask()\n{\n\t// This task should not react to Enter/ExitState when the state is reselected.\n\tbShouldStateChangeOnReselect = false;\n}\n\nbool FMassClaimSmartObjectTask::Link(FStateTreeLinker& Linker)\n{\n\tLinker.LinkExternalData(SmartObjectUserHandle);\n\tLinker.LinkExternalData(SmartObjectSubsystemHandle);\n\tLinker.LinkExternalData(MassSignalSubsystemHandle);\n\n\treturn true;\n}\n\nEStateTreeRunStatus FMassClaimSmartObjectTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\t// Retrieve fragments and subsystems\n\tUSmartObjectSubsystem& SmartObjectSubsystem = Context.GetExternalData(SmartObjectSubsystemHandle);\n\tUMassSignalSubsystem& SignalSubsystem = Context.GetExternalData(MassSignalSubsystemHandle);\n\tFMassSmartObjectUserFragment& SOUser = Context.GetExternalData(SmartObjectUserHandle);\n\n\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\tconst FMassSmartObjectCandidateSlots* CandidateSlots = InstanceData.CandidateSlots.GetPtr<FMassSmartObjectCandidateSlots>();\n\tif (CandidateSlots == nullptr)\n\t{\n\t\tMASSBEHAVIOR_LOG(Log, TEXT(\"Candidate slots not set\"));\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\n\tInstanceData.ClaimedSlot.Invalidate();\n\t\n\t// Setup MassSmartObject handler and claim\n\tconst FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);\n\tconst FMassSmartObjectHandler MassSmartObjectHandler(MassContext.GetEntityManager(), MassContext.GetEntitySubsystemExecutionContext(), SmartObjectSubsystem, SignalSubsystem);\n\t\n\tInstanceData.ClaimedSlot = MassSmartObjectHandler.ClaimCandidate(MassContext.GetEntity(), SOUser, *CandidateSlots);\n\n\t// Treat claiming a slot as consuming all the candidate slots.\n\t// This is done here because of the limited ways we can communicate between FindSmartObject() and ClaimSmartObject().\n\t// InteractionCooldownEndTime is used by the FindSmartObject() to invalidate the candidates.\n\tSOUser.InteractionCooldownEndTime = Context.GetWorld()->GetTimeSeconds() + InteractionCooldown;\n\n\tif (!InstanceData.ClaimedSlot.IsValid())\n\t{\n\t\tMASSBEHAVIOR_LOG(Log, TEXT(\"Failed to claim smart object slot from %d candidates\"), CandidateSlots->NumSlots);\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\n\treturn EStateTreeRunStatus::Running;\n}\n\nvoid FMassClaimSmartObjectTask::ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\tFMassSmartObjectUserFragment& SOUser = Context.GetExternalData(SmartObjectUserHandle);\n\tconst FInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t// Succeeded or not, prevent interactions for a specified duration.\n\tSOUser.InteractionCooldownEndTime = Context.GetWorld()->GetTimeSeconds() + InteractionCooldown;\n\n\tif (InstanceData.ClaimedSlot.IsValid())\n\t{\n\t\tconst FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);\n\t\tUSmartObjectSubsystem& SmartObjectSubsystem = Context.GetExternalData(SmartObjectSubsystemHandle);\n\t\tUMassSignalSubsystem& SignalSubsystem = Context.GetExternalData(MassSignalSubsystemHandle);\n\t\tconst FMassSmartObjectHandler MassSmartObjectHandler(MassContext.GetEntityManager(), MassContext.GetEntitySubsystemExecutionContext(), SmartObjectSubsystem, SignalSubsystem);\n\n\t\tMassSmartObjectHandler.ReleaseSmartObject(MassContext.GetEntity(), SOUser, InstanceData.ClaimedSlot);\n\t}\n\telse\n\t{\n\t\tMASSBEHAVIOR_LOG(VeryVerbose, TEXT(\"Exiting state with an invalid ClaimHandle: nothing to do.\"));\n\t}\n}\n\nEStateTreeRunStatus FMassClaimSmartObjectTask::Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const\n{\n\tFMassSmartObjectUserFragment& SOUser = Context.GetExternalData(SmartObjectUserHandle);\n\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\t\n\t// Prevent FindSmartObject() to query new objects while claimed.\n\t// This is done here because of the limited ways we can communicate between FindSmartObject() and ClaimSmartObject().\n\t// InteractionCooldownEndTime is used by the FindSmartObject() to invalidate the candidates.\n\tSOUser.InteractionCooldownEndTime = Context.GetWorld()->GetTimeSeconds() + InteractionCooldown;\n\n\t// Check that the claimed slot is still valid, and if not, fail the task.\n\t// The slot can become invalid if the whole SO or slot becomes invalidated.\n\tif (InstanceData.ClaimedSlot.IsValid())\n\t{\n\t\tconst USmartObjectSubsystem& SmartObjectSubsystem = Context.GetExternalData(SmartObjectSubsystemHandle);\n\t\tif (!SmartObjectSubsystem.IsClaimedSmartObjectValid(InstanceData.ClaimedSlot))\n\t\t{\n\t\t\tInstanceData.ClaimedSlot.Invalidate();\n\t\t}\n\t}\n\n\treturn InstanceData.ClaimedSlot.IsValid() ? EStateTreeRunStatus::Running : EStateTreeRunStatus::Failed;\n}\n",
      "lines": 118
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\Tasks\\MassFindSmartObjectTask.cpp",
      "extension": ".cpp",
      "size_bytes": 7875,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Tasks/MassFindSmartObjectTask.h\"\n#include \"ZoneGraphAnnotationSubsystem.h\"\n#include \"MassAIBehaviorTypes.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassSmartObjectFragments.h\"\n#include \"MassSmartObjectHandler.h\"\n#include \"MassStateTreeExecutionContext.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"SmartObjectZoneAnnotations.h\"\n#include \"StateTreeLinker.h\"\n\nFMassFindSmartObjectTask::FMassFindSmartObjectTask()\n{\n\t// Do not clear the request on sustained transitions.\n\t// A child state (move) task can succeed on the same tick as the request is made (very likely in event based ticking).\n\t// That will cause transitions which would kill out request immediately.\n\tbShouldStateChangeOnReselect = false;\n}\n\nbool FMassFindSmartObjectTask::Link(FStateTreeLinker& Linker)\n{\n\tLinker.LinkExternalData(SmartObjectSubsystemHandle);\n\tLinker.LinkExternalData(MassSignalSubsystemHandle);\n\tLinker.LinkExternalData(EntityTransformHandle);\n\tLinker.LinkExternalData(SmartObjectUserHandle);\n\tLinker.LinkExternalData(LocationHandle);\n\n\treturn true;\n}\n\nvoid FMassFindSmartObjectTask::ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t// Stop any request that are still in flight.\n\tif (InstanceData.SearchRequestID.IsSet())\n\t{\n\t\tconst FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);\n\t\tUSmartObjectSubsystem& SmartObjectSubsystem = Context.GetExternalData(SmartObjectSubsystemHandle);\n\t\tUMassSignalSubsystem& SignalSubsystem = Context.GetExternalData(MassSignalSubsystemHandle);\n\t\tconst FMassSmartObjectHandler MassSmartObjectHandler(\n\t\t\tMassContext.GetEntityManager(),\n\t\t\tMassContext.GetEntitySubsystemExecutionContext(),\n\t\t\tSmartObjectSubsystem,\n\t\t\tSignalSubsystem);\n\t\tMassSmartObjectHandler.RemoveRequest(InstanceData.SearchRequestID);\n\t\tInstanceData.SearchRequestID.Reset();\n\n\t\tMASSBEHAVIOR_LOG(Verbose, TEXT(\"Cancelling pending SmartObject search on ExitState.\"));\n\t}\n}\n\nvoid FMassFindSmartObjectTask::StateCompleted(FStateTreeExecutionContext& Context, const EStateTreeRunStatus CompletionStatus, const FStateTreeActiveStates& CompletedActiveStates) const\n{\n\tconst UWorld* World = Context.GetWorld();\n\t\n\tFMassSmartObjectUserFragment& SOUser = Context.GetExternalData(SmartObjectUserHandle);\n\n\t// This is done here because of the limited ways we can communicate between FindSmartObject() and ClaimSmartObject().\n\t// ClaimSmartObject() sets the InteractionCooldownEndTime when it tries to claim the candidates.\n\t// Use that to signal that the candidates have been consumed (either in success or failure).\n\t// Doing the reset here, allows the conditions relying on bHasCandidateSlots to function properly\n\t// in failure cases (i.e. don't try to use failed slot).\n\t// This code assumes that ClaimSmartObject() accesses the candidates only in EnterState() and Tick().\n\tif (SOUser.InteractionHandle.IsValid() || SOUser.InteractionCooldownEndTime > World->GetTimeSeconds())\n\t{\n\t\tMASSBEHAVIOR_LOG(Verbose, TEXT(\"StateCompleted: Reset candidates because of interaction cooldown.\"));\n\n\t\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t\tInstanceData.FoundCandidateSlots.Reset();\n\t\tInstanceData.bHasCandidateSlots = false;\n\t}\n}\n\nEStateTreeRunStatus FMassFindSmartObjectTask::Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const\n{\n\tconst UWorld* World = Context.GetWorld();\n\tUSmartObjectSubsystem& SmartObjectSubsystem = Context.GetExternalData(SmartObjectSubsystemHandle);\n\tUMassSignalSubsystem& SignalSubsystem = Context.GetExternalData(MassSignalSubsystemHandle);\n\tconst FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);\n\tconst FMassSmartObjectHandler MassSmartObjectHandler(\n\t\tMassContext.GetEntityManager(),\n\t\tMassContext.GetEntitySubsystemExecutionContext(),\n\t\tSmartObjectSubsystem,\n\t\tSignalSubsystem);\n\n\tFMassSmartObjectUserFragment& SOUser = Context.GetExternalData(SmartObjectUserHandle);\n\n\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\t\n\t// Try to search for new slots if not already in progress.\n\tif (!InstanceData.SearchRequestID.IsSet())\n\t{\n\t\t// If the user is already using a SmartObject, or has used interaction recently, skip search and empty results. \n\t\tif (SOUser.InteractionHandle.IsValid() || SOUser.InteractionCooldownEndTime > World->GetTimeSeconds())\n\t\t{\n\t\t\tMASSBEHAVIOR_LOG(Verbose, TEXT(\"Skipped: Recently interacted (%s %.1f)\"), SOUser.InteractionHandle.IsValid() ? TEXT(\"Interacting\") : TEXT(\"Cooldown\"), FMath::Max(0.0f, SOUser.InteractionCooldownEndTime - World->GetTimeSeconds()));\n\n\t\t\t// Do not offer any new candidates during cool down.\n\t\t\tInstanceData.FoundCandidateSlots.Reset();\n\t\t\tInstanceData.bHasCandidateSlots = false;\n\n\t\t\treturn EStateTreeRunStatus::Running;\n\t\t}\n\n\t\t// Check to see if we should request. \n\t\tconst FMassZoneGraphLaneLocationFragment* LaneLocation = Context.GetExternalDataPtr(LocationHandle);\n\t\tconst bool bLaneHasChanged = (LaneLocation && InstanceData.LastLane != LaneLocation->LaneHandle);\n\t\tconst bool bTimeForNextUpdate = World->GetTimeSeconds() > InstanceData.NextUpdate;\n\n\t\tif (bTimeForNextUpdate || bLaneHasChanged)\n\t\t{\n\t\t\t// Use lanes if possible for faster queries using zone graph annotations\n\t\t\tconst FMassEntityHandle RequestingEntity = MassContext.GetEntity();\n\t\t\tif (LaneLocation != nullptr)\n\t\t\t{\n\t\t\t\tMASSBEHAVIOR_CLOG(!LaneLocation->LaneHandle.IsValid(), Error, TEXT(\"Always expecting a valid lane from the ZoneGraph movement\"));\n\t\t\t\tif (LaneLocation->LaneHandle.IsValid())\n\t\t\t\t{\n\t\t\t\t\tMASSBEHAVIOR_LOG(Log, TEXT(\"Requesting search candidates from lane %s (%s/%s)\"),\n\t\t\t\t\t\t*LaneLocation->LaneHandle.ToString(),\n\t\t\t\t\t\t*LexToString(LaneLocation->DistanceAlongLane),\n\t\t\t\t\t\t*LexToString(LaneLocation->LaneLength));\n\n\t\t\t\t\tInstanceData.SearchRequestID = MassSmartObjectHandler.FindCandidatesAsync(RequestingEntity, SOUser.UserTags, ActivityRequirements, { LaneLocation->LaneHandle, LaneLocation->DistanceAlongLane });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconst FTransformFragment& TransformFragment = Context.GetExternalData(EntityTransformHandle);\n\t\t\t\tInstanceData.SearchRequestID = MassSmartObjectHandler.FindCandidatesAsync(RequestingEntity, SOUser.UserTags, ActivityRequirements, TransformFragment.GetTransform().GetLocation());\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Poll to see if the candidates are ready.\n\t\t// A \"candidates ready\" signal will trigger the state tree evaluation when candidates are ready.\n\t\tif (const FMassSmartObjectCandidateSlots* NewCandidates = MassSmartObjectHandler.GetRequestCandidates(InstanceData.SearchRequestID))\n\t\t{\n\t\t\tMASSBEHAVIOR_LOG(Log, TEXT(\"Found %d smart object candidates\"), NewCandidates->NumSlots);\n\n\t\t\tInstanceData.FoundCandidateSlots = *NewCandidates;\n\t\t\tInstanceData.bHasCandidateSlots = InstanceData.FoundCandidateSlots.NumSlots > 0;\n\t\t\t\n\t\t\t// Remove requests\n\t\t\tMassSmartObjectHandler.RemoveRequest(InstanceData.SearchRequestID);\n\t\t\tInstanceData.SearchRequestID.Reset();\n\n\t\t\t// Schedule next update.\n\t\t\tconst FMassEntityHandle Entity = MassContext.GetEntity(); \n\n\t\t\tconstexpr float SearchIntervalDeviation = 0.1f;\n\t\t\tconst float DelayInSeconds = SearchInterval * FMath::FRandRange(1.0f - SearchIntervalDeviation, 1.0f + SearchIntervalDeviation);\n\t\t\t\t\n\t\t\tInstanceData.NextUpdate = World->GetTimeSeconds() + DelayInSeconds;\n\t\t\tUMassSignalSubsystem& MassSignalSubsystem = Context.GetExternalData(MassSignalSubsystemHandle);\n\t\t\tMassSignalSubsystem.DelaySignalEntity(UE::Mass::Signals::SmartObjectRequestCandidates, Entity, DelayInSeconds);\n\t\t}\n\t}\n\t\n\treturn EStateTreeRunStatus::Running;\n}\n",
      "lines": 166
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\Tasks\\MassLookAtTask.cpp",
      "extension": ".cpp",
      "size_bytes": 2814,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Tasks/MassLookAtTask.h\"\n#include \"MassAIBehaviorTypes.h\"\n#include \"MassLookAtFragments.h\"\n#include \"MassSignalSubsystem.h\"\n#include \"MassStateTreeExecutionContext.h\"\n#include \"StateTreeLinker.h\"\n\nbool FMassLookAtTask::Link(FStateTreeLinker& Linker)\n{\n\tLinker.LinkExternalData(MassSignalSubsystemHandle);\n\tLinker.LinkExternalData(LookAtHandle);\n\t\n\treturn true;\n}\n\nEStateTreeRunStatus FMassLookAtTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\t\n\tInstanceData.Time = 0.f;\n\t\n\tconst FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);\n\tFMassLookAtFragment& LookAtFragment = MassContext.GetExternalData(LookAtHandle);\n\n\tLookAtFragment.Reset();\n\tLookAtFragment.LookAtMode = LookAtMode;\n\t\n\tif (LookAtMode == EMassLookAtMode::LookAtEntity)\n\t{\n\t\tif (!InstanceData.TargetEntity.IsSet())\n\t\t{\n\t\t\tLookAtFragment.LookAtMode = EMassLookAtMode::LookForward;\n\t\t\tMASSBEHAVIOR_LOG(Error, TEXT(\"Failed LookAt: invalid target entity\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLookAtFragment.LookAtMode = EMassLookAtMode::LookAtEntity;\n\t\t\tLookAtFragment.TrackedEntity = InstanceData.TargetEntity;\n\t\t}\n\t}\n\n\tLookAtFragment.RandomGazeMode = RandomGazeMode;\n\tLookAtFragment.RandomGazeYawVariation = RandomGazeYawVariation;\n\tLookAtFragment.RandomGazePitchVariation = RandomGazePitchVariation;\n\tLookAtFragment.bRandomGazeEntities = bRandomGazeEntities;\n\n\t// A Duration <= 0 indicates that the task runs until a transition in the state tree stops it.\n\t// Otherwise we schedule a signal to end the task.\n\tif (InstanceData.Duration > 0.0f)\n\t{\n\t\tUMassSignalSubsystem& MassSignalSubsystem = MassContext.GetExternalData(MassSignalSubsystemHandle);\n\t\tMassSignalSubsystem.DelaySignalEntity(UE::Mass::Signals::LookAtFinished, MassContext.GetEntity(), InstanceData.Duration);\n\t}\n\n\treturn EStateTreeRunStatus::Running;\n}\n\nvoid FMassLookAtTask::ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\tconst FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);\n\tFMassLookAtFragment& LookAtFragment = MassContext.GetExternalData(LookAtHandle);\n\t\n\tLookAtFragment.Reset();\n}\n\nEStateTreeRunStatus FMassLookAtTask::Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const\n{\n\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\t\n\tInstanceData.Time += DeltaTime;\n\t\n\treturn InstanceData.Duration <= 0.0f ? EStateTreeRunStatus::Running : (InstanceData.Time < InstanceData.Duration ? EStateTreeRunStatus::Running : EStateTreeRunStatus::Succeeded);\n}\n",
      "lines": 75
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\Tasks\\MassUseSmartObjectTask.cpp",
      "extension": ".cpp",
      "size_bytes": 6864,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Tasks/MassUseSmartObjectTask.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassAIBehaviorTypes.h\"\n#include \"MassSignalSubsystem.h\"\n#include \"MassSmartObjectHandler.h\"\n#include \"MassSmartObjectFragments.h\"\n#include \"MassStateTreeExecutionContext.h\"\n#include \"MassNavigationFragments.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"MassZoneGraphNavigationUtils.h\"\n#include \"Engine/World.h\"\n#include \"StateTreeLinker.h\"\n\n//----------------------------------------------------------------------//\n// FMassUseSmartObjectTask\n//----------------------------------------------------------------------//\n\nFMassUseSmartObjectTask::FMassUseSmartObjectTask()\n{\n\t// This task should not react to Enter/ExitState when the state is reselected.\n\tbShouldStateChangeOnReselect = false;\n}\n\nbool FMassUseSmartObjectTask::Link(FStateTreeLinker& Linker)\n{\n\tLinker.LinkExternalData(SmartObjectSubsystemHandle);\n\tLinker.LinkExternalData(MassSignalSubsystemHandle);\n\tLinker.LinkExternalData(EntityTransformHandle);\n\tLinker.LinkExternalData(SmartObjectUserHandle);\n\tLinker.LinkExternalData(MoveTargetHandle);\n\n\treturn true;\n}\n\nEStateTreeRunStatus FMassUseSmartObjectTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\tFMassSmartObjectUserFragment& SOUser = Context.GetExternalData(SmartObjectUserHandle);\n\t\n\tif (SOUser.InteractionHandle.IsValid())\n\t{\n\t\tMASSBEHAVIOR_LOG(Error, TEXT(\"Agent is already using smart object slot %s.\"), *LexToString(SOUser.InteractionHandle));\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\n\tUSmartObjectSubsystem& SmartObjectSubsystem = Context.GetExternalData(SmartObjectSubsystemHandle);\n\tUMassSignalSubsystem& SignalSubsystem = Context.GetExternalData(MassSignalSubsystemHandle);\n\tFMassMoveTargetFragment& MoveTarget = Context.GetExternalData(MoveTargetHandle);\n\n\tconst FInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\t// Setup MassSmartObject handler and start interaction\n\tconst FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);\n\tconst FMassSmartObjectHandler MassSmartObjectHandler(MassContext.GetEntityManager(), MassContext.GetEntitySubsystemExecutionContext(), SmartObjectSubsystem, SignalSubsystem);\n\n\tif (!MassSmartObjectHandler.StartUsingSmartObject(MassContext.GetEntity(), SOUser, InstanceData.ClaimedSlot))\n\t{\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\n\t// @todo: we should have common API to control this, currently handle via tasks.\n\tconst UWorld* World = Context.GetWorld();\n\tcheckf(World != nullptr, TEXT(\"A valid world is expected from the execution context\"));\n\n\tMoveTarget.CreateNewAction(EMassMovementAction::Animate, *World);\n\tconst bool bSuccess = UE::MassNavigation::ActivateActionAnimate(*World, Context.GetOwner(), MassContext.GetEntity(), MoveTarget);\n\n\treturn bSuccess ? EStateTreeRunStatus::Running : EStateTreeRunStatus::Failed;\n}\n\nvoid FMassUseSmartObjectTask::ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\tFMassSmartObjectUserFragment& SOUser = Context.GetExternalData(SmartObjectUserHandle);\n\n\tif (SOUser.InteractionHandle.IsValid())\n\t{\n\t\tMASSBEHAVIOR_LOG(VeryVerbose, TEXT(\"Exiting state with a valid InteractionHandle: stop using the smart object.\"));\n\n\t\tconst FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);\n\t\tUSmartObjectSubsystem& SmartObjectSubsystem = Context.GetExternalData(SmartObjectSubsystemHandle);\n\t\tUMassSignalSubsystem& SignalSubsystem = Context.GetExternalData(MassSignalSubsystemHandle);\n\t\tconst FMassSmartObjectHandler MassSmartObjectHandler(MassContext.GetEntityManager(), MassContext.GetEntitySubsystemExecutionContext(), SmartObjectSubsystem, SignalSubsystem);\n\t\tMassSmartObjectHandler.StopUsingSmartObject(MassContext.GetEntity(), SOUser, EMassSmartObjectInteractionStatus::Aborted);\n\t}\n\telse\n\t{\n\t\tMASSBEHAVIOR_LOG(VeryVerbose, TEXT(\"Exiting state with an invalid ClaimHandle: nothing to do.\"));\n\t}\n}\n\nvoid FMassUseSmartObjectTask::StateCompleted(FStateTreeExecutionContext& Context, const EStateTreeRunStatus CompletionStatus, const FStateTreeActiveStates& CompletedActiveStates) const\n{\n\tFMassSmartObjectUserFragment& SOUser = Context.GetExternalData(SmartObjectUserHandle);\n\n\tif (SOUser.InteractionHandle.IsValid())\n\t{\n\t\tMASSBEHAVIOR_LOG(VeryVerbose, TEXT(\"Completing state with a valid InteractionHandle: stop using the smart object.\"));\n\n\t\tconst FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);\n\t\tUSmartObjectSubsystem& SmartObjectSubsystem = Context.GetExternalData(SmartObjectSubsystemHandle);\n\t\tUMassSignalSubsystem& SignalSubsystem = Context.GetExternalData(MassSignalSubsystemHandle);\n\t\tconst FMassSmartObjectHandler MassSmartObjectHandler(MassContext.GetEntityManager(), MassContext.GetEntitySubsystemExecutionContext(), SmartObjectSubsystem, SignalSubsystem);\n\t\tconst EMassSmartObjectInteractionStatus NewStatus = (CompletionStatus == EStateTreeRunStatus::Succeeded)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? EMassSmartObjectInteractionStatus::TaskCompleted\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: EMassSmartObjectInteractionStatus::Aborted;\n\t\tMassSmartObjectHandler.StopUsingSmartObject(MassContext.GetEntity(), SOUser, NewStatus);\n\t}\n}\n\nEStateTreeRunStatus FMassUseSmartObjectTask::Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const\n{\n\tEStateTreeRunStatus Status = EStateTreeRunStatus::Failed;\n\n\tFMassSmartObjectUserFragment& SOUser = Context.GetExternalData(SmartObjectUserHandle);\n\tswitch (SOUser.InteractionStatus)\n\t{\n\tcase EMassSmartObjectInteractionStatus::InProgress:\n\t\tMASSBEHAVIOR_LOG(VeryVerbose, TEXT(\"Interacting ...\"));\n\t\tStatus = EStateTreeRunStatus::Running;\n\t\tbreak;\n\n\tcase EMassSmartObjectInteractionStatus::BehaviorCompleted:\n\t\tMASSBEHAVIOR_LOG(Log, TEXT(\"Behavior completed\"));\n\t\tStatus = EStateTreeRunStatus::Succeeded;\n\t\tbreak;\n\n\tcase EMassSmartObjectInteractionStatus::TaskCompleted:\n\t\tensureMsgf(false, TEXT(\"Not expecting to tick an already completed task\"));\n\t\tStatus = EStateTreeRunStatus::Failed;\n\t\tbreak;\n\n\tcase EMassSmartObjectInteractionStatus::Aborted:\n\t\tMASSBEHAVIOR_LOG(Log, TEXT(\"Interaction aborted\"));\n\t\tStatus = EStateTreeRunStatus::Failed;\n\t\tbreak;\n\n\tcase EMassSmartObjectInteractionStatus::Unset:\n\t\tMASSBEHAVIOR_LOG(Error, TEXT(\"Error while using smart object: interaction state is not valid\"));\n\t\tStatus = EStateTreeRunStatus::Failed;\n\t\tbreak;\n\n\tdefault:\n\t\tensureMsgf(false, TEXT(\"Unhandled interaction status %s => Returning EStateTreeRunStatus::Failed\"), *UEnum::GetValueAsString(SOUser.InteractionStatus));\n\t\tStatus = EStateTreeRunStatus::Failed;\n\t}\n\n\treturn Status;\n}\n",
      "lines": 149
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\Tasks\\MassZoneGraphFindEscapeTarget.cpp",
      "extension": ".cpp",
      "size_bytes": 6822,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Tasks/MassZoneGraphFindEscapeTarget.h\"\n#include \"StateTreeExecutionContext.h\"\n#include \"MassStateTreeSubsystem.h\"\n#include \"ZoneGraphSubsystem.h\"\n#include \"ZoneGraphAnnotationSubsystem.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"Annotations/ZoneGraphDisturbanceAnnotation.h\"\n#include \"MassAIBehaviorTypes.h\"\n#include \"MassStateTreeExecutionContext.h\"\n#include \"ZoneGraphSettings.h\"\n#include \"StateTreeLinker.h\"\n#include \"MassDebugger.h\"\n\n\nFMassZoneGraphFindEscapeTarget::FMassZoneGraphFindEscapeTarget()\n{\n}\n\nbool FMassZoneGraphFindEscapeTarget::Link(FStateTreeLinker& Linker)\n{\n\tLinker.LinkExternalData(LocationHandle);\n\tLinker.LinkExternalData(ZoneGraphSubsystemHandle);\n\tLinker.LinkExternalData(ZoneGraphAnnotationSubsystemHandle);\n\n\treturn true;\n}\n\nEStateTreeRunStatus FMassZoneGraphFindEscapeTarget::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\tFMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);\n\tbool bDisplayDebug = false;\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\tbDisplayDebug = UE::Mass::Debug::IsDebuggingEntity(MassContext.GetEntity());\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\tconst FMassZoneGraphLaneLocationFragment& LaneLocation = Context.GetExternalData(LocationHandle);\n\tUZoneGraphSubsystem& ZoneGraphSubsystem = Context.GetExternalData(ZoneGraphSubsystemHandle);\n\tUZoneGraphAnnotationSubsystem& ZoneGraphAnnotationSubsystem = Context.GetExternalData(ZoneGraphAnnotationSubsystemHandle);\n\n\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\tif (!LaneLocation.LaneHandle.IsValid())\n\t{\n\t\tMASSBEHAVIOR_LOG(Error, TEXT(\"Invalid lane handle.\"));\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\t\t\t\n\tconst FZoneGraphStorage* ZoneGraphStorage = ZoneGraphSubsystem.GetZoneGraphStorage(LaneLocation.LaneHandle.DataHandle);\n\tif (!ZoneGraphStorage)\n\t{\n\t\tMASSBEHAVIOR_LOG(Error, TEXT(\"Missing ZoneGraph Storage for current lane %s.\"), *LaneLocation.LaneHandle.ToString());\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\n\tconst UZoneGraphDisturbanceAnnotation* DisturbanceAnnotation = Cast<const UZoneGraphDisturbanceAnnotation>(ZoneGraphAnnotationSubsystem.GetFirstAnnotationForTag(DisturbanceAnnotationTag));\n\tif (!DisturbanceAnnotation)\n\t{\n\t\tMASSBEHAVIOR_LOG(Error, TEXT(\"Failed to find Flee Behavior for tag %s on lane %s.\"), *UE::ZoneGraph::Helpers::GetTagName(DisturbanceAnnotationTag).ToString(), *LaneLocation.LaneHandle.ToString());\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\n\tconst FZoneGraphEscapeLaneAction* EscapeAction = DisturbanceAnnotation->GetEscapeAction(LaneLocation.LaneHandle);\n\tif (!EscapeAction)\n\t{\n\t\tMASSBEHAVIOR_LOG(Warning, TEXT(\"Failed to find escape action for current lane %s.\"), *LaneLocation.LaneHandle.ToString());\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\n\tconst uint8 SpanIndex = EscapeAction->FindSpanIndex(LaneLocation.DistanceAlongLane);\n\tconst FZoneGraphEscapeLaneSpan& EscapeSpan = EscapeAction->Spans[SpanIndex];\n\tconst float MoveDir = EscapeSpan.bReverseLaneDirection ? -1.f : 1.f;\n\n\tconstexpr float AdjacentMoveDistance = 50.0f;\n\tconstexpr float MoveDistanceRandomDeviation = 250.0f;\n\tconstexpr float BaseMoveDistance = 800.0f;\n\tconst float MoveDistance = FMath::Max(0.0f, BaseMoveDistance + FMath::RandRange(-MoveDistanceRandomDeviation, MoveDistanceRandomDeviation));\n\n\tif (EscapeSpan.ExitLaneIndex == INDEX_NONE)\n\t{\n\t\tMASSBEHAVIOR_LOG(Warning, TEXT(\"Invalid flee exit lane.\"));\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\t\n\tif (EscapeSpan.ExitLinkType == EZoneLaneLinkType::Adjacent)\n\t{\n\t\t// TODO: could improve this by checking the adjacent lane type and move based on that:\n\t\t// - split: move closer to beginning of the lane\n\t\t// - merge: move closer to end of the lane\n\t\t// - adjacent: ?\n\t\t// Could also try to sample few locations along the lane to see which is closest.\n\t\t\n\t\t// Small move, and goto adjacent lane\n\t\tInstanceData.EscapeTargetLocation.LaneHandle = LaneLocation.LaneHandle;\n\t\tInstanceData.EscapeTargetLocation.TargetDistance = FMath::Clamp(LaneLocation.DistanceAlongLane + AdjacentMoveDistance * MoveDir, 0.f, LaneLocation.LaneLength);\n\t\tInstanceData.EscapeTargetLocation.NextExitLinkType = EZoneLaneLinkType::Adjacent;\n\t\tInstanceData.EscapeTargetLocation.NextLaneHandle = FZoneGraphLaneHandle(EscapeSpan.ExitLaneIndex, ZoneGraphStorage->DataHandle);\n\t\tInstanceData.EscapeTargetLocation.bMoveReverse = EscapeSpan.bReverseLaneDirection;\n\t\tInstanceData.EscapeTargetLocation.EndOfPathIntent = EMassMovementAction::Move;\n\n\t\tMASSBEHAVIOR_CLOG(bDisplayDebug, Log, TEXT(\"Switching from lane %s to adjacent lane %s.\"),\n\t\t\t*LaneLocation.LaneHandle.ToString(), *InstanceData.EscapeTargetLocation.NextLaneHandle.ToString());\n\t}\n\telse\n\t{\n\t\t// Forward or backwards on current lane.\n\t\tInstanceData.EscapeTargetLocation.LaneHandle = LaneLocation.LaneHandle;\n\t\tInstanceData.EscapeTargetLocation.TargetDistance = LaneLocation.DistanceAlongLane + MoveDistance * MoveDir;\n\t\tInstanceData.EscapeTargetLocation.NextExitLinkType = EZoneLaneLinkType::None;\n\t\tInstanceData.EscapeTargetLocation.NextLaneHandle.Reset();\n\t\tInstanceData.EscapeTargetLocation.bMoveReverse = EscapeSpan.bReverseLaneDirection;\n\t\tInstanceData.EscapeTargetLocation.EndOfPathIntent = EMassMovementAction::Move;\n\n\t\t// When close to end of a lane, choose next lane.\n\t\tconst bool bPastStart = InstanceData.EscapeTargetLocation.TargetDistance < 0.0f;\n\t\tconst bool bPastEnd = InstanceData.EscapeTargetLocation.TargetDistance > LaneLocation.LaneLength;\n\t\tif (bPastStart || bPastEnd)\n\t\t{\n\t\t\tInstanceData.EscapeTargetLocation.TargetDistance = FMath::Clamp(InstanceData.EscapeTargetLocation.TargetDistance, 0.0f, LaneLocation.LaneLength);\n\n\t\t\tInstanceData.EscapeTargetLocation.NextExitLinkType = EscapeSpan.ExitLinkType;\n\t\t\tInstanceData.EscapeTargetLocation.NextLaneHandle = FZoneGraphLaneHandle(EscapeSpan.ExitLaneIndex, ZoneGraphStorage->DataHandle);\n\n\t\t\tMASSBEHAVIOR_CLOG(bDisplayDebug, Log, TEXT(\"Advancing %s along flee lane %s to next lane %s at distance %.1f.\"),\n\t\t\t\tInstanceData.EscapeTargetLocation.bMoveReverse ? TEXT(\"forward\") : TEXT(\"reverse\"),\n\t\t\t\t*InstanceData.EscapeTargetLocation.LaneHandle.ToString(), *InstanceData.EscapeTargetLocation.NextLaneHandle.ToString(),\n\t\t\t\tInstanceData.EscapeTargetLocation.TargetDistance);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMASSBEHAVIOR_CLOG(bDisplayDebug, Log, TEXT(\"Advancing %s along flee lane %s to distance %.1f.\"),\n\t\t\t\tInstanceData.EscapeTargetLocation.bMoveReverse ? TEXT(\"forward\") : TEXT(\"reverse\"),\n\t\t\t\t*InstanceData.EscapeTargetLocation.LaneHandle.ToString(), InstanceData.EscapeTargetLocation.TargetDistance);\n\t\t}\n\t}\n\n\treturn EStateTreeRunStatus::Running;\n}\n",
      "lines": 140
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\Tasks\\MassZoneGraphFindSmartObjectTarget.cpp",
      "extension": ".cpp",
      "size_bytes": 3837,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Tasks/MassZoneGraphFindSmartObjectTarget.h\"\n#include \"ZoneGraphAnnotationSubsystem.h\"\n#include \"MassAIBehaviorTypes.h\"\n#include \"SmartObjectSubsystem.h\"\n#include \"MassSmartObjectFragments.h\"\n#include \"MassSmartObjectSettings.h\"\n#include \"MassStateTreeExecutionContext.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"SmartObjectZoneAnnotations.h\"\n#include \"StateTreeLinker.h\"\n\nbool FMassZoneGraphFindSmartObjectTarget::Link(FStateTreeLinker& Linker)\n{\n\tLinker.LinkExternalData(LocationHandle);\n\tLinker.LinkExternalData(AnnotationSubsystemHandle);\n\tLinker.LinkExternalData(SmartObjectSubsystemHandle);\n\t\n\treturn true;\n}\n\nEStateTreeRunStatus FMassZoneGraphFindSmartObjectTarget::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\tconst UZoneGraphAnnotationSubsystem& AnnotationSubsystem = Context.GetExternalData(AnnotationSubsystemHandle);\n\tconst USmartObjectSubsystem& SmartObjectSubsystem = Context.GetExternalData(SmartObjectSubsystemHandle);\n\tconst FMassZoneGraphLaneLocationFragment& LaneLocation = Context.GetExternalData(LocationHandle);\n\tconst FZoneGraphLaneHandle LaneHandle(LaneLocation.LaneHandle);\n\n\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\tInstanceData.SmartObjectLocation.Reset();\n\n\tif (!InstanceData.ClaimedSlot.SmartObjectHandle.IsValid())\n\t{\n\t\tMASSBEHAVIOR_LOG(Error, TEXT(\"Invalid claimed smart object ID.\"));\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\n\tif (!LaneHandle.IsValid())\n\t{\n\t\tMASSBEHAVIOR_LOG(Error, TEXT(\"Invalid lane location.\"));\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\n\tconst FZoneGraphTag SmartObjectTag = GetDefault<UMassSmartObjectSettings>()->SmartObjectTag;\n\tconst USmartObjectZoneAnnotations* SOAnnotations = Cast<USmartObjectZoneAnnotations>(AnnotationSubsystem.GetFirstAnnotationForTag(SmartObjectTag));\n\tconst FTransform Transform = SmartObjectSubsystem.GetSlotTransform(InstanceData.ClaimedSlot).Get(FTransform::Identity);\n\n\tInstanceData.SmartObjectLocation.LaneHandle = LaneHandle;\n\tInstanceData.SmartObjectLocation.NextExitLinkType = EZoneLaneLinkType::None;\n\tInstanceData.SmartObjectLocation.NextLaneHandle.Reset();\n\tInstanceData.SmartObjectLocation.bMoveReverse = false;\n\tInstanceData.SmartObjectLocation.EndOfPathIntent = EMassMovementAction::Stand;\n\tInstanceData.SmartObjectLocation.EndOfPathPosition = Transform.GetLocation();\n\t// Can't set direction at the moment since it seems problematic if it's opposite to the steering direction\n\t//SmartObjectLocation.EndOfPathDirection = SOUser.TargetDirection;\n\n\t// Let's start moving toward the interaction a bit before the entry point.\n\tInstanceData.SmartObjectLocation.AnticipationDistance.Set(100.f);\n\n\t// Find entry point on lane for the claimed object\n\tTOptional<FSmartObjectLaneLocation> SmartObjectLaneLocation;\n\tif (SOAnnotations != nullptr)\n\t{\n\t\tSmartObjectLaneLocation = SOAnnotations->GetSmartObjectLaneLocation(LaneHandle.DataHandle, InstanceData.ClaimedSlot.SmartObjectHandle);\n\t}\n\n\tif (SmartObjectLaneLocation.IsSet())\n\t{\n\t\t// Request path along current lane to reach entry point on lane\n\t\tMASSBEHAVIOR_LOG(Log, TEXT(\"Claim successful: create path along lane to reach interaction location.\"));\n\t\tInstanceData.SmartObjectLocation.TargetDistance = SmartObjectLaneLocation.GetValue().DistanceAlongLane;\n\t}\n\telse\n\t{\n\t\t// Request path from current lane location directly to interaction location\n\t\tMASSBEHAVIOR_LOG(Warning, TEXT(\"Claim successful: create path from current lane location directly to interaction location since SmartObject zone annotations weren't found.\"));\n\t\tInstanceData.SmartObjectLocation.TargetDistance = LaneLocation.DistanceAlongLane;\n\t}\n\t\n\treturn EStateTreeRunStatus::Running;\n}\n",
      "lines": 83
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\Tasks\\MassZoneGraphPathFollowTask.cpp",
      "extension": ".cpp",
      "size_bytes": 7636,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Tasks/MassZoneGraphPathFollowTask.h\"\n\n#include \"MassAIBehaviorTypes.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassNavigationFragments.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassStateTreeExecutionContext.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"MassZoneGraphNavigationUtils.h\"\n#include \"ZoneGraphSubsystem.h\"\n#include \"StateTreeLinker.h\"\n#include \"MassDebugger.h\"\n\n\nbool FMassZoneGraphPathFollowTask::Link(FStateTreeLinker& Linker)\n{\n\tLinker.LinkExternalData(LocationHandle);\n\tLinker.LinkExternalData(MoveTargetHandle);\n\tLinker.LinkExternalData(PathRequestHandle);\n\tLinker.LinkExternalData(ShortPathHandle);\n\tLinker.LinkExternalData(CachedLaneHandle);\n\tLinker.LinkExternalData(AgentRadiusHandle);\n\tLinker.LinkExternalData(MovementParamsHandle);\n\tLinker.LinkExternalData(ZoneGraphSubsystemHandle);\n\n\treturn true;\n}\n\nbool FMassZoneGraphPathFollowTask::RequestPath(FMassStateTreeExecutionContext& Context, const FMassZoneGraphTargetLocation& RequestedTargetLocation) const\n{\n\tconst UZoneGraphSubsystem& ZoneGraphSubsystem = Context.GetExternalData(ZoneGraphSubsystemHandle);\n\tconst FMassZoneGraphLaneLocationFragment& LaneLocation = Context.GetExternalData(LocationHandle);\n\tconst FAgentRadiusFragment& AgentRadius = Context.GetExternalData(AgentRadiusHandle);\n\tFMassZoneGraphShortPathFragment& ShortPath = Context.GetExternalData(ShortPathHandle);\n\tFMassZoneGraphCachedLaneFragment& CachedLane = Context.GetExternalData(CachedLaneHandle);\n\tFMassMoveTargetFragment& MoveTarget = Context.GetExternalData(MoveTargetHandle);\n\tFMassZoneGraphPathRequestFragment& RequestFragment = Context.GetExternalData(PathRequestHandle);\n\tconst FMassMovementParameters& MovementParams = Context.GetExternalData(MovementParamsHandle);\n\n\tconst FInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\t\n\tbool bDisplayDebug = false;\n#if WITH_MASSGAMEPLAY_DEBUG\n\tbDisplayDebug = UE::Mass::Debug::IsDebuggingEntity(Context.GetEntity());\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\tif (RequestedTargetLocation.LaneHandle != LaneLocation.LaneHandle)\n\t{\n\t\tMASSBEHAVIOR_LOG(Error, TEXT(\"Target location lane %s does not match current lane location %s.\"),\n\t\t\t*RequestedTargetLocation.LaneHandle.ToString(), *LaneLocation.LaneHandle.ToString());\n\t\treturn false;\n\t}\n\n\tif (bDisplayDebug)\n\t{\n\t\tMASSBEHAVIOR_LOG(Log, TEXT(\"PathFollow Request: %s, lane %s, Start: %f End:%f, next lane %s.\"),\n\t\t\tRequestedTargetLocation.bMoveReverse ? TEXT(\"reverse\") : TEXT(\"forward\"),\n\t\t\t*LaneLocation.LaneHandle.ToString(),\n\t\t\tLaneLocation.DistanceAlongLane, RequestedTargetLocation.TargetDistance,\n\t\t\t*RequestedTargetLocation.NextLaneHandle.ToString());\n\t}\n\n\t// @todo: Combine FMassZoneGraphTargetLocation and FZoneGraphShortPathRequest.\n\tFZoneGraphShortPathRequest& PathRequest = RequestFragment.PathRequest;\n\tPathRequest.StartPosition = MoveTarget.Center;\n\tPathRequest.bMoveReverse = RequestedTargetLocation.bMoveReverse;\n\tPathRequest.TargetDistance = RequestedTargetLocation.TargetDistance;\n\tPathRequest.NextLaneHandle = RequestedTargetLocation.NextLaneHandle;\n\tPathRequest.NextExitLinkType = RequestedTargetLocation.NextExitLinkType;\n\tPathRequest.EndOfPathIntent = RequestedTargetLocation.EndOfPathIntent;\n\tPathRequest.bIsEndOfPathPositionSet = RequestedTargetLocation.EndOfPathPosition.IsSet();\n\tPathRequest.EndOfPathPosition = RequestedTargetLocation.EndOfPathPosition.Get(FVector::ZeroVector);\n\tPathRequest.bIsEndOfPathDirectionSet = RequestedTargetLocation.EndOfPathDirection.IsSet();\n\tPathRequest.EndOfPathDirection.Set(RequestedTargetLocation.EndOfPathDirection.Get(FVector::ForwardVector));\n\tPathRequest.AnticipationDistance = RequestedTargetLocation.AnticipationDistance;\n\tPathRequest.EndOfPathOffset.Set(FMath::RandRange(-AgentRadius.Radius, AgentRadius.Radius));\n\n\tconst float DesiredSpeed = FMath::Min(MovementParams.GenerateDesiredSpeed(InstanceData.MovementStyle, Context.GetEntity().Index) * InstanceData.SpeedScale, MovementParams.MaxSpeed);\n\tconst UWorld* World = Context.GetWorld();\n\tcheckf(World != nullptr, TEXT(\"A valid world is expected from the execution context\"));\n\n\tMoveTarget.CreateNewAction(EMassMovementAction::Move, *World);\n\treturn UE::MassNavigation::ActivateActionMove(*World, Context.GetOwner(), Context.GetEntity(), ZoneGraphSubsystem, LaneLocation, PathRequest, AgentRadius.Radius, DesiredSpeed, MoveTarget, ShortPath, CachedLane);\n}\n\nEStateTreeRunStatus FMassZoneGraphPathFollowTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\tFMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);\n\tconst FInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\tbool bDisplayDebug = false;\n#if WITH_MASSGAMEPLAY_DEBUG\n\tbDisplayDebug = UE::Mass::Debug::IsDebuggingEntity(MassContext.GetEntity());\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\tif (bDisplayDebug)\n\t{\n\t\tMASSBEHAVIOR_LOG(Verbose, TEXT(\"enterstate.\"));\n\t}\n\n\tconst FMassZoneGraphLaneLocationFragment& LaneLocation = Context.GetExternalData(LocationHandle);\n\tconst FMassZoneGraphTargetLocation* TargetLocation = InstanceData.TargetLocation.GetPtr<FMassZoneGraphTargetLocation>();\n\n\tif (TargetLocation == nullptr)\n\t{\n\t\tMASSBEHAVIOR_LOG(Error, TEXT(\"Target is not defined.\"));\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\t\n\tif (TargetLocation->LaneHandle != LaneLocation.LaneHandle)\n\t{\n\t\tMASSBEHAVIOR_LOG(Error, TEXT(\"Target is not on current lane, target lane is %s expected %s.\"), *TargetLocation->LaneHandle.ToString(), *LaneLocation.LaneHandle.ToString());\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\n\tif (!RequestPath(MassContext, *TargetLocation))\n\t{\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\n\treturn EStateTreeRunStatus::Running;\n}\n\nEStateTreeRunStatus FMassZoneGraphPathFollowTask::Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const\n{\n\tFMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);\n\tconst FInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\tbool bDisplayDebug = false;\n#if WITH_MASSGAMEPLAY_DEBUG\n\tbDisplayDebug = UE::Mass::Debug::IsDebuggingEntity(MassContext.GetEntity());\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\tif (bDisplayDebug)\n\t{\n\t\tMASSBEHAVIOR_LOG(Verbose, TEXT(\"tick\"));\n\t}\n\n\tconst FMassZoneGraphShortPathFragment& ShortPath = Context.GetExternalData(ShortPathHandle);\n\tconst FMassZoneGraphLaneLocationFragment& LaneLocation = Context.GetExternalData(LocationHandle);\n\tconst FMassZoneGraphTargetLocation* TargetLocation = InstanceData.TargetLocation.GetPtr<FMassZoneGraphTargetLocation>();\n\n\t// Current path follow is done, but it was partial (i.e. many points on a curve), try again until we get there.\n\tif (ShortPath.IsDone() && ShortPath.bPartialResult)\n\t{\n\t\tif (TargetLocation == nullptr)\n\t\t{\n\t\t\tMASSBEHAVIOR_LOG(Error, TEXT(\"Target is not defined.\"));\n\t\t\treturn EStateTreeRunStatus::Failed;\n\t\t}\n\t\tif (TargetLocation->LaneHandle != LaneLocation.LaneHandle)\n\t\t{\n\t\t\tMASSBEHAVIOR_LOG(Error, TEXT(\"Target is not on current lane, target lane is %s expected %s.\"), *TargetLocation->LaneHandle.ToString(), *LaneLocation.LaneHandle.ToString());\n\t\t\treturn EStateTreeRunStatus::Failed;\n\t\t}\n\t\t\n\t\tif (!RequestPath(MassContext, *TargetLocation))\n\t\t{\n\t\t\tMASSBEHAVIOR_LOG(Error, TEXT(\"Failed to request path.\"));\n\t\t\treturn EStateTreeRunStatus::Failed;\n\t\t}\n\t}\n\t\n\treturn ShortPath.IsDone() ? EStateTreeRunStatus::Succeeded : EStateTreeRunStatus::Running;\n}\n",
      "lines": 165
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\Private\\Tasks\\MassZoneGraphStandTask.cpp",
      "extension": ".cpp",
      "size_bytes": 3515,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Tasks/MassZoneGraphStandTask.h\"\n#include \"StateTreeExecutionContext.h\"\n#include \"ZoneGraphSubsystem.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"MassZoneGraphNavigationUtils.h\"\n#include \"MassAIBehaviorTypes.h\"\n#include \"MassNavigationFragments.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassStateTreeExecutionContext.h\"\n#include \"MassSignalSubsystem.h\"\n#include \"MassSimulationLOD.h\"\n#include \"StateTreeLinker.h\"\n\nbool FMassZoneGraphStandTask::Link(FStateTreeLinker& Linker)\n{\n\tLinker.LinkExternalData(LocationHandle);\n\tLinker.LinkExternalData(MoveTargetHandle);\n\tLinker.LinkExternalData(ShortPathHandle);\n\tLinker.LinkExternalData(CachedLaneHandle);\n\tLinker.LinkExternalData(MovementParamsHandle);\n\tLinker.LinkExternalData(ZoneGraphSubsystemHandle);\n\tLinker.LinkExternalData(MassSignalSubsystemHandle);\n\n\treturn true;\n}\n\nEStateTreeRunStatus FMassZoneGraphStandTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\tconst FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);\n\n\tconst FMassZoneGraphLaneLocationFragment& LaneLocation = Context.GetExternalData(LocationHandle);\n\tconst UZoneGraphSubsystem& ZoneGraphSubsystem = Context.GetExternalData(ZoneGraphSubsystemHandle);\n\tconst FMassMovementParameters& MovementParams = Context.GetExternalData(MovementParamsHandle);\n\n\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\tif (!LaneLocation.LaneHandle.IsValid())\n\t{\n\t\tMASSBEHAVIOR_LOG(Error, TEXT(\"Invalid lande handle\"));\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\n\tFMassZoneGraphShortPathFragment& ShortPath = Context.GetExternalData(ShortPathHandle);\n\tFMassZoneGraphCachedLaneFragment& CachedLane = Context.GetExternalData(CachedLaneHandle);\n\tFMassMoveTargetFragment& MoveTarget = Context.GetExternalData(MoveTargetHandle);\n\n\t// TODO: This could be smarter too, like having a stand location/direction, or even make a small path to stop, if we're currently running.\n\n\tconst UWorld* World = Context.GetWorld();\n\tcheckf(World != nullptr, TEXT(\"A valid world is expected from the execution context\"));\n\n\tMoveTarget.CreateNewAction(EMassMovementAction::Stand, *World);\n\tconst bool bSuccess = UE::MassNavigation::ActivateActionStand(*World, Context.GetOwner(), MassContext.GetEntity(), ZoneGraphSubsystem, LaneLocation, MovementParams.DefaultDesiredSpeed, MoveTarget, ShortPath, CachedLane);\n\tif (!bSuccess)\n\t{\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\n\tInstanceData.Time = 0.0f;\n\n\t// A Duration <= 0 indicates that the task runs until a transition in the state tree stops it.\n\t// Otherwise we schedule a signal to end the task.\n\tif (InstanceData.Duration > 0.0f)\n\t{\n\t\tUMassSignalSubsystem& MassSignalSubsystem = Context.GetExternalData(MassSignalSubsystemHandle);\n\t\tMassSignalSubsystem.DelaySignalEntity(UE::Mass::Signals::StandTaskFinished, MassContext.GetEntity(), InstanceData.Duration);\n\t}\n\n\treturn EStateTreeRunStatus::Running;\n}\n\nEStateTreeRunStatus FMassZoneGraphStandTask::Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const\n{\n\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\t\n\tInstanceData.Time += DeltaTime;\n\treturn InstanceData.Duration <= 0.0f ? EStateTreeRunStatus::Running : (InstanceData.Time < InstanceData.Duration ? EStateTreeRunStatus::Running : EStateTreeRunStatus::Succeeded);\n}\n",
      "lines": 80
    },
    {
      "file_path": "MassAI\\MassAIDebug\\Private\\GameplayDebuggerCategory_Mass.cpp",
      "extension": ".cpp",
      "size_bytes": 51051,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"GameplayDebuggerCategory_Mass.h\"\n\n#if WITH_GAMEPLAY_DEBUGGER && WITH_MASSGAMEPLAY_DEBUG\n#include \"MassGameplayDebugTypes.h\"\n#include \"MassEntityView.h\"\n#include \"MassExecutionContext.h\"\n#include \"GameplayDebuggerConfig.h\"\n#include \"GameplayDebuggerCategoryReplicator.h\"\n#include \"MassDebuggerSubsystem.h\"\n#include \"MassSignalSubsystem.h\"\n#include \"MassActorSubsystem.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"MassAgentComponent.h\"\n#include \"MassEntityManager.h\"\n#include \"MassEntitySubsystem.h\"\n#include \"MassNavigationFragments.h\"\n#include \"Steering/MassSteeringFragments.h\"\n#include \"MassLookAtFragments.h\"\n#include \"MassStateTreeFragments.h\"\n#include \"MassStateTreeExecutionContext.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"MassSmartObjectFragments.h\"\n#include \"SmartObjectSubsystem.h\"\n#include \"Util/ColorConstants.h\"\n#include \"MassSimulationLOD.h\"\n#include \"CanvasItem.h\"\n#include \"Engine/World.h\"\n#include \"MassDebugger.h\"\n#include \"MassLODSubsystem.h\"\n\n\nnamespace UE::Mass::Debug\n{\n\tFMassEntityHandle GetEntityFromActor(const AActor& Actor, const UMassAgentComponent*& OutMassAgentComponent)\n\t{\n\t\tFMassEntityHandle EntityHandle;\n\t\tif (const UMassAgentComponent* AgentComp = Actor.FindComponentByClass<UMassAgentComponent>())\n\t\t{\n\t\t\tEntityHandle = AgentComp->GetEntityHandle();\n\t\t\tOutMassAgentComponent = AgentComp;\n\t\t}\n\t\telse if (UMassActorSubsystem* ActorSubsystem = UWorld::GetSubsystem<UMassActorSubsystem>(Actor.GetWorld()))\n\t\t{\n\t\t\tEntityHandle = ActorSubsystem->GetEntityHandleFromActor(&Actor);\n\t\t}\n\t\treturn EntityHandle;\n\t};\n\n\tFMassEntityHandle GetBestEntity(const FVector ViewLocation, const FVector ViewDirection, const TConstArrayView<FMassEntityHandle> Entities\n\t\t, const TConstArrayView<FVector> Locations, const bool bLimitAngle, const FVector::FReal MaxScanDistance)\n\t{\n\t\tconstexpr FVector::FReal MinViewDirDot = 0.707; // 45 degrees\t\t\n\t\tconst FVector::FReal MaxScanDistanceSq = MaxScanDistance * MaxScanDistance;\n\n\t\tcheckf(Entities.Num() == Locations.Num(), TEXT(\"Both Entities and Locations lists are expected to be of the same size: %d vs %d\"), Entities.Num(), Locations.Num());\n\t\t\n\t\tFVector::FReal BestScore = bLimitAngle ? MinViewDirDot : (-1. - KINDA_SMALL_NUMBER);\n\t\tFMassEntityHandle BestEntity;\n\n\t\tfor (int i = 0; i < Entities.Num(); ++i)\n\t\t{\n\t\t\tif (Entities[i].IsSet() == false)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tconst FVector DirToEntity = (Locations[i] - ViewLocation);\n\t\t\tconst FVector::FReal DistToEntitySq = DirToEntity.SizeSquared();\n\t\t\tif (DistToEntitySq > MaxScanDistanceSq)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst FVector::FReal Distance = FMath::Sqrt(DistToEntitySq);\n\t\t\tconst FVector DirToEntityNormal = (FMath::IsNearlyZero(DistToEntitySq)) ? ViewDirection : (DirToEntity / Distance);\n\t\t\tconst FVector::FReal ViewDot = FVector::DotProduct(ViewDirection, DirToEntityNormal);\n\t\t\tconst FVector::FReal Score = ViewDot * 0.1 * (1. - Distance / MaxScanDistance);\n\t\t\tif (ViewDot > BestScore)\n\t\t\t{\n\t\t\t\tBestScore = ViewDot;\n\t\t\t\tBestEntity = Entities[i];\n\t\t\t}\n\t\t}\n\n\t\treturn BestEntity;\n\t}\n} // namespace UE::Mass:Debug\n\n//----------------------------------------------------------------------//\n//  FGameplayDebuggerCategory_Mass\n//----------------------------------------------------------------------//\nTArray<FAutoConsoleCommandWithWorld> FGameplayDebuggerCategory_Mass::ConsoleCommands;\nFGameplayDebuggerCategory_Mass::FOnConsoleCommandBroadcastDelegate FGameplayDebuggerCategory_Mass::OnToggleArchetypesBroadcast;\nFGameplayDebuggerCategory_Mass::FOnConsoleCommandBroadcastDelegate FGameplayDebuggerCategory_Mass::OnToggleShapesBroadcast;\nFGameplayDebuggerCategory_Mass::FOnConsoleCommandBroadcastDelegate FGameplayDebuggerCategory_Mass::OnToggleAgentFragmentsBroadcast;\nFGameplayDebuggerCategory_Mass::FOnConsoleCommandBroadcastDelegate FGameplayDebuggerCategory_Mass::OnPickEntityBroadcast;\nFGameplayDebuggerCategory_Mass::FOnConsoleCommandBroadcastDelegate FGameplayDebuggerCategory_Mass::OnToggleEntityDetailsBroadcast;\nFGameplayDebuggerCategory_Mass::FOnConsoleCommandBroadcastDelegate FGameplayDebuggerCategory_Mass::OnToggleNearEntityOverviewBroadcast;\nFGameplayDebuggerCategory_Mass::FOnConsoleCommandBroadcastDelegate FGameplayDebuggerCategory_Mass::OnToggleNearEntityAvoidanceBroadcast;\nFGameplayDebuggerCategory_Mass::FOnConsoleCommandBroadcastDelegate FGameplayDebuggerCategory_Mass::OnToggleNearEntityPathBroadcast;\nFGameplayDebuggerCategory_Mass::FOnConsoleCommandBroadcastDelegate FGameplayDebuggerCategory_Mass::OnToggleDebugLocalEntityManagerBroadcast;\nFGameplayDebuggerCategory_Mass::FOnConsoleCommandBroadcastDelegate FGameplayDebuggerCategory_Mass::OnTogglePickedActorAsViewerBroadcast;\nFGameplayDebuggerCategory_Mass::FOnConsoleCommandBroadcastDelegate FGameplayDebuggerCategory_Mass::OnToggleDrawViewersBroadcast;\nFGameplayDebuggerCategory_Mass::FOnConsoleCommandBroadcastDelegate FGameplayDebuggerCategory_Mass::OnClearActorViewersBroadcast;\n\nFGameplayDebuggerCategory_Mass::FGameplayDebuggerCategory_Mass()\n{\n\tCachedDebugActor = nullptr;\n\tbShowOnlyWithDebugActor = false;\n\n\t// @todo would be nice to have these saved in per-user settings \n\tbShowArchetypes = false;\n\tbShowShapes = false;\n\tbShowAgentFragments = false;\n\tbPickEntity = false;\n\tbShowEntityDetails = false;\n\tbShowNearEntityOverview = true;\n\tbShowNearEntityAvoidance = false;\n\tbShowNearEntityPath = false;\n\tbMarkEntityBeingDebugged = true;\n\tbDebugLocalEntityManager = false;\n\tbShowViewers = false;\n\n\tBindKeyPress(EKeys::A.GetFName(), FGameplayDebuggerInputModifier::Shift, this, &FGameplayDebuggerCategory_Mass::OnToggleArchetypes, EGameplayDebuggerInputMode::Replicated);\n\tBindKeyPress(EKeys::S.GetFName(), FGameplayDebuggerInputModifier::Shift, this, &FGameplayDebuggerCategory_Mass::OnToggleShapes, EGameplayDebuggerInputMode::Replicated);\n\tBindKeyPress(EKeys::G.GetFName(), FGameplayDebuggerInputModifier::Shift, this, &FGameplayDebuggerCategory_Mass::OnToggleAgentFragments, EGameplayDebuggerInputMode::Replicated);\n\tBindKeyPress(EKeys::P.GetFName(), FGameplayDebuggerInputModifier::Shift, this, &FGameplayDebuggerCategory_Mass::OnPickEntity, EGameplayDebuggerInputMode::Replicated);\n\tBindKeyPress(EKeys::D.GetFName(), FGameplayDebuggerInputModifier::Shift, this, &FGameplayDebuggerCategory_Mass::OnToggleEntityDetails, EGameplayDebuggerInputMode::Replicated);\n\tBindKeyPress(EKeys::O.GetFName(), FGameplayDebuggerInputModifier::Shift, this, &FGameplayDebuggerCategory_Mass::OnToggleNearEntityOverview, EGameplayDebuggerInputMode::Replicated);\n\tBindKeyPress(EKeys::V.GetFName(), FGameplayDebuggerInputModifier::Shift, this, &FGameplayDebuggerCategory_Mass::OnToggleNearEntityAvoidance, EGameplayDebuggerInputMode::Replicated);\n\tBindKeyPress(EKeys::C.GetFName(), FGameplayDebuggerInputModifier::Shift, this, &FGameplayDebuggerCategory_Mass::OnToggleNearEntityPath, EGameplayDebuggerInputMode::Replicated);\n\tToggleDebugLocalEntityManagerInputIndex = GetNumInputHandlers();\n\tBindKeyPress(EKeys::L.GetFName(), FGameplayDebuggerInputModifier::Shift, this, &FGameplayDebuggerCategory_Mass::OnToggleDebugLocalEntityManager, EGameplayDebuggerInputMode::Local);\n\tBindKeyPress(EKeys::Add.GetFName(), FGameplayDebuggerInputModifier::Shift, this, &FGameplayDebuggerCategory_Mass::OnIncreaseSearchRange, EGameplayDebuggerInputMode::Replicated);\n\tBindKeyPress(EKeys::Subtract.GetFName(), FGameplayDebuggerInputModifier::Shift, this, &FGameplayDebuggerCategory_Mass::OnDecreaseSearchRange, EGameplayDebuggerInputMode::Replicated);\n\tTogglePickedActorAsViewerInputIndex = GetNumInputHandlers();\n\tBindKeyPress(EKeys::U.GetFName(), FGameplayDebuggerInputModifier::Ctrl, this, &FGameplayDebuggerCategory_Mass::OnTogglePickedActorAsViewer, EGameplayDebuggerInputMode::Replicated);\n\tToggleDrawViewersInputIndex = GetNumInputHandlers();\n\tBindKeyPress(EKeys::U.GetFName(), FGameplayDebuggerInputModifier::Shift, this, &FGameplayDebuggerCategory_Mass::OnToggleDrawViewers, EGameplayDebuggerInputMode::Replicated);\n\tClearViewersInputIndex = GetNumInputHandlers();\n\tBindKeyPress(EKeys::U.GetFName(), FGameplayDebuggerInputModifier::Shift + FGameplayDebuggerInputModifier::Ctrl, this, &FGameplayDebuggerCategory_Mass::OnClearActorViewers, EGameplayDebuggerInputMode::Replicated);\n\n\tif (ConsoleCommands.Num() == 0)\n\t{\n\t\tConsoleCommands.Emplace(TEXT(\"gdt.mass.ToggleArchetypes\"), TEXT(\"\"), FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* InWorld) { OnToggleArchetypesBroadcast.Broadcast(InWorld); }));\n\t\tConsoleCommands.Emplace(TEXT(\"gdt.mass.ToggleShapes\"), TEXT(\"\"), FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* InWorld) { OnToggleShapesBroadcast.Broadcast(InWorld); }));\n\t\tConsoleCommands.Emplace(TEXT(\"gdt.mass.ToggleAgentFragments\"), TEXT(\"\"), FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* InWorld) { OnToggleAgentFragmentsBroadcast.Broadcast(InWorld); }));\n\t\tConsoleCommands.Emplace(TEXT(\"gdt.mass.PickEntity\"), TEXT(\"\"), FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* InWorld) { OnPickEntityBroadcast.Broadcast(InWorld); }));\n\t\tConsoleCommands.Emplace(TEXT(\"gdt.mass.ToggleEntityDetails\"), TEXT(\"\"), FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* InWorld) { OnToggleEntityDetailsBroadcast.Broadcast(InWorld); }));\n\t\tConsoleCommands.Emplace(TEXT(\"gdt.mass.ToggleNearEntityOverview\"), TEXT(\"\"), FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* InWorld) { OnToggleNearEntityOverviewBroadcast.Broadcast(InWorld); }));\n\t\tConsoleCommands.Emplace(TEXT(\"gdt.mass.ToggleNearEntityAvoidance\"), TEXT(\"\"), FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* InWorld) { OnToggleNearEntityAvoidanceBroadcast.Broadcast(InWorld); }));\n\t\tConsoleCommands.Emplace(TEXT(\"gdt.mass.ToggleNearEntityPath\"), TEXT(\"\"), FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* InWorld) { OnToggleNearEntityPathBroadcast.Broadcast(InWorld); }));\n\t\tConsoleCommands.Emplace(TEXT(\"gdt.mass.ToggleDebugLocalEntityManager\"), TEXT(\"\"), FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* InWorld) { OnToggleDebugLocalEntityManagerBroadcast.Broadcast(InWorld); }));\n\t\tConsoleCommands.Emplace(TEXT(\"gdt.mass.TogglePickedActorAsViewer\"), TEXT(\"\"), FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* InWorld) { OnTogglePickedActorAsViewerBroadcast.Broadcast(InWorld); }));\n\t\tConsoleCommands.Emplace(TEXT(\"gdt.mass.ToggleDrawViewers\"), TEXT(\"\"), FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* InWorld) { OnToggleDrawViewersBroadcast.Broadcast(InWorld); }));\t\n\t\tConsoleCommands.Emplace(TEXT(\"gdt.mass.ClearActorViewers\"), TEXT(\"\"), FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* InWorld) { OnClearActorViewersBroadcast.Broadcast(InWorld); }));\n\t}\n\n\tConsoleCommandHandles.Add(FDelegateHandlePair(&OnToggleArchetypesBroadcast, OnToggleArchetypesBroadcast.AddLambda([this](UWorld* InWorld) { if (InWorld == GetWorldFromReplicator()) { OnToggleArchetypes(); }})));\n\tConsoleCommandHandles.Add(FDelegateHandlePair(&OnToggleShapesBroadcast, OnToggleShapesBroadcast.AddLambda([this](UWorld* InWorld) { if (InWorld == GetWorldFromReplicator()) { OnToggleShapes(); }})));\n\tConsoleCommandHandles.Add(FDelegateHandlePair(&OnToggleAgentFragmentsBroadcast, OnToggleAgentFragmentsBroadcast.AddLambda([this](UWorld* InWorld) { if (InWorld == GetWorldFromReplicator()) { OnToggleAgentFragments(); }})));\n\tConsoleCommandHandles.Add(FDelegateHandlePair(&OnPickEntityBroadcast, OnPickEntityBroadcast.AddLambda([this](UWorld* InWorld) { if (InWorld == GetWorldFromReplicator()) { OnPickEntity(); }})));\n\tConsoleCommandHandles.Add(FDelegateHandlePair(&OnToggleEntityDetailsBroadcast, OnToggleEntityDetailsBroadcast.AddLambda([this](UWorld* InWorld) { if (InWorld == GetWorldFromReplicator()) { OnToggleEntityDetails(); }})));\n\tConsoleCommandHandles.Add(FDelegateHandlePair(&OnToggleNearEntityOverviewBroadcast, OnToggleNearEntityOverviewBroadcast.AddLambda([this](UWorld* InWorld) { if (InWorld == GetWorldFromReplicator()) { OnToggleNearEntityOverview(); }})));\n\tConsoleCommandHandles.Add(FDelegateHandlePair(&OnToggleNearEntityAvoidanceBroadcast, OnToggleNearEntityAvoidanceBroadcast.AddLambda([this](UWorld* InWorld) { if (InWorld == GetWorldFromReplicator()) { OnToggleNearEntityAvoidance(); }})));\n\tConsoleCommandHandles.Add(FDelegateHandlePair(&OnToggleNearEntityPathBroadcast, OnToggleNearEntityPathBroadcast.AddLambda([this](UWorld* InWorld) { if (InWorld == GetWorldFromReplicator()) { OnToggleNearEntityPath(); }})));\n\tConsoleCommandHandles.Add(FDelegateHandlePair(&OnToggleDebugLocalEntityManagerBroadcast, OnToggleDebugLocalEntityManagerBroadcast.AddLambda([this](UWorld* InWorld) { if (InWorld == GetWorldFromReplicator()) { OnToggleDebugLocalEntityManager(); }})));\n\tConsoleCommandHandles.Add(FDelegateHandlePair(&OnTogglePickedActorAsViewerBroadcast, OnTogglePickedActorAsViewerBroadcast.AddLambda([this](UWorld* InWorld) { if (InWorld == GetWorldFromReplicator()) { OnTogglePickedActorAsViewer(); }})));\n\tConsoleCommandHandles.Add(FDelegateHandlePair(&OnToggleDrawViewersBroadcast, OnToggleDrawViewersBroadcast.AddLambda([this](UWorld* InWorld) { if (InWorld == GetWorldFromReplicator()) { OnToggleDrawViewers(); }})));\n\tConsoleCommandHandles.Add(FDelegateHandlePair(&OnClearActorViewersBroadcast, OnClearActorViewersBroadcast.AddLambda([this](UWorld* InWorld) { if (InWorld == GetWorldFromReplicator()) { OnClearActorViewers(); }})));\n\n\tOnEntitySelectedHandle = FMassDebugger::OnEntitySelectedDelegate.AddRaw(this, &FGameplayDebuggerCategory_Mass::OnEntitySelected);\n}\n\nFGameplayDebuggerCategory_Mass::~FGameplayDebuggerCategory_Mass()\n{\n\tFMassDebugger::OnEntitySelectedDelegate.Remove(OnEntitySelectedHandle);\n\n\tfor (FDelegateHandlePair& Pair : ConsoleCommandHandles)\n\t{\n\t\tCA_ASSUME(Pair.Key);\n\t\tPair.Key->Remove(Pair.Value);\n\t}\n}\n\nvoid FGameplayDebuggerCategory_Mass::SetCachedEntity(const FMassEntityHandle Entity, const FMassEntityManager& EntityManager)\n{\n\tif (CachedEntity != Entity)\n\t{\n\t\tFMassDebugger::SelectEntity(EntityManager, Entity);\n\t}\n}\n\nvoid FGameplayDebuggerCategory_Mass::OnEntitySelected(const FMassEntityManager& EntityManager, const FMassEntityHandle EntityHandle)\n{\n\tUWorld* World = EntityManager.GetWorld();\n\tif (World != GetWorldFromReplicator())\n\t{ \n\t\t// ignore, this call is for a different world\n\t\treturn;\n\t}\n\n\tAActor* BestActor = nullptr;\n\tif (EntityHandle.IsSet() && World)\n\t{\n\t\tif (const UMassActorSubsystem* ActorSubsystem = World->GetSubsystem<UMassActorSubsystem>())\n\t\t{\n\t\t\tBestActor = ActorSubsystem->GetActorFromHandle(EntityHandle);\n\t\t}\n\t}\n\n\tCachedEntity = EntityHandle;\n\tCachedDebugActor = BestActor;\n\tcheck(GetReplicator());\n\tGetReplicator()->SetDebugActor(BestActor);\n}\n\nvoid FGameplayDebuggerCategory_Mass::ClearCachedEntity()\n{\n\tCachedEntity = FMassEntityHandle();\n}\n\nvoid FGameplayDebuggerCategory_Mass::PickEntity(const FVector& ViewLocation, const FVector& ViewDirection, const UWorld& World, FMassEntityManager& EntityManager, const bool bLimitAngle)\n{\n\tFMassEntityHandle BestEntity;\n\t\n\t// entities indicated by UE::Mass::Debug take precedence\n    if (UE::Mass::Debug::HasDebugEntities() && !UE::Mass::Debug::IsDebuggingSingleEntity())\n    {\n\t\tTArray<FMassEntityHandle> Entities;\n\t    TArray<FVector> Locations;\n\t    UE::Mass::Debug::GetDebugEntitiesAndLocations(EntityManager, Entities, Locations);\n\t    BestEntity = UE::Mass::Debug::GetBestEntity(ViewLocation, ViewDirection, Entities, Locations, bLimitAngle, SearchRange);\n    }\n\telse\n\t{\n\t\tTArray<FMassEntityHandle> Entities;\n\t\tTArray<FVector> Locations;\n\t\tFMassExecutionContext ExecutionContext(EntityManager);\n\t\tFMassEntityQuery Query;\n\t\tQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\t\tQuery.ForEachEntityChunk(EntityManager, ExecutionContext, [&Entities, &Locations](FMassExecutionContext& Context)\n\t\t{\n\t\t\tEntities.Append(Context.GetEntities().GetData(), Context.GetEntities().Num());\n\t\t\tTConstArrayView<FTransformFragment> InLocations = Context.GetFragmentView<FTransformFragment>();\n\t\t\tLocations.Reserve(Locations.Num() + InLocations.Num());\n\t\t\tfor (const FTransformFragment& TransformFragment : InLocations)\n\t\t\t{\n\t\t\t\tLocations.Add(TransformFragment.GetTransform().GetLocation());\n\t\t\t}\n\t\t});\n\n\t\tBestEntity = UE::Mass::Debug::GetBestEntity(ViewLocation, ViewDirection, Entities, Locations, bLimitAngle, SearchRange);\n\t}\n\n\tSetCachedEntity(BestEntity, EntityManager);\n}\n\nTSharedRef<FGameplayDebuggerCategory> FGameplayDebuggerCategory_Mass::MakeInstance()\n{\n\treturn MakeShareable(new FGameplayDebuggerCategory_Mass());\n}\n\nvoid FGameplayDebuggerCategory_Mass::CollectData(APlayerController* OwnerPC, AActor* DebugActor)\n{\n\tconstexpr float ViewerCylinderMarkLength = 1500.f;\n\tconstexpr float ViewerCylinderMarkLRadius = 30.f;\n\n\tif (bAllowLocalDataCollection)\n\t{\n\t\tResetReplicatedData();\n\t}\n\n\t// we only want to display this if there are local/remote roles in play\n\tif (IsCategoryAuth() != IsCategoryLocal())\n\t{\n\t\tAddTextLine(FString::Printf(TEXT(\"Source: {yellow}%s{white}\"), bDebugLocalEntityManager ? TEXT(\"LOCAL\") : TEXT(\"REMOTE\")));\n\t}\n\n\tUWorld* World = GetDataWorld(OwnerPC, DebugActor);\n\tcheck(World);\n\n\tUMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(World);\n\tif (EntitySubsystem == nullptr)\n\t{\n\t\tAddTextLine(FString::Printf(TEXT(\"{Red}EntitySubsystem instance is missing\")));\n\t\treturn;\n\t}\n\tFMassEntityManager& EntityManager = EntitySubsystem->GetMutableEntityManager();\n\tUMassDebuggerSubsystem* Debugger = World->GetSubsystem<UMassDebuggerSubsystem>();\n\n\tconst UMassAgentComponent* AgentComp = nullptr;\n\t\n\tif (bAllowLocalDataCollection)\n\t{\n\t\tDebugActor = CachedDebugActor.GetEvenIfUnreachable();\n\t}\n\n\tif (DebugActor)\n\t{\n\t\tconst FMassEntityHandle EntityHandle = UE::Mass::Debug::GetEntityFromActor(*DebugActor, AgentComp);\t\n\t\tSetCachedEntity(EntityHandle, EntityManager);\n\t\tCachedDebugActor = DebugActor;\n\t}\n\telse if (CachedDebugActor.Get())\n\t{\n\t\tClearCachedEntity();\n\t\tCachedDebugActor = nullptr;\n\t}\n\telse if (CachedEntity.IsValid() == true && EntityManager.IsEntityValid(CachedEntity) == false)\n\t{\n\t\tClearCachedEntity();\n\t}\n\n\tFVector ViewLocation = FVector::ZeroVector;\n\tFVector ViewDirection = FVector::ForwardVector;\n\tif (GetViewPoint(OwnerPC, ViewLocation, ViewDirection))\n\t{\n\t\t// Ideally we would have a way to register in the main picking flow but that would require more changes to\n\t\t// also support client-server picking. For now, we handle explicit mass picking requests on the authority\n\t\tif (bPickEntity)\n\t\t{\n\t\t\tPickEntity(ViewLocation, ViewDirection, *World, EntityManager);\n\t\t\tbPickEntity = false;\n\t\t}\n\t\t// if we're debugging based on UE::Mass::Debug and the range changed\n\t\telse if (CachedDebugActor == nullptr && UE::Mass::Debug::HasDebugEntities() && UE::Mass::Debug::IsDebuggingEntity(CachedEntity) == false\n\t\t\t&& UE::Mass::Debug::IsDebuggingSingleEntity() == false)\n\t\t{\n\t\t\t// using bLimitAngle = false to not limit the selection to only the things in from of the player\n\t\t\tPickEntity(ViewLocation, ViewDirection, *World, EntityManager, /*bLimitAngle=*/false);\n\t\t}\n\t}\n\n\tAddTextLine(FString::Printf(TEXT(\"{Green}Entities count active{grey}/all: {white}%d{grey}/%d\"), EntityManager.DebugGetEntityCount(), EntityManager.DebugGetEntityCount()));\n\tAddTextLine(FString::Printf(TEXT(\"{Green}Registered Archetypes count: {white}%d {green}data ver: {white}%d\"), EntityManager.DebugGetArchetypesCount(), EntityManager.GetArchetypeDataVersion()));\n\n\tAddTextLine(FString::Printf(TEXT(\"{Green}Search range: {White}%.0f\"), SearchRange));\n\n\tconst FTransformFragment* TransformFragment = nullptr;\n\tif (CachedEntity.IsValid())\n\t{\n\t\tAddTextLine(FString::Printf(TEXT(\"{Green}Entity: {White}%s\"), *CachedEntity.DebugGetDescription()));\n\t\tTransformFragment = EntityManager.GetFragmentDataPtr<FTransformFragment>(CachedEntity);\n\t\tif (TransformFragment)\n\t\t{\n\t\t\tAddTextLine(FString::Printf(TEXT(\"{Green}Distance: {White}%.0f\"), FVector::Distance(TransformFragment->GetTransform().GetLocation(), ViewLocation)));\n\t\t}\n\t}\n\n\tif (UE::Mass::Debug::HasDebugEntities())\n\t{\n\t\tint32 RangeBegin, RangeEnd;\n\t\tUE::Mass::Debug::GetDebugEntitiesRange(RangeBegin, RangeEnd);\n\t\t// not printing single-entity range, since in that case the CachedEntity is already set to the appropriate entity\n\t\tif (RangeBegin != RangeEnd)\n\t\t{\n\t\t\tAddTextLine(FString::Printf(TEXT(\"{Green}Debugged entity range: {orange}%d-%d\"), RangeBegin, RangeEnd));\n\t\t}\n\t}\n\n\tif (bShowArchetypes)\n\t{\n\t\tFStringOutputDevice Ar;\n\t\tAr.SetAutoEmitLineTerminator(true);\n\t\tEntityManager.DebugPrintArchetypes(Ar, /*bIncludeEmpty*/false);\n\n\t\tAddTextLine(Ar);\n\t}\n\n\tif (bShowViewers)\n\t{\n\t\tif (UMassLODSubsystem* LODSubsystem = World->GetSubsystem<UMassLODSubsystem>())\n\t\t{\n\t\t\tfor (const FViewerInfo& Viewer : LODSubsystem->GetViewers())\n\t\t\t{\n\t\t\t\tAddShape(FGameplayDebuggerShape::MakeCylinder(Viewer.Location, ViewerCylinderMarkLRadius, ViewerCylinderMarkLength, FColor::Blue));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (CachedEntity.IsSet() && bMarkEntityBeingDebugged && TransformFragment)\n\t{\n\t\tconst FVector Location = TransformFragment->GetTransform().GetLocation();\n\t\tAddShape(FGameplayDebuggerShape::MakeBox(Location, FVector(8,8,500), FColor::Purple,  FString::Printf(TEXT(\"[%s]\"), *CachedEntity.DebugGetDescription())));\n\t\tAddShape(FGameplayDebuggerShape::MakePoint(Location, 10, FColor::Purple));\n\t}\n\n\tif (CachedEntity.IsSet() && Debugger)\n\t{\n\t\tAddTextLine(Debugger->GetSelectedEntityInfo());\n\t}\n\n\t//@todo could shave off some perf cost if UMassDebuggerSubsystem used FGameplayDebuggerShape directly\n\tif (bShowShapes && Debugger)\n\t{\n\t\tconst TArray<UMassDebuggerSubsystem::FShapeDesc>* Shapes = Debugger->GetShapes();\n\t\tcheck(Shapes);\n\t\t// EMassEntityDebugShape::Box\n\t\tfor (const UMassDebuggerSubsystem::FShapeDesc& Desc : Shapes[uint8(EMassEntityDebugShape::Box)])\n\t\t{\n\t\t\tAddShape(FGameplayDebuggerShape::MakeBox(Desc.Location, FVector(Desc.Size), FColor::Blue));\n\t\t}\n\t\t// EMassEntityDebugShape::Cone\n\t\t// note that we're modifying the Size here because MakeCone is using the third param as Cone's \"height\", while all mass debugger shapes are created with agent radius\n\t\t// FGameplayDebuggerShape::Draw is using 0.25 rad for cone angle, so that's what we'll use here\n\t\tstatic const float Tan025Rad = FMath::Tan(0.25f);\n\t\tfor (const UMassDebuggerSubsystem::FShapeDesc& Desc : Shapes[uint8(EMassEntityDebugShape::Cone)])\n\t\t{\n\t\t\tAddShape(FGameplayDebuggerShape::MakeCone(Desc.Location, FVector::UpVector, Desc.Size / Tan025Rad, FColor::Orange));\n\t\t}\n\t\t// EMassEntityDebugShape::Cylinder\n\t\tfor (const UMassDebuggerSubsystem::FShapeDesc& Desc : Shapes[uint8(EMassEntityDebugShape::Cylinder)])\n\t\t{\n\t\t\tAddShape(FGameplayDebuggerShape::MakeCylinder(Desc.Location, Desc.Size, Desc.Size * 2, FColor::Yellow));\n\t\t}\n\t\t// EMassEntityDebugShape::Capsule\n\t\tfor (const UMassDebuggerSubsystem::FShapeDesc& Desc : Shapes[uint8(EMassEntityDebugShape::Capsule)])\n\t\t{\n\t\t\tAddShape(FGameplayDebuggerShape::MakeCapsule(Desc.Location, Desc.Size, Desc.Size * 2, FColor::Green));\n\t\t}\n\t}\n\n\tif (bShowAgentFragments)\n\t{\n\t\tif (CachedEntity.IsSet())\n\t\t{\n\t\t\t// CachedEntity can become invalid if the entity \"dies\" or in editor mode when related actor gets moved \n\t\t\t// (which causes the MassAgentComponent destruction and recreation).\n\t\t\tif (EntityManager.IsEntityActive(CachedEntity))\n\t\t\t{\n\t\t\t\tAddTextLine(FString::Printf(TEXT(\"{Green}Type: {White}%s\"), (AgentComp == nullptr) ? TEXT(\"N/A\") : AgentComp->IsPuppet() ? TEXT(\"PUPPET\") : TEXT(\"AGENT\")));\n\n\t\t\t\tif (bShowEntityDetails)\n\t\t\t\t{\n\t\t\t\t\tFStringOutputDevice FragmentsDesc;\n\t\t\t\t\tFragmentsDesc.SetAutoEmitLineTerminator(true);\n\t\t\t\t\tconst TCHAR* PrefixToRemove = TEXT(\"DataFragment_\");\n\t\t\t\t\tFMassDebugger::OutputEntityDescription(FragmentsDesc, EntityManager, CachedEntity, PrefixToRemove);\n\t\t\t\t\tAddTextLine(FString::Printf(TEXT(\"{Green}Fragments:\\n{White}%s\"), *FragmentsDesc));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tconst FMassArchetypeHandle Archetype = EntityManager.GetArchetypeForEntity(CachedEntity);\n\t\t\t\t\tconst FMassArchetypeCompositionDescriptor& Composition = EntityManager.GetArchetypeComposition(Archetype);\n\t\t\t\t\t\n\t\t\t\t\tauto DescriptionBuilder = [](const TArray<FName>& ItemNames) -> FString {\n\t\t\t\t\t\tconstexpr int ColumnsCount = 2;\n\t\t\t\t\t\tFString Description;\n\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\tfor (const FName Name : ItemNames)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((i++ % ColumnsCount) == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDescription += TEXT(\"\\n\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tDescription += FString::Printf(TEXT(\"%s,\\t\"), *Name.ToString());\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn Description;\n\t\t\t\t\t};\n\n\t\t\t\t\tTArray<FName> ItemNames;\n\t\t\t\t\tComposition.Tags.DebugGetIndividualNames(ItemNames);\n\t\t\t\t\tAddTextLine(FString::Printf(TEXT(\"{Green}Tags:{White}%s\"), *DescriptionBuilder(ItemNames)));\n\t\t\t\t\t\n\t\t\t\t\tItemNames.Reset();\n\t\t\t\t\tComposition.Fragments.DebugGetIndividualNames(ItemNames);\n\t\t\t\t\tAddTextLine(FString::Printf(TEXT(\"{Green}Fragments:{White}%s\"), *DescriptionBuilder(ItemNames)));\n\t\t\t\t\t\n\t\t\t\t\tItemNames.Reset();\n\t\t\t\t\tComposition.ChunkFragments.DebugGetIndividualNames(ItemNames);\n\t\t\t\t\tAddTextLine(FString::Printf(TEXT(\"{Green}Chunk Fragments:{White}%s\"), *DescriptionBuilder(ItemNames)));\n\n\t\t\t\t\tItemNames.Reset();\n\t\t\t\t\tComposition.SharedFragments.DebugGetIndividualNames(ItemNames);\n\t\t\t\t\tAddTextLine(FString::Printf(TEXT(\"{Green}Shared Fragments:{White}%s\"), *DescriptionBuilder(ItemNames)));\n\t\t\t\t}\n\n\t\t\t\tcheck(TransformFragment);\n\t\t\t\tconstexpr float CapsuleRadius = 50.f;\n\t\t\t\tAddShape(FGameplayDebuggerShape::MakeCapsule(TransformFragment->GetTransform().GetLocation() + 2.f * CapsuleRadius * FVector::UpVector, CapsuleRadius, CapsuleRadius * 2.f, FColor::Orange));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCachedEntity.Reset();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tAddTextLine(FString::Printf(TEXT(\"{Green}Entity: {Red}INACTIVE\")));\n\t\t}\n\t}\n\n\tNearEntityDescriptions.Reset();\n\tif (bShowNearEntityOverview && OwnerPC)\n\t{\n\t\tFMassEntityQuery EntityQuery;\n\t\tEntityQuery.AddRequirement<FMassStateTreeInstanceFragment>(EMassFragmentAccess::ReadOnly);\n\t\tEntityQuery.AddConstSharedRequirement<FMassStateTreeSharedFragment>();\n\t\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\t\tEntityQuery.AddRequirement<FAgentRadiusFragment>(EMassFragmentAccess::ReadOnly);\n\t\tEntityQuery.AddRequirement<FMassSteeringFragment>(EMassFragmentAccess::ReadOnly);\n\t\tEntityQuery.AddRequirement<FMassStandingSteeringFragment>(EMassFragmentAccess::ReadOnly);\n\t\tEntityQuery.AddRequirement<FMassGhostLocationFragment>(EMassFragmentAccess::ReadOnly);\n\t\tEntityQuery.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadOnly);\n\t\tEntityQuery.AddRequirement<FMassForceFragment>(EMassFragmentAccess::ReadOnly);\n\t\tEntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadOnly);\n\t\tEntityQuery.AddRequirement<FMassLookAtFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\t\tEntityQuery.AddRequirement<FMassSimulationLODFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\t\tEntityQuery.AddRequirement<FMassZoneGraphShortPathFragment>(EMassFragmentAccess::ReadOnly);\n\t\tEntityQuery.AddRequirement<FMassSmartObjectUserFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\n\t\tconst double CurrentTime = World->GetTimeSeconds();\n\t\t\n\t\tUMassStateTreeSubsystem* MassStateTreeSubsystem = World->GetSubsystem<UMassStateTreeSubsystem>();\n\t\tUMassSignalSubsystem* SignalSubsystem = World->GetSubsystem<UMassSignalSubsystem>();\n\t\tUSmartObjectSubsystem* SmartObjectSubsystem = World->GetSubsystem<USmartObjectSubsystem>();\n\t\t\n\t\tif (MassStateTreeSubsystem && SignalSubsystem && SmartObjectSubsystem)\n\t\t{\n\t\t\tFMassExecutionContext Context(EntityManager, 0.0f);\n\t\t\n\t\t\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this, MassStateTreeSubsystem, SignalSubsystem, SmartObjectSubsystem, OwnerPC, ViewLocation, ViewDirection, CurrentTime](FMassExecutionContext& Context)\n\t\t\t{\n\t\t\t\tFMassEntityManager& EntityManager = Context.GetEntityManagerChecked();\n\n\t\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\t\tconst TConstArrayView<FMassStateTreeInstanceFragment> StateTreeInstanceList = Context.GetFragmentView<FMassStateTreeInstanceFragment>();\n\t\t\t\tconst TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();\n\t\t\t\tconst TConstArrayView<FAgentRadiusFragment> RadiusList = Context.GetFragmentView<FAgentRadiusFragment>();\n\t\t\t\tconst TConstArrayView<FMassSteeringFragment> SteeringList = Context.GetFragmentView<FMassSteeringFragment>();\n\t\t\t\tconst TConstArrayView<FMassStandingSteeringFragment> StandingSteeringList = Context.GetFragmentView<FMassStandingSteeringFragment>();\n\t\t\t\tconst TConstArrayView<FMassGhostLocationFragment> GhostList = Context.GetFragmentView<FMassGhostLocationFragment>();\n\t\t\t\tconst TConstArrayView<FMassVelocityFragment> VelocityList = Context.GetFragmentView<FMassVelocityFragment>();\n\t\t\t\tconst TConstArrayView<FMassForceFragment> ForceList = Context.GetFragmentView<FMassForceFragment>();\n\t\t\t\tconst TConstArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetFragmentView<FMassMoveTargetFragment>();\n\t\t\t\tconst TConstArrayView<FMassLookAtFragment> LookAtList = Context.GetFragmentView<FMassLookAtFragment>();\n\t\t\t\tconst TConstArrayView<FMassSimulationLODFragment> SimLODList = Context.GetFragmentView<FMassSimulationLODFragment>();\n\t\t\t\tconst TConstArrayView<FMassZoneGraphShortPathFragment> ShortPathList = Context.GetFragmentView<FMassZoneGraphShortPathFragment>();\n\t\t\t\tconst TConstArrayView<FMassSmartObjectUserFragment> SOUserList = Context.GetFragmentView<FMassSmartObjectUserFragment>();\n\t\t\t\tconst FMassStateTreeSharedFragment& SharedStateTree = Context.GetConstSharedFragment<FMassStateTreeSharedFragment>();\n\n\t\t\t\tconst bool bHasLOD = (SimLODList.Num() > 0);\n\t\t\t\tconst bool bHasLookAt = (LookAtList.Num() > 0);\n\t\t\t\tconst bool bHasSOUser = (SOUserList.Num() > 0);\n\n\t\t\t\tconst UGameplayDebuggerUserSettings* Settings = GetDefault<UGameplayDebuggerUserSettings>();\n\t\t\t\tconst FVector::FReal MaxViewDistance = Settings->MaxViewDistance;\n\t\t\t\tconst FVector::FReal MinViewDirDot = FMath::Cos(FMath::DegreesToRadians(Settings->MaxViewAngle));\n\n\t\t\t\tconst UStateTree* StateTree = SharedStateTree.StateTree;\n\n\t\t\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t\t\t{\n\t\t\t\t\tconst FTransformFragment& Transform = TransformList[EntityIndex];\n\t\t\t\t\tconst FVector EntityLocation = Transform.GetTransform().GetLocation();\n\t\t\t\t\t\n\t\t\t\t\t// Cull entities\n\t\t\t\t\tconst FVector DirToEntity = EntityLocation - ViewLocation;\n\t\t\t\t\tconst FVector::FReal DistanceToEntitySq = DirToEntity.SquaredLength();\n\t\t\t\t\tif (DistanceToEntitySq > FMath::Square(MaxViewDistance))\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst FVector::FReal ViewDot = FVector::DotProduct(DirToEntity.GetSafeNormal(), ViewDirection);\n\t\t\t\t\tif (ViewDot < MinViewDirDot)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst FAgentRadiusFragment& Radius = RadiusList[EntityIndex];\n\t\t\t\t\tconst FMassSteeringFragment& Steering = SteeringList[EntityIndex];\n\t\t\t\t\tconst FMassStandingSteeringFragment& StandingSteering = StandingSteeringList[EntityIndex];\n\t\t\t\t\tconst FMassGhostLocationFragment& Ghost = GhostList[EntityIndex];\n\t\t\t\t\tconst FMassVelocityFragment& Velocity = VelocityList[EntityIndex];\n\t\t\t\t\tconst FMassForceFragment& Force = ForceList[EntityIndex];\n\t\t\t\t\tconst FMassMoveTargetFragment& MoveTarget = MoveTargetList[EntityIndex];\n\t\t\t\t\tconst FMassSimulationLODFragment& SimLOD = bHasLOD ? SimLODList[EntityIndex] : FMassSimulationLODFragment();\n\t\t\t\t\tconst FMassZoneGraphShortPathFragment& ShortPath = ShortPathList[EntityIndex];\n\t\t\t\t\tconst FMassStateTreeInstanceFragment& StateTreeInstance = StateTreeInstanceList[EntityIndex];\n\n\t\t\t\t\tconst FVector EntityForward = Transform.GetTransform().GetRotation().GetForwardVector();\n\n\t\t\t\t\tconstexpr float EyeHeight = 160.0f; // @todo: add eye height to agent.\n\n\t\t\t\t\t// Draw entity position and orientation.\n\t\t\t\t\tFVector BasePos = EntityLocation + FVector(0.0f ,0.0f ,25.0f );\n\n\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeCircle(BasePos, FVector::UpVector, Radius.Radius, FColor::White));\n\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeSegment(BasePos, BasePos + EntityForward * Radius.Radius * 1.25f, FColor::White));\n\n\t\t\t\t\t// Velocity and steering target\n\t\t\t\t\tBasePos += FVector(0.0f ,0.0f ,5.0f );\n\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeArrow(BasePos, BasePos + Velocity.Value, 10.0f, 2.0f, FColor::Yellow));\n\t\t\t\t\tBasePos += FVector(0.0f ,0.0f ,5.0f );\n\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeArrow(BasePos, BasePos + Steering.DesiredVelocity, 10.0f, 1.0f, FColorList::Pink));\n\n\t\t\t\t\t// Move target\n\t\t\t\t\tconst FVector MoveBasePos = MoveTarget.Center + FVector(0,0,5);\n\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeArrow(MoveBasePos - MoveTarget.Forward * Radius.Radius, MoveBasePos + MoveTarget.Forward * Radius.Radius, 10.0f, 2.0f, FColorList::MediumVioletRed));\n\n\t\t\t\t\t// Look at\n\t\t\t\t\tconstexpr FVector::FReal LookArrowLength = 100.;\n\t\t\t\t\tBasePos = EntityLocation + FVector(0,0,EyeHeight);\n\n\t\t\t\t\tif (bHasLookAt)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst FMassLookAtFragment& LookAt = LookAtList[EntityIndex];\n\t\t\t\t\t\tconst FVector WorldLookDirection = Transform.GetTransform().TransformVector(LookAt.Direction);\n\t\t\t\t\t\tbool bLookArrowDrawn = false;\n\t\t\t\t\t\tif (LookAt.LookAtMode == EMassLookAtMode::LookAtEntity && EntityManager.IsEntityValid(LookAt.TrackedEntity))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (const FTransformFragment* TargetTransform = EntityManager.GetFragmentDataPtr<FTransformFragment>(LookAt.TrackedEntity))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tFVector TargetPosition = TargetTransform->GetTransform().GetLocation();\n\t\t\t\t\t\t\t\tTargetPosition.Z = BasePos.Z;\n\t\t\t\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeCircle(TargetPosition, FVector::UpVector, Radius.Radius, FColor::Red));\n\n\t\t\t\t\t\t\t\tconst FVector::FReal TargetDistance = FMath::Max(LookArrowLength, FVector::DotProduct(WorldLookDirection, TargetPosition - BasePos));\n\t\t\t\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeSegment(BasePos, BasePos + WorldLookDirection * TargetDistance, FColorList::LightGrey));\n\t\t\t\t\t\t\t\tbLookArrowDrawn = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (LookAt.bRandomGazeEntities && EntityManager.IsEntityValid(LookAt.GazeTrackedEntity))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (const FTransformFragment* TargetTransform = EntityManager.GetFragmentDataPtr<FTransformFragment>(LookAt.GazeTrackedEntity))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tFVector TargetPosition = TargetTransform->GetTransform().GetLocation();\n\t\t\t\t\t\t\t\tTargetPosition.Z = BasePos.Z;\n\t\t\t\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeCircle(TargetPosition, FVector::UpVector, Radius.Radius, FColor::Turquoise));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!bLookArrowDrawn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeArrow(BasePos, BasePos + WorldLookDirection * LookArrowLength, 10.0f, 1.0f, FColor::Turquoise));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// SmartObject\n\t\t\t\t\tif (bHasSOUser)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst FMassSmartObjectUserFragment& SOUser = SOUserList[EntityIndex];\n\t\t\t\t\t\tif (SOUser.InteractionHandle.IsValid())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst FVector ZOffset = FVector(0.0f , 0.0f , 25.0f );\n\t\t\t\t\t\t\tconst FTransform SlotTransform = SmartObjectSubsystem->GetSlotTransform(SOUser.InteractionHandle).Get(FTransform::Identity);\n\t\t\t\t\t\t\tconst FVector SlotLocation = SlotTransform.GetLocation();\n\t\t\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeSegment(EntityLocation + ZOffset, SlotLocation + ZOffset, 3.0f, FColorList::Orange));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Path\n\t\t\t\t\tif (bShowNearEntityPath)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst FVector ZOffset = FVector(0.0f , 0.0f , 25.0f );\n\t\t\t\t\t\tfor (uint8 PointIndex = 0; PointIndex < ShortPath.NumPoints - 1; PointIndex++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst FMassZoneGraphPathPoint& CurrPoint = ShortPath.Points[PointIndex];\n\t\t\t\t\t\t\tconst FMassZoneGraphPathPoint& NextPoint = ShortPath.Points[PointIndex + 1];\n\t\t\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeSegment(CurrPoint.Position + ZOffset, NextPoint.Position + ZOffset, 3.0f, FColorList::Grey));\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\tfor (uint8 PointIndex = 0; PointIndex < ShortPath.NumPoints; PointIndex++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst FMassZoneGraphPathPoint& CurrPoint = ShortPath.Points[PointIndex];\n\t\t\t\t\t\t\tconst FVector CurrBase = CurrPoint.Position + ZOffset;\n\t\t\t\t\t\t\t// Lane tangents\n\t\t\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeSegment(CurrBase, CurrBase + CurrPoint.Tangent.GetVector() * 50.0f, 1.0f, FColorList::LightGrey));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (bShowNearEntityAvoidance)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Standing avoidance.\n\t\t\t\t\t\tif (Ghost.IsValid(MoveTarget.GetCurrentActionID()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFVector GhostBasePos = Ghost.Location + FVector(0.0f ,0.0f ,25.0f );\n\t\t\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeCircle(GhostBasePos, FVector::UpVector, Radius.Radius, FColorList::LightGrey));\n\t\t\t\t\t\t\tGhostBasePos += FVector(0,0,5);\n\t\t\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeArrow(GhostBasePos, GhostBasePos + Ghost.Velocity, 10.0f, 2.0f, FColorList::LightGrey));\n\n\t\t\t\t\t\t\tconst FVector GhostTargetBasePos = StandingSteering.TargetLocation + FVector(0.0f ,0.0f ,25.0f );\n\t\t\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeCircle(GhostTargetBasePos, FVector::UpVector, Radius.Radius * 0.75f, FColorList::Orange));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Status\n\t\t\t\t\tif (DistanceToEntitySq < FMath::Square(MaxViewDistance * 0.5f))\n\t\t\t\t\t{\n\t\t\t\t\t\tFString Status;\n\n\t\t\t\t\t\t// Entity name\n\t\t\t\t\t\tFMassEntityHandle Entity = Context.GetEntity(EntityIndex);\n\t\t\t\t\t\tStatus += TEXT(\"{orange}\");\n\t\t\t\t\t\tStatus += Entity.DebugGetDescription();\n\t\t\t\t\t\tStatus += TEXT(\" {white}LOD \");\n\t\t\t\t\t\tswitch (SimLOD.LOD) {\n\t\t\t\t\t\tcase EMassLOD::High:\n\t\t\t\t\t\t\tStatus += TEXT(\"High\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EMassLOD::Medium:\n\t\t\t\t\t\t\tStatus += TEXT(\"Med\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EMassLOD::Low:\n\t\t\t\t\t\t\tStatus += TEXT(\"Low\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EMassLOD::Off:\n\t\t\t\t\t\t\tStatus += TEXT(\"Off\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tStatus += TEXT(\"?\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tStatus += TEXT(\"\\n\");\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Current StateTree task\n\t\t\t\t\t\tif (StateTree != nullptr)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (FStateTreeInstanceData* InstanceData = MassStateTreeSubsystem->GetInstanceData(StateTreeInstance.InstanceHandle))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tFMassStateTreeExecutionContext StateTreeContext(*OwnerPC, *StateTree, *InstanceData, EntityManager, *SignalSubsystem, Context);\n\t\t\t\t\t\t\t\tStateTreeContext.SetEntity(Entity);\n\n\t\t\t\t\t\t\t\tStatus += StateTreeContext.GetActiveStateName();\n\t\t\t\t\t\t\t\tStatus += FString::Printf(TEXT(\"  {yellow}%d{white}\\n\"), StateTreeContext.GetStateChangeCount());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tStatus += TEXT(\"{red}<No StateTree instance>{white}\\n\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Movement info\n\t\t\t\t\t\tStatus += FString::Printf(TEXT(\"{yellow}%s/%03d {lightgrey}Speed:{white}%.1f {lightgrey}Force:{white}%.1f\\n\"),\n\t\t\t\t\t\t\t*UEnum::GetDisplayValueAsText(MoveTarget.GetCurrentAction()).ToString(), MoveTarget.GetCurrentActionID(), Velocity.Value.Length(), Force.Value.Length());\n\t\t\t\t\t\tStatus += FString::Printf(TEXT(\"{pink}-> %s {white}Dist: %.1f\\n\"),\n\t\t\t\t\t\t\t*UEnum::GetDisplayValueAsText(MoveTarget.IntentAtGoal).ToString(), MoveTarget.DistanceToGoal);\n\n\t\t\t\t\t\t// Look\n\t\t\t\t\t\tif (bHasLookAt)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst FMassLookAtFragment& LookAt = LookAtList[EntityIndex];\n\t\t\t\t\t\t\tconst double RemainingTime = LookAt.GazeDuration - (CurrentTime - LookAt.GazeStartTime);\n\t\t\t\t\t\t\tStatus += FString::Printf(TEXT(\"{turquoise}%s/%s {lightgrey}%.1f\\n\"),\n\t\t\t\t\t\t\t\t*UEnum::GetDisplayValueAsText(LookAt.LookAtMode).ToString(), *UEnum::GetDisplayValueAsText(LookAt.RandomGazeMode).ToString(), RemainingTime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!Status.IsEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tBasePos += FVector(0,0,50);\n\t\t\t\t\t\t\tconstexpr FVector::FReal ViewWeight = 0.6f; // Higher the number the more the view angle affects the score.\n\t\t\t\t\t\t\tconst FVector::FReal ViewScale = 1. - (ViewDot / MinViewDirDot); // Zero at center of screen\n\t\t\t\t\t\t\tNearEntityDescriptions.Emplace(static_cast<float>(DistanceToEntitySq * ((1. - ViewWeight) + ViewScale * ViewWeight)), BasePos, Status);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (bShowNearEntityAvoidance)\n\t\t{\n\t\t\tFMassEntityQuery EntityColliderQuery;\n\t\t\tEntityColliderQuery.AddRequirement<FMassAvoidanceColliderFragment>(EMassFragmentAccess::ReadOnly);\n\t\t\tEntityColliderQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\t\t\tFMassExecutionContext Context(EntityManager, 0.f);\n\t\t\tEntityColliderQuery.ForEachEntityChunk(EntityManager, Context, [this, ViewLocation, ViewDirection](const FMassExecutionContext& Context)\n\t\t\t{\n\t\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\t\tconst TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();\n\t\t\t\tconst TConstArrayView<FMassAvoidanceColliderFragment> CollidersList = Context.GetFragmentView<FMassAvoidanceColliderFragment>();\n\n\t\t\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t\t\t{\n\t\t\t\t\tconst FTransformFragment& Transform = TransformList[EntityIndex];\n\t\t\t\t\tconst FVector EntityLocation = Transform.GetTransform().GetLocation();\n\t\t\t\t\tconst FVector EntityForward = Transform.GetTransform().GetRotation().GetForwardVector();\n\t\t\t\t\t\n\t\t\t\t\tFVector BasePos = EntityLocation + FVector(0.0f ,0.0f ,25.0f );\n\n\t\t\t\t\t// Cull entities\n\t\t\t\t\tif (!IsLocationInViewCone(ViewLocation, ViewDirection, EntityLocation))\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Display colliders\n\t\t\t\t\tconst FMassAvoidanceColliderFragment& Collider = CollidersList[EntityIndex];\n\t\t\t\t\tif (Collider.Type == EMassColliderType::Circle)\n\t\t\t\t\t{\n\t\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeCircle(BasePos, FVector::UpVector, Collider.GetCircleCollider().Radius, FColor::Blue));\n\t\t\t\t\t}\n\t\t\t\t\telse if (Collider.Type == EMassColliderType::Pill)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst FMassPillCollider& Pill = Collider.GetPillCollider();\n\t\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeCircle(BasePos + Pill.HalfLength * EntityForward, FVector::UpVector, Pill.Radius, FColor::Blue));\n\t\t\t\t\t\tAddShape(FGameplayDebuggerShape::MakeCircle(BasePos - Pill.HalfLength * EntityForward, FVector::UpVector, Pill.Radius, FColor::Blue));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\t// Cap labels to closest ones.\n\t\tNearEntityDescriptions.Sort([](const FEntityDescription& LHS, const FEntityDescription& RHS){ return LHS.Score < RHS.Score; });\n\t\tconstexpr int32 MaxLabels = 15;\n\t\tif (NearEntityDescriptions.Num() > MaxLabels)\n\t\t{\n\t\t\tNearEntityDescriptions.RemoveAt(MaxLabels, NearEntityDescriptions.Num() - MaxLabels);\n\t\t}\n\t}\n\t\n}\n\nvoid FGameplayDebuggerCategory_Mass::DrawData(APlayerController* OwnerPC, FGameplayDebuggerCanvasContext& CanvasContext)\n{\n\tCanvasContext.Printf(TEXT(\"\\n[{yellow}%s{white}] %s Archetypes\"), *GetInputHandlerDescription(0), bShowArchetypes ? TEXT(\"Hide\") : TEXT(\"Show\"));\n\tCanvasContext.Printf(TEXT(\"[{yellow}%s{white}] %s Shapes\"), *GetInputHandlerDescription(1), bShowShapes ? TEXT(\"Hide\") : TEXT(\"Show\"));\n\tCanvasContext.Printf(TEXT(\"[{yellow}%s{white}] %s Agent Fragments\"), *GetInputHandlerDescription(2), bShowAgentFragments ? TEXT(\"Hide\") : TEXT(\"Show\"));\n\tif (bShowAgentFragments)\n\t{\n\t\tCanvasContext.Printf(TEXT(\"[{yellow}%s{white}] %s Entity details\"), *GetInputHandlerDescription(4), bShowEntityDetails ? TEXT(\"Hide\") : TEXT(\"Show\"));\n\t}\n\telse\n\t{\n\t\tCanvasContext.Printf(TEXT(\"{grey}[%s] Entity details [enable Agent Fragments]{white}\"), *GetInputHandlerDescription(4));\n\t}\n\tCanvasContext.Printf(TEXT(\"[{yellow}%s{white}] Pick Entity\"), *GetInputHandlerDescription(3));\n\tCanvasContext.Printf(TEXT(\"[{yellow}%s{white}] Toggle Picked Actor as viewer\"), *GetInputHandlerDescription(TogglePickedActorAsViewerInputIndex));\n\tCanvasContext.Printf(TEXT(\"[{yellow}%s{white}] %s LOD Viewers\"), *GetInputHandlerDescription(ToggleDrawViewersInputIndex), bShowViewers ? TEXT(\"Hide\") : TEXT(\"Show\"));\n\tCanvasContext.Printf(TEXT(\"[{yellow}%s{white}] Reset Actor LOD Viewers\"), *GetInputHandlerDescription(ClearViewersInputIndex));\n\tCanvasContext.Printf(TEXT(\"[{yellow}%s{white}] %s Entity overview\"), *GetInputHandlerDescription(5), bShowNearEntityOverview ? TEXT(\"Hide\") : TEXT(\"Show\"));\n\tCanvasContext.Printf(TEXT(\"[{yellow}%s{white}] %s Entity avoidance\"), *GetInputHandlerDescription(6), bShowNearEntityAvoidance ? TEXT(\"Hide\") : TEXT(\"Show\"));\n\tCanvasContext.Printf(TEXT(\"[{yellow}%s{white}] %s Entity path\"), *GetInputHandlerDescription(7), bShowNearEntityPath ? TEXT(\"Hide\") : TEXT(\"Show\"));\n\n\tif (IsCategoryLocal() && !IsCategoryAuth())\n\t{\n\t\t// we want to display this line only on clients in client-server environment.\n\t\tCanvasContext.Printf(TEXT(\"[{yellow}%s{white}] Toggle Local/Remote debugging\"), *GetInputHandlerDescription(ToggleDebugLocalEntityManagerInputIndex));\n\t}\n\n\tstruct FEntityLayoutRect\n\t{\n\t\tFVector2D Min = FVector2D::ZeroVector;\n\t\tFVector2D Max = FVector2D::ZeroVector;\n\t\tint32 Index = INDEX_NONE;\n\t\tfloat Alpha = 1.0f;\n\t};\n\n\tTArray<FEntityLayoutRect> Layout;\n\n\t// The loop below is O(N^2), make sure to keep the N small.\n\tconstexpr int32 MaxDesc = 20;\n\tconst int32 NumDescs = FMath::Min(NearEntityDescriptions.Num(), MaxDesc);\n\t\n\t// The labels are assumed to have been ordered in order of importance (i.e. front to back).\n\tfor (int32 Index = 0; Index < NumDescs; Index++)\n\t{\n\t\tconst FEntityDescription& Desc = NearEntityDescriptions[Index];\n\t\tif (Desc.Description.Len() && CanvasContext.IsLocationVisible(Desc.Location))\n\t\t{\n\t\t\tfloat SizeX = 0, SizeY = 0;\n\t\t\tconst FVector2D ScreenLocation = CanvasContext.ProjectLocation(Desc.Location);\n\t\t\tCanvasContext.MeasureString(Desc.Description, SizeX, SizeY);\n\t\t\t\n\t\t\tFEntityLayoutRect Rect;\n\t\t\tRect.Min = ScreenLocation + FVector2D(0, -SizeY * 0.5f);\n\t\t\tRect.Max = Rect.Min + FVector2D(SizeX, SizeY);\n\t\t\tRect.Index = Index;\n\t\t\tRect.Alpha = 0.0f;\n\n\t\t\t// Calculate transparency based on how much more important rects are overlapping the new rect.\n\t\t\tconst FVector::FReal Area = FMath::Max(0.0, Rect.Max.X - Rect.Min.X) * FMath::Max(0.0, Rect.Max.Y - Rect.Min.Y);\n\t\t\tconst FVector::FReal InvArea = Area > KINDA_SMALL_NUMBER ? 1.0 / Area : 0.0;\n\t\t\tFVector::FReal Coverage = 0.0;\n\n\t\t\tfor (const FEntityLayoutRect& Other : Layout)\n\t\t\t{\n\t\t\t\t// Calculate rect intersection\n\t\t\t\tconst FVector::FReal MinX = FMath::Max(Rect.Min.X, Other.Min.X);\n\t\t\t\tconst FVector::FReal MinY = FMath::Max(Rect.Min.Y, Other.Min.Y);\n\t\t\t\tconst FVector::FReal MaxX = FMath::Min(Rect.Max.X, Other.Max.X);\n\t\t\t\tconst FVector::FReal MaxY = FMath::Min(Rect.Max.Y, Other.Max.Y);\n\n\t\t\t\t// return zero area if not overlapping\n\t\t\t\tconst FVector::FReal IntersectingArea = FMath::Max(0.0, MaxX - MinX) * FMath::Max(0.0, MaxY - MinY);\n\t\t\t\tCoverage += (IntersectingArea * InvArea) * Other.Alpha;\n\t\t\t}\n\n\t\t\tRect.Alpha = FloatCastChecked<float>(FMath::Square(1.0 - FMath::Min(Coverage, 1.0)), UE::LWC::DefaultFloatPrecision);\n\t\t\t\n\t\t\tif (Rect.Alpha > KINDA_SMALL_NUMBER)\n\t\t\t{\n\t\t\t\tLayout.Add(Rect);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Render back to front so that the most important item renders at top.\n\tconst FVector2D Padding(5, 5);\n\tfor (int32 Index = Layout.Num() - 1; Index >= 0; Index--)\n\t{\n\t\tconst FEntityLayoutRect& Rect = Layout[Index];\n\t\tconst FEntityDescription& Desc = NearEntityDescriptions[Rect.Index];\n\n\t\tconst FVector2D BackgroundPosition(Rect.Min - Padding);\n\t\tFCanvasTileItem Background(Rect.Min - Padding, Rect.Max - Rect.Min + Padding * 2.0f, FLinearColor(0.0f, 0.0f, 0.0f, 0.35f * Rect.Alpha));\n\t\tBackground.BlendMode = SE_BLEND_TranslucentAlphaOnly;\n\t\tCanvasContext.DrawItem(Background\n\t\t\t, FloatCastChecked<float>(BackgroundPosition.X, UE::LWC::DefaultFloatPrecision)\n\t\t\t, FloatCastChecked<float>(BackgroundPosition.Y, UE::LWC::DefaultFloatPrecision));\n\n\t\tCanvasContext.PrintAt(FloatCastChecked<float>(Rect.Min.X, UE::LWC::DefaultFloatPrecision)\n\t\t\t, FloatCastChecked<float>(Rect.Min.Y, UE::LWC::DefaultFloatPrecision)\n\t\t\t, FColor::White, Rect.Alpha, Desc.Description);\n\t}\n\n\tFGameplayDebuggerCategory::DrawData(OwnerPC, CanvasContext);\n}\n\nvoid FGameplayDebuggerCategory_Mass::OnToggleDebugLocalEntityManager()\n{\n\t// this code will only execute on locally-controlled categories (as per BindKeyPress's EGameplayDebuggerInputMode::Local\n\t// parameter). In such a case we don't want to toggle if we're also Auth (there's no client-server relationship here).\n\tif (IsCategoryAuth())\n\t{\n\t\treturn;\n\t}\n\n\tResetReplicatedData();\n\tbDebugLocalEntityManager = !bDebugLocalEntityManager;\n\tbAllowLocalDataCollection = bDebugLocalEntityManager;\n\n\tconst EGameplayDebuggerInputMode NewInputMode = bDebugLocalEntityManager ? EGameplayDebuggerInputMode::Local : EGameplayDebuggerInputMode::Replicated;\n\tfor (int32 HandlerIndex = 0; HandlerIndex < GetNumInputHandlers(); ++HandlerIndex)\n\t{\n\t\tif (HandlerIndex != ToggleDebugLocalEntityManagerInputIndex)\n\t\t{\n\t\t\tGetInputHandler(HandlerIndex).Mode = NewInputMode;\n\t\t}\n\t}\n\n\tCachedEntity.Reset();\n}\n\nvoid FGameplayDebuggerCategory_Mass::OnIncreaseSearchRange()\n{\n\tSearchRange = FMath::Clamp(SearchRange * SearchRangeChangeScale, MinSearchRange, MaxSearchRange);\n}\n\nvoid FGameplayDebuggerCategory_Mass::OnDecreaseSearchRange()\n{\n\tSearchRange = FMath::Clamp(SearchRange / SearchRangeChangeScale, MinSearchRange, MaxSearchRange);\n}\n\nvoid FGameplayDebuggerCategory_Mass::OnTogglePickedActorAsViewer()\n{\n\tif (AActor* DebugActor = CachedDebugActor.Get())\n\t{\n\t\tUWorld* World = GetWorldFromReplicator();\n\t\tif (UMassLODSubsystem* LODSubsystem = World->GetSubsystem<UMassLODSubsystem>())\n\t\t{\n\t\t\tFMassViewerHandle ViewerHandle = LODSubsystem->GetViewerHandleFromActor(*DebugActor);\n\t\t\tif (ViewerHandle.IsValid() == false)\n\t\t\t{\n\t\t\t\tLODSubsystem->RegisterActorViewer(*DebugActor);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLODSubsystem->UnregisterActorViewer(*DebugActor);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid FGameplayDebuggerCategory_Mass::OnClearActorViewers()\n{\n\tUWorld* World = GetWorldFromReplicator();\n\tif (UMassLODSubsystem* LODSubsystem = World->GetSubsystem<UMassLODSubsystem>())\n\t{\n\t\tLODSubsystem->DebugUnregisterActorViewer();\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// DEPRECATED\n//-----------------------------------------------------------------------------\nvoid FGameplayDebuggerCategory_Mass::PickEntity(const APlayerController& OwnerPC, const UWorld& World, FMassEntityManager& EntityManager, const bool bLimitAngle)\n{\n\tFVector ViewLocation = FVector::ZeroVector;\n\tFVector ViewDirection = FVector::ForwardVector;\n\tensureMsgf(GetViewPoint(&OwnerPC, ViewLocation, ViewDirection), TEXT(\"GetViewPoint is expected to always succeed when passing a valid controller.\"));\n\n\tPickEntity(ViewLocation, ViewDirection, World, EntityManager, bLimitAngle);\n}\n\n#endif // WITH_GAMEPLAY_DEBUGGER && WITH_MASSGAMEPLAY_DEBUG\n\n",
      "lines": 1000
    },
    {
      "file_path": "MassAI\\MassAIDebug\\Private\\MassAIDebugModule.cpp",
      "extension": ".cpp",
      "size_bytes": 1294,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleManager.h\"\n#include \"IMassAIDebugModule.h\"\n#if WITH_GAMEPLAY_DEBUGGER\n#include \"GameplayDebugger.h\"\n#include \"GameplayDebuggerCategory_Mass.h\"\n#endif // WITH_GAMEPLAY_DEBUGGER\n\n\nclass FMassAIDebug : public IMassAIDebugModule\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nIMPLEMENT_MODULE(FMassAIDebug, MassAIDebug)\n\nvoid FMassAIDebug::StartupModule()\n{\n#if WITH_GAMEPLAY_DEBUGGER && WITH_MASSGAMEPLAY_DEBUG\n\tIGameplayDebugger& GameplayDebuggerModule = IGameplayDebugger::Get();\n\tGameplayDebuggerModule.RegisterCategory(\"Mass\", IGameplayDebugger::FOnGetCategory::CreateStatic(&FGameplayDebuggerCategory_Mass::MakeInstance), EGameplayDebuggerCategoryState::EnabledInGameAndSimulate);\n\tGameplayDebuggerModule.NotifyCategoriesChanged();\n#endif\n}\n\nvoid FMassAIDebug::ShutdownModule()\n{\n#if WITH_GAMEPLAY_DEBUGGER && WITH_MASSGAMEPLAY_DEBUG\n\tif (IGameplayDebugger::IsAvailable())\n\t{\n\t\tIGameplayDebugger& GameplayDebuggerModule = IGameplayDebugger::Get();\n\t\tGameplayDebuggerModule.UnregisterCategory(\"Mass\");\n\t\tGameplayDebuggerModule.NotifyCategoriesChanged();\n\t}\n#endif\n}\n\n\n\n",
      "lines": 43
    },
    {
      "file_path": "MassAI\\MassAIDebug\\Private\\MassDebugStateTreeProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 4538,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassDebugStateTreeProcessor.h\"\n#include \"MassDebuggerSubsystem.h\"\n#include \"MassSignalSubsystem.h\"\n#include \"MassStateTreeExecutionContext.h\"\n#include \"MassStateTreeFragments.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassDebugger.h\"\n#include \"MassExecutionContext.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"Engine/World.h\"\n\n//----------------------------------------------------------------------//\n// UMassDebugStateTreeProcessor\n//----------------------------------------------------------------------//\nUMassDebugStateTreeProcessor::UMassDebugStateTreeProcessor()\n\t: EntityQuery(*this)\n{\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Behavior;\n\tExecutionOrder.ExecuteAfter.Add(TEXT(\"MassStateTreeProcessor\"));\n}\n\nvoid UMassDebugStateTreeProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassStateTreeInstanceFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddConstSharedRequirement<FMassStateTreeSharedFragment>();\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n}\n\nvoid UMassDebugStateTreeProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n#if WITH_MASSGAMEPLAY_DEBUG\n\tUWorld* World = GetWorld();\n\tif (World == nullptr)\n\t{\n\t\treturn;\n\t}\n\t\n\tUMassDebuggerSubsystem* Debugger = World->GetSubsystem<UMassDebuggerSubsystem>();\n\tif (Debugger == nullptr)\n\t{\n\t\treturn;\n\t}\n\n\tUMassStateTreeSubsystem* MassStateTreeSubsystem = World->GetSubsystem<UMassStateTreeSubsystem>();\n\tif (MassStateTreeSubsystem == nullptr)\n\t{\n\t\treturn;\n\t}\n\n\tUMassSignalSubsystem* MassSignalSubsystem = World->GetSubsystem<UMassSignalSubsystem>();\n\tif (MassSignalSubsystem == nullptr)\n\t{\n\t\treturn;\n\t}\n\n\tif (!Debugger->GetSelectedEntity().IsSet() && !UE::Mass::Debug::HasDebugEntities())\n\t{\n\t\treturn;\n\t}\n\t\n\tQUICK_SCOPE_CYCLE_COUNTER(UMassDebugStateTreeProcessor_Run);\t\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this, Debugger, MassStateTreeSubsystem, &EntityManager, MassSignalSubsystem](FMassExecutionContext& Context)\n\t{\n\t\tconst FMassEntityHandle SelectedEntity = Debugger->GetSelectedEntity();\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tconst TConstArrayView<FMassStateTreeInstanceFragment> StateTreeInstanceList = Context.GetFragmentView<FMassStateTreeInstanceFragment>();\n\t\tconst FMassStateTreeSharedFragment& SharedStateTree = Context.GetConstSharedFragment<FMassStateTreeSharedFragment>();\n\t\tconst TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();\n\n\t\tconst UStateTree* StateTree = SharedStateTree.StateTree;\n\n\t\t// Not reporting error since this processor is a debug tool \n\t\tif (StateTree == nullptr)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\n\t\tfor (int32 i = 0; i < NumEntities; ++i)\n\t\t{\n\t\t\tconst FMassEntityHandle Entity = Context.GetEntity(i);\n\n\t\t\tif (Entity != SelectedEntity && !UE::Mass::Debug::IsDebuggingEntity(Entity))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tconst FMassStateTreeInstanceFragment& StateTreeInstance = StateTreeInstanceList[i];\n\n\t\t\tFStateTreeInstanceData* InstanceData = MassStateTreeSubsystem->GetInstanceData(StateTreeInstance.InstanceHandle);\n\t\t\tif (InstanceData == nullptr)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (Entity == SelectedEntity)\n\t\t\t{\n\t\t\t\tFMassStateTreeExecutionContext StateTreeContext(*MassStateTreeSubsystem, *StateTree, *InstanceData, EntityManager, *MassSignalSubsystem, Context);\n\t\t\t\tStateTreeContext.SetEntity(Entity);\n\t\t\t\t\n#if WITH_GAMEPLAY_DEBUGGER\n\t\t\t\tDebugger->AppendSelectedEntityInfo(StateTreeContext.GetDebugInfoString());\n#endif // WITH_GAMEPLAY_DEBUGGER\n\t\t\t}\n\t\t\t\t\n\t\t\tFColor EntityColor = FColor::White;\n\t\t\tconst bool bDisplayDebug = UE::Mass::Debug::IsDebuggingEntity(Entity, &EntityColor);\n\t\t\tif (bDisplayDebug)\n\t\t\t{\n\t\t\t\tconst FTransformFragment& Transform = TransformList[i];\n\t\t\t\t\n\t\t\t\tconst FVector ZOffset(0,0,50);\n\t\t\t\tconst FVector Position = Transform.GetTransform().GetLocation() + ZOffset;\n\n\t\t\t\tFMassStateTreeExecutionContext StateTreeContext(*MassStateTreeSubsystem, *StateTree, *InstanceData, EntityManager, *MassSignalSubsystem, Context);\n\t\t\t\tStateTreeContext.SetEntity(Entity);\n\n\t\t\t\t// State\n\t\t\t\tUE_VLOG_SEGMENT_THICK(this, LogStateTree, Log, Position, Position + FVector(0,0,50), EntityColor, /*Thickness*/ 2, TEXT(\"%s %s\"),\n\t\t\t\t\t*Entity.DebugGetDescription(), *StateTreeContext.GetActiveStateName());\n\t\t\t}\n\t\t}\n\t});\n\t#endif // WITH_MASSGAMEPLAY_DEBUG\n}\n",
      "lines": 126
    },
    {
      "file_path": "MassAI\\MassAIReplication\\Private\\MassAIReplicationModule.cpp",
      "extension": ".cpp",
      "size_bytes": 810,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CoreMinimal.h\"\n#include \"IMassAIReplicationModule.h\"\n\n\nclass FMassAIReplicationModule : public IMassAIReplicationModule\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nIMPLEMENT_MODULE(FMassAIReplicationModule, MassAIReplication)\n\n\n\nvoid FMassAIReplicationModule::StartupModule()\n{\n\t// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)\n}\n\n\nvoid FMassAIReplicationModule::ShutdownModule()\n{\n\t// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n\t// we call this function before unloading the module.\n}\n\n\n\n",
      "lines": 31
    },
    {
      "file_path": "MassAI\\MassAIReplication\\Private\\MassReplicationPathHandlers.cpp",
      "extension": ".cpp",
      "size_bytes": 7352,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassReplicationPathHandlers.h\"\n#include \"MassEntityQuery.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassSimulationSubsystem.h\"\n#include \"MassZoneGraphNavigationUtils.h\"\n#include \"ZoneGraphSubsystem.h\"\n#include \"GameFramework/GameStateBase.h\"\n#include \"VisualLogger/VisualLogger.h\"\n\nvoid FMassReplicationProcessorPathHandler::AddRequirements(FMassEntityQuery& InQuery)\n{\n\tInQuery.AddRequirement<FMassZoneGraphPathRequestFragment>(EMassFragmentAccess::ReadWrite);\n\tInQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadWrite);\n\tInQuery.AddRequirement<FMassZoneGraphLaneLocationFragment>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid FMassReplicationProcessorPathHandler::CacheFragmentViews(FMassExecutionContext& ExecContext)\n{\n\tPathRequestList = ExecContext.GetMutableFragmentView<FMassZoneGraphPathRequestFragment>();\n\tMoveTargetList = ExecContext.GetMutableFragmentView<FMassMoveTargetFragment>();\n\tLaneLocationList = ExecContext.GetMutableFragmentView<FMassZoneGraphLaneLocationFragment>();\n}\n\nvoid FMassReplicationProcessorPathHandler::AddEntity(const int32 EntityIdx, FReplicatedAgentPathData& InOutReplicatedPathData) const\n{\n\tconst FMassZoneGraphPathRequestFragment& RequestFragment = PathRequestList[EntityIdx];\n\tconst FMassMoveTargetFragment& MoveTargetFragment = MoveTargetList[EntityIdx];\n\tconst FMassZoneGraphLaneLocationFragment& LaneLocationFragment = LaneLocationList[EntityIdx];\n\n\tInOutReplicatedPathData = FReplicatedAgentPathData(RequestFragment, MoveTargetFragment, LaneLocationFragment);\n}\n\nFReplicatedAgentPathData::FReplicatedAgentPathData(const FMassZoneGraphPathRequestFragment& RequestFragment,\n\tconst FMassMoveTargetFragment& MoveTargetFragment,\n\tconst FMassZoneGraphLaneLocationFragment& LaneLocationFragment)\n{\n\t// Move target\n\tActionID = MoveTargetFragment.GetCurrentActionID();\n\tAction = MoveTargetFragment.GetCurrentAction();\n\tActionServerStartTime = MoveTargetFragment.GetCurrentActionStartTime();\n\tDesiredSpeed = MoveTargetFragment.DesiredSpeed;\n\n\t// Lane Location\n\tLaneHandle = LaneLocationFragment.LaneHandle;\n\tDistanceAlongLane = LaneLocationFragment.DistanceAlongLane;\n\tLaneLength = LaneLocationFragment.LaneLength;\n\n\t// Path request\n\tPathRequest = RequestFragment.PathRequest;\n}\n\nvoid FReplicatedAgentPathData::InitEntity(const UWorld& InWorld,\n\t\t\t\t\t\t\t\t\t\t  const FMassEntityView& InEntityView,\n\t\t\t\t\t\t\t\t\t\t  FMassZoneGraphLaneLocationFragment& OutLaneLocation,\n\t\t\t\t\t\t\t\t\t\t  FMassMoveTargetFragment& OutMoveTarget,\n\t\t\t\t\t\t\t\t\t\t  FMassZoneGraphPathRequestFragment& OutActionRequest) const\n{\n\tconst FMassEntityHandle Entity = InEntityView.GetEntity();\n\n\tconst UZoneGraphSubsystem* ZoneGraphSubsystem = InWorld.GetSubsystem<UZoneGraphSubsystem>();\n\tconst UMassSimulationSubsystem* SimulationSubsystem = InWorld.GetSubsystem<UMassSimulationSubsystem>();\n\tif (ZoneGraphSubsystem == nullptr || SimulationSubsystem == nullptr)\n\t{\n\t\tUE_CVLOG(ZoneGraphSubsystem == nullptr, &InWorld, LogMassNavigation, Error, TEXT(\"Entity [%s] no ZoneGraphSubsystem to process request %s\"),\n\t\t\t*Entity.DebugGetDescription(), *PathRequest.ToString());\n\t\tUE_CVLOG(SimulationSubsystem == nullptr, &InWorld, LogMassNavigation, Error, TEXT(\"Entity [%s] no MassSimulationSubsystem to process request %s\"),\n\t\t\t*Entity.DebugGetDescription(), *PathRequest.ToString());\n\t\treturn;\n\t}\n\n\tUE_VLOG(SimulationSubsystem, LogMassNavigation, Log, TEXT(\"%s InitEntity\"), *Entity.DebugGetDescription());\n\n\t// Setup initial lane location\n\tOutLaneLocation.LaneHandle = LaneHandle;\n\tOutLaneLocation.DistanceAlongLane = DistanceAlongLane;\n\tOutLaneLocation.LaneLength = LaneLength;\n\n\t// Setup initial move target\n\tFZoneGraphLaneLocation LaneLocation;\n\tZoneGraphSubsystem->CalculateLocationAlongLane(LaneHandle, DistanceAlongLane, LaneLocation);\n\tOutMoveTarget.DesiredSpeed = DesiredSpeed;\n\tOutMoveTarget.Center = LaneLocation.Position;\n\tOutMoveTarget.Forward = LaneLocation.Tangent;\n\tOutMoveTarget.DistanceToGoal = 0.0f;\n\tOutMoveTarget.SlackRadius = 0.0f;\n\n\t// Setup initial action request\n\tOutActionRequest.PathRequest = PathRequest;\n\n\tApplyToEntity(InWorld, InEntityView);\n}\n\nvoid FReplicatedAgentPathData::ApplyToEntity(const UWorld& InWorld, const FMassEntityView& InEntityView) const\n{\n\tconst FMassEntityHandle Entity = InEntityView.GetEntity();\n\tFMassMoveTargetFragment& MoveTarget = InEntityView.GetFragmentData<FMassMoveTargetFragment>();\n\tif (MoveTarget.GetCurrentActionID() == ActionID)\n\t{\n\t\treturn;\n\t}\n\n\tconst UZoneGraphSubsystem* ZoneGraphSubsystem = InWorld.GetSubsystem<UZoneGraphSubsystem>();\n\tconst UMassSimulationSubsystem* SimulationSubsystem = InWorld.GetSubsystem<UMassSimulationSubsystem>();\n\tif (ZoneGraphSubsystem == nullptr || SimulationSubsystem == nullptr)\n\t{\n\t\tUE_CVLOG(ZoneGraphSubsystem == nullptr, &InWorld, LogMassNavigation, Error, TEXT(\"Entity [%s] no ZoneGraphSubsystem to process request %s\"),\n\t\t\t*Entity.DebugGetDescription(), *PathRequest.ToString());\n\t\tUE_CVLOG(SimulationSubsystem == nullptr, &InWorld, LogMassNavigation, Error, TEXT(\"Entity [%s] no MassSimulationSubsystem to process request %s\"),\n\t\t\t*Entity.DebugGetDescription(), *PathRequest.ToString());\n\t\treturn;\n\t}\n\n\tUE_VLOG(SimulationSubsystem, LogMassNavigation, Log, TEXT(\"Entity [%s] apply replicated data to entity\"), *Entity.DebugGetDescription());\n\n\tFMassZoneGraphShortPathFragment& ShortPath = InEntityView.GetFragmentData<FMassZoneGraphShortPathFragment>();\n\tFMassZoneGraphCachedLaneFragment& CachedLane = InEntityView.GetFragmentData<FMassZoneGraphCachedLaneFragment>();\n\tFMassZoneGraphLaneLocationFragment& LaneLocation = InEntityView.GetFragmentData<FMassZoneGraphLaneLocationFragment>();\n\tconst FAgentRadiusFragment& AgentRadius = InEntityView.GetFragmentData<FAgentRadiusFragment>();\n\n\tMoveTarget.CreateReplicatedAction(Action, ActionID, InWorld.GetTimeSeconds(), ActionServerStartTime);\n\tMoveTarget.DesiredSpeed = DesiredSpeed;\n\n\t// Force current lane to build same path as server\n\tif (LaneLocation.LaneHandle != LaneHandle)\n\t{\n\t\tUE_VLOG(SimulationSubsystem, LogMassNavigation, Verbose, TEXT(\"Entity [%s] Force lane location from %s - %.1f to %s - %.1f to build similar path.\"),\n\t\t\t*Entity.DebugGetDescription(),\n\t\t\t*LaneLocation.LaneHandle.ToString(), LaneLocation.DistanceAlongLane,\n\t\t\t*LaneHandle.ToString(),\tDistanceAlongLane);\n\n\t\tLaneLocation.LaneHandle = LaneHandle;\n\t\tLaneLocation.DistanceAlongLane = DistanceAlongLane;\n\t\tLaneLocation.LaneLength = LaneLength;\n\t}\n\n\tswitch (Action)\n\t{\n\tcase EMassMovementAction::Stand:\n\t\tUE::MassNavigation::ActivateActionStand(InWorld, SimulationSubsystem, Entity, *ZoneGraphSubsystem, LaneLocation, DesiredSpeed.Get(), MoveTarget, ShortPath, CachedLane);\n\t\tbreak;\n\tcase EMassMovementAction::Move:\n\t\tUE::MassNavigation::ActivateActionMove(InWorld, SimulationSubsystem, Entity, *ZoneGraphSubsystem, LaneLocation, PathRequest, AgentRadius.Radius, DesiredSpeed.Get(), MoveTarget, ShortPath, CachedLane);\n\t\tbreak;\n\tcase EMassMovementAction::Animate:\n\t\tUE::MassNavigation::ActivateActionAnimate(InWorld, SimulationSubsystem, Entity, MoveTarget);\n\t\tbreak;\n\tdefault:\n\t\tensureMsgf(false, TEXT(\"Unhandled action type: %s\"), *UEnum::GetValueAsString(Action));\n\t}\n}\n",
      "lines": 153
    },
    {
      "file_path": "MassAI\\MassAITestSuite\\Private\\MassAITest.cpp",
      "extension": ".cpp",
      "size_bytes": 180,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CoreMinimal.h\"\n#include \"AITestsCommon.h\"\n\n#define LOCTEXT_NAMESPACE \"MassTest\"\n\n\n\n#undef LOCTEXT_NAMESPACE\n",
      "lines": 10
    },
    {
      "file_path": "MassAI\\MassAITestSuite\\Private\\MassAITestSuiteModule.cpp",
      "extension": ".cpp",
      "size_bytes": 297,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassAITestSuiteModule.h\"\n\n#define LOCTEXT_NAMESPACE \"MassAITestSuite\"\n\nclass FMassAITestSuiteModule : public IMassAITestSuiteModule\n{\n};\n\nIMPLEMENT_MODULE(FMassAITestSuiteModule, MassAITestSuite)\n\n#undef LOCTEXT_NAMESPACE\n",
      "lines": 13
    },
    {
      "file_path": "MassAI\\MassNavigation\\Private\\MassAvoidanceProcessors.cpp",
      "extension": ".cpp",
      "size_bytes": 60737,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Avoidance/MassAvoidanceProcessors.h\"\n#include \"Avoidance/MassAvoidanceFragments.h\"\n#include \"DrawDebugHelpers.h\"\n#include \"MassEntityView.h\"\n#include \"MassExecutionContext.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"Math/Vector2D.h\"\n#include \"Logging/LogMacros.h\"\n#include \"MassSimulationLOD.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassNavigationSubsystem.h\"\n#include \"MassNavigationFragments.h\"\n#include \"MassNavigationUtils.h\"\n#include \"Engine/World.h\"\n#include \"MassDebugger.h\"\n\n\n#define UNSAFE_FOR_MT 1\n\nDEFINE_LOG_CATEGORY(LogAvoidance);\nDEFINE_LOG_CATEGORY(LogAvoidanceVelocities);\nDEFINE_LOG_CATEGORY(LogAvoidanceAgents);\nDEFINE_LOG_CATEGORY(LogAvoidanceObstacles);\n\nnamespace UE::MassAvoidance\n{\n\tnamespace Tweakables\n\t{\n\t\tbool bEnableEnvironmentAvoidance = true;\n\t\tbool bEnableSettingsforExtendingColliders = true;\n\t\tbool bUseAdjacentCorridors = true;\n\t\tbool bUseDrawDebugHelpers = false;\n\t} // Tweakables\n\n\tFAutoConsoleVariableRef Vars[] = \n\t{\n\t\tFAutoConsoleVariableRef(TEXT(\"ai.mass.avoidance.EnableEnvironmentAvoidance\"), Tweakables::bEnableEnvironmentAvoidance, TEXT(\"Set to false to disable avoidance forces for environment (for debug purposes).\"), ECVF_Cheat),\n\t\tFAutoConsoleVariableRef(TEXT(\"ai.mass.avoidance.EnableSettingsforExtendingColliders\"), Tweakables::bEnableSettingsforExtendingColliders, TEXT(\"Set to false to disable using different settings for extending obstacles (for debug purposes).\"), ECVF_Cheat),\n\t\tFAutoConsoleVariableRef(TEXT(\"ai.mass.avoidance.UseAdjacentCorridors\"), Tweakables::bUseAdjacentCorridors, TEXT(\"Set to false to disable usage of adjacent lane width.\"), ECVF_Cheat),\n\t\tFAutoConsoleVariableRef(TEXT(\"ai.mass.avoidance.UseDrawDebugHelpers\"), Tweakables::bUseDrawDebugHelpers, TEXT(\"Use debug draw helpers in addition to visual logs.\"), ECVF_Cheat)\n\t};\n\n\tconstexpr int32 MaxExpectedAgentsPerCell = 6;\n\tconstexpr int32 MinTouchingCellCount = 4;\n\tconstexpr int32 MaxObstacleResults = MaxExpectedAgentsPerCell * MinTouchingCellCount;\n\n\tstatic void FindCloseObstacles(const FVector& Center, const FVector::FReal SearchRadius, const FNavigationObstacleHashGrid2D& AvoidanceObstacleGrid,\n\t\t\t\t\t\t\t\t\tTArray<FMassNavigationObstacleItem, TFixedAllocator<MaxObstacleResults>>& OutCloseEntities, const int32 MaxResults)\n\t{\n\t\tOutCloseEntities.Reset();\n\t\tconst FVector Extent(SearchRadius, SearchRadius, 0.);\n\t\tconst FBox QueryBox = FBox(Center - Extent, Center + Extent);\n\n\t\tstruct FSortingCell\n\t\t{\n\t\t\tint32 X;\n\t\t\tint32 Y;\n\t\t\tint32 Level;\n\t\t\tFVector::FReal SqDist;\n\t\t};\n\t\tTArray<FSortingCell, TInlineAllocator<64>> Cells;\n\t\tconst FVector QueryCenter = QueryBox.GetCenter();\n\t\t\n\t\tfor (int32 Level = 0; Level < AvoidanceObstacleGrid.NumLevels; Level++)\n\t\t{\n\t\t\tconst FVector::FReal CellSize = AvoidanceObstacleGrid.GetCellSize(Level);\n\t\t\tconst FNavigationObstacleHashGrid2D::FCellRect Rect = AvoidanceObstacleGrid.CalcQueryBounds(QueryBox, Level);\n\t\t\tfor (int32 Y = Rect.MinY; Y <= Rect.MaxY; Y++)\n\t\t\t{\n\t\t\t\tfor (int32 X = Rect.MinX; X <= Rect.MaxX; X++)\n\t\t\t\t{\n\t\t\t\t\tconst FVector::FReal CenterX = (X + 0.5) * CellSize;\n\t\t\t\t\tconst FVector::FReal CenterY = (Y + 0.5) * CellSize;\n\t\t\t\t\tconst FVector::FReal DX = CenterX - QueryCenter.X;\n\t\t\t\t\tconst FVector::FReal DY = CenterY - QueryCenter.Y;\n\t\t\t\t\tconst FVector::FReal SqDist = DX * DX + DY * DY;\n\t\t\t\t\tFSortingCell SortCell;\n\t\t\t\t\tSortCell.X = X;\n\t\t\t\t\tSortCell.Y = Y;\n\t\t\t\t\tSortCell.Level = Level;\n\t\t\t\t\tSortCell.SqDist = SqDist;\n\t\t\t\t\tCells.Add(SortCell);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCells.Sort([](const FSortingCell& A, const FSortingCell& B) { return A.SqDist < B.SqDist; });\n\n\t\tfor (const FSortingCell& SortedCell : Cells)\n\t\t{\n\t\t\tif (const FNavigationObstacleHashGrid2D::FCell* Cell = AvoidanceObstacleGrid.FindCell(SortedCell.X, SortedCell.Y, SortedCell.Level))\n\t\t\t{\n\t\t\t\tconst TSparseArray<FNavigationObstacleHashGrid2D::FItem>&  Items = AvoidanceObstacleGrid.GetItems();\n\t\t\t\tfor (int32 Idx = Cell->First; Idx != INDEX_NONE; Idx = Items[Idx].Next)\n\t\t\t\t{\n\t\t\t\t\tOutCloseEntities.Add(Items[Idx].ID);\n\t\t\t\t\tif (OutCloseEntities.Num() >= MaxResults)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Adapted from ray-capsule intersection: https://iquilezles.org/www/articles/intersectors/intersectors.htm\n\tstatic FVector::FReal ComputeClosestPointOfApproach(const FVector2D Pos, const FVector2D Vel, const FVector::FReal Rad, const FVector2D SegStart, const FVector2D SegEnd, const FVector::FReal TimeHoriz)\n\t{\n\t\tconst FVector2D SegDir = SegEnd - SegStart;\n\t\tconst FVector2D RelPos = Pos - SegStart;\n\t\tconst FVector::FReal VelSq = FVector2D::DotProduct(Vel, Vel);\n\t\tconst FVector::FReal SegDirSq = FVector2D::DotProduct(SegDir, SegDir);\n\t\tconst FVector::FReal DirVelSq = FVector2D::DotProduct(SegDir, Vel);\n\t\tconst FVector::FReal DirRelPosSq = FVector2D::DotProduct(SegDir, RelPos);\n\t\tconst FVector::FReal VelRelPosSq = FVector2D::DotProduct(Vel, RelPos);\n\t\tconst FVector::FReal RelPosSq = FVector2D::DotProduct(RelPos, RelPos);\n\t\tconst FVector::FReal A = SegDirSq * VelSq - DirVelSq * DirVelSq;\n\t\tconst FVector::FReal B = SegDirSq * VelRelPosSq - DirRelPosSq * DirVelSq;\n\t\tconst FVector::FReal C = SegDirSq * RelPosSq - DirRelPosSq * DirRelPosSq - FMath::Square(Rad) * SegDirSq;\n\t\tconst FVector::FReal H = FMath::Max(0., B*B - A*C); // b^2 - ac, Using max for closest point of arrival result when no hit.\n\t\tconst FVector::FReal T = FMath::Abs(A) > SMALL_NUMBER ? (-B - FMath::Sqrt(H)) / A : 0.;\n\t\tconst FVector::FReal Y = DirRelPosSq + T * DirVelSq;\n\t\t\n\t\tif (Y > 0. && Y < SegDirSq) \n\t\t{\n\t\t\treturn FMath::Clamp(T, 0., TimeHoriz);\n\t\t}\n\t\telse \n\t\t{\n\t\t\t// caps\n\t\t\tconst FVector2D CapRelPos = (Y <= 0.) ? RelPos : Pos - SegEnd;\n\t\t\tconst FVector::FReal Cb = FVector2D::DotProduct(Vel, CapRelPos);\n\t\t\tconst FVector::FReal Cc = FVector2D::DotProduct(CapRelPos, CapRelPos) - FMath::Square(Rad);\n\t\t\tconst FVector::FReal Ch = FMath::Max(0., Cb * Cb - VelSq * Cc);\n\t\t\tconst FVector::FReal T1 = VelSq > SMALL_NUMBER ? (-Cb - FMath::Sqrt(Ch)) / VelSq : 0.;\n\t\t\treturn FMath::Clamp(T1, 0., TimeHoriz);\n\t\t}\n\t}\n\n\tstatic FVector::FReal ComputeClosestPointOfApproach(const FVector RelPos, const FVector RelVel, const FVector::FReal TotalRadius, const FVector::FReal TimeHoriz)\n\t{\n\t\t// Calculate time of impact based on relative agent positions and velocities.\n\t\tconst FVector::FReal A = FVector::DotProduct(RelVel, RelVel);\n\t\tconst FVector::FReal Inv2A = A > SMALL_NUMBER ? 1. / (2. * A) : 0.;\n\t\tconst FVector::FReal B = FMath::Min(0., 2. * FVector::DotProduct(RelVel, RelPos));\n\t\tconst FVector::FReal C = FVector::DotProduct(RelPos, RelPos) - FMath::Square(TotalRadius);\n\t\t// Using max() here gives us CPA (closest point on arrival) when there is no hit.\n\t\tconst FVector::FReal Discr = FMath::Sqrt(FMath::Max(0., B * B - 4. * A * C));\n\t\tconst FVector::FReal T = (-B - Discr) * Inv2A;\n\t\treturn FMath::Clamp(T, 0., TimeHoriz);\n\t}\n\n\tstatic bool UseDrawDebugHelper()\n\t{\n\t\treturn Tweakables::bUseDrawDebugHelpers;\n\t}\n\n#if WITH_MASSGAMEPLAY_DEBUG\t\n\n\t// Colors\n\tstatic const FColor CurrentAgentColor = FColor::Emerald;\n\n\tstatic const FColor VelocityColor = FColor::Black;\n\tstatic const FColor PrefVelocityColor = FColor::Red;\n\tstatic const FColor DesiredVelocityColor = FColor::Yellow;\n\tstatic const FColor FinalSteeringForceColor = FColor::Cyan;\n\tstatic constexpr float BigArrowThickness = 6.f;\n\tstatic constexpr float BigArrowHeadSize = 12.f;\n\n\t// Agents colors\n\tstatic const FColor AgentsColor = FColor::Orange;\n\tstatic const FColor AgentSeparationForceColor = FColor(255, 145, 71);\t// Orange red\n\tstatic const FColor AgentAvoidForceColor = AgentsColor;\n\t\n\t// Obstacles colors\n\tstatic const FColor ObstacleColor = FColor::Blue;\n\tstatic const FColor ObstacleContactNormalColor = FColor::Silver;\n\tstatic const FColor ObstacleAvoidForceColor = FColor::Magenta;\n\tstatic const FColor ObstacleSeparationForceColor = FColor(255, 66, 66);\t// Bright red\n\t\n\tstatic const FVector DebugAgentHeightOffset = FVector(0., 0., 185.);\n\tstatic const FVector DebugLowCylinderOffset = FVector(0., 0., 20.);\n\n\t//----------------------------------------------------------------------//\n\t// Begin MassDebugUtils\n\t// @todo: Extract those generic debug functions to a separate location\n\t//----------------------------------------------------------------------//\n\tstruct FDebugContext\n\t{\n\t\tFDebugContext(const UObject* InLogOwner, const FLogCategoryBase& InCategory, const UWorld* InWorld, const FMassEntityHandle InEntity)\n\t\t\t: LogOwner(InLogOwner)\n\t\t\t, Category(InCategory)\n\t\t\t, World(InWorld)\n\t\t\t, Entity(InEntity)\n\t\t{}\n\n\t\tconst UObject* LogOwner;\n\t\tconst FLogCategoryBase& Category;\n\t\tconst UWorld* World;\n\t\tconst FMassEntityHandle Entity;\n\t};\n\n\tstatic bool DebugIsSelected(const FMassEntityHandle Entity)\n\t{\n\t\tFColor Color;\n\t\treturn UE::Mass::Debug::IsDebuggingEntity(Entity, &Color);\n\t}\n\n\tstatic void DebugDrawLine(const FDebugContext& Context, const FVector& Start, const FVector& End, const FColor& Color, const float Thickness = 0.f, const bool bPersistent = false)\n\t{\n\t\tif (!DebugIsSelected(Context.Entity))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tUE_VLOG_SEGMENT_THICK(Context.LogOwner, Context.Category, Log, Start, End, Color, (int16)Thickness, TEXT(\"\"));\n\n\t\tif (UseDrawDebugHelper() && Context.World)\n\t\t{\n\t\t\tDrawDebugLine(Context.World, Start, End, Color, bPersistent, /*LifeTime =*/ -1.f, /*DepthPriority =*/ 0, Thickness);\n\t\t}\n\t}\n\n\tstatic void DebugDrawArrow(const FDebugContext& Context, const FVector& Start, const FVector& End, const FColor& Color, const float HeadSize = 8.f, const float Thickness = 1.5f)\n\t{\n\t\tif (!DebugIsSelected(Context.Entity))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tconst FVector::FReal Pointyness = 1.8;\n\t\tconst FVector Line = End - Start;\n\t\tconst FVector UnitV = Line.GetSafeNormal();\n\t\tconst FVector Perp = FVector::CrossProduct(UnitV, FVector::UpVector);\n\t\tconst FVector Left = Perp - (Pointyness*UnitV);\n\t\tconst FVector Right = -Perp - (Pointyness*UnitV);\n\t\tUE_VLOG_SEGMENT_THICK(Context.LogOwner, Context.Category, Log, Start, End, Color, (int16)Thickness, TEXT(\"\"));\n\t\tUE_VLOG_SEGMENT_THICK(Context.LogOwner, Context.Category, Log, End, End + HeadSize * Left, Color, (int16)Thickness, TEXT(\"\"));\n\t\tUE_VLOG_SEGMENT_THICK(Context.LogOwner, Context.Category, Log, End, End + HeadSize * Right, Color, (int16)Thickness, TEXT(\"\"));\n\n\t\tif (UseDrawDebugHelper() && Context.World)\n\t\t{\n\t\t\tDrawDebugLine(Context.World, Start, End, Color, /*bPersistent=*/ false, /*LifeTime =*/ -1.f, /*DepthPriority =*/ 0, Thickness);\n\t\t\tDrawDebugLine(Context.World, End, End + HeadSize * Left, Color, /*bPersistent=*/ false, /*LifeTime =*/ -1.f, /*DepthPriority =*/ 0, Thickness);\n\t\t\tDrawDebugLine(Context.World, End, End + HeadSize * Right, Color, /*bPersistent=*/ false, /*LifeTime =*/ -1.f, /*DepthPriority =*/ 0, Thickness);\n\t\t}\n\t}\n\n\tstatic void DebugDrawSphere(const FDebugContext& Context, const FVector& Center, const float Radius, const FColor& Color)\n\t{\n\t\tif (!DebugIsSelected(Context.Entity))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tUE_VLOG_LOCATION(Context.LogOwner, Context.Category, Log, Center, Radius, Color, TEXT(\"\"));\n\n\t\tif (UseDrawDebugHelper() && Context.World)\n\t\t{\n\t\t\tDrawDebugSphere(Context.World, Center, Radius, /*segments = */16, Color);\n\t\t}\n\t}\n\n\tstatic void DebugDrawBox(const FDebugContext& Context, const FBox& Box, const FColor& Color)\n\t{\n\t\tif (!DebugIsSelected(Context.Entity))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tUE_VLOG_BOX(Context.LogOwner, Context.Category, Log, Box, Color, TEXT(\"\"));\n\t\t\n\t\tif (UseDrawDebugHelper() && Context.World)\n\t\t{\n\t\t\tDrawDebugBox(Context.World, Box.GetCenter(), Box.GetExtent(), Color);\n\t\t}\n\t}\n\t\n\tstatic void DebugDrawCylinder(const FDebugContext& Context, const FVector& Bottom, const FVector& Top, const float Radius, const FColor& Color, const FString& Text = FString())\n\t{\n\t\tif (!DebugIsSelected(Context.Entity))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tUE_VLOG_CYLINDER(Context.LogOwner, Context.Category, Log, Bottom, Top, Radius, Color, TEXT(\"%s\"), *Text);\n\n\t\tif (UseDrawDebugHelper() && Context.World)\n\t\t{\n\t\t\tDrawDebugCylinder(Context.World, Bottom, Top, Radius, /*segments = */24, Color);\n\t\t}\n\t}\n\t//----------------------------------------------------------------------//\n\t// End MassDebugUtils\n\t//----------------------------------------------------------------------//\n\n\n\t// Local debug utils\n\tstatic void DebugDrawVelocity(const FDebugContext& Context, const FVector& Start, const FVector& End, const FColor& Color)\n\t{\n\t\t// Different arrow than DebugDrawArrow()\n\t\tif (!DebugIsSelected(Context.Entity))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tconst float Thickness = 3.f;\n\t\tconst FVector::FReal Pointyness = 1.8;\n\t\tconst FVector Line = End - Start;\n\t\tconst FVector UnitV = Line.GetSafeNormal();\n\t\tconst FVector Perp = FVector::CrossProduct(UnitV, FVector::UpVector);\n\t\tconst FVector Left = Perp - (Pointyness * UnitV);\n\t\tconst FVector Right = -Perp - (Pointyness * UnitV);\n\t\tconst FVector::FReal HeadSize = 0.08 * Line.Size();\n\t\tUE_VLOG_SEGMENT_THICK(Context.LogOwner, Context.Category, Log, Start, End, Color, (int16)Thickness, TEXT(\"\"));\n\t\tUE_VLOG_SEGMENT_THICK(Context.LogOwner, Context.Category, Log, End, End + HeadSize * Left, Color, (int16)Thickness, TEXT(\"\"));\n\t\tUE_VLOG_SEGMENT_THICK(Context.LogOwner, Context.Category, Log, End, End + HeadSize * Right, Color, (int16)Thickness, TEXT(\"\"));\n\t\tUE_VLOG_SEGMENT_THICK(Context.LogOwner, Context.Category, Log, End + HeadSize * Left, End + HeadSize * Right, Color, (int16)Thickness, TEXT(\"\"));\n\n\t\tif (UseDrawDebugHelper() && Context.World)\n\t\t{\n\t\t\tDrawDebugLine(Context.World, Start, End, Color, /*bPersistent=*/ false, /*LifeTime =*/ -1.f, /*DepthPriority =*/ 0, Thickness);\n\t\t\tDrawDebugLine(Context.World, End, End + HeadSize * Left, Color, /*bPersistent=*/ false, /*LifeTime =*/ -1.f, /*DepthPriority =*/ 0, Thickness);\n\t\t\tDrawDebugLine(Context.World, End, End + HeadSize * Right, Color, /*bPersistent=*/ false, /*LifeTime =*/ -1.f, /*DepthPriority =*/ 0, Thickness);\n\t\t\tDrawDebugLine(Context.World, End + HeadSize * Left, End + HeadSize * Right, Color, /*bPersistent=*/ false, /*LifeTime =*/ -1.f, /*DepthPriority =*/ 0, Thickness);\n\t\t}\n\t}\n\n\tstatic void DebugDrawForce(const FDebugContext& Context, const FVector& Start, const FVector& End, const FColor& Color)\n\t{\n\t\tDebugDrawArrow(Context, Start, End, Color, /*HeadSize*/4.f, /*Thickness*/3.f);\n\t}\n\n\tstatic void DebugDrawSummedForce(const FDebugContext& Context, const FVector& Start, const FVector& End, const FColor& Color)\n\t{\n\t\tDebugDrawArrow(Context, Start + FVector(0.,0.,1.), End + FVector(0., 0., 1.), Color, /*HeadSize*/8.f, /*Thickness*/6.f);\n\t}\n\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n} // namespace UE::MassAvoidance\n\n\n//----------------------------------------------------------------------//\n//  UMassMovingAvoidanceProcessor\n//----------------------------------------------------------------------//\nUMassMovingAvoidanceProcessor::UMassMovingAvoidanceProcessor()\n\t: EntityQuery(*this) \n{\n\tbAutoRegisterWithProcessingPhases = true;\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Avoidance;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LOD);\n}\n\nvoid UMassMovingAvoidanceProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassForceFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassNavigationEdgesFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FAgentRadiusFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddTagRequirement<FMassMediumLODTag>(EMassFragmentPresence::None);\n\tEntityQuery.AddTagRequirement<FMassLowLODTag>(EMassFragmentPresence::None);\n\tEntityQuery.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);\n\tEntityQuery.AddConstSharedRequirement<FMassMovingAvoidanceParameters>(EMassFragmentPresence::All);\n\tEntityQuery.AddConstSharedRequirement<FMassMovementParameters>(EMassFragmentPresence::All);\n}\n\nvoid UMassMovingAvoidanceProcessor::Initialize(UObject& Owner)\n{\n\tSuper::Initialize(Owner);\n\n\tWorld = Owner.GetWorld();\n\tNavigationSubsystem = UWorld::GetSubsystem<UMassNavigationSubsystem>(Owner.GetWorld());\n}\n\nvoid UMassMovingAvoidanceProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tQUICK_SCOPE_CYCLE_COUNTER(UMassMovingAvoidanceProcessor);\n\n\tif (!World || !NavigationSubsystem)\n\t{\n\t\treturn;\n\t}\n\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this, &EntityManager](FMassExecutionContext& Context)\n\t{\n\t\tconst float DeltaTime = Context.GetDeltaTimeSeconds();\n\t\tconst double CurrentTime = World->GetTimeSeconds();\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\n\t\tconst TArrayView<FMassForceFragment> ForceList = Context.GetMutableFragmentView<FMassForceFragment>();\n\t\tconst TConstArrayView<FMassNavigationEdgesFragment> NavEdgesList = Context.GetFragmentView<FMassNavigationEdgesFragment>();\n\t\tconst TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\t\tconst TConstArrayView<FMassVelocityFragment> VelocityList = Context.GetFragmentView<FMassVelocityFragment>();\n\t\tconst TConstArrayView<FAgentRadiusFragment> RadiusList = Context.GetFragmentView<FAgentRadiusFragment>();\n\t\tconst TConstArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetFragmentView<FMassMoveTargetFragment>();\n\t\tconst FMassMovingAvoidanceParameters& MovingAvoidanceParams = Context.GetConstSharedFragment<FMassMovingAvoidanceParameters>();\n\t\tconst FMassMovementParameters& MovementParams = Context.GetConstSharedFragment<FMassMovementParameters>();\n\n\t\tconst FVector::FReal InvPredictiveAvoidanceTime = 1. / MovingAvoidanceParams.PredictiveAvoidanceTime;\n\n\t\t// Arrays used to store close obstacles\n\t\tTArray<FMassNavigationObstacleItem, TFixedAllocator<UE::MassAvoidance::MaxObstacleResults>> CloseEntities;\n\n\t\t// Used for storing sorted list or nearest obstacles.\n\t\tstruct FSortedObstacle\n\t\t{\n\t\t\tFVector LocationCached;\n\t\t\tFVector Forward;\n\t\t\tFMassNavigationObstacleItem ObstacleItem;\n\t\t\tFVector::FReal SqDist;\n\t\t};\n\t\tTArray<FSortedObstacle, TFixedAllocator<UE::MassAvoidance::MaxObstacleResults>> ClosestObstacles;\n\n\t\t// Potential contact between agent and environment. \n\t\tstruct FEnvironmentContact\n\t\t{\n\t\t\tFVector Position = FVector::ZeroVector;\n\t\t\tFVector Normal = FVector::ZeroVector;\n\t\t\tFVector::FReal Distance = 0.;\n\t\t};\n\t\tTArray<FEnvironmentContact, TInlineAllocator<16>> Contacts;\n\n\t\t// Describes collider to avoid, collected from neighbour obstacles.\n\t\tstruct FCollider\n\t\t{\n\t\t\tFVector Location = FVector::ZeroVector;\n\t\t\tFVector Velocity = FVector::ZeroVector;\n\t\t\tfloat Radius = 0.f;\n\t\t\tbool bCanAvoid = true;\n\t\t\tbool bIsMoving = false;\n\t\t};\n\t\tTArray<FCollider, TInlineAllocator<16>> Colliders;\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\t// @todo: this check should eventually be part of the query (i.e. only handle moving agents).\n\t\t\tconst FMassMoveTargetFragment& MoveTarget = MoveTargetList[EntityIndex];\n\t\t\tif (MoveTarget.GetCurrentAction() == EMassMovementAction::Animate || MoveTarget.GetCurrentAction() == EMassMovementAction::Stand)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFMassEntityHandle Entity = Context.GetEntity(EntityIndex);\n\t\t\tconst FMassNavigationEdgesFragment& NavEdges = NavEdgesList[EntityIndex];\n\t\t\tconst FTransformFragment& Location = LocationList[EntityIndex];\n\t\t\tconst FMassVelocityFragment& Velocity = VelocityList[EntityIndex];\n\t\t\tconst FAgentRadiusFragment& Radius = RadiusList[EntityIndex];\n\t\t\tFMassForceFragment& Force = ForceList[EntityIndex];\n\n\t\t\t// Smaller steering max accel makes the steering more \"calm\" but less opportunistic, may not find solution, or gets stuck.\n\t\t\t// Max contact accel should be quite a big bigger than steering so that collision response is firm. \n\t\t\tconst FVector::FReal MaxSteerAccel = MovementParams.MaxAcceleration;\n\t\t\tconst FVector::FReal MaximumSpeed = MovementParams.MaxSpeed;\n\n\t\t\tconst FVector AgentLocation = Location.GetTransform().GetTranslation();\n\t\t\tconst FVector AgentVelocity = FVector(Velocity.Value.X, Velocity.Value.Y, 0.);\n\t\t\t\n\t\t\tconst FVector::FReal AgentRadius = Radius.Radius;\n\t\t\tconst FVector::FReal SeparationAgentRadius = Radius.Radius * MovingAvoidanceParams.SeparationRadiusScale;\n\t\t\tconst FVector::FReal PredictiveAvoidanceAgentRadius = Radius.Radius * MovingAvoidanceParams.PredictiveAvoidanceRadiusScale;\n\t\t\t\n\t\t\tFVector SteeringForce = Force.Value;\n\n\t\t\t// Near start and end fades are used to subdue the avoidance at the start and end of the path.\n\t\t\tFVector::FReal NearStartFade = 1.;\n\t\t\tFVector::FReal NearEndFade = 1.;\n\n\t\t\tif (MoveTarget.GetPreviousAction() != EMassMovementAction::Move)\n\t\t\t{\n\t\t\t\t// Fade in avoidance when transitioning from other than move action.\n\t\t\t\t// I.e. the standing behavior may move the agents so close to each,\n\t\t\t\t// and that causes the separation to push them out quickly when avoidance is activated. \n\t\t\t\tNearStartFade = FMath::Min((CurrentTime - MoveTarget.GetCurrentActionStartTime()) / MovingAvoidanceParams.StartOfPathDuration, 1.);\n\t\t\t}\n\n\t\t\tif (MoveTarget.IntentAtGoal == EMassMovementAction::Stand)\n\t\t\t{\n\t\t\t\t// Estimate approach based on current desired speed.\n\t\t\t\tconst FVector::FReal ApproachDistance = FMath::Max<FVector::FReal>(1., MovingAvoidanceParams.EndOfPathDuration * MoveTarget.DesiredSpeed.Get());\n\t\t\t\tNearEndFade = FMath::Clamp(MoveTarget.DistanceToGoal / ApproachDistance, 0., 1.);\n\t\t\t}\n\t\t\t\n\t\t\tconst FVector::FReal NearStartScaling = FMath::Lerp<FVector::FReal>(MovingAvoidanceParams.StartOfPathAvoidanceScale, 1., NearStartFade);\n\t\t\tconst FVector::FReal NearEndScaling = FMath::Lerp<FVector::FReal>(MovingAvoidanceParams.EndOfPathAvoidanceScale, 1., NearEndFade);\n\t\t\t\n#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT\n\t\t\tconst UE::MassAvoidance::FDebugContext BaseDebugContext(this, LogAvoidance, World, Entity);\n\t\t\tconst UE::MassAvoidance::FDebugContext VelocitiesDebugContext(this, LogAvoidanceVelocities, World, Entity);\n\t\t\tconst UE::MassAvoidance::FDebugContext ObstacleDebugContext(this, LogAvoidanceObstacles, World, Entity);\n\t\t\tconst UE::MassAvoidance::FDebugContext AgentDebugContext(this, LogAvoidanceAgents, World, Entity);\n\t\t\t\n\t\t\tif (UE::MassAvoidance::DebugIsSelected(Entity))\n\t\t\t{\n\t\t\t\t// Draw agent\n\t\t\t\tconst FString Text = FString::Printf(TEXT(\"%i\"), Entity.Index);\n\t\t\t\tDebugDrawCylinder(BaseDebugContext, AgentLocation, AgentLocation + UE::MassAvoidance::DebugAgentHeightOffset, static_cast<float>(AgentRadius+1.), UE::MassAvoidance::CurrentAgentColor, Text);\n\n\t\t\t\tDebugDrawSphere(BaseDebugContext, AgentLocation, 10.f, UE::MassAvoidance::CurrentAgentColor);\n\n\t\t\t\t// Draw current velocity (black)\n\t\t\t\tDebugDrawVelocity(VelocitiesDebugContext, AgentLocation + UE::MassAvoidance::DebugAgentHeightOffset, AgentLocation + UE::MassAvoidance::DebugAgentHeightOffset + AgentVelocity, UE::MassAvoidance::VelocityColor);\n\n\t\t\t\t// Draw preferred velocity (red)\n//\t\t\t\tDebugDrawVelocity(VelocitiesDebugContext, AgentLocation + UE::MassAvoidance::DebugAgentHeightOffset, AgentLocation + UE::MassAvoidance::DebugAgentHeightOffset + PrefVelocity, UE::MassAvoidance::PrefVelocityColor);\n\n\t\t\t\t// Draw initial steering force\n\t\t\t\tDebugDrawArrow(BaseDebugContext, AgentLocation + UE::MassAvoidance::DebugAgentHeightOffset, AgentLocation +UE::MassAvoidance:: DebugAgentHeightOffset + SteeringForce, UE::MassAvoidance::CurrentAgentColor, UE::MassAvoidance::BigArrowHeadSize, UE::MassAvoidance::BigArrowThickness);\n\n\t\t\t\t// Draw center\n\t\t\t\tDebugDrawSphere(BaseDebugContext, AgentLocation, /*Radius*/2.f, UE::MassAvoidance::CurrentAgentColor);\n\t\t\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t\t\tFVector OldSteeringForce = FVector::ZeroVector;\n\n\t\t\t//////////////////////////////////////////////////////////////////////////\n\t\t\t// Environment avoidance.\n\t\t\t//\n\t\t\t\n\t\t\tif (!MoveTarget.bOffBoundaries && UE::MassAvoidance::Tweakables::bEnableEnvironmentAvoidance)\n\t\t\t{\n\t\t\t\tconst FVector DesiredAcceleration = UE::MassNavigation::ClampVector(SteeringForce, MaxSteerAccel);\n\t\t\t\tconst FVector DesiredVelocity = UE::MassNavigation::ClampVector(AgentVelocity + DesiredAcceleration * DeltaTime, MaximumSpeed);\n\n#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT\n\t\t\t\t// Draw desired velocity (yellow)\n\t\t\t\tUE::MassAvoidance::DebugDrawVelocity(VelocitiesDebugContext, AgentLocation + UE::MassAvoidance::DebugAgentHeightOffset, AgentLocation + UE::MassAvoidance::DebugAgentHeightOffset + DesiredVelocity, UE::MassAvoidance::DesiredVelocityColor);\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t\t\t\tOldSteeringForce = SteeringForce;\n\t\t\t\tContacts.Reset();\n\n\t\t\t\t// Collect potential contacts between agent and environment edges.\n\t\t\t\tfor (const FNavigationAvoidanceEdge& Edge : NavEdges.AvoidanceEdges)\n\t\t\t\t{\n\t\t\t\t\tconst FVector EdgeDiff = Edge.End - Edge.Start;\n\t\t\t\t\tFVector EdgeDir = FVector::ZeroVector;\n\t\t\t\t\tFVector::FReal EdgeLength = 0.;\n\t\t\t\t\tEdgeDiff.ToDirectionAndLength(EdgeDir, EdgeLength);\n\n\t\t\t\t\tconst FVector AgentToEdgeStart = AgentLocation - Edge.Start;\n\t\t\t\t\tconst FVector::FReal DistAlongEdge = FVector::DotProduct(EdgeDir, AgentToEdgeStart);\n\t\t\t\t\tconst FVector::FReal DistAwayFromEdge = FVector::DotProduct(Edge.LeftDir, AgentToEdgeStart);\n\n\t\t\t\t\tFVector::FReal ConDist = 0.;\n\t\t\t\t\tFVector ConNorm = FVector::ForwardVector;\n\t\t\t\t\tFVector ConPos = FVector::ZeroVector;\n\t\t\t\t\tbool bDirectlyBehindEdge = false;\n\t\t\t\t\t\n\t\t\t\t\tif (DistAwayFromEdge < 0.)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Inside or behind the edge\n\t\t\t\t\t\tif (DistAlongEdge < 0.)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tConPos = Edge.Start;\n\t\t\t\t\t\t\tConNorm = -EdgeDir;\n\t\t\t\t\t\t\tConDist = -DistAlongEdge;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (DistAlongEdge > EdgeLength)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tConPos = Edge.End;\n\t\t\t\t\t\t\tConNorm = EdgeDir;\n\t\t\t\t\t\t\tConDist = DistAlongEdge;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tConPos = Edge.Start + EdgeDir * DistAlongEdge;\n\t\t\t\t\t\t\tConNorm = Edge.LeftDir;\n\t\t\t\t\t\t\tConDist = 0.;\n\t\t\t\t\t\t\tbDirectlyBehindEdge = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (DistAlongEdge < 0.)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Start Corner\n\t\t\t\t\t\t\tConPos = Edge.Start;\n\t\t\t\t\t\t\tEdgeDiff.ToDirectionAndLength(ConNorm, ConDist);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (DistAlongEdge > EdgeLength)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// End Corner\n\t\t\t\t\t\t\tConPos = Edge.End;\n\t\t\t\t\t\t\tEdgeDiff.ToDirectionAndLength(ConNorm, ConDist);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Front\n\t\t\t\t\t\t\tConPos = Edge.Start + EdgeDir * DistAlongEdge;\n\t\t\t\t\t\t\tConNorm = Edge.LeftDir;\n\t\t\t\t\t\t\tConDist = DistAwayFromEdge;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Check to merge contacts\n\t\t\t\t\tbool bAdd = true;\n\t\t\t\t\tfor (int ContactIndex = 0; ContactIndex < Contacts.Num(); ContactIndex++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (FVector::DotProduct(Contacts[ContactIndex].Normal, ConNorm) > 0. && FMath::Abs(FVector::DotProduct(ConNorm, Contacts[ContactIndex].Position - ConPos)) < (10./*cm*/))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Contacts are on same place, merge\n\t\t\t\t\t\t\tif (ConDist < Contacts[ContactIndex].Distance)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// New is closer, override.\n\t\t\t\t\t\t\t\tContacts[ContactIndex].Position = ConPos;\n\t\t\t\t\t\t\t\tContacts[ContactIndex].Normal = ConNorm;\n\t\t\t\t\t\t\t\tContacts[ContactIndex].Distance = ConDist;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbAdd = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Not found, add new contact\n\t\t\t\t\tif (bAdd)\n\t\t\t\t\t{\n\t\t\t\t\t\tFEnvironmentContact Contact;\n\t\t\t\t\t\tContact.Position = ConPos;\n\t\t\t\t\t\tContact.Normal = ConNorm;\n\t\t\t\t\t\tContact.Distance = ConDist;\n\t\t\t\t\t\tContacts.Add(Contact);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Skip predictive avoidance when behind the edge.\n\t\t\t\t\tif (!bDirectlyBehindEdge)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Avoid edges\n\t\t\t\t\t\tconst FVector::FReal CPA = UE::MassAvoidance::ComputeClosestPointOfApproach(FVector2D(AgentLocation), FVector2D(DesiredVelocity), AgentRadius,\n\t\t\t\t\t\t\tFVector2D(Edge.Start), FVector2D(Edge.End), MovingAvoidanceParams.PredictiveAvoidanceTime);\n\t\t\t\t\t\tconst FVector HitAgentPos = AgentLocation + DesiredVelocity * CPA;\n\t\t\t\t\t\tconst FVector::FReal EdgeT = UE::MassNavigation::ProjectPtSeg(FVector2D(HitAgentPos), FVector2D(Edge.Start), FVector2D(Edge.End));\n\t\t\t\t\t\tconst FVector HitObPos = FMath::Lerp(Edge.Start, Edge.End, EdgeT);\n\n\t\t\t\t\t\t// Calculate penetration at CPA\n\t\t\t\t\t\tFVector AvoidRelPos = HitAgentPos - HitObPos;\n\t\t\t\t\t\tAvoidRelPos.Z = 0.;\t// @todo AT: ignore the z component for now until we clamp the height of obstacles\n\t\t\t\t\t\tconst FVector::FReal AvoidDist = AvoidRelPos.Size();\n\t\t\t\t\t\tconst FVector AvoidNormal = AvoidDist > 0. ? (AvoidRelPos / AvoidDist) : FVector::ForwardVector;\n\n\t\t\t\t\t\tconst FVector::FReal AvoidPen = (PredictiveAvoidanceAgentRadius + MovingAvoidanceParams.PredictiveAvoidanceDistance) - AvoidDist;\n\t\t\t\t\t\tconst FVector::FReal AvoidMag = FMath::Square(FMath::Clamp(AvoidPen / MovingAvoidanceParams.PredictiveAvoidanceDistance, 0., 1.));\n\t\t\t\t\t\tconst FVector::FReal AvoidMagDist = 1. + FMath::Square(1. - CPA * InvPredictiveAvoidanceTime);\n\t\t\t\t\t\tconst FVector AvoidForce = AvoidNormal * AvoidMag * AvoidMagDist * MovingAvoidanceParams.EnvironmentPredictiveAvoidanceStiffness * NearEndScaling; // Predictive avoidance against environment is tuned down towards the end of the path\n\n\t\t\t\t\t\tSteeringForce += AvoidForce;\n\n#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT\n\t\t\t\t\t\t// Draw contact normal\n\t\t\t\t\t\tUE::MassAvoidance::DebugDrawArrow(ObstacleDebugContext, ConPos, ConPos + 50. * ConNorm, UE::MassAvoidance::ObstacleContactNormalColor, /*HeadSize=*/ 5.f);\n\t\t\t\t\t\tUE::MassAvoidance::DebugDrawSphere(ObstacleDebugContext, ConPos, 2.5f, UE::MassAvoidance::ObstacleContactNormalColor);\n\n\t\t\t\t\t\t// Draw hit pos with edge\n\t\t\t\t\t\tUE::MassAvoidance::DebugDrawLine(ObstacleDebugContext, AgentLocation, HitAgentPos, UE::MassAvoidance::ObstacleAvoidForceColor);\n\t\t\t\t\t\tUE::MassAvoidance::DebugDrawCylinder(ObstacleDebugContext, HitAgentPos, HitAgentPos + UE::MassAvoidance::DebugAgentHeightOffset, static_cast<float>(AgentRadius), UE::MassAvoidance::ObstacleAvoidForceColor);\n\n\t\t\t\t\t\t// Draw avoid obstacle force\n\t\t\t\t\t\tUE::MassAvoidance::DebugDrawForce(ObstacleDebugContext, HitObPos, HitObPos + AvoidForce, UE::MassAvoidance::ObstacleAvoidForceColor);\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t\t\t\t\t}\n\t\t\t\t} // edge loop\n\n#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT\n\t\t\t\t// Draw total steering force to avoid obstacles\n\t\t\t\tconst FVector EnvironmentAvoidSteeringForce = SteeringForce - OldSteeringForce;\n\t\t\t\tUE::MassAvoidance::DebugDrawSummedForce(ObstacleDebugContext,\n\t\t\t\t\tAgentLocation + UE::MassAvoidance::DebugAgentHeightOffset,\n\t\t\t\t\tAgentLocation + UE::MassAvoidance::DebugAgentHeightOffset + EnvironmentAvoidSteeringForce,\n\t\t\t\t\tUE::MassAvoidance::ObstacleAvoidForceColor);\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t\t\t\t// Process contacts to add edge separation force\n\t\t\t\tconst FVector SteeringForceBeforeSeparation = SteeringForce;\n\t\t\t\tfor (int ContactIndex = 0; ContactIndex < Contacts.Num(); ContactIndex++) \n\t\t\t\t{\n\t\t\t\t\tconst FVector ConNorm = Contacts[ContactIndex].Normal.GetSafeNormal();\n\t\t\t\t\tconst FVector::FReal ContactDist = Contacts[ContactIndex].Distance;\n\n\t\t\t\t\t// Separation force (stay away from obstacles if possible)\n\t\t\t\t\tconst FVector::FReal SeparationPenalty = (SeparationAgentRadius + MovingAvoidanceParams.EnvironmentSeparationDistance) - ContactDist;\n\t\t\t\t\tconst FVector::FReal SeparationMag = UE::MassNavigation::Smooth(FMath::Clamp(SeparationPenalty / MovingAvoidanceParams.EnvironmentSeparationDistance, 0., 1.));\n\t\t\t\t\tconst FVector SeparationForce = ConNorm * MovingAvoidanceParams.EnvironmentSeparationStiffness * SeparationMag;\n\n\t\t\t\t\tSteeringForce += SeparationForce;\n\n#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT\n\t\t\t\t\t// Draw individual contact forces\n\t\t\t\t\tDebugDrawForce(ObstacleDebugContext, Contacts[ContactIndex].Position + UE::MassAvoidance::DebugAgentHeightOffset,\n\t\t\t\t\tContacts[ContactIndex].Position + SeparationForce + UE::MassAvoidance::DebugAgentHeightOffset, UE::MassAvoidance::ObstacleSeparationForceColor);\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t\t\t\t}\n\t\t\t\t\n#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT\n\t\t\t\t// Draw total steering force to separate from close edges\n\t\t\t\tconst FVector TotalSeparationForce = SteeringForce - SteeringForceBeforeSeparation;\n\t\t\t\tDebugDrawSummedForce(ObstacleDebugContext,\n\t\t\t\t\tAgentLocation + UE::MassAvoidance::DebugAgentHeightOffset,\n\t\t\t\t\tAgentLocation + UE::MassAvoidance::DebugAgentHeightOffset + TotalSeparationForce,\n\t\t\t\t\tUE::MassAvoidance::ObstacleSeparationForceColor);\n\n\t\t\t\t// Display close obstacle edges\n\t\t\t\tif (UE::MassAvoidance::DebugIsSelected(Entity))\n\t\t\t\t{\n\t\t\t\t\tfor (const FNavigationAvoidanceEdge& Edge : NavEdges.AvoidanceEdges)\n\t\t\t\t\t{\n\t\t\t\t\t\tDebugDrawLine(ObstacleDebugContext, UE::MassAvoidance::DebugAgentHeightOffset + Edge.Start,\n\t\t\t\t\t\t\tUE::MassAvoidance::DebugAgentHeightOffset + Edge.End, UE::MassAvoidance::ObstacleColor, /*Thickness=*/2.f);\n\t\t\t\t\t\tconst FVector Middle = UE::MassAvoidance::DebugAgentHeightOffset + 0.5f * (Edge.Start + Edge.End);\n\t\t\t\t\t\tDebugDrawArrow(ObstacleDebugContext, Middle, Middle + 10. * FVector::CrossProduct((Edge.End - Edge.Start), FVector::UpVector).GetSafeNormal(), UE::MassAvoidance::ObstacleColor, /*HeadSize=*/2.f);\n\t\t\t\t\t}\n\t\t\t\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t\t\t}\n\n\t\t\t//////////////////////////////////////////////////////////////////////////\n\t\t\t// Avoid close agents\n\n\t\t\t// Update desired velocity based on avoidance so far.\n\t\t\tconst FVector DesAcc = UE::MassNavigation::ClampVector(SteeringForce, MaxSteerAccel);\n\t\t\tconst FVector DesVel = UE::MassNavigation::ClampVector(AgentVelocity + DesAcc * DeltaTime, MaximumSpeed);\n\n\t\t\t// Find close obstacles\n\t\t\tconst FNavigationObstacleHashGrid2D& AvoidanceObstacleGrid = NavigationSubsystem->GetObstacleGridMutable();\n\t\t\tUE::MassAvoidance::FindCloseObstacles(AgentLocation, MovingAvoidanceParams.ObstacleDetectionDistance, AvoidanceObstacleGrid, CloseEntities, UE::MassAvoidance::MaxObstacleResults);\n\n\t\t\t// Remove unwanted and find the closests in the CloseEntities\n\t\t\tconst FVector::FReal DistanceCutOffSqr = FMath::Square(MovingAvoidanceParams.ObstacleDetectionDistance);\n\t\t\tClosestObstacles.Reset();\n\t\t\tfor (const FNavigationObstacleHashGrid2D::ItemIDType OtherEntity : CloseEntities)\n\t\t\t{\n\t\t\t\t// Skip self\n\t\t\t\tif (OtherEntity.Entity == Entity)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Skip invalid entities.\n\t\t\t\tif (!EntityManager.IsEntityValid(OtherEntity.Entity))\n\t\t\t\t{\n\t\t\t\t\tUE_LOG(LogAvoidanceObstacles, VeryVerbose, TEXT(\"Close entity is invalid, skipped.\"));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Skip too far\n\t\t\t\tconst FTransform& Transform = EntityManager.GetFragmentDataChecked<FTransformFragment>(OtherEntity.Entity).GetTransform();\n\t\t\t\tconst FVector OtherLocation = Transform.GetLocation();\n\t\t\t\t\n\t\t\t\tconst FVector::FReal SqDist = FVector::DistSquared(AgentLocation, OtherLocation);\n\t\t\t\tif (SqDist > DistanceCutOffSqr)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tFSortedObstacle Obstacle;\n\t\t\t\tObstacle.LocationCached = OtherLocation;\n\t\t\t\tObstacle.Forward = Transform.GetRotation().GetForwardVector();\n\t\t\t\tObstacle.ObstacleItem = OtherEntity;\n\t\t\t\tObstacle.SqDist = SqDist;\n\t\t\t\tClosestObstacles.Add(Obstacle);\n\t\t\t}\n\t\t\tClosestObstacles.Sort([](const FSortedObstacle& A, const FSortedObstacle& B) { return A.SqDist < B.SqDist; });\n\n\t\t\t// Compute forces\n\t\t\tOldSteeringForce = SteeringForce;\n\t\t\tFVector TotalAgentSeparationForce = FVector::ZeroVector;\n\n\t\t\t// Fill collider list from close agents\n\t\t\tColliders.Reset();\n\t\t\tconstexpr int32 MaxColliders = 6;\n\t\t\tfor (int32 Index = 0; Index < ClosestObstacles.Num(); Index++)\n\t\t\t{\n\t\t\t\tif (Colliders.Num() >= MaxColliders)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tFSortedObstacle& Obstacle = ClosestObstacles[Index];\n\t\t\t\tFMassEntityView OtherEntityView(EntityManager, Obstacle.ObstacleItem.Entity);\n\n\t\t\t\tconst FMassVelocityFragment* OtherVelocityFragment = OtherEntityView.GetFragmentDataPtr<FMassVelocityFragment>();\n\t\t\t\tconst FVector OtherVelocity = OtherVelocityFragment != nullptr ? OtherVelocityFragment->Value : FVector::ZeroVector; // Get velocity from FAvoidanceComponent\n\n\t\t\t\t// @todo: this is heavy fragment to access, see if we could handle this differently.\n\t\t\t\tconst FMassMoveTargetFragment* OtherMoveTarget = OtherEntityView.GetFragmentDataPtr<FMassMoveTargetFragment>();\n\t\t\t\tconst bool bCanAvoid = OtherMoveTarget != nullptr;\n\t\t\t\tconst bool bOtherIsMoving = OtherMoveTarget ? OtherMoveTarget->GetCurrentAction() == EMassMovementAction::Move : true; // Assume moving if other does not have move target.\n\t\t\t\t\n\t\t\t\t// Check for colliders data\n\t\t\t\tif (EnumHasAnyFlags(Obstacle.ObstacleItem.ItemFlags, EMassNavigationObstacleFlags::HasColliderData))\n\t\t\t\t{\n\t\t\t\t\tif (const FMassAvoidanceColliderFragment* ColliderFragment = OtherEntityView.GetFragmentDataPtr<FMassAvoidanceColliderFragment>())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ColliderFragment->Type == EMassColliderType::Circle)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst FMassCircleCollider Circle = ColliderFragment->GetCircleCollider();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tFCollider& Collider = Colliders.Add_GetRef(FCollider{});\n\t\t\t\t\t\t\tCollider.Velocity = OtherVelocity;\n\t\t\t\t\t\t\tCollider.bCanAvoid = bCanAvoid;\n\t\t\t\t\t\t\tCollider.bIsMoving = bOtherIsMoving;\n\t\t\t\t\t\t\tCollider.Radius = Circle.Radius;\n\t\t\t\t\t\t\tCollider.Location = Obstacle.LocationCached;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ColliderFragment->Type == EMassColliderType::Pill)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst FMassPillCollider Pill = ColliderFragment->GetPillCollider(); \n\n\t\t\t\t\t\t\tFCollider& Collider = Colliders.Add_GetRef(FCollider{});\n\t\t\t\t\t\t\tCollider.Velocity = OtherVelocity;\n\t\t\t\t\t\t\tCollider.bCanAvoid = bCanAvoid;\n\t\t\t\t\t\t\tCollider.bIsMoving = bOtherIsMoving;\n\t\t\t\t\t\t\tCollider.Radius = Pill.Radius;\n\t\t\t\t\t\t\tCollider.Location = Obstacle.LocationCached + (Pill.HalfLength * Obstacle.Forward);\n\n\t\t\t\t\t\t\tif (Colliders.Num() < MaxColliders)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tFCollider& Collider2 = Colliders.Add_GetRef(FCollider{});\n\t\t\t\t\t\t\t\tCollider2.Velocity = OtherVelocity;\n\t\t\t\t\t\t\t\tCollider2.bCanAvoid = bCanAvoid;\n\t\t\t\t\t\t\t\tCollider2.bIsMoving = bOtherIsMoving;\n\t\t\t\t\t\t\t\tCollider2.Radius = Pill.Radius;\n\t\t\t\t\t\t\t\tCollider2.Location = Obstacle.LocationCached + (-Pill.HalfLength * Obstacle.Forward);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tFCollider& Collider = Colliders.Add_GetRef(FCollider{});\n\t\t\t\t\tCollider.Location = Obstacle.LocationCached;\n\t\t\t\t\tCollider.Velocity = OtherVelocity;\n\t\t\t\t\tCollider.Radius = OtherEntityView.GetFragmentData<FAgentRadiusFragment>().Radius;\n\t\t\t\t\tCollider.bCanAvoid = bCanAvoid;\n\t\t\t\t\tCollider.bIsMoving = bOtherIsMoving;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Process colliders for avoidance\n\t\t\tfor (const FCollider& Collider : Colliders)\n\t\t\t{\n\t\t\t\tbool bHasForcedNormal = false;\n\t\t\t\tFVector ForcedNormal = FVector::ZeroVector;\n\n\t\t\t\tif (Collider.bCanAvoid == false)\n\t\t\t\t{\n\t\t\t\t\t// If the other obstacle cannot avoid us, try to avoid the local minima they create between the wall and their collider.\n\t\t\t\t\t// If the space between edge and collider is less than MinClearance, make the agent to avoid the gap.\n\t\t\t\t\tconst FVector::FReal MinClearance = 2. * AgentRadius * MovingAvoidanceParams.StaticObstacleClearanceScale;\n\t\t\t\t\t\n\t\t\t\t\t// Find the maximum distance from edges that are too close.\n\t\t\t\t\tFVector::FReal MaxDist = -1.;\n\t\t\t\t\tFVector ClosestPoint = FVector::ZeroVector;\n\t\t\t\t\tfor (const FNavigationAvoidanceEdge& Edge : NavEdges.AvoidanceEdges)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst FVector Point = FMath::ClosestPointOnSegment(Collider.Location, Edge.Start, Edge.End);\n\t\t\t\t\t\tconst FVector Offset = Collider.Location - Point;\n\t\t\t\t\t\tif (FVector::DotProduct(Offset, Edge.LeftDir) < 0.)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Behind the edge, ignore.\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst FVector::FReal OffsetLength = Offset.Length();\n\t\t\t\t\t\tconst bool bTooNarrow = (OffsetLength - Collider.Radius) < MinClearance; \n\t\t\t\t\t\tif (bTooNarrow)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (OffsetLength > MaxDist)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMaxDist = OffsetLength;\n\t\t\t\t\t\t\t\tClosestPoint = Point;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (MaxDist != -1.)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Set up forced normal to avoid the gap between collider and edge.\n\t\t\t\t\t\tForcedNormal = (Collider.Location - ClosestPoint).GetSafeNormal();\n\t\t\t\t\t\tbHasForcedNormal = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tFVector RelPos = AgentLocation - Collider.Location;\n\t\t\t\tRelPos.Z = 0.; // we assume we work on a flat plane for now\n\t\t\t\tconst FVector RelVel = DesVel - Collider.Velocity;\n\t\t\t\tconst FVector::FReal ConDist = RelPos.Size();\n\t\t\t\tconst FVector ConNorm = ConDist > 0. ? RelPos / ConDist : FVector::ForwardVector;\n\n\t\t\t\tFVector SeparationNormal = ConNorm;\n\t\t\t\tif (bHasForcedNormal)\n\t\t\t\t{\n\t\t\t\t\t// The more head on the collisions is, the more we should avoid towards the forced direction.\n\t\t\t\t\tconst FVector RelVelNorm = RelVel.GetSafeNormal();\n\t\t\t\t\tconst FVector::FReal Blend = FMath::Max(0., -FVector::DotProduct(ConNorm, RelVelNorm));\n\t\t\t\t\tSeparationNormal = FMath::Lerp(ConNorm, ForcedNormal, Blend).GetSafeNormal();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconst FVector::FReal StandingScaling = Collider.bIsMoving ? 1. : MovingAvoidanceParams.StandingObstacleAvoidanceScale; // Care less about standing agents so that we can push through standing crowd.\n\t\t\t\t\n\t\t\t\t// Separation force (stay away from agents if possible)\n\t\t\t\tconst FVector::FReal PenSep = (SeparationAgentRadius + Collider.Radius + MovingAvoidanceParams.ObstacleSeparationDistance) - ConDist;\n\t\t\t\tconst FVector::FReal SeparationMag = FMath::Square(FMath::Clamp(PenSep / MovingAvoidanceParams.ObstacleSeparationDistance, 0., 1.));\n\t\t\t\tconst FVector SepForce = SeparationNormal * MovingAvoidanceParams.ObstacleSeparationStiffness;\n\t\t\t\tconst FVector SeparationForce = SepForce * SeparationMag * StandingScaling;\n\n\t\t\t\tSteeringForce += SeparationForce;\n\t\t\t\tTotalAgentSeparationForce += SeparationForce;\n\n\t\t\t\t// Calculate closest point of approach based on relative agent positions and velocities.\n\t\t\t\tconst FVector::FReal CPA = UE::MassAvoidance::ComputeClosestPointOfApproach(RelPos, RelVel, PredictiveAvoidanceAgentRadius + Collider.Radius, MovingAvoidanceParams.PredictiveAvoidanceTime);\n\n\t\t\t\t// Calculate penetration at CPA\n\t\t\t\tconst FVector AvoidRelPos = RelPos + RelVel * CPA;\n\t\t\t\tconst FVector::FReal AvoidDist = AvoidRelPos.Size();\n\t\t\t\tconst FVector AvoidConNormal = AvoidDist > 0. ? (AvoidRelPos / AvoidDist) : FVector::ForwardVector;\n\n\t\t\t\tFVector AvoidNormal = AvoidConNormal;\n\t\t\t\tif (bHasForcedNormal)\n\t\t\t\t{\n\t\t\t\t\t// The more head on the predicted collisions is, the more we should avoid towards the forced direction.\n\t\t\t\t\tconst FVector RelVelNorm = RelVel.GetSafeNormal();\n\t\t\t\t\tconst FVector::FReal Blend = FMath::Max(0., -FVector::DotProduct(AvoidConNormal, RelVelNorm));\n\t\t\t\t\tAvoidNormal = FMath::Lerp(AvoidConNormal, ForcedNormal, Blend).GetSafeNormal();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconst FVector::FReal AvoidPenetration = (PredictiveAvoidanceAgentRadius + Collider.Radius + MovingAvoidanceParams.PredictiveAvoidanceDistance) - AvoidDist; // Based on future agents distance\n\t\t\t\tconst FVector::FReal AvoidMag = FMath::Square(FMath::Clamp(AvoidPenetration / MovingAvoidanceParams.PredictiveAvoidanceDistance, 0., 1.));\n\t\t\t\tconst FVector::FReal AvoidMagDist = (1. - (CPA * InvPredictiveAvoidanceTime)); // No clamp, CPA is between 0 and PredictiveAvoidanceTime\n\t\t\t\tconst FVector AvoidForce = AvoidNormal * AvoidMag * AvoidMagDist * MovingAvoidanceParams.ObstaclePredictiveAvoidanceStiffness * StandingScaling;\n\n\t\t\t\tSteeringForce += AvoidForce;\n\n#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT\n\t\t\t\t// Display close agent\n\t\t\t\tUE::MassAvoidance::DebugDrawCylinder(AgentDebugContext, Collider.Location, Collider.Location + UE::MassAvoidance::DebugLowCylinderOffset, Collider.Radius, UE::MassAvoidance::AgentsColor);\n\n\t\t\t\tif (bHasForcedNormal)\n\t\t\t\t{\n\t\t\t\t\tUE::MassAvoidance::DebugDrawCylinder(BaseDebugContext, Collider.Location, Collider.Location + UE::MassAvoidance::DebugAgentHeightOffset, Collider.Radius, FColor::Red);\n\t\t\t\t}\n\n\t\t\t\t// Draw agent contact separation force\n\t\t\t\tUE::MassAvoidance::DebugDrawSummedForce(AgentDebugContext,\n\t\t\t\t\tCollider.Location + UE::MassAvoidance::DebugAgentHeightOffset,\n\t\t\t\t\tCollider.Location + UE::MassAvoidance::DebugAgentHeightOffset + SeparationForce,\n\t\t\t\t\tUE::MassAvoidance::AgentSeparationForceColor); \n\t\t\t\t\n\t\t\t\tif (AvoidForce.Size() > 0.)\n\t\t\t\t{\n\t\t\t\t\t// Draw agent vs agent hit positions\n\t\t\t\t\tconst FVector HitPosition = AgentLocation + (DesVel * CPA);\n\t\t\t\t\tconst FVector LeftOffset = PredictiveAvoidanceAgentRadius * UE::MassNavigation::GetLeftDirection(DesVel.GetSafeNormal(), FVector::UpVector);\n\t\t\t\t\tUE::MassAvoidance::DebugDrawLine(AgentDebugContext, AgentLocation + UE::MassAvoidance::DebugAgentHeightOffset + LeftOffset, HitPosition + UE::MassAvoidance::DebugAgentHeightOffset + LeftOffset, UE::MassAvoidance::CurrentAgentColor, 1.5f);\n\t\t\t\t\tUE::MassAvoidance::DebugDrawLine(AgentDebugContext, AgentLocation + UE::MassAvoidance::DebugAgentHeightOffset - LeftOffset, HitPosition + UE::MassAvoidance::DebugAgentHeightOffset - LeftOffset, UE::MassAvoidance::CurrentAgentColor, 1.5f);\n\t\t\t\t\tUE::MassAvoidance::DebugDrawCylinder(AgentDebugContext, HitPosition, HitPosition + UE::MassAvoidance::DebugAgentHeightOffset, static_cast<float>(PredictiveAvoidanceAgentRadius), UE::MassAvoidance::CurrentAgentColor);\n\n\t\t\t\t\tconst FVector OtherHitPosition = Collider.Location + (Collider.Velocity * CPA);\n\t\t\t\t\tconst FVector OtherLeftOffset = Collider.Radius * UE::MassNavigation::GetLeftDirection(Collider.Velocity.GetSafeNormal(), FVector::UpVector);\n\t\t\t\t\tconst FVector Left = UE::MassAvoidance::DebugAgentHeightOffset + OtherLeftOffset;\n\t\t\t\t\tconst FVector Right = UE::MassAvoidance::DebugAgentHeightOffset - OtherLeftOffset;\n\t\t\t\t\tUE::MassAvoidance::DebugDrawLine(AgentDebugContext, Collider.Location + Left, OtherHitPosition + Left, UE::MassAvoidance::AgentsColor, 1.5f);\n\t\t\t\t\tUE::MassAvoidance::DebugDrawLine(AgentDebugContext, Collider.Location + Right, OtherHitPosition + Right, UE::MassAvoidance::AgentsColor, 1.5f);\n\t\t\t\t\tUE::MassAvoidance::DebugDrawCylinder(AgentDebugContext, Collider.Location, Collider.Location + UE::MassAvoidance::DebugAgentHeightOffset, static_cast<float>(AgentRadius), UE::MassAvoidance::AgentsColor);\n\t\t\t\t\tUE::MassAvoidance::DebugDrawCylinder(AgentDebugContext, OtherHitPosition, OtherHitPosition + UE::MassAvoidance::DebugAgentHeightOffset, static_cast<float>(AgentRadius), UE::MassAvoidance::AgentsColor);\n\n\t\t\t\t\t// Draw agent avoid force\n\t\t\t\t\tUE::MassAvoidance::DebugDrawForce(AgentDebugContext,\n\t\t\t\t\t\tOtherHitPosition + UE::MassAvoidance::DebugAgentHeightOffset,\n\t\t\t\t\t\tOtherHitPosition + UE::MassAvoidance::DebugAgentHeightOffset + AvoidForce,\n\t\t\t\t\t\tUE::MassAvoidance::AgentAvoidForceColor);\n\t\t\t\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t\t\t} // close entities loop\n\n\t\t\tSteeringForce *= NearStartScaling * NearEndScaling;\n\t\t\t\n\t\t\tForce.Value = UE::MassNavigation::ClampVector(SteeringForce, MaxSteerAccel); // Assume unit mass\n\n#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT\n\t\t\tconst FVector AgentAvoidSteeringForce = SteeringForce - OldSteeringForce;\n\n\t\t\t// Draw total steering force to separate agents\n\t\t\tUE::MassAvoidance::DebugDrawSummedForce(AgentDebugContext,\n\t\t\t\tAgentLocation + UE::MassAvoidance::DebugAgentHeightOffset,\n\t\t\t\tAgentLocation + UE::MassAvoidance::DebugAgentHeightOffset + TotalAgentSeparationForce,\n\t\t\t\tUE::MassAvoidance::AgentSeparationForceColor);\n\n\t\t\t// Draw total steering force to avoid agents\n\t\t\tUE::MassAvoidance::DebugDrawSummedForce(AgentDebugContext,\n\t\t\t\tAgentLocation + UE::MassAvoidance::DebugAgentHeightOffset,\n\t\t\t\tAgentLocation + UE::MassAvoidance::DebugAgentHeightOffset + AgentAvoidSteeringForce,\n\t\t\t\tUE::MassAvoidance::AgentAvoidForceColor);\n\n\t\t\t// Draw final steering force adding to the agent velocity\n\t\t\tUE::MassAvoidance::DebugDrawArrow(BaseDebugContext, \n\t\t\t\tAgentLocation + AgentVelocity + UE::MassAvoidance::DebugAgentHeightOffset,\n\t\t\t\tAgentLocation + AgentVelocity + UE::MassAvoidance::DebugAgentHeightOffset + Force.Value,\n\t\t\t\tUE::MassAvoidance::FinalSteeringForceColor, UE::MassAvoidance::BigArrowHeadSize, UE::MassAvoidance::BigArrowThickness);\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t\t}\n\t});\n}\n\n//----------------------------------------------------------------------//\n//  UMassStandingAvoidanceProcessor\n//----------------------------------------------------------------------//\nUMassStandingAvoidanceProcessor::UMassStandingAvoidanceProcessor()\n\t: EntityQuery(*this)\n\n{\n\tbAutoRegisterWithProcessingPhases = true;\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Avoidance;\n\tExecutionOrder.ExecuteAfter.Add(TEXT(\"MassMovingAvoidanceProcessor\"));\n}\n\nvoid UMassStandingAvoidanceProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassGhostLocationFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassNavigationEdgesFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FAgentRadiusFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddTagRequirement<FMassMediumLODTag>(EMassFragmentPresence::None);\n\tEntityQuery.AddTagRequirement<FMassLowLODTag>(EMassFragmentPresence::None);\n\tEntityQuery.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);\n\tEntityQuery.AddConstSharedRequirement<FMassStandingAvoidanceParameters>(EMassFragmentPresence::All);\n}\n\nvoid UMassStandingAvoidanceProcessor::Initialize(UObject& Owner)\n{\n\tSuper::Initialize(Owner);\n\n\tWorld = Owner.GetWorld();\n\tNavigationSubsystem = UWorld::GetSubsystem<UMassNavigationSubsystem>(Owner.GetWorld());\n}\n\nvoid UMassStandingAvoidanceProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tQUICK_SCOPE_CYCLE_COUNTER(UMassStandingAvoidanceProcessor);\n\n\tif (!World || !NavigationSubsystem)\n\t{\n\t\treturn;\n\t}\n\n\t// Avoidance while standing\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this, &EntityManager](FMassExecutionContext& Context)\n\t{\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tconst float DeltaTime = Context.GetDeltaTimeSeconds();\n\n\t\tconst TArrayView<FMassGhostLocationFragment> GhostList = Context.GetMutableFragmentView<FMassGhostLocationFragment>();\n\t\tconst TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\t\tconst TConstArrayView<FAgentRadiusFragment> RadiusList = Context.GetFragmentView<FAgentRadiusFragment>();\n\t\tconst TConstArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetFragmentView<FMassMoveTargetFragment>();\n\t\tconst FMassStandingAvoidanceParameters& StandingParams = Context.GetConstSharedFragment<FMassStandingAvoidanceParameters>();\n\n\t\tconst FVector::FReal GhostSeparationDistance = StandingParams.GhostSeparationDistance;\n\t\tconst FVector::FReal GhostSeparationStiffness = StandingParams.GhostSeparationStiffness;\n\n\t\tconst FVector::FReal MovingSeparationDistance = StandingParams.GhostSeparationDistance * StandingParams.MovingObstacleAvoidanceScale;\n\t\tconst FVector::FReal MovingSeparationStiffness = StandingParams.GhostSeparationStiffness * StandingParams.MovingObstacleAvoidanceScale;\n\n\t\t// Arrays used to store close agents\n\t\tTArray<FMassNavigationObstacleItem, TFixedAllocator<UE::MassAvoidance::MaxObstacleResults>> CloseEntities;\n\n\t\tstruct FSortedObstacle\n\t\t{\n\t\t\tFSortedObstacle() = default;\n\t\t\tFSortedObstacle(const FMassEntityHandle InEntity, const FVector InLocation, const FVector InForward, const FVector::FReal InDistSq) : Entity(InEntity), Location(InLocation), Forward(InForward), DistSq(InDistSq) {}\n\t\t\t\n\t\t\tFMassEntityHandle Entity;\n\t\t\tFVector Location = FVector::ZeroVector;\n\t\t\tFVector Forward = FVector::ForwardVector;\n\t\t\tFVector::FReal DistSq = 0.;\n\t\t};\n\t\tTArray<FSortedObstacle, TFixedAllocator<UE::MassAvoidance::MaxObstacleResults>> ClosestObstacles;\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\t// @todo: this check should eventually be part of the query.\n\t\t\tconst FMassMoveTargetFragment& MoveTarget = MoveTargetList[EntityIndex];\n\t\t\tif (MoveTarget.GetCurrentAction() != EMassMovementAction::Stand)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tFMassGhostLocationFragment& Ghost = GhostList[EntityIndex];\n\t\t\t// Skip if the ghost is not valid for this movement action yet.\n\t\t\tif (Ghost.IsValid(MoveTarget.GetCurrentActionID()) == false)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst FTransformFragment& Location = LocationList[EntityIndex];\n\t\t\tconst FAgentRadiusFragment& Radius = RadiusList[EntityIndex];\n\n\t\t\tFMassEntityHandle Entity = Context.GetEntity(EntityIndex);\n\t\t\tconst FVector AgentLocation = Location.GetTransform().GetTranslation();\n\t\t\tconst FVector::FReal AgentRadius = Radius.Radius;\n\n\t\t\t// Steer ghost to move target.\n\t\t\tconst FVector::FReal SteerK = 1. / StandingParams.GhostSteeringReactionTime;\n\t\t\tconstexpr FVector::FReal SteeringMinDistance = 1.; // Do not bother to steer if the distance is less than this.\n\n\t\t\tFVector SteerDirection = FVector::ZeroVector;\n\t\t\tFVector Delta = MoveTarget.Center - Ghost.Location;\n\t\t\tDelta.Z = 0.;\n\t\t\tconst FVector::FReal Distance = Delta.Size();\n\t\t\tFVector::FReal SpeedFade = 0.;\n\t\t\tif (Distance > SteeringMinDistance)\n\t\t\t{\n\t\t\t\tSteerDirection = Delta / Distance;\n\t\t\t\tSpeedFade = FMath::Clamp(Distance / FMath::Max(KINDA_SMALL_NUMBER, StandingParams.GhostStandSlowdownRadius), 0., 1.);\n\t\t\t}\n\n\t\t\tconst FVector GhostDesiredVelocity = SteerDirection * StandingParams.GhostMaxSpeed * SpeedFade;\n\t\t\tFVector GhostSteeringForce = SteerK * (GhostDesiredVelocity - Ghost.Velocity); // Goal force\n\t\t\t\n\t\t\t// Find close obstacles\n\t\t\t// @todo: optimize FindCloseObstacles() and cache results. We're intentionally using agent location here, to allow to share the results with moving avoidance.\n\t\t\tconst FNavigationObstacleHashGrid2D& ObstacleGrid = NavigationSubsystem->GetObstacleGridMutable();\n\t\t\tUE::MassAvoidance::FindCloseObstacles(AgentLocation, StandingParams.GhostObstacleDetectionDistance, ObstacleGrid, CloseEntities, UE::MassAvoidance::MaxObstacleResults);\n\n\t\t\t// Remove unwanted and find the closest in the CloseEntities\n\t\t\tconst FVector::FReal DistanceCutOffSqr = FMath::Square(StandingParams.GhostObstacleDetectionDistance);\n\t\t\tClosestObstacles.Reset();\n\t\t\tfor (const FNavigationObstacleHashGrid2D::ItemIDType OtherEntity : CloseEntities)\n\t\t\t{\n\t\t\t\t// Skip self\n\t\t\t\tif (OtherEntity.Entity == Entity)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Skip invalid entities.\n\t\t\t\tif (!EntityManager.IsEntityValid(OtherEntity.Entity))\n\t\t\t\t{\n\t\t\t\t\tUE_LOG(LogAvoidanceObstacles, VeryVerbose, TEXT(\"Close entity is invalid, skipped.\"));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Skip too far\n\t\t\t\tconst FTransformFragment& OtherTransform = EntityManager.GetFragmentDataChecked<FTransformFragment>(OtherEntity.Entity);\n\t\t\t\tconst FVector OtherLocation = OtherTransform.GetTransform().GetLocation();\n\t\t\t\tconst FVector::FReal DistSq = FVector::DistSquared(AgentLocation, OtherLocation);\n\t\t\t\tif (DistSq > DistanceCutOffSqr)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tClosestObstacles.Emplace(OtherEntity.Entity, OtherLocation, OtherTransform.GetTransform().GetRotation().GetForwardVector(), DistSq);\n\t\t\t}\n\t\t\tClosestObstacles.Sort([](const FSortedObstacle& A, const FSortedObstacle& B) { return A.DistSq < B.DistSq; });\n\n\t\t\tconst FVector::FReal GhostRadius = AgentRadius * StandingParams.GhostSeparationRadiusScale;\n\t\t\t\n\t\t\t// Compute forces\n\t\t\tconstexpr int32 MaxCloseObstacleTreated = 6;\n\t\t\tconst int32 NumCloseObstacles = FMath::Min(ClosestObstacles.Num(), MaxCloseObstacleTreated);\n\t\t\tfor (int32 Index = 0; Index < NumCloseObstacles; Index++)\n\t\t\t{\n\t\t\t\tFSortedObstacle& OtherAgent = ClosestObstacles[Index];\n\t\t\t\tFMassEntityView OtherEntityView(EntityManager, OtherAgent.Entity);\n\n\t\t\t\tconst FVector::FReal OtherRadius = OtherEntityView.GetFragmentData<FAgentRadiusFragment>().Radius;\n\t\t\t\tconst FVector::FReal TotalRadius = GhostRadius + OtherRadius;\n\n\t\t\t\t// @todo: this is heavy fragment to access, see if we could handle this differently.\n\t\t\t\tconst FMassMoveTargetFragment* OtherMoveTarget = OtherEntityView.GetFragmentDataPtr<FMassMoveTargetFragment>();\n\t\t\t\tconst FMassGhostLocationFragment* OtherGhost = OtherEntityView.GetFragmentDataPtr<FMassGhostLocationFragment>();\n\n\t\t\t\tconst bool bOtherHasGhost = OtherMoveTarget != nullptr && OtherGhost != nullptr\n\t\t\t\t\t\t\t\t\t\t\t&& OtherMoveTarget->GetCurrentAction() == EMassMovementAction::Stand\n\t\t\t\t\t\t\t\t\t\t\t&& OtherGhost->IsValid(OtherMoveTarget->GetCurrentActionID());\n\n\t\t\t\t// If other has ghost active, avoid that, else avoid the actual agent.\n\t\t\t\tif (bOtherHasGhost)\n\t\t\t\t{\n\t\t\t\t\t// Avoid the other agent more, when it is further away from it's goal location.\n\t\t\t\t\tconst FVector::FReal OtherDistanceToGoal = FVector::Distance(OtherGhost->Location, OtherMoveTarget->Center);\n\t\t\t\t\tconst FVector::FReal OtherSteerFade = FMath::Clamp(OtherDistanceToGoal / StandingParams.GhostToTargetMaxDeviation, 0., 1.);\n\t\t\t\t\tconst FVector::FReal SeparationStiffness = FMath::Lerp(GhostSeparationStiffness, MovingSeparationStiffness, OtherSteerFade);\n\n\t\t\t\t\t// Ghost separation\n\t\t\t\t\tFVector RelPos = Ghost.Location - OtherGhost->Location;\n\t\t\t\t\tRelPos.Z = 0.; // we assume we work on a flat plane for now\n\t\t\t\t\tconst FVector::FReal ConDist = RelPos.Size();\n\t\t\t\t\tconst FVector ConNorm = ConDist > 0. ? RelPos / ConDist : FVector::ForwardVector;\n\n\t\t\t\t\t// Separation force (stay away from obstacles if possible)\n\t\t\t\t\tconst FVector::FReal PenSep = (TotalRadius + GhostSeparationDistance) - ConDist;\n\t\t\t\t\tconst FVector::FReal SeparationMag = UE::MassNavigation::Smooth(FMath::Clamp(PenSep / GhostSeparationDistance, 0., 1.));\n\t\t\t\t\tconst FVector SeparationForce = ConNorm * SeparationStiffness * SeparationMag;\n\n\t\t\t\t\tGhostSteeringForce += SeparationForce;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Avoid more when the avoidance other is in front,\n\t\t\t\t\tconst FVector DirToOther = (OtherAgent.Location - Ghost.Location).GetSafeNormal();\n\t\t\t\t\tconst FVector::FReal DirectionalFade = FMath::Square(FMath::Max(0., FVector::DotProduct(MoveTarget.Forward, DirToOther)));\n\t\t\t\t\tconst FVector::FReal DirectionScale = FMath::Lerp(StandingParams.MovingObstacleDirectionalScale, 1., DirectionalFade);\n\n\t\t\t\t\t// Treat the other agent as a 2D capsule protruding towards forward.\n \t\t\t\t\tconst FVector OtherBasePosition = OtherAgent.Location;\n\t\t\t\t\tconst FVector OtherPersonalSpacePosition = OtherAgent.Location + OtherAgent.Forward * OtherRadius * StandingParams.MovingObstaclePersonalSpaceScale * DirectionScale;\n\t\t\t\t\tconst FVector OtherLocation = FMath::ClosestPointOnSegment(Ghost.Location, OtherBasePosition, OtherPersonalSpacePosition);\n\n\t\t\t\t\tFVector RelPos = Ghost.Location - OtherLocation;\n\t\t\t\t\tRelPos.Z = 0.;\n\t\t\t\t\tconst FVector::FReal ConDist = RelPos.Size();\n\t\t\t\t\tconst FVector ConNorm = ConDist > 0. ? RelPos / ConDist : FVector::ForwardVector;\n\n\t\t\t\t\t// Separation force (stay away from obstacles if possible)\n\t\t\t\t\tconst FVector::FReal PenSep = (TotalRadius + MovingSeparationDistance) - ConDist;\n\t\t\t\t\tconst FVector::FReal SeparationMag = UE::MassNavigation::Smooth(FMath::Clamp(PenSep / MovingSeparationDistance, 0., 1.));\n\t\t\t\t\tconst FVector SeparationForce = ConNorm * MovingSeparationStiffness * SeparationMag;\n\n\t\t\t\t\tGhostSteeringForce += SeparationForce;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tGhostSteeringForce.Z = 0.;\n\t\t\tGhostSteeringForce = UE::MassNavigation::ClampVector(GhostSteeringForce, StandingParams.GhostMaxAcceleration); // Assume unit mass\n\t\t\tGhost.Velocity += GhostSteeringForce * DeltaTime;\n\t\t\tGhost.Velocity.Z = 0.;\n\t\t\t\n\t\t\t// Damping\n\t\t\tFMath::ExponentialSmoothingApprox(Ghost.Velocity, FVector::ZeroVector, DeltaTime, StandingParams.GhostVelocityDampingTime);\n\t\t\t\n\t\t\tGhost.Location += Ghost.Velocity * DeltaTime;\n\n\t\t\t// Dont let the ghost location too far from move target center.\n\t\t\tconst FVector DirToCenter = Ghost.Location - MoveTarget.Center;\n\t\t\tconst FVector::FReal DistToCenter = DirToCenter.Length();\n\t\t\tif (DistToCenter > StandingParams.GhostToTargetMaxDeviation)\n\t\t\t{\n\t\t\t\tGhost.Location = MoveTarget.Center + DirToCenter * (StandingParams.GhostToTargetMaxDeviation / DistToCenter);\n\t\t\t}\n\t\t}\n\t});\n\t\n}\n\n#undef UNSAFE_FOR_MT\n",
      "lines": 1254
    },
    {
      "file_path": "MassAI\\MassNavigation\\Private\\MassAvoidanceTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 1432,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Avoidance/MassAvoidanceTrait.h\"\n#include \"Avoidance/MassAvoidanceFragments.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassNavigationFragments.h\"\n#include \"Engine/World.h\"\n#include \"MassEntityUtils.h\"\n\n\nvoid UMassObstacleAvoidanceTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tFMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(World);\n\n\tBuildContext.RequireFragment<FAgentRadiusFragment>();\n\tBuildContext.AddFragment<FMassNavigationEdgesFragment>();\n\tBuildContext.RequireFragment<FTransformFragment>();\n\tBuildContext.RequireFragment<FMassVelocityFragment>();\n\tBuildContext.RequireFragment<FMassForceFragment>();\n\tBuildContext.RequireFragment<FMassMoveTargetFragment>();\n\n\tconst FMassMovingAvoidanceParameters MovingValidated = MovingParameters.GetValidated();\n\tconst FConstSharedStruct MovingFragment = EntityManager.GetOrCreateConstSharedFragment(MovingValidated);\n\tBuildContext.AddConstSharedFragment(MovingFragment);\n\n\tconst FMassStandingAvoidanceParameters StandingValidated = StandingParameters.GetValidated();\n\tconst FConstSharedStruct StandingFragment = EntityManager.GetOrCreateConstSharedFragment(StandingValidated);\n\tBuildContext.AddConstSharedFragment(StandingFragment);\n}\n",
      "lines": 31
    },
    {
      "file_path": "MassAI\\MassNavigation\\Private\\MassNavigationFragments.cpp",
      "extension": ".cpp",
      "size_bytes": 1383,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassNavigationFragments.h\"\n#include \"GameFramework/GameStateBase.h\"\n#include \"Engine/World.h\"\n\nvoid FMassMoveTargetFragment::CreateNewAction(const EMassMovementAction InAction, const UWorld& InWorld)\n{\n\tensureMsgf(InWorld.GetNetMode() != NM_Client, TEXT(\"This version of SetDesiredAction should only be called on the authority.\"));\n\tCurrentAction = InAction;\n\tCurrentActionID++;\n\tCurrentActionWorldStartTime = InWorld.TimeSeconds;\n\n\tconst AGameStateBase* GameState = InWorld.GetGameState();\n\tCurrentActionServerStartTime = GameState != nullptr ? GameState->GetServerWorldTimeSeconds() : CurrentActionWorldStartTime;\n\n\tMarkNetDirty();\n}\n\nvoid FMassMoveTargetFragment::CreateReplicatedAction(const EMassMovementAction InAction, const uint16 InActionID, const double InWorldStartTime, const double InServerStartTime)\n{\n\tCurrentAction = InAction;\n\tCurrentActionID = InActionID;\n\tCurrentActionWorldStartTime = InWorldStartTime;\n\tCurrentActionServerStartTime = InServerStartTime;\n}\n\nFString FMassMoveTargetFragment::ToString() const\n{\n\treturn FString::Printf(TEXT(\"ActionID:%d Action:%s StartTime: World:%.1f Server:%.1f DesiredSpeed:%.1f \"),\n\t\tCurrentActionID,\n\t\t*UEnum::GetValueAsString(CurrentAction),\n\t\tCurrentActionWorldStartTime,\n\t\tCurrentActionServerStartTime,\n\t\tDesiredSpeed.Get());\n}",
      "lines": 36
    },
    {
      "file_path": "MassAI\\MassNavigation\\Private\\MassNavigationModule.cpp",
      "extension": ".cpp",
      "size_bytes": 823,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CoreMinimal.h\"\n#include \"IMassNavigationModule.h\"\n#include \"UObject/CoreRedirects.h\"\n\n\nclass FMassNavigationModule : public IMassNavigationModule\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nIMPLEMENT_MODULE(FMassNavigationModule, MassNavigation)\n\n\nvoid FMassNavigationModule::StartupModule()\n{\n\t// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)\n}\n\n\nvoid FMassNavigationModule::ShutdownModule()\n{\n\t// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n\t// we call this function before unloading the module.\n}\n\n\n\n",
      "lines": 31
    },
    {
      "file_path": "MassAI\\MassNavigation\\Private\\MassNavigationObstacleTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 486,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n#include \"Avoidance/MassNavigationObstacleTrait.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"MassNavigationFragments.h\"\n#include \"MassCommonFragments.h\"\n\nvoid UMassNavigationObstacleTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tBuildContext.RequireFragment<FAgentRadiusFragment>();\n\n\tBuildContext.AddFragment<FMassNavigationObstacleGridCellLocationFragment>();\n}\n",
      "lines": 12
    },
    {
      "file_path": "MassAI\\MassNavigation\\Private\\MassNavigationProcessors.cpp",
      "extension": ".cpp",
      "size_bytes": 15248,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassNavigationProcessors.h\"\n#include \"MassCommonUtils.h\"\n#include \"MassCommandBuffer.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassNavigationFragments.h\"\n#include \"MassNavigationSubsystem.h\"\n#include \"MassSimulationLOD.h\"\n#include \"MassMovementTypes.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassEntityView.h\"\n#include \"MassExecutionContext.h\"\n#include \"Engine/World.h\"\n\n\n#define UNSAFE_FOR_MT 0\n#define MOVEMENT_DEBUGDRAW 0\t// Set to 1 to see heading debugdraw\n\n//----------------------------------------------------------------------//\n//  UMassOffLODNavigationProcessor\n//----------------------------------------------------------------------//\n\nUMassOffLODNavigationProcessor::UMassOffLODNavigationProcessor()\n\t: EntityQuery_Conditional(*this)\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Movement;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Avoidance); // @todo: remove this direct dependency\n}\n\nvoid UMassOffLODNavigationProcessor::ConfigureQueries()\n{\n\tEntityQuery_Conditional.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery_Conditional.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery_Conditional.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::All);\n\tEntityQuery_Conditional.AddChunkRequirement<FMassSimulationVariableTickChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tEntityQuery_Conditional.SetChunkFilter(&FMassSimulationVariableTickChunkFragment::ShouldTickChunkThisFrame);\n}\n\nvoid UMassOffLODNavigationProcessor::Execute(FMassEntityManager& EntityManager,\n\t\t\t\t\t\t\t\t\t\t\t\t\tFMassExecutionContext& Context)\n{\n\tEntityQuery_Conditional.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\tif (UE::MassMovement::bFreezeMovement)\n\t\t{\n\t\t\treturn;\n\t\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\n\t\tconst TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();\n\t\tconst TConstArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetFragmentView<FMassMoveTargetFragment>();\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tFTransform& CurrentTransform = LocationList[EntityIndex].GetMutableTransform();\n\t\t\tconst FMassMoveTargetFragment& MoveTarget = MoveTargetList[EntityIndex];\n\n\t\t\t// Snap position to move target directly\n\t\t\tCurrentTransform.SetLocation(MoveTarget.Center);\n\t\t}\n\t});\n}\n\n\n//----------------------------------------------------------------------//\n//  UMassNavigationSmoothHeightProcessor\n//----------------------------------------------------------------------//\n\nUMassNavigationSmoothHeightProcessor::UMassNavigationSmoothHeightProcessor()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Movement);\n}\n\nvoid UMassNavigationSmoothHeightProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);\n\tEntityQuery.AddConstSharedRequirement<FMassMovementParameters>(EMassFragmentPresence::All);\n}\n\nvoid UMassNavigationSmoothHeightProcessor::Execute(FMassEntityManager& EntityManager,\n\t\t\t\t\t\t\t\t\t\t\t\t\tFMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\tif (UE::MassMovement::bFreezeMovement)\n\t\t{\n\t\t\treturn;\n\t\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tconst float DeltaTime = Context.GetDeltaTimeSeconds();\n\n\t\tconst FMassMovementParameters& MovementParams = Context.GetConstSharedFragment<FMassMovementParameters>();\n\t\tconst TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();\n\t\tconst TConstArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetFragmentView<FMassMoveTargetFragment>();\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tFTransform& CurrentTransform = LocationList[EntityIndex].GetMutableTransform();\n\t\t\tconst FMassMoveTargetFragment& MoveTarget = MoveTargetList[EntityIndex];\n\n\t\t\tif (MoveTarget.GetCurrentAction() == EMassMovementAction::Move || MoveTarget.GetCurrentAction() == EMassMovementAction::Stand)\n\t\t\t{\n\t\t\t\t// Set height smoothly to follow current move targets height.\n\t\t\t\tFVector CurrentLocation = CurrentTransform.GetLocation();\n\t\t\t\tFMath::ExponentialSmoothingApprox(CurrentLocation.Z, MoveTarget.Center.Z, DeltaTime, MovementParams.HeightSmoothingTime);\n\t\t\t\tCurrentTransform.SetLocation(CurrentLocation);\n\t\t\t}\n\t\t}\n\t});\n}\n\n//----------------------------------------------------------------------//\n//  UMassMoveTargetFragmentInitializer\n//----------------------------------------------------------------------//\n\nUMassMoveTargetFragmentInitializer::UMassMoveTargetFragmentInitializer()\n\t: InitializerQuery(*this)\n{\n\tObservedType = FMassMoveTargetFragment::StaticStruct();\n\tOperation = EMassObservedOperation::Add;\n}\n\nvoid UMassMoveTargetFragmentInitializer::ConfigureQueries()\n{\n\tInitializerQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadWrite);\n\tInitializerQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n}\n\nvoid UMassMoveTargetFragmentInitializer::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tInitializerQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)\n\t{\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tconst TArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetMutableFragmentView<FMassMoveTargetFragment>();\n\t\tconst TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tFMassMoveTargetFragment& MoveTarget = MoveTargetList[EntityIndex];\n\t\t\tconst FTransformFragment& Location = LocationList[EntityIndex];\n\n\t\t\tMoveTarget.Center = Location.GetTransform().GetLocation();\n\t\t\tMoveTarget.Forward = Location.GetTransform().GetRotation().Vector();\n\t\t\tMoveTarget.DistanceToGoal = 0.0f;\n\t\t\tMoveTarget.SlackRadius = 0.0f;\n\t\t}\n\t});\n}\n\n\n//----------------------------------------------------------------------//\n//  UMassNavigationObstacleGridProcessor\n//----------------------------------------------------------------------//\nUMassNavigationObstacleGridProcessor::UMassNavigationObstacleGridProcessor()\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Movement);\n}\n\nvoid UMassNavigationObstacleGridProcessor::ConfigureQueries()\n{\n\tFMassEntityQuery BaseEntityQuery;\n\tBaseEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tBaseEntityQuery.AddRequirement<FAgentRadiusFragment>(EMassFragmentAccess::ReadOnly);\n\tBaseEntityQuery.AddRequirement<FMassNavigationObstacleGridCellLocationFragment>(EMassFragmentAccess::ReadWrite);\n\tBaseEntityQuery.AddSubsystemRequirement<UMassNavigationSubsystem>(EMassFragmentAccess::ReadWrite);\n\n\tAddToGridEntityQuery = BaseEntityQuery;\n\tAddToGridEntityQuery.AddRequirement<FMassAvoidanceColliderFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tAddToGridEntityQuery.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);\n\tAddToGridEntityQuery.AddTagRequirement<FMassInNavigationObstacleGridTag>(EMassFragmentPresence::None);\n\tAddToGridEntityQuery.RegisterWithProcessor(*this);\n\n\tUpdateGridEntityQuery = BaseEntityQuery;\n\tUpdateGridEntityQuery.AddRequirement<FMassAvoidanceColliderFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tUpdateGridEntityQuery.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);\n\tUpdateGridEntityQuery.AddTagRequirement<FMassInNavigationObstacleGridTag>(EMassFragmentPresence::All);\n\tUpdateGridEntityQuery.RegisterWithProcessor(*this);\n\n\tRemoveFromGridEntityQuery = BaseEntityQuery;\n\tRemoveFromGridEntityQuery.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::All);\n\tRemoveFromGridEntityQuery.AddTagRequirement<FMassInNavigationObstacleGridTag>(EMassFragmentPresence::All);\n\tRemoveFromGridEntityQuery.RegisterWithProcessor(*this);\n}\n\nvoid UMassNavigationObstacleGridProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\t// can't be ParallelFor due to MovementSubsystem->GetGridMutable().Move not being thread-safe\n\tAddToGridEntityQuery.ForEachEntityChunk(EntityManager, Context, [this, &EntityManager](FMassExecutionContext& Context)\n\t{\n\t\tFNavigationObstacleHashGrid2D& HashGrid = Context.GetMutableSubsystemChecked<UMassNavigationSubsystem>().GetObstacleGridMutable();\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\n\t\tTConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\t\tTConstArrayView<FAgentRadiusFragment> RadiiList = Context.GetFragmentView<FAgentRadiusFragment>();\n\t\tTArrayView<FMassNavigationObstacleGridCellLocationFragment> NavigationObstacleCellLocationList = Context.GetMutableFragmentView<FMassNavigationObstacleGridCellLocationFragment>();\n\t\tconst bool bHasColliderData = Context.GetFragmentView<FMassAvoidanceColliderFragment>().Num() > 0;\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\t// Add to the grid\n\t\t\tconst FVector NewPos = LocationList[EntityIndex].GetTransform().GetLocation();\n\t\t\tconst float Radius = RadiiList[EntityIndex].Radius;\n\n\t\t\tFMassNavigationObstacleItem ObstacleItem;\n\t\t\tObstacleItem.Entity = Context.GetEntity(EntityIndex);\n\t\t\tObstacleItem.ItemFlags |= bHasColliderData ? EMassNavigationObstacleFlags::HasColliderData : EMassNavigationObstacleFlags::None;\n\t\t\t\n\t\t\tconst FBox NewBounds(NewPos - FVector(Radius, Radius, 0.f), NewPos + FVector(Radius, Radius, 0.f));\n\t\t\tNavigationObstacleCellLocationList[EntityIndex].CellLoc = HashGrid.Add(ObstacleItem, NewBounds);\n\n\t\t\tContext.Defer().AddTag<FMassInNavigationObstacleGridTag>(ObstacleItem.Entity);\n\t\t}\n\t});\n\n\tUpdateGridEntityQuery.ForEachEntityChunk(EntityManager, Context, [this, &EntityManager](FMassExecutionContext& Context)\n\t{\n\t\tFNavigationObstacleHashGrid2D& HashGrid = Context.GetMutableSubsystemChecked<UMassNavigationSubsystem>().GetObstacleGridMutable();\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\n\t\tTConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\t\tTConstArrayView<FAgentRadiusFragment> RadiiList = Context.GetFragmentView<FAgentRadiusFragment>();\n\t\tTArrayView<FMassNavigationObstacleGridCellLocationFragment> NavigationObstacleCellLocationList = Context.GetMutableFragmentView<FMassNavigationObstacleGridCellLocationFragment>();\n\t\tconst bool bHasColliderData = Context.GetFragmentView<FMassAvoidanceColliderFragment>().Num() > 0;\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\t// Update position in grid\n\t\t\tconst FVector NewPos = LocationList[EntityIndex].GetTransform().GetLocation();\n\t\t\tconst float Radius = RadiiList[EntityIndex].Radius;\n\t\t\tFMassNavigationObstacleItem ObstacleItem;\n\t\t\tObstacleItem.Entity = Context.GetEntity(EntityIndex);\n\t\t\tObstacleItem.ItemFlags |= bHasColliderData ? EMassNavigationObstacleFlags::HasColliderData : EMassNavigationObstacleFlags::None;\n\n\t\t\tconst FBox NewBounds(NewPos - FVector(Radius, Radius, 0.f), NewPos + FVector(Radius, Radius, 0.f));\n\t\t\tNavigationObstacleCellLocationList[EntityIndex].CellLoc = HashGrid.Move(ObstacleItem, NavigationObstacleCellLocationList[EntityIndex].CellLoc, NewBounds);\n\n#if WITH_MASSGAMEPLAY_DEBUG && 0\n\t\t\tconst FDebugContext BaseDebugContext(this, LogAvoidance, nullptr, ObstacleItem.Entity);\n\t\t\tif (DebugIsSelected(ObstacleItem.Entity))\n\t\t\t{\n\t\t\t\tFBox Box = MovementSubsystem->GetGridMutable().CalcCellBounds(AvoidanceObstacleCellLocationList[EntityIndex].CellLoc);\n\t\t\t\tBox.Max.Z += 200.f;\n\t\t\t\tDebugDrawBox(BaseDebugContext, Box, FColor::Yellow);\n\t\t\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t\t}\n\t});\n\n\tRemoveFromGridEntityQuery.ForEachEntityChunk(EntityManager, Context, [this, &EntityManager](FMassExecutionContext& Context)\n\t{\n\t\tFNavigationObstacleHashGrid2D& HashGrid = Context.GetMutableSubsystemChecked<UMassNavigationSubsystem>().GetObstacleGridMutable();\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\n\t\tTArrayView<FMassNavigationObstacleGridCellLocationFragment> AvoidanceObstacleCellLocationList = Context.GetMutableFragmentView<FMassNavigationObstacleGridCellLocationFragment>();\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tFMassNavigationObstacleItem ObstacleItem;\n\t\t\tObstacleItem.Entity = Context.GetEntity(EntityIndex);\n\t\t\tHashGrid.Remove(ObstacleItem, AvoidanceObstacleCellLocationList[EntityIndex].CellLoc);\n\t\t\tAvoidanceObstacleCellLocationList[EntityIndex].CellLoc = FNavigationObstacleHashGrid2D::FCellLocation();\n\n\t\t\tContext.Defer().RemoveTag<FMassInNavigationObstacleGridTag>(ObstacleItem.Entity);\n\t\t}\n\t});\n}\n\n//----------------------------------------------------------------------//\n//  UMassNavigationObstacleRemoverProcessor\n//----------------------------------------------------------------------//\nUMassNavigationObstacleRemoverProcessor::UMassNavigationObstacleRemoverProcessor()\n\t: EntityQuery(*this)\n{\n\tObservedType = FMassNavigationObstacleGridCellLocationFragment::StaticStruct();\n\tOperation = EMassObservedOperation::Remove;\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n}\n\nvoid UMassNavigationObstacleRemoverProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassNavigationObstacleGridCellLocationFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddSubsystemRequirement<UMassNavigationSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassNavigationObstacleRemoverProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tFNavigationObstacleHashGrid2D& HashGrid = Context.GetMutableSubsystemChecked<UMassNavigationSubsystem>().GetObstacleGridMutable();\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tconst TArrayView<FMassNavigationObstacleGridCellLocationFragment> AvoidanceObstacleCellLocationList = Context.GetMutableFragmentView<FMassNavigationObstacleGridCellLocationFragment>();\n\n\t\tfor (int32 i = 0; i < NumEntities; ++i)\n\t\t{\n\t\t\tFMassNavigationObstacleItem ObstacleItem;\n\t\t\tObstacleItem.Entity = Context.GetEntity(i);\n\t\t\tHashGrid.Remove(ObstacleItem, AvoidanceObstacleCellLocationList[i].CellLoc);\n\t\t}\n\t});\n}\n\n#undef UNSAFE_FOR_MT\n",
      "lines": 312
    },
    {
      "file_path": "MassAI\\MassNavigation\\Private\\MassNavigationSubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 633,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassNavigationSubsystem.h\"\n#include \"Engine/World.h\"\n#include \"MassSimulationSubsystem.h\"\n\n//----------------------------------------------------------------------//\n// UMassNavigationSubsystem\n//----------------------------------------------------------------------//\nUMassNavigationSubsystem::UMassNavigationSubsystem()\n\t: AvoidanceObstacleGrid(250.f) // 2.5m grid\n{\n}\n\nvoid UMassNavigationSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tSuper::Initialize(Collection);\n\tCollection.InitializeDependency<UMassSimulationSubsystem>();\n}\n\n",
      "lines": 20
    },
    {
      "file_path": "MassAI\\MassNavigation\\Private\\MassNavigationTypes.cpp",
      "extension": ".cpp",
      "size_bytes": 180,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassNavigationTypes.h\"\n\nDEFINE_LOG_CATEGORY(LogMassNavigation);\nDEFINE_LOG_CATEGORY(LogMassNavigationObstacle);\n",
      "lines": 6
    },
    {
      "file_path": "MassAI\\MassNavigation\\Private\\MassSmoothOrientationProcessors.cpp",
      "extension": ".cpp",
      "size_bytes": 6707,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"SmoothOrientation/MassSmoothOrientationProcessors.h\"\n#include \"SmoothOrientation/MassSmoothOrientationFragments.h\"\n#include \"MassCommandBuffer.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassNavigationFragments.h\"\n#include \"MassMovementFragments.h\"\n#include \"Math/UnrealMathUtility.h\"\n#include \"MassSimulationLOD.h\"\n#include \"MassNavigationUtils.h\"\n\n#define UNSAFE_FOR_MT 0\n#define MOVEMENT_DEBUGDRAW 0\t// Set to 1 to see heading debugdraw\n\n//----------------------------------------------------------------------//\n//  UMassSmoothOrientationProcessor\n//----------------------------------------------------------------------//\nUMassSmoothOrientationProcessor::UMassSmoothOrientationProcessor()\n\t: HighResEntityQuery(*this)\n\t, LowResEntityQuery_Conditional(*this)\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Movement;\n}\n\nvoid UMassSmoothOrientationProcessor::ConfigureQueries()\n{\n\tHighResEntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadOnly);\n\tHighResEntityQuery.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadWrite);\n\tHighResEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);\n\tHighResEntityQuery.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);\n\tHighResEntityQuery.AddConstSharedRequirement<FMassSmoothOrientationParameters>(EMassFragmentPresence::All);\n\n\tLowResEntityQuery_Conditional.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);\n\tLowResEntityQuery_Conditional.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadOnly);\n\tLowResEntityQuery_Conditional.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::All);\n\tLowResEntityQuery_Conditional.AddChunkRequirement<FMassSimulationVariableTickChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tLowResEntityQuery_Conditional.SetChunkFilter(&FMassSimulationVariableTickChunkFragment::ShouldTickChunkThisFrame);\n}\n\nvoid UMassSmoothOrientationProcessor::Execute(FMassEntityManager& EntityManager,\n\t\t\t\t\t\t\t\t\t\t\t\t\tFMassExecutionContext& Context)\n{\n\t// Clamp max delta time to avoid force explosion on large time steps (i.e. during initialization).\n\tconst float DeltaTime = FMath::Min(0.1f, Context.GetDeltaTimeSeconds());\n\n\t{\n\t\tQUICK_SCOPE_CYCLE_COUNTER(HighRes);\n\n\t\tHighResEntityQuery.ForEachEntityChunk(EntityManager, Context, [this, DeltaTime](FMassExecutionContext& Context)\n\t\t{\n\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\n\t\t\tconst FMassSmoothOrientationParameters& OrientationParams = Context.GetConstSharedFragment<FMassSmoothOrientationParameters>();\n\n\t\t\tconst TConstArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetFragmentView<FMassMoveTargetFragment>();\n\t\t\tconst TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();\n\t\t\tconst TArrayView<FMassVelocityFragment> VelocityList = Context.GetMutableFragmentView<FMassVelocityFragment>();\n\n\t\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t\t{\n\t\t\t\tconst FMassMoveTargetFragment& MoveTarget = MoveTargetList[EntityIndex];\n\n\t\t\t\t// Do not touch transform at all when animating\n\t\t\t\tif (MoveTarget.GetCurrentAction() == EMassMovementAction::Animate)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst FMassVelocityFragment& CurrentVelocity = VelocityList[EntityIndex];\n\t\t\t\tFTransform& CurrentTransform = LocationList[EntityIndex].GetMutableTransform();\n\t\t\t\tconst FVector CurrentForward = CurrentTransform.GetRotation().GetForwardVector();\n\t\t\t\tconst FVector::FReal CurrentHeading = UE::MassNavigation::GetYawFromDirection(CurrentForward);\n\n\t\t\t\tconst float EndOfPathAnticipationDistance = OrientationParams.EndOfPathDuration * MoveTarget.DesiredSpeed.Get();\n\t\t\t\t\n\t\t\t\tFVector::FReal MoveTargetWeight = 0.5;\n\t\t\t\tFVector::FReal VelocityWeight = 0.5;\n\t\t\t\t\n\t\t\t\tif (MoveTarget.GetCurrentAction() == EMassMovementAction::Move)\n\t\t\t\t{\n\t\t\t\t\tif (MoveTarget.IntentAtGoal == EMassMovementAction::Stand && MoveTarget.DistanceToGoal < EndOfPathAnticipationDistance)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Fade towards the movement target direction at the end of the path.\n\t\t\t\t\t\tconst float Fade = FMath::Square(FMath::Clamp(MoveTarget.DistanceToGoal / EndOfPathAnticipationDistance, 0.0f, 1.0f)); // zero at end of the path\n\n\t\t\t\t\t\tMoveTargetWeight = FMath::Lerp(OrientationParams.Standing.MoveTargetWeight, OrientationParams.Moving.MoveTargetWeight, Fade);\n\t\t\t\t\t\tVelocityWeight = FMath::Lerp(OrientationParams.Standing.VelocityWeight, OrientationParams.Moving.VelocityWeight, Fade);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tMoveTargetWeight = OrientationParams.Moving.MoveTargetWeight;\n\t\t\t\t\t\tVelocityWeight = OrientationParams.Moving.VelocityWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse // Stand\n\t\t\t\t{\n\t\t\t\t\tMoveTargetWeight = OrientationParams.Standing.MoveTargetWeight;\n\t\t\t\t\tVelocityWeight = OrientationParams.Standing.VelocityWeight;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconst FVector::FReal VelocityHeading = UE::MassNavigation::GetYawFromDirection(CurrentVelocity.Value);\n\t\t\t\tconst FVector::FReal MovementHeading = UE::MassNavigation::GetYawFromDirection(MoveTarget.Forward);\n\n\t\t\t\tconst FVector::FReal Ratio = MoveTargetWeight / (MoveTargetWeight + VelocityWeight);\n\t\t\t\tconst FVector::FReal DesiredHeading = UE::MassNavigation::LerpAngle(VelocityHeading, MovementHeading,Ratio);\n\t\t\t\t\n\t\t\t\tconst FVector::FReal NewHeading = UE::MassNavigation::ExponentialSmoothingAngle(CurrentHeading, DesiredHeading, DeltaTime, OrientationParams.OrientationSmoothingTime);\n\n\t\t\t\tFQuat Rotation(FVector::UpVector, NewHeading);\n\t\t\t\tCurrentTransform.SetRotation(Rotation);\n\t\t\t}\n\t\t});\n\t}\n\n\t{\n\t\tQUICK_SCOPE_CYCLE_COUNTER(LowRes);\n\n\t\tLowResEntityQuery_Conditional.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t\t{\n\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\n\t\t\tconst TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();\n\t\t\tconst TConstArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetFragmentView<FMassMoveTargetFragment>();\n\n\t\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t\t{\n\t\t\t\tFTransform& CurrentTransform = LocationList[EntityIndex].GetMutableTransform();\n\t\t\t\tconst FMassMoveTargetFragment& MoveTarget = MoveTargetList[EntityIndex];\n\n\t\t\t\t// Snap position to move target directly\n\t\t\t\tCurrentTransform.SetRotation(FQuat::FindBetweenNormals(FVector::ForwardVector, MoveTarget.Forward));\n\t\t\t}\n\t\t});\n\t}\n}\n\n#undef UNSAFE_FOR_MT\n",
      "lines": 140
    },
    {
      "file_path": "MassAI\\MassNavigation\\Private\\MassSmoothOrientationTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 879,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n#include \"SmoothOrientation/MassSmoothOrientationTrait.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassNavigationFragments.h\"\n#include \"Engine/World.h\"\n#include \"MassEntityUtils.h\"\n\n\nvoid UMassSmoothOrientationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tFMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(World);\n\n\tBuildContext.RequireFragment<FMassMoveTargetFragment>();\n\tBuildContext.RequireFragment<FMassVelocityFragment>();\n\tBuildContext.RequireFragment<FTransformFragment>();\n\n\tconst FConstSharedStruct OrientationFragment = EntityManager.GetOrCreateConstSharedFragment(Orientation);\n\tBuildContext.AddConstSharedFragment(OrientationFragment);\n}\n",
      "lines": 21
    },
    {
      "file_path": "MassAI\\MassNavigation\\Private\\MassSteeringProcessors.cpp",
      "extension": ".cpp",
      "size_bytes": 17219,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Steering/MassSteeringProcessors.h\"\n#include \"MassCommonUtils.h\"\n#include \"MassCommandBuffer.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassNavigationFragments.h\"\n#include \"Steering/MassSteeringFragments.h\"\n#include \"Math/UnrealMathUtility.h\"\n#include \"MassSimulationLOD.h\"\n\n#define UNSAFE_FOR_MT 0\n#define MOVEMENT_DEBUGDRAW 0\t// Set to 1 to see heading debugdraw\n\nnamespace UE::MassNavigation\n{\n\t/*\n\t* Calculates speed scale based on agent's forward direction and desired steering direction.\n\t*/\n\tstatic FVector::FReal CalcDirectionalSpeedScale(const FVector ForwardDirection, const FVector SteerDirection)\n\t{\n\t\t// @todo: make these configurable\n\t\tconstexpr FVector::FReal ForwardSpeedScale = 1.;\n\t\tconstexpr FVector::FReal BackwardSpeedScale = 0.25;\n\t\tconstexpr FVector::FReal SideSpeedScale = 0.5;\n\n\t\tconst FVector LeftDirection = FVector::CrossProduct(ForwardDirection, FVector::UpVector);\n\t\tconst FVector::FReal DirX = FVector::DotProduct(LeftDirection, SteerDirection);\n\t\tconst FVector::FReal DirY = FVector::DotProduct(ForwardDirection, SteerDirection);\n\n\t\t// Calculate intersection between a direction vector and ellipse, where A & B are the size of the ellipse.\n\t\t// The direction vector is starting from the center of the ellipse.\n\t\tconstexpr FVector::FReal SideA = SideSpeedScale;\n\t\tconst FVector::FReal SideB = DirY > 0. ? ForwardSpeedScale : BackwardSpeedScale;\n\t\tconst FVector::FReal Disc = FMath::Square(SideA) * FMath::Square(DirY) + FMath::Square(SideB) * FMath::Square(DirX);\n\t\tconst FVector::FReal Speed = (Disc > SMALL_NUMBER) ? (SideA * SideB / FMath::Sqrt(Disc)) : 0.;\n\n\t\treturn Speed;\n\t}\n\n\t/** Speed envelope when approaching a point. NormalizedDistance in range [0..1] */\n\tstatic FVector::FReal ArrivalSpeedEnvelope(const FVector::FReal NormalizedDistance)\n\t{\n\t\treturn FMath::Sqrt(NormalizedDistance);\n\t}\n\n} // UE::MassNavigation\n\n//----------------------------------------------------------------------//\n//  UMassSteerToMoveTargetProcessor\n//----------------------------------------------------------------------//\nUMassSteerToMoveTargetProcessor::UMassSteerToMoveTargetProcessor()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = int32(EProcessorExecutionFlags::AllNetModes);\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Tasks);\n\tExecutionOrder.ExecuteBefore.Add(UE::Mass::ProcessorGroupNames::Avoidance);\n}\n\nvoid UMassSteerToMoveTargetProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassSteeringFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassStandingSteeringFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassGhostLocationFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassForceFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddConstSharedRequirement<FMassMovementParameters>(EMassFragmentPresence::All);\n\tEntityQuery.AddConstSharedRequirement<FMassMovingSteeringParameters>(EMassFragmentPresence::All);\n\tEntityQuery.AddConstSharedRequirement<FMassStandingSteeringParameters>(EMassFragmentPresence::All);\n\n\t// No need for Off LOD to do steering, applying move target directly\n\tEntityQuery.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);\n}\n\nvoid UMassSteerToMoveTargetProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tconst TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();\n\t\tconst TArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetMutableFragmentView<FMassMoveTargetFragment>();\n\t\tconst TArrayView<FMassVelocityFragment> VelocityList = Context.GetMutableFragmentView<FMassVelocityFragment>();\n\t\tconst TArrayView<FMassForceFragment> ForceList = Context.GetMutableFragmentView<FMassForceFragment>();\n\t\tconst TArrayView<FMassSteeringFragment> SteeringList = Context.GetMutableFragmentView<FMassSteeringFragment>();\n\t\tconst TArrayView<FMassStandingSteeringFragment> StandingSteeringList = Context.GetMutableFragmentView<FMassStandingSteeringFragment>();\n\t\tconst TArrayView<FMassGhostLocationFragment> GhostList = Context.GetMutableFragmentView<FMassGhostLocationFragment>();\n\t\tconst FMassMovementParameters& MovementParams = Context.GetConstSharedFragment<FMassMovementParameters>();\n\t\tconst FMassMovingSteeringParameters& MovingSteeringParams = Context.GetConstSharedFragment<FMassMovingSteeringParameters>();\n\t\tconst FMassStandingSteeringParameters& StandingSteeringParams = Context.GetConstSharedFragment<FMassStandingSteeringParameters>();\n\n\t\tconst FVector::FReal SteerK = 1. / MovingSteeringParams.ReactionTime;\n\t\tconst float DeltaTime = Context.GetDeltaTimeSeconds();\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tconst FTransformFragment& TransformFragment = TransformList[EntityIndex];\n\t\t\tFMassSteeringFragment& Steering = SteeringList[EntityIndex];\n\t\t\tFMassStandingSteeringFragment& StandingSteering = StandingSteeringList[EntityIndex];\n\t\t\tFMassGhostLocationFragment& Ghost = GhostList[EntityIndex];\n\t\t\tFMassMoveTargetFragment& MoveTarget = MoveTargetList[EntityIndex];\n\t\t\tFMassForceFragment& Force = ForceList[EntityIndex];\n\t\t\tFMassVelocityFragment& Velocity = VelocityList[EntityIndex];\n\t\t\tconst FMassEntityHandle Entity = Context.GetEntity(EntityIndex);\n\n\t\t\tconst FTransform& Transform = TransformFragment.GetTransform();;\n\n\t\t\t// Calculate velocity for steering.\n\t\t\tconst FVector CurrentLocation = Transform.GetLocation();\n\t\t\tconst FVector CurrentForward = Transform.GetRotation().GetForwardVector();\n\n\t\t\tconst FVector::FReal LookAheadDistance = FMath::Max(1.0f, MovingSteeringParams.LookAheadTime * MoveTarget.DesiredSpeed.Get());\n\n\t\t\tif (MoveTarget.GetCurrentAction() == EMassMovementAction::Move)\n\t\t\t{\n\t\t\t\t// Tune down avoidance and speed when arriving at goal.\n\t\t\t\tFVector::FReal ArrivalFade = 1.;\n\t\t\t\tif (MoveTarget.IntentAtGoal == EMassMovementAction::Stand)\n\t\t\t\t{\n\t\t\t\t\tArrivalFade = FMath::Clamp(MoveTarget.DistanceToGoal / LookAheadDistance, 0., 1.);\n\t\t\t\t}\n\t\t\t\tconst FVector::FReal SteeringPredictionDistance = LookAheadDistance * ArrivalFade;\n\n\t\t\t\t// Steer towards and along the move target.\n\t\t\t\tconst FVector TargetSide = FVector::CrossProduct(MoveTarget.Forward, FVector::UpVector);\n\t\t\t\tconst FVector Delta = CurrentLocation - MoveTarget.Center;\n\n\t\t\t\tconst FVector::FReal ForwardOffset = FVector::DotProduct(MoveTarget.Forward, Delta);\n\n\t\t\t\t// Calculate steering direction. When far away from the line defined by TargetPosition and TargetTangent,\n\t\t\t\t// the steering direction is towards the line, the close we get, the more it aligns with the line.\n\t\t\t\tconst FVector::FReal SidewaysOffset = FVector::DotProduct(TargetSide, Delta);\n\t\t\t\tconst FVector::FReal SteerForward = FMath::Sqrt(FMath::Max(0., FMath::Square(SteeringPredictionDistance) - FMath::Square(SidewaysOffset)));\n\n\t\t\t\t// The Max() here makes the steering directions behind the TargetPosition to steer towards it directly.\n\t\t\t\tFVector SteerTarget = MoveTarget.Center + MoveTarget.Forward * FMath::Clamp(ForwardOffset + SteerForward, 0., SteeringPredictionDistance);\n\n\t\t\t\tFVector SteerDirection = SteerTarget - CurrentLocation;\n\t\t\t\tSteerDirection.Z = 0.;\n\t\t\t\tconst FVector::FReal DistanceToSteerTarget = SteerDirection.Length();\n\t\t\t\tif (DistanceToSteerTarget > KINDA_SMALL_NUMBER)\n\t\t\t\t{\n\t\t\t\t\tSteerDirection *= 1. / DistanceToSteerTarget;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconst FVector::FReal DirSpeedScale = UE::MassNavigation::CalcDirectionalSpeedScale(CurrentForward, SteerDirection);\n\t\t\t\tFVector::FReal DesiredSpeed = MoveTarget.DesiredSpeed.Get() * DirSpeedScale;\n\n\t\t\t\t// Control speed based relation to the forward axis of the move target.\n\t\t\t\tFVector::FReal CatchupDesiredSpeed = DesiredSpeed;\n\t\t\t\tif (ForwardOffset < 0.)\n\t\t\t\t{\n\t\t\t\t\t// Falling behind, catch up\n\t\t\t\t\tconst FVector::FReal T = FMath::Min(-ForwardOffset / LookAheadDistance, 1.);\n\t\t\t\t\tCatchupDesiredSpeed = FMath::Lerp(DesiredSpeed, MovementParams.MaxSpeed, T);\n\t\t\t\t}\n\t\t\t\telse if (ForwardOffset > 0.)\n\t\t\t\t{\n\t\t\t\t\t// Ahead, slow down.\n\t\t\t\t\tconst FVector::FReal T = FMath::Min(ForwardOffset / LookAheadDistance, 1.);\n\t\t\t\t\tCatchupDesiredSpeed = FMath::Lerp(DesiredSpeed, DesiredSpeed * 0., 1. - FMath::Square(1. - T));\n\t\t\t\t}\n\n\t\t\t\t// Control speed based on distance to move target. This allows to catch up even if speed above reaches zero.\n\t\t\t\tconst FVector::FReal DeviantSpeed = FMath::Min(FMath::Abs(SidewaysOffset) / LookAheadDistance, 1.) * DesiredSpeed;\n\n\t\t\t\tDesiredSpeed = FMath::Max(CatchupDesiredSpeed, DeviantSpeed);\n\n\t\t\t\t// Slow down towards the end of path.\n\t\t\t\tif (MoveTarget.IntentAtGoal == EMassMovementAction::Stand)\n\t\t\t\t{\n\t\t\t\t\tconst FVector::FReal NormalizedDistanceToSteerTarget = FMath::Clamp(DistanceToSteerTarget / LookAheadDistance, 0., 1.);\n\t\t\t\t\tDesiredSpeed *= UE::MassNavigation::ArrivalSpeedEnvelope(FMath::Max(ArrivalFade, NormalizedDistanceToSteerTarget));\n\t\t\t\t}\n\n\t\t\t\tMoveTarget.bSteeringFallingBehind = ForwardOffset < -LookAheadDistance * 0.8;\n\n\t\t\t\t// @todo: This current completely overrides steering, we probably should have one processor that resets the steering at the beginning of the frame.\n\t\t\t\tSteering.DesiredVelocity = SteerDirection * DesiredSpeed;\n\t\t\t\tForce.Value = SteerK * (Steering.DesiredVelocity - Velocity.Value); // Goal force\n\t\t\t}\n\t\t\telse if (MoveTarget.GetCurrentAction() == EMassMovementAction::Stand)\n\t\t\t{\n\t\t\t\t// Calculate unique target move threshold so that different agents react a bit differently.\n\t\t\t\tconst FVector::FReal PerEntityScale = UE::RandomSequence::FRand(Entity.Index);\n\t\t\t\tconst FVector::FReal TargetMoveThreshold = StandingSteeringParams.TargetMoveThreshold * (1. - StandingSteeringParams.TargetMoveThresholdVariance + PerEntityScale * StandingSteeringParams.TargetMoveThresholdVariance * 2.);\n\t\t\t\t\n\t\t\t\tif (Ghost.LastSeenActionID != MoveTarget.GetCurrentActionID())\n\t\t\t\t{\n\t\t\t\t\t// Reset when action changes. @todo: should reset only when move->stand?\n\t\t\t\t\tGhost.Location = MoveTarget.Center;\n\t\t\t\t\tGhost.Velocity = FVector::ZeroVector;\n\t\t\t\t\tGhost.LastSeenActionID = MoveTarget.GetCurrentActionID();\n\n\t\t\t\t\tStandingSteering.TargetLocation = MoveTarget.Center;\n\t\t\t\t\tStandingSteering.TrackedTargetSpeed = 0.0f;\n\t\t\t\t\tStandingSteering.bIsUpdatingTarget = false;\n\t\t\t\t\tStandingSteering.TargetSelectionCooldown = StandingSteeringParams.TargetSelectionCooldown * FMath::RandRange(1.f - StandingSteeringParams.TargetSelectionCooldownVariance, 1.f + StandingSteeringParams.TargetSelectionCooldownVariance);\n\t\t\t\t\tStandingSteering.bEnteredFromMoveAction = MoveTarget.GetPreviousAction() == EMassMovementAction::Move;\n\t\t\t\t}\n\n\t\t\t\tStandingSteering.TargetSelectionCooldown = FMath::Max(0.0f, StandingSteering.TargetSelectionCooldown - DeltaTime);\n\n\t\t\t\tif (!StandingSteering.bIsUpdatingTarget)\n\t\t\t\t{\n\t\t\t\t\t// Update the move target if enough time has passed and the target has moved. \n\t\t\t\t\tif (StandingSteering.TargetSelectionCooldown <= 0.0f\n\t\t\t\t\t\t&& FVector::DistSquared(StandingSteering.TargetLocation, Ghost.Location) > FMath::Square(TargetMoveThreshold))\n\t\t\t\t\t{\n\t\t\t\t\t\tStandingSteering.TargetLocation = Ghost.Location;\n\t\t\t\t\t\tStandingSteering.TrackedTargetSpeed = 0.0f;\n\t\t\t\t\t\tStandingSteering.bIsUpdatingTarget = true;\n\t\t\t\t\t\tStandingSteering.bEnteredFromMoveAction = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Updating target\n\t\t\t\t\tStandingSteering.TargetLocation = Ghost.Location;\n\t\t\t\t\tconst FVector::FReal GhostSpeed = Ghost.Velocity.Length();\n\n\t\t\t\t\tif (GhostSpeed > (StandingSteering.TrackedTargetSpeed * StandingSteeringParams.TargetSpeedHysteresisScale))\n\t\t\t\t\t{\n\t\t\t\t\t\tconst FVector::FReal TrackedTargetSpeed = FMath::Max(StandingSteering.TrackedTargetSpeed, GhostSpeed);\n\t\t\t\t\t\tStandingSteering.TrackedTargetSpeed = static_cast<float>(TrackedTargetSpeed);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Speed is dropping, we have found the peak change, stop updating the target and start cooldown.\n\t\t\t\t\t\tStandingSteering.TargetSelectionCooldown = StandingSteeringParams.TargetSelectionCooldown * FMath::RandRange(1.0f - StandingSteeringParams.TargetSelectionCooldownVariance, 1.0f + StandingSteeringParams.TargetSelectionCooldownVariance);\n\t\t\t\t\t\tStandingSteering.bIsUpdatingTarget = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Move directly towards the move target when standing.\n\t\t\t\tFVector SteerDirection = FVector::ZeroVector;\n\t\t\t\tFVector::FReal DesiredSpeed = 0.;\n\n\t\t\t\tFVector Delta = StandingSteering.TargetLocation - CurrentLocation;\n\t\t\t\tDelta.Z = 0.;\n\t\t\t\tconst FVector::FReal Distance = Delta.Size();\n\t\t\t\tif (Distance > StandingSteeringParams.DeadZoneRadius)\n\t\t\t\t{\n\t\t\t\t\tSteerDirection = Delta / Distance;\n\t\t\t\t\tif (StandingSteering.bEnteredFromMoveAction)\n\t\t\t\t\t{\n\t\t\t\t\t\t// If the current steering target is from approaching a move target, use the same speed logic as movement to ensure smooth transition.\n\t\t\t\t\t\tconst FVector::FReal Range = FMath::Max(1., LookAheadDistance - StandingSteeringParams.DeadZoneRadius);\n\t\t\t\t\t\tconst FVector::FReal SpeedFade = FMath::Clamp((Distance - StandingSteeringParams.DeadZoneRadius) / Range, 0., 1.);\n\t\t\t\t\t\tDesiredSpeed = MoveTarget.DesiredSpeed.Get() * UE::MassNavigation::CalcDirectionalSpeedScale(CurrentForward, SteerDirection) * UE::MassNavigation::ArrivalSpeedEnvelope(SpeedFade);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tconst FVector::FReal Range = FMath::Max(1., LookAheadDistance - StandingSteeringParams.DeadZoneRadius);\n\t\t\t\t\t\tconst FVector::FReal SpeedFade = FMath::Clamp((Distance - StandingSteeringParams.DeadZoneRadius) / Range, 0., 1.);\n\t\t\t\t\t\t// Not using the directional scaling so that the steps we take to avoid are done quickly, and the behavior is reactive.\n\t\t\t\t\t\tDesiredSpeed = MoveTarget.DesiredSpeed.Get() * UE::MassNavigation::ArrivalSpeedEnvelope(SpeedFade);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// @todo: This current completely overrides steering, we probably should have one processor that resets the steering at the beginning of the frame.\n\t\t\t\t\tSteering.DesiredVelocity = SteerDirection * DesiredSpeed;\n\t\t\t\t\tForce.Value = SteerK * (Steering.DesiredVelocity - Velocity.Value); // Goal force\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// When reached destination, clamp small velocities to zero to avoid tiny drifting.\n\t\t\t\t\tif (Velocity.Value.SquaredLength() < FMath::Square(StandingSteeringParams.LowSpeedThreshold))\n\t\t\t\t\t{\n\t\t\t\t\t\tVelocity.Value = FVector::ZeroVector;\n\t\t\t\t\t\tForce.Value = FVector::ZeroVector;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tMoveTarget.bSteeringFallingBehind = false;\n\t\t\t}\n\t\t\telse if (MoveTarget.GetCurrentAction() == EMassMovementAction::Animate)\n\t\t\t{\n\t\t\t\t// Stop all movement when animating.\n\t\t\t\tSteering.Reset();\n\t\t\t\tMoveTarget.bSteeringFallingBehind = false;\n\t\t\t\tForce.Value = FVector::ZeroVector;\n\t\t\t\tVelocity.Value = FVector::ZeroVector;\n\t\t\t}\n\n#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT\n\t\t\tFColor EntityColor = FColor::White;\n\t\t\tconst bool bDisplayDebug = UE::Mass::Debug::IsDebuggingEntity(Entity, &EntityColor);\n\t\t\tif (bDisplayDebug)\n\t\t\t{\n\t\t\t\tconst FVector ZOffset(0,0,25);\n\n\t\t\t\tconst FColor DarkEntityColor = UE::MassNavigation::Debug::MixColors(EntityColor, FColor::Black);\n\t\t\t\tconst FColor LightEntityColor = UE::MassNavigation::Debug::MixColors(EntityColor, FColor::White);\n\t\t\t\t\n\t\t\t\tconst FVector MoveTargetCenter = MoveTarget.Center + ZOffset;\n\n\t\t\t\t// MoveTarget slack boundary\n\t\t\t\tUE_VLOG_CIRCLE_THICK(this, LogMassNavigation, Log, MoveTargetCenter, FVector::UpVector, LookAheadDistance, EntityColor, /*Thickness*/2,\n\t\t\t\t\tTEXT(\"%s MoveTgt %s\"), *Entity.DebugGetDescription(), *UEnum::GetDisplayValueAsText(MoveTarget.IntentAtGoal).ToString());\n\n\t\t\t\t// MoveTarget orientation\n\t\t\t\tUE_VLOG_SEGMENT_THICK(this, LogMassNavigation, Log, MoveTargetCenter, MoveTargetCenter + MoveTarget.Forward * LookAheadDistance, EntityColor, /*Thickness*/2, TEXT(\"\"));\n\n\t\t\t\t// MoveTarget - current location relation.\n\t\t\t\tif (FVector::Dist2D(CurrentLocation, MoveTarget.Center) > LookAheadDistance * 1.5f)\n\t\t\t\t{\n\t\t\t\t\tUE_VLOG_SEGMENT_THICK(this, LogMassNavigation, Log, MoveTargetCenter, CurrentLocation + ZOffset, FColor::Red, /*Thickness*/1, TEXT(\"LOST\"));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tUE_VLOG_SEGMENT_THICK(this, LogMassNavigation, Log, MoveTargetCenter, CurrentLocation + ZOffset, DarkEntityColor, /*Thickness*/1, TEXT(\"\"));\n\t\t\t\t}\n\n\t\t\t\t// Steering\n\t\t\t\tUE_VLOG_SEGMENT_THICK(this, LogMassNavigation, Log, CurrentLocation + ZOffset, CurrentLocation + Steering.DesiredVelocity + ZOffset, LightEntityColor, /*Thickness*/2,\n\t\t\t\t\tTEXT(\"%s Steer %.1f\"), *Entity.DebugGetDescription(), Steering.DesiredVelocity.Length());\n\t\t\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t\t\t\n\t\t}\n\t});\n}\n\n#undef UNSAFE_FOR_MT\n",
      "lines": 328
    },
    {
      "file_path": "MassAI\\MassNavigation\\Private\\MassSteeringTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 1373,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Steering/MassSteeringTrait.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassNavigationFragments.h\"\n#include \"Steering/MassSteeringFragments.h\"\n#include \"Engine/World.h\"\n#include \"MassEntityUtils.h\"\n\n\nvoid UMassSteeringTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tFMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(World);\n\n\tBuildContext.RequireFragment<FAgentRadiusFragment>();\n\tBuildContext.RequireFragment<FTransformFragment>();\n\tBuildContext.RequireFragment<FMassVelocityFragment>();\n\tBuildContext.RequireFragment<FMassForceFragment>();\n\n\tBuildContext.AddFragment<FMassMoveTargetFragment>();\n\tBuildContext.AddFragment<FMassSteeringFragment>();\n\tBuildContext.AddFragment<FMassStandingSteeringFragment>();\n\tBuildContext.AddFragment<FMassGhostLocationFragment>();\n\n\tconst FConstSharedStruct MovingSteeringFragment = EntityManager.GetOrCreateConstSharedFragment(MovingSteering);\n\tBuildContext.AddConstSharedFragment(MovingSteeringFragment);\n\n\tconst FConstSharedStruct StandingSteeringFragment = EntityManager.GetOrCreateConstSharedFragment(StandingSteering);\n\tBuildContext.AddConstSharedFragment(StandingSteeringFragment);\n}\n",
      "lines": 32
    },
    {
      "file_path": "MassAI\\MassNavigationEditor\\Private\\MassNavigationEditorModule.cpp",
      "extension": ".cpp",
      "size_bytes": 932,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassNavigationEditorModule.h\"\n#include \"Modules/ModuleManager.h\"\n#include \"AssetToolsModule.h\"\n#include \"PropertyEditorModule.h\"\n#include \"ToolMenus.h\"\n\n#define LOCTEXT_NAMESPACE \"MassNavigationEditor\"\n\nIMPLEMENT_MODULE(FMassNavigationEditorModule, MassNavigationEditor)\n\nvoid FMassNavigationEditorModule::StartupModule()\n{\n\t// Register the details customizer\n\tFPropertyEditorModule& PropertyModule = FModuleManager::LoadModuleChecked<FPropertyEditorModule>(\"PropertyEditor\");\n}\n\nvoid FMassNavigationEditorModule::ShutdownModule()\n{\n\tUToolMenus::UnRegisterStartupCallback(this);\n\tUToolMenus::UnregisterOwner(this);\n\n\tif (FModuleManager::Get().IsModuleLoaded(TEXT(\"PropertyEditor\")))\n\t{\n\t\tFPropertyEditorModule& PropertyModule = FModuleManager::GetModuleChecked<FPropertyEditorModule>(TEXT(\"PropertyEditor\"));\n\t}\n}\n\n#undef LOCTEXT_NAMESPACE\n",
      "lines": 30
    },
    {
      "file_path": "MassAI\\MassNavigationEditor\\Private\\MassNavigationTestingActor.cpp",
      "extension": ".cpp",
      "size_bytes": 11845,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassNavigationTestingActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"DebugRenderSceneProxy.h\"\n#include \"ZoneGraphSubsystem.h\"\n#include \"ZoneGraphDelegates.h\"\n#include \"ZoneGraphRenderingUtilities.h\"\n#include \"ZoneGraphData.h\"\n\n#if UE_ENABLE_DEBUG_DRAWING\n\n//////////////////////////////////////////////////////////////////////////\n// FMassNavigationTestingSceneProxy\nFMassNavigationTestingSceneProxy::FMassNavigationTestingSceneProxy(const UPrimitiveComponent& InComponent)\n\t: FDebugRenderSceneProxy(&InComponent)\n{\n\tDrawType = WireMesh;\n}\n\nSIZE_T FMassNavigationTestingSceneProxy::GetTypeHash() const\n{\n\tstatic size_t UniquePointer;\n\treturn reinterpret_cast<size_t>(&UniquePointer);\n}\n\nFPrimitiveViewRelevance FMassNavigationTestingSceneProxy::GetViewRelevance(const FSceneView* View) const\n{\n\tFPrimitiveViewRelevance Result;\n\tResult.bDrawRelevance = IsShown(View);\n\tResult.bDynamicRelevance = true;\n\tResult.bShadowRelevance = IsShadowCast(View);\n\tResult.bEditorPrimitiveRelevance = UseEditorCompositing(View);\n\treturn Result;\n}\n\nuint32 FMassNavigationTestingSceneProxy::GetMemoryFootprint(void) const\n{\n\treturn sizeof(*this) + FDebugRenderSceneProxy::GetAllocatedSize();\n}\n\n#endif // UE_ENABLE_DEBUG_DRAWING\n\n//////////////////////////////////////////////////////////////////////////\n// UMassNavigationTestingComponent\n\nUMassNavigationTestingComponent::UMassNavigationTestingComponent(const FObjectInitializer& ObjectInitialize)\n\t: Super(ObjectInitialize)\n{\n\tSearchExtent = FVector(150.0f);\n}\n\n#if WITH_EDITOR\nvoid UMassNavigationTestingComponent::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)\n{\n\tSuper::PostEditChangeProperty(PropertyChangedEvent);\n\tUpdateTests();\n}\n#endif\n\nvoid UMassNavigationTestingComponent::OnRegister()\n{\n\tSuper::OnRegister();\n#if WITH_EDITOR\n\t// Force to update tests when ever the data changes.\n\tOnDataChangedHandle = UE::ZoneGraphDelegates::OnZoneGraphDataBuildDone.AddUObject(this, &UMassNavigationTestingComponent::OnZoneGraphDataBuildDone);\n#endif\n\tOnDataAddedHandle = UE::ZoneGraphDelegates::OnPostZoneGraphDataAdded.AddUObject(this, &UMassNavigationTestingComponent::OnZoneGraphDataChanged);\n\tOnDataRemovedHandle = UE::ZoneGraphDelegates::OnPreZoneGraphDataRemoved.AddUObject(this, &UMassNavigationTestingComponent::OnZoneGraphDataChanged);\n\n\tZoneGraph = UWorld::GetSubsystem<UZoneGraphSubsystem>(GetWorld());\n\n\tUpdateTests();\n}\n\nvoid UMassNavigationTestingComponent::OnUnregister()\n{\n\tSuper::OnUnregister();\n#if WITH_EDITOR\n\tUE::ZoneGraphDelegates::OnZoneGraphDataBuildDone.Remove(OnDataChangedHandle);\n#endif\n\tUE::ZoneGraphDelegates::OnPostZoneGraphDataAdded.Remove(OnDataAddedHandle);\n\tUE::ZoneGraphDelegates::OnPreZoneGraphDataRemoved.Remove(OnDataRemovedHandle);\n}\n\nvoid UMassNavigationTestingComponent::OnZoneGraphDataChanged(const AZoneGraphData* ZoneGraphData)\n{\n\t// Only consider valid graph from our world\n\tif (ZoneGraphData == nullptr || ZoneGraphData->GetWorld() != GetWorld())\n\t{\n\t\treturn;\n\t}\n\n\tUpdateTests();\n}\n\n#if WITH_EDITOR\nvoid UMassNavigationTestingComponent::OnZoneGraphDataBuildDone(const struct FZoneGraphBuildData& BuildData)\n{\n\tUpdateTests();\n}\n#endif\n\nFBoxSphereBounds UMassNavigationTestingComponent::CalcBounds(const FTransform& LocalToWorld) const\n{\n\tconst FVector ActorPosition = LocalToWorld.GetTranslation();\n\treturn FBox(ActorPosition - SearchExtent, ActorPosition + SearchExtent);\n}\n\nvoid UMassNavigationTestingComponent::UpdateTests()\n{\n\tif (!ZoneGraph)\n\t{\n\t\treturn;\n\t}\n\n\tconst FVector WorldPosition = GetOwner()->GetActorLocation();\n\n\t// Find nearest\n\tfloat DistanceSqr = 0.0f;\n\tif (PinnedLane.IsValid())\n\t{\n\t\tZoneGraph->FindNearestLocationOnLane(LaneLocation.LaneHandle, FBox(WorldPosition - SearchExtent, WorldPosition + SearchExtent), LaneLocation, DistanceSqr);\n\t}\n\telse\n\t{\n\t\tZoneGraph->FindNearestLane(FBox(WorldPosition - SearchExtent, WorldPosition + SearchExtent), QueryFilter, LaneLocation, DistanceSqr);\n\t}\n\n\tCachedLane.Reset();\n\tShortPaths.Reset();\n\n\tGoalLaneLocation.Reset();\n\n\tif (LaneLocation.IsValid())\n\t{\n\t\tconst FVector GoalWorldPosition = WorldPosition + GoalPosition;\n\t\tZoneGraph->FindNearestLocationOnLane(LaneLocation.LaneHandle, FBox(GoalWorldPosition - SearchExtent, GoalWorldPosition + SearchExtent), GoalLaneLocation, DistanceSqr);\n\n\t\tif (const FZoneGraphStorage* ZoneStorage = ZoneGraph->GetZoneGraphStorage(LaneLocation.LaneHandle.DataHandle))\n\t\t{\n\t\t\tconstexpr float InflateDistance = 200.0f;\n\t\t\tCachedLane.CacheLaneData(*ZoneStorage, LaneLocation.LaneHandle, LaneLocation.DistanceAlongLane, GoalLaneLocation.DistanceAlongLane, InflateDistance);\n\n\t\t\t// Path find has smaller buffer than cache, calculate up to 5 paths. Also allows to test that one path find can be continued to next one.\n\t\t\tFZoneGraphShortPathRequest PathRequest;\n\t\t\tPathRequest.bMoveReverse = GoalLaneLocation.DistanceAlongLane < LaneLocation.DistanceAlongLane;\n\t\t\tPathRequest.TargetDistance = GoalLaneLocation.DistanceAlongLane;\n\t\t\tif (bHasSpecificEndPoint)\n\t\t\t{\n\t\t\t\tPathRequest.EndOfPathPosition = GoalWorldPosition;\n\t\t\t}\n\t\t\tPathRequest.AnticipationDistance.Set(AnticipationDistance);\n\n\t\t\tPathRequest.StartPosition = WorldPosition;\n\t\t\tfloat StartDistanceAlongPath = LaneLocation.DistanceAlongLane;\n\t\t\tfor (int32 Iter = 0; Iter < 5; Iter++)\n\t\t\t{\n\t\t\t\tFMassZoneGraphShortPathFragment& ShortPath = ShortPaths.AddDefaulted_GetRef();\n\t\t\t\tShortPath.RequestPath(CachedLane, PathRequest, StartDistanceAlongPath, AgentRadius);\n\n\t\t\t\tif (ShortPath.NumPoints == 0 || !ShortPath.bPartialResult)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Restart from last lane end.\n\t\t\t\tPathRequest.StartPosition = ShortPath.Points[ShortPath.NumPoints - 1].Position;\n\t\t\t\tStartDistanceAlongPath = ShortPath.Points[ShortPath.NumPoints - 1].DistanceAlongLane.Get();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tMarkRenderStateDirty();\n}\n\nvoid UMassNavigationTestingComponent::PinLane()\n{\n\tif (LaneLocation.IsValid())\n\t{\n\t\tPinnedLane = LaneLocation.LaneHandle;\n\t}\n\tUpdateTests();\n}\n\nvoid UMassNavigationTestingComponent::ClearPinnedLane()\n{\n\tPinnedLane.Reset();\n\tUpdateTests();\n}\n\n#if UE_ENABLE_DEBUG_DRAWING\n\nFDebugRenderSceneProxy* UMassNavigationTestingComponent::CreateDebugSceneProxy()\n{\n\tFMassNavigationTestingSceneProxy* DebugProxy = new FMassNavigationTestingSceneProxy(*this);\n\n\tconst FTransform& ActorTransform = GetOwner()->GetActorTransform();\n\tconst FVector Center = ActorTransform.GetLocation(); \n\tconst FVector Goal = Center + GoalPosition; \n\t\n\tstatic constexpr float TickSize = 25.0f;\n\n\tDebugProxy->Boxes.Emplace(FBox(Center - SearchExtent, Center + SearchExtent), FColorList::SkyBlue);\n\n\tDebugProxy->Lines.Emplace(Center + FVector(-TickSize, 0, 0), Center + FVector(TickSize, 0, 0), FColorList::SkyBlue);\n\tDebugProxy->Lines.Emplace(Center + FVector(0, -TickSize, 0), Center + FVector(0, TickSize, 0), FColorList::SkyBlue);\n\tDebugProxy->Lines.Emplace(Center + FVector(0, 0, -TickSize), Center + FVector(0, 0, TickSize), FColorList::SkyBlue);\n\n\tDebugProxy->Lines.Emplace(Goal + FVector(-TickSize, 0, 0), Goal + FVector(TickSize, 0, 0), FColorList::YellowGreen);\n\tDebugProxy->Lines.Emplace(Goal + FVector(0, -TickSize, 0), Goal + FVector(0, TickSize, 0), FColorList::YellowGreen);\n\tDebugProxy->Lines.Emplace(Goal + FVector(0, 0, -TickSize), Goal + FVector(0, 0, TickSize), FColorList::YellowGreen);\n\n\tconst FVector ZOffset(0,0,10);\n\tconst FVector ZOffsetPath(0,0,20);\n\t\n\tif (LaneLocation.IsValid())\n\t{\n\t\tDebugProxy->Lines.Emplace(LaneLocation.Position - LaneLocation.Up * TickSize, LaneLocation.Position + LaneLocation.Up * TickSize * 3.0f, FColorList::SkyBlue);\n\t\tDebugProxy->Lines.Emplace(Center, LaneLocation.Position, FColorList::SkyBlue);\n\t}\n\n\tif (GoalLaneLocation.IsValid())\n\t{\n\t\tDebugProxy->Lines.Emplace(GoalLaneLocation.Position - GoalLaneLocation.Up * TickSize, GoalLaneLocation.Position + GoalLaneLocation.Up * TickSize * 3.0f, FColorList::YellowGreen);\n\t\tDebugProxy->Lines.Emplace(Goal, GoalLaneLocation.Position, FColorList::YellowGreen);\n\t}\n\n\tif (CachedLane.NumPoints > 1)\n\t{\n\t\tconst float LeftSpace = CachedLane.LaneWidth.Get() * 0.5f + CachedLane.LaneLeftSpace.Get() - AgentRadius;\n\t\tconst float RightSpace = CachedLane.LaneWidth.Get() * 0.5f + CachedLane.LaneRightSpace.Get() - AgentRadius;\n\t\t\n\t\tfor (uint8 PointIndex = 0; PointIndex < CachedLane.NumPoints - 1; PointIndex++)\n\t\t{\n\t\t\tDebugProxy->Lines.Emplace(CachedLane.LanePoints[PointIndex] + ZOffset, CachedLane.LanePoints[PointIndex + 1] + ZOffset, FColorList::Grey, 4.0f);\n\n\t\t\t// Draw boundaries\n\t\t\tconst FVector StartTangent = CachedLane.LaneTangentVectors[PointIndex].GetVector();\n\t\t\tconst FVector StartLeftDir = FVector::CrossProduct(StartTangent, FVector::UpVector);\n\t\t\tconst FVector StartLeftPos = CachedLane.LanePoints[PointIndex] + ZOffset + StartLeftDir * LeftSpace;\n\t\t\tconst FVector StartRightPos = CachedLane.LanePoints[PointIndex] + ZOffset + StartLeftDir * -RightSpace;\n\n\t\t\tconst FVector EndTangent = CachedLane.LaneTangentVectors[PointIndex + 1].GetVector();\n\t\t\tconst FVector EndLeftDir = FVector::CrossProduct(EndTangent, FVector::UpVector);\n\t\t\tconst FVector EndLeftPos = CachedLane.LanePoints[PointIndex + 1] + ZOffset + EndLeftDir * LeftSpace;\n\t\t\tconst FVector EndRightPos = CachedLane.LanePoints[PointIndex + 1] + ZOffset + EndLeftDir * -RightSpace;\n\n\t\t\tDebugProxy->Lines.Emplace(StartLeftPos, EndLeftPos, FColorList::LightGrey, 1.0f);\n\t\t\tDebugProxy->Lines.Emplace(StartRightPos, EndRightPos, FColorList::LightGrey, 1.0f);\n\n\t\t\tif (PointIndex == 0)\n\t\t\t{\n\t\t\t\tDebugProxy->Lines.Emplace(StartLeftPos, StartRightPos, FColorList::LightGrey, 1.0f);\n\t\t\t}\n\t\t\telse if (PointIndex == (CachedLane.NumPoints - 1))\n\t\t\t{\n\t\t\t\tDebugProxy->Lines.Emplace(EndLeftPos, EndRightPos, FColorList::LightGrey, 1.0f);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n\tfor (int32 PathIndex = 0; PathIndex < ShortPaths.Num(); PathIndex++)\n\t{\n\t\tconst FMassZoneGraphShortPathFragment& ShortPath = ShortPaths[PathIndex];\n\t\tconst FColor PathColor = (PathIndex & 1) ? FColor::Orange : FColor::Emerald;\n\t\n\t\tif (ShortPath.NumPoints > 1)\n\t\t{\n\t\t\tfor (uint8 PointIndex = 0; PointIndex < ShortPath.NumPoints; PointIndex++)\n\t\t\t{\n\t\t\t\tconst FVector Position = ShortPath.Points[PointIndex].Position + ZOffsetPath;\n\t\t\t\tconst FVector LeftDir = FVector::CrossProduct(ShortPath.Points[PointIndex].Tangent.GetVector(), FVector::UpVector);\n\n\t\t\t\tDebugProxy->Lines.Emplace(Position - LeftDir * TickSize, Position + LeftDir * TickSize, PathColor, 2.0f);\n\t\t\t\tDebugProxy->Texts.Emplace(FString::Printf(TEXT(\"%d\"), (int32)PointIndex), Position, PathColor);\n\t\t\t}\n\n\t\t\tfor (uint8 PointIndex = 0; PointIndex < ShortPath.NumPoints - 1; PointIndex++)\n\t\t\t{\n\t\t\t\tDebugProxy->Lines.Emplace(ShortPath.Points[PointIndex].Position + ZOffsetPath, ShortPath.Points[PointIndex + 1].Position + ZOffsetPath, PathColor, 4.0f);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn DebugProxy;\n}\n#endif // UE_ENABLE_DEBUG_DRAWING\n\n//////////////////////////////////////////////////////////////////////////\n// UMassNavigationTestingComponent\n\nAMassNavigationTestingActor::AMassNavigationTestingActor(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n\tDebugComp = CreateDefaultSubobject<UMassNavigationTestingComponent>(TEXT(\"DebugComp\"));\n\tRootComponent = DebugComp;\n\n\tSetCanBeDamaged(false);\n}\n\n#if WITH_EDITOR\nvoid AMassNavigationTestingActor::PostEditMove(bool bFinished)\n{\n\tif (DebugComp)\n\t{\n\t\tDebugComp->UpdateTests();\n\t}\n}\n#endif\n\nvoid AMassNavigationTestingActor::PinLane()\n{\n\tif (DebugComp)\n\t{\n\t\tDebugComp->PinLane();\n\t}\n}\n\t\nvoid AMassNavigationTestingActor::ClearPinnedLane()\n{\n\tif (DebugComp)\n\t{\n\t\tDebugComp->ClearPinnedLane();\n\t}\n}\n",
      "lines": 327
    },
    {
      "file_path": "MassAI\\MassZoneGraphNavigation\\Private\\MassZoneGraphNavigationFragments.cpp",
      "extension": ".cpp",
      "size_bytes": 21453,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"ZoneGraphTypes.h\"\n#include \"ZoneGraphQuery.h\"\n\n\nnamespace UE::MassNavigation::ZoneGraphPath\n{\n\tstruct FCachedLaneSegmentIterator\n\t{\n\t\tFCachedLaneSegmentIterator(const FMassZoneGraphCachedLaneFragment& InCachedLane, const float DistanceAlongPath, const bool bInMoveReverse)\n\t\t\t: CachedLane(InCachedLane)\n\t\t\t, SegmentInc(bInMoveReverse ? -1 : 1)\n\t\t\t, bMoveReverse(bInMoveReverse)\n\t\t{\n\t\t\tcheck(CachedLane.NumPoints >= 2);\n\t\t\tCurrentSegment = CachedLane.FindSegmentIndexAtDistance(DistanceAlongPath);\n\t\t\tLastSegment = bInMoveReverse ? 0 : ((int32)CachedLane.NumPoints - 2);\n\t\t}\n\n\t\tbool HasReachedDistance(const float Distance) const\n\t\t{\n\t\t\tif (CurrentSegment == LastSegment)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (bMoveReverse)\n\t\t\t{\n\t\t\t\tconst float SegStartDistance = CachedLane.LanePointProgressions[CurrentSegment].Get();\n\t\t\t\tif (Distance > SegStartDistance)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconst float SegEndDistance = CachedLane.LanePointProgressions[CurrentSegment + 1].Get();\n\t\t\t\tif (Distance < SegEndDistance)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tvoid Next()\n\t\t{\n\t\t\tif (CurrentSegment != LastSegment)\n\t\t\t{\n\t\t\t\tCurrentSegment += SegmentInc;\n\t\t\t}\n\t\t}\n\n\t\tconst FMassZoneGraphCachedLaneFragment& CachedLane;\n\t\tint32 CurrentSegment = 0;\n\t\tint32 LastSegment = 0;\n\t\tint32 SegmentInc = 0;\n\t\tbool bMoveReverse = false;\n\t};\n\n} // UE::MassMovement::ZoneGraphPath\n\nvoid FMassZoneGraphCachedLaneFragment::CacheLaneData(const FZoneGraphStorage& ZoneGraphStorage, const FZoneGraphLaneHandle CurrentLaneHandle,\n\t\t\t\t\t\t\t\t\t\t\t\t\t const float CurrentDistanceAlongLane, const float TargetDistanceAlongLane, const float InflateDistance)\n{\n\tconst FZoneLaneData& Lane = ZoneGraphStorage.Lanes[CurrentLaneHandle.Index];\n\n\tconst float StartDistance = FMath::Min(CurrentDistanceAlongLane, TargetDistanceAlongLane);\n\tconst float EndDistance = FMath::Max(CurrentDistanceAlongLane, TargetDistanceAlongLane);\n\tconst float CurrentLaneLength = ZoneGraphStorage.LanePointProgressions[Lane.PointsEnd - 1];\n\n\t// If cached data contains the request part of the lane, early out.\n\tconst float InflatedStartDistance = FMath::Max(0.0f, StartDistance - InflateDistance);\n\tconst float InflatedEndDistance = FMath::Min(EndDistance + InflateDistance, CurrentLaneLength);\n\tif (LaneHandle == CurrentLaneHandle\n\t\t&& NumPoints > 0\n\t\t&& InflatedStartDistance >= LanePointProgressions[0].Get()\n\t\t&& InflatedEndDistance <= LanePointProgressions[NumPoints - 1].Get())\n\t{\n\t\treturn;\n\t}\n\n\tReset();\n\tCacheID++;\n\n\tLaneHandle = CurrentLaneHandle;\n\tLaneWidth = FMassInt16Real(Lane.Width);\n\tLaneLength = CurrentLaneLength;\n\n\tconst int32 LaneNumPoints = Lane.PointsEnd - Lane.PointsBegin;\n\tif (LaneNumPoints <= (int32)MaxPoints)\n\t{\n\t\t// If we can fit all the lane's points, just do a copy.\n\t\tNumPoints = (uint8)LaneNumPoints;\n\t\tfor (int32 Index = 0; Index < (int32)NumPoints; Index++)\n\t\t{\n\t\t\tLanePoints[Index] = ZoneGraphStorage.LanePoints[Lane.PointsBegin + Index];\n\t\t\tLaneTangentVectors[Index] = FMassSnorm8Vector2D(FVector2D(ZoneGraphStorage.LaneTangentVectors[Lane.PointsBegin + Index]));\n\t\t\tLanePointProgressions[Index] = FMassInt16Real10(ZoneGraphStorage.LanePointProgressions[Lane.PointsBegin + Index]);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Find the segment of the lane that is important and copy that.\n\t\tint32 StartSegmentIndex = 0;\n\t\tint32 EndSegmentIndex = 0;\n\t\tUE::ZoneGraph::Query::CalculateLaneSegmentIndexAtDistance(ZoneGraphStorage, CurrentLaneHandle, StartDistance, StartSegmentIndex);\n\t\tUE::ZoneGraph::Query::CalculateLaneSegmentIndexAtDistance(ZoneGraphStorage, CurrentLaneHandle, EndDistance, EndSegmentIndex);\n\n\t\t// Expand if close to start of a segment start.\n\t\tif ((StartSegmentIndex - 1) >= Lane.PointsBegin && (StartDistance - InflateDistance) < ZoneGraphStorage.LanePointProgressions[StartSegmentIndex])\n\t\t{\n\t\t\tStartSegmentIndex--;\n\t\t}\n\t\t// Expand if close to end segment end.\n\t\tif ((EndSegmentIndex + 1) < (Lane.PointsEnd - 2) && (EndDistance + InflateDistance) > ZoneGraphStorage.LanePointProgressions[EndSegmentIndex + 1])\n\t\t{\n\t\t\tEndSegmentIndex++;\n\t\t}\n\t\n\t\tNumPoints = (uint8)FMath::Min((EndSegmentIndex - StartSegmentIndex) + 2, (int32)MaxPoints);\n\n\t\tfor (int32 Index = 0; Index < (int32)NumPoints; Index++)\n\t\t{\n\t\t\tcheck((StartSegmentIndex + Index) >= Lane.PointsBegin && (StartSegmentIndex + Index) < Lane.PointsEnd);\n\t\t\tLanePoints[Index] = ZoneGraphStorage.LanePoints[StartSegmentIndex + Index];\n\t\t\tLaneTangentVectors[Index] = FMassSnorm8Vector2D(FVector2D(ZoneGraphStorage.LaneTangentVectors[StartSegmentIndex + Index]));\n\t\t\tLanePointProgressions[Index] = FMassInt16Real10(ZoneGraphStorage.LanePointProgressions[StartSegmentIndex + Index]);\n\t\t}\n\t}\n\n\t// Calculate extra space around the lane on adjacent lanes.\n\tTArray<FZoneGraphLinkedLane> LinkedLanes;\n\tUE::ZoneGraph::Query::GetLinkedLanes(ZoneGraphStorage, CurrentLaneHandle, EZoneLaneLinkType::Adjacent, EZoneLaneLinkFlags::Left|EZoneLaneLinkFlags::Right, EZoneLaneLinkFlags::None, LinkedLanes);\n\n\tfloat AdjacentLeftWidth = 0.0f;\n\tfloat AdjacentRightWidth = 0.0f;\n\tfor (const FZoneGraphLinkedLane& LinkedLane : LinkedLanes)\n\t{\n\t\tif (LinkedLane.HasFlags(EZoneLaneLinkFlags::Left))\n\t\t{\n\t\t\tconst FZoneLaneData& AdjacentLane = ZoneGraphStorage.Lanes[LinkedLane.DestLane.Index];\n\t\t\tAdjacentLeftWidth += AdjacentLane.Width;\n\t\t}\n\t\telse if (LinkedLane.HasFlags(EZoneLaneLinkFlags::Right))\n\t\t{\n\t\t\tconst FZoneLaneData& AdjacentLane = ZoneGraphStorage.Lanes[LinkedLane.DestLane.Index];\n\t\t\tAdjacentRightWidth += AdjacentLane.Width;\n\t\t}\n\t}\n\tLaneLeftSpace = FMassInt16Real(AdjacentLeftWidth);\n\tLaneRightSpace = FMassInt16Real(AdjacentRightWidth);\n}\n\nbool FMassZoneGraphShortPathFragment::RequestPath(const FMassZoneGraphCachedLaneFragment& CachedLane, const FZoneGraphShortPathRequest& Request, const float InCurrentDistanceAlongLane, const float AgentRadius)\n{\n\tReset();\n\n\tif (CachedLane.NumPoints < 2)\n\t{\n\t\treturn false;\n\t}\n\n\n\t// The current distance can come from a quantized lane distance. Check against quantized bounds, but clamp it to the actual path length when calculating the path.\n\tstatic_assert(std::is_same_v<decltype(FMassZoneGraphPathPoint::Distance), FMassInt16Real>, \"Assuming FMassZoneGraphPathPoint::Distance is quantized to 10 units.\");\n\tconst float LaneLengthQuantized = FMath::CeilToFloat(CachedLane.LaneLength / 10.0f) * 10.0f;\n\n\tstatic constexpr float Epsilon = 0.1f;\n\tensureMsgf(InCurrentDistanceAlongLane >= -Epsilon && InCurrentDistanceAlongLane <= (LaneLengthQuantized + Epsilon), TEXT(\"Current distance %f should be within the lane bounds 0.0 - %f\"), InCurrentDistanceAlongLane, LaneLengthQuantized);\n\n\tconst float CurrentDistanceAlongLane = FMath::Min(InCurrentDistanceAlongLane, CachedLane.LaneLength);\n\t\n\t// Set common lane parameters\n#if WITH_MASSGAMEPLAY_DEBUG\n\tDebugLaneHandle = CachedLane.LaneHandle;\n#endif\n\n\tbMoveReverse = Request.bMoveReverse;\n\tEndOfPathIntent = Request.EndOfPathIntent;\n\tbPartialResult = false;\n\n\tconst float DeflatedLaneHalfWidth = FMath::Max(0.0f, CachedLane.LaneWidth.Get() - AgentRadius) * 0.5f;\n\tconst float DeflatedLaneLeft = DeflatedLaneHalfWidth + CachedLane.LaneLeftSpace.Get();\n\tconst float DeflatedLaneRight = DeflatedLaneHalfWidth + CachedLane.LaneRightSpace.Get();\n\n\tconst float TargetDistanceAlongLane = FMath::Clamp(Request.TargetDistance, 0.0f, CachedLane.LaneLength);\n\tconst float MinDistanceAlongLane = FMath::Min(CurrentDistanceAlongLane, TargetDistanceAlongLane);\n\tconst float MaxDistanceAlongLane = FMath::Max(CurrentDistanceAlongLane, TargetDistanceAlongLane);\n\t\n\tconst float TangentSign = Request.bMoveReverse ? -1.0f : 1.0f;\n\n\t// Slop factors used when testing if a point is conservatively inside the lane.\n\tconstexpr float OffLaneCapSlop = 10.0f;\n\tconstexpr float OffLaneEdgeSlop = 1.0f;\n\n\t// Calculate how the start point relates to the corresponding location on lane.\n\tFVector StartLanePosition;\n\tFVector StartLaneTangent;\n\tCachedLane.GetPointAndTangentAtDistance(CurrentDistanceAlongLane, StartLanePosition, StartLaneTangent);\n\tfloat StartDistanceAlongPath = CurrentDistanceAlongLane;\n\n\tFVector StartPosition = Request.StartPosition;\n\t// Calculate start point's relation to the start point location on lane.\n\tconst FVector StartDelta = StartPosition - StartLanePosition;\n\tconst FVector StartLeftDir = FVector::CrossProduct(StartLaneTangent, FVector::UpVector);\n\tfloat StartLaneOffset = FloatCastChecked<float>(FVector::DotProduct(StartLeftDir, StartDelta), UE::LWC::DefaultFloatPrecision);\n\tfloat StartLaneForwardOffset = FloatCastChecked<float>(FVector::DotProduct(StartLaneTangent, StartDelta) * TangentSign, UE::LWC::DefaultFloatPrecision);\n\t// The point is off-lane if behind the start, or beyond the boundary.\n\tconst bool bStartOffLane = StartLaneForwardOffset < -OffLaneCapSlop\n\t\t\t\t\t\t\t\t|| StartLaneOffset < -(DeflatedLaneRight + OffLaneEdgeSlop)\n\t\t\t\t\t\t\t\t|| StartLaneOffset > (DeflatedLaneLeft + OffLaneEdgeSlop);\n\tStartLaneOffset = FMath::Clamp(StartLaneOffset, -DeflatedLaneRight, DeflatedLaneLeft);\n\n\tif (bStartOffLane)\n\t{\n\t\t// The start point was off-lane, move the start location along the lane a bit further to have smoother connection.\n\t\tconst float StartForwardOffset = FMath::Clamp(Request.AnticipationDistance.Get() + StartLaneForwardOffset, 0.0f, Request.AnticipationDistance.Get());\n\t\tStartDistanceAlongPath += StartForwardOffset * TangentSign; // Not clamping this distance intentionally so that the halfway point and clamping later works correctly.\n\t}\n\n\t// Calculate how the end point relates to the corresponding location on lane.\n\tconst bool bHasEndOfPathPoint = Request.bIsEndOfPathPositionSet;\n\tfloat EndDistanceAlongPath = TargetDistanceAlongLane;\n\tFVector EndLanePosition = FVector::ZeroVector;\n\tFVector EndLaneTangent = FVector::ZeroVector;\n\tbool bEndOffLane = false;\n\tfloat EndLaneOffset = StartLaneOffset;\n\n\tif (bHasEndOfPathPoint)\n\t{\n\t\t// Calculate end point's relation to the end point location on lane.\n\t\tCachedLane.GetPointAndTangentAtDistance(TargetDistanceAlongLane, EndLanePosition, EndLaneTangent);\n\t\tconst FVector EndPosition = Request.EndOfPathPosition;\n\t\tconst FVector EndDelta = EndPosition - EndLanePosition;\n\t\tconst FVector LeftDir = FVector::CrossProduct(EndLaneTangent, FVector::UpVector);\n\t\tEndLaneOffset = FloatCastChecked<float>(FVector::DotProduct(LeftDir, EndDelta), UE::LWC::DefaultFloatPrecision);\n\t\tconst float EndLaneForwardOffset = FloatCastChecked<float>(FVector::DotProduct(EndLaneTangent, EndDelta) * TangentSign, UE::LWC::DefaultFloatPrecision);\n\t\t// The point is off-lane if further than the, or beyond the boundary.\n\t\tbEndOffLane = EndLaneForwardOffset > OffLaneCapSlop\n\t\t\t\t\t\t|| EndLaneOffset < -(DeflatedLaneRight + OffLaneEdgeSlop)\n\t\t\t\t\t\t|| EndLaneOffset > (DeflatedLaneLeft + OffLaneEdgeSlop);\n\t\tEndLaneOffset = FMath::Clamp(EndLaneOffset, -DeflatedLaneRight, DeflatedLaneLeft);\n\n\t\t// Move the end location along the lane a bit back to have smoother connection.\n\t\tconst float EndForwardOffset = FMath::Clamp(Request.AnticipationDistance.Get() - EndLaneForwardOffset, 0.0f, Request.AnticipationDistance.Get());\n\t\tEndDistanceAlongPath -= EndForwardOffset * TangentSign; // Not clamping this distance intentionally so that the halfway point and clamping later works correctly.\n\t}\n\n\t// Clamp the path move distances to current lane. We use halfway point to split the anticipation in case it gets truncated.\n\tconst float HalfwayDistanceAlongLane = FMath::Clamp((StartDistanceAlongPath + EndDistanceAlongPath) * 0.5f, MinDistanceAlongLane, MaxDistanceAlongLane);\n\n\tif (Request.bMoveReverse)\n\t{\n\t\tStartDistanceAlongPath = FMath::Clamp(StartDistanceAlongPath, HalfwayDistanceAlongLane, MaxDistanceAlongLane);\n\t\tEndDistanceAlongPath = FMath::Clamp(EndDistanceAlongPath, MinDistanceAlongLane, HalfwayDistanceAlongLane);\n\t}\n\telse\n\t{\n\t\tStartDistanceAlongPath = FMath::Clamp(StartDistanceAlongPath, MinDistanceAlongLane, HalfwayDistanceAlongLane);\n\t\tEndDistanceAlongPath = FMath::Clamp(EndDistanceAlongPath, HalfwayDistanceAlongLane, MaxDistanceAlongLane);\n\t}\n\n\t// Check if the mid path got clamped away. This can happen if start of end or both are off-mesh, or just a short path.\n\tconst float MidPathMoveDistance = FMath::Abs(EndDistanceAlongPath - StartDistanceAlongPath); \n\tconst bool bHasMidPath = MidPathMoveDistance > KINDA_SMALL_NUMBER;\n\n\t// If end position is not set to a specific location, use proposed offset\n\tif (!bHasEndOfPathPoint)\n\t{\n\t\t// Slope defines how much the offset can change over the course of the path.\n\t\tconstexpr float MaxLaneOffsetSlope = 1.0f / 10.0f;\n\t\tconst float MaxOffset = MidPathMoveDistance * MaxLaneOffsetSlope;\n\t\tconst float LaneOffset = FMath::Clamp(Request.EndOfPathOffset.Get(), -MaxOffset, MaxOffset);\n\t\tEndLaneOffset = FMath::Clamp(EndLaneOffset + LaneOffset, -DeflatedLaneRight, DeflatedLaneLeft);\n\t}\n\n\t// Always add off-lane start point.\n\tif (bStartOffLane)\n\t{\n\t\tFMassZoneGraphPathPoint& StartPoint = Points[NumPoints++];\n\t\tStartPoint.DistanceAlongLane = FMassInt16Real10(CurrentDistanceAlongLane);\n\t\tStartPoint.Position = Request.StartPosition;\n\t\tStartPoint.Tangent = FMassSnorm8Vector2D(StartLaneTangent * TangentSign);\n\t\tStartPoint.bOffLane = true;\n\t\tStartPoint.bIsLaneExtrema = false;\n\n\t\t// Update start point to be inside the lane.\n\t\tCachedLane.GetPointAndTangentAtDistance(StartDistanceAlongPath, StartLanePosition, StartLaneTangent);\n\t\tconst FVector LeftDir = FVector::CrossProduct(StartLaneTangent, FVector::UpVector);\n\t\tStartPosition = StartLanePosition + LeftDir * StartLaneOffset;\n\n\t\t// Adjust the start point to point towards the first on-lane point.\n\t\tconst FVector DirToClampedPoint = StartPosition - StartPoint.Position;\n\t\tStartPoint.Tangent = FMassSnorm8Vector2D(DirToClampedPoint.GetSafeNormal());\n\t}\n\n\t// The second point is added if there was no off-lane start point, or we have mid path.\n\t// This ensures that there's always at least one start point, and that no excess points are added if both start & end are off-lane close to each other.\n\tif (!bStartOffLane || bHasMidPath)\n\t{\n\t\t// Add first on-lane point.\n\t\tFMassZoneGraphPathPoint& Point = Points[NumPoints++];\n\t\tPoint.DistanceAlongLane = FMassInt16Real10(StartDistanceAlongPath);\n\t\tPoint.Position = StartPosition;\n\t\tPoint.Tangent = FMassSnorm8Vector2D(StartLaneTangent * TangentSign);\n\t\tPoint.bOffLane = false;\n\t\tPoint.bIsLaneExtrema = false;\n\t}\n\n\t// Add in between points.\n\tconst float InvDistanceRange = 1.0f / (EndDistanceAlongPath - StartDistanceAlongPath); // Used for lane offset interpolation. \n\tfloat PrevDistanceAlongLane = StartDistanceAlongPath;\n\n\tUE::MassNavigation::ZoneGraphPath::FCachedLaneSegmentIterator SegmentIterator(CachedLane, StartDistanceAlongPath, Request.bMoveReverse);\n\twhile (!SegmentIterator.HasReachedDistance(EndDistanceAlongPath))\n\t{\n\t\t// The segment endpoint is start when moving backwards (i.e. the segment index), and end when moving forwards.\n\t\tconst int32 CurrentSegmentEndPointIndex = SegmentIterator.CurrentSegment + (SegmentIterator.bMoveReverse ? 0 : 1);\n\t\tconst float DistanceAlongLane = CachedLane.LanePointProgressions[CurrentSegmentEndPointIndex].Get();\n\n\t\tif (FMath::IsNearlyEqual(PrevDistanceAlongLane, DistanceAlongLane) == false)\n\t\t{\n\t\t\tif (NumPoints < MaxPoints)\n\t\t\t{\n\t\t\t\tconst FVector& LanePosition = CachedLane.LanePoints[CurrentSegmentEndPointIndex];\n\t\t\t\tconst FVector LaneTangent = CachedLane.LaneTangentVectors[CurrentSegmentEndPointIndex].GetVector();\n\n\t\t\t\tconst float LaneOffsetT = (DistanceAlongLane - StartDistanceAlongPath) * InvDistanceRange;\n\t\t\t\tconst float LaneOffset = FMath::Lerp(StartLaneOffset, EndLaneOffset, LaneOffsetT);\n\t\t\t\tconst FVector LeftDir = FVector::CrossProduct(LaneTangent, FVector::UpVector);\n\n\t\t\t\tFMassZoneGraphPathPoint& Point = Points[NumPoints++];\n\t\t\t\tPoint.DistanceAlongLane = FMassInt16Real10(DistanceAlongLane);\n\t\t\t\tPoint.Position = LanePosition + LeftDir * LaneOffset;\n\t\t\t\tPoint.Tangent = FMassSnorm8Vector2D(LaneTangent * TangentSign);\n\t\t\t\tPoint.bOffLane = false;\n\t\t\t\tPoint.bIsLaneExtrema = false;\n\n\t\t\t\tPrevDistanceAlongLane = DistanceAlongLane;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbPartialResult = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSegmentIterator.Next();\n\t}\n\n\t// The second last point is added if there is no end point, or we have mid path.\n\t// This ensures that there's always at least one end point, and that no excess points are added if both start & end are off-lane close to each other.\n\tif (!bHasEndOfPathPoint || bHasMidPath)\n\t{\n\t\tif (NumPoints < MaxPoints)\n\t\t{\n\t\t\t// Interpolate last point on mid path.\n\t\t\tFVector LanePosition;\n\t\t\tFVector LaneTangent;\n\t\t\tCachedLane.InterpolatePointAndTangentOnSegment(SegmentIterator.CurrentSegment, EndDistanceAlongPath, LanePosition, LaneTangent);\n\n\t\t\tconst float LaneOffset = EndLaneOffset;\n\t\t\tconst FVector LeftDir = FVector::CrossProduct(LaneTangent, FVector::UpVector);\n\n\t\t\tFMassZoneGraphPathPoint& Point = Points[NumPoints++];\n\t\t\tPoint.DistanceAlongLane = FMassInt16Real10(EndDistanceAlongPath);\n\t\t\tPoint.Position = LanePosition + LeftDir * LaneOffset;\n\t\t\tPoint.Tangent = FMassSnorm8Vector2D(LaneTangent * TangentSign);\n\t\t\tPoint.bOffLane = false;\n\t\t\tPoint.bIsLaneExtrema = !Request.bIsEndOfPathPositionSet && CachedLane.IsDistanceAtLaneExtrema(EndDistanceAlongPath);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbPartialResult = true;\n\t\t}\n\t}\n\n\tcheckf(NumPoints >= 1, TEXT(\"Path should have at least 1 point at this stage but has none.\"));\n\n\t// Add end of path point if set.\n\tif (bHasEndOfPathPoint)\n\t{\n\t\tif (NumPoints < MaxPoints)\n\t\t{\n\t\t\tconst FVector EndPosition = Request.EndOfPathPosition;\n\n\t\t\t// Use provided direction if set, otherwise use direction from last point on lane to end of path point\n\t\t\tconst FVector EndDirection = (Request.bIsEndOfPathDirectionSet) ?\n\t\t\t\tRequest.EndOfPathDirection.Get() :\n\t\t\t\t(EndPosition - Points[NumPoints-1].Position).GetSafeNormal();\n\t\t\t\n\t\t\tFMassZoneGraphPathPoint& Point = Points[NumPoints++];\n\t\t\tPoint.DistanceAlongLane = FMassInt16Real10(TargetDistanceAlongLane);\n\t\t\tPoint.Position = EndPosition;\n\t\t\tPoint.Tangent = FMassSnorm8Vector2D(EndDirection);\n\t\t\tPoint.bOffLane = bEndOffLane;\n\t\t\tPoint.bIsLaneExtrema = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbPartialResult = true;\n\t\t}\n\t}\n\n\tcheckf(NumPoints >= 2, TEXT(\"Path should have at least 2 points at this stage, has %d.\"), NumPoints);\n\n\t// Calculate movement distance at each point.\n\tfloat PathDistance = 0.0f;\n\tPoints[0].Distance.Set(PathDistance);\n\tfor (uint8 PointIndex = 1; PointIndex < NumPoints; PointIndex++)\n\t{\n\t\tFMassZoneGraphPathPoint& PrevPoint = Points[PointIndex - 1];\n\t\tFMassZoneGraphPathPoint& Point = Points[PointIndex];\n\t\tconst FVector PrevPosition = PrevPoint.Position;\n\t\tconst FVector Position = Point.Position;\n\t\tconst float DeltaDistance = FloatCastChecked<float>(FVector::Dist(PrevPosition, Position), UE::LWC::DefaultFloatPrecision);\n\t\tPathDistance += DeltaDistance;\n\t\tPoint.Distance.Set(PathDistance);\n\t}\n\t\n\t// If the last point on path reaches end of the lane, set the next handle to the next lane. It will be update when path finishes.\n\tif (!bPartialResult && Request.NextLaneHandle.IsValid())\n\t{\n\t\tconst FMassZoneGraphPathPoint& LastPoint = Points[NumPoints - 1];\n\t\n\t\tif (Request.NextExitLinkType == EZoneLaneLinkType::Adjacent || LastPoint.bIsLaneExtrema)\n\t\t{\n\t\t\tNextLaneHandle = Request.NextLaneHandle;\n\t\t\tNextExitLinkType = Request.NextExitLinkType;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool FMassZoneGraphShortPathFragment::RequestStand(const FMassZoneGraphCachedLaneFragment& CachedLane, const float CurrentDistanceAlongLane, const FVector& CurrentPosition)\n{\n\tReset();\n\n\tif (CachedLane.NumPoints < 2)\n\t{\n\t\treturn false;\n\t}\n\n\tstatic constexpr float Epsilon = 0.1f;\n\tcheck(CurrentDistanceAlongLane >= -Epsilon && CurrentDistanceAlongLane <= (CachedLane.LaneLength + Epsilon));\n\t\n\t// Get current location\n\tFVector CurrentLanePosition;\n\tFVector CurrentLaneTangent;\n\tCachedLane.GetPointAndTangentAtDistance(CurrentDistanceAlongLane, CurrentLanePosition, CurrentLaneTangent);\n\t\n\t// Set common lane parameters\n#if WITH_MASSGAMEPLAY_DEBUG\n\tDebugLaneHandle = CachedLane.LaneHandle;\n#endif\n\tbMoveReverse = false;\n\tEndOfPathIntent = EMassMovementAction::Stand;\n\tbPartialResult = false;\n\n\t// Add start point, if the start is outside the lane, add another point to get back to lane.\n\tconst FVector StartMoveOffset = CurrentPosition - CurrentLanePosition;\n\n\tFMassZoneGraphPathPoint& StartPoint = Points[NumPoints];\n\tStartPoint.DistanceAlongLane = FMassInt16Real10(CurrentDistanceAlongLane);\n\tStartPoint.Position = CurrentPosition;\n\tStartPoint.Tangent = FMassSnorm8Vector2D(CurrentLaneTangent);\n\tStartPoint.bOffLane = false;\n\tStartPoint.bIsLaneExtrema = false;\n\tStartPoint.Distance = FMassInt16Real(0.0f);\n\tNumPoints++;\n\n\tFMassZoneGraphPathPoint& EndPoint = Points[NumPoints];\n\tEndPoint.DistanceAlongLane = FMassInt16Real10(CurrentDistanceAlongLane);\n\tEndPoint.Position = CurrentPosition;\n\tEndPoint.Tangent = FMassSnorm8Vector2D(CurrentLaneTangent);\n\tEndPoint.bOffLane = false;\n\tEndPoint.bIsLaneExtrema = false;\n\tEndPoint.Distance = FMassInt16Real(0.0f);\n\tNumPoints++;\n\n\treturn true;\n}\n",
      "lines": 487
    },
    {
      "file_path": "MassAI\\MassZoneGraphNavigation\\Private\\MassZoneGraphNavigationModule.cpp",
      "extension": ".cpp",
      "size_bytes": 847,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CoreMinimal.h\"\n#include \"IMassZoneGraphNavigationModule.h\"\n\n\nclass FMassZoneGraphNavigationModule : public IMassZoneGraphNavigationModule\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nIMPLEMENT_MODULE(FMassZoneGraphNavigationModule, MassZoneGraphNavigation)\n\n\nvoid FMassZoneGraphNavigationModule::StartupModule()\n{\n\t// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)\n}\n\n\nvoid FMassZoneGraphNavigationModule::ShutdownModule()\n{\n\t// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n\t// we call this function before unloading the module.\n}\n",
      "lines": 27
    },
    {
      "file_path": "MassAI\\MassZoneGraphNavigation\\Private\\MassZoneGraphNavigationProcessors.cpp",
      "extension": ".cpp",
      "size_bytes": 28646,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassZoneGraphNavigationProcessors.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"MassNavigationTypes.h\"\n#include \"MassNavigationFragments.h\"\n#include \"MassNavigationUtils.h\"\n#include \"Avoidance/MassAvoidanceFragments.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassSignalSubsystem.h\"\n#include \"ZoneGraphSubsystem.h\"\n#include \"ZoneGraphQuery.h\"\n#include \"MassGameplayExternalTraits.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassSimulationLOD.h\"\n#include \"Engine/World.h\"\n#include \"MassDebugger.h\"\n\n#define UNSAFE_FOR_MT 1\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\nnamespace UE::MassNavigation::Debug\n{\n\tFColor MixColors(const FColor ColorA, const FColor ColorB)\n\t{\n\t\tconst int32 R = ((int32)ColorA.R + (int32)ColorB.R) / 2;\n\t\tconst int32 G = ((int32)ColorA.G + (int32)ColorB.G) / 2;\n\t\tconst int32 B = ((int32)ColorA.B + (int32)ColorB.B) / 2;\n\t\tconst int32 A = ((int32)ColorA.A + (int32)ColorB.A) / 2;\n\t\treturn FColor((uint8)R, (uint8)G, (uint8)B, (uint8)A);\n\t}\n}\n\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n//----------------------------------------------------------------------//\n//  UMassZoneGraphLocationInitializer\n//----------------------------------------------------------------------//\nUMassZoneGraphLocationInitializer::UMassZoneGraphLocationInitializer()\n\t: EntityQuery(*this)\n{\n\tObservedType = FMassZoneGraphLaneLocationFragment::StaticStruct();\n\tOperation = EMassObservedOperation::Add;\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n}\n\nvoid UMassZoneGraphLocationInitializer::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassZoneGraphLaneLocationFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadWrite); // Make optional?\n\tEntityQuery.AddConstSharedRequirement<FMassZoneGraphNavigationParameters>(EMassFragmentPresence::All);\n\tEntityQuery.AddSubsystemRequirement<UZoneGraphSubsystem>(EMassFragmentAccess::ReadOnly);\n}\n\nvoid UMassZoneGraphLocationInitializer::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tconst UZoneGraphSubsystem& ZoneGraphSubsystem = Context.GetSubsystemChecked<UZoneGraphSubsystem>();\n\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tconst TArrayView<FMassZoneGraphLaneLocationFragment> LaneLocationList = Context.GetMutableFragmentView<FMassZoneGraphLaneLocationFragment>();\n\t\tconst TArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetMutableFragmentView<FMassMoveTargetFragment>();\n\t\tconst TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();\n\t\tconst FMassZoneGraphNavigationParameters& NavigationParams = Context.GetConstSharedFragment<FMassZoneGraphNavigationParameters>();\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tconst FTransformFragment& Transform = TransformList[EntityIndex];\n\t\t\tconst FVector& AgentLocation = Transform.GetTransform().GetLocation();\n\t\t\tFMassMoveTargetFragment& MoveTarget = MoveTargetList[EntityIndex];\n\t\t\tFMassZoneGraphLaneLocationFragment& LaneLocation = LaneLocationList[EntityIndex];\n\n\t\t\tconst FVector QuerySize(NavigationParams.QueryRadius);\n\t\t\tconst FBox QueryBounds(AgentLocation - QuerySize, AgentLocation + QuerySize);\n\t\t\t\n\t\t\tFZoneGraphLaneLocation NearestLane;\n\t\t\tfloat NearestLaneDistSqr = 0;\n\t\t\t\n\t\t\tif (ZoneGraphSubsystem.FindNearestLane(QueryBounds, NavigationParams.LaneFilter, NearestLane, NearestLaneDistSqr))\n\t\t\t{\n\t\t\t\tconst FZoneGraphStorage* ZoneGraphStorage = ZoneGraphSubsystem.GetZoneGraphStorage(NearestLane.LaneHandle.DataHandle);\n\t\t\t\tcheck(ZoneGraphStorage); // Assume valid storage since we just got result.\n\n\t\t\t\tLaneLocation.LaneHandle = NearestLane.LaneHandle;\n\t\t\t\tLaneLocation.DistanceAlongLane = NearestLane.DistanceAlongLane;\n\t\t\t\tUE::ZoneGraph::Query::GetLaneLength(*ZoneGraphStorage, LaneLocation.LaneHandle, LaneLocation.LaneLength);\n\t\t\t\t\n\t\t\t\tMoveTarget.Center = AgentLocation;\n\t\t\t\tMoveTarget.Forward = NearestLane.Tangent;\n\t\t\t\tMoveTarget.DistanceToGoal = 0.0f;\n\t\t\t\tMoveTarget.SlackRadius = 0.0f;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLaneLocation.LaneHandle.Reset();\n\t\t\t\tLaneLocation.DistanceAlongLane = 0.0f;\n\t\t\t\tLaneLocation.LaneLength = 0.0f;\n\n\t\t\t\tMoveTarget.Center = AgentLocation;\n\t\t\t\tMoveTarget.Forward = FVector::ForwardVector;\n\t\t\t\tMoveTarget.DistanceToGoal = 0.0f;\n\t\t\t\tMoveTarget.SlackRadius = 0.0f;\n\t\t\t}\n\t\t}\n\t});\n}\n\n\n//----------------------------------------------------------------------//\n//  UMassZoneGraphPathFollowProcessor\n//----------------------------------------------------------------------//\nUMassZoneGraphPathFollowProcessor::UMassZoneGraphPathFollowProcessor()\n\t: EntityQuery_Conditional(*this)\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Tasks;\n\tExecutionOrder.ExecuteBefore.Add(UE::Mass::ProcessorGroupNames::Avoidance);\n}\n\nvoid UMassZoneGraphPathFollowProcessor::Initialize(UObject& Owner)\n{\n\tSuper::Initialize(Owner);\n\tSignalSubsystem = UWorld::GetSubsystem<UMassSignalSubsystem>(Owner.GetWorld());\n}\n\nvoid UMassZoneGraphPathFollowProcessor::ConfigureQueries()\n{\n\tEntityQuery_Conditional.AddRequirement<FMassZoneGraphShortPathFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery_Conditional.AddRequirement<FMassZoneGraphLaneLocationFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery_Conditional.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery_Conditional.AddRequirement<FMassSimulationLODFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tEntityQuery_Conditional.AddRequirement<FMassSimulationVariableTickFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\n\tEntityQuery_Conditional.AddChunkRequirement<FMassSimulationVariableTickChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tEntityQuery_Conditional.SetChunkFilter(&FMassSimulationVariableTickChunkFragment::ShouldTickChunkThisFrame);\n\n\tEntityQuery_Conditional.AddSubsystemRequirement<UZoneGraphSubsystem>(EMassFragmentAccess::ReadOnly);\n}\n\nvoid UMassZoneGraphPathFollowProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tif (!SignalSubsystem)\n\t{\n\t\treturn;\n\t}\n\t\n\tTArray<FMassEntityHandle> EntitiesToSignalPathDone;\n\tTArray<FMassEntityHandle> EntitiesToSignalLaneChanged;\n\n\tEntityQuery_Conditional.ForEachEntityChunk(EntityManager, Context, [this, &EntitiesToSignalPathDone, &EntitiesToSignalLaneChanged](FMassExecutionContext& Context)\n\t{\n\t\tconst UZoneGraphSubsystem& ZoneGraphSubsystem = Context.GetSubsystemChecked<UZoneGraphSubsystem>();\n\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tconst TArrayView<FMassZoneGraphShortPathFragment> ShortPathList = Context.GetMutableFragmentView<FMassZoneGraphShortPathFragment>();\n\t\tconst TArrayView<FMassZoneGraphLaneLocationFragment> LaneLocationList = Context.GetMutableFragmentView<FMassZoneGraphLaneLocationFragment>();\n\t\tconst TArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetMutableFragmentView<FMassMoveTargetFragment>();\n\t\tconst TConstArrayView<FMassSimulationLODFragment> SimLODList = Context.GetFragmentView<FMassSimulationLODFragment>();\n\t\tconst bool bHasLOD = (SimLODList.Num() > 0);\n\t\tconst TConstArrayView<FMassSimulationVariableTickFragment> SimVariableTickList = Context.GetFragmentView<FMassSimulationVariableTickFragment>();\n\t\tconst bool bHasVariableTick = (SimVariableTickList.Num() > 0);\n\t\tconst float WorldDeltaTime = Context.GetDeltaTimeSeconds();\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tFMassZoneGraphShortPathFragment& ShortPath = ShortPathList[EntityIndex];\n\t\t\tFMassZoneGraphLaneLocationFragment& LaneLocation = LaneLocationList[EntityIndex];\n\t\t\tFMassMoveTargetFragment& MoveTarget = MoveTargetList[EntityIndex];\n\t\t\tconst FMassEntityHandle Entity = Context.GetEntity(EntityIndex);\n\t\t\tconst float DeltaTime = bHasVariableTick ? SimVariableTickList[EntityIndex].DeltaTime : WorldDeltaTime;\n\n\t\t\tbool bDisplayDebug = false;\n#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT // this will result in bDisplayDebug == false and disabling of all the vlogs below\n\t\t\tbDisplayDebug = UE::Mass::Debug::IsDebuggingEntity(Entity);\n\t\t\tif (bDisplayDebug)\n\t\t\t{\n\t\t\t\tUE_VLOG(this, LogMassNavigation, Log, TEXT(\"Entity [%s] Updating path following\"), *Entity.DebugGetDescription());\n\t\t\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t\t\t// Must have at least two points to interpolate.\n\t\t\tif (MoveTarget.GetCurrentAction() == EMassMovementAction::Move && ShortPath.NumPoints >= 2)\n\t\t\t{\n\t\t\t\tconst bool bWasDone = ShortPath.IsDone();\n\n\t\t\t\t// Note: this should be in sync with the logic in apply velocity.\n\t\t\t\tconst bool bHasSteering = (bHasLOD == false) || (SimLODList[EntityIndex].LOD != EMassLOD::Off);\n\n\t\t\t\tif (!bHasSteering || !MoveTarget.bSteeringFallingBehind)\n\t\t\t\t{\n\t\t\t\t\t// Update progress\n\t\t\t\t\tShortPath.ProgressDistance += MoveTarget.DesiredSpeed.Get() * DeltaTime;\n\t\t\t\t}\n\n\t\t\t\t// @todo MassMovement: Ideally we would carry over any left over distance to the next path, especially when dealing with larger timesteps.\n\t\t\t\t// @todo MassMovement: Feedback current movement progress back to ShortPath.DesiredSpeed.\n\n\t\t\t\tif (!bWasDone)\n\t\t\t\t{\n\t\t\t\t\tconst uint8 LastPointIndex = ShortPath.NumPoints - 1;\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\t\t\t\tensureMsgf(LaneLocation.LaneHandle == ShortPath.DebugLaneHandle, TEXT(\"Short path lane should match current lane location.\"));\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t\t\t\t\tif (ShortPath.ProgressDistance <= 0.0f)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Requested time before the start of the path\n\t\t\t\t\t\tLaneLocation.DistanceAlongLane = ShortPath.Points[0].DistanceAlongLane.Get();\n\t\t\t\t\t\t\n\t\t\t\t\t\tMoveTarget.Center = ShortPath.Points[0].Position;\n\t\t\t\t\t\tMoveTarget.Forward = ShortPath.Points[0].Tangent.GetVector();\n\t\t\t\t\t\tMoveTarget.DistanceToGoal = ShortPath.Points[LastPointIndex].Distance.Get();\n\t\t\t\t\t\tMoveTarget.bOffBoundaries = ShortPath.Points[0].bOffLane;\n\n\t\t\t\t\t\tUE_CVLOG(bDisplayDebug,this, LogMassNavigation, Verbose, TEXT(\"Entity [%s] before start of lane %s at distance %.1f. Distance to goal: %.1f. Off Boundaries: %s\"),\n\t\t\t\t\t\t\t*Entity.DebugGetDescription(),\n\t\t\t\t\t\t\t*LaneLocation.LaneHandle.ToString(),\n\t\t\t\t\t\t\tLaneLocation.DistanceAlongLane,\n\t\t\t\t\t\t\tMoveTarget.DistanceToGoal,\n\t\t\t\t\t\t\t*LexToString((bool)MoveTarget.bOffBoundaries));\n\t\t\t\t\t}\n\t\t\t\t\telse if (ShortPath.ProgressDistance <= ShortPath.Points[LastPointIndex].Distance.Get())\n\t\t\t\t\t{\n\t\t\t\t\t\t// Requested time along the path, interpolate.\n\t\t\t\t\t\tuint8 PointIndex = 0;\n\t\t\t\t\t\twhile (PointIndex < (ShortPath.NumPoints - 2))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst FMassZoneGraphPathPoint& NextPoint = ShortPath.Points[PointIndex + 1];\n\t\t\t\t\t\t\tif (ShortPath.ProgressDistance <= NextPoint.Distance.Get())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tPointIndex++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst FMassZoneGraphPathPoint& CurrPoint = ShortPath.Points[PointIndex];\n\t\t\t\t\t\tconst FMassZoneGraphPathPoint& NextPoint = ShortPath.Points[PointIndex + 1];\n\t\t\t\t\t\tconst float T = (ShortPath.ProgressDistance - CurrPoint.Distance.Get()) / (NextPoint.Distance.Get() - CurrPoint.Distance.Get());\n\t\t\t\t\t\t\n\t\t\t\t\t\tLaneLocation.DistanceAlongLane = FMath::Min(FMath::Lerp(CurrPoint.DistanceAlongLane.Get(), NextPoint.DistanceAlongLane.Get(), T), LaneLocation.LaneLength);\n\n\t\t\t\t\t\tMoveTarget.Center = FMath::Lerp(CurrPoint.Position, NextPoint.Position, T);\n\t\t\t\t\t\tMoveTarget.Forward = FMath::Lerp(CurrPoint.Tangent.GetVector(), NextPoint.Tangent.GetVector(), T).GetSafeNormal();\n\t\t\t\t\t\tMoveTarget.DistanceToGoal = ShortPath.Points[LastPointIndex].Distance.Get() - FMath::Lerp(CurrPoint.Distance.Get(), NextPoint.Distance.Get(), T);\n\t\t\t\t\t\tMoveTarget.bOffBoundaries = CurrPoint.bOffLane || NextPoint.bOffLane;\n\n\t\t\t\t\t\tUE_CVLOG(bDisplayDebug, this, LogMassNavigation, Verbose, TEXT(\"Entity [%s] along lane %s at distance %.1f. Distance to goal: %.1f. Off Boundaries: %s\"),\n\t\t\t\t\t\t\t*Entity.DebugGetDescription(),\n\t\t\t\t\t\t\t*LaneLocation.LaneHandle.ToString(),\n\t\t\t\t\t\t\tLaneLocation.DistanceAlongLane,\n\t\t\t\t\t\t\tMoveTarget.DistanceToGoal,\n\t\t\t\t\t\t\t*LexToString((bool)MoveTarget.bOffBoundaries));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Requested time after the end of the path, clamp to lane length in case quantization overshoots.\n\t\t\t\t\t\tLaneLocation.DistanceAlongLane = FMath::Min(ShortPath.Points[LastPointIndex].DistanceAlongLane.Get(), LaneLocation.LaneLength);\n\n\t\t\t\t\t\tMoveTarget.Center = ShortPath.Points[LastPointIndex].Position;\n\t\t\t\t\t\tMoveTarget.Forward = ShortPath.Points[LastPointIndex].Tangent.GetVector();\n\t\t\t\t\t\tMoveTarget.DistanceToGoal = 0.0f;\n\t\t\t\t\t\tMoveTarget.bOffBoundaries = ShortPath.Points[LastPointIndex].bOffLane;\n\n\t\t\t\t\t\tUE_CVLOG(bDisplayDebug, this, LogMassNavigation, Log, TEXT(\"Entity [%s] Finished path follow on lane %s at distance %f. Off Boundaries: %s\"),\n\t\t\t\t\t\t\t*Entity.DebugGetDescription(), *LaneLocation.LaneHandle.ToString(), LaneLocation.DistanceAlongLane, *LexToString((bool)MoveTarget.bOffBoundaries));\n\n\t\t\t\t\t\tif (bDisplayDebug)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tUE_VLOG(this, LogMassNavigation, Log, TEXT(\"Entity [%s] End of path.\"), *Entity.DebugGetDescription());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check to see if need advance to next lane.\n\t\t\t\t\t\tif (ShortPath.NextLaneHandle.IsValid())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst FZoneGraphStorage* ZoneGraphStorage = ZoneGraphSubsystem.GetZoneGraphStorage(LaneLocation.LaneHandle.DataHandle);\n\t\t\t\t\t\t\tif (ZoneGraphStorage != nullptr)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (ShortPath.NextExitLinkType == EZoneLaneLinkType::Outgoing)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfloat NewLaneLength = 0.f;\n\t\t\t\t\t\t\t\t\tUE::ZoneGraph::Query::GetLaneLength(*ZoneGraphStorage, ShortPath.NextLaneHandle, NewLaneLength);\n\n\t\t\t\t\t\t\t\t\tUE_CVLOG(bDisplayDebug, this, LogMassNavigation, Log, TEXT(\"Entity [%s] Switching to OUTGOING lane %s -> %s, new distance %f.\"),\n\t\t\t\t\t\t\t\t\t\t*Entity.DebugGetDescription(), *LaneLocation.LaneHandle.ToString(), *ShortPath.NextLaneHandle.ToString(), 0.f);\n\n\t\t\t\t\t\t\t\t\t// update lane location\n\t\t\t\t\t\t\t\t\tLaneLocation.LaneHandle = ShortPath.NextLaneHandle;\n\t\t\t\t\t\t\t\t\tLaneLocation.LaneLength = NewLaneLength;\n\t\t\t\t\t\t\t\t\tLaneLocation.DistanceAlongLane = 0.0f;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (ShortPath.NextExitLinkType == EZoneLaneLinkType::Incoming)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfloat NewLaneLength = 0.f;\n\t\t\t\t\t\t\t\t\tUE::ZoneGraph::Query::GetLaneLength(*ZoneGraphStorage, ShortPath.NextLaneHandle, NewLaneLength);\n\n\t\t\t\t\t\t\t\t\tUE_CVLOG(bDisplayDebug, this, LogMassNavigation, Log, TEXT(\"Entity [%s] Switching to INCOMING lane %s -> %s, new distance %f.\"),\n\t\t\t\t\t\t\t\t\t\t*Entity.DebugGetDescription(), *LaneLocation.LaneHandle.ToString(), *ShortPath.NextLaneHandle.ToString(), NewLaneLength);\n\n\t\t\t\t\t\t\t\t\t// update lane location\n\t\t\t\t\t\t\t\t\tLaneLocation.LaneHandle = ShortPath.NextLaneHandle;\n\t\t\t\t\t\t\t\t\tLaneLocation.LaneLength = NewLaneLength;\n\t\t\t\t\t\t\t\t\tLaneLocation.DistanceAlongLane = NewLaneLength;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (ShortPath.NextExitLinkType == EZoneLaneLinkType::Adjacent)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tFZoneGraphLaneLocation NewLocation;\n\t\t\t\t\t\t\t\t\tfloat DistanceSqr;\n\t\t\t\t\t\t\t\t\tif (UE::ZoneGraph::Query::FindNearestLocationOnLane(*ZoneGraphStorage, ShortPath.NextLaneHandle, MoveTarget.Center, MAX_flt, NewLocation, DistanceSqr))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tfloat NewLaneLength = 0.f;\n\t\t\t\t\t\t\t\t\t\tUE::ZoneGraph::Query::GetLaneLength(*ZoneGraphStorage, ShortPath.NextLaneHandle, NewLaneLength);\n\n\t\t\t\t\t\t\t\t\t\tUE_CVLOG(bDisplayDebug, this, LogMassNavigation, Log, TEXT(\"Entity [%s] Switching to ADJACENT lane %s -> %s, new distance %f.\"),\n\t\t\t\t\t\t\t\t\t\t\t*Entity.DebugGetDescription(), *LaneLocation.LaneHandle.ToString(), *ShortPath.NextLaneHandle.ToString(), NewLocation.DistanceAlongLane);\n\n\t\t\t\t\t\t\t\t\t\t// update lane location\n\t\t\t\t\t\t\t\t\t\tLaneLocation.LaneHandle = ShortPath.NextLaneHandle;\n\t\t\t\t\t\t\t\t\t\tLaneLocation.LaneLength = NewLaneLength;\n\t\t\t\t\t\t\t\t\t\tLaneLocation.DistanceAlongLane = NewLocation.DistanceAlongLane;\n\n\t\t\t\t\t\t\t\t\t\tMoveTarget.Forward = NewLocation.Tangent;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tUE_CVLOG(bDisplayDebug, this, LogMassNavigation, Error, TEXT(\"Entity [%s] Failed to switch to ADJACENT lane %s -> %s.\"),\n\t\t\t\t\t\t\t\t\t\t\t*Entity.DebugGetDescription(), *LaneLocation.LaneHandle.ToString(), *ShortPath.NextLaneHandle.ToString());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tensureMsgf(false, TEXT(\"Unhandle NextExitLinkType type %s\"), *UEnum::GetValueAsString(ShortPath.NextExitLinkType));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Signal lane changed.\n\t\t\t\t\t\t\t\tEntitiesToSignalLaneChanged.Add(Entity);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tUE_CVLOG(bDisplayDebug, this, LogMassNavigation, Error, TEXT(\"Entity [%s] Could not find ZoneGraph storage for lane %s.\"),\n\t\t\t\t\t\t\t\t\t*Entity.DebugGetDescription(), *LaneLocation.LaneHandle.ToString());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tUE_CVLOG(bDisplayDebug, this, LogMassNavigation, Log, TEXT(\"Entity [%s] Next lane not defined.\"), *Entity.DebugGetDescription());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tShortPath.bDone = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst bool bIsDone = ShortPath.IsDone();\n\n\t\t\t\t// Signal path done.\n\t\t\t\tif (!bWasDone && bIsDone)\n\t\t\t\t{\n\t\t\t\t\tEntitiesToSignalPathDone.Add(Entity);\n\t\t\t\t}\n\n#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT\n\t\t\t\tif (bDisplayDebug)\n\t\t\t\t{\n\t\t\t\t\tconst FColor EntityColor = UE::Mass::Debug::GetEntityDebugColor(Entity);\n\n\t\t\t\t\tconst FVector ZOffset(0,0,25);\n\t\t\t\t\tconst FColor LightEntityColor = UE::MassNavigation::Debug::MixColors(EntityColor, FColor::White);\n\t\t\t\t\t\n\t\t\t\t\tfor (uint8 PointIndex = 0; PointIndex < ShortPath.NumPoints - 1; PointIndex++)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst FMassZoneGraphPathPoint& CurrPoint = ShortPath.Points[PointIndex];\n\t\t\t\t\t\tconst FMassZoneGraphPathPoint& NextPoint = ShortPath.Points[PointIndex + 1];\n\n\t\t\t\t\t\t// Path\n\t\t\t\t\t\tUE_VLOG_SEGMENT_THICK(this, LogMassNavigation, Display, CurrPoint.Position + ZOffset, NextPoint.Position + ZOffset, EntityColor, /*Thickness*/3, TEXT(\"\"));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (uint8 PointIndex = 0; PointIndex < ShortPath.NumPoints; PointIndex++)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst FMassZoneGraphPathPoint& CurrPoint = ShortPath.Points[PointIndex];\n\t\t\t\t\t\tconst FVector CurrBase = CurrPoint.Position + ZOffset;\n\t\t\t\t\t\t// Lane tangents\n\t\t\t\t\t\tUE_VLOG_SEGMENT_THICK(this, LogMassNavigation, Display, CurrBase, CurrBase + CurrPoint.Tangent.GetVector() * 100.0f, LightEntityColor, /*Thickness*/1, TEXT(\"\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ShortPath.NumPoints > 0 && ShortPath.NextLaneHandle.IsValid())\n\t\t\t\t\t{\n\t\t\t\t\t\tconst FMassZoneGraphPathPoint& LastPoint = ShortPath.Points[ShortPath.NumPoints - 1];\n\t\t\t\t\t\tconst FVector CurrBase = LastPoint.Position + ZOffset;\n\t\t\t\t\t\tUE_VLOG_SEGMENT_THICK(this, LogMassNavigation, Display, CurrBase, CurrBase + FVector(0,0,100), FColor::Red, /*Thickness*/3, TEXT(\"Next: %s\"), *ShortPath.NextLaneHandle.ToString());\n\t\t\t\t\t}\n\t\t\t\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t\t\t}\n\t\t}\n\t});\n\n\tif (EntitiesToSignalPathDone.Num())\n\t{\n\t\tSignalSubsystem->SignalEntities(UE::Mass::Signals::FollowPointPathDone, EntitiesToSignalPathDone);\n\t}\n\tif (EntitiesToSignalLaneChanged.Num())\n\t{\n\t\tSignalSubsystem->SignalEntities(UE::Mass::Signals::CurrentLaneChanged, EntitiesToSignalLaneChanged);\n\t}\n}\n\n\n\n//----------------------------------------------------------------------//\n//  UMassZoneGraphLaneCacheBoundaryProcessor\n//----------------------------------------------------------------------//\nUMassZoneGraphLaneCacheBoundaryProcessor::UMassZoneGraphLaneCacheBoundaryProcessor()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\n\tbAutoRegisterWithProcessingPhases = true;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LOD);\n\tExecutionOrder.ExecuteBefore.Add(UE::Mass::ProcessorGroupNames::Avoidance);\n}\n\nvoid UMassZoneGraphLaneCacheBoundaryProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassZoneGraphCachedLaneFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassZoneGraphLaneLocationFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassLaneCacheBoundaryFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassNavigationEdgesFragment>(EMassFragmentAccess::ReadWrite);\t// output edges\n\tEntityQuery.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);\n}\n\nvoid UMassZoneGraphLaneCacheBoundaryProcessor::Initialize(UObject& Owner)\n{\n\tSuper::Initialize(Owner);\n\n\tWeakWorld = Owner.GetWorld();\n}\n\nvoid UMassZoneGraphLaneCacheBoundaryProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tQUICK_SCOPE_CYCLE_COUNTER(MassLaneCacheBoundaryProcessor);\n\n\tconst UWorld* World = WeakWorld.Get();\n\tif (!World)\n\t{\n\t\treturn;\n\t}\n\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this, World](FMassExecutionContext& Context)\n\t{\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\n\t\tTConstArrayView<FMassZoneGraphCachedLaneFragment> CachedLaneList = Context.GetFragmentView<FMassZoneGraphCachedLaneFragment>();\n\t\tTConstArrayView<FMassZoneGraphLaneLocationFragment> LaneLocationList = Context.GetFragmentView<FMassZoneGraphLaneLocationFragment>();\n\t\tTConstArrayView<FMassMoveTargetFragment> MovementTargetList = Context.GetFragmentView<FMassMoveTargetFragment>();\n\t\tTArrayView<FMassLaneCacheBoundaryFragment> LaneCacheBoundaryList = Context.GetMutableFragmentView<FMassLaneCacheBoundaryFragment>();\n\t\tTArrayView<FMassNavigationEdgesFragment> EdgesList = Context.GetMutableFragmentView<FMassNavigationEdgesFragment>();\n\n\t\tTArray<FZoneGraphLinkedLane> LinkedLanes;\n\t\tLinkedLanes.Reserve(4);\t\n\t\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tconst FMassZoneGraphCachedLaneFragment& CachedLane = CachedLaneList[EntityIndex];\n\t\t\tconst FMassZoneGraphLaneLocationFragment& LaneLocation = LaneLocationList[EntityIndex];\n\t\t\tconst FMassMoveTargetFragment& MovementTarget = MovementTargetList[EntityIndex];\n\t\t\tFMassNavigationEdgesFragment& Edges = EdgesList[EntityIndex];\n\t\t\tFMassLaneCacheBoundaryFragment& LaneCacheBoundary = LaneCacheBoundaryList[EntityIndex];\n\t\t\tconst FMassEntityHandle Entity = Context.GetEntity(EntityIndex);\n\n\t\t\t// First check if we moved enough for an update\n\t\t\tconst FVector::FReal DeltaDistSquared = FVector::DistSquared(MovementTarget.Center, LaneCacheBoundary.LastUpdatePosition);\n\t\t\tconst FVector::FReal UpdateDistanceThresholdSquared = FMath::Square(50.);\n\n#if WITH_MASSGAMEPLAY_DEBUG && 0\n\t\t\tconst FDebugContext ObstacleDebugContext(this, LogAvoidanceObstacles, World, Entity);\n\t\t\tif (DebugIsSelected(Entity))\n\t\t\t{\n\t\t\t\tDebugDrawSphere(ObstacleDebugContext, LaneCacheBoundary.LastUpdatePosition, /*Radius=*/10.f, FColor(128,128,128));\n\t\t\t\tDebugDrawSphere(ObstacleDebugContext, MovementTarget.Center, /*Radius=*/10.f, FColor(255,255,255));\n\t\t\t}\n#endif\n\t\n\t\t\tif (DeltaDistSquared < UpdateDistanceThresholdSquared && CachedLane.CacheID == LaneCacheBoundary.LastUpdateCacheID)\n\t\t\t{\n\t\t\t\t// Not moved enough\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tLaneCacheBoundary.LastUpdatePosition = MovementTarget.Center;\n\t\t\tLaneCacheBoundary.LastUpdateCacheID = CachedLane.CacheID;\n\n\t\t\t// If we are skipping the update we don't want to reset the edges, we just want to execute up to the display of the lane.\n\t\t\tEdges.AvoidanceEdges.Reset();\n\t\t\tif (CachedLane.NumPoints < 2)\n\t\t\t{\n\t\t\t\t// Nothing to do\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\n#if WITH_MASSGAMEPLAY_DEBUG && 0\n\t\t\tif (DebugIsSelected(Entity))\n\t\t\t{\n\t\t\t\tDebugDrawSphere(ObstacleDebugContext, MovementTarget.Center, /*Radius=*/100.f, FColor(128,128,128));\n\t\t\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t\t\tconst float HalfWidth = 0.5f * CachedLane.LaneWidth.Get();\n\n\t\t\tstatic const int32 MaxPoints = 4;\n\t\t\tFVector Points[MaxPoints];\n\t\t\tFVector SegmentDirections[MaxPoints];\n\t\t\tFVector SegmentNormals[MaxPoints];\n\t\t\tFVector MiterDirections[MaxPoints];\n\n\t\t\tconst int32 CurrentSegment = CachedLane.FindSegmentIndexAtDistance(LaneLocation.DistanceAlongLane);\n\t\t\tconst int32 FirstSegment = FMath::Max(0, CurrentSegment - 1); // Segment should always be <= CachedLane.NumPoints - 2\n\t\t\tconst int32 LastSegment = FMath::Min(CurrentSegment + 1, (int32)CachedLane.NumPoints - 2); // CachedLane.NumPoints - 1 is the lane last point, CachedLane.NumPoints - 2 is the lane last segment\n\t\t\tconst int32 NumPoints = (LastSegment - FirstSegment + 1) + 1; // NumPoint = NumSegment + 1\n\t\t\tcheck(NumPoints >= 2);\n\t\t\tcheck(NumPoints <= MaxPoints);\n\t\t\t\n\t\t\t// Get points\n\t\t\tfor (int32 Index = 0; Index < NumPoints; Index++)\n\t\t\t{\n\t\t\t\tPoints[Index] = CachedLane.LanePoints[Index];\n\t\t\t}\n\t\t\t\n\t\t\t// Calculate segment direction and normal. Normal points to left, away from the segment.  \n\t\t\tfor (int32 Index = 0; Index < NumPoints - 1; Index++)\n\t\t\t{\n\t\t\t\tSegmentDirections[Index] = (Points[Index + 1] - Points[Index]).GetSafeNormal();\n\t\t\t\tSegmentNormals[Index] = UE::MassNavigation::GetLeftDirection(SegmentDirections[Index], FVector::UpVector);\n\t\t\t}\n\n\t\t\t// Last point inherits the direction from the last segment.\n\t\t\tSegmentDirections[NumPoints - 1] = SegmentDirections[NumPoints - 2];\n\t\t\tSegmentNormals[NumPoints - 1] = SegmentNormals[NumPoints - 2];\n\n\t\t\t// Calculate miter directions at inner corners.\n\t\t\t// Note, mitered direction is average of the adjacent edge left directions, and scaled so that the expanded edges are parallel to the stem.\n\t\t\t// First and last point dont have adjacent segments, and not mitered.\n\t\t\tMiterDirections[0] = SegmentNormals[0];\n\t\t\tMiterDirections[NumPoints - 1] = SegmentNormals[NumPoints - 1];\n\t\t\tfor (int32 Index = 1; Index < NumPoints - 1; Index++)\n\t\t\t{\n\t\t\t\tMiterDirections[Index] = UE::MassNavigation::ComputeMiterNormal(SegmentNormals[Index - 1], SegmentNormals[Index]);\n\t\t\t}\n\n\t\t\t// Compute left and right positions from lane width and miter directions.\n\t\t\tconst float LeftWidth = HalfWidth + CachedLane.LaneLeftSpace.Get();\n\t\t\tconst float RightWidth = HalfWidth + CachedLane.LaneRightSpace.Get();\n\t\t\tFVector LeftPositions[MaxPoints];\n\t\t\tFVector RightPositions[MaxPoints];\n\t\t\tfor (int32 Index = 0; Index < NumPoints; Index++)\n\t\t\t{\n\t\t\t\tconst FVector MiterDir = MiterDirections[Index];\n\t\t\t\tLeftPositions[Index] = Points[Index] + LeftWidth * MiterDir;\n\t\t\t\tRightPositions[Index] = Points[Index] - RightWidth * MiterDir;\n\t\t\t}\n\t\t\tint32 NumLeftPositions = NumPoints;\n\t\t\tint32 NumRightPositions = NumPoints;\n\n\n#if 0 && WITH_MASSGAMEPLAY_DEBUG // Detailed debug disabled\n\t\t\tif (DebugIsSelected(Entity))\n\t\t\t{\n\t\t\t\tfloat Radius = 2.f;\n\t\t\t\tfor (int32 Index = 0; Index < NumPoints; Index++)\n\t\t\t\t{\n\t\t\t\t\tif (Index < NumPoints - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tDebugDrawLine(ObstacleDebugContext, Points[Index], Points[Index + 1], FColor::Blue, /*Thickness=*/6.f);\n\t\t\t\t\t}\n\t\t\t\t\tDebugDrawSphere(ObstacleDebugContext, Points[Index], Radius, FColor::Blue);\n\t\t\t\t\tDebugDrawSphere(ObstacleDebugContext, LeftPositions[Index], Radius, FColor::Green);\n\t\t\t\t\tDebugDrawSphere(ObstacleDebugContext, RightPositions[Index], Radius, FColor::Red);\n\t\t\t\t\tRadius += 4.f;\n\t\t\t\t}\n\t\t\t}\n#endif //WITH_MASSGAMEPLAY_DEBUG\n\n\t\t\t// Remove edges crossing when there are 3 edges.\n\t\t\tif (NumPoints == 4)\n\t\t\t{\n\t\t\t\tFVector Intersection = FVector::ZeroVector;\n\t\t\t\tif (FMath::SegmentIntersection2D(LeftPositions[0], LeftPositions[1], LeftPositions[2], LeftPositions[3], Intersection))\n\t\t\t\t{\n\t\t\t\t\tLeftPositions[1] = Intersection;\n\t\t\t\t\tLeftPositions[2] = LeftPositions[3];\n\t\t\t\t\tNumLeftPositions--;\n\t\t\t\t}\n\n\t\t\t\tIntersection = FVector::ZeroVector;\n\t\t\t\tif (FMath::SegmentIntersection2D(RightPositions[0], RightPositions[1], RightPositions[2], RightPositions[3], Intersection))\n\t\t\t\t{\n\t\t\t\t\tRightPositions[1] = Intersection;\n\t\t\t\t\tRightPositions[2] = RightPositions[3];\n\t\t\t\t\tNumRightPositions--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add edges\n\t\t\tfor (int32 Index = 0; Index < NumLeftPositions - 1; Index++)\n\t\t\t{\n\t\t\t\tEdges.AvoidanceEdges.Add(FNavigationAvoidanceEdge(LeftPositions[Index + 1], LeftPositions[Index])); // Left side: reverse start and end to keep the normal inside.\n\t\t\t}\n\n\t\t\tfor (int32 Index = 0; Index < NumRightPositions - 1; Index++)\n\t\t\t{\n\t\t\t\tEdges.AvoidanceEdges.Add(FNavigationAvoidanceEdge(RightPositions[Index], RightPositions[Index + 1]));\n\t\t\t}\n\t\t}\n\t});\n}\n\n#undef UNSAFE_FOR_MT\n",
      "lines": 622
    },
    {
      "file_path": "MassAI\\MassZoneGraphNavigation\\Private\\MassZoneGraphNavigationTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 1247,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n#include \"MassZoneGraphNavigationTrait.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassNavigationFragments.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"Engine/World.h\"\n#include \"MassEntityUtils.h\"\n\n\nvoid UMassZoneGraphNavigationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tFMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(World);\n\n\tBuildContext.RequireFragment<FAgentRadiusFragment>();\n\tBuildContext.RequireFragment<FTransformFragment>();\n\tBuildContext.RequireFragment<FMassVelocityFragment>();\n\tBuildContext.RequireFragment<FMassMoveTargetFragment>();\n\n\tBuildContext.AddFragment<FMassZoneGraphLaneLocationFragment>();\n\tBuildContext.AddFragment<FMassZoneGraphPathRequestFragment>();\n\tBuildContext.AddFragment<FMassZoneGraphShortPathFragment>();\n\tBuildContext.AddFragment<FMassZoneGraphCachedLaneFragment>();\n\n\tconst FConstSharedStruct ZGMovementParamsFragment = EntityManager.GetOrCreateConstSharedFragment(NavigationParameters);\n\tBuildContext.AddConstSharedFragment(ZGMovementParamsFragment);\n}\n",
      "lines": 28
    },
    {
      "file_path": "MassAI\\MassZoneGraphNavigation\\Private\\MassZoneGraphNavigationUtils.cpp",
      "extension": ".cpp",
      "size_bytes": 5106,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassZoneGraphNavigationUtils.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassNavigationFragments.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"ZoneGraphSubsystem.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassDebugger.h\"\n\nnamespace UE::MassNavigation\n{\n\tstatic constexpr float InflateDistance = 200.0f; // @todo: make a setting.\n\n\tbool ActivateActionMove(const UWorld& World,\n\t\t\t\t\t\t\tconst UObject* Requester,\n\t\t\t\t\t\t\tconst FMassEntityHandle Entity,\n\t\t\t\t\t\t\tconst UZoneGraphSubsystem& ZoneGraphSubsystem,\n\t\t\t\t\t\t\tconst FMassZoneGraphLaneLocationFragment& LaneLocation,\n\t\t\t\t\t\t\tconst FZoneGraphShortPathRequest& PathRequest,\n\t\t\t\t\t\t\tconst float AgentRadius,\n\t\t\t\t\t\t\tconst float DesiredSpeed,\n\t\t\t\t\t\t\tFMassMoveTargetFragment& MoveTarget,\n\t\t\t\t\t\t\tFMassZoneGraphShortPathFragment& ShortPath,\n\t\t\t\t\t\t\tFMassZoneGraphCachedLaneFragment& CachedLane)\n\t{\n\t\tShortPath.Reset();\n\t\tCachedLane.Reset();\n\t\tMoveTarget.DistanceToGoal = 0.0f;\n\t\tMoveTarget.DesiredSpeed.Set(0.0f);\n\n\t\tif (!ensureMsgf(MoveTarget.GetCurrentAction() == EMassMovementAction::Move, TEXT(\"Expecting action 'Move': Invalid action %u\"), MoveTarget.GetCurrentAction()))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tconst FZoneGraphStorage* ZoneGraphStorage = ZoneGraphSubsystem.GetZoneGraphStorage(LaneLocation.LaneHandle.DataHandle);\n\t\tif (ZoneGraphStorage == nullptr)\n\t\t{\n\t\t\tUE_VLOG(Requester, LogMassNavigation, Error, TEXT(\"Entity [%s] move request failed: missing ZoneGraph Storage for current lane %s.\"),\n\t\t\t\t*Entity.DebugGetDescription(),\n\t\t\t\t*LaneLocation.LaneHandle.ToString());\n\t\t\treturn false;\n\t\t}\n\n\t\tMoveTarget.IntentAtGoal = EMassMovementAction::Stand;\n\t\tMoveTarget.DesiredSpeed.Set(DesiredSpeed);\n\n\t\tCachedLane.CacheLaneData(*ZoneGraphStorage, LaneLocation.LaneHandle, LaneLocation.DistanceAlongLane, PathRequest.TargetDistance, InflateDistance);\n\t\tif (ShortPath.RequestPath(CachedLane, PathRequest, LaneLocation.DistanceAlongLane, AgentRadius))\n\t\t{\n\t\t\tMoveTarget.IntentAtGoal = ShortPath.EndOfPathIntent;\n\t\t\tMoveTarget.DistanceToGoal = (ShortPath.NumPoints > 0) ? ShortPath.Points[ShortPath.NumPoints - 1].DistanceAlongLane.Get() : 0.0f;\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\t\tUE_CVLOG(UE::Mass::Debug::IsDebuggingEntity(Entity),\n\t\t\t\tRequester,\n\t\t\t\tLogMassNavigation,\n\t\t\t\tLog,\n\t\t\t\tTEXT(\"Move %s, on lane %s, from %.1fcm to %.1fcm, next lane %s.\"),\n\t\t\t\tPathRequest.bMoveReverse ? TEXT(\"reverse\") : TEXT(\"forward\"),\n\t\t\t\t*LaneLocation.LaneHandle.ToString(),\n\t\t\t\tLaneLocation.DistanceAlongLane,\n\t\t\t\tPathRequest.TargetDistance,\n\t\t\t\t*PathRequest.NextLaneHandle.ToString());\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUE_VLOG(Requester, LogMassNavigation, Error, TEXT(\"Entity [%s] move request failed: unable to request path on lane %s.\"),\n\t\t\t\t*Entity.DebugGetDescription(),\n\t\t\t\t*LaneLocation.LaneHandle.ToString());\n\t\t\treturn false;\n\t\t}\n\n\t\tUE_VLOG(Requester, LogMassNavigation, Log, TEXT(\"Entity [%s] successfully requested %s\"), *Entity.DebugGetDescription(), *MoveTarget.ToString());\n\t\treturn true;\n\t}\n\n\tbool ActivateActionStand(const UWorld& World,\n\t\t\t\t\t\t\t const UObject* Requester,\n\t\t\t\t\t\t\t const FMassEntityHandle Entity,\n\t\t\t\t\t\t\t const UZoneGraphSubsystem& ZoneGraphSubsystem,\n\t\t\t\t\t\t\t const FMassZoneGraphLaneLocationFragment& LaneLocation,\n\t\t\t\t\t\t\t const float DesiredSpeed,\n\t\t\t\t\t\t\t FMassMoveTargetFragment& MoveTarget,\n\t\t\t\t\t\t\t FMassZoneGraphShortPathFragment& ShortPath,\n\t\t\t\t\t\t\t FMassZoneGraphCachedLaneFragment& CachedLane)\n\t{\n\t\tShortPath.Reset();\n\t\tCachedLane.Reset();\n\t\tMoveTarget.DistanceToGoal = 0.0f;\n\t\tMoveTarget.DesiredSpeed.Set(0.0f);\n\n\t\tif (!ensureMsgf(MoveTarget.GetCurrentAction() == EMassMovementAction::Stand, TEXT(\"Expecting action 'Stand': Invalid action %u\"), MoveTarget.GetCurrentAction()))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tconst FZoneGraphStorage* ZoneGraphStorage = ZoneGraphSubsystem.GetZoneGraphStorage(LaneLocation.LaneHandle.DataHandle);\n\n\t\tMoveTarget.IntentAtGoal = EMassMovementAction::Stand;\n\t\tMoveTarget.DesiredSpeed.Set(DesiredSpeed);\n\n\t\tCachedLane.CacheLaneData(*ZoneGraphStorage, LaneLocation.LaneHandle, LaneLocation.DistanceAlongLane, LaneLocation.DistanceAlongLane, InflateDistance);\n\n\t\tUE_VLOG(Requester, LogMassNavigation, Log, TEXT(\"Entity [%s] successfully requested %s\"), *Entity.DebugGetDescription(), *MoveTarget.ToString());\n\t\treturn true;\n\t}\n\n\tbool ActivateActionAnimate(const UWorld& World,\n\t\t\t\t\t\t\t   const UObject* Requester,\n\t\t\t\t\t\t\t   const FMassEntityHandle Entity,\n\t\t\t\t\t\t\t   FMassMoveTargetFragment& MoveTarget)\n\t{\n\t\tMoveTarget.DistanceToGoal = 0.0f;\n\t\tMoveTarget.DesiredSpeed.Set(0.0f);\n\n\t\tif (!ensureMsgf(MoveTarget.GetCurrentAction() == EMassMovementAction::Animate, TEXT(\"Expecting action 'Animate': Invalid action %u\"), MoveTarget.GetCurrentAction()))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tMoveTarget.IntentAtGoal = EMassMovementAction::Stand;\n\n\t\tUE_VLOG(Requester, LogMassNavigation, Log, TEXT(\"Entity [%s] successfully requested %s\"), *Entity.DebugGetDescription(), *MoveTarget.ToString());\n\t\treturn true;\n\t}\n}\n",
      "lines": 128
    },
    {
      "file_path": "MassCrowd\\Private\\MassCrowdBubble.cpp",
      "extension": ".cpp",
      "size_bytes": 7292,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCrowdBubble.h\"\n#include \"MassEntityManager.h\"\n#include \"Net/UnrealNetwork.h\"\n#include \"MassExecutionContext.h\"\n\nnamespace UE::Mass::Crowd\n{\n\tbool bDebugReplicationPositions = false;\n\tFAutoConsoleVariableRef CVarbDebugReplication(TEXT(\"mass.debug.CrowdReplicationPositions\"), bDebugReplicationPositions, TEXT(\"Crowd debug replication positions on server and client\"), ECVF_Cheat);\n\n#if WITH_MASSGAMEPLAY_DEBUG && WITH_EDITOR\n\t// @todo provide a better way of selecting agents to debug\n\tconstexpr int32 MaxAgentsDraw = 300;\n\n\tvoid DebugDrawReplicatedAgent(FMassEntityHandle Entity, const FMassEntityManager& EntityManager)\n\t{\n\t\tstatic const FVector DebugCylinderHeight = FVector(0.f, 0.f, 200.f);\n\t\tstatic constexpr float DebugCylinderRadius = 50.f;\n\n\t\tconst FMassEntityView EntityView(EntityManager, Entity);\n\n\t\tconst FTransformFragment& TransformFragment = EntityView.GetFragmentData<FTransformFragment>();\n\t\tconst FMassNetworkIDFragment& NetworkIDFragment = EntityView.GetFragmentData<FMassNetworkIDFragment>();\n\n\t\tconst FVector& Pos = TransformFragment.GetTransform().GetLocation();\n\t\tconst uint32 NetworkID = NetworkIDFragment.NetID.GetValue();\n\n\t\t// Multiply by a largeish number that is not a multiple of 256 to separate out the color shades a bit\n\t\tconst uint32 InitialColor = NetworkID * 20001;\n\n\t\tconst uint8 NetworkIdMod3 = NetworkID % 3;\n\t\tFColor DebugCylinderColor;\n\n\t\t// Make a deterministic color from the Mod by 3 to vary how we create it\n\t\tif (NetworkIdMod3 == 0)\n\t\t{\n\t\t\tDebugCylinderColor = FColor(InitialColor % 256, InitialColor / 256 % 256, InitialColor / 256 / 256 % 256);\n\t\t}\n\t\telse if (NetworkIdMod3 == 1)\n\t\t{\n\t\t\tDebugCylinderColor = FColor(InitialColor / 256 / 256 % 256, InitialColor % 256, InitialColor / 256 % 256);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDebugCylinderColor = FColor(InitialColor / 256 % 256, InitialColor / 256 / 256 % 256, InitialColor % 256);\n\t\t}\n\n\t\tconst UWorld* World = EntityManager.GetWorld();\n\t\tif (World != nullptr && World->GetNetMode() == NM_Client)\n\t\t{\n\t\t\tDrawDebugCylinder(World, Pos, Pos + 0.5f * DebugCylinderHeight, DebugCylinderRadius, /*segments = */24, DebugCylinderColor);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDrawDebugCylinder(World, Pos + 0.5f * DebugCylinderHeight, Pos + DebugCylinderHeight, DebugCylinderRadius, /*segments = */24, DebugCylinderColor);\n\t\t}\n\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG && WITH_EDITOR\n}\n\n#if WITH_MASSGAMEPLAY_DEBUG && WITH_EDITOR\nvoid FMassCrowdClientBubbleHandler::DebugValidateBubbleOnServer()\n{\n\tSuper::DebugValidateBubbleOnServer();\n\n#if UE_REPLICATION_COMPILE_SERVER_CODE\n\tif (UE::Mass::Crowd::bDebugReplicationPositions)\n\t{\n\t\tconst FMassEntityManager& EntityManager = Serializer->GetEntityManagerChecked();\n\n\t\t// @todo cap at MaxAgentsDraw for now\n\t\tconst int32 MaxAgentsDraw = FMath::Min(UE::Mass::Crowd::MaxAgentsDraw, (*Agents).Num());\n\n\t\tfor (int32 Idx = 0; Idx < MaxAgentsDraw; ++Idx)\n\t\t{\n\t\t\tconst FCrowdFastArrayItem& CrowdItem = (*Agents)[Idx];\n\n\t\t\tconst FMassAgentLookupData& LookupData = AgentLookupArray[CrowdItem.GetHandle().GetIndex()];\n\n\t\t\tcheck(LookupData.Entity.IsSet());\n\n\t\t\tUE::Mass::Crowd::DebugDrawReplicatedAgent(LookupData.Entity, EntityManager);\n\t\t}\n\t}\n#endif // UE_REPLICATION_COMPILE_SERVER_CODE\n}\n#endif // WITH_MASSGAMEPLAY_DEBUG && WITH_EDITOR\n\n#if WITH_MASSGAMEPLAY_DEBUG && WITH_EDITOR\nvoid FMassCrowdClientBubbleHandler::DebugValidateBubbleOnClient()\n{\n\tSuper::DebugValidateBubbleOnClient();\n\n\tif (UE::Mass::Crowd::bDebugReplicationPositions)\n\t{\n\t\tconst FMassEntityManager& EntityManager = Serializer->GetEntityManagerChecked();\n\n\t\tUMassReplicationSubsystem* ReplicationSubsystem = Serializer->GetReplicationSubsystem();\n\t\tcheck(ReplicationSubsystem);\n\n\t\t// @todo cap at MaxAgentsDraw for now\n\t\tconst int32 MaxAgentsDraw = FMath::Min(UE::Mass::Crowd::MaxAgentsDraw, (*Agents).Num());\n\n\t\tfor (int32 Idx = 0; Idx < MaxAgentsDraw; ++Idx)\n\t\t{\n\t\t\tconst FCrowdFastArrayItem& CrowdItem = (*Agents)[Idx];\n\n\t\t\tconst FMassReplicationEntityInfo* EntityInfo = ReplicationSubsystem->FindMassEntityInfo(CrowdItem.Agent.GetNetID());\n\n\t\t\tcheck(EntityInfo->Entity.IsSet());\n\n\t\t\tUE::Mass::Crowd::DebugDrawReplicatedAgent(EntityInfo->Entity, EntityManager);\n\t\t}\n\t}\n}\n#endif // WITH_MASSGAMEPLAY_DEBUG && WITH_EDITOR\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\nvoid FMassCrowdClientBubbleHandler::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)\n{\n\tauto AddRequirementsForSpawnQuery = [this](FMassEntityQuery& InQuery)\n\t{\n\t\tPathHandler.AddRequirementsForSpawnQuery(InQuery);\n\t\tTransformHandler.AddRequirementsForSpawnQuery(InQuery);\n\t};\n\n\tauto CacheFragmentViewsForSpawnQuery = [this](FMassExecutionContext& InExecContext)\n\t{\n\t\tPathHandler.CacheFragmentViewsForSpawnQuery(InExecContext);\n\t\tTransformHandler.CacheFragmentViewsForSpawnQuery(InExecContext);\n\t};\n\n\tauto SetSpawnedEntityData = [this](const FMassEntityView& EntityView, const FReplicatedCrowdAgent& ReplicatedEntity, const int32 EntityIdx)\n\t{\n\t\tPathHandler.SetSpawnedEntityData(EntityView, ReplicatedEntity.GetReplicatedPathData(), EntityIdx);\n\t\tTransformHandler.SetSpawnedEntityData(EntityIdx, ReplicatedEntity.GetReplicatedPositionYawData());\n\t};\n\n\tauto SetModifiedEntityData = [this](const FMassEntityView& EntityView, const FReplicatedCrowdAgent& Item)\n\t{\n\t\tPostReplicatedChangeEntity(EntityView, Item);\n\t};\n\n\tPostReplicatedAddHelper(AddedIndices, AddRequirementsForSpawnQuery, CacheFragmentViewsForSpawnQuery, SetSpawnedEntityData, SetModifiedEntityData);\n\n\tPathHandler.ClearFragmentViewsForSpawnQuery();\n\tTransformHandler.ClearFragmentViewsForSpawnQuery();\n}\n#endif //UE_REPLICATION_COMPILE_SERVER_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\nvoid FMassCrowdClientBubbleHandler::FMassCrowdClientBubbleHandler::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)\n{\n\tauto SetModifiedEntityData = [this](const FMassEntityView& EntityView, const FReplicatedCrowdAgent& Item)\n\t{\n\t\tPostReplicatedChangeEntity(EntityView, Item);\n\t};\n\n\tPostReplicatedChangeHelper(ChangedIndices, SetModifiedEntityData);\n}\n#endif //UE_REPLICATION_COMPILE_SERVER_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\nvoid FMassCrowdClientBubbleHandler::PostReplicatedChangeEntity(const FMassEntityView& EntityView, const FReplicatedCrowdAgent& Item) const\n{\n\tPathHandler.SetModifiedEntityData(EntityView, Item.GetReplicatedPathData());\n\n\t// No need to call TransformHandler as that only gets replicated when an agent is added to the bubble\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\nAMassCrowdClientBubbleInfo::AMassCrowdClientBubbleInfo(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n\tSerializers.Add(&CrowdSerializer);\n}\n\nvoid AMassCrowdClientBubbleInfo::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tFDoRepLifetimeParams SharedParams;\n\tSharedParams.bIsPushBased = true;\n\n\t// Technically, this doesn't need to be PushModel based because it's a FastArray and they ignore it.\n\tDOREPLIFETIME_WITH_PARAMS_FAST(AMassCrowdClientBubbleInfo, CrowdSerializer, SharedParams);\n}\n",
      "lines": 189
    },
    {
      "file_path": "MassCrowd\\Private\\MassCrowdLaneClosingTest.cpp",
      "extension": ".cpp",
      "size_bytes": 2104,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCrowdLaneClosingTest.h\"\n#include \"Engine/World.h\"\n#include \"MassCrowdSubsystem.h\"\n#include \"ZoneGraphRenderingUtilities.h\"\n\nvoid UZoneGraphCloseCrowdLaneTest::OnLaneLocationUpdated(const FZoneGraphLaneLocation& PrevLaneLocation, const FZoneGraphLaneLocation& NextLaneLocation)\n{\n\tif (CrowdSubsystem == nullptr)\n\t{\n\t\treturn;\n\t}\n\n\t// Extra checks here, because GetCrowdLaneData() will ensure() on bad handle. We can end up here when Crowd subsystem has already been torn down.\n\tif (PrevLaneLocation.IsValid() && CrowdSubsystem->HasCrowdDataForZoneGraph(PrevLaneLocation.LaneHandle.DataHandle))\n\t{\n\t\tCrowdSubsystem->SetLaneState(PrevLaneLocation.LaneHandle, PrevLaneState);\n\t}\n\n\tif (NextLaneLocation.IsValid() && CrowdSubsystem->HasCrowdDataForZoneGraph(NextLaneLocation.LaneHandle.DataHandle))\n\t{\n\t\tPrevLaneState = CrowdSubsystem->GetLaneState(NextLaneLocation.LaneHandle);\n\t\tCrowdSubsystem->SetLaneState(NextLaneLocation.LaneHandle, LaneState);\n\t}\n\n\tLaneLocation = NextLaneLocation;\n}\n\nvoid UZoneGraphCloseCrowdLaneTest::Draw(FPrimitiveDrawInterface* PDI) const\n{\n\tif (!LaneLocation.IsValid())\n\t{\n\t\treturn;\n\t}\n\t\n\tconst FZoneGraphStorage* Storage = OwnerComponent->GetZoneGraphStorage(LaneLocation.LaneHandle);\n\tif (Storage != nullptr)\n\t{\n\t\tTArray<FZoneGraphLaneHandle> Lanes;\n\t\tLanes.Push(LaneLocation.LaneHandle);\n\n\t\tFColor Color = FColor::White;\n\t\tswitch (LaneState)\n\t\t{\n\t\tcase ECrowdLaneState::Opened:\t\tColor = FColor::Emerald;\tbreak;\n\t\tcase ECrowdLaneState::Closed:\t\tColor = FColor::Red;\t\tbreak;\n\t\tdefault:\n\t\t\tensureMsgf(false, TEXT(\"Unhandled lane state %d\"), (int32)LaneState);\n\t\t\tbreak;\n\t\t}\n\n\t\tstatic constexpr float LaneLineThickness = 25.0f;\n\t\tUE::ZoneGraph::RenderingUtilities::DrawLanes(*Storage, PDI, Lanes, Color, LaneLineThickness);\n\t}\t\n}\n\nvoid UZoneGraphCloseCrowdLaneTest::OnOwnerSet()\n{\n\tif (OwnerComponent == nullptr)\n\t{\n\t\tCrowdSubsystem = nullptr;\n\t\treturn;\n\t}\n\n\tCrowdSubsystem = UWorld::GetSubsystem<UMassCrowdSubsystem>(OwnerComponent->GetWorld());\n}\n",
      "lines": 67
    },
    {
      "file_path": "MassCrowd\\Private\\MassCrowdLaneDataRenderingComponent.cpp",
      "extension": ".cpp",
      "size_bytes": 10909,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCrowdLaneDataRenderingComponent.h\"\n\n#include \"Engine/Engine.h\"\n#include \"MassCrowdSettings.h\"\n#include \"MassCrowdSubsystem.h\"\n#include \"PrimitiveViewRelevance.h\"\n#include \"ZoneGraphQuery.h\"\n#include \"ZoneGraphRenderingComponent.h\"\n#include \"ZoneGraphSubsystem.h\"\n#include \"Debug/DebugDrawService.h\"\n#include \"Engine/Canvas.h\"\n\n#if !UE_BUILD_SHIPPING && !UE_BUILD_TEST\nvoid UMassCrowdLaneDataRenderingComponent::OnRegister()\n{\n\tSuper::OnRegister();\n\n\tif (GetWorld()->IsGameWorld())\n\t{\n\t\tDebugTextDrawingDelegateHandle = UDebugDrawService::Register(TEXT(\"Navigation\"), FDebugDrawDelegate::CreateUObject(this, &UMassCrowdLaneDataRenderingComponent::DebugDrawOnCanvas));\n\n\t\t// Track lane state changes\n\t\tif (UMassCrowdSubsystem* MassCrowdSubsystem = UWorld::GetSubsystem<UMassCrowdSubsystem>(GetWorld()))\n\t\t{\n\t\t\tOnLaneStateChangedDelegateHandle = MassCrowdSubsystem->DebugOnMassCrowdLaneStateChanged.AddLambda([this]()\n\t\t\t{\n\t\t\t\tMarkRenderStateDirty();\n\t\t\t});\n\t\t}\n\t}\n\n#if WITH_EDITOR\n\t// Track render settings changes\n\tOnLaneRenderSettingsChangedDelegateHandle = GetDefault<UMassCrowdSettings>()->OnMassCrowdLaneRenderSettingsChanged.AddLambda([this]()\n\t{\n\t\tMarkRenderStateDirty();\n\t});\n#endif\n}\n\nvoid UMassCrowdLaneDataRenderingComponent::OnUnregister()\n{\n\tUDebugDrawService::Unregister(DebugTextDrawingDelegateHandle);\n\n\tif (UMassCrowdSubsystem* MassCrowdSubsystem = UWorld::GetSubsystem<UMassCrowdSubsystem>(GetWorld()))\n\t{\n\t\tMassCrowdSubsystem->DebugOnMassCrowdLaneStateChanged.Remove(OnLaneStateChangedDelegateHandle);\n\t}\n\n#if WITH_EDITOR\n\tGetDefault<UMassCrowdSettings>()->OnMassCrowdLaneDataSettingsChanged.Remove(OnLaneRenderSettingsChangedDelegateHandle);\n#endif\n\n\tSuper::OnUnregister();\n}\n\nFPrimitiveSceneProxy* UMassCrowdLaneDataRenderingComponent::CreateSceneProxy()\n{\n\tclass FMassCrowdLaneDataSceneProxy final : public FZoneGraphSceneProxy\n\t{\n\tpublic:\n\t\tfriend class UCrowdLaneDataRenderComponent;\n\n\t\tvirtual SIZE_T GetTypeHash() const override\n\t\t{\n\t\t\tstatic size_t UniquePointer;\n\t\t\treturn reinterpret_cast<size_t>(&UniquePointer);\n\t\t}\n\n\t\tFMassCrowdLaneDataSceneProxy(const UMassCrowdLaneDataRenderingComponent& InComponent, const AZoneGraphData& ZoneGraph)\n\t\t\t: FZoneGraphSceneProxy(InComponent, ZoneGraph)\n\t\t\t, Component(&InComponent)\n\t\t{\n\t\t\tconst UZoneGraphSubsystem* ZoneGraphSubsystem = UWorld::GetSubsystem<UZoneGraphSubsystem>(Component->GetWorld());\n\t\t\tconst UMassCrowdSubsystem* MassCrowdSubsystem = UWorld::GetSubsystem<UMassCrowdSubsystem>(Component->GetWorld());\n\t\t\tconst UMassCrowdSettings* Settings = GetDefault<UMassCrowdSettings>();\n\t\t\tcheckf(Settings, TEXT(\"Settings default object is always expected to be valid\"));\n\n\t\t\t// The subsystems could be removed during world tear down\n\t\t\tif (ZoneGraphSubsystem == nullptr || MassCrowdSubsystem == nullptr)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst FZoneGraphStorage& Storage = ZoneGraph.GetStorage();\n\t\t\t// Make sure we still have lane data since we can end up here when Crowd subsystem has already been torn down.\n\t\t\tif (!MassCrowdSubsystem->HasCrowdDataForZoneGraph(Storage.DataHandle))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Nothing to render if none of these options are enabled\n\t\t\tif (!(Settings->bDisplayStates || Settings->bDisplayDensities))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst FZoneGraphTag CrowdTag = Settings->CrowdTag;\n\t\t\tconst float LaneThickness = Settings->LaneBaseLineThickness;\n\t\t\tconst float IntersectionLaneThickness = Settings->IntersectionLaneScaleFactor * LaneThickness;\n\t\t\tconst FVector Offset(0.f, 0.f, Settings->LaneRenderZOffset);\n\n\t\t\tconst float LaneDensityThickness = Settings->LaneDensityScaleFactor * LaneThickness;\n\t\t\tconst float IntersectionLaneDensityThickness = Settings->LaneDensityScaleFactor * IntersectionLaneThickness;\n\t\t\tconst FVector LaneDensityOffset = 0.9f * Offset;\n\n\t\t\tauto AddLinesForLane = [this](const FZoneGraphStorage& Storage, const FZoneLaneData& Lane, const FColor Color, const float LineThickness, const FVector& Offset)\n\t\t\t{\n\t\t\t\tconst FVector OffsetZ(0.f, 0.f, 0.1f);\n\t\t\t\tFVector PrevPoint = Storage.LanePoints[Lane.PointsBegin] + Offset;\n\t\t\t\tfor (int32 PointIdx = Lane.PointsBegin + 1; PointIdx < Lane.PointsEnd; PointIdx++)\n\t\t\t\t{\n\t\t\t\t\tconst FVector Point = Storage.LanePoints[PointIdx] + Offset;\n\t\t\t\t\tLines.Add(FDebugRenderSceneProxy::FDebugLine(PrevPoint + OffsetZ, Point + OffsetZ, Color, LineThickness));\n\t\t\t\t\tPrevPoint = Point;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (int i = 0; i < Storage.Zones.Num(); i++)\n\t\t\t{\n\t\t\t\tconst FZoneData& Zone = Storage.Zones[i];\n\n\t\t\t\tfor (int32 LaneIndex = Zone.LanesBegin; LaneIndex < Zone.LanesEnd; ++LaneIndex)\n\t\t\t\t{\n\t\t\t\t\tconst FZoneLaneData& Lane = Storage.Lanes[LaneIndex];\n\t\t\t\t\t// Render only lanes used by the crowd\n\t\t\t\t\tif (!Lane.Tags.Contains(CrowdTag))\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst FZoneGraphLaneHandle LaneHandle(LaneIndex, Storage.DataHandle);\n\t\t\t\t\tconst FCrowdBranchingLaneData* BranchingLaneData = MassCrowdSubsystem->GetCrowdBranchingLaneData(LaneHandle);\n\t\t\t\t\tconst bool bIsBranchingLane = BranchingLaneData != nullptr;\n\n\t\t\t\t\t// states\n\t\t\t\t\tif (Settings->bDisplayStates)\n\t\t\t\t\t{\n\t\t\t\t\t\tTOptional<FZoneGraphCrowdLaneData> LaneData = MassCrowdSubsystem->GetCrowdLaneData(LaneHandle);\n\t\t\t\t\t\tconst bool bIsOpened = LaneData.IsSet() ? LaneData.GetValue().GetState() == ECrowdLaneState::Opened : true;\n\n\t\t\t\t\t\tAddLinesForLane(Storage, Lane,\n\t\t\t\t\t\t\t\t\t\tbIsOpened ? Settings->OpenedLaneColor : Settings->ClosedLaneColor,\n\t\t\t\t\t\t\t\t\t\tbIsBranchingLane ? IntersectionLaneThickness : LaneThickness, Offset);\n\t\t\t\t\t}\n\n\t\t\t\t\t// densities\n\t\t\t\t\tif (Settings->bDisplayDensities)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst FZoneGraphTagMask& LaneTagMask = Storage.Lanes[LaneHandle.Index].Tags;\n\t\t\t\t\t\tconst uint32 LaneMask = LaneTagMask.GetValue();\n\t\t\t\t\t\tconst FZoneGraphTagMask LaneDensityMask(bIsBranchingLane ? BranchingLaneData->DensityMask : (LaneMask & MassCrowdSubsystem->GetDensityMask().GetValue()));\n\n\t\t\t\t\t\tif (LaneDensityMask.GetValue())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst FMassCrowdLaneDensityDesc* Descriptor = Settings->GetLaneDensities().FindByPredicate(\n\t\t\t\t\t\t\t\t[LaneDensityMask](const FMassCrowdLaneDensityDesc& Desc){ return LaneDensityMask.Contains(Desc.Tag);});\n\n\t\t\t\t\t\t\tif (Descriptor != nullptr)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAddLinesForLane(Storage, Lane,\n\t\t\t\t\t\t\t\t\t\t\t\tDescriptor->RenderColor,\n\t\t\t\t\t\t\t\t\t\t\t\tbIsBranchingLane ? IntersectionLaneDensityThickness : LaneDensityThickness, LaneDensityOffset);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvirtual FPrimitiveViewRelevance GetViewRelevance(const FSceneView* View) const override\n\t\t{\n\t\t\t// Disable dependency on Navigation show flag\n\t\t\tFGuardValue_Bitfield(const_cast<FSceneViewFamily*>(View->Family)->EngineShowFlags.Navigation, true);\n\t\t\treturn FZoneGraphSceneProxy::GetViewRelevance(View);\n\t\t}\n\n\tprivate:\n\t\tconst UMassCrowdLaneDataRenderingComponent* Component;\n\t};\n\n\tAZoneGraphData* ZoneGraph = Cast<AZoneGraphData>(GetOwner());\n\treturn ZoneGraph ? new FMassCrowdLaneDataSceneProxy(*this, *ZoneGraph) : nullptr;\n}\n\nFBoxSphereBounds UMassCrowdLaneDataRenderingComponent::CalcBounds(const FTransform& LocalToWorld) const\n{\n\tconst AZoneGraphData* ZoneGraphData = Cast<AZoneGraphData>(GetOwner());\n\treturn FBoxSphereBounds(ZoneGraphData != nullptr ? ZoneGraphData->GetBounds() : FBox(ForceInit));\n}\n\nvoid UMassCrowdLaneDataRenderingComponent::DebugDrawOnCanvas(UCanvas* Canvas, APlayerController*) const\n{\n\tconst UMassCrowdSubsystem* MassCrowdSubsystem = UWorld::GetSubsystem<UMassCrowdSubsystem>(GetWorld());\n\t// The subsystems could be removed during world tear down\n\tif (MassCrowdSubsystem == nullptr)\n\t{\n\t\treturn;\n\t}\n\n\tconst UMassCrowdSettings* Settings = GetDefault<UMassCrowdSettings>();\n\tcheckf(Settings, TEXT(\"Settings default object is always expected to be valid\"));\n\tif (!Settings->bDisplayTrackingData)\n\t{\n\t\treturn;\n\t}\n\n\tconst AZoneGraphData* ZoneGraphData = Cast<AZoneGraphData>(GetOwner());\n\tconst FZoneGraphStorage& ZoneStorage = ZoneGraphData->GetStorage();\n\n\t// Make sure we still have lane data since we can end up here when Crowd subsystem has already been torn down.\n\tif (!MassCrowdSubsystem->HasCrowdDataForZoneGraph(ZoneStorage.DataHandle))\n\t{\n\t\treturn;\n\t}\n\n\tconst FSceneView* View = Canvas->SceneView;\n\tTGuardValue<FColor> ColorGuard(Canvas->DrawColor, FColor::White);\n\tconst UFont* Font = GEngine->GetSmallFont();\n\tconst FZoneGraphTag CrowdTag = Settings->CrowdTag;\n\n\t// * A CachedMaxDrawDistance of 0 indicates that the primitive should not be culled by distance.\n\tconst float MaxDrawDistance = CachedMaxDrawDistance > 0 ? CachedMaxDrawDistance : FLT_MAX;\n\tconst FZoneGraphSceneProxy::FDrawDistances Distances = FZoneGraphSceneProxy::GetDrawDistances(MinDrawDistance, MaxDrawDistance);\n\tconst FVector Origin = View->ViewMatrices.GetViewOrigin();\n\n\tfor (const FZoneData& Zone : ZoneStorage.Zones)\n\t{\n\t\tconst FZoneGraphSceneProxy::FZoneVisibility DrawInfo = FZoneGraphSceneProxy::CalculateZoneVisibility(Distances, Origin, Zone.Bounds.GetCenter());\n\t\tif (!DrawInfo.bVisible || !DrawInfo.bDetailsVisible)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (int32 LaneIdx = Zone.LanesBegin; LaneIdx < Zone.LanesEnd; LaneIdx++)\n\t\t{\n\t\t\tconst FZoneLaneData& Lane = ZoneStorage.Lanes[LaneIdx];\n\t\t\t// Render only lanes used by the crowd\n\t\t\tif (!Lane.Tags.Contains(CrowdTag))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst FZoneGraphLaneHandle LaneHandle(LaneIdx, ZoneStorage.DataHandle);\n\t\t\tconst FCrowdWaitAreaData* WaitAreaData = MassCrowdSubsystem->GetCrowdWaitingAreaData(LaneHandle);\n\t\t\tconst FCrowdTrackingLaneData* TrackingLaneData = MassCrowdSubsystem->GetCrowdTrackingLaneData(LaneHandle);\n\t\t\tif (WaitAreaData == nullptr && TrackingLaneData == nullptr)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcheckf(TrackingLaneData != nullptr, TEXT(\"Tracking can exist without wait area data but not the opposite\"));\n\n\t\t\tFZoneGraphLaneLocation CenterLoc;\n\t\t\tUE::ZoneGraph::Query::CalculateLocationAlongLaneFromRatio(ZoneStorage, LaneIdx, 0.5f, CenterLoc);\n\t\t\tconst FVector Location = FVector(GetComponentTransform().TransformPosition(CenterLoc.Position));\n\t\t\tconst FVector ScreenLoc = Canvas->Project(Location);\n\n\t\t\tif (WaitAreaData != nullptr)\n\t\t\t{\n\t\t\t\tCanvas->DrawText(Font, FString::Printf(TEXT(\"        %d/%d\"), TrackingLaneData->NumEntitiesOnLane, WaitAreaData->GetNumSlots())\n\t\t\t\t\t, FloatCastChecked<float>(ScreenLoc.X, UE::LWC::DefaultFloatPrecision)\n\t\t\t\t\t, FloatCastChecked<float>(ScreenLoc.Y, UE::LWC::DefaultFloatPrecision));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCanvas->DrawText(Font, FString::Printf(TEXT(\" %d\"), TrackingLaneData->NumEntitiesOnLane)\n\t\t\t\t\t, FloatCastChecked<float>(ScreenLoc.X, UE::LWC::DefaultFloatPrecision)\n\t\t\t\t\t, FloatCastChecked<float>(ScreenLoc.Y, UE::LWC::DefaultFloatPrecision));\n\t\t\t}\n\t\t}\n\t}\n}\n\n#endif // !UE_BUILD_SHIPPING && !UE_BUILD_TEST\n",
      "lines": 276
    },
    {
      "file_path": "MassCrowd\\Private\\MassCrowdMemberTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 394,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCrowdMemberTrait.h\"\n#include \"MassCrowdFragments.h\"\n#include \"MassEntityTemplateRegistry.h\"\n\nvoid UMassCrowdMemberTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tBuildContext.AddTag<FMassCrowdTag>();\n\tBuildContext.AddFragment<FMassCrowdLaneTrackingFragment>();\t\n}\n",
      "lines": 11
    },
    {
      "file_path": "MassCrowd\\Private\\MassCrowdModule.cpp",
      "extension": ".cpp",
      "size_bytes": 716,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"IMassCrowdModule.h\"\n\nclass FMassCrowdModule : public IMassCrowdModule\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nIMPLEMENT_MODULE(IMassCrowdModule, MassCrowd)\n\nvoid FMassCrowdModule::StartupModule()\n{\n\t// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)\n}\n\nvoid FMassCrowdModule::ShutdownModule()\n{\n\t// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n\t// we call this function before unloading the module.\n}\n\n",
      "lines": 24
    },
    {
      "file_path": "MassCrowd\\Private\\MassCrowdNavigationProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 14614,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCrowdNavigationProcessor.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassAIBehaviorTypes.h\"\n#include \"MassCrowdSubsystem.h\"\n#include \"MassCrowdFragments.h\"\n#include \"MassEntityManager.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassCrowdSettings.h\"\n#include \"ZoneGraphAnnotationSubsystem.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"Annotations/ZoneGraphDisturbanceAnnotation.h\"\n#include \"MassSimulationLOD.h\"\n#include \"MassSignalSubsystem.h\"\n\n//----------------------------------------------------------------------//\n// UMassCrowdLaneTrackingSignalProcessor\n//----------------------------------------------------------------------//\nUMassCrowdLaneTrackingSignalProcessor::UMassCrowdLaneTrackingSignalProcessor()\n{\n\tExecutionOrder.ExecuteBefore.Add(UE::Mass::ProcessorGroupNames::Behavior);\n}\n\nvoid UMassCrowdLaneTrackingSignalProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddTagRequirement<FMassCrowdTag>(EMassFragmentPresence::All);\n\tEntityQuery.AddRequirement<FMassCrowdLaneTrackingFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassZoneGraphLaneLocationFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddSubsystemRequirement<UMassCrowdSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassCrowdLaneTrackingSignalProcessor::Initialize(UObject& Owner)\n{\n\tSuper::Initialize(Owner);\n\t\n\tUMassSignalSubsystem* SignalSubsystem = UWorld::GetSubsystem<UMassSignalSubsystem>(Owner.GetWorld());\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::CurrentLaneChanged);\n}\n\nvoid UMassCrowdLaneTrackingSignalProcessor::SignalEntities(FMassEntityManager& EntityManager, FMassExecutionContext& Context, FMassSignalNameLookup&)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tUMassCrowdSubsystem& MassCrowdSubsystem = Context.GetMutableSubsystemChecked<UMassCrowdSubsystem>();\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tconst TConstArrayView<FMassZoneGraphLaneLocationFragment> LaneLocationList = Context.GetFragmentView<FMassZoneGraphLaneLocationFragment>();\n\t\tconst TArrayView<FMassCrowdLaneTrackingFragment> LaneTrackingList = Context.GetMutableFragmentView<FMassCrowdLaneTrackingFragment>();\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tconst FMassZoneGraphLaneLocationFragment& LaneLocation = LaneLocationList[EntityIndex];\n\t\t\tFMassCrowdLaneTrackingFragment& LaneTracking = LaneTrackingList[EntityIndex];\n\t\t\tif (LaneTracking.TrackedLaneHandle != LaneLocation.LaneHandle)\n\t\t\t{\n\t\t\t\tMassCrowdSubsystem.OnEntityLaneChanged(Context.GetEntity(EntityIndex), LaneTracking.TrackedLaneHandle, LaneLocation.LaneHandle);\n\t\t\t\tLaneTracking.TrackedLaneHandle = LaneLocation.LaneHandle;\n\t\t\t}\n\t\t}\n\t});\n}\n\n//----------------------------------------------------------------------//\n// UMassCrowdLaneTrackingDestructor\n//----------------------------------------------------------------------//\nUMassCrowdLaneTrackingDestructor::UMassCrowdLaneTrackingDestructor()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)(EProcessorExecutionFlags::Standalone | EProcessorExecutionFlags::Server);\n\tObservedType = FMassCrowdLaneTrackingFragment::StaticStruct();\n\tOperation = EMassObservedOperation::Remove;\n}\n\nvoid UMassCrowdLaneTrackingDestructor::ConfigureQueries()\n{\n\tEntityQuery.AddTagRequirement<FMassCrowdTag>(EMassFragmentPresence::All);\n\tEntityQuery.AddRequirement<FMassCrowdLaneTrackingFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddSubsystemRequirement<UMassCrowdSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassCrowdLaneTrackingDestructor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tUMassCrowdSubsystem& MassCrowdSubsystem = Context.GetMutableSubsystemChecked<UMassCrowdSubsystem>();\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tconst TConstArrayView<FMassCrowdLaneTrackingFragment> LaneTrackingList = Context.GetFragmentView<FMassCrowdLaneTrackingFragment>();\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tconst FMassCrowdLaneTrackingFragment& LaneTracking = LaneTrackingList[EntityIndex];\n\t\t\tif (LaneTracking.TrackedLaneHandle.IsValid())\n\t\t\t{\n\t\t\t\tMassCrowdSubsystem.OnEntityLaneChanged(Context.GetEntity(EntityIndex), LaneTracking.TrackedLaneHandle, FZoneGraphLaneHandle());\n\t\t\t}\n\t\t}\n\t});\n}\n\n//----------------------------------------------------------------------//\n// UMassCrowdDynamicObstacleProcessor\n//----------------------------------------------------------------------//\n\nUMassCrowdDynamicObstacleProcessor::UMassCrowdDynamicObstacleProcessor()\n\t: EntityQuery_Conditional(*this)\n{\n\tbAutoRegisterWithProcessingPhases = true;\n\n\tExecutionOrder.ExecuteBefore.Add(UE::Mass::ProcessorGroupNames::UpdateAnnotationTags);\n}\n\nvoid UMassCrowdDynamicObstacleProcessor::Initialize(UObject& Owner)\n{\n\tSuper::Initialize(Owner);\n\n\tZoneGraphAnnotationSubsystem = UWorld::GetSubsystem<UZoneGraphAnnotationSubsystem>(Owner.GetWorld());\n\tcheckf(ZoneGraphAnnotationSubsystem != nullptr, TEXT(\"UZoneGraphAnnotationSubsystem is mandatory when using this processor.\"));\n}\n\nvoid UMassCrowdDynamicObstacleProcessor::ConfigureQueries()\n{\n\tEntityQuery_Conditional.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery_Conditional.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tEntityQuery_Conditional.AddRequirement<FAgentRadiusFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery_Conditional.AddRequirement<FMassCrowdObstacleFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery_Conditional.AddRequirement<FMassSimulationVariableTickFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tEntityQuery_Conditional.AddChunkRequirement<FMassSimulationVariableTickChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tEntityQuery_Conditional.SetChunkFilter(&FMassSimulationVariableTickChunkFragment::ShouldTickChunkThisFrame);\n}\n\nvoid UMassCrowdDynamicObstacleProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tUWorld* World = EntityManager.GetWorld();\n\tconst UMassCrowdSettings* CrowdSettings = GetDefault<UMassCrowdSettings>();\n\tcheckf(CrowdSettings, TEXT(\"Settings default object is always expected to be valid\"));\n\n\tEntityQuery_Conditional.ForEachEntityChunk(EntityManager, Context, [this, World, CrowdSettings](FMassExecutionContext& Context)\n\t{\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\n\t\tconst TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\t\tconst TConstArrayView<FMassVelocityFragment> VelocityList = Context.GetFragmentView<FMassVelocityFragment>();\n\t\tconst TConstArrayView<FAgentRadiusFragment> RadiusList = Context.GetFragmentView<FAgentRadiusFragment>();\n\t\tconst TArrayView<FMassCrowdObstacleFragment> ObstacleDataList = Context.GetMutableFragmentView<FMassCrowdObstacleFragment>();\n\t\tconst TConstArrayView<FMassSimulationVariableTickFragment> SimVariableTickList = Context.GetFragmentView<FMassSimulationVariableTickFragment>();\n\n\t\tconst bool bHasVelocity = VelocityList.Num() > 0;\n\t\tconst bool bHasVariableTick = (SimVariableTickList.Num() > 0);\n\t\tconst float WorldDeltaTime = Context.GetDeltaTimeSeconds();\n\n\t\tconst float ObstacleMovingDistanceTolerance = CrowdSettings->ObstacleMovingDistanceTolerance;\n\t\tconst float ObstacleStoppingSpeedTolerance = CrowdSettings->ObstacleStoppingSpeedTolerance;\n\t\tconst float ObstacleTimeToStop = CrowdSettings->ObstacleTimeToStop;\n\t\tconst float ObstacleEffectRadius = CrowdSettings->ObstacleEffectRadius;\n\t\t\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\t// @todo: limit update frequency, this does not need to occur every frame\n\t\t\tconst FVector Position = LocationList[EntityIndex].GetTransform().GetLocation();\n\t\t\tconst float Radius = RadiusList[EntityIndex].Radius;\n\t\t\tFMassCrowdObstacleFragment& Obstacle = ObstacleDataList[EntityIndex];\n\t\t\tconst float DeltaTime = FMath::Max(KINDA_SMALL_NUMBER, bHasVariableTick ? SimVariableTickList[EntityIndex].DeltaTime : WorldDeltaTime);\n\n\t\t\tUE_VLOG_LOCATION(this, LogMassNavigationObstacle, Display, Position, Radius, Obstacle.bIsMoving ? FColor::Green : FColor::Red, TEXT(\"\"));\n\n\t\t\tif (Obstacle.bIsMoving)\n\t\t\t{\n\t\t\t\t// Calculate current speed based on velocity or last known position.\n\t\t\t\tconst FVector::FReal CurrentSpeed = bHasVelocity ? VelocityList[EntityIndex].Value.Length() : (FVector::Dist(Position, Obstacle.LastPosition) / DeltaTime);\n\n\t\t\t\t// Update position while moving, the stop logic will use the last position while check if the obstacles moves again.\n\t\t\t\tObstacle.LastPosition = Position;\n\n\t\t\t\t// Keep track how long the obstacle has been almost stationary.\n\t\t\t\tif (CurrentSpeed < ObstacleStoppingSpeedTolerance)\n\t\t\t\t{\n\t\t\t\t\tObstacle.TimeSinceStopped += DeltaTime;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tObstacle.TimeSinceStopped = 0.0f;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// If the obstacle has been almost stationary for a while, mark it as obstacle.\n\t\t\t\tif (Obstacle.TimeSinceStopped > ObstacleTimeToStop)\n\t\t\t\t{\n\t\t\t\t\tensureMsgf(Obstacle.LaneObstacleID.IsValid() == false, TEXT(\"Obstacle should not have been set.\"));\n\t\t\t\t\t\t\n\t\t\t\t\tObstacle.bIsMoving = false;\n\t\t\t\t\tObstacle.LaneObstacleID = FMassLaneObstacleID::GetNextUniqueID();\n\n\t\t\t\t\t// Add an obstacle disturbance.\n\t\t\t\t\tFZoneGraphObstacleDisturbanceArea Disturbance;\n\t\t\t\t\tDisturbance.Position = Obstacle.LastPosition;\n\t\t\t\t\tDisturbance.Radius = ObstacleEffectRadius;\n\t\t\t\t\tDisturbance.ObstacleRadius = Radius;\n\t\t\t\t\tDisturbance.ObstacleID = Obstacle.LaneObstacleID;\n\t\t\t\t\tDisturbance.Action = EZoneGraphObstacleDisturbanceAreaAction::Add;\n\t\t\t\t\tZoneGraphAnnotationSubsystem->SendEvent(Disturbance);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tObstacle.TimeSinceStopped += DeltaTime;\n\n\t\t\t\t// If the obstacle moves outside movement tolerance, mark it as moving, and remove it as obstacle.\n\t\t\t\tif (FVector::Dist(Position, Obstacle.LastPosition) > ObstacleMovingDistanceTolerance)\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\tensureMsgf(Obstacle.LaneObstacleID.IsValid(), TEXT(\"Obstacle should have been set.\"));\n\n\t\t\t\t\tFZoneGraphObstacleDisturbanceArea Disturbance;\n\t\t\t\t\tDisturbance.ObstacleID = Obstacle.LaneObstacleID;\n\t\t\t\t\tDisturbance.Action = EZoneGraphObstacleDisturbanceAreaAction::Remove;\n\t\t\t\t\tZoneGraphAnnotationSubsystem->SendEvent(Disturbance);\n\n\t\t\t\t\tObstacle.bIsMoving = true;\n\t\t\t\t\tObstacle.TimeSinceStopped = 0.0f;\n\t\t\t\t\tObstacle.LaneObstacleID = FMassLaneObstacleID();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n}\n\n//----------------------------------------------------------------------//\n// UMassCrowdDynamicObstacleInitializer\n//----------------------------------------------------------------------//\nUMassCrowdDynamicObstacleInitializer::UMassCrowdDynamicObstacleInitializer()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)(EProcessorExecutionFlags::Standalone | EProcessorExecutionFlags::Server);\n\tObservedType = FMassCrowdObstacleFragment::StaticStruct();\n\tOperation = EMassObservedOperation::Add;\n}\n\nvoid UMassCrowdDynamicObstacleInitializer::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassCrowdObstacleFragment>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassCrowdDynamicObstacleInitializer::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tUWorld* World = EntityManager.GetWorld();\n\t\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [World](FMassExecutionContext& Context)\n\t{\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tconst TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\t\tconst TArrayView<FMassCrowdObstacleFragment> ObstacleDataList = Context.GetMutableFragmentView<FMassCrowdObstacleFragment>();\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tconst FVector Position = LocationList[EntityIndex].GetTransform().GetLocation();\n\t\t\tFMassCrowdObstacleFragment& Obstacle = ObstacleDataList[EntityIndex];\n\n\t\t\tObstacle.LastPosition = Position;\n\t\t\tObstacle.TimeSinceStopped = 0.0f;\n\t\t\tObstacle.bIsMoving = true;\n\t\t}\n\t});\n}\n\n\n//----------------------------------------------------------------------//\n// UMassCrowdDynamicObstacleDeinitializer\n//----------------------------------------------------------------------//\nUMassCrowdDynamicObstacleDeinitializer::UMassCrowdDynamicObstacleDeinitializer()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)(EProcessorExecutionFlags::Standalone | EProcessorExecutionFlags::Server);\n\tObservedType = FMassCrowdObstacleFragment::StaticStruct();\n\tOperation = EMassObservedOperation::Remove;\n}\n\nvoid UMassCrowdDynamicObstacleDeinitializer::Initialize(UObject& Owner)\n{\n\tSuper::Initialize(Owner);\n\n\tUWorld* World = Owner.GetWorld();\n\tZoneGraphAnnotationSubsystem = UWorld::GetSubsystem<UZoneGraphAnnotationSubsystem>(World);\n\tcheckf(ZoneGraphAnnotationSubsystem != nullptr || (World && World->WorldType == EWorldType::Inactive)\n\t\t, TEXT(\"UZoneGraphAnnotationSubsystem is mandatory when using this processor.\"));\n}\n\nvoid UMassCrowdDynamicObstacleDeinitializer::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassCrowdObstacleFragment>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassCrowdDynamicObstacleDeinitializer::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tconst TArrayView<FMassCrowdObstacleFragment> ObstacleDataList = Context.GetMutableFragmentView<FMassCrowdObstacleFragment>();\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tFMassCrowdObstacleFragment& Obstacle = ObstacleDataList[EntityIndex];\n\n\t\t\tif (Obstacle.LaneObstacleID.IsValid())\n\t\t\t{\n\t\t\t\tFZoneGraphObstacleDisturbanceArea Disturbance;\n\t\t\t\tDisturbance.ObstacleID = Obstacle.LaneObstacleID;\n\t\t\t\tDisturbance.Action = EZoneGraphObstacleDisturbanceAreaAction::Remove;\n\t\t\t\tZoneGraphAnnotationSubsystem->SendEvent(Disturbance);\n\n\t\t\t\t// Reset obstacle\n\t\t\t\tObstacle = FMassCrowdObstacleFragment();\n\t\t\t}\n\t\t}\n\t});\n}\n",
      "lines": 315
    },
    {
      "file_path": "MassCrowd\\Private\\MassCrowdReplicator.cpp",
      "extension": ".cpp",
      "size_bytes": 3354,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCrowdReplicator.h\"\n#include \"MassCrowdBubble.h\"\n#include \"MassExecutionContext.h\"\n\n//----------------------------------------------------------------------//\n//  UMassCrowdReplicator\n//----------------------------------------------------------------------//\nvoid UMassCrowdReplicator::AddRequirements(FMassEntityQuery& EntityQuery)\n{\n\tFMassReplicationProcessorPositionYawHandler::AddRequirements(EntityQuery);\n\tFMassReplicationProcessorPathHandler::AddRequirements(EntityQuery);\n}\n\nvoid UMassCrowdReplicator::ProcessClientReplication(FMassExecutionContext& Context, FMassReplicationContext& ReplicationContext)\n{\n#if UE_REPLICATION_COMPILE_SERVER_CODE\n\n\tFMassReplicationProcessorPathHandler PathHandler;\n\tFMassReplicationProcessorPositionYawHandler PositionYawHandler;\n\tFMassReplicationSharedFragment* RepSharedFrag = nullptr;\n\n\tauto CacheViewsCallback = [&RepSharedFrag, &PathHandler, &PositionYawHandler](FMassExecutionContext& Context)\n\t{\n\t\tPathHandler.CacheFragmentViews(Context);\n\t\tPositionYawHandler.CacheFragmentViews(Context);\n\t\tRepSharedFrag = &Context.GetMutableSharedFragment<FMassReplicationSharedFragment>();\n\t\tcheck(RepSharedFrag);\n\t};\n\n\tauto AddEntityCallback = [&RepSharedFrag, &PathHandler, &PositionYawHandler](FMassExecutionContext& Context, const int32 EntityIdx, FReplicatedCrowdAgent& InReplicatedAgent, const FMassClientHandle ClientHandle)->FMassReplicatedAgentHandle\n\t{\n\t\tAMassCrowdClientBubbleInfo& CrowdBubbleInfo = RepSharedFrag->GetTypedClientBubbleInfoChecked<AMassCrowdClientBubbleInfo>(ClientHandle);\n\n\t\tPathHandler.AddEntity(EntityIdx, InReplicatedAgent.GetReplicatedPathDataMutable());\n\t\tPositionYawHandler.AddEntity(EntityIdx, InReplicatedAgent.GetReplicatedPositionYawDataMutable());\n\n\t\treturn CrowdBubbleInfo.GetCrowdSerializer().Bubble.AddAgent(Context.GetEntity(EntityIdx), InReplicatedAgent);\n\t};\n\n\tauto ModifyEntityCallback = [&RepSharedFrag, &PathHandler](FMassExecutionContext& Context, const int32 EntityIdx, const EMassLOD::Type LOD, const double Time, const FMassReplicatedAgentHandle Handle, const FMassClientHandle ClientHandle)\n\t{\n\t\tAMassCrowdClientBubbleInfo& CrowdBubbleInfo = RepSharedFrag->GetTypedClientBubbleInfoChecked<AMassCrowdClientBubbleInfo>(ClientHandle);\n\n\t\tFMassCrowdClientBubbleHandler& Bubble = CrowdBubbleInfo.GetCrowdSerializer().Bubble;\n\n\t\tconst bool bLastClient = RepSharedFrag->CachedClientHandles.Last() == ClientHandle;\n\t\tPathHandler.ModifyEntity<FCrowdFastArrayItem>(Handle, EntityIdx, Bubble.GetPathHandlerMutable(), bLastClient);\n\n\t\t// Don't call the PositionYawHandler here as we currently only replicate the position and yaw when we add an entity to Mass\n\t};\n\n\tauto RemoveEntityCallback = [&RepSharedFrag](FMassExecutionContext& Context, const FMassReplicatedAgentHandle Handle, const FMassClientHandle ClientHandle)\n\t{\n\t\tAMassCrowdClientBubbleInfo& CrowdBubbleInfo = RepSharedFrag->GetTypedClientBubbleInfoChecked<AMassCrowdClientBubbleInfo>(ClientHandle);\n\n\t\tCrowdBubbleInfo.GetCrowdSerializer().Bubble.RemoveAgentChecked(Handle);\n\t};\n\n\tCalculateClientReplication<FCrowdFastArrayItem>(Context, ReplicationContext, CacheViewsCallback, AddEntityCallback, ModifyEntityCallback, RemoveEntityCallback);\n#endif // UE_REPLICATION_COMPILE_SERVER_CODE\n}\n",
      "lines": 63
    },
    {
      "file_path": "MassCrowd\\Private\\MassCrowdRepresentationActorManagement.cpp",
      "extension": ".cpp",
      "size_bytes": 4574,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCrowdRepresentationActorManagement.h\"\n #include \"Components/SkeletalMeshComponent.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"GameFramework/Character.h\"\n#include \"MassAgentComponent.h\"\n#include \"MassRepresentationSubsystem.h\"\n\nvoid UMassCrowdRepresentationActorManagement::SetActorEnabled(const EMassActorEnabledType EnabledType, AActor& Actor, const int32 EntityIdx, FMassCommandBuffer& CommandBuffer) const\n{\n\tSuper::SetActorEnabled(EnabledType, Actor, EntityIdx, CommandBuffer);\n\n\tconst bool bEnabled = EnabledType != EMassActorEnabledType::Disabled;\n\n\tUSkeletalMeshComponent* SkeletalMeshComponent = Actor.FindComponentByClass<USkeletalMeshComponent>();\n\tif (SkeletalMeshComponent)\n\t{\n\t\t// Enable/disable the ticking and visibility of SkeletalMesh and its children\n\t\tSkeletalMeshComponent->SetVisibility(bEnabled);\n\t\tSkeletalMeshComponent->SetComponentTickEnabled(bEnabled);\n\t\tconst TArray<USceneComponent*>& AttachedChildren = SkeletalMeshComponent->GetAttachChildren();\n\t\tif (AttachedChildren.Num() > 0)\n\t\t{\n\t\t\tTInlineComponentArray<USceneComponent*, NumInlinedActorComponents> ComponentStack;\n\n\t\t\tComponentStack.Append(AttachedChildren);\n\t\t\twhile (ComponentStack.Num() > 0)\n\t\t\t{\n\t\t\t\tUSceneComponent* const CurrentComp = ComponentStack.Pop(EAllowShrinking::No);\n\t\t\t\tif (CurrentComp)\n\t\t\t\t{\n\t\t\t\t\tComponentStack.Append(CurrentComp->GetAttachChildren());\n\t\t\t\t\tCurrentComp->SetVisibility(bEnabled);\n\t\t\t\t\tif (bEnabled)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Re-enable only if it was enabled at startup\n\t\t\t\t\t\tCurrentComp->SetComponentTickEnabled(CurrentComp->PrimaryComponentTick.bStartWithTickEnabled);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tCurrentComp->SetComponentTickEnabled(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Enable/disable the ticking of CharacterMovementComponent as well\n\tACharacter* Character = Cast<ACharacter>(&Actor);\n\tUCharacterMovementComponent* MovementComp = Character != nullptr ? Character->GetCharacterMovement() : nullptr;\n\tif (MovementComp != nullptr)\n\t{\n\t\tMovementComp->SetComponentTickEnabled(bEnabled);\n\t}\n\n\t// when we \"suspend\" the puppet actor we need to let the agent subsystem know by unregistering the agent component\n\t// associated with the actor. This will result in removing all the puppet-actor-specific fragments which in turn\n\t// will exclude the owner entity from being processed by puppet-specific processors (usually translators).\n\tif (UMassAgentComponent* AgentComp = Actor.FindComponentByClass<UMassAgentComponent>())\n\t{\n\t\tAgentComp->PausePuppet(!bEnabled);\n\t}\n}\n\nAActor* UMassCrowdRepresentationActorManagement::GetOrSpawnActor(UMassRepresentationSubsystem& RepresentationSubsystem\n\t, FMassEntityManager& EntityManager, const FMassEntityHandle MassAgent, const FTransform& Transform\n\t, const int16 TemplateActorIndex, FMassActorSpawnRequestHandle& SpawnRequestHandle, const float Priority) const\n{\n\tFTransform RootTransform = Transform;\n\t\n\tif (const AActor* DefaultActor = RepresentationSubsystem.GetTemplateActorClass(TemplateActorIndex).GetDefaultObject())\n\t{\n\t\tif (const UCapsuleComponent* CapsuleComp = DefaultActor->FindComponentByClass<UCapsuleComponent>())\n\t\t{\n\t\t\tRootTransform.AddToTranslation(FVector(0.0f, 0.0f, CapsuleComp->GetScaledCapsuleHalfHeight()));\n\t\t}\n\t}\n\n\treturn Super::GetOrSpawnActor(RepresentationSubsystem, EntityManager, MassAgent, RootTransform, TemplateActorIndex, SpawnRequestHandle, Priority);\n}\n\nvoid UMassCrowdRepresentationActorManagement::TeleportActor(const FTransform& Transform, AActor& Actor, FMassCommandBuffer& CommandBuffer) const\n{\n\tFTransform RootTransform = Transform;\n\n\tif (const UCapsuleComponent* CapsuleComp = Actor.FindComponentByClass<UCapsuleComponent>())\n\t{\n\t\tconst FVector HalfHeight(0.0f, 0.0f, CapsuleComp->GetScaledCapsuleHalfHeight());\n\t\tRootTransform.AddToTranslation(HalfHeight);\n\t\tconst FVector RootLocation = RootTransform.GetLocation();\n\t\tconst FVector SweepOffset(0.0f, 0.0f, 20.0f);\n\t\tconst FVector Start = RootLocation + SweepOffset;\n\t\tconst FVector End = RootLocation - SweepOffset;\n\t\tFCollisionQueryParams Params;\n\t\tParams.AddIgnoredActor(&Actor);\n\t\tFHitResult OutHit;\n\t\tif (Actor.GetWorld()->SweepSingleByChannel(OutHit, Start, End, Transform.GetRotation(), CapsuleComp->GetCollisionObjectType(), CapsuleComp->GetCollisionShape(), Params))\n\t\t{\n\t\t\tRootTransform.SetLocation(OutHit.Location);\n\t\t}\n\t}\n\tSuper::TeleportActor(RootTransform, Actor, CommandBuffer);\n}\n",
      "lines": 105
    },
    {
      "file_path": "MassCrowd\\Private\\MassCrowdRepresentationSubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 469,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCrowdRepresentationSubsystem.h\"\n#include \"MassCrowdSpawnerSubsystem.h\"\n#include \"Engine/World.h\"\n\nvoid UMassCrowdRepresentationSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tCollection.InitializeDependency(UMassCrowdSpawnerSubsystem::StaticClass());\n\n\tSuper::Initialize(Collection);\n\n\tActorSpawnerSubsystem = UWorld::GetSubsystem<UMassCrowdSpawnerSubsystem>(GetWorld());\n}\n",
      "lines": 14
    },
    {
      "file_path": "MassCrowd\\Private\\MassCrowdServerRepresentationLODProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 4257,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCrowdServerRepresentationLODProcessor.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassCrowdFragments.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassRepresentationFragments.h\"\n#include \"MassEntityManager.h\"\n\nnamespace UE::MassCrowd\n{\n\tint32 bDebugCrowdServerRepresentationLOD = 0;\n\tFAutoConsoleVariableRef CVarDebugServerRepresentationLODTest(TEXT(\"mass.debug.CrowdServerRepresentationLOD\"), bDebugCrowdServerRepresentationLOD, TEXT(\"Debug Crowd ServerRepresentation LOD\"), ECVF_Cheat);\n} // UE::MassCrowd\n\nUMassCrowdServerRepresentationLODProcessor::UMassCrowdServerRepresentationLODProcessor()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::Server;\n\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::LOD;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LODCollector);\n\n\tLODDistance[EMassLOD::High] = 0.0f;\n\tLODDistance[EMassLOD::Medium] = 5000.0f;\n\tLODDistance[EMassLOD::Low] = 5000.0f;\n\tLODDistance[EMassLOD::Off] = 5000.0f;\n\t\n\tLODMaxCount[EMassLOD::High] = 50;\n\tLODMaxCount[EMassLOD::Medium] = 0;\n\tLODMaxCount[EMassLOD::Low] = 0;\n\tLODMaxCount[EMassLOD::Off] = INT_MAX;\n}\n\nvoid UMassCrowdServerRepresentationLODProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddTagRequirement<FMassCrowdTag>(EMassFragmentPresence::All);\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassViewerInfoFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassRepresentationLODFragment>(EMassFragmentAccess::ReadWrite);\n\n\tProcessorRequirements.AddSubsystemRequirement<UMassLODSubsystem>(EMassFragmentAccess::ReadOnly);\n}\n\nvoid UMassCrowdServerRepresentationLODProcessor::Initialize(UObject& InOwner)\n{\n\tLODCalculator.Initialize(LODDistance, BufferHysteresisOnDistancePercentage / 100.0f, LODMaxCount);\n\n\tSuper::Initialize(InOwner);\n}\n\nvoid UMassCrowdServerRepresentationLODProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE(CrowdServerRepresentationLOD)\n\n\tconst UMassLODSubsystem& LODSubsystem = Context.GetSubsystemChecked<UMassLODSubsystem>();\n\tconst TArray<FViewerInfo>& Viewers = LODSubsystem.GetViewers();\n\tLODCalculator.PrepareExecution(Viewers);\n\t\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(CalculateLOD)\n\t\t\n\t\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t\t{\n\t\t\tconst TConstArrayView<FMassViewerInfoFragment> ViewersInfoList = Context.GetFragmentView<FMassViewerInfoFragment>();\n\t\t\tconst TArrayView<FMassRepresentationLODFragment> RepresentationLODFragments = Context.GetMutableFragmentView<FMassRepresentationLODFragment>();\n\t\t\tLODCalculator.CalculateLOD(Context, ViewersInfoList, RepresentationLODFragments);\n\t\t});\n\t}\n\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(AdjustDistancesAndLODFromCount)\n\t\t\n\t\tif (LODCalculator.AdjustDistancesFromCount())\n\t\t{\n\t\t\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t\t\t{\n\t\t\t\tconst TConstArrayView<FMassViewerInfoFragment> ViewersInfoList = Context.GetFragmentView<FMassViewerInfoFragment>();\n\t\t\t\tconst TArrayView<FMassRepresentationLODFragment> RepresentationLODFragments = Context.GetMutableFragmentView<FMassRepresentationLODFragment>();\n\t\t\t\tLODCalculator.AdjustLODFromCount(Context, ViewersInfoList, RepresentationLODFragments);\n\t\t\t});\n\t\t}\n\t}\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\t// Optional debug display\n\tif (UE::MassCrowd::bDebugCrowdServerRepresentationLOD)\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(DebugDisplayLOD)\n\t\tUWorld* World = EntityManager.GetWorld();\n\t\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this, World](FMassExecutionContext& Context)\n\t\t{\n\t\t\tconst TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\t\t\tconst TConstArrayView<FMassRepresentationLODFragment> RepresentationLODFragments = Context.GetFragmentView<FMassRepresentationLODFragment>();\n\t\t\tLODCalculator.DebugDisplayLOD(Context, RepresentationLODFragments, LocationList, World);\n\t\t});\n\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n}\n",
      "lines": 100
    },
    {
      "file_path": "MassCrowd\\Private\\MassCrowdServerRepresentationProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 656,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCrowdServerRepresentationProcessor.h\"\n#include \"MassCrowdFragments.h\"\n#include \"MassLODTypes.h\"\n\nUMassCrowdServerRepresentationProcessor::UMassCrowdServerRepresentationProcessor()\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::Server;\n\n\tbAutoRegisterWithProcessingPhases = true;\n\tbRequiresGameThreadExecution = true;\n\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LOD);\n}\n\nvoid UMassCrowdServerRepresentationProcessor::ConfigureQueries()\n{\n\tSuper::ConfigureQueries();\n\tEntityQuery.AddTagRequirement<FMassCrowdTag>(EMassFragmentPresence::All);\n}\n",
      "lines": 21
    },
    {
      "file_path": "MassCrowd\\Private\\MassCrowdServerRepresentationTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 3089,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCrowdServerRepresentationTrait.h\"\n#include \"MassEntityManager.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"MassCrowdRepresentationSubsystem.h\"\n#include \"MassCrowdRepresentationActorManagement.h\"\n#include \"MassActorSubsystem.h\"\n#include \"MassEntityUtils.h\"\n\n\nUMassCrowdServerRepresentationTrait::UMassCrowdServerRepresentationTrait()\n{\n\tParams.RepresentationActorManagementClass = UMassCrowdRepresentationActorManagement::StaticClass();\n\tParams.LODRepresentation[EMassLOD::High] = EMassRepresentationType::HighResSpawnedActor;\n\tParams.LODRepresentation[EMassLOD::Medium] = EMassRepresentationType::None;\n\tParams.LODRepresentation[EMassLOD::Low] = EMassRepresentationType::None;\n\tParams.LODRepresentation[EMassLOD::Off] = EMassRepresentationType::None;\n\tParams.bKeepLowResActors = false;\n\tParams.bKeepActorExtraFrame = false;\n\tParams.bSpreadFirstVisualizationUpdate = false;\n\tParams.WorldPartitionGridNameContainingCollision = NAME_None;\n\tParams.NotVisibleUpdateRate = 0.5f;\n}\n\nvoid UMassCrowdServerRepresentationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\t// This should only be ran on NM_DedicatedServer network mode\n\tif (!World.IsNetMode(NM_DedicatedServer) && !BuildContext.IsInspectingData())\n\t{\n\t\treturn;\n\t}\n\t\n\tBuildContext.RequireFragment<FMassViewerInfoFragment>();\n\tBuildContext.RequireFragment<FTransformFragment>();\n\tBuildContext.RequireFragment<FMassActorFragment>();\n\n\tFMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(World);\n\n\tUMassCrowdRepresentationSubsystem* RepresentationSubsystem = World.GetSubsystem<UMassCrowdRepresentationSubsystem>();\n\tcheck(RepresentationSubsystem || BuildContext.IsInspectingData());\n\n\tFMassRepresentationSubsystemSharedFragment SubsystemSharedFragment;\n\tSubsystemSharedFragment.RepresentationSubsystem = RepresentationSubsystem;\n\tFSharedStruct SubsystemFragment = EntityManager.GetOrCreateSharedFragment<FMassRepresentationSubsystemSharedFragment>(SubsystemSharedFragment);\n\tBuildContext.AddSharedFragment(SubsystemFragment);\n\n\tFConstSharedStruct ParamsFragment = EntityManager.GetOrCreateConstSharedFragment(Params);\n\tParamsFragment.Get<const FMassRepresentationParameters>().ComputeCachedValues();\n\tBuildContext.AddConstSharedFragment(ParamsFragment);\n\n\tFMassRepresentationFragment& RepresentationFragment = BuildContext.AddFragment_GetRef<FMassRepresentationFragment>();\n\tRepresentationFragment.StaticMeshDescHandle = FStaticMeshInstanceVisualizationDescHandle();\n\tif (!BuildContext.IsInspectingData())\n\t{\n\t\tRepresentationFragment.HighResTemplateActorIndex = TemplateActor.Get() ? RepresentationSubsystem->FindOrAddTemplateActor(TemplateActor.Get()) : INDEX_NONE;\n\t}\n\tRepresentationFragment.LowResTemplateActorIndex = INDEX_NONE;\n\n\tBuildContext.AddFragment<FMassRepresentationLODFragment>();\n\n\t// @todo figure out if this chunk fragment is really needed?\n\tBuildContext.AddChunkFragment<FMassVisualizationChunkFragment>();\n}\n",
      "lines": 64
    },
    {
      "file_path": "MassCrowd\\Private\\MassCrowdSettings.cpp",
      "extension": ".cpp",
      "size_bytes": 2309,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCrowdSettings.h\"\n\n#if WITH_EDITOR\nvoid UMassCrowdSettings::PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent)\n{\n\tSuper::PostEditChangeChainProperty(PropertyChangedEvent);\n\n\tFProperty* Property = PropertyChangedEvent.Property;\n\tFProperty* MemberProperty = nullptr;\n\tif (PropertyChangedEvent.PropertyChain.GetActiveMemberNode())\n\t{\n\t\tMemberProperty = PropertyChangedEvent.PropertyChain.GetActiveMemberNode()->GetValue();\n\t}\n\n\tif (MemberProperty != nullptr && Property != nullptr)\n\t{\n\t\tconst FName MemberPropertyName = MemberProperty->GetFName();\n\t\tconst FName PropertyName = Property->GetFName();\n\t\tif (MemberPropertyName == GET_MEMBER_NAME_CHECKED(UMassCrowdSettings, LaneDensities) ||\n\t\t\tMemberPropertyName == GET_MEMBER_NAME_CHECKED(UMassCrowdSettings, CrowdTag) ||\n\t\t\tMemberPropertyName == GET_MEMBER_NAME_CHECKED(UMassCrowdSettings, CrossingTag) ||\n\t\t\tMemberPropertyName == GET_MEMBER_NAME_CHECKED(UMassCrowdSettings, SlotSize) ||\n\t\t\tMemberPropertyName == GET_MEMBER_NAME_CHECKED(UMassCrowdSettings, SlotOffset))\n\t\t{\n\t\t\tOnMassCrowdLaneDataSettingsChanged.Broadcast();\n\t\t}\n\n\t\tif (MemberPropertyName == GET_MEMBER_NAME_CHECKED(UMassCrowdSettings, LaneBaseLineThickness) ||\n\t\t\tMemberPropertyName == GET_MEMBER_NAME_CHECKED(UMassCrowdSettings, LaneRenderZOffset) ||\n\t\t\tMemberPropertyName == GET_MEMBER_NAME_CHECKED(UMassCrowdSettings, IntersectionLaneScaleFactor) ||\n\t\t\tMemberPropertyName == GET_MEMBER_NAME_CHECKED(UMassCrowdSettings, LaneDensityScaleFactor) ||\n\t\t\tMemberPropertyName == GET_MEMBER_NAME_CHECKED(UMassCrowdSettings, OpenedLaneColor) ||\n\t\t\tMemberPropertyName == GET_MEMBER_NAME_CHECKED(UMassCrowdSettings, ClosedLaneColor) ||\n\t\t\tMemberPropertyName == GET_MEMBER_NAME_CHECKED(UMassCrowdSettings, bDisplayTrackingData) ||\n\t\t\tMemberPropertyName == GET_MEMBER_NAME_CHECKED(UMassCrowdSettings, bDisplayStates) ||\n\t\t\tMemberPropertyName == GET_MEMBER_NAME_CHECKED(UMassCrowdSettings, bDisplayDensities) ||\n\t\t\t(MemberPropertyName == GET_MEMBER_NAME_CHECKED(UMassCrowdSettings, LaneDensities) && PropertyName == GET_MEMBER_NAME_CHECKED(FMassCrowdLaneDensityDesc, RenderColor)))\n\t\t{\n\t\t\tOnMassCrowdLaneRenderSettingsChanged.Broadcast();\n\t\t}\n\t}\n}\n#endif // WITH_EDITOR\n",
      "lines": 45
    },
    {
      "file_path": "MassCrowd\\Private\\MassCrowdSubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 26731,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCrowdSubsystem.h\"\n#include \"MassSimulationSubsystem.h\"\n#include \"MassCrowdBubble.h\"\n#include \"MassCrowdSettings.h\"\n#include \"Subsystems/Subsystem.h\"\n#include \"ZoneGraphAnnotationSubsystem.h\"\n#include \"ZoneGraphCrowdLaneAnnotations.h\"\n#include \"ZoneGraphDelegates.h\"\n#include \"ZoneGraphQuery.h\"\n#include \"ZoneGraphSubsystem.h\"\n#include \"VisualLogger/VisualLogger.h\"\n\n#if WITH_MASSGAMEPLAY_DEBUG\nnamespace UE::MassCrowdDebug\n{\nbool bForceFillIntersectionLanes = false;\nFAutoConsoleVariableRef CVars[] =\n{\n\tFAutoConsoleVariableRef(TEXT(\"ai.mass.CrowdForceFillIntersections\"),\n\t\t\t\t\t\t\tUE::MassCrowdDebug::bForceFillIntersectionLanes,\n\t\t\t\t\t\t\tTEXT(\"Modify lane selection to always choose a non full closed lane (if any).\"), ECVF_Cheat)\n};\n\n#if WITH_EDITOR\nstatic FAutoConsoleCommandWithWorld RebuildCmd(\n\tTEXT(\"ai.mass.CrowdRebuildLaneData\"),\n\tTEXT(\"Clears and rebuilds lane and intersection data for registered zone graphs using MassCrowd settings.\"),\n\tFConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* World)\n\t{\n\t\tif (UMassCrowdSubsystem* MassCrowdSubsystem = World != nullptr ? World->GetSubsystem<UMassCrowdSubsystem>() : nullptr)\n\t\t{\n\t\t\tMassCrowdSubsystem->RebuildLaneData();\n\t\t}\n\t}));\n#endif // WITH_EDITOR\n}// namespace UE::MassCrowdDebug\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n//----------------------------------------------------------------------//\n// UMassCrowdSubsystem\n//----------------------------------------------------------------------//\nvoid UMassCrowdSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tSuper::Initialize(Collection);\n\n\tCollection.InitializeDependency<UMassSimulationSubsystem>();\n\tZoneGraphSubsystem = Collection.InitializeDependency<UZoneGraphSubsystem>();\n\tZoneGraphAnnotationSubsystem = Collection.InitializeDependency<UZoneGraphAnnotationSubsystem>();\n\n\t// Cache settings\n\tMassCrowdSettings = GetDefault<UMassCrowdSettings>();\n\n\t// Compute the combined mask regrouping all possible densities\n\t// This must be updated before registering zone graphs\n\tUpdateDensityMask();\n\n\t// Register existing data.\n\tfor (const FRegisteredZoneGraphData& Registered : ZoneGraphSubsystem->GetRegisteredZoneGraphData())\n\t{\n\t\tif (Registered.bInUse && Registered.ZoneGraphData != nullptr)\n\t\t{\n\t\t\tPostZoneGraphDataAdded(Registered.ZoneGraphData);\n\t\t}\n\t}\n\n\tOnPostZoneGraphDataAddedHandle = UE::ZoneGraphDelegates::OnPostZoneGraphDataAdded.AddUObject(this, &UMassCrowdSubsystem::PostZoneGraphDataAdded);\n\tOnPreZoneGraphDataRemovedHandle = UE::ZoneGraphDelegates::OnPreZoneGraphDataRemoved.AddUObject(this, &UMassCrowdSubsystem::PreZoneGraphDataRemoved);\n\n#if WITH_EDITOR\n\t// Track density settings changes\n\tOnMassCrowdSettingsChangedHandle = MassCrowdSettings->OnMassCrowdLaneDataSettingsChanged.AddLambda([this]()\n\t{\n\t\tUpdateDensityMask();\n\t\tRebuildLaneData();\n\t});\n\n\tOnZoneGraphDataBuildDoneHandle = UE::ZoneGraphDelegates::OnZoneGraphDataBuildDone.AddLambda([this](const FZoneGraphBuildData& /*BuildData*/)\n\t{\n\t\tUpdateDensityMask();\n\t\tRebuildLaneData();\n\t});\n#endif\n\n\tHandleLateCreation();\n}\n\nvoid UMassCrowdSubsystem::Deinitialize()\n{\n#if WITH_EDITOR\n\tcheckf(MassCrowdSettings, TEXT(\"UMassCrowdSettings CDO should have been cached in Initialize\"));\n\tMassCrowdSettings->OnMassCrowdLaneDataSettingsChanged.Remove(OnMassCrowdSettingsChangedHandle);\n\n\tUE::ZoneGraphDelegates::OnZoneGraphDataBuildDone.Remove(OnZoneGraphDataBuildDoneHandle);\n#endif\n\n\tUE::ZoneGraphDelegates::OnPostZoneGraphDataAdded.Remove(OnPostZoneGraphDataAddedHandle);\n\tUE::ZoneGraphDelegates::OnPreZoneGraphDataRemoved.Remove(OnPreZoneGraphDataRemovedHandle);\n\n\tSuper::Deinitialize();\n}\n\nvoid UMassCrowdSubsystem::PostInitialize()\n{\n\tSuper::PostInitialize();\n\n\tUMassReplicationSubsystem* ReplicationSubsystem = UWorld::GetSubsystem<UMassReplicationSubsystem>(GetWorld());\n\n\tcheck(ReplicationSubsystem);\n\tReplicationSubsystem->RegisterBubbleInfoClass(AMassCrowdClientBubbleInfo::StaticClass());\n}\n\nvoid UMassCrowdSubsystem::PostZoneGraphDataAdded(const AZoneGraphData* ZoneGraphData)\n{\n\tconst UWorld* World = GetWorld();\n\n\t// Only consider valid graph from our world\n\tif (ZoneGraphData == nullptr || ZoneGraphData->GetWorld() != World)\n\t{\n\t\treturn;\n\t}\n\n\tconst FString WorldName = World->GetName();\n\n\tconst FZoneGraphStorage& Storage = ZoneGraphData->GetStorage();\n\tconst int32 Index = Storage.DataHandle.Index;\n\n\tUE_VLOG_UELOG(this, LogMassNavigation, Verbose, TEXT(\"%s adding data %d/%d\"), *WorldName, Storage.DataHandle.Index, Storage.DataHandle.Generation);\n\n\tif (Index >= RegisteredLaneData.Num())\n\t{\n\t\tRegisteredLaneData.SetNum(Index + 1);\n\t}\n\n\tFRegisteredCrowdLaneData& LaneData = RegisteredLaneData[Index];\n\tif (LaneData.DataHandle != Storage.DataHandle)\n\t{\n\t\t// Initialize lane data if here the first time.\n\t\tBuildLaneData(LaneData, Storage);\n\t}\n}\n\nvoid UMassCrowdSubsystem::PreZoneGraphDataRemoved(const AZoneGraphData* ZoneGraphData)\n{\n\t// Only consider valid graph from our world\n\tif (ZoneGraphData == nullptr || ZoneGraphData->GetWorld() != GetWorld())\n\t{\n\t\treturn;\n\t}\n\n\tconst FZoneGraphStorage& Storage = ZoneGraphData->GetStorage();\n\tconst int32 Index = Storage.DataHandle.Index;\n\n\tif (!RegisteredLaneData.IsValidIndex(Index))\n\t{\n\t\treturn;\n\t}\n\n\tFRegisteredCrowdLaneData& LaneData = RegisteredLaneData[Index];\n\tLaneData.Reset();\n}\n\nvoid UMassCrowdSubsystem::BuildLaneData(FRegisteredCrowdLaneData& LaneData, const FZoneGraphStorage& Storage)\n{\n\tLaneData.DataHandle = Storage.DataHandle;\n\tLaneData.CrowdLaneDataArray.Reset(Storage.Lanes.Num());\n\tLaneData.CrowdLaneDataArray.SetNum(Storage.Lanes.Num());\n\n\t// Graph may contain lanes that won't be used by the crowd so let's filter them at least for the intersection data.\n\t// regular lane data is always created to preserve fast index based access.\n\tconst FZoneGraphTag CrowdTag = MassCrowdSettings->CrowdTag;\n\tconst FZoneGraphTag CrossingTag = MassCrowdSettings->CrossingTag;\n\n\tcheckf(ZoneGraphAnnotationSubsystem != nullptr, TEXT(\"ZoneGraphAnnotationSubsystem should be initialized from the subsystem collection dependencies.\"));\n\n\tTArray<FZoneGraphLinkedLane> Links;\n\tfor (int32 LaneIndex = 0; LaneIndex < Storage.Lanes.Num(); ++LaneIndex)\n\t{\n\t\tconst FZoneLaneData& ZoneLaneData = Storage.Lanes[LaneIndex];\n\t\tif (!ZoneLaneData.Tags.Contains(CrowdTag))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tUE::ZoneGraph::Query::GetLinkedLanes(Storage, LaneIndex, EZoneLaneLinkType::Incoming, EZoneLaneLinkFlags::All, EZoneLaneLinkFlags::None, Links);\n\n\t\t// We only need tracking data for crossing lanes ond their incoming lanes\n\t\tif (ZoneLaneData.Tags.Contains(CrossingTag))\n\t\t{\n\t\t\tCreateTrackingData(LaneIndex, Storage);\n\n\t\t\t// Close all crossings by default.\n\t\t\tZoneGraphAnnotationSubsystem->SendEvent(FZoneGraphCrowdLaneStateChangeEvent({LaneIndex, Storage.DataHandle}, ECrowdLaneState::Closed));\n\n\t\t\tconst int32 WaitAreaIndex = LaneData.WaitAreas.AddDefaulted();\n\t\t\tFCrowdWaitAreaData& WaitingArea = LaneData.WaitAreas[WaitAreaIndex];\n\t\t\tCreateWaitSlots(LaneIndex, WaitingArea, Storage);\n\t\t\tfor (const FZoneGraphLinkedLane& Link : Links)\n\t\t\t{\n\t\t\t\tFCrowdTrackingLaneData& TrackingData = CreateTrackingData(Link.DestLane.Index, Storage);\n\t\t\t\tTrackingData.WaitAreaIndex = WaitAreaIndex;\n\n\t\t\t\tWaitingArea.ConnectedLanes.Add(Link.DestLane);\n\t\t\t}\n\t\t}\n\n\t\t// We only need branching data for merging/splitting lanes since they require per lane density\n\t\tconst bool bRequiresBranchingData = (Links.Num() > 1);\n\t\tif (bRequiresBranchingData)\n\t\t{\n\t\t\tfor (const FZoneGraphLinkedLane& Link : Links)\n\t\t\t{\n\t\t\t\tCreateBranchingData(Link.DestLane.Index, Storage);\n\t\t\t}\n\t\t}\n \t}\n}\n\nTOptional<FZoneGraphCrowdLaneData> UMassCrowdSubsystem::GetCrowdLaneData(const FZoneGraphLaneHandle LaneHandle) const\n{\n\tTOptional<FZoneGraphCrowdLaneData> LaneData;\n\tif (const FZoneGraphCrowdLaneData* MutableLaneData = const_cast<UMassCrowdSubsystem*>(this)->GetMutableCrowdLaneData(LaneHandle))\n\t{\n\t\tLaneData = *MutableLaneData;\n\t}\n\treturn LaneData;\n}\n\nFZoneGraphCrowdLaneData* UMassCrowdSubsystem::GetMutableCrowdLaneData(const FZoneGraphLaneHandle LaneHandle)\n{\n\tif (!ensureMsgf(LaneHandle.IsValid(), TEXT(\"Invalid lane handle: returning an invalid entry.\")))\n\t{\n\t\treturn nullptr;\n\t}\n\n\tconst int32 Index = LaneHandle.DataHandle.Index;\n\tif (!ensureMsgf(RegisteredLaneData.IsValidIndex(Index), TEXT(\"Invalid lane handle index: returning an invalid entry.\")))\n\t{\n\t\treturn nullptr;\n\t}\n\n\tFRegisteredCrowdLaneData& LaneData = RegisteredLaneData[Index];\n\tif (!ensureMsgf(LaneData.DataHandle == LaneHandle.DataHandle, TEXT(\"Mismatching data handle: returning an invalid entry.\")))\n\t{\n\t\treturn nullptr;\n\t}\n\n\treturn &(LaneData.CrowdLaneDataArray[LaneHandle.Index]);\n}\n\nconst FCrowdTrackingLaneData* UMassCrowdSubsystem::GetCrowdTrackingLaneData(const FZoneGraphLaneHandle LaneHandle) const\n{\n\tif (!ensureMsgf(LaneHandle.IsValid(), TEXT(\"Invalid lane handle: returning a null entry.\")))\n\t{\n\t\treturn nullptr;\n\t}\n\n\tcheckf(RegisteredLaneData.IsValidIndex(LaneHandle.DataHandle.Index), TEXT(\"Storage must have been allocated before creating lane data\"));\n\tconst FRegisteredCrowdLaneData& CrowdLaneData = RegisteredLaneData[LaneHandle.DataHandle.Index];\n\treturn CrowdLaneData.LaneToTrackingDataLookup.Find(LaneHandle.Index);\n}\n\nconst FCrowdBranchingLaneData* UMassCrowdSubsystem::GetCrowdBranchingLaneData(const FZoneGraphLaneHandle LaneHandle) const\n{\n\tif (!ensureMsgf(LaneHandle.IsValid(), TEXT(\"Invalid lane handle: returning a null entry.\")))\n\t{\n\t\treturn nullptr;\n\t}\n\n\tcheckf(RegisteredLaneData.IsValidIndex(LaneHandle.DataHandle.Index), TEXT(\"Storage must have been allocated before creating lane data\"));\n\tconst FRegisteredCrowdLaneData& CrowdLaneData = RegisteredLaneData[LaneHandle.DataHandle.Index];\n\treturn CrowdLaneData.LaneToBranchingDataLookup.Find(LaneHandle.Index);\n}\n\nconst FCrowdWaitAreaData* UMassCrowdSubsystem::GetCrowdWaitingAreaData(const FZoneGraphLaneHandle LaneHandle) const\n{\n\tif (!ensureMsgf(LaneHandle.IsValid(), TEXT(\"Invalid lane handle: returning a null entry.\")))\n\t{\n\t\treturn nullptr;\n\t}\n\n\tcheckf(RegisteredLaneData.IsValidIndex(LaneHandle.DataHandle.Index), TEXT(\"Storage must have been allocated before creating lane data\"));\n\tconst FRegisteredCrowdLaneData& CrowdLaneData = RegisteredLaneData[LaneHandle.DataHandle.Index];\n\tconst FCrowdTrackingLaneData* TrackingData = CrowdLaneData.LaneToTrackingDataLookup.Find(LaneHandle.Index);\n\t\n\treturn (TrackingData && TrackingData->WaitAreaIndex != INDEX_NONE) ? &CrowdLaneData.WaitAreas[TrackingData->WaitAreaIndex] : nullptr;\n}\n\n#if WITH_EDITOR\nvoid UMassCrowdSubsystem::RebuildLaneData()\n{\n\tif (ZoneGraphSubsystem == nullptr)\n\t{\n\t\tUE_VLOG_UELOG(this, LogMassNavigation, Warning, TEXT(\"%s called before ZoneGraphSubsystem is set. Nothing to do.\"), ANSI_TO_TCHAR(__FUNCTION__));\n\t\treturn;\n\t};\n\n\tUWorld* World = GetWorld();\n\tif (World != nullptr && World->IsGameWorld())\n\t{\n\t\tUE_VLOG_UELOG(this, LogMassNavigation, Warning, TEXT(\"%s is not supported on game world since data is in use.\"), ANSI_TO_TCHAR(__FUNCTION__));\n\t\treturn;\n\t}\n\n\tfor (FRegisteredCrowdLaneData& LaneData : RegisteredLaneData)\n\t{\n\t\tLaneData.LaneToTrackingDataLookup.Reset();\n\t\tLaneData.LaneToBranchingDataLookup.Reset();\n\t\tLaneData.WaitAreas.Reset();\n\t\tconst FZoneGraphStorage* Storage = ZoneGraphSubsystem->GetZoneGraphStorage(LaneData.DataHandle);\n\t\tif (Storage)\n\t\t{\n\t\t\tBuildLaneData(LaneData, *Storage);\n\t\t}\n\t}\n}\n#endif // WITH_EDITOR\n\nbool UMassCrowdSubsystem::HasCrowdDataForZoneGraph(const FZoneGraphDataHandle DataHandle) const\n{\n\tif (!DataHandle.IsValid())\n\t{\n\t\treturn false;\n\t}\n\n\tconst int32 Index = DataHandle.Index;\n\tif (!RegisteredLaneData.IsValidIndex(Index))\n\t{\n\t\treturn false;\n\t}\n\n\tconst FRegisteredCrowdLaneData& LaneData = RegisteredLaneData[Index];\n\tif (LaneData.DataHandle != DataHandle)\n\t{\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nconst FRegisteredCrowdLaneData* UMassCrowdSubsystem::GetCrowdData(const FZoneGraphDataHandle DataHandle) const\n{\n\tif (!ensureMsgf(DataHandle.IsValid(), TEXT(\"Requesting crowd data using an invalid handle.\")))\n\t{\n\t\treturn nullptr;\n\t}\n\n\tconst int32 Index = DataHandle.Index;\n\tif (!ensureMsgf(RegisteredLaneData.IsValidIndex(Index),\n\t\tTEXT(\"Requesting crowd data from a valid handle but associated data was not generated (e.g. Graph registration was not processed).\")))\n\t{\n\t\treturn nullptr;\n\t}\n\n\tconst FRegisteredCrowdLaneData& LanesData = RegisteredLaneData[Index];\n\tif (!ensureMsgf(LanesData.DataHandle == DataHandle,\n\t\tTEXT(\"Mismatch between the graph handle stored in the associated crowd data and the provided handle (e.g. inconsistent registration/unregistration).\")))\n\t{\n\t\treturn nullptr;\n\t}\n\n\treturn &LanesData;\n}\n\nvoid UMassCrowdSubsystem::OnEntityLaneChanged(const FMassEntityHandle Entity, const FZoneGraphLaneHandle PreviousLaneHandle, const FZoneGraphLaneHandle CurrentLaneHandle)\n{\n\tconst bool bPreviousLocationValid = PreviousLaneHandle.IsValid();\n\tconst bool bCurrentLocationValid = CurrentLaneHandle.IsValid();\n\n\tif (!bPreviousLocationValid && !bCurrentLocationValid)\n\t{\n\t\treturn;\n\t}\n\n\tconst int32 DataIndex = bPreviousLocationValid ? PreviousLaneHandle.DataHandle.Index : CurrentLaneHandle.DataHandle.Index;\n\tcheckf(RegisteredLaneData.IsValidIndex(DataIndex), TEXT(\"Storage must have been allocated before creating lane data\"));\n\tFRegisteredCrowdLaneData& CrowdLaneData = RegisteredLaneData[DataIndex];\n\n\tif (bPreviousLocationValid)\n\t{\n\t\tconst int32 PrevLaneIndex = PreviousLaneHandle.Index;\n\n\t\tif (FCrowdTrackingLaneData* PreviousTrackingLaneData = CrowdLaneData.LaneToTrackingDataLookup.Find(PrevLaneIndex))\n\t\t{\n\t\t\tOnExitTrackedLane(Entity, PrevLaneIndex, *PreviousTrackingLaneData);\n\t\t}\n\t\t\n\t\tUE_VLOG_UELOG(this, LogMassNavigation, Verbose, TEXT(\"Entity [%s] exits lane %d\"), *Entity.DebugGetDescription(), PrevLaneIndex);\n\t}\n\n\tif (bCurrentLocationValid)\n\t{\n\t\tconst int32 CurLaneIndex = CurrentLaneHandle.Index;\n\n\t\tif (FCrowdTrackingLaneData* CurrentTrackingLaneData = CrowdLaneData.LaneToTrackingDataLookup.Find(CurLaneIndex))\n\t\t{\n\t\t\tOnEnterTrackedLane(Entity, CurLaneIndex, *CurrentTrackingLaneData);\n\t\t}\n\n\t\tUE_VLOG_UELOG(this, LogMassNavigation, Verbose, TEXT(\"Entity [%s] enters lane %d\"), *Entity.DebugGetDescription(), CurLaneIndex);\n\t}\n}\n\nfloat UMassCrowdSubsystem::GetDensityWeight(const FZoneGraphLaneHandle LaneHandle, const FZoneGraphTagMask LaneTagMask) const\n{\n\tconst FCrowdBranchingLaneData* BranchingLaneData = GetCrowdBranchingLaneData(LaneHandle);\n\tconst uint32 LaneMask = LaneTagMask.GetValue();\n\tconst FZoneGraphTagMask LaneDensityMask((BranchingLaneData != nullptr) ? BranchingLaneData->DensityMask : (LaneMask & DensityMask.GetValue()));\n\n\tfloat Weight = FMassCrowdLaneDensityDesc::DefaultWeight;\n\tif (LaneDensityMask.GetValue())\n\t{\n\t\tfor (const FMassCrowdLaneDensityDesc& DensityDescriptor : MassCrowdSettings->GetLaneDensities())\n\t\t{\n\t\t\tif (LaneDensityMask.Contains(DensityDescriptor.Tag))\n\t\t\t{\n\t\t\t\tWeight = DensityDescriptor.Weight;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Weight;\n}\n\nECrowdLaneState UMassCrowdSubsystem::GetLaneState(const FZoneGraphLaneHandle LaneHandle) const\n{\n\tconst TOptional<FZoneGraphCrowdLaneData> LaneData = GetCrowdLaneData(LaneHandle);\n\treturn LaneData.IsSet() ? LaneData.GetValue().GetState() : ECrowdLaneState::Opened;\n}\n\nbool UMassCrowdSubsystem::SetLaneState(const FZoneGraphLaneHandle LaneHandle, ECrowdLaneState NewState)\n{\n\tif (!LaneHandle.IsValid())\n\t{\n\t\tUE_VLOG_UELOG(this, LogMassNavigation, Warning, TEXT(\"Trying to set lane state %s on an invalid lane %s\\n\"), *UEnum::GetValueAsString(NewState), *LaneHandle.ToString());\n\t\treturn false;\n\t}\n\t\n\tFZoneGraphCrowdLaneData* CrowdLaneData = GetMutableCrowdLaneData(LaneHandle);\n\tconst bool bSuccess = CrowdLaneData != nullptr;\n\tif (bSuccess)\n\t{\n\t\tCrowdLaneData->SetState(NewState);\n\n\t\tcheckf(ZoneGraphAnnotationSubsystem != nullptr, TEXT(\"ZoneGraphAnnotationSubsystem should be initialized from the subsystem collection dependencies.\"));\n\t\tZoneGraphAnnotationSubsystem->SendEvent(FZoneGraphCrowdLaneStateChangeEvent(LaneHandle, NewState));\n\n#if !UE_BUILD_SHIPPING && !UE_BUILD_TEST\n\t\tDebugOnMassCrowdLaneStateChanged.Broadcast();\n#endif\n\t}\n\treturn bSuccess;\n}\n\nFCrowdTrackingLaneData& UMassCrowdSubsystem::CreateTrackingData(const int32 LaneIndex, const FZoneGraphStorage& ZoneGraphStorage)\n{\n\tcheckf(RegisteredLaneData.IsValidIndex(ZoneGraphStorage.DataHandle.Index), TEXT(\"Storage must have been allocated before creating lane data\"));\n\tFRegisteredCrowdLaneData& CrowdLaneData = RegisteredLaneData[ZoneGraphStorage.DataHandle.Index];\n\treturn CrowdLaneData.LaneToTrackingDataLookup.Add(LaneIndex);\n}\n\nFCrowdBranchingLaneData& UMassCrowdSubsystem::CreateBranchingData(const int32 LaneIndex, const FZoneGraphStorage& ZoneGraphStorage)\n{\n\tcheckf(RegisteredLaneData.IsValidIndex(ZoneGraphStorage.DataHandle.Index), TEXT(\"Storage must have been allocated before creating lane data\"));\n\tFRegisteredCrowdLaneData& CrowdLaneData = RegisteredLaneData[ZoneGraphStorage.DataHandle.Index];\n\tFCrowdBranchingLaneData& NewWaitingData = CrowdLaneData.LaneToBranchingDataLookup.Add(LaneIndex);\n\n\t// Fetch density tag from upcoming lane\n\t// Keep default if unable to propagate a single density (no linked lanes or more than one outgoing lane)\n\tTArray<FZoneGraphLinkedLane> Links;\n\tUE::ZoneGraph::Query::GetLinkedLanes(ZoneGraphStorage, LaneIndex, EZoneLaneLinkType::Outgoing, EZoneLaneLinkFlags::All, EZoneLaneLinkFlags::None, Links);\n\tif (Links.Num() == 1)\n\t{\n\t\tconst uint32 LinkLaneMask = ZoneGraphStorage.Lanes[Links[0].DestLane.Index].Tags.GetValue();\n\t\tNewWaitingData.DensityMask = LinkLaneMask & DensityMask.GetValue();\n\t}\n\n\treturn NewWaitingData;\n}\n\nvoid UMassCrowdSubsystem::CreateWaitSlots(const int32 CrossingLaneIndex, FCrowdWaitAreaData& WaitArea, const FZoneGraphStorage& ZoneGraphStorage)\n{\n\tcheckf(RegisteredLaneData.IsValidIndex(ZoneGraphStorage.DataHandle.Index), TEXT(\"Storage must have been allocated before creating lane data\"));\n\n\t// Figure out total width of the crossing lane, including adjacent lanes.\n\tTArray<FZoneGraphLinkedLane> Links;\n\tUE::ZoneGraph::Query::GetLinkedLanes(ZoneGraphStorage, CrossingLaneIndex, EZoneLaneLinkType::Adjacent, EZoneLaneLinkFlags::Left | EZoneLaneLinkFlags::Right, EZoneLaneLinkFlags::None, Links);\n\n\tconst FZoneLaneData& CrossingLane = ZoneGraphStorage.Lanes[CrossingLaneIndex];\n\n\tfloat SpaceLeft = CrossingLane.Width * 0.5f;\n\tfloat SpaceRight = CrossingLane.Width * 0.5f;\n\t\n\tfor (const FZoneGraphLinkedLane& Link : Links)\n\t{\n\t\tconst FZoneLaneData& AdjacentLane = ZoneGraphStorage.Lanes[Link.DestLane.Index];\n\t\tif (Link.HasFlags(EZoneLaneLinkFlags::Left))\n\t\t{\n\t\t\tSpaceLeft += AdjacentLane.Width;\n\t\t}\n\t\telse // Right\n\t\t{\n\t\t\tSpaceRight += AdjacentLane.Width;\n\t\t}\n\t}\t\n\n\tconst float TotalSpace = SpaceLeft + SpaceRight;\n\n\t// Distribute slots along the total width.\n\tcheckf(MassCrowdSettings, TEXT(\"UMassCrowdSettings CDO should have been cached in Initialize\"));\n\tconst float SlotSize = (float)MassCrowdSettings->SlotSize;\n\tconst int32 NumSlots = FMath::Max((SlotSize > 0 ? FMath::RoundToInt(TotalSpace / SlotSize) : 1), 1);\n\n\tconst FVector Forward = ZoneGraphStorage.LaneTangentVectors[CrossingLane.PointsBegin];\n\tconst FVector Up = ZoneGraphStorage.LaneUpVectors[CrossingLane.PointsBegin];\n\tconst FVector Left = FVector::CrossProduct(Forward, Up);\n\tconst FVector Base = ZoneGraphStorage.LanePoints[CrossingLane.PointsBegin] - Forward * MassCrowdSettings->SlotOffset;\n\n\tWaitArea.Slots.Reserve(NumSlots);\n\tfor (int32 SlotIndex = 0; SlotIndex < NumSlots; SlotIndex++)\n\t{\n\t\tconst float U = (SlotIndex + 0.5f) / (float)NumSlots;\n\t\tFCrowdWaitSlot& Slot = WaitArea.Slots.AddDefaulted_GetRef();\n\t\tSlot.Forward = Forward;\n\t\t// @todo This calculate is a bit kludge. The idea is to narrow the used space by zigzag pattern, so that there's enough space for incoming pedestrians to pass through. \n\t\tSlot.Position = Base - Left * (SpaceRight + SlotSize/2 - TotalSpace * U * 0.75f) - Forward * ((SlotIndex & 1) * SlotSize*0.5f);\n\t\tSlot.Radius = SlotSize * 0.5f;\n\t}\n\t\n\tWaitArea.NumFreeSlots = NumSlots;\n}\n\nvoid UMassCrowdSubsystem::UpdateDensityMask()\n{\n\tcheck(MassCrowdSettings);\n\tDensityMask = FZoneGraphTagMask::None;\n\tconst TArray<FMassCrowdLaneDensityDesc>& Densities = MassCrowdSettings->GetLaneDensities();\n\tfor (const FMassCrowdLaneDensityDesc& DensityDesc : Densities)\n\t{\n\t\tDensityMask.Add(DensityDesc.Tag);\n\t}\n}\n\nvoid UMassCrowdSubsystem::OnEnterTrackedLane(const FMassEntityHandle Entity, const int32 LaneIndex, FCrowdTrackingLaneData& TrackingData)\n{\n\t++TrackingData.NumEntitiesOnLane;\n\n\tUE_VLOG_UELOG(this, LogMassNavigation, Verbose, TEXT(\"[%s] enters lane %d. Num entities on lane: %d\"), *Entity.DebugGetDescription(), LaneIndex, TrackingData.NumEntitiesOnLane);\n}\n\nvoid UMassCrowdSubsystem::OnExitTrackedLane(const FMassEntityHandle Entity, const int32 LaneIndex, FCrowdTrackingLaneData& TrackingData)\n{\n\tensureMsgf(TrackingData.NumEntitiesOnLane >= 1, TEXT(\"OnExitTrackedLane should not be called more often than OnEnterTrackedLane\"));\n\t--TrackingData.NumEntitiesOnLane;\n\n\tUE_VLOG_UELOG(this, LogMassNavigation, Verbose, TEXT(\"[%s] exits lane %d. Num entities on lane: %d\"), *Entity.DebugGetDescription(), LaneIndex, TrackingData.NumEntitiesOnLane);\n}\n\nint32 UMassCrowdSubsystem::AcquireWaitingSlot(const FMassEntityHandle Entity, const FVector& EntityPosition, const FZoneGraphLaneHandle LaneHandle,\n\t\t\t\t\t\t\t\t\t\t\t  FVector& OutSlotPosition, FVector& OutSlotDirection)\n{\n\tif (!LaneHandle.IsValid())\n\t{\n\t\treturn INDEX_NONE;\n\t}\n\t\n\tcheckf(RegisteredLaneData.IsValidIndex(LaneHandle.DataHandle.Index), TEXT(\"Storage must have been allocated before creating lane data\"));\n\tFRegisteredCrowdLaneData& CrowdLaneData = RegisteredLaneData[LaneHandle.DataHandle.Index];\n\n\tint32 BestSlotIndex = INDEX_NONE;\n\tFVector BestSlotPosition = FVector::ZeroVector;\n\tFVector BestSlotForward = FVector::ForwardVector;\n\n\tconst FCrowdTrackingLaneData* TrackingData = CrowdLaneData.LaneToTrackingDataLookup.Find(LaneHandle.Index);\n\tif (TrackingData && TrackingData->WaitAreaIndex != INDEX_NONE)\n\t{\n\t\tFCrowdWaitAreaData& WaitArea = CrowdLaneData.WaitAreas[TrackingData->WaitAreaIndex];\n\t\t\n\t\tif (!WaitArea.IsFull())\n\t\t{\n\t\t\tcheck(WaitArea.NumFreeSlots > 0);\n\t\t\t\n\t\t\t// Find best vacant slot\n\t\t\t// The most distant slot is used so that later arrivals are less likely to need passing between already standing agents. \n\t\t\tFVector::FReal BestDistanceSq = 0.;\n\t\t\tfor (int32 SlotIndex = 0; SlotIndex < WaitArea.Slots.Num(); SlotIndex++)\n\t\t\t{\n\t\t\t\tconst FCrowdWaitSlot& Slot = WaitArea.Slots[SlotIndex];\n\t\t\t\tif (!Slot.bOccupied)\n\t\t\t\t{\n\t\t\t\t\tconst FVector::FReal DistanceToSlotSq = FVector::DistSquared(EntityPosition, Slot.Position);\n\t\t\t\t\tif (DistanceToSlotSq > BestDistanceSq)\n\t\t\t\t\t{\n\t\t\t\t\t\tBestDistanceSq = DistanceToSlotSq;\n\t\t\t\t\t\tBestSlotPosition = Slot.Position;\n\t\t\t\t\t\tBestSlotForward = Slot.Forward;\n\t\t\t\t\t\tBestSlotIndex = SlotIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (BestSlotIndex != INDEX_NONE)\n\t\t\t{\n\t\t\t\tWaitArea.Slots[BestSlotIndex].bOccupied = true;\n\t\t\t\tWaitArea.NumFreeSlots--;\n\t\t\t}\n\t\t\t\n\t\t\t// Signal if the lane became full.\n\t\t\tif (WaitArea.IsFull())\n\t\t\t{\n\t\t\t\tfor (const FZoneGraphLaneHandle ConnectedLaneHandle : WaitArea.ConnectedLanes)\n\t\t\t\t{\n\t\t\t\t\tif (const FZoneGraphCrowdLaneData* LaneData = GetMutableCrowdLaneData(ConnectedLaneHandle))\n\t\t\t\t\t{\n\t\t\t\t\t\tcheckf(ZoneGraphAnnotationSubsystem != nullptr, TEXT(\"ZoneGraphAnnotationSubsystem should be initialized from the subsystem collection dependencies.\"));\n\t\t\t\t\t\t// Resend the current state, to signal the ZoneGraphCrowdLaneAnnotations to update the tags.\n\t\t\t\t\t\t// The annotations is responsible for dealing with Waiting/Closed.\n\t\t\t\t\t\t// @todo: improve the logic when we dont have two systems using state differently.\n\t\t\t\t\t\tZoneGraphAnnotationSubsystem->SendEvent(FZoneGraphCrowdLaneStateChangeEvent(ConnectedLaneHandle, LaneData->GetState()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (BestSlotIndex != INDEX_NONE)\n\t{\n\t\tOutSlotPosition = BestSlotPosition;\n\t\tOutSlotDirection = BestSlotForward;\n\t}\n\t\n\treturn BestSlotIndex;\n}\n\nvoid UMassCrowdSubsystem::ReleaseWaitingSlot(const FMassEntityHandle Entity, const FZoneGraphLaneHandle LaneHandle, const int32 SlotIndex)\n{\n\tif (!LaneHandle.IsValid())\n\t{\n\t\treturn;\n\t}\n\n\tcheckf(RegisteredLaneData.IsValidIndex(LaneHandle.DataHandle.Index), TEXT(\"Storage must have been allocated before creating lane data\"));\n\tFRegisteredCrowdLaneData& CrowdLaneData = RegisteredLaneData[LaneHandle.DataHandle.Index];\n\n\tconst FCrowdTrackingLaneData* TrackingData = CrowdLaneData.LaneToTrackingDataLookup.Find(LaneHandle.Index);\n\n\tif (TrackingData && TrackingData->WaitAreaIndex != INDEX_NONE)\n\t{\n\t\tFCrowdWaitAreaData& WaitArea = CrowdLaneData.WaitAreas[TrackingData->WaitAreaIndex];\n\n\t\tif (!WaitArea.Slots.IsValidIndex(SlotIndex))\n\t\t{\n\t\t\tUE_VLOG_UELOG(this, LogMassNavigation, Error, TEXT(\"%s Trying to release invalid slot index %d (max %d) on lane %d\"),\n\t\t\t\t*Entity.DebugGetDescription(), SlotIndex, WaitArea.Slots.Num(), LaneHandle.Index);\n\t\t\treturn;\n\t\t}\n\n\t\tconst bool bWasFull = WaitArea.IsFull();\n\n\t\tif (WaitArea.Slots[SlotIndex].bOccupied == false)\n\t\t{\n\t\t\tUE_VLOG_UELOG(this, LogMassNavigation, Error, TEXT(\"%s Trying to release already released waiting slot %d on lane %d\"),\n\t\t\t\t*Entity.DebugGetDescription(), SlotIndex, LaneHandle.Index);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWaitArea.Slots[SlotIndex].bOccupied = false;\n\t\t\tWaitArea.NumFreeSlots++;\n\t\t\t\n\t\t\tcheck(WaitArea.NumFreeSlots <= WaitArea.Slots.Num())\n\t\t}\n\t\t\n\t\t// Signal if the lane became vacant.\n\t\tif (bWasFull)\n\t\t{\n\t\t\tfor (const FZoneGraphLaneHandle ConnectedLaneHandle : WaitArea.ConnectedLanes)\n\t\t\t{\n\t\t\t\tif (const FZoneGraphCrowdLaneData* LaneData = GetMutableCrowdLaneData(ConnectedLaneHandle))\n\t\t\t\t{\n\t\t\t\t\tcheckf(ZoneGraphAnnotationSubsystem != nullptr, TEXT(\"ZoneGraphAnnotationSubsystem should be initialized from the subsystem collection dependencies.\"));\n\t\t\t\t\t// Resend the current state, to signal the ZoneGraphCrowdLaneAnnotations to update the tags.\n\t\t\t\t\t// The annotations is responsible for dealing with Waiting/Closed.\n\t\t\t\t\t// @todo: improve the logic when we dont have two systems using the state differently.\n\t\t\t\t\tZoneGraphAnnotationSubsystem->SendEvent(FZoneGraphCrowdLaneStateChangeEvent(ConnectedLaneHandle, LaneData->GetState()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n",
      "lines": 692
    },
    {
      "file_path": "MassCrowd\\Private\\MassCrowdVisualizationLODProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 5506,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCrowdVisualizationLODProcessor.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassCrowdFragments.h\"\n#include \"MassEntityManager.h\"\n#include \"MassRepresentationFragments.h\"\n\nnamespace UE::MassCrowd\n{\n\n\tMASSCROWD_API int32 GCrowdTurnOffVisualization = 0;\n\tFAutoConsoleVariableRef CVarCrowdTurnOffVisualization(TEXT(\"Mass.CrowdTurnOffVisualization\"), GCrowdTurnOffVisualization, TEXT(\"Turn off crowd visualization\"));\n\n\tint32 bDebugCrowdVisualizationLOD = 0;\n\tint32 bDebugShowISMUnderSpecifiedRange = 0;\n\n\tFAutoConsoleVariableRef ConsoleVariables[] =\n\t{\n\t\tFAutoConsoleVariableRef(TEXT(\"mass.debug.crowd.VisualizationLOD\"), bDebugCrowdVisualizationLOD, TEXT(\"Debug crowd visualization LOD\"), ECVF_Cheat),\n\t\tFAutoConsoleVariableRef(TEXT(\"mass.debug.crowd.ShowISMUnderSpecifiedRange\"), bDebugShowISMUnderSpecifiedRange, TEXT(\"Show ISM under a specified range (meters)\"), ECVF_Cheat)\n\t};\n\n} // UE::MassCrowd\n\n//----------------------------------------------------------------------//\n// UMassCrowdVisualizationLODProcessor\n//----------------------------------------------------------------------//\nUMassCrowdVisualizationLODProcessor::UMassCrowdVisualizationLODProcessor()\n{\n\tbAutoRegisterWithProcessingPhases = true;\n\n\tExecutionFlags = (int32)(EProcessorExecutionFlags::Client | EProcessorExecutionFlags::Standalone);\n\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::LOD;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LODCollector);\n}\n\nvoid UMassCrowdVisualizationLODProcessor::ConfigureQueries()\n{\n\tSuper::ConfigureQueries();\n\n\tCloseEntityQuery.AddTagRequirement<FMassCrowdTag>(EMassFragmentPresence::All);\n\tCloseEntityAdjustDistanceQuery.AddTagRequirement<FMassCrowdTag>(EMassFragmentPresence::All);\n\tFarEntityQuery.AddTagRequirement<FMassCrowdTag>(EMassFragmentPresence::All);\n\tDebugEntityQuery.AddTagRequirement<FMassCrowdTag>(EMassFragmentPresence::All);\n\n\tFilterTag = FMassCrowdTag::StaticStruct();\n}\n\nvoid UMassCrowdVisualizationLODProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tUWorld* World = EntityManager.GetWorld();\n\n\tForceOffLOD((bool)UE::MassCrowd::GCrowdTurnOffVisualization);\n\n\tTRACE_CPUPROFILER_EVENT_SCOPE(CrowdVisualizationLOD)\n\n\tSuper::Execute(EntityManager, Context);\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\tif (UE::MassCrowd::bDebugCrowdVisualizationLOD)\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(DebugDisplayLOD)\n\n\t\tDebugEntityQuery.ForEachEntityChunk(EntityManager, Context, [World](FMassExecutionContext& Context)\n\t\t{\n\t\t\tFMassVisualizationLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassVisualizationLODSharedFragment>();\n\t\t\tconst TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\t\t\tconst TConstArrayView<FMassRepresentationLODFragment> VisualizationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();\n\t\t\tLODSharedFragment.LODCalculator.DebugDisplayLOD(Context, VisualizationLODList, LocationList, World);\n\t\t});\n\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\tif (UE::MassCrowd::bDebugShowISMUnderSpecifiedRange > 0)\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(ShowISMUnderSpecifiedRange)\n\n\t\tDebugEntityQuery.ForEachEntityChunk(EntityManager, Context, [World](const FMassExecutionContext& Context)\n\t\t{\n\t\t\tconst TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\t\t\tconst TConstArrayView<FMassRepresentationFragment> RepresentationFragmentList = Context.GetFragmentView<FMassRepresentationFragment>();\n\t\t\tconst TConstArrayView<FMassViewerInfoFragment> LODInfoFragmentList = Context.GetFragmentView<FMassViewerInfoFragment>();\n\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\tconst float SpecifiedRangeSquaredCentimeters = static_cast<float>(FMath::Square(UE::MassCrowd::bDebugShowISMUnderSpecifiedRange * 100));\n\t\t\tfor (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t\t\t{\n\t\t\t\tconst FMassRepresentationFragment& RepresentationFragment = RepresentationFragmentList[EntityIdx];\n\t\t\t\tconst FMassViewerInfoFragment& LODInfoFragment = LODInfoFragmentList[EntityIdx];\n\t\t\t\tif (RepresentationFragment.CurrentRepresentation == EMassRepresentationType::StaticMeshInstance && SpecifiedRangeSquaredCentimeters > LODInfoFragment.ClosestViewerDistanceSq)\n\t\t\t\t{\n\t\t\t\t\tconst FTransformFragment& EntityLocation = LocationList[EntityIdx];\n\t\t\t\t\tDrawDebugSolidBox(World, EntityLocation.GetTransform().GetLocation() + FVector(0.0f, 0.0f, 150.0f), FVector(50.0f), FColor::Red);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\n//----------------------------------------------------------------------//\n// UMassCrowdLODCollectorProcessor\n//----------------------------------------------------------------------//\nUMassCrowdLODCollectorProcessor::UMassCrowdLODCollectorProcessor()\n{\n\tbAutoRegisterWithProcessingPhases = true;\n}\n\nvoid UMassCrowdLODCollectorProcessor::ConfigureQueries()\n{\n\tSuper::ConfigureQueries();\n\n\tEntityQuery_VisibleRangeAndOnLOD.AddTagRequirement<FMassCrowdTag>(EMassFragmentPresence::All);\n\tEntityQuery_VisibleRangeOnly.AddTagRequirement<FMassCrowdTag>(EMassFragmentPresence::All);\n\tEntityQuery_OnLODOnly.AddTagRequirement<FMassCrowdTag>(EMassFragmentPresence::All);\n\tEntityQuery_NotVisibleRangeAndOffLOD.AddTagRequirement<FMassCrowdTag>(EMassFragmentPresence::All);\n}\n",
      "lines": 119
    },
    {
      "file_path": "MassCrowd\\Private\\MassCrowdVisualizationProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 4242,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCrowdVisualizationProcessor.h\"\n#include \"MassCrowdFragments.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassActorSubsystem.h\"\n#include \"MassRepresentationFragments.h\"\n\nnamespace UE::MassCrowd\n{\n\tint32 bDebugCrowdVisualType = 0;\n\tFAutoConsoleVariableRef CVarDebugVisualType(TEXT(\"mass.debug.CrowdVisualType\"), bDebugCrowdVisualType, TEXT(\"Debug Crowd Visual Type\"), ECVF_Cheat);\n\n\tFColor CrowdRepresentationTypesColors[] =\n\t{\n\t\tFColor::Red,\n\t\tFColor::Yellow,\n\t\tFColor::Emerald,\n\t\tFColor::White,\n\t};\n} // UE::MassCrowd\n\n//----------------------------------------------------------------------//\n// UMassCrowdVisualizationProcessor\n//----------------------------------------------------------------------//\nUMassCrowdVisualizationProcessor::UMassCrowdVisualizationProcessor()\n{\n\tExecutionFlags = (int32)(EProcessorExecutionFlags::Client | EProcessorExecutionFlags::Standalone);\n\n\tbAutoRegisterWithProcessingPhases = true;\n\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LOD);\n\n\tbRequiresGameThreadExecution = true;\n}\n\nvoid UMassCrowdVisualizationProcessor::ConfigureQueries()\n{\n\tSuper::ConfigureQueries();\n\tEntityQuery.AddTagRequirement<FMassCrowdTag>(EMassFragmentPresence::All);\n}\n\n//----------------------------------------------------------------------//\n// UMassDebugCrowdVisualizationProcessor\n//----------------------------------------------------------------------//\nUMassDebugCrowdVisualizationProcessor::UMassDebugCrowdVisualizationProcessor()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)(EProcessorExecutionFlags::Client | EProcessorExecutionFlags::Standalone);\n\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LOD);\n\tExecutionOrder.ExecuteAfter.Add(UMassCrowdVisualizationProcessor::StaticClass()->GetFName());\n\n\tbRequiresGameThreadExecution = true;\n}\n\nvoid UMassDebugCrowdVisualizationProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddTagRequirement<FMassCrowdTag>(EMassFragmentPresence::All);\n\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassRepresentationFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassActorFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.RequireMutatingWorldAccess(); // due to UWorld mutable access\n}\n\nvoid UMassDebugCrowdVisualizationProcessor::Initialize(UObject& Owner)\n{\n\tSuper::Initialize(Owner);\n\n\tWorld = Owner.GetWorld();\n\tcheck(World);\n}\n\nvoid UMassDebugCrowdVisualizationProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tif (UE::MassCrowd::bDebugCrowdVisualType)\n\t{\n\t\tcheck(World);\n\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(DebugDisplayVisualType)\n\n\t\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](const FMassExecutionContext& Context)\n\t\t{\n\t\t\tconst TConstArrayView<FMassRepresentationFragment> VisualizationList = Context.GetFragmentView<FMassRepresentationFragment>();\n\t\t\tconst TConstArrayView<FMassActorFragment> ActorList = Context.GetFragmentView<FMassActorFragment>();\n\t\t\tconst TConstArrayView<FTransformFragment> EntityLocationList = Context.GetFragmentView<FTransformFragment>();\n\n\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\tfor (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t\t\t{\n\t\t\t\tconst FTransformFragment& EntityLocation = EntityLocationList[EntityIdx];\n\t\t\t\tconst FMassRepresentationFragment& Visualization = VisualizationList[EntityIdx];\n\t\t\t\tconst FMassActorFragment& ActorInfo = ActorList[EntityIdx];\n\t\t\t\tconst int32 RepresentationTypeIdx = (int32)Visualization.CurrentRepresentation;\n\t\t\t\t// Show replicated actors\n\t\t\t\tif (ActorInfo.IsValid() && !ActorInfo.IsOwnedByMass())\n\t\t\t\t{\n\t\t\t\t\tDrawDebugBox(World, EntityLocation.GetTransform().GetLocation() + FVector(0.0f, 0.0f, 120.0f), FVector(25.0f), UE::MassCrowd::CrowdRepresentationTypesColors[RepresentationTypeIdx]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{ \n\t\t\t\t\tDrawDebugSolidBox(World, EntityLocation.GetTransform().GetLocation() + FVector(0.0f, 0.0f, 120.0f), FVector(25.0f), UE::MassCrowd::CrowdRepresentationTypesColors[RepresentationTypeIdx]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n",
      "lines": 108
    },
    {
      "file_path": "MassCrowd\\Private\\MassCrowdVisualizationTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 2395,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCrowdVisualizationTrait.h\"\n#include \"MassCrowdRepresentationSubsystem.h\"\n#include \"MassCrowdRepresentationActorManagement.h\"\n#include \"MassCrowdFragments.h\"\n#include \"MassEntityTemplateRegistry.h\"\n\nUMassCrowdVisualizationTrait::UMassCrowdVisualizationTrait()\n{\n\t// Override the subsystem to support parallelization of the crowd\n\tRepresentationSubsystemClass = UMassCrowdRepresentationSubsystem::StaticClass();\n\tParams.RepresentationActorManagementClass = UMassCrowdRepresentationActorManagement::StaticClass();\n\tParams.LODRepresentation[EMassLOD::High] = EMassRepresentationType::HighResSpawnedActor;\n\tParams.LODRepresentation[EMassLOD::Medium] = EMassRepresentationType::LowResSpawnedActor;\n\tParams.LODRepresentation[EMassLOD::Low] = EMassRepresentationType::StaticMeshInstance;\n\tParams.LODRepresentation[EMassLOD::Off] = EMassRepresentationType::None;\n\t// Set bKeepLowResActor to true as a spawning optimization, this will keep the low-res actor if available while showing the static mesh instance\n\tParams.bKeepLowResActors = true;\n\tParams.bKeepActorExtraFrame = true;\n\tParams.bSpreadFirstVisualizationUpdate = false;\n\tParams.WorldPartitionGridNameContainingCollision = NAME_None;\n\tParams.NotVisibleUpdateRate = 0.5f;\n\n\tLODParams.BaseLODDistance[EMassLOD::High] = 0.f;\n\tLODParams.BaseLODDistance[EMassLOD::Medium] = 500.f;\n\tLODParams.BaseLODDistance[EMassLOD::Low] = 1000.f;\n\tLODParams.BaseLODDistance[EMassLOD::Off] = 5000.f;\n\n\tLODParams.VisibleLODDistance[EMassLOD::High] = 0.f;\n\tLODParams.VisibleLODDistance[EMassLOD::Medium] = 1000.f;\n\tLODParams.VisibleLODDistance[EMassLOD::Low] = 5000.f;\n\tLODParams.VisibleLODDistance[EMassLOD::Off] = 10000.f;\n\n\tLODParams.LODMaxCount[EMassLOD::High] = 10;\n\tLODParams.LODMaxCount[EMassLOD::Medium] = 20;\n\tLODParams.LODMaxCount[EMassLOD::Low] = 500;\n\tLODParams.LODMaxCount[EMassLOD::Off] = TNumericLimits<int32>::Max();\n\n\tLODParams.BufferHysteresisOnDistancePercentage = 20.0f;\n\tLODParams.DistanceToFrustum = 0.0f;\n\tLODParams.DistanceToFrustumHysteresis = 0.0f;\n\n\tLODParams.FilterTag = FMassCrowdTag::StaticStruct();\n}\n\nvoid UMassCrowdVisualizationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext,\n\tconst UWorld& World) const\n{\n\tSuper::BuildTemplate(BuildContext, World);\n\n\tBuildContext.RequireTag<FMassCrowdTag>();\n}\n",
      "lines": 53
    },
    {
      "file_path": "MassCrowd\\Private\\ZoneGraphCrowdLaneAnnotations.cpp",
      "extension": ".cpp",
      "size_bytes": 10250,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"ZoneGraphCrowdLaneAnnotations.h\"\n#include \"Engine/Engine.h\"\n#include \"MassCrowdSubsystem.h\"\n#include \"ZoneGraphAnnotationSubsystem.h\"\n#include \"ZoneGraphRenderingUtilities.h\"\n#include \"ZoneGraphSubsystem.h\"\n#include \"ZoneGraphQuery.h\"\n#include \"ZoneGraphSettings.h\"\n#include \"MassNavigationTypes.h\"\n#include \"VisualLogger/VisualLogger.h\"\n\n#if UE_ENABLE_DEBUG_DRAWING\n#include \"Engine/Canvas.h\"\n#endif // UE_ENABLE_DEBUG_DRAWING\n\nvoid UZoneGraphCrowdLaneAnnotations::PostSubsystemsInitialized()\n{\n\tSuper::PostSubsystemsInitialized();\n\n\tCrowdSubsystem = UWorld::GetSubsystem<UMassCrowdSubsystem>(GetWorld());\n\tcheckf(CrowdSubsystem, TEXT(\"Expecting MassCrowdSubsystem to be present.\"));\n}\n\nFZoneGraphTagMask UZoneGraphCrowdLaneAnnotations::GetAnnotationTags() const\n{\n\tFZoneGraphTagMask AllTags;\n\tAllTags.Add(CloseLaneTag);\n\tAllTags.Add(WaitingLaneTag);\n\n\treturn AllTags;\n}\n\nvoid UZoneGraphCrowdLaneAnnotations::HandleEvents(const FInstancedStructContainer& Events)\n{\n\tfor (FConstStructView Event : Events)\n\t{\n\t\tif (const FZoneGraphCrowdLaneStateChangeEvent* const StateChangeEvent = Event.GetPtr<const FZoneGraphCrowdLaneStateChangeEvent>())\n\t\t{\n\t\t\tStateChangeEvents.Add(*StateChangeEvent);\n\t\t}\n\t}\n}\n\nvoid UZoneGraphCrowdLaneAnnotations::TickAnnotation(const float DeltaTime, FZoneGraphAnnotationTagContainer& AnnotationTagContainer)\n{\n\tif (!CloseLaneTag.IsValid())\n\t{\n\t\treturn;\n\t}\n\n\tFZoneGraphTagMask AllTags;\n\tAllTags.Add(CloseLaneTag);\n\tAllTags.Add(WaitingLaneTag);\n\n\t// Process events\n\tfor (const FZoneGraphCrowdLaneStateChangeEvent& Event : StateChangeEvents)\n\t{\n\t\tif (Event.Lane.IsValid())\n\t\t{\n\t\t\tTArrayView<FZoneGraphTagMask> LaneTags = AnnotationTagContainer.GetMutableAnnotationTagsForData(Event.Lane.DataHandle);\n\t\t\tFZoneGraphTagMask& LaneTagMask = LaneTags[Event.Lane.Index];\n\n\t\t\tLaneTagMask.Remove(AllTags);\n\n\t\t\tif (Event.State == ECrowdLaneState::Closed)\n\t\t\t{\n\t\t\t\tconst FCrowdWaitAreaData* WaitArea = CrowdSubsystem->GetCrowdWaitingAreaData(Event.Lane);\n\n\t\t\t\tif (WaitArea && !WaitArea->IsFull())\n\t\t\t\t{\n\t\t\t\t\tLaneTagMask.Add(WaitingLaneTag);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLaneTagMask.Add(CloseLaneTag);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUE_VLOG_UELOG(this, LogMassNavigation, Warning, TEXT(\"Trying to set lane state %s on an invalid lane %s\\n\"), *UEnum::GetValueAsString(Event.State), *Event.Lane.ToString());\n\t\t}\n\t}\n\tStateChangeEvents.Reset();\n\n#if UE_ENABLE_DEBUG_DRAWING\n\tif (bEnableDebugDrawing)\n\t{\n\t\tMarkRenderStateDirty();\n\t}\n#endif // UE_ENABLE_DEBUG_DRAWING\n}\n\n#if UE_ENABLE_DEBUG_DRAWING\nvoid UZoneGraphCrowdLaneAnnotations::DebugDraw(FZoneGraphAnnotationSceneProxy* DebugProxy)\n{\n\tUZoneGraphSubsystem* ZoneGraph = UWorld::GetSubsystem<UZoneGraphSubsystem>(GetWorld());\n\tUZoneGraphAnnotationSubsystem* ZoneGraphAnnotationSubsystem = UWorld::GetSubsystem<UZoneGraphAnnotationSubsystem>(GetWorld());\n\tif (!ZoneGraph || !ZoneGraphAnnotationSubsystem)\n\t{\n\t\treturn;\n\t}\n\n\tconst UZoneGraphSettings* ZoneGraphSettings = GetDefault<UZoneGraphSettings>();\n\tcheck(ZoneGraphSettings);\n\n\tstatic const FVector ZOffset(0, 0, 35.0f);\n\tstatic const FLinearColor WaitingColor(FColor(255, 196, 0));\n\tstatic const FLinearColor ClosedColor(FColor(255, 61, 0));\n\n\tFZoneGraphTagMask AllTags;\n\tAllTags.Add(CloseLaneTag);\n\tAllTags.Add(WaitingLaneTag);\n\n\tFVector ViewLocation = FVector::ZeroVector;\n\tFRotator ViewRotation = FRotator::ZeroRotator;\n\tGetFirstViewPoint(ViewLocation, ViewRotation);\n\n\tconst float DrawDistance = GetMaxDebugDrawDistance();\n\tconst float DrawDistanceSq = FMath::Square(DrawDistance);\n\n\tfor (const FRegisteredCrowdLaneData& RegisteredLaneData : CrowdSubsystem->RegisteredLaneData)\n\t{\n\t\tconst FZoneGraphStorage* ZoneStorage = ZoneGraph->GetZoneGraphStorage(RegisteredLaneData.DataHandle);\n\t\tif (ZoneStorage == nullptr)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (const FZoneData& Zone : ZoneStorage->Zones)\n\t\t{\n\t\t\tconst FVector::FReal DistanceSq = FVector::DistSquared(ViewLocation, Zone.Bounds.GetCenter());\n\t\t\tif (DistanceSq > DrawDistanceSq)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int32 LaneIdx = Zone.LanesBegin; LaneIdx < Zone.LanesEnd; LaneIdx++)\n\t\t\t{\n\t\t\t\tconst FZoneGraphCrowdLaneData& LaneData = RegisteredLaneData.CrowdLaneDataArray[LaneIdx];\n\t\t\t\tif (LaneData.GetState() == ECrowdLaneState::Closed)\n\t\t\t\t{\n\t\t\t\t\tconst FZoneGraphLaneHandle LaneHandle(LaneIdx, RegisteredLaneData.DataHandle);\n\n\t\t\t\t\tFLinearColor Color = ClosedColor;\n\n\t\t\t\t\tconst FCrowdWaitAreaData* WaitArea = CrowdSubsystem->GetCrowdWaitingAreaData(LaneHandle);\n\t\t\t\t\tif (WaitArea && !WaitArea->IsFull())\n\t\t\t\t\t{\n\t\t\t\t\t\tColor = WaitingColor;\n\t\t\t\t\t}\n\n\t\t\t\t\tUE::ZoneGraph::RenderingUtilities::AppendLane(DebugProxy, *ZoneStorage, LaneHandle, Color.ToFColor(/*sRGB*/true), 4.0f, ZOffset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tauto AppendCircleXY = [DebugProxy](const FVector& Center, const float Radius, const FColor Color, const float LineThickness)\n\t\t{\n\t\t\tstatic int32 NumDivs = 16;\n\n\t\t\tFVector PrevPoint;\n\t\t\tfor (int32 Index = 0; Index <= NumDivs; Index++)\n\t\t\t{\n\t\t\t\tconst float Angle = (float)Index / (float)NumDivs * PI * 2.0f;\n\t\t\t\tfloat DirX, DirY;\n\t\t\t\tFMath::SinCos(&DirX, &DirY, Angle);\n\t\t\t\tconst FVector Dir(DirX, DirY, 0.0f);\n\t\t\t\tconst FVector Point = Center + Dir * Radius;\n\t\t\t\tif (Index > 0)\n\t\t\t\t{\n\t\t\t\t\tDebugProxy->Lines.Emplace(PrevPoint, Point, Color, LineThickness);\n\t\t\t\t}\n\t\t\t\tPrevPoint = Point;\n\t\t\t}\n\t\t};\n\n\t\tconst FColor SlotColor = FColor::Orange;\n\t\tfor (const FCrowdWaitAreaData& WaitArea : RegisteredLaneData.WaitAreas)\n\t\t{\n\t\t\tif (WaitArea.Slots.Num() > 0)\n\t\t\t{\n\t\t\t\tconst FVector::FReal DistanceSq = FVector::DistSquared(ViewLocation, WaitArea.Slots[0].Position);\n\t\t\t\tif (DistanceSq < DrawDistanceSq)\n\t\t\t\t{\n\t\t\t\t\tfor (const FCrowdWaitSlot& Slot : WaitArea.Slots)\n\t\t\t\t\t{\n\t\t\t\t\t\tAppendCircleXY(Slot.Position + ZOffset, Slot.Radius, SlotColor, 1.0f);\n\t\t\t\t\t\tDebugProxy->Lines.Emplace(Slot.Position + ZOffset, Slot.Position + Slot.Forward * Slot.Radius + ZOffset, SlotColor, 4.0f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid UZoneGraphCrowdLaneAnnotations::DebugDrawCanvas(UCanvas* Canvas, APlayerController*)\n{\n\tif (!bEnableDebugDrawing)\n\t{\n\t\treturn;\n\t}\n\n\tconst FColor OldDrawColor = Canvas->DrawColor;\n\tconst UFont* RenderFont = GEngine->GetSmallFont();\n\n\tconst FFontRenderInfo FontInfo = Canvas->CreateFontRenderInfo(/*bClipText*/true, /*bEnableShadow*/true);\n\n\tCanvas->SetDrawColor(FColor::White);\n\tstatic const FVector ZOffset(0, 0, 35.0f);\n\n\tUZoneGraphSubsystem* ZoneGraph = UWorld::GetSubsystem<UZoneGraphSubsystem>(GetWorld());\n\tUZoneGraphAnnotationSubsystem* ZoneGraphAnnotationSubsystem = UWorld::GetSubsystem<UZoneGraphAnnotationSubsystem>(GetWorld());\n\tif (!ZoneGraph)\n\t{\n\t\treturn;\n\t}\n\n\tif (Canvas->SceneView == nullptr)\n\t{\n\t\treturn;\n\t}\n\t\n\tconst FVector ViewLocation = Canvas->SceneView->ViewLocation;\n\tconst float DrawDistance = GetMaxDebugDrawDistance() * 0.25f;\n\tconst FVector::FReal DrawDistanceSq = FMath::Square(DrawDistance);\n\n\tauto InFrustum = [Canvas](const FVector& Location)\n\t{\n\t\treturn Canvas->SceneView->ViewFrustum.IntersectBox(Location, FVector::ZeroVector);\n\t};\n\n\tfor (const FRegisteredCrowdLaneData& RegisteredLaneData : CrowdSubsystem->RegisteredLaneData)\n\t{\n\t\tconst FZoneGraphStorage* ZoneStorage = RegisteredLaneData.DataHandle.IsValid() ? ZoneGraph->GetZoneGraphStorage(RegisteredLaneData.DataHandle) : nullptr;\n\t\tif (ZoneStorage == nullptr)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (const FZoneData& Zone : ZoneStorage->Zones)\n\t\t{\n\t\t\tconst FVector::FReal DistanceSq = FVector::DistSquared(ViewLocation, Zone.Bounds.GetCenter());\n\t\t\tif (DistanceSq > DrawDistanceSq)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int32 LaneIdx = Zone.LanesBegin; LaneIdx < Zone.LanesEnd; LaneIdx++)\n\t\t\t{\n\t\t\t\tconst FZoneGraphLaneHandle LaneHandle(LaneIdx, RegisteredLaneData.DataHandle);\n\t\t\t\t\n\t\t\t\tFZoneGraphLaneLocation CenterLoc;\n\t\t\t\tUE::ZoneGraph::Query::CalculateLocationAlongLaneFromRatio(*ZoneStorage, LaneIdx, 0.5f, CenterLoc);\n\n\t\t\t\tif (!InFrustum(CenterLoc.Position))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconst FVector ScreenLoc = Canvas->Project(CenterLoc.Position, /*bClampToNearPlane*/false);\n\t\t\t\t\n\t\t\t\t// Flags\n\t\t\t\tif (bDisplayTags)\n\t\t\t\t{\n\t\t\t\t\tconst FZoneGraphTagMask Mask = ZoneGraphAnnotationSubsystem->GetAnnotationTags(LaneHandle);\n\t\t\t\t\tCanvas->DrawText(RenderFont, FString::Printf(TEXT(\"%s\\n0x%08X\"), *UE::ZoneGraph::Helpers::GetTagMaskString(Mask, TEXT(\", \")), Mask.GetValue())\n\t\t\t\t\t\t, FloatCastChecked<float>(ScreenLoc.X, UE::LWC::DefaultFloatPrecision)\n\t\t\t\t\t\t, FloatCastChecked<float>(ScreenLoc.Y, UE::LWC::DefaultFloatPrecision)\n\t\t\t\t\t\t, /*XScale*/1.0f, /*YScale*/1.0f, FontInfo);\n\t\t\t\t}\n\n\t\t\t\t// Tracking\n\t\t\t\tif (const FCrowdTrackingLaneData* TrackingData = RegisteredLaneData.LaneToTrackingDataLookup.Find(LaneIdx))\n\t\t\t\t{\n\t\t\t\t\tif (TrackingData->NumEntitiesOnLane > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tCanvas->DrawText(RenderFont, FString::Printf(TEXT(\"Num Entities: %d\"), TrackingData->NumEntitiesOnLane)\n\t\t\t\t\t\t, FloatCastChecked<float>(ScreenLoc.X, UE::LWC::DefaultFloatPrecision)\n\t\t\t\t\t\t, FloatCastChecked<float>(ScreenLoc.Y + 20, UE::LWC::DefaultFloatPrecision)\n\t\t\t\t\t\t, /*XScale*/1.0f, /*YScale*/1.0f, FontInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Waiting areas\n\t\tfor (const FCrowdWaitAreaData& WaitArea : RegisteredLaneData.WaitAreas)\n\t\t{\n\t\t\tif (WaitArea.Slots.Num() > 0)\n\t\t\t{\n\t\t\t\tconst FVector::FReal DistanceSq = FVector::DistSquared(ViewLocation, WaitArea.Slots[0].Position);\n\t\t\t\tif (DistanceSq < DrawDistanceSq)\n\t\t\t\t{\n\t\t\t\t\tfor (const FCrowdWaitSlot& Slot : WaitArea.Slots)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Slot.bOccupied)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!InFrustum(Slot.Position + ZOffset))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst FVector ScreenLoc = Canvas->Project(Slot.Position + ZOffset);\n\t\t\t\t\t\t\tCanvas->DrawText(RenderFont, TEXT(\"OCCUPIED\")\n\t\t\t\t\t\t\t\t, FloatCastChecked<float>(ScreenLoc.X, UE::LWC::DefaultFloatPrecision)\n\t\t\t\t\t\t\t\t, FloatCastChecked<float>(ScreenLoc.Y, UE::LWC::DefaultFloatPrecision)\n\t\t\t\t\t\t\t\t, /*XScale*/1.0f, /*YScale*/1.0f, FontInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tCanvas->SetDrawColor(OldDrawColor);\n}\n\n#endif // UE_ENABLE_DEBUG_DRAWING\n",
      "lines": 321
    },
    {
      "file_path": "MassCrowd\\Private\\Tasks\\MassCrowdClaimWaitSlotTask.cpp",
      "extension": ".cpp",
      "size_bytes": 3334,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Tasks/MassCrowdClaimWaitSlotTask.h\"\n#include \"MassCrowdSubsystem.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"MassNavigationFragments.h\"\n#include \"MassStateTreeExecutionContext.h\"\n#include \"StateTreeLinker.h\"\n\nFMassCrowdClaimWaitSlotTask::FMassCrowdClaimWaitSlotTask()\n{\n\t// This task should not react to Enter/ExitState when the state is reselected.\n\tbShouldStateChangeOnReselect = false;\n}\n\nbool FMassCrowdClaimWaitSlotTask::Link(FStateTreeLinker& Linker)\n{\n\tLinker.LinkExternalData(LocationHandle);\n\tLinker.LinkExternalData(MoveTargetHandle);\n\tLinker.LinkExternalData(CrowdSubsystemHandle);\n\n\treturn true;\n}\n\nEStateTreeRunStatus FMassCrowdClaimWaitSlotTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\tconst FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);\n\tconst FMassEntityHandle Entity = MassContext.GetEntity();\n\t\n\tconst FMassZoneGraphLaneLocationFragment& LaneLocation = Context.GetExternalData(LocationHandle);\n\tconst FMassMoveTargetFragment& MoveTarget = Context.GetExternalData(MoveTargetHandle);\n\tUMassCrowdSubsystem& CrowdSubsystem = Context.GetExternalData(CrowdSubsystemHandle);\n\n\tFVector SlotPosition = FVector::ZeroVector;\n\tFVector SlotDirection = FVector::ForwardVector;\n\tInstanceData.WaitingSlotIndex = CrowdSubsystem.AcquireWaitingSlot(Entity, MoveTarget.Center, LaneLocation.LaneHandle, SlotPosition, SlotDirection);\n\tif (InstanceData.WaitingSlotIndex == INDEX_NONE)\n\t{\n\t\t// Failed to acquire slot\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\t\n\tInstanceData.AcquiredLane = LaneLocation.LaneHandle;\n\n\tInstanceData.WaitSlotLocation.LaneHandle = LaneLocation.LaneHandle;\n\tInstanceData.WaitSlotLocation.NextExitLinkType = EZoneLaneLinkType::None;\n\tInstanceData.WaitSlotLocation.NextLaneHandle.Reset();\n\tInstanceData.WaitSlotLocation.bMoveReverse = false;\n\tInstanceData.WaitSlotLocation.EndOfPathIntent = EMassMovementAction::Stand;\n\tInstanceData.WaitSlotLocation.EndOfPathPosition = SlotPosition;\n\tInstanceData.WaitSlotLocation.EndOfPathDirection = SlotDirection;\n\tInstanceData.WaitSlotLocation.TargetDistance = LaneLocation.LaneLength; // Go to end of lane\n\t// Let's start moving toward the interaction a bit before the entry point.\n\tInstanceData.WaitSlotLocation.AnticipationDistance.Set(100.f);\n\t\n\treturn EStateTreeRunStatus::Running;\n}\n\nvoid FMassCrowdClaimWaitSlotTask::ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\tconst FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);\n\tconst FMassEntityHandle Entity = MassContext.GetEntity();\n\n\tUMassCrowdSubsystem& CrowdSubsystem = Context.GetExternalData(CrowdSubsystemHandle);\n\n\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\t\n\tif (InstanceData.WaitingSlotIndex != INDEX_NONE)\n\t{\n\t\tCrowdSubsystem.ReleaseWaitingSlot(Entity, InstanceData.AcquiredLane, InstanceData.WaitingSlotIndex);\n\t}\n\t\n\tInstanceData.WaitingSlotIndex = INDEX_NONE;\n\tInstanceData.AcquiredLane.Reset();\n\tInstanceData.WaitSlotLocation.Reset();\n}\n",
      "lines": 78
    },
    {
      "file_path": "MassCrowd\\Private\\Tasks\\MassZoneGraphFindWanderTarget.cpp",
      "extension": ".cpp",
      "size_bytes": 6106,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Tasks/MassZoneGraphFindWanderTarget.h\"\n#include \"ZoneGraphAnnotationSubsystem.h\"\n#include \"ZoneGraphSubsystem.h\"\n#include \"ZoneGraphQuery.h\"\n#include \"MassZoneGraphNavigationFragments.h\"\n#include \"MassAIBehaviorTypes.h\"\n#include \"MassCrowdSettings.h\"\n#include \"MassCrowdSubsystem.h\"\n#include \"MassStateTreeExecutionContext.h\"\n#include \"StateTreeLinker.h\"\n#include \"MassDebugger.h\"\n\n\nFMassZoneGraphFindWanderTarget::FMassZoneGraphFindWanderTarget()\n{\n}\n\nbool FMassZoneGraphFindWanderTarget::Link(FStateTreeLinker& Linker)\n{\n\tLinker.LinkExternalData(LocationHandle);\n\tLinker.LinkExternalData(ZoneGraphSubsystemHandle);\n\tLinker.LinkExternalData(ZoneGraphAnnotationSubsystemHandle);\n\tLinker.LinkExternalData(MassCrowdSubsystemHandle);\n\n\treturn true;\n}\n\nEStateTreeRunStatus FMassZoneGraphFindWanderTarget::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const\n{\n\tconst FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);\n\n\tconst FMassZoneGraphLaneLocationFragment& LaneLocation = Context.GetExternalData(LocationHandle);\n\tconst UZoneGraphSubsystem& ZoneGraphSubsystem = Context.GetExternalData(ZoneGraphSubsystemHandle);\n\tUZoneGraphAnnotationSubsystem& ZoneGraphAnnotationSubsystem = Context.GetExternalData(ZoneGraphAnnotationSubsystemHandle);\n\tconst UMassCrowdSubsystem& MassCrowdSubsystem = Context.GetExternalData(MassCrowdSubsystemHandle);\n\n\tFInstanceDataType& InstanceData = Context.GetInstanceData(*this);\n\n\tbool bDisplayDebug = false;\n#if WITH_MASSGAMEPLAY_DEBUG\n\tbDisplayDebug = UE::Mass::Debug::IsDebuggingEntity(MassContext.GetEntity());\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\tif (!LaneLocation.LaneHandle.IsValid())\n\t{\n\t\tMASSBEHAVIOR_LOG(Error, TEXT(\"Invalid lane location.\"));\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\t\t\t\n\tconst FZoneGraphStorage* ZoneGraphStorage = ZoneGraphSubsystem.GetZoneGraphStorage(LaneLocation.LaneHandle.DataHandle);\n\tif (!ZoneGraphStorage)\n\t{\n\t\tMASSBEHAVIOR_LOG(Error, TEXT(\"Missing ZoneGraph Storage for current lane %s.\"), *LaneLocation.LaneHandle.ToString());\n\t\treturn EStateTreeRunStatus::Failed;\n\t}\n\n\tconst float MoveDistance = GetDefault<UMassCrowdSettings>()->GetMoveDistance();\n\n\tInstanceData.WanderTargetLocation.LaneHandle = LaneLocation.LaneHandle;\n\tInstanceData.WanderTargetLocation.TargetDistance = LaneLocation.DistanceAlongLane + MoveDistance;\n\tInstanceData.WanderTargetLocation.NextExitLinkType = EZoneLaneLinkType::None;\n\tInstanceData.WanderTargetLocation.NextLaneHandle.Reset();\n\tInstanceData.WanderTargetLocation.bMoveReverse = false;\n\tInstanceData.WanderTargetLocation.EndOfPathIntent = EMassMovementAction::Move;\n\n\tif (bDisplayDebug)\n\t{\n\t\tMASSBEHAVIOR_LOG(Log, TEXT(\"Find wander target.\"));\n\t}\n\n\tEStateTreeRunStatus Status = EStateTreeRunStatus::Running;\n\t\n\t// When close to end of a lane, choose next lane.\n\tif (InstanceData.WanderTargetLocation.TargetDistance > LaneLocation.LaneLength)\n\t{\n\t\tInstanceData.WanderTargetLocation.TargetDistance = FMath::Min(InstanceData.WanderTargetLocation.TargetDistance, LaneLocation.LaneLength);\n\n\t\ttypedef TTuple<const FZoneGraphLinkedLane, const float> FBranchingCandidate;\n\t\tTArray<FBranchingCandidate, TInlineAllocator<8>> Candidates;\n\t\tfloat CombinedWeight = 0.f;\n\n\t\tauto FindCandidates = [this, &ZoneGraphAnnotationSubsystem, &MassCrowdSubsystem, ZoneGraphStorage, LaneLocation, &Candidates, &CombinedWeight](const EZoneLaneLinkType Type)-> bool\n\t\t{\n\t\t\tTArray<FZoneGraphLinkedLane> LinkedLanes;\n\t\t\tUE::ZoneGraph::Query::GetLinkedLanes(*ZoneGraphStorage, LaneLocation.LaneHandle, Type, EZoneLaneLinkFlags::All, EZoneLaneLinkFlags::None, LinkedLanes);\n\n\t\t\tfor (const FZoneGraphLinkedLane& LinkedLane : LinkedLanes)\n\t\t\t{\n\t\t\t\t// Apply tag filter\n\t\t\t\tconst FZoneGraphTagMask BehaviorTags = ZoneGraphAnnotationSubsystem.GetAnnotationTags(LinkedLane.DestLane);\n\t\t\t\tif (!AllowedAnnotationTags.Pass(BehaviorTags))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Add new candidate with its selection weight based on density\n\t\t\t\tconst FZoneGraphTagMask& LaneTagMask = ZoneGraphStorage->Lanes[LinkedLane.DestLane.Index].Tags;\n\t\t\t\tconst float Weight = MassCrowdSubsystem.GetDensityWeight(LinkedLane.DestLane, LaneTagMask);\n\t\t\t\tCombinedWeight += Weight;\n\t\t\t\tCandidates.Add(MakeTuple(LinkedLane, CombinedWeight));\n\t\t\t}\n\n\t\t\treturn !Candidates.IsEmpty();\n\t\t};\n\n\t\tif (FindCandidates(EZoneLaneLinkType::Outgoing))\n\t\t{\n\t\t\tInstanceData.WanderTargetLocation.NextExitLinkType = EZoneLaneLinkType::Outgoing;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Could not continue, try to switch to an adjacent lane.\n\t\t\t// @todo: we could try to do something smarter here so that agents do not clump up. May need to have some heuristic,\n\t\t\t//\t\t  i.e. at intersections it looks better to switch lane immediately, with flee, it looks better to vary the location randomly.\n\t\t\tInstanceData.WanderTargetLocation.TargetDistance = LaneLocation.DistanceAlongLane;\n\n\t\t\t// Try adjacent lanes\n\t\t\tif (FindCandidates(EZoneLaneLinkType::Adjacent))\n\t\t\t{\n\t\t\t\t// Found adjacent lane, choose it once followed the short path. Keeping the random offset from above,\n\t\t\t\t// so that all agents dont follow until the end of the path to turn.\n\t\t\t\tInstanceData.WanderTargetLocation.NextExitLinkType = EZoneLaneLinkType::Adjacent;\n\t\t\t}\n\t\t}\n\n\t\tif (Candidates.IsEmpty())\n\t\t{\n\t\t\t// Could not find next lane, fail.\n\t\t\tInstanceData.WanderTargetLocation.Reset();\n\t\t\tStatus = EStateTreeRunStatus::Failed;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Select new lane based on the weight of each candidates\n\t\t\tconst float Rand = FMath::RandRange(0.f, CombinedWeight);\n\t\t\tfor (const FBranchingCandidate& Candidate : Candidates)\n\t\t\t{\n\t\t\t\tconst float CandidateCombinedWeight = Candidate.Get<1>();\n\t\t\t\tif (Rand < CandidateCombinedWeight)\n\t\t\t\t{\n\t\t\t\t\tconst FZoneGraphLinkedLane& LinkedLane = Candidate.Get<0>();\n\t\t\t\t\tInstanceData.WanderTargetLocation.NextLaneHandle = LinkedLane.DestLane;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Status;\n}\n",
      "lines": 152
    },
    {
      "file_path": "MassEntity\\Private\\MassArchetypeData.cpp",
      "extension": ".cpp",
      "size_bytes": 68975,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassArchetypeData.h\"\n#include \"MassEntityTypes.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassEntitySettings.h\"\n#include \"MassDebugger.h\"\n#include \"Misc/StringBuilder.h\"\n\n\nDECLARE_CYCLE_STAT(TEXT(\"Mass Archetype BatchAdd\"), STAT_Mass_ArchetypeBatchAdd, STATGROUP_Mass);\n\nnamespace UE::Mass\n{\n\tnamespace Private\n\t{\n\t\tconstexpr int32 UninitializedInt32 = -1;\n\t\tconstexpr int32 MinChunkMemorySize = 1024;\n\t\tconstexpr int32 MaxChunkMemorySize = 512 * 1024;\n\t}\n\n\tint32 SanitizeChunkMemorySize(const int32 InChunkMemorySize, const bool bLogMismatch)\n\t{\n\t\tconst int32 SanitizedSize = FMath::Clamp(InChunkMemorySize, Private::MinChunkMemorySize, Private::MaxChunkMemorySize);\n\t\tUE_CLOG(bLogMismatch && SanitizedSize != InChunkMemorySize, LogMass, Warning\n\t\t\t, TEXT(\"ChunkMemorySize sanitization resulted in changing value. Old: %d, modified: %d\")\n\t\t\t, InChunkMemorySize, SanitizedSize);\n\t\treturn SanitizedSize;\n\t}\n}\n\n//////////////////////////////////////////////////////////////////////\n// FMassArchetypeData\n\nFMassArchetypeData::FMassArchetypeData(const FMassArchetypeCreationParams& CreationParams)\n\t: NumEntitiesPerChunk(UE::Mass::Private::UninitializedInt32)\n\t, EntityListOffsetWithinChunk(UE::Mass::Private::UninitializedInt32)\n\t, ChunkMemorySize(UE::Mass::SanitizeChunkMemorySize(CreationParams.ChunkMemorySize ? CreationParams.ChunkMemorySize : GET_MASS_CONFIG_VALUE(ChunkMemorySize)))\n{\n#if WITH_MASSENTITY_DEBUG\n\tDebugNames.Add(CreationParams.DebugName);\n#endif // WITH_MASSENTITY_DEBUG\n}\n\nvoid FMassArchetypeData::ForEachFragmentType(TFunction< void(const UScriptStruct* /*Fragment*/)> Function) const\n{\n\tfor (const FMassArchetypeFragmentConfig& FragmentData : FragmentConfigs)\n\t{\n\t\tFunction(FragmentData.FragmentType);\n\t}\n}\n\nbool FMassArchetypeData::HasFragmentType(const UScriptStruct* FragmentType) const\n{\n\treturn (FragmentType && CompositionDescriptor.Fragments.Contains(*FragmentType));\n}\n\nvoid FMassArchetypeData::Initialize(const FMassArchetypeCompositionDescriptor& InCompositionDescriptor, const uint32 ArchetypeDataVersion)\n{\n\tif (!ensureMsgf(Chunks.Num() == 0, TEXT(\"Trying to re-initialize non-empty Mass Archetype is not supported\")))\n\t{\n\t\treturn;\n\t}\n\tif (!ensureMsgf(CreatedArchetypeDataVersion == 0, TEXT(\"MassArchetype has already been initialized\")))\n\t{\n\t\treturn;\n\t}\n\n\tCreatedArchetypeDataVersion = ArchetypeDataVersion;\n\tCompositionDescriptor.Fragments = InCompositionDescriptor.Fragments;\n\tConfigureFragments();\n\n\t// Tags\n\tCompositionDescriptor.Tags = InCompositionDescriptor.Tags;\n\n\t// Chunk fragments\n\tCompositionDescriptor.ChunkFragments = InCompositionDescriptor.ChunkFragments;\n\tTArray<const UScriptStruct*, TInlineAllocator<16>> ChunkFragmentList;\n\tCompositionDescriptor.ChunkFragments.ExportTypes(ChunkFragmentList);\n\tChunkFragmentList.Sort(FScriptStructSortOperator());\n\tfor (const UScriptStruct* ChunkFragmentType : ChunkFragmentList)\n\t{\n\t\tcheck(ChunkFragmentType);\n\t\tChunkFragmentsTemplate.Emplace(ChunkFragmentType);\n\t}\n\n\t// Share fragments\n\tCompositionDescriptor.SharedFragments = InCompositionDescriptor.SharedFragments;\n\tCompositionDescriptor.ConstSharedFragments = InCompositionDescriptor.ConstSharedFragments;\n\n\tEntityListOffsetWithinChunk = 0;\n}\n\nvoid FMassArchetypeData::InitializeWithSimilar(const FMassArchetypeData& BaseArchetype, FMassArchetypeCompositionDescriptor&& NewComposition, const uint32 ArchetypeDataVersion)\n{\n\tcheckf(IsInitialized() == false, TEXT(\"Trying to InitializeWithSimilar but this archetype has already been initialized\"));\n\n\tCreatedArchetypeDataVersion = ArchetypeDataVersion;\n\n\t// note that we're calling this function rarely, so we can be a little bit inefficient here.\n\tCompositionDescriptor = MoveTemp(NewComposition);\n\tif (CompositionDescriptor.Fragments != NewComposition.Fragments)\n\t{\n\t\tConfigureFragments();\n\t}\n\telse\n\t{\n\t\tFragmentConfigs = BaseArchetype.FragmentConfigs;\n\t\tFragmentIndexMap = BaseArchetype.FragmentIndexMap;\n\t\tTotalBytesPerEntity = BaseArchetype.TotalBytesPerEntity;\n\t\tNumEntitiesPerChunk = BaseArchetype.NumEntitiesPerChunk;\n\t}\n\tChunkFragmentsTemplate = BaseArchetype.ChunkFragmentsTemplate;\n\n\tEntityListOffsetWithinChunk = 0;\n}\n\nvoid FMassArchetypeData::ConfigureFragments()\n{\n\tTArray<const UScriptStruct*, TInlineAllocator<16>> SortedFragmentList;\n\tCompositionDescriptor.Fragments.ExportTypes(SortedFragmentList);\n\n\tSortedFragmentList.Sort(FScriptStructSortOperator());\n\n\t// Figure out how many bytes all of the individual fragments (and metadata) will cost per entity\n\tSIZE_T FragmentSizeTallyBytes = 0;\n\n\t// Alignment padding computation is currently very conservative and over-estimated.\n\tSIZE_T AlignmentPadding = 0;\n\t\n\t// Save room for the 'metadata' (entity array)\n\tFragmentSizeTallyBytes += sizeof(FMassEntityHandle);\n\n\t// Tally up the fragment sizes and place them in the index map\n\tFragmentConfigs.AddDefaulted(SortedFragmentList.Num());\n\tFragmentIndexMap.Reserve(SortedFragmentList.Num());\n\n\tfor (int32 FragmentIndex = 0; FragmentIndex < SortedFragmentList.Num(); ++FragmentIndex)\n\t{\n\t\tconst UScriptStruct* FragmentType = SortedFragmentList[FragmentIndex];\n\t\tcheck(FragmentType);\n\t\tFragmentConfigs[FragmentIndex].FragmentType = FragmentType;\n\n\t\tAlignmentPadding += SIZE_T(FragmentType->GetMinAlignment());\n\t\tFragmentSizeTallyBytes += SIZE_T(FragmentType->GetStructureSize());\n\n\t\tFragmentIndexMap.Add(FragmentType, FragmentIndex);\n\t}\n\n\tTotalBytesPerEntity = FragmentSizeTallyBytes;\n\tconst SIZE_T ChunkAvailableSize = GetChunkAllocSize() - AlignmentPadding;\n\tcheck(TotalBytesPerEntity <= ChunkAvailableSize);\n\n\tNumEntitiesPerChunk = static_cast<int32>(ChunkAvailableSize / TotalBytesPerEntity);\n\n\t// Set up the offsets for each fragment into the chunk data\n\tint32 CurrentOffset = NumEntitiesPerChunk * sizeof(FMassEntityHandle);\n\tfor (FMassArchetypeFragmentConfig& FragmentData : FragmentConfigs)\n\t{\n\t\tCurrentOffset = Align(CurrentOffset, FragmentData.FragmentType->GetMinAlignment());\n\t\tFragmentData.ArrayOffsetWithinChunk = CurrentOffset;\n\t\tconst int32 SizeOfThisFragmentArray = NumEntitiesPerChunk * FragmentData.FragmentType->GetStructureSize();\n\t\tCurrentOffset += SizeOfThisFragmentArray;\n\t}\n}\n\nvoid FMassArchetypeData::AddEntity(FMassEntityHandle Entity, const FMassArchetypeSharedFragmentValues& SharedFragmentValues)\n{\n\tconst int32 AbsoluteIndex = AddEntityInternal(Entity, SharedFragmentValues);\n\n\t// Initialize fragments\n\tconst int32 ChunkIndex = AbsoluteIndex / NumEntitiesPerChunk;\n\tconst int32 IndexWithinChunk = AbsoluteIndex % NumEntitiesPerChunk;\n\tFMassArchetypeChunk& Chunk = Chunks[ChunkIndex];\n\tfor (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)\n\t{\n\t\tvoid* FragmentPtr = FragmentConfig.GetFragmentData(Chunk.GetRawMemory(), IndexWithinChunk);\n\t\tFragmentConfig.FragmentType->InitializeStruct(FragmentPtr);\n\t}\n}\n\nint32 FMassArchetypeData::AddEntityInternal(FMassEntityHandle Entity, const FMassArchetypeSharedFragmentValues& SharedFragmentValues)\n{\n\tcheckf(SharedFragmentValues.IsSorted(), TEXT(\"Expecting shared fragment values to be previously sorted\"));\n\tcheckf(SharedFragmentValues.HasExactFragmentTypesMatch(CompositionDescriptor.SharedFragments, CompositionDescriptor.ConstSharedFragments)\n\t\t, TEXT(\"Expecting values for every specified shared fragment in the archetype and only those\"))\n\n\tint32 IndexWithinChunk = 0;\n\tint32 AbsoluteIndex = 0;\n\n\tFMassArchetypeChunk& DestinationChunk = GetOrAddChunk(SharedFragmentValues, AbsoluteIndex, IndexWithinChunk);\n\tDestinationChunk.AddInstance();\n\n\t// Add to the table and map\n\tEntityMap.Add(Entity.Index, AbsoluteIndex);\n\tDestinationChunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, IndexWithinChunk) = Entity;\n\n\treturn AbsoluteIndex;\n}\n\nFMassArchetypeChunk& FMassArchetypeData::GetOrAddChunk(const FMassArchetypeSharedFragmentValues& SharedFragmentValues, int32& OutAbsoluteIndex, int32& OutIndexWithinChunk)\n{\n\tOutAbsoluteIndex = 0;\n\tOutIndexWithinChunk = 0;\n\n\tint32 ChunkIndex = 0;\n\tint32 EmptyChunkIndex = INDEX_NONE;\n\tint32 EmptyAbsoluteIndex = INDEX_NONE;\n\n\tFMassArchetypeChunk* DestinationChunk = nullptr;\n\t// Check chunks for a free spot (trying to reuse the earlier ones first so later ones might get freed up) \n\t//@TODO: This could be accelerated to include a cached index to the first chunk with free spots or similar\n\tfor (FMassArchetypeChunk& Chunk : Chunks)\n\t{\n\t\tif (Chunk.GetNumInstances() == 0)\n\t\t{\n\t\t\t// Remember first empty chunk but continue looking for a chunk that has space and same group tag\n\t\t\tif (EmptyChunkIndex == INDEX_NONE)\n\t\t\t{\n\t\t\t\tEmptyChunkIndex = ChunkIndex;\n\t\t\t\tEmptyAbsoluteIndex = OutAbsoluteIndex;\n\t\t\t}\n\t\t}\n\t\telse if (Chunk.GetNumInstances() < NumEntitiesPerChunk && Chunk.GetSharedFragmentValues().IsEquivalent(SharedFragmentValues))\n\t\t{\n\t\t\tOutIndexWithinChunk = Chunk.GetNumInstances();\n\t\t\tOutAbsoluteIndex += OutIndexWithinChunk;\n\n\t\t\tDestinationChunk = &Chunk;\n\t\t\tbreak;\n\t\t}\n\t\tOutAbsoluteIndex += NumEntitiesPerChunk;\n\t\t++ChunkIndex;\n\t}\n\n\tif (DestinationChunk == nullptr)\n\t{\n\t\t// Check if it is a recycled chunk\n\t\tif (EmptyChunkIndex != INDEX_NONE)\n\t\t{\n\t\t\tDestinationChunk = &Chunks[EmptyChunkIndex];\n\t\t\tDestinationChunk->Recycle(ChunkFragmentsTemplate, SharedFragmentValues);\n\t\t\tOutAbsoluteIndex = EmptyAbsoluteIndex;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDestinationChunk = &Chunks.Emplace_GetRef(GetChunkAllocSize(), ChunkFragmentsTemplate, SharedFragmentValues);\n\t\t}\n\t}\n\n\tcheck(DestinationChunk);\n\treturn *DestinationChunk;\n}\n\nvoid FMassArchetypeData::RemoveEntity(FMassEntityHandle Entity)\n{\n\tconst int32 AbsoluteIndex = EntityMap.FindAndRemoveChecked(Entity.Index);\n\n\t// Destroy fragments\n\tconst int32 ChunkIndex = AbsoluteIndex / NumEntitiesPerChunk;\n\tconst int32 IndexWithinChunk = AbsoluteIndex % NumEntitiesPerChunk;\n\tFMassArchetypeChunk& Chunk = Chunks[ChunkIndex];\n\n\tfor (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)\n\t{\n\t\t// Destroy the fragment data\n\t\tvoid* DyingFragmentPtr = FragmentConfig.GetFragmentData(Chunk.GetRawMemory(), IndexWithinChunk);\n\t\tFragmentConfig.FragmentType->DestroyStruct(DyingFragmentPtr);\n\t}\n\n\tRemoveEntityInternal(AbsoluteIndex);\n}\n\nvoid FMassArchetypeData::RemoveEntityInternal(const int32 AbsoluteIndex)\n{\n\tconst int32 ChunkIndex = AbsoluteIndex / NumEntitiesPerChunk;\n\tconst int32 IndexWithinChunk = AbsoluteIndex % NumEntitiesPerChunk;\n\n\tFMassArchetypeChunk& Chunk = Chunks[ChunkIndex];\n\n\tconst int32 IndexToSwapFrom = Chunk.GetNumInstances() - 1;\n\n\t// Remove and swap the last entry in the chunk to the location of the removed item (if it's not the same as the dying entry)\n\tif (IndexToSwapFrom != IndexWithinChunk)\n\t{\n\t\tfor (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)\n\t\t{\n\t\t\tvoid* DyingFragmentPtr = FragmentConfig.GetFragmentData(Chunk.GetRawMemory(), IndexWithinChunk);\n\t\t\tvoid* MovingFragmentPtr = FragmentConfig.GetFragmentData(Chunk.GetRawMemory(), IndexToSwapFrom);\n\n\t\t\t// Move last entry\n\t\t\tFMemory::Memcpy(DyingFragmentPtr, MovingFragmentPtr, FragmentConfig.FragmentType->GetStructureSize());\n\t\t}\n\n\t\t// Update the entity table and map\n\t\tconst FMassEntityHandle EntityBeingSwapped = Chunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, IndexToSwapFrom);\n\t\tChunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, IndexWithinChunk) = EntityBeingSwapped;\n\t\tEntityMap.FindChecked(EntityBeingSwapped.Index) = AbsoluteIndex;\n\t}\n\t\n\tChunk.RemoveInstance();\n\n\t// If the chunk itself is empty now, see if we can remove it entirely\n\t// Note: This is only possible for trailing chunks, to avoid messing up the absolute indices in the entities map\n\twhile ((Chunks.Num() > 0) && (Chunks.Last().GetNumInstances() == 0))\n\t{\n\t\tChunks.RemoveAt(Chunks.Num() - 1, EAllowShrinking::No);\n\t}\n}\n\nvoid FMassArchetypeData::BatchDestroyEntityChunks(FMassArchetypeEntityCollection::FConstEntityRangeArrayView EntityRangeContainer, TArray<FMassEntityHandle>& OutEntitiesRemoved)\n{\n\tconst int32 InitialOutEntitiesCount = OutEntitiesRemoved.Num();\n\n\t// Sorting the subchunks info so that subchunks of a given chunk are processed \"from the back\". Otherwise removing \n\t// a subchunk from the front of the chunk would inevitably invalidate following subchunks' information.\n\tFMassArchetypeEntityCollection::FEntityRangeArray SortedRangeCollection(EntityRangeContainer);\n\tSortedRangeCollection.Sort([](const FMassArchetypeEntityCollection::FArchetypeEntityRange& A, const FMassArchetypeEntityCollection::FArchetypeEntityRange& B) \n\t\t{ \n\t\t\treturn A.ChunkIndex < B.ChunkIndex || (A.ChunkIndex == B.ChunkIndex && A.SubchunkStart > B.SubchunkStart);\n\t\t});\n\n\tfor (const FMassArchetypeEntityCollection::FArchetypeEntityRange EntityRange : SortedRangeCollection)\n\t{ \n\t\tFMassArchetypeChunk& Chunk = Chunks[EntityRange.ChunkIndex];\n\n\t\t// gather entities we're about to remove\n\t\tFMassEntityHandle* DyingEntityPtr = &Chunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, EntityRange.SubchunkStart);\n\t\tOutEntitiesRemoved.Append(DyingEntityPtr, EntityRange.Length);\n\n\t\tfor (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)\n\t\t{\n\t\t\t// Destroy the fragment data\n\t\t\tvoid* DyingFragmentPtr = FragmentConfig.GetFragmentData(Chunk.GetRawMemory(), EntityRange.SubchunkStart);\n\t\t\tFragmentConfig.FragmentType->DestroyStruct(DyingFragmentPtr, EntityRange.Length);\n\t\t}\n\n\t\tBatchRemoveEntitiesInternal(EntityRange.ChunkIndex, EntityRange.SubchunkStart, EntityRange.Length);\n\t}\n\n\tfor (int i = InitialOutEntitiesCount; i < OutEntitiesRemoved.Num(); ++i)\n\t{\n\t\tEntityMap.FindAndRemoveChecked(OutEntitiesRemoved[i].Index);\n\t}\n\n\t// If the chunk itself is empty now, see if we can remove it entirely\n\t// Note: This is only possible for trailing chunks, to avoid messing up the absolute indices in the entities map\n\twhile ((Chunks.Num() > 0) && (Chunks.Last().GetNumInstances() == 0))\n\t{\n\t\tChunks.RemoveAt(Chunks.Num() - 1, EAllowShrinking::No);\n\t}\n}\n\nbool FMassArchetypeData::HasFragmentDataForEntity(const UScriptStruct* FragmentType, int32 EntityIndex) const\n{\n\treturn (FragmentType && CompositionDescriptor.Fragments.Contains(*FragmentType));\n}\n\nvoid* FMassArchetypeData::GetFragmentDataForEntityChecked(const UScriptStruct* FragmentType, int32 EntityIndex) const\n{\n\tconst FMassRawEntityInChunkData InternalIndex = MakeEntityHandle(EntityIndex);\n\t\n\t// failing the below Find means given entity's archetype is missing given FragmentType\n\tconst int32 FragmentIndex = FragmentIndexMap.FindChecked(FragmentType);\n\treturn GetFragmentData(FragmentIndex, InternalIndex);\n}\n\nvoid* FMassArchetypeData::GetFragmentDataForEntity(const UScriptStruct* FragmentType, int32 EntityIndex) const\n{\n\tif (const int32* FragmentIndex = FragmentIndexMap.Find(FragmentType))\n\t{\n\t\tFMassRawEntityInChunkData InternalIndex = MakeEntityHandle(EntityIndex);\n\t\t// failing the below Find means given entity's archetype is missing given FragmentType\n\t\treturn GetFragmentData(*FragmentIndex, InternalIndex);\n\t}\n\treturn nullptr;\n}\n\nvoid FMassArchetypeData::SetSharedFragmentsData(const FMassEntityHandle Entity, TConstArrayView<FSharedStruct> SharedFragmentValueOverrides)\n{\n\t// Gets the current chunk where the entity is located\n\tconst int32 OldAbsoluteIndex = EntityMap.FindChecked(Entity.Index);\n\tconst int32 OldChunkIndex = OldAbsoluteIndex / NumEntitiesPerChunk;\n\tconst int32 OldIndexWithinChunk = OldAbsoluteIndex % NumEntitiesPerChunk;\n\tconst FMassArchetypeChunk& OldChunk = Chunks[OldChunkIndex];\n\n\t// Gets or adds a new chunk that will hold the new entity with the new shared values\n\tFMassArchetypeSharedFragmentValues NewSharedFragmentValues(OldChunk.GetSharedFragmentValues());\n\tNewSharedFragmentValues.ReplaceSharedFragments(SharedFragmentValueOverrides);\n\tNewSharedFragmentValues.Sort();\n\n\tint32 NewAbsoluteIndex = 0;\n\tint32 NewIndexWithinChunk = 0;\n\tFMassArchetypeChunk& NewChunk = GetOrAddChunk(NewSharedFragmentValues, NewAbsoluteIndex, NewIndexWithinChunk);\n\n\tif (ensureMsgf(&NewChunk != &OldChunk, TEXT(\"Found target chunk is the same as the source chunk. Probably \"\n\t\t\"caused by setting shared fragment values resulted in no change, meaning the target values equal the source values\")))\n\t{\n\t\tNewChunk.AddInstance();\n\n\t\t// Update the new entity in the table and map\n\t\tEntityMap[Entity.Index] = NewAbsoluteIndex;\n\t\tNewChunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, NewIndexWithinChunk) = Entity;\n\t\t\n\t\t// Move the current entity fragments into the new chunk\n\t\tMoveFragmentsToNewLocationInternal({ OldChunk.GetRawMemory(), OldIndexWithinChunk }, { NewChunk.GetRawMemory(), NewIndexWithinChunk }, 1);\n\n\t\t// Clean up the old chunk\n\t\tRemoveEntityInternal(OldAbsoluteIndex);\n\t}\n}\n\nvoid FMassArchetypeData::SetFragmentsData(const FMassEntityHandle Entity, TArrayView<const FInstancedStruct> FragmentInstances)\n{\n\tFMassRawEntityInChunkData InternalIndex = MakeEntityHandle(Entity);\n\n\tfor (const FInstancedStruct& Instance : FragmentInstances)\n\t{\n\t\tconst UScriptStruct* FragmentType = Instance.GetScriptStruct();\n\t\tcheck(FragmentType);\n\t\tconst int32 FragmentIndex = FragmentIndexMap.FindChecked(FragmentType);\n\t\tvoid* FragmentMemory = GetFragmentData(FragmentIndex, InternalIndex);\n\t\tFragmentType->CopyScriptStruct(FragmentMemory, Instance.GetMemory());\n\t}\n}\n\nvoid FMassArchetypeData::SetFragmentData(FMassArchetypeEntityCollection::FConstEntityRangeArrayView EntityRangeContainer, const FInstancedStruct& FragmentSource)\n{\n\tcheck(FragmentSource.IsValid());\n\tconst UScriptStruct* FragmentType = FragmentSource.GetScriptStruct();\n\tcheck(FragmentType);\n\tconst int32 FragmentIndex = FragmentIndexMap.FindChecked(FragmentType);\n\tconst int32 FragmentTypeSize = FragmentType->GetStructureSize();\n\tconst uint8* FragmentSourceMemory = FragmentSource.GetMemory();\n\tcheck(FragmentSourceMemory);\n\t\n\tfor (FMassArchetypeChunkIterator ChunkIterator(EntityRangeContainer); ChunkIterator; ++ChunkIterator)\n\t{\n\t\tuint8* FragmentMemory = (uint8*)FragmentConfigs[FragmentIndex].GetFragmentData(Chunks[ChunkIterator->ChunkIndex].GetRawMemory(), ChunkIterator->SubchunkStart);\n\t\tfor (int i = ChunkIterator->Length; i; --i, FragmentMemory += FragmentTypeSize)\n\t\t{\n\t\t\tFragmentType->CopyScriptStruct(FragmentMemory, FragmentSourceMemory);\n\t\t}\n\t}\n}\n\nvoid FMassArchetypeData::MoveEntityToAnotherArchetype(const FMassEntityHandle Entity, FMassArchetypeData& NewArchetype, const FMassArchetypeSharedFragmentValues* SharedFragmentValuesOverride)\n{\n\tcheck(&NewArchetype != this);\n\n\tconst int32 AbsoluteIndex = EntityMap.FindAndRemoveChecked(Entity.Index);\n\tconst int32 ChunkIndex = AbsoluteIndex / NumEntitiesPerChunk;\n\tconst int32 IndexWithinChunk = AbsoluteIndex % NumEntitiesPerChunk;\n\tFMassArchetypeChunk& Chunk = Chunks[ChunkIndex];\n\n\tconst int32 NewAbsoluteIndex = NewArchetype.AddEntityInternal(Entity, SharedFragmentValuesOverride ? *SharedFragmentValuesOverride : Chunk.GetSharedFragmentValues());\n\tconst int32 NewChunkIndex = NewAbsoluteIndex / NewArchetype.NumEntitiesPerChunk;\n\tconst int32 NewIndexWithinChunk = NewAbsoluteIndex % NewArchetype.NumEntitiesPerChunk;\n\tFMassArchetypeChunk& NewChunk = NewArchetype.Chunks[NewChunkIndex];\n\n\tMoveFragmentsToAnotherArchetypeInternal(NewArchetype, { NewChunk.GetRawMemory(), NewIndexWithinChunk }, { Chunk.GetRawMemory(), IndexWithinChunk }, /*Count=*/1);\n\n\tRemoveEntityInternal(AbsoluteIndex);\n}\n\nvoid FMassArchetypeData::ExecuteFunction(FMassExecutionContext& RunContext, const FMassExecuteFunction& Function, const FMassQueryRequirementIndicesMapping& RequirementMapping, FMassArchetypeEntityCollection::FConstEntityRangeArrayView EntityRangeContainer, const FMassChunkConditionFunction& ChunkCondition)\n{\n\tif (GetNumEntities() == 0)\n\t{\n\t\treturn;\n\t}\n\n\t// @todo do we really want users to check composition of the archetype being processed at the moment?\n\tRunContext.SetCurrentArchetypeCompositionDescriptor(GetCompositionDescriptor());\n\n\tuint32 PrevSharedFragmentValuesHash = UINT32_MAX;\n\tfor (FMassArchetypeChunkIterator ChunkIterator(EntityRangeContainer); ChunkIterator; ++ChunkIterator)\n\t{\n\t\tFMassArchetypeChunk& Chunk = Chunks[ChunkIterator->ChunkIndex];\n\n\t\tconst int32 ChunkLength = ChunkIterator->Length > 0 ? ChunkIterator->Length : (Chunk.GetNumInstances() - ChunkIterator->SubchunkStart);\n\t\tif (ChunkLength)\n\t\t{\n\t\t\tconst uint32 SharedFragmentValuesHash = GetTypeHash(Chunk.GetSharedFragmentValues());\n\t\t\tif (PrevSharedFragmentValuesHash != SharedFragmentValuesHash)\n\t\t\t{\n\t\t\t\tPrevSharedFragmentValuesHash = SharedFragmentValuesHash;\n\t\t\t\tBindConstSharedFragmentRequirements(RunContext, Chunk.GetSharedFragmentValues(), RequirementMapping.ConstSharedFragments);\n\t\t\t\tBindSharedFragmentRequirements(RunContext, Chunk.GetMutableSharedFragmentValues(), RequirementMapping.SharedFragments);\n\t\t\t}\n\n\t\t\tcheckf((ChunkIterator->SubchunkStart + ChunkLength) <= Chunk.GetNumInstances() && ChunkLength > 0, TEXT(\"Invalid subchunk, it is going over the number of instances in the chunk or it is empty.\"));\n\n\t\t\tRunContext.SetCurrentChunkSerialModificationNumber(Chunk.GetSerialModificationNumber());\n\t\t\tBindChunkFragmentRequirements(RunContext, RequirementMapping.ChunkFragments, Chunk);\n\n\t\t\tif (!ChunkCondition || ChunkCondition(RunContext))\n\t\t\t{\n\t\t\t\tBindEntityRequirements(RunContext, RequirementMapping.EntityFragments, Chunk, ChunkIterator->SubchunkStart, ChunkLength);\n\t\t\t\tFunction(RunContext);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid FMassArchetypeData::ExecuteFunction(FMassExecutionContext& RunContext, const FMassExecuteFunction& Function, const FMassQueryRequirementIndicesMapping& RequirementMapping, const FMassChunkConditionFunction& ChunkCondition)\n{\n\tif (GetNumEntities() == 0)\n\t{\n\t\treturn;\n\t}\n\n\tRunContext.SetCurrentArchetypeCompositionDescriptor(GetCompositionDescriptor());\n\n\tuint32 PrevSharedFragmentValuesHash = UINT32_MAX;\n\tfor (FMassArchetypeChunk& Chunk : Chunks)\n\t{\n\t\tif (Chunk.GetNumInstances())\n\t\t{\n\t\t\tconst uint32 SharedFragmentValuesHash = GetTypeHash(Chunk.GetSharedFragmentValues());\n\t\t\tif (PrevSharedFragmentValuesHash != SharedFragmentValuesHash)\n\t\t\t{\n\t\t\t\tPrevSharedFragmentValuesHash = SharedFragmentValuesHash;\n\t\t\t\tBindConstSharedFragmentRequirements(RunContext, Chunk.GetSharedFragmentValues(), RequirementMapping.ConstSharedFragments);\n\t\t\t\tBindSharedFragmentRequirements(RunContext, Chunk.GetMutableSharedFragmentValues(), RequirementMapping.SharedFragments);\n\t\t\t}\n\n\t\t\tRunContext.SetCurrentChunkSerialModificationNumber(Chunk.GetSerialModificationNumber());\n\t\t\tBindChunkFragmentRequirements(RunContext, RequirementMapping.ChunkFragments, Chunk);\n\n\t\t\tif (!ChunkCondition || ChunkCondition(RunContext))\n\t\t\t{\n\t\t\t\tBindEntityRequirements(RunContext, RequirementMapping.EntityFragments, Chunk, 0, Chunk.GetNumInstances());\n\t\t\t\tFunction(RunContext);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid FMassArchetypeData::ExecutionFunctionForChunk(FMassExecutionContext& RunContext, const FMassExecuteFunction& Function, const FMassQueryRequirementIndicesMapping& RequirementMapping, const FMassArchetypeEntityCollection::FArchetypeEntityRange& EntityRange, const FMassChunkConditionFunction& ChunkCondition)\n{\n\tFMassArchetypeChunk& Chunk = Chunks[EntityRange.ChunkIndex];\n\tconst int32 ChunkLength = EntityRange.Length > 0 ? EntityRange.Length : (Chunk.GetNumInstances() - EntityRange.SubchunkStart);\n\n\tif (ChunkLength)\n\t{\n\t\tBindConstSharedFragmentRequirements(RunContext, Chunk.GetSharedFragmentValues(), RequirementMapping.ConstSharedFragments);\n\t\tBindSharedFragmentRequirements(RunContext, Chunk.GetMutableSharedFragmentValues(), RequirementMapping.SharedFragments);\n\n\t\tRunContext.SetCurrentArchetypeCompositionDescriptor(GetCompositionDescriptor());\n\t\tRunContext.SetCurrentChunkSerialModificationNumber(Chunk.GetSerialModificationNumber());\n\t\tBindChunkFragmentRequirements(RunContext, RequirementMapping.ChunkFragments, Chunk);\n\n\t\tif (!ChunkCondition || ChunkCondition(RunContext))\n\t\t{\n\t\t\tBindEntityRequirements(RunContext, RequirementMapping.EntityFragments, Chunk, EntityRange.SubchunkStart, ChunkLength);\n\t\t\tFunction(RunContext);\n\t\t}\n\t}\n}\n\nint32 FMassArchetypeData::CompactEntities(const double TimeAllowed)\n{\n\tint32 TotalEntitiesMoved = 0;\n\tconst double TimeAllowedEnd = FPlatformTime::Seconds() + TimeAllowed;\n\n\tTMap<uint32, TArray<FMassArchetypeChunk*>> SortedChunksBySharedValues;\n\tfor (FMassArchetypeChunk& Chunk : Chunks)\n\t{\n\t\t// Skip already full chunks\n\t\tconst int32 NumInstances = Chunk.GetNumInstances();\n\t\tif (NumInstances > 0 && NumInstances < NumEntitiesPerChunk)\n\t\t{\n\t\t\tconst uint32 SharedFragmentHash = GetTypeHash(Chunk.GetSharedFragmentValues());\n\t\t\tTArray<FMassArchetypeChunk*>& SortedChunks = SortedChunksBySharedValues.FindOrAddByHash(SharedFragmentHash, SharedFragmentHash, TArray<FMassArchetypeChunk*>());\n\t\t\tSortedChunks.Add(&Chunk);\n\t\t}\n\t}\n\n\tfor (TPair<uint32, TArray<FMassArchetypeChunk*>>& Pair : SortedChunksBySharedValues)\n\t{\n\t\tTArray<FMassArchetypeChunk*>& SortedChunks = Pair.Value;\n\n\t\t// Check if there is anything to compact at all\n\t\tif (SortedChunks.Num() <= 1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tSortedChunks.Sort([](const FMassArchetypeChunk& LHS, const FMassArchetypeChunk& RHS)\n\t\t{\n\t\t\treturn LHS.GetNumInstances() < RHS.GetNumInstances();\n\t\t});\n\n\t\tint32 ChunkToFillSortedIdx = 0;\n\t\tint32 ChunkToEmptySortedIdx = SortedChunks.Num() - 1;\n\t\twhile (ChunkToFillSortedIdx < ChunkToEmptySortedIdx && FPlatformTime::Seconds() < TimeAllowedEnd)\n\t\t{\n\t\t\twhile (ChunkToFillSortedIdx < SortedChunks.Num() && SortedChunks[ChunkToFillSortedIdx]->GetNumInstances() == NumEntitiesPerChunk)\n\t\t\t{\n\t\t\t\tChunkToFillSortedIdx++;\n\t\t\t}\n\t\t\twhile (ChunkToEmptySortedIdx >= 0 && SortedChunks[ChunkToEmptySortedIdx]->GetNumInstances() == 0)\n\t\t\t{\n\t\t\t\tChunkToEmptySortedIdx--;\n\t\t\t}\n\t\t\tif (ChunkToFillSortedIdx >= ChunkToEmptySortedIdx)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tFMassArchetypeChunk* ChunkToFill = SortedChunks[ChunkToFillSortedIdx];\n\t\t\tFMassArchetypeChunk* ChunkToEmpty = SortedChunks[ChunkToEmptySortedIdx];\n\t\t\tconst int32 NumberOfEntitiesToMove = FMath::Min(NumEntitiesPerChunk - ChunkToFill->GetNumInstances(), ChunkToEmpty->GetNumInstances());\n\t\t\tconst int32 FromIndex = ChunkToEmpty->GetNumInstances() - NumberOfEntitiesToMove;\n\t\t\tconst int32 ToIndex = ChunkToFill->GetNumInstances();\n\t\t\tcheck(NumberOfEntitiesToMove > 0);\n\n\t\t\tMoveFragmentsToNewLocationInternal({ChunkToFill->GetRawMemory(), ToIndex}, {ChunkToEmpty->GetRawMemory(), FromIndex}\n\t\t\t\t, NumberOfEntitiesToMove);\n\n\t\t\tFMassEntityHandle* FromEntity = &ChunkToEmpty->GetEntityArrayElementRef(EntityListOffsetWithinChunk, FromIndex);\n\t\t\tFMassEntityHandle* ToEntity = &ChunkToFill->GetEntityArrayElementRef(EntityListOffsetWithinChunk, ToIndex);\n\t\t\tFMemory::Memcpy(ToEntity, FromEntity, NumberOfEntitiesToMove * sizeof(FMassEntityHandle));\n\t\t\tChunkToFill->AddMultipleInstances(NumberOfEntitiesToMove);\n\t\t\tChunkToEmpty->RemoveMultipleInstances(NumberOfEntitiesToMove);\n\n\t\t\tconst int32 ChunkToFillIdx = UE_PTRDIFF_TO_INT32(ChunkToFill - &Chunks[0]);\n\t\t\tcheck(ChunkToFillIdx >= 0 && ChunkToFillIdx < Chunks.Num());\n\t\t\tconst int32 AbsoluteIndex = ChunkToFillIdx * NumEntitiesPerChunk + ToIndex;\n\n\t\t\tfor (int32 i = 0; i < NumberOfEntitiesToMove; i++, ++ToEntity)\n\t\t\t{\n\t\t\t\tEntityMap.FindChecked(ToEntity->Index) = AbsoluteIndex + i;\n\t\t\t}\n\n\t\t\tTotalEntitiesMoved += NumberOfEntitiesToMove;\n\t\t}\n\t}\n\n\treturn TotalEntitiesMoved;\n}\n\nvoid FMassArchetypeData::GetRequirementsFragmentMapping(TConstArrayView<FMassFragmentRequirementDescription> Requirements, FMassFragmentIndicesMapping& OutFragmentIndices) const\n{\n\tOutFragmentIndices.Reset(Requirements.Num());\n\tfor (const FMassFragmentRequirementDescription& Requirement : Requirements)\n\t{\n\t\tif (Requirement.RequiresBinding())\n\t\t{\n\t\t\tconst int32* FragmentIndex = FragmentIndexMap.Find(Requirement.StructType);\n\t\t\tcheck(FragmentIndex != nullptr || Requirement.IsOptional());\n\t\t\tOutFragmentIndices.Add(FragmentIndex ? *FragmentIndex : INDEX_NONE);\n\t\t}\n\t}\n}\n\n// @todo make ChunkRequirements a dedicated type, so that we can ensure that the contents are sorted as expected by the for loop below\nvoid FMassArchetypeData::GetRequirementsChunkFragmentMapping(TConstArrayView<FMassFragmentRequirementDescription> ChunkRequirements, FMassFragmentIndicesMapping& OutFragmentIndices) const\n{\n\tint32 LastFoundFragmentIndex = -1;\n\tOutFragmentIndices.Reset(ChunkRequirements.Num());\n\tfor (const FMassFragmentRequirementDescription& Requirement : ChunkRequirements)\n\t{\n\t\tif (Requirement.RequiresBinding())\n\t\t{\n\t\t\tint32 FragmentIndex = INDEX_NONE;\n\t\t\tfor (int32 i = LastFoundFragmentIndex + 1; i < ChunkFragmentsTemplate.Num(); ++i)\n\t\t\t{\n\t\t\t\tif (ChunkFragmentsTemplate[i].GetScriptStruct()->IsChildOf(Requirement.StructType))\n\t\t\t\t{\n\t\t\t\t\tFragmentIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcheck(FragmentIndex != INDEX_NONE || Requirement.IsOptional());\n\t\t\tOutFragmentIndices.Add(FragmentIndex);\n\t\t\tLastFoundFragmentIndex = FragmentIndex;\n\t\t}\n\t}\n}\n\nvoid FMassArchetypeData::GetRequirementsConstSharedFragmentMapping(TConstArrayView<FMassFragmentRequirementDescription> Requirements, FMassFragmentIndicesMapping& OutFragmentIndices) const\n{\n\tif (Chunks.Num() == 0)\n\t{\n\t\treturn;\n\t}\n\t// All shared fragment values for this archetype should have deterministic indices, so anyone will work to calculate them\n\tconst FMassArchetypeSharedFragmentValues& SharedFragmentValues = Chunks[0].GetSharedFragmentValues();\n\n\tOutFragmentIndices.Reset(Requirements.Num());\n\tfor (const FMassFragmentRequirementDescription& Requirement : Requirements)\n\t{\n\t\tif (Requirement.RequiresBinding())\n\t\t{\n\t\t\tconst int32 FragmentIndex = SharedFragmentValues.GetConstSharedFragments().IndexOfByPredicate(FStructTypeEqualOperator(Requirement.StructType));\n\t\t\tcheck(FragmentIndex != INDEX_NONE || Requirement.IsOptional());\n\t\t\tOutFragmentIndices.Add(FragmentIndex);\n\t\t}\n\t}\n}\n\nvoid FMassArchetypeData::GetRequirementsSharedFragmentMapping(TConstArrayView<FMassFragmentRequirementDescription> Requirements, FMassFragmentIndicesMapping& OutFragmentIndices) const\n{\n\tif (Chunks.Num() == 0)\n\t{\n\t\treturn;\n\t}\n\n\t// All shared fragment values for this archetype should have deterministic indices, so anyone will work to calculate them\n\tconst FMassArchetypeSharedFragmentValues& SharedFragmentValues = Chunks[0].GetSharedFragmentValues();\n\n\tOutFragmentIndices.Reset(Requirements.Num());\n\tfor (const FMassFragmentRequirementDescription& Requirement : Requirements)\n\t{\n\t\tif (Requirement.RequiresBinding())\n\t\t{\n\t\t\tconst int32 FragmentIndex = SharedFragmentValues.GetSharedFragments().IndexOfByPredicate(FStructTypeEqualOperator(Requirement.StructType));\n\t\t\tcheck(FragmentIndex != INDEX_NONE || Requirement.IsOptional());\n\t\t\tOutFragmentIndices.Add(FragmentIndex);\n\t\t}\n\t}\n}\n\nvoid FMassArchetypeData::BindEntityRequirements(FMassExecutionContext& RunContext, const FMassFragmentIndicesMapping& EntityFragmentsMapping, FMassArchetypeChunk& Chunk, const int32 SubchunkStart, const int32 SubchunkLength)\n{\n\t// auto-correcting number of entities to process in case SubchunkStart +  SubchunkLength > Chunk.GetNumInstances()\n\tconst int32 NumEntities = SubchunkLength >= 0 ? FMath::Min(SubchunkLength, Chunk.GetNumInstances() - SubchunkStart) : Chunk.GetNumInstances();\n\tcheck(SubchunkStart >= 0 && SubchunkStart < Chunk.GetNumInstances());\n\n\tif (EntityFragmentsMapping.Num() > 0)\n\t{\n\t\tcheck(RunContext.GetMutableRequirements().Num() == EntityFragmentsMapping.Num());\n\n\t\tfor (int i = 0; i < EntityFragmentsMapping.Num(); ++i)\n\t\t{\n\t\t\tFMassExecutionContext::FFragmentView& Requirement = RunContext.FragmentViews[i];\n\t\t\tconst int32 FragmentIndex = EntityFragmentsMapping[i];\n\n\t\t\tcheck(FragmentIndex != INDEX_NONE || Requirement.Requirement.IsOptional());\n\t\t\tif (FragmentIndex != INDEX_NONE)\n\t\t\t{\n\t\t\t\tRequirement.FragmentView = TArrayView<FMassFragment>((FMassFragment*)GetFragmentData(FragmentIndex, Chunk.GetRawMemory(), SubchunkStart), NumEntities);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// @todo this might not be needed\n\t\t\t\tRequirement.FragmentView = TArrayView<FMassFragment>();\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Map in the required data arrays from the current chunk to the array views\n\t\tfor (FMassExecutionContext::FFragmentView& Requirement : RunContext.GetMutableRequirements())\n\t\t{\n\t\t\tconst int32* FragmentIndex = FragmentIndexMap.Find(Requirement.Requirement.StructType);\n\t\t\tcheck(FragmentIndex != nullptr || Requirement.Requirement.IsOptional());\n\t\t\tif (FragmentIndex)\n\t\t\t{\n\t\t\t\tRequirement.FragmentView = TArrayView<FMassFragment>((FMassFragment*)GetFragmentData(*FragmentIndex, Chunk.GetRawMemory(), SubchunkStart), NumEntities);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRequirement.FragmentView = TArrayView<FMassFragment>();\n\t\t\t}\n\t\t}\n\t}\n\n\tRunContext.EntityListView = TArrayView<FMassEntityHandle>(&Chunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, SubchunkStart), NumEntities);\n}\n\nvoid FMassArchetypeData::BindChunkFragmentRequirements(FMassExecutionContext& RunContext, const FMassFragmentIndicesMapping& ChunkFragmentsMapping, FMassArchetypeChunk& Chunk)\n{\n\tif (ChunkFragmentsMapping.Num() > 0)\n\t{\n\t\tcheck(RunContext.GetMutableChunkRequirements().Num() == ChunkFragmentsMapping.Num());\n\n\t\tfor (int i = 0; i < ChunkFragmentsMapping.Num(); ++i)\n\t\t{\n\t\t\tFMassExecutionContext::FChunkFragmentView& ChunkRequirement = RunContext.ChunkFragmentViews[i];\n\t\t\tconst int32 ChunkFragmentIndex = ChunkFragmentsMapping[i];\n\n\t\t\tcheck(ChunkFragmentIndex != INDEX_NONE || ChunkRequirement.Requirement.IsOptional());\n\t\t\tChunkRequirement.FragmentView = ChunkFragmentIndex != INDEX_NONE ? Chunk.GetMutableChunkFragmentViewChecked(ChunkFragmentIndex) : FStructView();\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (FMassExecutionContext::FChunkFragmentView& ChunkRequirement : RunContext.GetMutableChunkRequirements())\n\t\t{\n\t\t\tFInstancedStruct* ChunkFragmentInstance = Chunk.FindMutableChunkFragment(ChunkRequirement.Requirement.StructType);\n\t\t\tcheck(ChunkFragmentInstance != nullptr || ChunkRequirement.Requirement.IsOptional());\n\t\t\tChunkRequirement.FragmentView = ChunkFragmentInstance ? FStructView(*ChunkFragmentInstance) : FStructView();\n\t\t}\n\t}\n}\n\nvoid FMassArchetypeData::BindConstSharedFragmentRequirements(FMassExecutionContext& RunContext, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, const FMassFragmentIndicesMapping& FragmentsMapping)\n{\n\tif (FragmentsMapping.Num() > 0)\n\t{\n\t\tcheck(RunContext.GetMutableConstSharedRequirements().Num() == FragmentsMapping.Num());\n\n\t\tfor (int i = 0; i < FragmentsMapping.Num(); ++i)\n\t\t{\n\t\t\tFMassExecutionContext::FConstSharedFragmentView& Requirement = RunContext.ConstSharedFragmentViews[i];\n\t\t\tconst int32 FragmentIndex = FragmentsMapping[i];\n\n\t\t\tcheck(FragmentIndex != INDEX_NONE || Requirement.Requirement.IsOptional());\n\t\t\tRequirement.FragmentView = FragmentIndex != INDEX_NONE ? FConstStructView(SharedFragmentValues.GetConstSharedFragments()[FragmentIndex]) : FConstStructView();\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (FMassExecutionContext::FConstSharedFragmentView& Requirement : RunContext.GetMutableConstSharedRequirements())\n\t\t{\n\t\t\tconst FConstSharedStruct* SharedFragment = SharedFragmentValues.GetConstSharedFragments().FindByPredicate(FStructTypeEqualOperator(Requirement.Requirement.StructType) );\n\t\t\tcheck(SharedFragment != nullptr || Requirement.Requirement.IsOptional());\n\t\t\tRequirement.FragmentView = SharedFragment ? FConstStructView(*SharedFragment) : FConstStructView();\n\t\t}\n\t}\n}\n\nvoid FMassArchetypeData::BindSharedFragmentRequirements(FMassExecutionContext& RunContext, FMassArchetypeSharedFragmentValues& SharedFragmentValues, const FMassFragmentIndicesMapping& FragmentsMapping)\n{\n\tif (FragmentsMapping.Num() > 0)\n\t{\n\t\tcheck(RunContext.GetMutableSharedRequirements().Num() == FragmentsMapping.Num());\n\n\t\tfor (int i = 0; i < FragmentsMapping.Num(); ++i)\n\t\t{\n\t\t\tFMassExecutionContext::FSharedFragmentView& Requirement = RunContext.SharedFragmentViews[i];\n\t\t\tconst int32 FragmentIndex = FragmentsMapping[i];\n\n\t\t\tcheck(FragmentIndex != INDEX_NONE || Requirement.Requirement.IsOptional());\n\t\t\tRequirement.FragmentView = FragmentIndex != INDEX_NONE ? FStructView(SharedFragmentValues.GetMutableSharedFragments()[FragmentIndex]) : FStructView();\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (FMassExecutionContext::FSharedFragmentView& Requirement : RunContext.GetMutableSharedRequirements())\n\t\t{\n\t\t\tFSharedStruct* SharedFragment = SharedFragmentValues.GetMutableSharedFragments().FindByPredicate(FStructTypeEqualOperator(Requirement.Requirement.StructType));\n\t\t\tcheck(SharedFragment != nullptr || Requirement.Requirement.IsOptional());\n\t\t\tRequirement.FragmentView = SharedFragment ? FStructView(*SharedFragment) : FStructView();\n\t\t}\n\t}\n}\n\nint32 FMassArchetypeData::GetNonEmptyChunkCount() const\n{\n\tint32 NumAllocatedChunks = 0;\n\tfor (const FMassArchetypeChunk& Chunk : Chunks)\n\t{\n\t\tif (Chunk.GetRawMemory() != nullptr)\n\t\t{\n\t\t\t++NumAllocatedChunks;\n\t\t}\n\t}\n\treturn NumAllocatedChunks;\n}\n\nSIZE_T FMassArchetypeData::GetAllocatedSize() const\n{\n\tconst int32 NumAllocatedChunkBuffers = GetNonEmptyChunkCount();\n\n\treturn sizeof(FMassArchetypeData) +\n\t\tChunkFragmentsTemplate.GetAllocatedSize() +\n\t\tFragmentConfigs.GetAllocatedSize() +\n\t\tChunks.GetAllocatedSize() +\n\t\t(NumAllocatedChunkBuffers * GetChunkAllocSize()) +\n\t\tEntityMap.GetAllocatedSize() +\n\t\tFragmentIndexMap.GetAllocatedSize();\n}\n\nFString FMassArchetypeData::DebugGetDescription() const\n{\n#if WITH_MASSENTITY_DEBUG\n\tFStringOutputDevice OutDescription;\n\n\tif (!DebugNames.IsEmpty())\n\t{\n\t\tOutDescription += TEXT(\"Name: \");\n\t\tOutDescription += GetCombinedDebugNamesAsString();\n\t\tOutDescription += TEXT(\"\\n\");\n\t}\n\tOutDescription += TEXT(\"Chunk fragments: \");\n\tCompositionDescriptor.ChunkFragments.DebugGetStringDesc(OutDescription);\n\tOutDescription += TEXT(\"\\nTags: \");\n\tCompositionDescriptor.Tags.DebugGetStringDesc(OutDescription);\n\tOutDescription += TEXT(\"\\nFragments: \");\n\tCompositionDescriptor.Fragments.DebugGetStringDesc(OutDescription);\n\t\n\treturn static_cast<FString>(OutDescription);\n#else\n\treturn {};\n#endif\n}\n\n#if WITH_MASSENTITY_DEBUG\nvoid FMassArchetypeData::DebugGetEntityMemoryNumbers(SIZE_T& OutActiveChunksMemorySize, SIZE_T& OutActiveEntitiesMemorySize) const\n{\n\tOutActiveChunksMemorySize = GetChunkAllocSize() * GetNonEmptyChunkCount();\n\tOutActiveEntitiesMemorySize = TotalBytesPerEntity * EntityMap.Num();\n}\n\nFString FMassArchetypeData::GetCombinedDebugNamesAsString() const\n{\n\tTStringBuilder<256> StringBuilder;\n\tfor (int i = 0; i < DebugNames.Num(); i++)\n\t{\n\t\tif (i > 0)\n\t\t{\n\t\t\tStringBuilder.Append(TEXT(\", \"));;\n\t\t}\n\t\tStringBuilder.Append(DebugNames[i].ToString());\n\t}\n\treturn StringBuilder.ToString();\n}\n\nvoid FMassArchetypeData::DebugPrintArchetype(FOutputDevice& Ar)\n{\n\tAr.Logf(ELogVerbosity::Log, TEXT(\"Name: %s\"), *GetCombinedDebugNamesAsString());\n\n\tFStringOutputDevice TagsDecription;\n\tCompositionDescriptor.Tags.DebugGetStringDesc(TagsDecription);\n\tAr.Logf(ELogVerbosity::Log, TEXT(\"Tags: %s\"), *TagsDecription);\n\tAr.Logf(ELogVerbosity::Log, TEXT(\"Fragments: %s\"), *DebugGetDescription());\n\tAr.Logf(ELogVerbosity::Log, TEXT(\"\\tChunks: %d x %d KB = %d KB total\"), Chunks.Num(), GetChunkAllocSize() / 1024, (GetChunkAllocSize()*Chunks.Num()) / 1024);\n\t\n\tint ChunkWithFragmentsCount = 0;\n\tfor (FMassArchetypeChunk& Chunk : Chunks)\n\t{\n\t\tChunkWithFragmentsCount += Chunk.DebugGetChunkFragmentCount() > 0 ? 1 : 0;\n\t}\n\tif (ChunkWithFragmentsCount)\n\t{\n\t\tAr.Logf(ELogVerbosity::Log, TEXT(\"\\tChunks with fragments: %d\"), ChunkWithFragmentsCount);\n\t}\n\n\tconst int32 CurrentEntityCapacity = Chunks.Num() * NumEntitiesPerChunk;\n\tAr.Logf(ELogVerbosity::Log, TEXT(\"\\tEntity Count    : %d\"), EntityMap.Num());\n\tAr.Logf(ELogVerbosity::Log, TEXT(\"\\tEntity Capacity : %d\"), CurrentEntityCapacity);\n\tif (Chunks.Num() > 1)\n\t{\n\t\tconst float Scaler = 100.0f / static_cast<float>(CurrentEntityCapacity);\n\t\t// count non-last chunks to see how occupied they are\n\t\tint EntitiesPerChunkMin = CurrentEntityCapacity;\n\t\tint EntitiesPerChunkMax = 0;\n\t\tfor (int ChunkIndex = 0; ChunkIndex < Chunks.Num() - 1; ++ChunkIndex)\n\t\t{\n\t\t\tconst int Population = Chunks[ChunkIndex].GetNumInstances();\n\t\t\tEntitiesPerChunkMin = FMath::Min(Population, EntitiesPerChunkMin);\n\t\t\tEntitiesPerChunkMax = FMath::Max(Population, EntitiesPerChunkMax);\n\t\t}\n\t\tAr.Logf(ELogVerbosity::Log, TEXT(\"\\tEntity Occupancy: %.1f%% (min: %.1f%%, max: %.1f%%)\"),\n\t\t\tScaler * static_cast<float>(EntityMap.Num()),\n\t\t\tScaler * static_cast<float>(EntitiesPerChunkMin),\n\t\t\tScaler * static_cast<float>(EntitiesPerChunkMax));\n\t}\n\telse \n\t{\n\t\tAr.Logf(ELogVerbosity::Log, TEXT(\"\\tEntity Occupancy: %.1f%%\"),\n\t\t\tCurrentEntityCapacity > 0 ? ((static_cast<float>(EntityMap.Num()) * 100.0f) / static_cast<float>(CurrentEntityCapacity)) : 0.f);\n\t}\n\tAr.Logf(ELogVerbosity::Log, TEXT(\"\\tBytes / Entity  : %zu\"), TotalBytesPerEntity);\n\tAr.Logf(ELogVerbosity::Log, TEXT(\"\\tEntities / Chunk: %d\"), NumEntitiesPerChunk);\n\n\tAr.Logf(ELogVerbosity::Log, TEXT(\"\\tOffset 0x%04X: Entity[] (%llu bytes each)\"), EntityListOffsetWithinChunk, sizeof(FMassEntityHandle));\n\tint32 TotalBytesOfValidData = sizeof(FMassEntityHandle) * NumEntitiesPerChunk;\n\tfor (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)\n\t{\n\t\tTotalBytesOfValidData += FragmentConfig.FragmentType->GetStructureSize() * NumEntitiesPerChunk;\n\t\tAr.Logf(ELogVerbosity::Log, TEXT(\"\\tOffset 0x%04X: %s[] (%d bytes each)\"), FragmentConfig.ArrayOffsetWithinChunk, *FragmentConfig.FragmentType->GetName(), FragmentConfig.FragmentType->GetStructureSize());\n\t}\n\n\t//@TODO: Print out padding in between things?\n\n\tconst SIZE_T UnusuablePaddingOffset = TotalBytesPerEntity * NumEntitiesPerChunk;\n\tconst SIZE_T UnusuablePaddingAmount = GetChunkAllocSize() - UnusuablePaddingOffset;\n\tif (UnusuablePaddingAmount > 0)\n\t{\n\t\tAr.Logf(ELogVerbosity::Log, TEXT(\"\\tOffset 0x%04X: WastePadding[] (%d bytes total)\"), UnusuablePaddingOffset, UnusuablePaddingAmount);\n\t}\n\n\tif (GetChunkAllocSize() != TotalBytesOfValidData + UnusuablePaddingAmount)\n\t{\n\t\tAr.Logf(ELogVerbosity::Log, TEXT(\"\\t@TODO: EXTRA PADDING HERE:  TotalBytesOfValidData: %d (%d missing)\"), TotalBytesOfValidData, GetChunkAllocSize() - TotalBytesOfValidData);\n\t}\n}\n\nvoid FMassArchetypeData::DebugPrintEntity(FMassEntityHandle Entity, FOutputDevice& Ar, const TCHAR* InPrefix) const\n{\n\tfor (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)\n\t{\n\t\tvoid* Data = GetFragmentDataForEntityChecked(FragmentConfig.FragmentType, Entity.Index);\n\t\t\n\t\tFString FragmentName = FragmentConfig.FragmentType->GetName();\n\t\tFragmentName.RemoveFromStart(InPrefix);\n\n\t\tFString ValueStr;\n\t\tFragmentConfig.FragmentType->ExportText(ValueStr, Data, /*Default*/nullptr, /*OwnerObject*/nullptr, EPropertyPortFlags::PPF_IncludeTransient, /*ExportRootScope*/nullptr);\n\n\t\tAr.Logf(TEXT(\"%s: %s\"), *FragmentName, *ValueStr);\n\t}\n}\n\n#endif // WITH_MASSENTITY_DEBUG\n\nvoid FMassArchetypeData::REMOVEME_GetArrayViewForFragmentInChunk(int32 ChunkIndex, const UScriptStruct* FragmentType, void*& OutChunkBase, int32& OutNumEntities)\n{\n\tconst FMassArchetypeChunk& Chunk = Chunks[ChunkIndex];\n\tconst int32 FragmentIndex = FragmentIndexMap.FindChecked(FragmentType);\n\n\tOutChunkBase = FragmentConfigs[FragmentIndex].GetFragmentData(Chunk.GetRawMemory(), 0);\n\tOutNumEntities = Chunk.GetNumInstances();\n}\n\n//////////////////////////////////////////////////////////////////////\n// FMassArchetypeData batched api\n\nvoid FMassArchetypeData::BatchAddEntities(TConstArrayView<FMassEntityHandle> Entities, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, TArray<FMassArchetypeEntityCollection::FArchetypeEntityRange>& OutNewRanges)\n{\n\tSCOPE_CYCLE_COUNTER(STAT_Mass_ArchetypeBatchAdd);\n\n\ttestableCheckfReturn(SharedFragmentValues.HasExactSharedFragmentTypesMatch(GetCompositionDescriptor().SharedFragments), return, TEXT(\"%hs parameter SharedFragmentValues doesn't match archetype's composition\"), __FUNCTION__);\n\ttestableCheckfReturn(SharedFragmentValues.HasExactConstSharedFragmentTypesMatch(GetCompositionDescriptor().ConstSharedFragments), return, TEXT(\"%hs parameter ConstSharedFragmentValues doesn't match archetype's composition\"), __FUNCTION__);\n\n\tFMassArchetypeEntityCollection::FArchetypeEntityRange ResultSubchunk;\n\tResultSubchunk.ChunkIndex = 0;\n\tint32 NumberMoved = 0;\n\tdo \n\t{\n\t\tResultSubchunk = PrepareNextEntitiesSpanInternal(MakeArrayView(Entities.GetData() + NumberMoved, Entities.Num() - NumberMoved), SharedFragmentValues, ResultSubchunk.ChunkIndex);\n\t\tcheck(Chunks.IsValidIndex(ResultSubchunk.ChunkIndex) && Chunks[ResultSubchunk.ChunkIndex].IsValidSubChunk(ResultSubchunk.SubchunkStart, ResultSubchunk.Length));\n\t\t\n\t\tfor (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)\n\t\t{\n\t\t\tvoid* FragmentPtr = FragmentConfig.GetFragmentData(Chunks[ResultSubchunk.ChunkIndex].GetRawMemory(), ResultSubchunk.SubchunkStart);\n\t\t\tFragmentConfig.FragmentType->InitializeStruct(FragmentPtr, ResultSubchunk.Length);\n\t\t}\n\n\t\tNumberMoved += ResultSubchunk.Length;\n\n\t\tOutNewRanges.Add(ResultSubchunk);\n\n\t} while (NumberMoved < Entities.Num());\n}\n\nvoid FMassArchetypeData::BatchMoveEntitiesToAnotherArchetype(const FMassArchetypeEntityCollection& EntityCollection\n\t, FMassArchetypeData& NewArchetype, TArray<FMassEntityHandle>& OutEntitiesBeingMoved\n\t, TArray<FMassArchetypeEntityCollection::FArchetypeEntityRange>* OutNewRanges, const FMassArchetypeSharedFragmentValues* SharedFragmentValuesToAdd\n\t, const FMassSharedFragmentBitSet* SharedFragmentToRemoveBitSet, const FMassConstSharedFragmentBitSet* ConstSharedFragmentToRemoveBitSet)\n{\n\tcheck(&NewArchetype != this);\n\n\t// verify the new archetype's shared fragment composition matches current archetype's composition modified as requested\n\tif (SharedFragmentValuesToAdd)\n\t{\n\t\tbool bIsValidArchetype = true;\n\t\tif (SharedFragmentToRemoveBitSet)\n\t\t{\n\t\t\tFMassSharedFragmentBitSet NewSharedFragmentsBitset = GetSharedFragmentBitSet();\n\t\t\tNewSharedFragmentsBitset -= *SharedFragmentToRemoveBitSet;\n\t\t\tNewSharedFragmentsBitset += SharedFragmentValuesToAdd->GetSharedFragmentBitSet();\n\t\t\tbIsValidArchetype = NewArchetype.GetCompositionDescriptor().SharedFragments == NewSharedFragmentsBitset;\n\t\t}\n\n\t\tif (bIsValidArchetype && ConstSharedFragmentToRemoveBitSet)\n\t\t{\n\t\t\tFMassConstSharedFragmentBitSet NewConstSharedFragmentsBitset = GetConstSharedFragmentBitSet();\n\t\t\tNewConstSharedFragmentsBitset -= *ConstSharedFragmentToRemoveBitSet;\n\t\t\tNewConstSharedFragmentsBitset += SharedFragmentValuesToAdd->GetConstSharedFragmentBitSet();\n\t\t\tbIsValidArchetype = NewArchetype.GetCompositionDescriptor().ConstSharedFragments == NewConstSharedFragmentsBitset;\n\t\t}\n\n\t\ttestableCheckfReturn(bIsValidArchetype, return, TEXT(\"%hs parameter SharedFragmentValues doesn't match archetype's composition\"), __FUNCTION__);\n\t}\n\n\tTArray<FMassArchetypeEntityCollection::FArchetypeEntityRange> Subchunks(EntityCollection.GetRanges());\n\n\tconst int32 InitialOutEntitiesCount = OutEntitiesBeingMoved.Num();\n\n\tfor (const FMassArchetypeEntityCollection::FArchetypeEntityRange EntityRange : Subchunks)\n\t{\n\t\tif (!ensureMsgf(EntityRange.IsSet() && EntityRange.Length > 0, TEXT(\"We only expect to get valid EntityRanges at this point.\")))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tFMassArchetypeChunk& Chunk = Chunks[EntityRange.ChunkIndex];\n\n\t\t// 0 - consider compacting new archetype to ensure larger empty spaces\n\t\t// 1. find next free spot in the destination archetype\n\t\t// 2. min(amount of elements) to move\n\n\t\t// gather entities we're about to remove\n\t\tFMassEntityHandle* DyingEntityPtr = &Chunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, EntityRange.SubchunkStart);\n\t\tOutEntitiesBeingMoved.Append(DyingEntityPtr, EntityRange.Length);\n\n\t\tFMassArchetypeEntityCollection::FArchetypeEntityRange ResultSubChunk;\n\t\tResultSubChunk.ChunkIndex = 0;\n\t\tResultSubChunk.Length = 0;\n\t\tint32 NumberMoved = 0;\n\t\tconst bool ChangeSharedFragments = SharedFragmentValuesToAdd || SharedFragmentToRemoveBitSet;\n\n\t\tdo\n\t\t{\n\t\t\tconst int32 IndexWithinChunk = EntityRange.SubchunkStart + NumberMoved;\n\n\t\t\tif (ChangeSharedFragments == false)\n\t\t\t{\n\t\t\t\tResultSubChunk = NewArchetype.PrepareNextEntitiesSpanInternal(MakeArrayView(DyingEntityPtr + NumberMoved, EntityRange.Length - NumberMoved)\n\t\t\t\t\t, Chunk.GetSharedFragmentValues(), ResultSubChunk.ChunkIndex);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// create new shared values\n\t\t\t\tFMassArchetypeSharedFragmentValues NewSharedValues = Chunk.GetSharedFragmentValues();\n\t\t\t\tif (SharedFragmentToRemoveBitSet)\n\t\t\t\t{\n\t\t\t\t\tNewSharedValues.Remove(*SharedFragmentToRemoveBitSet);\n\t\t\t\t}\n\t\t\t\tif (ConstSharedFragmentToRemoveBitSet)\n\t\t\t\t{\n\t\t\t\t\tNewSharedValues.Remove(*ConstSharedFragmentToRemoveBitSet);\n\t\t\t\t}\n\t\t\t\tif (SharedFragmentValuesToAdd)\n\t\t\t\t{\n\t\t\t\t\tNewSharedValues.Append(*SharedFragmentValuesToAdd);\n\t\t\t\t}\n\t\t\t\tNewSharedValues.Sort();\n\n\t\t\t\tResultSubChunk = NewArchetype.PrepareNextEntitiesSpanInternal(MakeArrayView(DyingEntityPtr + NumberMoved, EntityRange.Length - NumberMoved)\n\t\t\t\t\t, NewSharedValues, ResultSubChunk.ChunkIndex);\n\t\t\t}\n\n\t\t\tFMassArchetypeChunk& NewChunk = NewArchetype.Chunks[ResultSubChunk.ChunkIndex];\n\t\t\tMoveFragmentsToAnotherArchetypeInternal(NewArchetype, {NewChunk.GetRawMemory(), ResultSubChunk.SubchunkStart}, {Chunk.GetRawMemory(), IndexWithinChunk}, ResultSubChunk.Length);\n\n\t\t\tNumberMoved += ResultSubChunk.Length;\n\n\t\t\tif (OutNewRanges)\n\t\t\t{\n\t\t\t\t// if the new ResultSubChunk is right next to the last stored one then merge them both\n\t\t\t\tif (OutNewRanges->Num() && OutNewRanges->Last().IsAdjacentAfter(ResultSubChunk))\n\t\t\t\t{\n\t\t\t\t\tOutNewRanges->Last().Length += ResultSubChunk.Length;\n\t\t\t\t}\n\t\t\t\telse // just add\n\t\t\t\t{\n\t\t\t\t\tOutNewRanges->Add(ResultSubChunk);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} while (NumberMoved < EntityRange.Length);\n\n\t}\n\n\t// Sorting the subchunks info so that subchunks of a given chunk are processed \"from the back\". Otherwise removing \n\t// a subchunk from the front of the chunk would inevitably invalidate following subchunks' information.\n\t// Note that we do this after already having added the entities to the new archetype to preserve the order of entities \n\t// as given by the input data.\n\tSubchunks.Sort([](const FMassArchetypeEntityCollection::FArchetypeEntityRange& A, const FMassArchetypeEntityCollection::FArchetypeEntityRange& B)\n\t{\n\t\treturn A.ChunkIndex < B.ChunkIndex || (A.ChunkIndex == B.ChunkIndex && A.SubchunkStart > B.SubchunkStart);\n\t});\n\n\tfor (const FMassArchetypeEntityCollection::FArchetypeEntityRange& Subchunk : Subchunks)\n\t{\n\t\tBatchRemoveEntitiesInternal(Subchunk.ChunkIndex, Subchunk.SubchunkStart, Subchunk.Length);\n\t}\n\n\tfor (int i = InitialOutEntitiesCount; i < OutEntitiesBeingMoved.Num(); ++i)\n\t{\n\t\tEntityMap.FindAndRemoveChecked(OutEntitiesBeingMoved[i].Index);\n\t}\n}\n\nFMassArchetypeEntityCollection::FArchetypeEntityRange FMassArchetypeData::PrepareNextEntitiesSpanInternal(TConstArrayView<FMassEntityHandle> Entities, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, int32 StartingChunk)\n{\n\tcheckf(SharedFragmentValues.IsSorted(), TEXT(\"Expecting shared fragment values to be previously sorted\"));\n\tcheckf(SharedFragmentValues.HasExactFragmentTypesMatch(CompositionDescriptor.SharedFragments, CompositionDescriptor.ConstSharedFragments)\n\t\t, TEXT(\"Expecting values for every specified shared fragment in the archetype and only those\"))\n\n\tint32 StartIndexWithinChunk = INDEX_NONE;\n\tint32 AbsoluteStartIndex = 0;\n\n\tFMassArchetypeChunk* DestinationChunk = nullptr;\n\t\n\tint32 ChunkIndex = StartingChunk;\n\t// find a chunk with any room left\n\tfor (; ChunkIndex < Chunks.Num(); ++ChunkIndex)\n\t{\n\t\tFMassArchetypeChunk& Chunk = Chunks[ChunkIndex];\n\t\tif (Chunk.GetNumInstances() < NumEntitiesPerChunk && Chunk.GetSharedFragmentValues().IsEquivalent(SharedFragmentValues))\n\t\t{\n\t\t\tStartIndexWithinChunk = Chunk.GetNumInstances();\n\t\t\tAbsoluteStartIndex = ChunkIndex * NumEntitiesPerChunk + StartIndexWithinChunk;\n\n\t\t\tDestinationChunk = &Chunk;\n\n\t\t\tif (StartIndexWithinChunk == 0)\n\t\t\t{\n\t\t\t\tChunk.Recycle(ChunkFragmentsTemplate, SharedFragmentValues);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// if no chunk found create one\n\tif (DestinationChunk == nullptr)\n\t{\n\t\tChunkIndex = Chunks.Num();\n\t\tAbsoluteStartIndex = Chunks.Num() * NumEntitiesPerChunk;\n\t\tStartIndexWithinChunk = 0;\n\n\t\tDestinationChunk = &Chunks.Emplace_GetRef(GetChunkAllocSize(), ChunkFragmentsTemplate, SharedFragmentValues);\n\t}\n\n\tcheck(DestinationChunk);\n\n\t// we might be able to fit in less entitites than requested\n\tconst int32 NumToAdd = FMath::Min(NumEntitiesPerChunk - StartIndexWithinChunk, Entities.Num());\n\tcheck(NumToAdd);\n\tDestinationChunk->AddMultipleInstances(NumToAdd);\n\n\t// Add to the table and map\n\tint32 AbsoluteIndex = AbsoluteStartIndex;\n\tfor (int32 i = 0; i < NumToAdd; ++i)\n\t{\n\t\tEntityMap.Add(Entities[i].Index, AbsoluteIndex++);\n\t}\n\n\tFMassEntityHandle* FirstAddedEntity = &DestinationChunk->GetEntityArrayElementRef(EntityListOffsetWithinChunk, StartIndexWithinChunk);\n\tFMemory::Memcpy(FirstAddedEntity, Entities.GetData(), sizeof(FMassEntityHandle) * NumToAdd);\n\n\treturn FMassArchetypeEntityCollection::FArchetypeEntityRange(ChunkIndex, StartIndexWithinChunk, NumToAdd);\n}\n\nvoid FMassArchetypeData::BatchRemoveEntitiesInternal(const int32 ChunkIndex, const int32 StartIndexWithinChunk, const int32 NumberToRemove)\n{\n\tFMassArchetypeChunk& Chunk = Chunks[ChunkIndex];\n\t\n\tconst int32 NumberToMove = FMath::Min(Chunk.GetNumInstances() - (StartIndexWithinChunk + NumberToRemove), NumberToRemove);\n\tcheckf(NumberToMove >= 0, TEXT(\"Trying to move a negative number of elements indicates a problem with sub-chunk indicators, it's possibly out of date.\"));\n\tconst int32 NumberToCut = FMath::Max(NumberToRemove - NumberToMove, 0);\n\n\tif (NumberToMove > 0)\n\t{\n\t\tFMassEntityHandle* DyingEntityPtr = &Chunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, StartIndexWithinChunk);\n\n\t\tconst int32 SwapStartIndex = Chunk.GetNumInstances() - NumberToMove;\n\t\tcheckf((StartIndexWithinChunk + NumberToMove - 1) < SwapStartIndex, TEXT(\"Remove and Move ranges overlap\"));\n\n\t\tMoveFragmentsToNewLocationInternal({ Chunk.GetRawMemory(), StartIndexWithinChunk }, { Chunk.GetRawMemory(), SwapStartIndex }, NumberToMove);\n\t\t\n\t\t// Update the entity table and map\n\t\tconst FMassEntityHandle* MovingEntityPtr = &Chunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, SwapStartIndex);\n\t\tint32 AbsoluteIndex = ChunkIndex * NumEntitiesPerChunk + StartIndexWithinChunk;\n\n\t\tfor (int i = 0; i < NumberToMove; ++i)\n\t\t{\n\t\t\tDyingEntityPtr[i] = MovingEntityPtr[i];\n\t\t\tEntityMap.FindChecked(MovingEntityPtr[i].Index) = AbsoluteIndex++;\n\t\t}\n\t}\n\n\tChunk.RemoveMultipleInstances(NumberToRemove);\n\n\t// If the chunk itself is empty now, see if we can remove it entirely\n\t// Note: This is only possible for trailing chunks, to avoid messing up the absolute indices in the entities map\n\twhile ((Chunks.Num() > 0) && (Chunks.Last().GetNumInstances() == 0))\n\t{\n\t\tChunks.RemoveAt(Chunks.Num() - 1, EAllowShrinking::No);\n\t}\n}\n\nvoid FMassArchetypeData::MoveFragmentsToAnotherArchetypeInternal(FMassArchetypeData& TargetArchetype, FMassArchetypeData::FTransientChunkLocation Target\n\t, const FMassArchetypeData::FTransientChunkLocation Source, const int32 ElementsNum)\n{\n\t// for every TargetArchetype's fragment see if it was in the old archetype as well and if so copy it's value. \n\t// If not then initialize the fragment.\n\tfor (const FMassArchetypeFragmentConfig& TargetFragmentConfig : TargetArchetype.FragmentConfigs)\n\t{\n\t\tconst int32* OldFragmentIndex = FragmentIndexMap.Find(TargetFragmentConfig.FragmentType);\n\t\tvoid* Dst = TargetFragmentConfig.GetFragmentData(Target.RawChunkMemory, Target.IndexWithinChunk);\n\n\t\t// Only copy if the fragment type exists in both archetypes\n\t\tif (OldFragmentIndex)\n\t\t{\n\t\t\tconst void* Src = FragmentConfigs[*OldFragmentIndex].GetFragmentData(Source.RawChunkMemory, Source.IndexWithinChunk);\n\t\t\tFMemory::Memcpy(Dst, Src, TargetFragmentConfig.FragmentType->GetStructureSize() * ElementsNum);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// the fragment's unique to the TargetArchetype need to be initialized\n\t\t\t// @todo we're doing it for tags here as well. A tiny bit of perf lost. Probably not worth adding a check\n\t\t\t// but something to keep in mind. Will go away once tags are more of an archetype fragment than entity's\n\t\t\tTargetFragmentConfig.FragmentType->InitializeStruct(Dst, ElementsNum);\n\t\t}\n\t}\n\n\t// Delete fragments that were left behind\n\tfor (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)\n\t{\n\t\t// If the fragment is not in the new archetype, destroy it.\n\t\tconst int32* NewFragmentIndex = TargetArchetype.FragmentIndexMap.Find(FragmentConfig.FragmentType);\n\t\tif (NewFragmentIndex == nullptr)\n\t\t{\n\t\t\tvoid* DyingFragmentPtr = FragmentConfig.GetFragmentData(Source.RawChunkMemory, Source.IndexWithinChunk);\n\t\t\tFragmentConfig.FragmentType->DestroyStruct(DyingFragmentPtr, ElementsNum);\n\t\t}\n\t}\n}\n\nFORCEINLINE void FMassArchetypeData::MoveFragmentsToNewLocationInternal(FMassArchetypeData::FTransientChunkLocation Target, const FMassArchetypeData::FTransientChunkLocation Source, const int32 NumberToMove)\n{\n\tfor (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)\n\t{\n\t\tvoid* DyingFragmentPtr = FragmentConfig.GetFragmentData(Target.RawChunkMemory, Target.IndexWithinChunk);\n\t\tvoid* MovingFragmentPtr = FragmentConfig.GetFragmentData(Source.RawChunkMemory, Source.IndexWithinChunk); \n\n\t\t// Swap fragments to the empty space just created.\n\t\tFMemory::Memcpy(DyingFragmentPtr, MovingFragmentPtr, FragmentConfig.FragmentType->GetStructureSize() * NumberToMove);\n\t}\n}\n\nvoid FMassArchetypeData::BatchSetFragmentValues(TConstArrayView<FMassArchetypeEntityCollection::FArchetypeEntityRange> EntityCollection, const FMassGenericPayloadViewSlice& Payload)\n{\n\tint32 EntitiesHandled = 0;\n\n\tfor (const FMassArchetypeEntityCollection::FArchetypeEntityRange EntityRange : EntityCollection)\n\t{\n\t\tFMassArchetypeChunk& Chunk = Chunks[EntityRange.ChunkIndex];\n\n\t\tfor (int i = 0; i < Payload.Num(); ++i)\n\t\t{\n\t\t\tFStructArrayView FragmentPayload = Payload[i];\n\t\t\tcheck(FragmentPayload.Num() - EntitiesHandled >= EntityRange.Length);\n\n\t\t\tconst UScriptStruct* FragmentType = FragmentPayload.GetScriptStruct();\n\t\t\tcheck(FragmentType);\n\n\t\t\tconst int32 FragmentIndex = FragmentIndexMap.FindChecked(FragmentType);\n\t\t\tvoid* Dst = FragmentConfigs[FragmentIndex].GetFragmentData(Chunk.GetRawMemory(), EntityRange.SubchunkStart);\n\t\t\tconst void* Src = FragmentPayload.GetDataAt(EntitiesHandled);\n\n\t\t\tFragmentType->CopyScriptStruct(Dst, Src, EntityRange.Length);\n\t\t}\n\n\t\tEntitiesHandled += EntityRange.Length;\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// FMassArchetypeHelper\n//-----------------------------------------------------------------------------\nbool FMassArchetypeHelper::DoesArchetypeMatchRequirements(const FMassArchetypeData& Archetype, const FMassFragmentRequirements& Requirements)\n{\n\treturn DoesArchetypeMatchRequirements(Archetype.GetCompositionDescriptor(), Requirements);\n}\nbool FMassArchetypeHelper::DoesArchetypeMatchRequirements(const FMassArchetypeCompositionDescriptor& ArchetypeComposition, const FMassFragmentRequirements& Requirements)\n{\n\treturn Requirements.DoesArchetypeMatchRequirements(ArchetypeComposition);\n}\n\n#if WITH_MASSENTITY_DEBUG\nbool FMassArchetypeHelper::DoesArchetypeMatchRequirements(const FMassArchetypeData& Archetype, const FMassFragmentRequirements& Requirements\n\t, const bool bBailOutOnFirstFail, FOutputDevice* OutputDevice)\n{\n\tif (DoesArchetypeMatchRequirements(Archetype.GetCompositionDescriptor(), Requirements))\n\t{\n\t\t// nothing to log\n\t\treturn true;\n\t}\n\t\n\tif (OutputDevice)\n\t{\n\t\t// do logging\n\t\tOutputDevice->Logf(TEXT(\"% s\")\n\t\t\t, *FMassDebugger::GetArchetypeRequirementCompatibilityDescription(Requirements, Archetype.GetCompositionDescriptor()));\n\t}\n\n\treturn false;\n\n\t//bool bResult = true;\n\t//if (Requirements.IsOptionalsOnly() == false)\n\t//{\n\t//\tif (Archetype.GetTagBitSet().HasAll(Requirements.GetRequiredAllTags()) == false)\n\t//\t{\n\t//\t\t// missing some required tags, skip.\n\t//\t\tconst FMassTagBitSet UnsatisfiedTags = Requirements.GetRequiredAllTags() - Archetype.GetTagBitSet();\n\t//\t\tFStringOutputDevice Description;\n\t//\t\tUnsatisfiedTags.DebugGetStringDesc(Description);\n\t//\t\tOutputDevice->Logf(TEXT(\"Archetype did not match due to missing tags: %s\"), *Description);\n\n\t//\t\tbResult = false;\n\t//\t\tif (bBailOutOnFirstFail)\n\t//\t\t{\n\t//\t\t\treturn false;\n\t//\t\t}\n\t//\t}\n\n\t//\tif (Archetype.GetTagBitSet().HasNone(Requirements.GetRequiredNoneTags()) == false)\n\t//\t{\n\t//\t\t// has some tags required to be absent\n\t//\t\tconst FMassTagBitSet UnwantedTags = Requirements.GetRequiredNoneTags().GetOverlap(Archetype.GetTagBitSet());\n\t//\t\tFStringOutputDevice Description;\n\t//\t\tUnwantedTags.DebugGetStringDesc(Description);\n\t//\t\tOutputDevice->Logf(TEXT(\"Archetype has tags required absent: %s\"), *Description);\n\n\t//\t\tbResult = false;\n\t//\t\tif (bBailOutOnFirstFail)\n\t//\t\t{\n\t//\t\t\treturn false;\n\t//\t\t}\n\t//\t}\n\n\t//\tif (Requirements.GetRequiredAnyTags().IsEmpty() == false\n\t//\t\t&& Archetype.GetTagBitSet().HasAny(Requirements.GetRequiredAnyTags()) == false)\n\t//\t{\n\t//\t\tFStringOutputDevice Description;\n\t//\t\tRequirements.GetRequiredAnyTags().DebugGetStringDesc(Description);\n\t//\t\tOutputDevice->Logf(TEXT(\"Archetype did not match due to missing \\'any\\' tags: %s\"), *Description);\n\n\t//\t\tbResult = false;\n\t//\t\tif (bBailOutOnFirstFail)\n\t//\t\t{\n\t//\t\t\treturn false;\n\t//\t\t}\n\t//\t}\n\n\t//\tif (Archetype.GetFragmentBitSet().HasAll(Requirements.GetRequiredAllFragments()) == false)\n\t//\t{\n\t//\t\t// missing some required fragments, skip.\n\t//\t\tconst FMassFragmentBitSet UnsatisfiedFragments = Requirements.GetRequiredAllFragments() - Archetype.GetFragmentBitSet();\n\t//\t\tFStringOutputDevice Description;\n\t//\t\tUnsatisfiedFragments.DebugGetStringDesc(Description);\n\t//\t\tOutputDevice->Logf(TEXT(\"Archetype did not match due to missing Fragments: %s\"), *Description);\n\n\t//\t\tbResult = false;\n\t//\t\tif (bBailOutOnFirstFail)\n\t//\t\t{\n\t//\t\t\treturn false;\n\t//\t\t}\n\t//\t}\n\n\t//\tif (Archetype.GetFragmentBitSet().HasNone(Requirements.GetRequiredNoneFragments()) == false)\n\t//\t{\n\t//\t\t// has some Fragments required to be absent\n\t//\t\tconst FMassFragmentBitSet UnwantedFragments = Requirements.GetRequiredNoneFragments().GetOverlap(Archetype.GetFragmentBitSet());\n\t//\t\tFStringOutputDevice Description;\n\t//\t\tUnwantedFragments.DebugGetStringDesc(Description);\n\t//\t\tOutputDevice->Logf(TEXT(\"Archetype has Fragments required absent: %s\"), *Description);\n\n\t//\t\tbResult = false;\n\t//\t\tif (bBailOutOnFirstFail)\n\t//\t\t{\n\t//\t\t\treturn false;\n\t//\t\t}\n\t//\t}\n\n\t//\tif (Requirements.GetRequiredAnyFragments().IsEmpty() == false\n\t//\t\t&& Archetype.GetFragmentBitSet().HasAny(Requirements.GetRequiredAnyFragments()) == false)\n\t//\t{\n\t//\t\tFStringOutputDevice Description;\n\t//\t\tRequirements.GetRequiredAnyFragments().DebugGetStringDesc(Description);\n\t//\t\tOutputDevice->Logf(TEXT(\"Archetype did not match due to missing \\'any\\' fragments: %s\"), *Description);\n\n\t//\t\tbResult = false;\n\t//\t\tif (bBailOutOnFirstFail)\n\t//\t\t{\n\t//\t\t\treturn false;\n\t//\t\t}\n\t//\t}\n\n\t//\tif (Archetype.GetChunkFragmentBitSet().HasAll(Requirements.GetRequiredAllChunkFragments()) == false)\n\t//\t{\n\t//\t\t// missing some required fragments, skip.\n\t//\t\tconst FMassChunkFragmentBitSet UnsatisfiedFragments = Requirements.GetRequiredAllChunkFragments() - Archetype.GetChunkFragmentBitSet();\n\t//\t\tFStringOutputDevice Description;\n\t//\t\tUnsatisfiedFragments.DebugGetStringDesc(Description);\n\t//\t\tOutputDevice->Logf(TEXT(\"Archetype did not match due to missing Chunk Fragments: %s\"), *Description);\n\n\t//\t\tbResult = false;\n\t//\t\tif (bBailOutOnFirstFail)\n\t//\t\t{\n\t//\t\t\treturn false;\n\t//\t\t}\n\t//\t}\n\n\t//\tif (Archetype.GetChunkFragmentBitSet().HasNone(Requirements.GetRequiredNoneChunkFragments()) == false)\n\t//\t{\n\t//\t\t// has some Fragments required to be absent\n\t//\t\tconst FMassChunkFragmentBitSet UnwantedFragments = Requirements.GetRequiredNoneChunkFragments().GetOverlap(Archetype.GetChunkFragmentBitSet());\n\t//\t\tFStringOutputDevice Description;\n\t//\t\tUnwantedFragments.DebugGetStringDesc(Description);\n\t//\t\tOutputDevice->Logf(TEXT(\"Archetype has Chunk Fragments required absent: %s\"), *Description);\n\n\t//\t\tbResult = false;\n\t//\t\tif (bBailOutOnFirstFail)\n\t//\t\t{\n\t//\t\t\treturn false;\n\t//\t\t}\n\t//\t}\n\n\t//\tif (Archetype.GetSharedFragmentBitSet().HasAll(Requirements.GetRequiredAllSharedFragments()) == false)\n\t//\t{\n\t//\t\t// missing some required fragments, skip.\n\t//\t\tconst FMassSharedFragmentBitSet UnsatisfiedFragments = Requirements.GetRequiredAllSharedFragments() - Archetype.GetSharedFragmentBitSet();\n\t//\t\tFStringOutputDevice Description;\n\t//\t\tUnsatisfiedFragments.DebugGetStringDesc(Description);\n\t//\t\tOutputDevice->Logf(TEXT(\"Archetype did not match due to missing Shared Fragments: %s\"), *Description);\n\n\t//\t\tbResult = false;\n\t//\t\tif (bBailOutOnFirstFail)\n\t//\t\t{\n\t//\t\t\treturn false;\n\t//\t\t}\n\t//\t}\n\n\t//\tif (Archetype.GetSharedFragmentBitSet().HasNone(Requirements.GetRequiredNoneSharedFragments()) == false)\n\t//\t{\n\t//\t\t// has some Fragments required to be absent\n\t//\t\tconst FMassSharedFragmentBitSet UnwantedFragments = Requirements.GetRequiredNoneSharedFragments().GetOverlap(Archetype.GetSharedFragmentBitSet());\n\t//\t\tFStringOutputDevice Description;\n\t//\t\tUnwantedFragments.DebugGetStringDesc(Description);\n\t//\t\tOutputDevice->Logf(TEXT(\"Archetype has Shared Fragments required absent: %s\"), *Description);\n\n\t//\t\tbResult = false;\n\t//\t\tif (bBailOutOnFirstFail)\n\t//\t\t{\n\t//\t\t\treturn false;\n\t//\t\t}\n\t//\t}\n\n\t//\tif (Archetype.GetConstSharedFragmentBitSet().HasAll(Requirements.GetRequiredAllConstSharedFragments()) == false)\n\t//\t{\n\t//\t\t// missing some required fragments, skip.\n\t//\t\tconst FMassConstSharedFragmentBitSet UnsatisfiedFragments = Requirements.GetRequiredAllConstSharedFragments() - Archetype.GetConstSharedFragmentBitSet();\n\t//\t\tFStringOutputDevice Description;\n\t//\t\tUnsatisfiedFragments.DebugGetStringDesc(Description);\n\t//\t\tOutputDevice->Logf(TEXT(\"Archetype did not match due to missing Const Shared Fragments: %s\"), *Description);\n\n\t//\t\tbResult = false;\n\t//\t\tif (bBailOutOnFirstFail)\n\t//\t\t{\n\t//\t\t\treturn false;\n\t//\t\t}\n\t//\t}\n\n\t//\tif (Archetype.GetConstSharedFragmentBitSet().HasNone(Requirements.GetRequiredNoneConstSharedFragments()) == false)\n\t//\t{\n\t//\t\t// has some Fragments required to be absent\n\t//\t\tconst FMassConstSharedFragmentBitSet UnwantedFragments = Requirements.GetRequiredNoneConstSharedFragments().GetOverlap(Archetype.GetConstSharedFragmentBitSet());\n\t//\t\tFStringOutputDevice Description;\n\t//\t\tUnwantedFragments.DebugGetStringDesc(Description);\n\t//\t\tOutputDevice->Logf(TEXT(\"Archetype has Const Shared Fragments required absent: %s\"), *Description);\n\n\t//\t\t// could skip the test as it's the final check we're performing, but leaving it in in case more cases are added\n\t//\t\t// later without checking the existing code\n\t//\t\tbResult = false;\n\t//\t\tif (bBailOutOnFirstFail)\n\t//\t\t{\n\t//\t\t\treturn false;\n\t//\t\t}\n\t//\t}\n\t//}\n\t//else\n\t//{\n\t//\t// test if contains any of the optional elements\n\t//\tif (Archetype.GetFragmentBitSet().HasNone(Requirements.GetRequiredOptionalFragments())\n\t//\t\t&& Archetype.GetTagBitSet().HasNone(Requirements.GetRequiredOptionalTags())\n\t//\t\t&& Archetype.GetChunkFragmentBitSet().HasNone(Requirements.GetRequiredOptionalChunkFragments())\n\t//\t\t&& Archetype.GetSharedFragmentBitSet().HasNone(Requirements.GetRequiredOptionalSharedFragments())\n\t//\t\t&& Archetype.GetConstSharedFragmentBitSet().HasNone(Requirements.GetRequiredOptionalConstSharedFragments()))\n\t//\t{\n\t//\t\tFStringOutputDevice Description;\n\t//\t\tRequirements.GetRequiredOptionalFragments().DebugGetStringDesc(Description);\n\t//\t\tRequirements.GetRequiredOptionalTags().DebugGetStringDesc(Description);\n\t//\t\tRequirements.GetRequiredOptionalChunkFragments().DebugGetStringDesc(Description);\n\t//\t\tRequirements.GetRequiredOptionalSharedFragments().DebugGetStringDesc(Description);\n\t//\t\tRequirements.GetRequiredOptionalConstSharedFragments().DebugGetStringDesc(Description);\n\t//\t\t\n\t//\t\tOutputDevice->Logf(TEXT(\"Archetype has none of the optional elements: %s\"), *Description);\n\n\t//\t\tbResult = false;\n\t//\t}\n\t//}\n\n\t//return bResult;\n}\n#endif // WITH_MASSENTITY_DEBUG",
      "lines": 1597
    },
    {
      "file_path": "MassEntity\\Private\\MassArchetypeTypes.cpp",
      "extension": ".cpp",
      "size_bytes": 13885,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassArchetypeTypes.h\"\n#include \"MassEntityManager.h\"\n#include \"MassArchetypeData.h\"\n#include \"MassCommandBuffer.h\"\n#include \"MassEntityUtils.h\"\n\n//////////////////////////////////////////////////////////////////////\n// FMassArchetypeHandle\n\nuint32 GetTypeHash(const FMassArchetypeHandle& Instance)\n{\n\treturn GetTypeHash(Instance.DataPtr.Get());\n}\n\n//////////////////////////////////////////////////////////////////////\n// FMassArchetypeEntityCollection \n\nFMassArchetypeEntityCollection::FMassArchetypeEntityCollection(const FMassArchetypeHandle& InArchetype, TConstArrayView<FMassEntityHandle> InEntities, EDuplicatesHandling DuplicatesHandling)\n\t: Archetype(InArchetype)\n{\n\tif (InEntities.Num() <= 0)\n\t{\n\t\treturn;\n\t}\n\n\tconst FMassArchetypeData* ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandle(InArchetype);\n\tconst int32 NumEntitiesPerChunk = ArchetypeData ? ArchetypeData->GetNumEntitiesPerChunk() : MAX_int32;\n\n\t// InEntities has a real chance of not being sorted by AbsoluteIndex. We gotta fix that to optimize how we process the data \n\tTArray<int32> TrueIndices;\n\tTrueIndices.AddUninitialized(InEntities.Num());\n\tint32 NumValidEntities = 0;\n\tif (ArchetypeData)\n\t{\n\t\tfor (const FMassEntityHandle& Entity : InEntities)\n\t\t{\n\t\t\tif (Entity.IsValid())\n\t\t\t{\n\t\t\t\tif (const int32* TrueIndex = ArchetypeData->GetInternalIndexForEntity(Entity.Index))\n\t\t\t\t{\n\t\t\t\t\tTrueIndices[NumValidEntities++] = *TrueIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// special case, where we have a bunch of entities that have been built but not assigned an archetype yet.\n\t\t// we use their base index for the sake of sorting here. Will still get some perf benefits and we can keep using\n\t\t// FMassArchetypeEntityCollection as the generic batched API wrapper for entities\n\t\tfor (const FMassEntityHandle& Entity : InEntities)\n\t\t{\n\t\t\tif (Entity.IsValid())\n\t\t\t{\n\t\t\t\tTrueIndices[NumValidEntities++] = Entity.Index;\n\t\t\t}\n\t\t}\n\t}\n\n\tTrueIndices.SetNum(NumValidEntities, EAllowShrinking::No);\n\tTrueIndices.Sort();\n\n#if DO_GUARD_SLOW\n\tif (DuplicatesHandling == NoDuplicates)\n\t{\n\t\t// ensure there are no duplicates. \n\t\tint32 PrevIndex = TrueIndices[0];\n\t\tfor (int j = 1; j < TrueIndices.Num(); ++j)\n\t\t{\n\t\t\tcheckf(TrueIndices[j] != PrevIndex, TEXT(\"InEntities contains duplicate while DuplicatesHandling is set to NoDuplicates\"));\n\t\t\tif (TrueIndices[j] == PrevIndex)\n\t\t\t{\n\t\t\t\t// fix it, for development's sake\n\t\t\t\tDuplicatesHandling = FoldDuplicates;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tPrevIndex = TrueIndices[j];\n\t\t}\n\t}\n#endif // DO_GUARD_SLOW\n\n\tif (DuplicatesHandling == FoldDuplicates)\n\t{\n\t\tint32 PrevIndex = TrueIndices[0];\n\t\tfor (int j = 1; j < TrueIndices.Num(); ++j)\n\t\t{\n\t\t\tif (TrueIndices[j] == PrevIndex)\n\t\t\t{\n\t\t\t\tconst int32 Num = TrueIndices.Num();\n\t\t\t\tint Skip = 0;\n\t\t\t\twhile ((j + ++Skip) < Num && TrueIndices[j + Skip] == PrevIndex);\n\t\t\t\t\n\t\t\t\tTrueIndices.RemoveAt(j, Skip, EAllowShrinking::No);\n\t\t\t\t--j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPrevIndex = TrueIndices[j];\n\t\t}\n\t}\n\n\tBuildEntityRanges(MakeStridedView<const int32>(TrueIndices));\n}\n\nvoid FMassArchetypeEntityCollection::BuildEntityRanges(TStridedView<const int32> TrueIndices)\n{\n\tcheckf(Ranges.Num() == 0, TEXT(\"Calling %s is valid only for initial configuration\"), ANSI_TO_TCHAR(__FUNCTION__));\n\n\tconst FMassArchetypeData* ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandle(Archetype);\n\tconst int32 NumEntitiesPerChunk = ArchetypeData ? ArchetypeData->GetNumEntitiesPerChunk() : MAX_int32;\n\n\t// the following block of code is splitting up sorted AbsoluteIndices into \n\t// continuous chunks\n\tint32 ChunkEnd = INDEX_NONE;\n\tFArchetypeEntityRange DummyChunk;\n\tFArchetypeEntityRange* SubChunkPtr = &DummyChunk;\n\tint32 SubchunkLen = 0;\n\tint32 PrevAbsoluteIndex = INDEX_NONE;\n\tfor (const int32 Index : TrueIndices)\n\t{\n\t\t// if run across a chunk border or run into an index discontinuity \n\t\tif (Index >= ChunkEnd || Index != (PrevAbsoluteIndex + 1))\n\t\t{\n\t\t\tSubChunkPtr->Length = SubchunkLen;\n\t\t\t// note that both ChunkIndex and ChunkEnd will change only if AbsoluteIndex >= ChunkEnd\n\t\t\tconst int32 ChunkIndex = Index / NumEntitiesPerChunk;\n\t\t\tChunkEnd = (ChunkIndex + 1) * NumEntitiesPerChunk;\n\t\t\tSubchunkLen = 0;\n\t\t\t// new subchunk\n\t\t\tconst int32 SubchunkStart = Index % NumEntitiesPerChunk;\n\t\t\tSubChunkPtr = &Ranges.Add_GetRef(FArchetypeEntityRange(ChunkIndex, SubchunkStart));\n\t\t}\n\t\t++SubchunkLen;\n\t\tPrevAbsoluteIndex = Index;\n\t}\n\n\tSubChunkPtr->Length = SubchunkLen;\n}\n\nFMassArchetypeEntityCollection::FMassArchetypeEntityCollection(const FMassArchetypeHandle& InArchetypeHandle, const EInitializationType Initialization)\n\t: Archetype(InArchetypeHandle)\n{\n\tif (Initialization == EInitializationType::GatherAll)\n\t{\n\t\tcheck(InArchetypeHandle.IsValid());\n\t\tGatherChunksFromArchetype();\n\t}\n}\n\nFMassArchetypeEntityCollection::FMassArchetypeEntityCollection(TSharedPtr<FMassArchetypeData>& InArchetype, const EInitializationType Initialization)\n\t: Archetype(FMassArchetypeHelper::ArchetypeHandleFromData(InArchetype))\n{\t\n\tif (Initialization == EInitializationType::GatherAll)\n\t{\n\t\tcheck(InArchetype.IsValid());\n\t\tGatherChunksFromArchetype();\n\t}\n}\n\nvoid FMassArchetypeEntityCollection::GatherChunksFromArchetype()\n{\n\tif (const FMassArchetypeData* ArchetypePtr = FMassArchetypeHelper::ArchetypeDataFromHandle(Archetype))\n\t{\n\t\tconst int32 ChunkCount = ArchetypePtr->GetChunkCount();\n\t\tRanges.Reset(ChunkCount);\n\t\tfor (int32 i = 0; i < ChunkCount; ++i)\n\t\t{\n\t\t\tRanges.Add(FArchetypeEntityRange(i));\n\t\t}\n\t}\n}\n\nbool FMassArchetypeEntityCollection::IsSame(const FMassArchetypeEntityCollection& Other) const\n{\n\tif (Archetype != Other.Archetype || Ranges.Num() != Other.Ranges.Num())\n\t{\n\t\treturn false;\n\t}\n\n\tfor (int i = 0; i < Ranges.Num(); ++i)\n\t{\n\t\tif (Ranges[i] != Other.Ranges[i])\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n//////////////////////////////////////////////////////////////////////\n// FMassArchetypeEntityCollectionWithPayload\n\nvoid FMassArchetypeEntityCollectionWithPayload::CreateEntityRangesWithPayload(const FMassEntityManager& EntityManager, const TConstArrayView<FMassEntityHandle> Entities\n\t, const FMassArchetypeEntityCollection::EDuplicatesHandling DuplicatesHandling, FMassGenericPayloadView Payload\n\t, TArray<FMassArchetypeEntityCollectionWithPayload>& OutEntityCollections)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"Mass_CreateEntityRangesWithPayload\");\n\n\tcheck(Payload.Num() > 0);\n\tfor (const FStructArrayView& Element : Payload.Content)\n\t{\n\t\tcheck(Entities.Num() == Element.Num());\n\t}\n\n\tstruct FEntityInArchetype\n\t{\n\t\tint32 ArchetypeIndex = INDEX_NONE;\n\t\tint32 TrueIndex = INDEX_NONE;\n\n\t\tbool operator==(const FEntityInArchetype& Other) const\n\t\t{\n\t\t\treturn ArchetypeIndex == Other.ArchetypeIndex && TrueIndex == Other.TrueIndex;\n\t\t}\n\n\t\t/** @return whether A should come before B in an ordered collection */\n\t\tstatic bool Compare(const FEntityInArchetype& A, const FEntityInArchetype& B)\n\t\t{\n\t\t\t// using \"greater\" to ensure INDEX_NONE archetypes end up at the end of the collection\n\t\t\treturn A.ArchetypeIndex > B.ArchetypeIndex || (A.ArchetypeIndex == B.ArchetypeIndex && A.TrueIndex < B.TrueIndex);\n\t\t}\n\t};\n\n\tTArray<FEntityInArchetype> EntityData;\n\tEntityData.AddUninitialized(Entities.Num());\n\n\tstruct FArchetypeInfo\n\t{\n\t\t// @todo using a handle here is temporary. Once ArchetypeHandle switches to using an index we'll use that instead\n\t\tFMassArchetypeHandle Archetype;\n\t\tint32 Count = 0;\n\n\t\tbool operator==(const FMassArchetypeHandle& InArchetype) const\n\t\t{\n\t\t\treturn Archetype == InArchetype;\n\t\t}\n\t\tbool operator==(const FArchetypeInfo& Other) const\n\t\t{\n\t\t\treturn Archetype == Other.Archetype;\n\t\t}\n\t};\n\tTArray<FArchetypeInfo> Archetypes;\n\n\tfor (int32 i = 0; i < Entities.Num(); ++i)\n\t{\n\t\tconst FMassEntityHandle& Entity = Entities[i];\n\t\tif (EntityManager.IsEntityValid(Entity))\n\t\t{\n\t\t\t// using Unsafe since we just checked that the entity is valid\n\t\t\tconst FMassArchetypeHandle ArchetypeHandle = EntityManager.GetArchetypeForEntityUnsafe(Entity);\n\t\t\tconst FMassArchetypeData* ArchetypePtr = FMassArchetypeHelper::ArchetypeDataFromHandle(ArchetypeHandle);\n\t\t\n\t\t\t// @todo if FMassArchetypeHandle used indices the look up would be a lot faster\n\t\t\tint32 ArchetypeIndex = INDEX_NONE;\n\t\t\n\t\t\tif (Archetypes.Find(FArchetypeInfo{ ArchetypeHandle, 0 }, ArchetypeIndex) == false)\n\t\t\t{\n\t\t\t\tArchetypeIndex = Archetypes.Add({ ArchetypeHandle, 0 });\n\t\t\t}\n\t\t\t++Archetypes[ArchetypeIndex].Count;\n\t\t\tEntityData[i] = { ArchetypeIndex, ArchetypePtr ? ArchetypePtr->GetInternalIndexForEntityChecked(Entity.Index) : Entity.Index };\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// for invalid entities we create an entry that will result in all of them batched together \n\t\t\t// (due to having the same archetype index, INDEX_NONE). Since the main logic loop below relies on entries \n\t\t\t// in Archetypes and the \"invalid\" EntityData doesn't correspond to any, all the invalid entities \n\t\t\t// will be silently filtered out.\n\t\t\tEntityData[i] = FEntityInArchetype();\n\t\t\tUE_LOG(LogMass, Warning, TEXT(\"%hs: Invalid entity handle passed in. Ignoring it, but check your code to make sure you don't mix synchronous entity-mutating Mass API function calls with Mass commands\")\n\t\t\t\t, __FUNCTION__);\n\t\t}\n\t}\n\n\t// A paranoid programmer might point out that there are no guarantees that a sorting algorithm will compare all elements.\n\t// While that's true we make an assumption here, that the elements next to each other will in fact all get compared\n\t// and since all we care about with `bDuplicatesFound` is whether same elements exist (that will be right next to each other\n\t// in the final lineup) we feel safe in the assumption.\n\tbool bDuplicatesFound = false;\n\tUE::Mass::Utils::AbstractSort(Entities.Num(), [&EntityData, &bDuplicatesFound](const int32 LHS, const int32 RHS)\n\t\t{\n\t\t\tbDuplicatesFound = bDuplicatesFound || (EntityData[LHS] == EntityData[RHS]);\n\t\t\treturn FEntityInArchetype::Compare(EntityData[LHS], EntityData[RHS]);\n\t\t}\n\t\t, [&EntityData, &Payload](const int32 A, const int32 B)\n\t\t{\n\t\t\t::Swap(EntityData[A], EntityData[B]);\n\t\t\tPayload.Swap(A, B);\n\t\t});\n\tensureMsgf(bDuplicatesFound == false || (DuplicatesHandling != FMassArchetypeEntityCollection::NoDuplicates)\n\t\t, TEXT(\"Caller declared lack of duplicates in the input data, but duplicates have been found\"));\n\n#if !UE_BUILD_SHIPPING\n\t// in non shipping builds we still want to verify that the assumption expressed in bDuplicatesFound comment above\n\t// is correct\n\tif (!bDuplicatesFound && (DuplicatesHandling == FMassArchetypeEntityCollection::FoldDuplicates))\n\t{\n\t\tfor (int32 EntryIndex = 0; EntryIndex < EntityData.Num() - 1; ++EntryIndex)\n\t\t{\n\t\t\tcheckf(EntityData[EntryIndex] != EntityData[EntryIndex + 1], TEXT(\"Assumption regarding comparison between identical elements while sorting is wrong!\"));\n\t\t}\n\t}\n#endif // !UE_BUILD_SHIPPING\n\n\tif (bDuplicatesFound && (DuplicatesHandling == FMassArchetypeEntityCollection::FoldDuplicates))\n\t{\n\t\t// we cannot remove elements from Payload, since it's a view to existing data, we need to sort the data in \n\t\t// such a way that all the duplicates end up at the end of the view. We can then ignore the appropriate\n\t\t// number of elements.\n\t\t\n\t\t// processing Num - 1 elements since there's no point in checking the last one - there's nothing to compare it against\n\t\tfor (int32 EntryIndex = 0; EntryIndex < EntityData.Num() - 1; ++EntryIndex)\n\t\t{\t\n\t\t\tFEntityInArchetype& Entry = EntityData[EntryIndex];\n\t\t\tif (Entry.ArchetypeIndex == INDEX_NONE)\n\t\t\t{\n\t\t\t\t// we're reached INDEX_NONE archetypes, which are at the end of EntityData\n\t\t\t\t// breaking since there's nothing more to process. \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (Entry != EntityData[EntryIndex + 1])\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint32 DuplicateIndex = EntryIndex + 1;\n\t\t\twhile (DuplicateIndex + 1 < EntityData.Num() && Entry == EntityData[DuplicateIndex + 1])\n\t\t\t{\n\t\t\t\t++DuplicateIndex;\n\t\t\t};\n\n\t\t\tconst int32 NumDuplicates = DuplicateIndex - EntryIndex;\n\n\t\t\tEntityData.RemoveAt(EntryIndex + 1, NumDuplicates, EAllowShrinking::No);\n\t\t\tPayload.SwapElementsToEnd(EntryIndex + 1, NumDuplicates);\n\t\t\t// even though we don't remove the elements from payload we later limit the number of elements used with\n\t\t\t// ArchetypeInfo.Count, so we need to update that\n\t\t\tArchetypes[Entry.ArchetypeIndex].Count -= NumDuplicates;\n\t\t}\n\t}\n\n\tint32 ProcessedEntitiesCount = 0;\n\t// processing from the back since that's how EntityData is sorted - higher-index archetypes come first\n\tfor (int32 ArchetypeIndex = Archetypes.Num() - 1; ArchetypeIndex >= 0; --ArchetypeIndex)\n\t{\n\t\tFArchetypeInfo& ArchetypeInfo = Archetypes[ArchetypeIndex];\n\t\tTArrayView<FEntityInArchetype> EntityDataSubset = MakeArrayView(&EntityData[ProcessedEntitiesCount], ArchetypeInfo.Count);\n\t\tensure(EntityDataSubset[0].ArchetypeIndex == ArchetypeIndex);\n\t\tensure(EntityDataSubset.Last().ArchetypeIndex == ArchetypeIndex);\n\t\tTStridedView<int32> TrueIndices = MakeStridedView(EntityDataSubset, &FEntityInArchetype::TrueIndex);\n\n\t\tFMassGenericPayloadViewSlice PayloadSubView(Payload, ProcessedEntitiesCount, ArchetypeInfo.Count);\n\n\t\tOutEntityCollections.Add(FMassArchetypeEntityCollectionWithPayload(ArchetypeInfo.Archetype, TrueIndices, MoveTemp(PayloadSubView)));\n\n\t\tProcessedEntitiesCount += ArchetypeInfo.Count;\n\t}\n}\n\nFMassArchetypeEntityCollectionWithPayload::FMassArchetypeEntityCollectionWithPayload(const FMassArchetypeHandle& InArchetype, TStridedView<const int32> TrueIndices, FMassGenericPayloadViewSlice&& InPayloadSlice)\n\t: Entities(InArchetype, FMassArchetypeEntityCollection::DoNothing)\n\t, PayloadSlice(InPayloadSlice)\n{\n\tEntities.BuildEntityRanges(TrueIndices);\n}\n",
      "lines": 365
    },
    {
      "file_path": "MassEntity\\Private\\MassCommandBuffer.cpp",
      "extension": ".cpp",
      "size_bytes": 6947,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCommandBuffer.h\"\n#include \"Containers/AnsiString.h\"\n#include \"MassObserverManager.h\"\n#include \"MassEntityUtils.h\"\n#include \"HAL/IConsoleManager.h\"\n#include \"ProfilingDebugging/CsvProfiler.h\"\n#include \"VisualLogger/VisualLogger.h\"\n\n\nCSV_DEFINE_CATEGORY(MassEntities, true);\nCSV_DEFINE_CATEGORY(MassEntitiesCounters, true);\nDECLARE_CYCLE_STAT(TEXT(\"Mass Flush Commands\"), STAT_Mass_FlushCommands, STATGROUP_Mass);\n\nnamespace UE::Mass::Command {\n\n#if CSV_PROFILER_STATS\nbool bEnableDetailedStats = false;\n\nFAutoConsoleVariableRef CVarEnableDetailedCommandStats(TEXT(\"massentities.EnableCommandDetailedStats\"), bEnableDetailedStats,\n\tTEXT(\"Set to true create a dedicated stat per type of command.\"), ECVF_Default);\n\n/** CSV stat names */\nstatic FString DefaultBatchedName = TEXT(\"BatchedCommand\");\nstatic TMap<FName, TPair<FString, FAnsiString>> CommandBatchedFNames;\n\n/** CSV custom stat names (ANSI) */\nstatic FAnsiString DefaultANSIBatchedName = \"BatchedCommand\";\n\n/**\n * Provides valid names for CSV profiling.\n * @param Command is the command instance\n * @param OutName is the name to use for csv custom stats\n * @param OutANSIName is the name to use for csv stats\n */\nvoid GetCommandStatNames(FMassBatchedCommand& Command, FString*& OutName, FAnsiString*& OutANSIName)\n{\n\tOutANSIName = &DefaultANSIBatchedName;\n\tOutName     = &DefaultBatchedName;\n\tif (!bEnableDetailedStats)\n\t{\n\t\treturn;\n\t}\n\n\tconst FName CommandFName = Command.GetFName();\n\n\tTPair<FString, FAnsiString>& Names = CommandBatchedFNames.FindOrAdd(CommandFName);\n\tOutName     = &Names.Get<FString>();\n\tOutANSIName = &Names.Get<FAnsiString>();\n\tif (OutName->IsEmpty())\n\t{\n\t\t*OutName     = CommandFName.ToString();\n\t\t*OutANSIName = **OutName;\n\t}\n}\n\n#endif\n} // UE::Mass::Command\n\n//////////////////////////////////////////////////////////////////////\n// FMassBatchedCommand\nstd::atomic<uint32> FMassBatchedCommand::CommandsCounter;\n\n//////////////////////////////////////////////////////////////////////\n// FMassCommandBuffer\n\nFMassCommandBuffer::FMassCommandBuffer()\n\t: OwnerThreadId(FPlatformTLS::GetCurrentThreadId())\n{\t\n}\n\nFMassCommandBuffer::~FMassCommandBuffer()\n{\n\tensureMsgf(HasPendingCommands() == false, TEXT(\"Destroying FMassCommandBuffer while there are still unprocessed commands. These operations will never be performed now.\"));\n\n\tCleanUp();\n}\n\nvoid FMassCommandBuffer::ForceUpdateCurrentThreadID()\n{\n\tOwnerThreadId = FPlatformTLS::GetCurrentThreadId();\n}\n\nbool FMassCommandBuffer::Flush(FMassEntityManager& EntityManager)\n{\n\tcheck(!bIsFlushing);\n\tTGuardValue FlushingGuard(bIsFlushing, true);\n\n\t// short-circuit exit\n\tif (HasPendingCommands() == false)\n\t{\n\t\treturn false;\n\t}\n\n\t{\n\t\tUE_MT_SCOPED_WRITE_ACCESS(PendingBatchCommandsDetector);\n\t\tLLM_SCOPE_BYNAME(TEXT(\"Mass/FlushCommands\"));\n\t\tSCOPE_CYCLE_COUNTER(STAT_Mass_FlushCommands);\n\n\t\t// array used to group commands depending on their operations. Based on EMassCommandOperationType\n\t\tconstexpr int32 CommandTypeOrder[] =\n\t\t{\n\t\t\tMAX_int32 - 1, // None\n\t\t\t0, // Create\n\t\t\t3, // Add\n\t\t\t1, // Remove\n\t\t\t2, // ChangeComposition\n\t\t\t4, // Set\n\t\t\t5, // Destroy\n\t\t};\n\t\tstatic_assert(UE_ARRAY_COUNT(CommandTypeOrder) == (int)EMassCommandOperationType::MAX, \"CommandTypeOrder needs to correspond to all EMassCommandOperationType\\'s entries\");\n\n\t\tstruct FBatchedCommandsSortedIndex\n\t\t{\n\t\t\tFBatchedCommandsSortedIndex(const int32 InIndex, const int32 InGroupOrder)\n\t\t\t\t: Index(InIndex), GroupOrder(InGroupOrder)\n\t\t\t{}\n\n\t\t\tconst int32 Index = -1;\n\t\t\tconst int32 GroupOrder = MAX_int32;\n\t\t\tbool IsValid() const { return GroupOrder < MAX_int32; }\n\t\t\tbool operator<(const FBatchedCommandsSortedIndex& Other) const { return GroupOrder < Other.GroupOrder; }\n\t\t};\n\t\t\n\t\tTArray<FBatchedCommandsSortedIndex> CommandsOrder;\n\t\tconst int32 OwnedCommandsCount = CommandInstances.Num();\n\n\t\tCommandsOrder.Reserve(OwnedCommandsCount);\n\t\tfor (int32 i = 0; i < OwnedCommandsCount; ++i)\n\t\t{\n\t\t\tconst TUniquePtr<FMassBatchedCommand>& Command = CommandInstances[i];\n\t\t\tCommandsOrder.Add(FBatchedCommandsSortedIndex(i, (Command && Command->HasWork())? CommandTypeOrder[(int)Command->GetOperationType()] : MAX_int32));\n\t\t}\n\t\tfor (int32 i = 0; i < AppendedCommandInstances.Num(); ++i)\n\t\t{\n\t\t\tconst TUniquePtr<FMassBatchedCommand>& Command = AppendedCommandInstances[i];\n\t\t\tCommandsOrder.Add(FBatchedCommandsSortedIndex(i + OwnedCommandsCount, (Command && Command->HasWork()) ? CommandTypeOrder[(int)Command->GetOperationType()] : MAX_int32));\n\t\t}\n\t\tCommandsOrder.StableSort();\n\t\t\t\t\n\t\tfor (int32 k = 0; k < CommandsOrder.Num() && CommandsOrder[k].IsValid(); ++k)\n\t\t{\n\t\t\tconst int32 CommandIndex = CommandsOrder[k].Index;\n\t\t\tTUniquePtr<FMassBatchedCommand>& Command = CommandIndex < OwnedCommandsCount\n\t\t\t\t? CommandInstances[CommandIndex]\n\t\t\t\t: AppendedCommandInstances[CommandIndex - OwnedCommandsCount];\n\t\t\tcheck(Command)\n\n#if CSV_PROFILER_STATS\n\t\t\tusing namespace UE::Mass::Command;\n\n\t\t\t// Extract name (default or detailed)\n\t\t\tFAnsiString* ANSIName = nullptr;\n\t\t\tFString*     Name     = nullptr;\n\t\t\tGetCommandStatNames(*Command, Name, ANSIName);\n\n\t\t\t// Push stats\n\t\t\tFScopedCsvStat ScopedCsvStat(**ANSIName, CSV_CATEGORY_INDEX(MassEntities));\n\t\t\tFCsvProfiler::RecordCustomStat(**Name, CSV_CATEGORY_INDEX(MassEntitiesCounters), Command->GetNumOperationsStat(), ECsvCustomStatOp::Accumulate);\n#endif // CSV_PROFILER_STATS\n\n\t\t\tCommand->Execute(EntityManager);\n\t\t\tCommand->Reset();\n\t\t}\n\n\t\tAppendedCommandInstances.Reset();\n\n\t\tActiveCommandsCounter = 0;\n\t}\n\n\treturn true;\n}\n \nvoid FMassCommandBuffer::CleanUp()\n{\n\tCommandInstances.Reset();\n\tAppendedCommandInstances.Reset();\n\n\tActiveCommandsCounter = 0;\n}\n\nvoid FMassCommandBuffer::MoveAppend(FMassCommandBuffer& Other)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE(MassCommandBuffer_MoveAppend);\n\n\t// @todo optimize, there surely a way to do faster then this.\n\tUE_MT_SCOPED_READ_ACCESS(Other.PendingBatchCommandsDetector);\n\tif (Other.HasPendingCommands())\n\t{\n\t\tFScopeLock Lock(&AppendingCommandsCS);\n\t\tUE_MT_SCOPED_WRITE_ACCESS(PendingBatchCommandsDetector);\n\t\tAppendedCommandInstances.Append(MoveTemp(Other.CommandInstances));\n\t\tAppendedCommandInstances.Append(MoveTemp(Other.AppendedCommandInstances));\n\t\tActiveCommandsCounter += Other.ActiveCommandsCounter;\n\t\tOther.ActiveCommandsCounter = 0;\n\t}\n}\n\nSIZE_T FMassCommandBuffer::GetAllocatedSize() const\n{\n\tSIZE_T TotalSize = 0;\n\tfor (const TUniquePtr<FMassBatchedCommand>& Command : CommandInstances)\n\t{\n\t\tTotalSize += Command ? Command->GetAllocatedSize() : 0;\n\t}\n\tfor (const TUniquePtr<FMassBatchedCommand>& Command : AppendedCommandInstances)\n\t{\n\t\tTotalSize += Command ? Command->GetAllocatedSize() : 0;\n\t}\n\n\tTotalSize += CommandInstances.GetAllocatedSize();\n\t\n\treturn TotalSize;\n}\n\n",
      "lines": 216
    },
    {
      "file_path": "MassEntity\\Private\\MassDebugger.cpp",
      "extension": ".cpp",
      "size_bytes": 28575,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassDebugger.h\"\n#if WITH_MASSENTITY_DEBUG\n#include \"MassProcessor.h\"\n#include \"MassEntityManager.h\"\n#include \"MassEntityManagerStorage.h\"\n#include \"MassEntitySubsystem.h\"\n#include \"MassArchetypeTypes.h\"\n#include \"MassArchetypeData.h\"\n#include \"MassRequirements.h\"\n#include \"MassEntityQuery.h\"\n#include \"Misc/OutputDevice.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n#include \"MassEntityUtils.h\"\n#include \"MassCommandBuffer.h\"\n\n\nnamespace UE::Mass::Debug\n{\n\tbool bAllowProceduralDebuggedEntitySelection = false;\n\tbool bAllowBreakOnDebuggedEntity = false;\n\tbool bTestSelectedEntityAgainstProcessorQueries = true;\n\n\tFAutoConsoleVariableRef CVars[] =\n\t{\n\t\t{ TEXT(\"mass.debug.AllowProceduralDebuggedEntitySelection\"), bAllowProceduralDebuggedEntitySelection\n\t\t\t, TEXT(\"Guards whether MASS_SET_ENTITY_DEBUGGED calls take effect.\"), ECVF_Cheat}\n\t\t, {TEXT(\"mass.debug.AllowBreakOnDebuggedEntity\"), bAllowBreakOnDebuggedEntity\n\t\t\t, TEXT(\"Guards whether MASS_BREAK_IF_ENTITY_DEBUGGED calls take effect.\"), ECVF_Cheat}\n\t\t, {\tTEXT(\"mass.debug.TestSelectedEntityAgainstProcessorQueries\"), bTestSelectedEntityAgainstProcessorQueries\n\t\t\t, TEXT(\"Enabling will result in testing all processors' queries against SelectedEntity (as indicated by\")\n\t\t\tTEXT(\"mass.debug.DebugEntity or the gameplay debugger) and storing potential failure results to be viewed in MassDebugger\")\n\t\t\t, ECVF_Cheat }\n\t};\n\t\n\n\tFString DebugGetFragmentAccessString(EMassFragmentAccess Access)\n\t{\n\t\tswitch (Access)\n\t\t{\n\t\tcase EMassFragmentAccess::None:\treturn TEXT(\"--\");\n\t\tcase EMassFragmentAccess::ReadOnly:\treturn TEXT(\"RO\");\n\t\tcase EMassFragmentAccess::ReadWrite:\treturn TEXT(\"RW\");\n\t\tdefault:\n\t\t\tensureMsgf(false, TEXT(\"Missing string conversion for EMassFragmentAccess=%d\"), Access);\n\t\t\tbreak;\n\t\t}\n\t\treturn TEXT(\"Missing string conversion\");\n\t}\n\n\tvoid DebugOutputDescription(TConstArrayView<UMassProcessor*> Processors, FOutputDevice& Ar)\n\t{\n\t\tconst bool bAutoLineEnd = Ar.GetAutoEmitLineTerminator();\n\t\tAr.SetAutoEmitLineTerminator(false);\n\t\tfor (const UMassProcessor* Proc : Processors)\n\t\t{\n\t\t\tif (Proc)\n\t\t\t{\n\t\t\t\tProc->DebugOutputDescription(Ar);\n\t\t\t\tAr.Logf(TEXT(\"\\n\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAr.Logf(TEXT(\"NULL\\n\"));\n\t\t\t}\n\t\t}\n\t\tAr.SetAutoEmitLineTerminator(bAutoLineEnd);\n\t}\n\n\t// First Id of a range of lightweight entity for which we want to activate debug information\n\tint32 DebugEntityBegin = INDEX_NONE;\n\n\t// Last Id of a range of lightweight entity for which we want to activate debug information\n\tint32 DebugEntityEnd = INDEX_NONE;\n\n\tvoid SetDebugEntityRange(const int32 InDebugEntityBegin, const int32 InDebugEntityEnd)\n\t{\n\t\tDebugEntityBegin = InDebugEntityBegin;\n\t\tDebugEntityEnd = InDebugEntityEnd;\n\t}\n\n\tstatic FAutoConsoleCommand SetDebugEntityRangeCommand(\n\t\tTEXT(\"mass.debug.SetDebugEntityRange\"),\n\t\tTEXT(\"Range of lightweight entity IDs that we want to debug.\")\n\t\tTEXT(\"Usage: \\\"mass.debug.SetDebugEntityRange <FirstEntity> <LastEntity>\\\"\"),\n\t\tFConsoleCommandWithArgsDelegate::CreateLambda([](const TArray<FString>& Args)\n\t\t\t{\n\t\t\t\tif (Args.Num() != 2)\n\t\t\t\t{\n\t\t\t\t\tUE_LOG(LogConsoleResponse, Display, TEXT(\"Error: Expecting 2 parameters\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tint32 FirstID = INDEX_NONE;\n\t\t\t\tint32 LastID = INDEX_NONE;\n\t\t\t\tif (!LexTryParseString<int32>(FirstID, *Args[0]))\n\t\t\t\t{\n\t\t\t\t\tUE_LOG(LogConsoleResponse, Display, TEXT(\"Error: first parameter must be an integer\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tif (!LexTryParseString<int32>(LastID, *Args[1]))\n\t\t\t\t{\n\t\t\t\t\tUE_LOG(LogConsoleResponse, Display, TEXT(\"Error: second parameter must be an integer\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tSetDebugEntityRange(FirstID, LastID);\n\t\t\t}));\n\n\tstatic FAutoConsoleCommand ResetDebugEntity(\n\t\tTEXT(\"mass.debug.ResetDebugEntity\"),\n\t\tTEXT(\"Disables lightweight entities debugging.\")\n\t\tTEXT(\"Usage: \\\"mass.debug.ResetDebugEntity\\\"\"),\n\t\tFConsoleCommandWithArgsDelegate::CreateLambda([](const TArray<FString>& Args)\n\t\t\t{\n\t\t\t\tSetDebugEntityRange(INDEX_NONE, INDEX_NONE);\n\t\t\t}));\n\n\tbool HasDebugEntities()\n\t{\n\t\treturn DebugEntityBegin != INDEX_NONE && DebugEntityEnd != INDEX_NONE;\n\t}\n\n\tbool IsDebuggingSingleEntity()\n\t{\n\t\treturn DebugEntityBegin != INDEX_NONE && DebugEntityBegin == DebugEntityEnd;\n\t}\n\n\tbool GetDebugEntitiesRange(int32& OutBegin, int32& OutEnd)\n\t{\n\t\tOutBegin = DebugEntityBegin;\n\t\tOutEnd = DebugEntityEnd;\n\t\treturn DebugEntityBegin != INDEX_NONE && DebugEntityEnd != INDEX_NONE && DebugEntityBegin <= DebugEntityEnd;\n\t}\n\t\n\tbool IsDebuggingEntity(FMassEntityHandle Entity, FColor* OutEntityColor)\n\t{\n\t\tconst int32 EntityIdx = Entity.Index;\n\t\tconst bool bIsDebuggingEntity = (DebugEntityBegin != INDEX_NONE && DebugEntityEnd != INDEX_NONE && DebugEntityBegin <= EntityIdx && EntityIdx <= DebugEntityEnd);\n\t\n\t\tif (bIsDebuggingEntity && OutEntityColor != nullptr)\n\t\t{\n\t\t\t*OutEntityColor = GetEntityDebugColor(Entity);\n\t\t}\n\n\t\treturn bIsDebuggingEntity;\n\t}\n\n\tFColor GetEntityDebugColor(FMassEntityHandle Entity)\n\t{\n\t\tconst int32 EntityIdx = Entity.Index;\n\t\treturn EntityIdx != INDEX_NONE ? GColorList.GetFColorByIndex(EntityIdx % GColorList.GetColorsNum()) : FColor::Black;\n\t}\n\n\tFAutoConsoleCommandWithWorldArgsAndOutputDevice PrintEntityFragmentsCmd(\n\t\tTEXT(\"mass.PrintEntityFragments\"),\n\t\tTEXT(\"Prints all fragment types and values (uproperties) for the specified Entity index\"),\n\t\tFConsoleCommandWithWorldArgsAndOutputDeviceDelegate::CreateLambda(\n\t\t\t[](const TArray<FString>& Params, UWorld* World, FOutputDevice& Ar)\n\t\t\t{\n\t\t\t\tcheck(World);\n\t\t\t\tif (UMassEntitySubsystem* EntityManager = World->GetSubsystem<UMassEntitySubsystem>())\n\t\t\t\t{\n\t\t\t\t\tint32 Index = INDEX_NONE;\n\t\t\t\t\tif (LexTryParseString<int32>(Index, *Params[0]))\n\t\t\t\t\t{\n\t\t\t\t\t\tFMassDebugger::OutputEntityDescription(Ar, EntityManager->GetEntityManager(), Index);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tAr.Logf(ELogVerbosity::Error, TEXT(\"Entity index parameter must be an integer\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAr.Logf(ELogVerbosity::Error, TEXT(\"Failed to find MassEntitySubsystem for world %s\"), *GetPathNameSafe(World));\n\t\t\t\t}\n\t\t\t})\n\t);\n\n\tFAutoConsoleCommandWithWorldArgsAndOutputDevice LogArchetypesCmd(\n\t\tTEXT(\"mass.LogArchetypes\"),\n\t\tTEXT(\"Dumps description of archetypes to log. Optional parameter controls whether to include or exclude non-occupied archetypes. Defaults to 'include'.\"),\n\t\tFConsoleCommandWithWorldArgsAndOutputDeviceDelegate::CreateLambda([](const TArray<FString>& Params, UWorld*, FOutputDevice& Ar)\n\t\t\t{\n\t\t\t\tconst TIndirectArray<FWorldContext>& WorldContexts = GEngine->GetWorldContexts();\n\t\t\t\tfor (const FWorldContext& Context : WorldContexts)\n\t\t\t\t{\n\t\t\t\t\tUWorld* World = Context.World();\n\t\t\t\t\tif (World == nullptr || World->IsPreviewWorld())\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tAr.Logf(ELogVerbosity::Log, TEXT(\"Dumping description of archetypes for world: %s (%s - %s)\"),\n\t\t\t\t\t\t*GetPathNameSafe(World),\n\t\t\t\t\t\tLexToString(World->WorldType),\n\t\t\t\t\t\t*ToString(World->GetNetMode()));\n\n\t\t\t\t\tif (UMassEntitySubsystem* EntityManager = World->GetSubsystem<UMassEntitySubsystem>())\n\t\t\t\t\t{\n\t\t\t\t\t\tbool bIncludeEmpty = true;\n\t\t\t\t\t\tif (Params.Num())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tLexTryParseString(bIncludeEmpty, *Params[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tAr.Logf(ELogVerbosity::Log, TEXT(\"Include empty archetypes: %s\"), bIncludeEmpty ? TEXT(\"TRUE\") : TEXT(\"FALSE\"));\n\t\t\t\t\t\tEntityManager->GetEntityManager().DebugGetArchetypesStringDetails(Ar, bIncludeEmpty);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tAr.Logf(ELogVerbosity::Error, TEXT(\"Failed to find MassEntitySubsystem for world: %s (%s - %s)\"),\n\t\t\t\t\t\t\t*GetPathNameSafe(World),\n\t\t\t\t\t\t\tLexToString(World->WorldType),\n\t\t\t\t\t\t\t*ToString(World->GetNetMode()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t);\n\n\t// @todo these console commands will be reparented to \"massentities\" domain once we rename and shuffle the modules around \n\tFAutoConsoleCommandWithWorld RecacheQueries(\n\t\tTEXT(\"mass.RecacheQueries\"),\n\t\tTEXT(\"Forces EntityQueries to recache their valid archetypes\"),\n\t\tFConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* InWorld)\n\t\t\t{\n\t\t\t\tcheck(InWorld);\n\t\t\t\tif (UMassEntitySubsystem* System = InWorld->GetSubsystem<UMassEntitySubsystem>())\n\t\t\t\t{\n\t\t\t\t\tSystem->GetMutableEntityManager().DebugForceArchetypeDataVersionBump();\n\t\t\t\t}\n\t\t\t}\n\t));\n\n\tFAutoConsoleCommandWithWorldArgsAndOutputDevice LogFragmentSizes(\n\t\tTEXT(\"mass.LogFragmentSizes\"),\n\t\tTEXT(\"Logs all the fragment types being used along with their sizes.\"),\n\t\tFConsoleCommandWithWorldArgsAndOutputDeviceDelegate::CreateLambda([](const TArray<FString>& Params, UWorld* World, FOutputDevice& Ar)\n\t\t\t{\n\t\t\t\tfor (const TWeakObjectPtr<const UScriptStruct>& WeakStruct : FMassFragmentBitSet::DebugGetAllStructTypes())\n\t\t\t\t{\n\t\t\t\t\tif (const UScriptStruct* StructType = WeakStruct.Get())\n\t\t\t\t\t{\n\t\t\t\t\t\tAr.Logf(ELogVerbosity::Log, TEXT(\"%s, size: %d\"), *StructType->GetName(), StructType->GetStructureSize());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t);\n\n\tFAutoConsoleCommandWithWorldArgsAndOutputDevice LogMemoryUsage(\n\t\tTEXT(\"mass.LogMemoryUsage\"),\n\t\tTEXT(\"Logs how much memory the mass entity system uses\"),\n\t\tFConsoleCommandWithWorldArgsAndOutputDeviceDelegate::CreateLambda([](const TArray<FString>& Params, UWorld* World, FOutputDevice& Ar)\n\t\t\t{\n\t\t\t\tcheck(World);\n\t\t\t\tif (UMassEntitySubsystem* System = World->GetSubsystem<UMassEntitySubsystem>())\n\t\t\t\t{\n\t\t\t\t\tFResourceSizeEx CumulativeResourceSize;\n\t\t\t\t\tSystem->GetResourceSizeEx(CumulativeResourceSize);\n\t\t\t\t\tAr.Logf(ELogVerbosity::Log, TEXT(\"MassEntity system uses: %d bytes\"), CumulativeResourceSize.GetDedicatedSystemMemoryBytes());\n\t\t\t\t}\n\t\t\t}));\n\n\tFAutoConsoleCommandWithOutputDevice LogFragments(\n\t\tTEXT(\"mass.LogKnownFragments\"),\n\t\tTEXT(\"Logs all the known tags and fragments along with their \\\"index\\\" as stored via bitsets.\"),\n\t\tFConsoleCommandWithOutputDeviceDelegate::CreateStatic([](FOutputDevice& OutputDevice)\n\t\t\t{\n\t\t\t\tauto PrintKnownTypes = [&OutputDevice](TConstArrayView<TWeakObjectPtr<const UScriptStruct>> AllStructs) {\n\t\t\t\t\tint i = 0;\n\t\t\t\t\tfor (TWeakObjectPtr<const UScriptStruct> Struct : AllStructs)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Struct.IsValid())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOutputDevice.Logf(TEXT(\"\\t%d. %s\"), i++, *Struct->GetName());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tOutputDevice.Logf(TEXT(\"Known tags:\"));\n\t\t\t\tPrintKnownTypes(FMassTagBitSet::DebugGetAllStructTypes());\n\n\t\t\t\tOutputDevice.Logf(TEXT(\"Known Fragments:\"));\n\t\t\t\tPrintKnownTypes(FMassFragmentBitSet::DebugGetAllStructTypes());\n\n\t\t\t\tOutputDevice.Logf(TEXT(\"Known Shared Fragments:\"));\n\t\t\t\tPrintKnownTypes(FMassSharedFragmentBitSet::DebugGetAllStructTypes());\n\n\t\t\t\tOutputDevice.Logf(TEXT(\"Known Chunk Fragments:\"));\n\t\t\t\tPrintKnownTypes(FMassChunkFragmentBitSet::DebugGetAllStructTypes());\n\t\t\t}));\n\n\tstatic FAutoConsoleCommandWithWorldAndArgs DestroyEntity(\n\t\tTEXT(\"mass.debug.DestroyEntity\"),\n\t\tTEXT(\"ID of a Mass entity that we want to destroy.\")\n\t\tTEXT(\"Usage: \\\"mass.debug.DestoryEntity <Entity>\\\"\"),\n\t\tFConsoleCommandWithWorldAndArgsDelegate::CreateLambda([](const TArray<FString>& Args, UWorld* World)\n\t{\n\t\tif (Args.Num() != 1)\n\t\t{\n\t\t\tUE_LOG(LogConsoleResponse, Display, TEXT(\"Error: Expecting 1 parameter\"));\n\t\t\treturn;\n\t\t}\n\n\t\tint32 ID = INDEX_NONE;\n\t\tif (!LexTryParseString<int32>(ID, *Args[0]))\n\t\t{\n\t\t\tUE_LOG(LogConsoleResponse, Display, TEXT(\"Error: parameter must be an integer\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!World)\n\t\t{\n\t\t\tUE_LOG(LogConsoleResponse, Display, TEXT(\"Error: invalid world\"));\n\t\t\treturn;\n\t\t}\n\n\t\tFMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(*World);\n\t\tFMassEntityHandle EntityToDestroy = EntityManager.DebugGetEntityIndexHandle(ID);\n\t\tif (!EntityToDestroy.IsSet())\n\t\t{\n\t\t\tUE_LOG(LogConsoleResponse, Display, TEXT(\"Error: cannot find entity for this index\"));\n\t\t\treturn;\n\t\t}\n\n\t\tEntityManager.Defer().DestroyEntity(EntityToDestroy);\n\t}));\n\n\tstatic FAutoConsoleCommandWithWorldAndArgs SetDebugEntity(\n\t\tTEXT(\"mass.debug.DebugEntity\"),\n\t\tTEXT(\"ID of a Mass entity that we want to debug.\")\n\t\tTEXT(\"Usage: \\\"mass.debug.DebugEntity <Entity>\\\"\"),\n\t\tFConsoleCommandWithWorldAndArgsDelegate::CreateLambda([](const TArray<FString>& Args, UWorld* World)\n\t\t{\n\t\t\tif (Args.Num() != 1)\n\t\t\t{\n\t\t\t\tUE_LOG(LogConsoleResponse, Display, TEXT(\"Error: Expecting 1 parameter\"));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint32 ID = INDEX_NONE;\n\t\t\tif (!LexTryParseString<int32>(ID, *Args[0]))\n\t\t\t{\n\t\t\t\tUE_LOG(LogConsoleResponse, Display, TEXT(\"Error: parameter must be an integer\"));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!World)\n\t\t\t{\n\t\t\t\tUE_LOG(LogConsoleResponse, Display, TEXT(\"Error: invalid world\"));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSetDebugEntityRange(ID, ID);\n\n\t\t\tFMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(*World);\n\t\t\tFMassEntityHandle EntityToDebug = EntityManager.DebugGetEntityIndexHandle(ID);\n\t\t\tif (!EntityToDebug.IsSet())\n\t\t\t{\n\t\t\t\tUE_LOG(LogConsoleResponse, Display, TEXT(\"Error: cannot find entity for this index\"));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tFMassDebugger::SelectEntity(EntityManager, EntityToDebug);\n\t\t}\n\t));\n\n} // namespace UE::Mass::Debug\n\n//----------------------------------------------------------------------//\n// FMassDebugger\n//----------------------------------------------------------------------//\nFMassDebugger::FOnEntitySelected FMassDebugger::OnEntitySelectedDelegate;\n\nFMassDebugger::FOnMassEntityManagerEvent FMassDebugger::OnEntityManagerInitialized;\nFMassDebugger::FOnMassEntityManagerEvent FMassDebugger::OnEntityManagerDeinitialized;\nFMassDebugger::FOnDebugEvent FMassDebugger::OnDebugEvent;\nTArray<FMassDebugger::FEnvironment> FMassDebugger::ActiveEnvironments;\nUE::FSpinLock FMassDebugger::EntityManagerRegistrationLock;\n\nTConstArrayView<FMassEntityQuery*> FMassDebugger::GetProcessorQueries(const UMassProcessor& Processor)\n{\n\treturn Processor.OwnedQueries;\n}\n\nTConstArrayView<FMassEntityQuery*> FMassDebugger::GetUpToDateProcessorQueries(const FMassEntityManager& EntityManager, UMassProcessor& Processor)\n{\n\tfor (FMassEntityQuery* Query : Processor.OwnedQueries)\n\t{\n\t\tif (Query)\n\t\t{\n\t\t\tQuery->CacheArchetypes(EntityManager);\n\t\t}\n\t}\n\n\treturn Processor.OwnedQueries;\n}\n\nUE::Mass::Debug::FQueryRequirementsView FMassDebugger::GetQueryRequirements(const FMassEntityQuery& Query)\n{\n\tUE::Mass::Debug::FQueryRequirementsView View = { Query.FragmentRequirements, Query.ChunkFragmentRequirements, Query.ConstSharedFragmentRequirements, Query.SharedFragmentRequirements\n\t\t, Query.RequiredAllTags, Query.RequiredAnyTags, Query.RequiredNoneTags, Query.RequiredOptionalTags\n\t\t, Query.RequiredConstSubsystems, Query.RequiredMutableSubsystems };\n\n\treturn View;\n}\n\nvoid FMassDebugger::GetQueryExecutionRequirements(const FMassEntityQuery& Query, FMassExecutionRequirements& OutExecutionRequirements)\n{\n\tQuery.ExportRequirements(OutExecutionRequirements);\n}\n\nTArray<FMassArchetypeHandle> FMassDebugger::GetAllArchetypes(const FMassEntityManager& EntityManager)\n{\n\tTArray<FMassArchetypeHandle> Archetypes;\n\n\tfor (auto& KVP : EntityManager.FragmentHashToArchetypeMap)\n\t{\n\t\tfor (const TSharedPtr<FMassArchetypeData>& Archetype : KVP.Value)\n\t\t{\n\t\t\tArchetypes.Add(FMassArchetypeHelper::ArchetypeHandleFromData(Archetype));\n\t\t}\n\t}\n\n\treturn Archetypes;\n}\n\nconst FMassArchetypeCompositionDescriptor& FMassDebugger::GetArchetypeComposition(const FMassArchetypeHandle& ArchetypeHandle)\n{\n\tconst FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);\n\treturn ArchetypeData.CompositionDescriptor;\n}\n\nvoid FMassDebugger::GetArchetypeEntityStats(const FMassArchetypeHandle& ArchetypeHandle, UE::Mass::Debug::FArchetypeStats& OutStats)\n{\n\tconst FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);\n\tOutStats.EntitiesCount = ArchetypeData.GetNumEntities();\n\tOutStats.EntitiesCountPerChunk = ArchetypeData.GetNumEntitiesPerChunk();\n\tOutStats.ChunksCount = ArchetypeData.GetChunkCount();\n\tOutStats.AllocatedSize = ArchetypeData.GetAllocatedSize();\n\tOutStats.BytesPerEntity = ArchetypeData.GetBytesPerEntity();\n\n\tSIZE_T ActiveChunksMemorySize = 0;\n\tSIZE_T ActiveEntitiesMemorySize = 0;\n\tArchetypeData.DebugGetEntityMemoryNumbers(ActiveChunksMemorySize, ActiveEntitiesMemorySize);\n\tOutStats.WastedEntityMemory = ActiveChunksMemorySize - ActiveEntitiesMemorySize;\n}\n\nconst TConstArrayView<FName> FMassDebugger::GetArchetypeDebugNames(const FMassArchetypeHandle& ArchetypeHandle)\n{\n\tconst FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);\n\treturn ArchetypeData.GetDebugNames();\n}\n\nTConstArrayView<struct UMassCompositeProcessor::FDependencyNode> FMassDebugger::GetProcessingGraph(const UMassCompositeProcessor& GraphOwner)\n{\n\treturn GraphOwner.FlatProcessingGraph;\n}\n\nTConstArrayView<TObjectPtr<UMassProcessor>> FMassDebugger::GetHostedProcessors(const UMassCompositeProcessor& GraphOwner)\n{\n\treturn GraphOwner.ChildPipeline.GetProcessors();\n}\n\nFString FMassDebugger::GetRequirementsDescription(const FMassFragmentRequirements& Requirements)\n{\n\tTStringBuilder<256> StringBuilder;\n\tStringBuilder.Append(TEXT(\"<\"));\n\n\tbool bNeedsComma = false;\n\tfor (const FMassFragmentRequirementDescription& Requirement : Requirements.FragmentRequirements)\n\t{\n\t\tif (bNeedsComma)\n\t\t{\n\t\t\tStringBuilder.Append(TEXT(\",\"));\n\t\t}\n\t\tStringBuilder.Append(*FMassDebugger::GetSingleRequirementDescription(Requirement));\n\t\tbNeedsComma = true;\n\t}\n\n\tStringBuilder.Append(TEXT(\">\"));\n\treturn StringBuilder.ToString();\n}\n\nFString FMassDebugger::GetArchetypeRequirementCompatibilityDescription(const FMassFragmentRequirements& Requirements, const FMassArchetypeHandle& ArchetypeHandle)\n{\n\tif (ArchetypeHandle.IsValid() == false)\n\t{\n\t\treturn TEXT(\"Invalid\");\n\t}\n\n\tconst FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);\n\treturn FMassDebugger::GetArchetypeRequirementCompatibilityDescription(Requirements, ArchetypeData.GetCompositionDescriptor());\n}\n\t\nFString FMassDebugger::GetArchetypeRequirementCompatibilityDescription(const FMassFragmentRequirements& Requirements, const FMassArchetypeCompositionDescriptor& ArchetypeComposition)\n{\n\tFStringOutputDevice OutDescription;\n\n\tif (Requirements.HasNegativeRequirements())\n\t{\n\t\tif (ArchetypeComposition.Fragments.HasNone(Requirements.RequiredNoneFragments) == false)\n\t\t{\n\t\t\t// has some of the fragments required absent\n\t\t\tOutDescription += TEXT(\"\\nHas fragments required absent: \");\n\t\t\t(Requirements.RequiredNoneFragments & ArchetypeComposition.Fragments).DebugGetStringDesc(OutDescription);\n\t\t}\n\n\t\tif (ArchetypeComposition.Tags.HasNone(Requirements.RequiredNoneTags) == false)\n\t\t{\n\t\t\t// has some of the tags required absent\n\t\t\tOutDescription += TEXT(\"\\nHas tags required absent: \");\n\t\t\t(Requirements.RequiredNoneTags & ArchetypeComposition.Tags).DebugGetStringDesc(OutDescription);\n\t\t}\n\n\t\tif (ArchetypeComposition.ChunkFragments.HasNone(Requirements.RequiredNoneChunkFragments) == false)\n\t\t{\n\t\t\t// has some of the chunk fragments required absent\n\t\t\tOutDescription += TEXT(\"\\nHas chunk fragments required absent: \");\n\t\t\t(Requirements.RequiredNoneChunkFragments & ArchetypeComposition.ChunkFragments).DebugGetStringDesc(OutDescription);\n\t\t}\n\n\t\tif (ArchetypeComposition.SharedFragments.HasNone(Requirements.RequiredNoneSharedFragments) == false)\n\t\t{\n\t\t\t// has some of the chunk fragments required absent\n\t\t\tOutDescription += TEXT(\"\\nHas shared fragments required absent: \");\n\t\t\t(Requirements.RequiredNoneSharedFragments & ArchetypeComposition.SharedFragments).DebugGetStringDesc(OutDescription);\n\t\t}\n\n\t\tif (ArchetypeComposition.ConstSharedFragments.HasNone(Requirements.RequiredNoneConstSharedFragments) == false)\n\t\t{\n\t\t\t// has some of the chunk fragments required absent\n\t\t\tOutDescription += TEXT(\"\\nHas shared fragments required absent: \");\n\t\t\t(Requirements.RequiredNoneConstSharedFragments & ArchetypeComposition.ConstSharedFragments).DebugGetStringDesc(OutDescription);\n\t\t}\n\t}\n\n\t// if we have regular (i.e. non-optional) positive requirements then these are the determining factor, we don't check optionals\n\tif (Requirements.HasPositiveRequirements())\n\t{\n\t\tif (ArchetypeComposition.Fragments.HasAll(Requirements.RequiredAllFragments) == false)\n\t\t{\n\t\t\t// missing one of the strictly required fragments\n\t\t\tOutDescription += TEXT(\"\\nMissing required fragments: \");\n\t\t\t(Requirements.RequiredAllFragments - ArchetypeComposition.Fragments).DebugGetStringDesc(OutDescription);\n\t\t}\n\n\t\tif (Requirements.RequiredAnyFragments.IsEmpty() == false && ArchetypeComposition.Fragments.HasAny(Requirements.RequiredAnyFragments) == false)\n\t\t{\n\t\t\t// missing all of the \"any\" fragments\n\t\t\tOutDescription += TEXT(\"\\nMissing all \\'any\\' fragments: \");\n\t\t\tRequirements.RequiredAnyFragments.DebugGetStringDesc(OutDescription);\n\t\t}\n\n\t\tif (ArchetypeComposition.Tags.HasAll(Requirements.RequiredAllTags) == false)\n\t\t{\n\t\t\t// missing one of the strictly required tags\n\t\t\tOutDescription += TEXT(\"\\nMissing required tags: \");\n\t\t\t(Requirements.RequiredAllTags - ArchetypeComposition.Tags).DebugGetStringDesc(OutDescription);\n\t\t}\n\n\t\tif (Requirements.RequiredAnyTags.IsEmpty() == false && ArchetypeComposition.Tags.HasAny(Requirements.RequiredAnyTags) == false)\n\t\t{\n\t\t\t// missing all of the \"any\" tags\n\t\t\tOutDescription += TEXT(\"\\nMissing all \\'any\\' tags: \");\n\t\t\tRequirements.RequiredAnyTags.DebugGetStringDesc(OutDescription);\n\t\t}\n\n\t\tif (ArchetypeComposition.ChunkFragments.HasAll(Requirements.RequiredAllChunkFragments) == false)\n\t\t{\n\t\t\t// missing one of the strictly required chunk fragments\n\t\t\tOutDescription += TEXT(\"\\nMissing required chunk fragments: \");\n\t\t\t(Requirements.RequiredAllChunkFragments - ArchetypeComposition.ChunkFragments).DebugGetStringDesc(OutDescription);\n\t\t}\n\n\t\tif (ArchetypeComposition.SharedFragments.HasAll(Requirements.RequiredAllSharedFragments) == false)\n\t\t{\n\t\t\t// missing one of the strictly required Shared fragments\n\t\t\tOutDescription += TEXT(\"\\nMissing required Shared fragments: \");\n\t\t\t(Requirements.RequiredAllSharedFragments - ArchetypeComposition.SharedFragments).DebugGetStringDesc(OutDescription);\n\t\t}\n\n\t\tif (ArchetypeComposition.ConstSharedFragments.HasAll(Requirements.RequiredAllConstSharedFragments) == false)\n\t\t{\n\t\t\t// missing one of the strictly required Shared fragments\n\t\t\tOutDescription += TEXT(\"\\nMissing required Shared fragments: \");\n\t\t\t(Requirements.RequiredAllConstSharedFragments - ArchetypeComposition.ConstSharedFragments).DebugGetStringDesc(OutDescription);\n\t\t}\n\t}\n\t// else we check if there are any optionals and if so test them\n\telse if (Requirements.HasOptionalRequirements() && (Requirements.DoesMatchAnyOptionals(ArchetypeComposition) == false))\n\t{\n\t\t// we report that none of the optionals has been met\n\t\tOutDescription += TEXT(\"\\nNone of the optionals were safisfied while not having other positive hard requirements: \");\n\n\t\tRequirements.RequiredOptionalTags.DebugGetStringDesc(OutDescription);\n\t\tRequirements.RequiredOptionalFragments.DebugGetStringDesc(OutDescription);\n\t\tRequirements.RequiredOptionalChunkFragments.DebugGetStringDesc(OutDescription);\n\t\tRequirements.RequiredOptionalSharedFragments.DebugGetStringDesc(OutDescription);\n\t\tRequirements.RequiredOptionalConstSharedFragments.DebugGetStringDesc(OutDescription);\n\t}\n\n\treturn OutDescription.Len() > 0 ? static_cast<FString>(OutDescription) : TEXT(\"Match\");\n}\n\nFString FMassDebugger::GetSingleRequirementDescription(const FMassFragmentRequirementDescription& Requirement)\n{\n\treturn FString::Printf(TEXT(\"%s%s[%s]\"), Requirement.IsOptional() ? TEXT(\"?\") : (Requirement.Presence == EMassFragmentPresence::None ? TEXT(\"-\") : TEXT(\"+\"))\n\t\t, *GetNameSafe(Requirement.StructType), *UE::Mass::Debug::DebugGetFragmentAccessString(Requirement.AccessMode));\n}\n\nvoid FMassDebugger::OutputArchetypeDescription(FOutputDevice& Ar, const FMassArchetypeHandle& ArchetypeHandle)\n{\n\tAr.Logf(TEXT(\"%s\"), ArchetypeHandle.IsValid() ? *FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle).DebugGetDescription() : TEXT(\"INVALID\"));\n}\n\nvoid FMassDebugger::OutputEntityDescription(FOutputDevice& Ar, const FMassEntityManager& EntityManager, const int32 EntityIndex, const TCHAR* InPrefix)\n{\n\tif (EntityIndex >= EntityManager.DebugGetEntityStorageInterface().Num())\n\t{\n\t\tAr.Logf(ELogVerbosity::Log, TEXT(\"Unable to list fragments values for out of range index in EntityManager owned by %s\"), *GetPathNameSafe(EntityManager.GetOwner()));\n\t\treturn;\n\t}\n\t\n\tif (!EntityManager.DebugGetEntityStorageInterface().IsValid(EntityIndex))\n\t{\n\t\tAr.Logf(ELogVerbosity::Log, TEXT(\"Unable to list fragments values for invalid entity in EntityManager owned by %s\"), *GetPathNameSafe(EntityManager.GetOwner()));\n\t}\n\t\n\tFMassEntityHandle Entity;\n\tEntity.Index = EntityIndex;\n\tEntity.SerialNumber = EntityManager.DebugGetEntityStorageInterface().GetSerialNumber(EntityIndex);\n\tOutputEntityDescription(Ar, EntityManager, Entity, InPrefix);\n}\n\nvoid FMassDebugger::OutputEntityDescription(FOutputDevice& Ar, const FMassEntityManager& EntityManager, const FMassEntityHandle Entity, const TCHAR* InPrefix)\n{\n\tif (!EntityManager.IsEntityActive(Entity))\n\t{\n\t\tAr.Logf(ELogVerbosity::Log, TEXT(\"Unable to list fragments values for invalid entity in EntityManager owned by %s\"), *GetPathNameSafe(EntityManager.GetOwner()));\n\t}\n\n\tAr.Logf(ELogVerbosity::Log, TEXT(\"Listing fragments values for Entity[%s] in EntityManager owned by %s\"), *Entity.DebugGetDescription(), *GetPathNameSafe(EntityManager.GetOwner()));\n\n\tFMassArchetypeData* Archetype = EntityManager.DebugGetEntityStorageInterface().GetArchetypeAsShared(Entity.Index).Get();\n\tif (Archetype == nullptr)\n\t{\n\t\tAr.Logf(ELogVerbosity::Log, TEXT(\"Unable to list fragments values for invalid entity in EntityManager owned by %s\"), *GetPathNameSafe(EntityManager.GetOwner()));\n\t}\n\telse\n\t{\n\t\tArchetype->DebugPrintEntity(Entity, Ar, InPrefix);\n\t}\n}\n\nvoid FMassDebugger::SelectEntity(const FMassEntityManager& EntityManager, const FMassEntityHandle EntityHandle)\n{\n\tUE::Mass::Debug::SetDebugEntityRange(EntityHandle.Index, EntityHandle.Index);\n\n\tconst int32 Index = ActiveEnvironments.IndexOfByPredicate([WeakManager = EntityManager.AsWeak()](const FEnvironment& Element)\n\t\t{\n\t\t\treturn Element.EntityManager == WeakManager;\n\t\t});\n\tif (ensure(Index != INDEX_NONE))\n\t{\n\t\tActiveEnvironments[Index].SelectedEntity = EntityHandle;\n\t}\n\n\tOnEntitySelectedDelegate.Broadcast(EntityManager, EntityHandle);\n}\n\nFMassEntityHandle FMassDebugger::GetSelectedEntity(const FMassEntityManager& EntityManager)\n{\n\tconst int32 Index = ActiveEnvironments.IndexOfByPredicate([WeakManager = EntityManager.AsWeak()](const FEnvironment& Element)\n\t\t{\n\t\t\treturn Element.EntityManager == WeakManager;\n\t\t});\n\n\treturn Index != INDEX_NONE ? ActiveEnvironments[Index].SelectedEntity : FMassEntityHandle();\n}\n\nvoid FMassDebugger::RegisterEntityManager(FMassEntityManager& EntityManager)\n{\n\tUE::TScopeLock<UE::FSpinLock> ScopeLock(EntityManagerRegistrationLock);\n\n\tActiveEnvironments.Emplace(EntityManager);\n\tOnEntityManagerInitialized.Broadcast(EntityManager);\n}\n\nvoid FMassDebugger::UnregisterEntityManager(FMassEntityManager& EntityManager)\n{\n\tUE::TScopeLock<UE::FSpinLock> ScopeLock(EntityManagerRegistrationLock);\n\n\tif (EntityManager.DoesSharedInstanceExist())\n\t{\n\t\tconst int32 Index = ActiveEnvironments.IndexOfByPredicate([WeakManager = EntityManager.AsWeak()](const FEnvironment& Element) \n\t\t{\n\t\t\treturn Element.EntityManager == WeakManager;\n\t\t});\n\t\tif (Index != INDEX_NONE)\n\t\t{\n\t\t\tActiveEnvironments.RemoveAt(Index, EAllowShrinking::No);\n\t\t}\n\t}\n\telse\n\t{\n\t\tActiveEnvironments.RemoveAll([](const FEnvironment& Item)\n\t\t\t{\n\t\t\t\treturn Item.IsValid() == false;\n\t\t\t});\n\t}\n\tOnEntityManagerDeinitialized.Broadcast(EntityManager);\n}\n\nbool FMassDebugger::DoesArchetypeMatchRequirements(const FMassArchetypeHandle& ArchetypeHandle, const FMassFragmentRequirements& Requirements, FOutputDevice& OutputDevice)\n{\n\tif (const FMassArchetypeData* Archetype = FMassArchetypeHelper::ArchetypeDataFromHandle(ArchetypeHandle))\n\t{\n\t\treturn FMassArchetypeHelper::DoesArchetypeMatchRequirements(*Archetype, Requirements, /*bBailOutOnFirstFail=*/false, &OutputDevice);\n\t}\n\treturn false;\n}\n\n#endif // WITH_MASSENTITY_DEBUG",
      "lines": 727
    },
    {
      "file_path": "MassEntity\\Private\\MassEntityManager.cpp",
      "extension": ".cpp",
      "size_bytes": 90036,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEntityManager.h\"\n#include \"MassEntityManagerConstants.h\"\n#include \"MassArchetypeData.h\"\n#include \"MassCommandBuffer.h\"\n#include \"MassEntityManagerStorage.h\"\n#include \"Engine/World.h\"\n#include \"UObject/UObjectIterator.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassDebugger.h\"\n#include \"Misc/Fork.h\"\n#include \"Misc/CoreDelegates.h\"\n#include \"Algo/Find.h\"\n#include \"MassEntityUtils.h\"\n\nconst FMassEntityHandle FMassEntityManager::InvalidEntity;\n\nnamespace UE::Mass::Private\n{\n\t// note: this function doesn't set EntityHandle.SerialNumber\n\tvoid ConvertArchetypelessSubchunksIntoEntityHandles(FMassArchetypeEntityCollection::FConstEntityRangeArrayView Subchunks, TArray<FMassEntityHandle>& OutEntityHandles)\n\t{\n\t\tint32 TotalCount = 0;\n\t\tfor (const FMassArchetypeEntityCollection::FArchetypeEntityRange& Subchunk : Subchunks)\n\t\t{\n\t\t\tTotalCount += Subchunk.Length;\n\t\t}\n\n\t\tint32 Index = OutEntityHandles.Num();\n\t\tOutEntityHandles.AddDefaulted(TotalCount);\n\n\t\tfor (const FMassArchetypeEntityCollection::FArchetypeEntityRange& Subchunk : Subchunks)\n\t\t{\n\t\t\tfor (int i = Subchunk.SubchunkStart; i < Subchunk.SubchunkStart + Subchunk.Length; ++i)\n\t\t\t{\n\t\t\t\tOutEntityHandles[Index++].Index = i;\n\t\t\t}\n\t\t}\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// FMassEntityManager::FEntityCreationContext\n//-----------------------------------------------------------------------------\nFMassEntityManager::FEntityCreationContext::FEntityCreationContext()\n\t: OwnerThreadId(FPlatformTLS::GetCurrentThreadId())\n{\t\n}\n\nFMassEntityManager::FEntityCreationContext::FEntityCreationContext(FMassEntityManager& InManager, const TConstArrayView<FMassEntityHandle> InCreatedEntities)\n\t: FEntityCreationContext()\n{\n\tCreatedEntities = InCreatedEntities;\n\tManager = InManager.AsShared();\n}\n\nFMassEntityManager::FEntityCreationContext::FEntityCreationContext(FMassEntityManager& InManager, const TConstArrayView<FMassEntityHandle> InCreatedEntities\n\t, FMassArchetypeEntityCollection&& InEntityCollection)\n\t: FEntityCreationContext(InManager, InCreatedEntities)\n{\n\tcheckf(InCreatedEntities.IsEmpty() || InEntityCollection.IsEmpty() == false, TEXT(\"Trying to create FEntityCreationContext instance with no entities but non-empty entity collection. This is not supported.\"))\n\tif (InCreatedEntities.IsEmpty() == false)\n\t{\n\t\tEntityCollections.Add(MoveTemp(InEntityCollection));\n\t}\n}\n\nFMassEntityManager::FEntityCreationContext::~FEntityCreationContext()\n{\n\tif (((EntityCollections.IsEmpty() == false) || (CreatedEntities.IsEmpty() == false)) && ensure(Manager))\n\t{\n\t\tManager->GetObserverManager().OnPostEntitiesCreated(GetEntityCollections());\n\t}\n}\n\nTConstArrayView<FMassArchetypeEntityCollection> FMassEntityManager::FEntityCreationContext::GetEntityCollections() const\n{\n\t// the EntityCollection has been dirtied, we need to rebuild it\n\tif (IsDirty() && ensure(Manager))\n\t{\n\t\tUE::Mass::Utils::CreateEntityCollections(*Manager.Get(), CreatedEntities, CollectionCreationDuplicatesHandling, EntityCollections);\n\t}\n\n\treturn EntityCollections;\n}\n\nvoid FMassEntityManager::FEntityCreationContext::MarkDirty()\n{\n\tcheckf(OwnerThreadId == FPlatformTLS::GetCurrentThreadId(), TEXT(\"%hs: all FEntityCreationContext operations ere expected to be run in a single thread\"), __FUNCTION__);\n\n\tEntityCollections.Reset();\n}\n\nvoid FMassEntityManager::FEntityCreationContext::AppendEntities(const TConstArrayView<FMassEntityHandle> EntitiesToAppend)\n{\n\tcheckf(OwnerThreadId == FPlatformTLS::GetCurrentThreadId(), TEXT(\"%hs: all FEntityCreationContext operations ere expected to be run in a single thread\"), __FUNCTION__);\n\n\tif (EntitiesToAppend.Num())\n\t{\n\t\tif (CreatedEntities.Num())\n\t\t{\n\t\t\t// since we already have entities in CreatedEntities (initially ensured to have no duplicates) we cannot \n\t\t\t// guarantee anymore that we'll have no duplicates after adding EntitiesToAppend\n\t\t\tCollectionCreationDuplicatesHandling = FMassArchetypeEntityCollection::FoldDuplicates;\n\t\t\tMarkDirty();\n\t\t}\n\t\t// else, if there are no entities the resulting state will be \"dirty\" by design\n\t\tensureMsgf(EntityCollections.IsEmpty(), TEXT(\"Having a non-empty array of entity collections is unexpected at this point!\"));\n\n\t\tCreatedEntities.Append(EntitiesToAppend);\n\t\tensure(IsDirty());\n\t}\n}\n\nvoid FMassEntityManager::FEntityCreationContext::AppendEntities(const TConstArrayView<FMassEntityHandle> EntitiesToAppend, FMassArchetypeEntityCollection&& InEntityCollection)\n{\n\tcheckf(OwnerThreadId == FPlatformTLS::GetCurrentThreadId(), TEXT(\"%hs: all FEntityCreationContext operations ere expected to be run in a single thread\"), __FUNCTION__);\n\n\tif (EntitiesToAppend.Num() == 0)\n\t{\n\t\treturn;\n\t}\n\t\n\tAppendEntities(EntitiesToAppend);\n\n\t// this condition boils down to checking if this FEntityCreationContext instance only connects the just added EntitiesToAppend\n\tif (CreatedEntities.Num() == EntitiesToAppend.Num())\n\t{\n\t\tcheckf(EntityCollections.Num() == 0, TEXT(\"We never expect EntityCollections to be non-empty while there are no entities in CreatedEntities.\"));\n\t\tEntityCollections.Add(MoveTemp(InEntityCollection));\n\t}\n}\n\nvoid FMassEntityManager::FEntityCreationContext::ForceUpdateCurrentThreadID()\n{\n\tOwnerThreadId = FPlatformTLS::GetCurrentThreadId();\n}\n\n//-----------------------------------------------------------------------------\n// FMassEntityManager\n//-----------------------------------------------------------------------------\n#if MASS_CONCURRENT_RESERVE\nUE::Mass::IEntityStorageInterface& FMassEntityManager::GetEntityStorageInterface()\n{\n\tusing namespace UE::Mass;\n\tstruct StorageSelector\n\t{\n\t\tUE::Mass::IEntityStorageInterface* operator()(FEmptyVariantState&) const\n\t\t{\n\t\t\tcheckf(false, TEXT(\"Attempt to use EntityStorageInterface without initialization\"));\n\t\t\treturn nullptr;\n\t\t}\n\t\tUE::Mass::IEntityStorageInterface* operator()(FSingleThreadedEntityStorage& Storage) const\n\t\t{\n\t\t\treturn &Storage;\n\t\t}\n\t\tUE::Mass::IEntityStorageInterface* operator()(FConcurrentEntityStorage& Storage) const\n\t\t{\n\t\t\treturn &Storage;\n\t\t}\n\t};\n\n\tUE::Mass::IEntityStorageInterface* Interface = Visit(StorageSelector{}, EntityStorage);\n\n\treturn *Interface;\n}\n\nconst UE::Mass::IEntityStorageInterface& FMassEntityManager::GetEntityStorageInterface() const\n{\n\tusing namespace UE::Mass;\n\tstruct StorageSelector\n\t{\n\t\tconst UE::Mass::IEntityStorageInterface* operator()(const FEmptyVariantState&) const\n\t\t{\n\t\t\tcheckf(false, TEXT(\"Attempt to use EntityStorageInterface without initialization\"));\n\t\t\treturn nullptr;\n\t\t}\n\t\tconst UE::Mass::IEntityStorageInterface* operator()(const FSingleThreadedEntityStorage& Storage) const\n\t\t{\n\t\t\treturn &Storage;\n\t\t}\n\t\tconst UE::Mass::IEntityStorageInterface* operator()(const FConcurrentEntityStorage& Storage) const\n\t\t{\n\t\t\treturn &Storage;\n\t\t}\n\t};\n\n\tconst UE::Mass::IEntityStorageInterface* Interface = Visit(StorageSelector{}, EntityStorage);\n\n\treturn *Interface;\n}\n#else\nUE::Mass::FSingleThreadedEntityStorage& FMassEntityManager::GetEntityStorageInterface()\n{\n\t// Get will assert if not initialized\n\treturn EntityStorage.Get<UE::Mass::FSingleThreadedEntityStorage>();\n}\n\nconst UE::Mass::FSingleThreadedEntityStorage& FMassEntityManager::GetEntityStorageInterface() const\n{\n\t// Get will assert if not initialized\n\treturn EntityStorage.Get<UE::Mass::FSingleThreadedEntityStorage>();\n}\n#endif\n\n#if WITH_MASSENTITY_DEBUG\nUE::Mass::IEntityStorageInterface& FMassEntityManager::DebugGetEntityStorageInterface()\n{\n\treturn GetEntityStorageInterface();\n}\n\nconst UE::Mass::IEntityStorageInterface& FMassEntityManager::DebugGetEntityStorageInterface() const\n{\n\treturn GetEntityStorageInterface();\n}\n#endif\n\n//-----------------------------------------------------------------------------\n// FMassEntityManager\n//-----------------------------------------------------------------------------\nFMassEntityManager::FMassEntityManager(UObject* InOwner)\n\t: ObserverManager(*this)\n\t, Owner(InOwner)\n{\n#if WITH_MASSENTITY_DEBUG\n\tDebugName = InOwner ? (InOwner->GetName() + TEXT(\"_EntityManager\")) : TEXT(\"Unset\");\n#endif\n}\n\nFMassEntityManager::~FMassEntityManager()\n{\n\tif (bInitialized)\n\t{\n\t\tDeinitialize();\n\t}\n}\n\nvoid FMassEntityManager::GetResourceSizeEx(FResourceSizeEx& CumulativeResourceSize)\n{\n\tSIZE_T MyExtraSize = GetEntityStorageInterface().GetAllocatedSize()\n\t\t+ FragmentHashToArchetypeMap.GetAllocatedSize()\n\t\t+ FragmentTypeToArchetypeMap.GetAllocatedSize();\n\n\tfor (const TSharedPtr<FMassCommandBuffer>& CommandBuffer : DeferredCommandBuffers)\n\t{\n\t\tMyExtraSize += (CommandBuffer ? CommandBuffer->GetAllocatedSize() : 0);\n\t}\n\t\n\tCumulativeResourceSize.AddDedicatedSystemMemoryBytes(MyExtraSize);\n\n\tfor (const auto& KVP : FragmentHashToArchetypeMap)\n\t{\n\t\tfor (const TSharedPtr<FMassArchetypeData>& ArchetypePtr : KVP.Value)\n\t\t{\n\t\t\tCumulativeResourceSize.AddDedicatedSystemMemoryBytes(ArchetypePtr->GetAllocatedSize());\n\t\t}\n\t}\n}\n\nvoid FMassEntityManager::AddReferencedObjects(FReferenceCollector& Collector)\n{\n\tfor (FConstSharedStruct& Struct : ConstSharedFragments)\n\t{\n\t\tStruct.AddStructReferencedObjects(Collector);\n\t}\n\n\tfor (FSharedStruct& Struct : SharedFragments)\n\t{\n\t\tStruct.AddStructReferencedObjects(Collector);\n\t}\n \n\tconst class UScriptStruct* ScriptStruct = FMassObserverManager::StaticStruct();\n\tTWeakObjectPtr<const UScriptStruct> ScriptStructPtr{ScriptStruct};\n\tCollector.AddReferencedObjects(ScriptStructPtr, &ObserverManager);\n}\n\nvoid FMassEntityManager::Initialize()\n{\n\tFMassEntityManagerStorageInitParams InitializationParams;\n\tInitializationParams.Emplace<FMassEntityManager_InitParams_SingleThreaded>();\n\tInitialize(InitializationParams);\n}\n\nnamespace UE::Mass::Private\n{\n\tstruct FEntityStorageInitializer\n\t{\n\t\tvoid operator()(const FMassEntityManager_InitParams_SingleThreaded& Params)\n\t\t{\n\t\t\tEntityStorage->Emplace<UE::Mass::FSingleThreadedEntityStorage>();\n\t\t\tEntityStorage->Get<FSingleThreadedEntityStorage>().Initialize(Params);\n\t\t}\n\t\tvoid operator()(const FMassEntityManager_InitParams_Concurrent& Params)\n\t\t{\n#if MASS_CONCURRENT_RESERVE\n\t\t\tEntityStorage->Emplace<UE::Mass::FConcurrentEntityStorage>();\n\t\t\tEntityStorage->Get<UE::Mass::FConcurrentEntityStorage>().Initialize(Params);\n#else\n\t\t\tcheckf(false, TEXT(\"Mass does not support this storage backend\"));\n#endif\n\t\t}\n\t\t\n\t\tFMassEntityManager::FEntityStorageContainerType* EntityStorage = nullptr;\n\t};\n}\n\nvoid FMassEntityManager::Initialize(const FMassEntityManagerStorageInitParams& InitializationParams)\n{\n\tif (bInitialized)\n\t{\n\t\tUE_LOG(LogMass, Log, TEXT(\"Calling %hs on already initialized entity manager owned by %s\")\n\t\t\t, __FUNCTION__, *GetNameSafe(Owner.Get()));\n\t\treturn;\n\t}\n\n\tVisit(UE::Mass::Private::FEntityStorageInitializer{&EntityStorage}, InitializationParams);\n\n\tfor (TSharedPtr<FMassCommandBuffer>& CommandBuffer : DeferredCommandBuffers)\n\t{\n\t\tCommandBuffer = MakeShareable(new FMassCommandBuffer());\n\t}\n\n\t// if we get forked we need to update the command buffer's CurrentThreadID\n\tif (FForkProcessHelper::IsForkRequested())\n\t{\n\t\tOnPostForkHandle = FCoreDelegates::OnPostFork.AddSP(AsShared(), &FMassEntityManager::OnPostFork);\n\t}\n\n\t// creating these bitset instances to populate respective bitset types' StructTrackers\n\tFMassFragmentBitSet Fragments;\n\tFMassTagBitSet Tags;\n\tFMassChunkFragmentBitSet ChunkFragments;\n\tFMassSharedFragmentBitSet LocalSharedFragments;\n\n\tfor (TObjectIterator<UScriptStruct> StructIt; StructIt; ++StructIt)\n\t{\n\t\tif (StructIt->IsChildOf(FMassFragment::StaticStruct()))\n\t\t{\n\t\t\tif (*StructIt != FMassFragment::StaticStruct())\n\t\t\t{\n\t\t\t\tFragments.Add(**StructIt);\n\t\t\t}\n\t\t}\n\t\telse if (StructIt->IsChildOf(FMassTag::StaticStruct()))\n\t\t{\n\t\t\tif (*StructIt != FMassTag::StaticStruct())\n\t\t\t{\n\t\t\t\tTags.Add(**StructIt);\n\t\t\t}\n\t\t}\n\t\telse if (StructIt->IsChildOf(FMassChunkFragment::StaticStruct()))\n\t\t{\n\t\t\tif (*StructIt != FMassChunkFragment::StaticStruct())\n\t\t\t{\n\t\t\t\tChunkFragments.Add(**StructIt);\n\t\t\t}\n\t\t}\n\t\telse if (StructIt->IsChildOf(FMassSharedFragment::StaticStruct()))\n\t\t{\n\t\t\tif (*StructIt != FMassSharedFragment::StaticStruct())\n\t\t\t{\n\t\t\t\tLocalSharedFragments.Add(**StructIt);\n\t\t\t}\n\t\t}\n\t}\n#if WITH_MASSENTITY_DEBUG\n\tRequirementAccessDetector.Initialize();\n\tFMassDebugger::RegisterEntityManager(*this);\n#endif // WITH_MASSENTITY_DEBUG\n\n\tbInitialized = true;\n\tbFirstCommandFlush = true;\n}\n\nvoid FMassEntityManager::PostInitialize()\n{\n\tensure(bInitialized);\n\t// this needs to be done after all the subsystems have been initialized since some processors might want to access\n\t// them during processors' initialization\n\tObserverManager.Initialize();\n}\n\nvoid FMassEntityManager::Deinitialize()\n{\n\tif (bInitialized)\n\t{\n\t\tFCoreDelegates::OnPostFork.Remove(OnPostForkHandle);\n\n\t\t// closing down so no point in actually flushing commands, but need to clean them up to avoid warnings on destruction\n\t\tfor (TSharedPtr<FMassCommandBuffer>& CommandBuffer : DeferredCommandBuffers)\n\t\t{\n\t\t\tif (CommandBuffer)\n\t\t\t{\n\t\t\t\tCommandBuffer->CleanUp();\n\t\t\t}\n\t\t}\n\n#if WITH_MASSENTITY_DEBUG\n\t\tFMassDebugger::UnregisterEntityManager(*this);\n#endif // WITH_MASSENTITY_DEBUG\n\n\t\tEntityStorage.Emplace<FEmptyVariantState>();\n\n\t\tObserverManager.DeInitialize();\n\t\t\n\t\tbInitialized = false;\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogMass, Log, TEXT(\"Calling %hs on already deinitialized entity manager owned by %s\")\n\t\t\t, __FUNCTION__, *GetNameSafe(Owner.Get()));\n\t}\n}\n\nvoid FMassEntityManager::OnPostFork(EForkProcessRole Role)\n{\n\tif (Role == EForkProcessRole::Child)\n\t{\n\t\tfor (TSharedPtr<FMassCommandBuffer>& CommandBuffer : DeferredCommandBuffers)\n\t\t{\n\t\t\tif (CommandBuffer)\n\t\t\t{\n\t\t\t\tCommandBuffer->ForceUpdateCurrentThreadID();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCommandBuffer = MakeShareable(new FMassCommandBuffer());\n\t\t\t}\n\t\t}\n\n\t\tif (TSharedPtr<FEntityCreationContext> ActiveContext = ActiveCreationContext.Pin())\n\t\t{\n\t\t\tActiveContext->ForceUpdateCurrentThreadID();\n\t\t}\n\t}\n}\n\nFMassArchetypeHandle FMassEntityManager::CreateArchetype(TConstArrayView<const UScriptStruct*> FragmentsAndTagsList, const FMassArchetypeCreationParams& CreationParams)\n{\n\tFMassArchetypeCompositionDescriptor Composition;\n\tInternalAppendFragmentsAndTagsToArchetypeCompositionDescriptor(Composition, FragmentsAndTagsList);\n\treturn CreateArchetype(Composition, CreationParams);\n}\n\nFMassArchetypeHandle FMassEntityManager::CreateArchetype(FMassArchetypeHandle SourceArchetype, TConstArrayView<const UScriptStruct*> FragmentsAndTagsList)\n{\n\tconst FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(SourceArchetype); \n\treturn CreateArchetype(SourceArchetype, FragmentsAndTagsList, FMassArchetypeCreationParams(ArchetypeData));\n}\n\nFMassArchetypeHandle FMassEntityManager::CreateArchetype(FMassArchetypeHandle SourceArchetype,\n\tTConstArrayView<const UScriptStruct*> FragmentsAndTagsList, const FMassArchetypeCreationParams& CreationParams)\n{\n\tconst FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(SourceArchetype);\n\tFMassArchetypeCompositionDescriptor Composition = ArchetypeData.GetCompositionDescriptor();\n\tInternalAppendFragmentsAndTagsToArchetypeCompositionDescriptor(Composition, FragmentsAndTagsList);\n\treturn CreateArchetype(Composition, CreationParams);\n}\n\nFMassArchetypeHandle FMassEntityManager::CreateArchetype(const TSharedPtr<FMassArchetypeData>& SourceArchetype, const FMassFragmentBitSet& AddedFragments)\n{\n\treturn CreateArchetype(SourceArchetype, AddedFragments, FMassArchetypeCreationParams(*SourceArchetype));\n}\n\nFMassArchetypeHandle FMassEntityManager::CreateArchetype(const TSharedPtr<FMassArchetypeData>& SourceArchetype, const FMassFragmentBitSet& AddedFragments, const FMassArchetypeCreationParams& CreationParams)\n{\n\tcheck(SourceArchetype.IsValid());\n\tcheckf(AddedFragments.IsEmpty() == false, TEXT(\"%hs Adding an empty fragment list to an archetype is not supported.\"), __FUNCTION__);\n\n\tconst FMassArchetypeCompositionDescriptor Composition(AddedFragments + SourceArchetype->GetFragmentBitSet()\n\t\t, SourceArchetype->GetTagBitSet()\n\t\t, SourceArchetype->GetChunkFragmentBitSet()\n\t\t, SourceArchetype->GetSharedFragmentBitSet()\n\t\t, SourceArchetype->GetConstSharedFragmentBitSet());\n\treturn CreateArchetype(Composition, CreationParams);\n}\n\nFMassArchetypeHandle FMassEntityManager::GetOrCreateSuitableArchetype(const FMassArchetypeHandle& ArchetypeHandle\n\t, const FMassSharedFragmentBitSet& SharedFragmentBitSet\n\t, const FMassConstSharedFragmentBitSet& ConstSharedFragmentBitSet\n\t, const FMassArchetypeCreationParams& CreationParams)\n{\n\tconst FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);\n\tif (SharedFragmentBitSet != ArchetypeData.GetSharedFragmentBitSet()\n\t\t|| ConstSharedFragmentBitSet != ArchetypeData.GetConstSharedFragmentBitSet())\n\t{\n\t\tFMassArchetypeCompositionDescriptor NewDescriptor = ArchetypeData.GetCompositionDescriptor();\n\t\tNewDescriptor.SharedFragments = SharedFragmentBitSet;\n\t\tNewDescriptor.ConstSharedFragments = ConstSharedFragmentBitSet;\n\t\treturn CreateArchetype(NewDescriptor);\n\t}\n\treturn ArchetypeHandle;\n}\n\nFMassArchetypeHandle FMassEntityManager::CreateArchetype(const FMassArchetypeCompositionDescriptor& Composition, const FMassArchetypeCreationParams& CreationParams)\n{\n\tconst uint32 TypeHash = Composition.CalculateHash();\n\n\tTArray<TSharedPtr<FMassArchetypeData>>& HashRow = FragmentHashToArchetypeMap.FindOrAdd(TypeHash);\n\n\tTSharedPtr<FMassArchetypeData> ArchetypeDataPtr;\n\tfor (const TSharedPtr<FMassArchetypeData>& Ptr : HashRow)\n\t{\n\t\tif (Ptr->IsEquivalent(Composition))\n\t\t{\n#if WITH_MASSENTITY_DEBUG\n\t\t\t// Keep track of all names for this archetype.\n\t\t\tif (!CreationParams.DebugName.IsNone())\n\t\t\t{\n\t\t\t\tPtr->AddUniqueDebugName(CreationParams.DebugName);\n\t\t\t}\n#endif // WITH_MASSENTITY_DEBUG\n\t\t\tif (CreationParams.ChunkMemorySize > 0 && CreationParams.ChunkMemorySize != Ptr->GetChunkAllocSize())\n\t\t\t{\n\t\t\t\tUE_LOG(LogMass, Warning, TEXT(\"Reusing existing Archetype, but the requested ChunkMemorySize is different. Requested %d, existing: %llu\")\n\t\t\t\t\t, CreationParams.ChunkMemorySize, Ptr->GetChunkAllocSize());\n\t\t\t}\n\t\t\tArchetypeDataPtr = Ptr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ArchetypeDataPtr.IsValid())\n\t{\n\t\t// Important to pre-increment the version as the queries will use this value to do incremental updates\n\t\t++ArchetypeDataVersion;\n\n\t\t// Create a new archetype\n\t\tFMassArchetypeData* NewArchetype = new FMassArchetypeData(CreationParams);\n\t\tNewArchetype->Initialize(Composition, ArchetypeDataVersion);\n\t\tArchetypeDataPtr = HashRow.Add_GetRef(MakeShareable(NewArchetype));\n\t\tAllArchetypes.Add(ArchetypeDataPtr);\n\t\tensure(AllArchetypes.Num() == ArchetypeDataVersion);\n\n\t\tfor (const FMassArchetypeFragmentConfig& FragmentConfig : NewArchetype->GetFragmentConfigs())\n\t\t{\n\t\t\tcheckSlow(FragmentConfig.FragmentType)\n\t\t\tFragmentTypeToArchetypeMap.FindOrAdd(FragmentConfig.FragmentType).Add(ArchetypeDataPtr);\n\t\t}\n\n\t\tOnNewArchetypeEvent.Broadcast(FMassArchetypeHandle(ArchetypeDataPtr));\n\t}\n\n\treturn FMassArchetypeHelper::ArchetypeHandleFromData(ArchetypeDataPtr);\n}\n\nFMassArchetypeHandle FMassEntityManager::InternalCreateSimilarArchetype(const TSharedPtr<FMassArchetypeData>& SourceArchetype, const FMassTagBitSet& OverrideTags)\n{\n\tcheckSlow(SourceArchetype.IsValid());\n\tconst FMassArchetypeData& SourceArchetypeRef = *SourceArchetype.Get();\n\tFMassArchetypeCompositionDescriptor NewComposition(SourceArchetypeRef.GetFragmentBitSet()\n\t\t, OverrideTags\n\t\t, SourceArchetypeRef.GetChunkFragmentBitSet()\n\t\t, SourceArchetypeRef.GetSharedFragmentBitSet()\n\t\t, SourceArchetypeRef.GetConstSharedFragmentBitSet());\n\treturn InternalCreateSimilarArchetype(SourceArchetypeRef, MoveTemp(NewComposition));\n}\n\nFMassArchetypeHandle FMassEntityManager::InternalCreateSimilarArchetype(const TSharedPtr<FMassArchetypeData>& SourceArchetype, const FMassFragmentBitSet& OverrideFragments)\n{\n\tcheckSlow(SourceArchetype.IsValid());\n\tconst FMassArchetypeData& SourceArchetypeRef = *SourceArchetype.Get();\n\tFMassArchetypeCompositionDescriptor NewComposition(OverrideFragments\n\t\t, SourceArchetypeRef.GetTagBitSet()\n\t\t, SourceArchetypeRef.GetChunkFragmentBitSet()\n\t\t, SourceArchetypeRef.GetSharedFragmentBitSet()\n\t\t, SourceArchetypeRef.GetConstSharedFragmentBitSet());\n\treturn InternalCreateSimilarArchetype(SourceArchetypeRef, MoveTemp(NewComposition));\n}\n\nFMassArchetypeHandle FMassEntityManager::InternalCreateSimilarArchetype(const FMassArchetypeData& SourceArchetypeRef, FMassArchetypeCompositionDescriptor&& NewComposition)\n{\n\tconst uint32 TypeHash = NewComposition.CalculateHash();\n\n\tTArray<TSharedPtr<FMassArchetypeData>>& HashRow = FragmentHashToArchetypeMap.FindOrAdd(TypeHash);\n\n\tTSharedPtr<FMassArchetypeData> ArchetypeDataPtr;\n\tfor (const TSharedPtr<FMassArchetypeData>& Ptr : HashRow)\n\t{\n\t\tif (Ptr->IsEquivalent(NewComposition))\n\t\t{\n\t\t\tArchetypeDataPtr = Ptr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ArchetypeDataPtr.IsValid())\n\t{\n\t\t// Important to pre-increment the version as the queries will use this value to do incremental updates\n\t\t++ArchetypeDataVersion;\n\n\t\t// Create a new archetype\n\t\tFMassArchetypeData* NewArchetype = new FMassArchetypeData(FMassArchetypeCreationParams(SourceArchetypeRef));\n\t\tNewArchetype->InitializeWithSimilar(SourceArchetypeRef, MoveTemp(NewComposition), ArchetypeDataVersion);\n\t\tNewArchetype->CopyDebugNamesFrom(SourceArchetypeRef);\n\n\t\tArchetypeDataPtr = HashRow.Add_GetRef(MakeShareable(NewArchetype));\n\t\tAllArchetypes.Add(ArchetypeDataPtr);\n\t\tensure(AllArchetypes.Num() == ArchetypeDataVersion);\n\n\t\tfor (const FMassArchetypeFragmentConfig& FragmentConfig : NewArchetype->GetFragmentConfigs())\n\t\t{\n\t\t\tcheckSlow(FragmentConfig.FragmentType)\n\t\t\tFragmentTypeToArchetypeMap.FindOrAdd(FragmentConfig.FragmentType).Add(ArchetypeDataPtr);\n\t\t}\n\n\t\tOnNewArchetypeEvent.Broadcast(FMassArchetypeHandle(ArchetypeDataPtr));\n\t}\n\n\treturn FMassArchetypeHelper::ArchetypeHandleFromData(ArchetypeDataPtr);\n}\n\nvoid FMassEntityManager::InternalAppendFragmentsAndTagsToArchetypeCompositionDescriptor(\n\tFMassArchetypeCompositionDescriptor& InOutComposition, TConstArrayView<const UScriptStruct*> FragmentsAndTagsList) const\n{\n\tfor (const UScriptStruct* Type : FragmentsAndTagsList)\n\t{\n\t\tif (Type->IsChildOf(FMassFragment::StaticStruct()))\n\t\t{\n\t\t\tInOutComposition.Fragments.Add(*Type);\n\t\t}\n\t\telse if (Type->IsChildOf(FMassTag::StaticStruct()))\n\t\t{\n\t\t\tInOutComposition.Tags.Add(*Type);\n\t\t}\n\t\telse if (Type->IsChildOf(FMassChunkFragment::StaticStruct()))\n\t\t{\n\t\t\tInOutComposition.ChunkFragments.Add(*Type);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUE_LOG(LogMass, Warning, TEXT(\"%hs: %s is not a valid fragment nor tag type. Ignoring.\")\n\t\t\t\t, __FUNCTION__, *GetNameSafe(Type));\n\t\t}\n\t}\n}\n\nFMassArchetypeHandle FMassEntityManager::GetArchetypeForEntity(FMassEntityHandle Entity) const\n{\n\tif (IsEntityValid(Entity))\n\t{\n\t\treturn FMassArchetypeHelper::ArchetypeHandleFromData(GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index));\n\t}\n\treturn FMassArchetypeHandle();\n}\n\nFMassArchetypeHandle FMassEntityManager::GetArchetypeForEntityUnsafe(FMassEntityHandle Entity) const\n{\n\tcheck(GetEntityStorageInterface().IsValidIndex(Entity.Index));\n\treturn FMassArchetypeHelper::ArchetypeHandleFromData(GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index));\n}\n\nvoid FMassEntityManager::ForEachArchetypeFragmentType(const FMassArchetypeHandle& ArchetypeHandle, TFunction< void(const UScriptStruct* /*FragmentType*/)> Function)\n{\n\tconst FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);\n\tArchetypeData.ForEachFragmentType(Function);\n}\n\nvoid FMassEntityManager::DoEntityCompaction(const double TimeAllowed)\n{\n\tint32 TotalEntitiesMoved = 0;\n\tconst double TimeAllowedEnd = FPlatformTime::Seconds() + TimeAllowed;\n\n\tbool bReachedTimeLimit = false;\n\tfor (const auto& KVP : FragmentHashToArchetypeMap)\n\t{\n\t\tfor (const TSharedPtr<FMassArchetypeData>& ArchetypePtr : KVP.Value)\n\t\t{\n\t\t\tconst double TimeAllowedLeft = TimeAllowedEnd - FPlatformTime::Seconds();\n\t\t\tbReachedTimeLimit = TimeAllowedLeft <= 0.0;\n\t\t\tif (bReachedTimeLimit)\n\t\t\t{\n \t\t\t\tbreak;\n\t\t\t}\n\t\t\tTotalEntitiesMoved += ArchetypePtr->CompactEntities(TimeAllowedLeft);\n\t\t}\n\t\tif (bReachedTimeLimit)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tUE_CVLOG(TotalEntitiesMoved, GetOwner(), LogMass, Verbose, TEXT(\"Entity Compaction: moved %d entities\"), TotalEntitiesMoved);\n}\n\nFMassEntityHandle FMassEntityManager::CreateEntity(const FMassArchetypeHandle& ArchetypeHandle, const FMassArchetypeSharedFragmentValues& SharedFragmentValues)\n{\n\tcheckf(IsProcessing() == false, TEXT(\"Synchronous API function %hs called during mass processing. Use asynchronous API instead.\"), __FUNCTION__);\n\tcheck(ArchetypeHandle.IsValid());\n\n\tconst FMassEntityHandle Entity = ReserveEntity();\n\tInternalBuildEntity(Entity\n\t\t, GetOrCreateSuitableArchetype(ArchetypeHandle, SharedFragmentValues.GetSharedFragmentBitSet(), SharedFragmentValues.GetConstSharedFragmentBitSet())\n\t\t, SharedFragmentValues);\n\n\treturn Entity;\n}\n\nFMassEntityHandle FMassEntityManager::CreateEntity(TConstArrayView<FInstancedStruct> FragmentInstanceList, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, const FMassArchetypeCreationParams& CreationParams)\n{\n\tcheckf(IsProcessing() == false, TEXT(\"Synchronous API function %hs called during mass processing. Use asynchronous API instead.\"), __FUNCTION__);\n\tcheck(FragmentInstanceList.Num() > 0);\n\n\tconst FMassArchetypeHandle& ArchetypeHandle = CreateArchetype(FMassArchetypeCompositionDescriptor(FragmentInstanceList,\n\t\tFMassTagBitSet(), FMassChunkFragmentBitSet(), FMassSharedFragmentBitSet(), FMassConstSharedFragmentBitSet()), CreationParams);\n\tcheck(ArchetypeHandle.IsValid());\n\n\tconst FMassEntityHandle Entity = ReserveEntity();\n\n\t// Using a creation context to prevent InternalBuildEntity from notifying observers before we set fragments data\n\tconst TSharedRef<FEntityCreationContext> CreationContext = GetOrMakeCreationContext();\n\tCreationContext->AppendEntities({Entity});\n\n\tInternalBuildEntity(Entity, ArchetypeHandle, SharedFragmentValues);\n\n\tFMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);\n\tcheck(CurrentArchetype);\n\tCurrentArchetype->SetFragmentsData(Entity, FragmentInstanceList);\n\n\treturn Entity;\n}\n\nFMassEntityHandle FMassEntityManager::ReserveEntity()\n{\n\tFMassEntityHandle Result = GetEntityStorageInterface().AcquireOne();\n\n\treturn Result;\n}\n\nvoid FMassEntityManager::ReleaseReservedEntity(FMassEntityHandle Entity)\n{\n\tcheckf(!IsEntityBuilt(Entity), TEXT(\"Entity is already built, use DestroyEntity() instead\"));\n\n\tInternalReleaseEntity(Entity);\n}\n\nvoid FMassEntityManager::BuildEntity(FMassEntityHandle Entity, const FMassArchetypeHandle& ArchetypeHandle, const FMassArchetypeSharedFragmentValues& SharedFragmentValues)\n{\n\tcheckf(IsProcessing() == false, TEXT(\"Synchronous API function %hs called during mass processing. Use asynchronous API instead.\"), __FUNCTION__);\n\tcheckf(!IsEntityBuilt(Entity), TEXT(\"Expecting an entity that is not already built\"));\n\tcheck(ArchetypeHandle.IsValid());\n\n\tInternalBuildEntity(Entity, ArchetypeHandle, SharedFragmentValues);\n}\n\nvoid FMassEntityManager::BuildEntity(FMassEntityHandle Entity, TConstArrayView<FInstancedStruct> FragmentInstanceList, const FMassArchetypeSharedFragmentValues& SharedFragmentValues)\n{\n\tcheckf(IsProcessing() == false, TEXT(\"Synchronous API function %hs called during mass processing. Use asynchronous API instead.\"), __FUNCTION__);\n\tcheck(FragmentInstanceList.Num() > 0);\n\tcheckf(!IsEntityBuilt(Entity), TEXT(\"Expecting an entity that is not already built\"));\n\n\tcheckf(SharedFragmentValues.IsSorted(), TEXT(\"Expecting shared fragment values to be previously sorted\"));\n\tFMassArchetypeCompositionDescriptor Composition(FragmentInstanceList, FMassTagBitSet(), FMassChunkFragmentBitSet(), FMassSharedFragmentBitSet(), FMassConstSharedFragmentBitSet());\n\tfor (const FConstSharedStruct& SharedFragment : SharedFragmentValues.GetConstSharedFragments())\n\t{\n\t\tComposition.ConstSharedFragments.Add(*SharedFragment.GetScriptStruct());\n\t}\n\tfor (const FSharedStruct& SharedFragment : SharedFragmentValues.GetSharedFragments())\n\t{\n\t\tComposition.SharedFragments.Add(*SharedFragment.GetScriptStruct());\n\t}\n\n\tconst FMassArchetypeHandle& ArchetypeHandle = CreateArchetype(Composition);\n\tcheck(ArchetypeHandle.IsValid());\n\n\t// Using a creation context to prevent InternalBuildEntity from notifying observers before we set fragments data\n\tconst TSharedRef<FEntityCreationContext> CreationContext = GetOrMakeCreationContext();\n\tCreationContext->AppendEntities({Entity});\n\n\tInternalBuildEntity(Entity, ArchetypeHandle, SharedFragmentValues);\n\n\tFMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);\n\tcheck(CurrentArchetype);\n\tCurrentArchetype->SetFragmentsData(Entity, FragmentInstanceList);\n}\n\nTConstArrayView<FMassEntityHandle> FMassEntityManager::BatchReserveEntities(const int32 Count, TArray<FMassEntityHandle>& InOutEntities)\n{\n\tconst int32 Index = InOutEntities.Num();\n\tconst int32 NumAdded = GetEntityStorageInterface().Acquire(Count, InOutEntities);\n\tensureMsgf(NumAdded == Count, TEXT(\"Failed to reserve %d entities, was able to only reserve %d\"), Count, NumAdded);\n\n\treturn MakeArrayView(InOutEntities.GetData() + Index, NumAdded);\n}\n\nint32 FMassEntityManager::BatchReserveEntities(TArrayView<FMassEntityHandle> InOutEntities)\n{\n\treturn GetEntityStorageInterface().Acquire(InOutEntities);\n}\n\nTSharedRef<FMassEntityManager::FEntityCreationContext> FMassEntityManager::BatchBuildEntities(const FMassArchetypeEntityCollectionWithPayload& EncodedEntitiesWithPayload\n\t, const FMassFragmentBitSet& FragmentsAffected, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, const FMassArchetypeCreationParams& CreationParams)\n{\n\tcheckf(IsProcessing() == false, TEXT(\"Synchronous API function %hs called during mass processing. Use asynchronous API instead.\"), __FUNCTION__);\n\tcheck(SharedFragmentValues.IsSorted());\n\n\tFMassArchetypeCompositionDescriptor Composition(FragmentsAffected, FMassTagBitSet(), FMassChunkFragmentBitSet(), FMassSharedFragmentBitSet(), FMassConstSharedFragmentBitSet());\n\tfor (const FConstSharedStruct& SharedFragment : SharedFragmentValues.GetConstSharedFragments())\n\t{\n\t\tComposition.SharedFragments.Add(*SharedFragment.GetScriptStruct());\n\t}\n\tfor (const FSharedStruct& SharedFragment : SharedFragmentValues.GetSharedFragments())\n\t{\n\t\tComposition.SharedFragments.Add(*SharedFragment.GetScriptStruct());\n\t}\n\n\treturn BatchBuildEntities(EncodedEntitiesWithPayload, MoveTemp(Composition), SharedFragmentValues, CreationParams);\n}\n\nTSharedRef<FMassEntityManager::FEntityCreationContext> FMassEntityManager::BatchBuildEntities(const FMassArchetypeEntityCollectionWithPayload& EncodedEntitiesWithPayload\n\t, FMassArchetypeCompositionDescriptor&& Composition\n\t, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, const FMassArchetypeCreationParams& CreationParams)\n{\n\tcheckf(IsProcessing() == false, TEXT(\"Synchronous API function %hs called during mass processing. Use asynchronous API instead.\"), __FUNCTION__);\n\n\tTRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchBuildEntities);\n\n\tFMassArchetypeEntityCollection::FEntityRangeArray TargetArchetypeEntityRanges;\n\n\t// \"built\" entities case, this is verified during FMassArchetypeEntityCollectionWithPayload construction\n\tFMassArchetypeHandle TargetArchetypeHandle = CreateArchetype(Composition, CreationParams);\n\tcheck(TargetArchetypeHandle.IsValid());\n\n\t// there are some extra steps in creating EncodedEntities from the original given entity handles and then back\n\t// to handles here, but this way we're consistent in how stuff is handled, and there are some slight benefits \n\t// to having entities ordered by their index (like accessing the Entities data below).\n\tTArray<FMassEntityHandle> EntityHandles;\n\tUE::Mass::Private::ConvertArchetypelessSubchunksIntoEntityHandles(EncodedEntitiesWithPayload.GetEntityCollection().GetRanges(), EntityHandles);\n\n\t// since the handles encoded via FMassArchetypeEntityCollectionWithPayload miss the SerialNumber we need to update it\n\t// before passing over the new archetype. Thankfully we need to iterate over all the entity handles anyway\n\t// to update the manager's information on these entities (stored in FMassEntityManager::Entities)\n\tfor (FMassEntityHandle& Entity : EntityHandles)\n\t{\n\t\tcheck(GetEntityStorageInterface().IsValidIndex(Entity.Index));\n\n\t\tconst UE::Mass::IEntityStorageInterface::EEntityState EntityState = GetEntityStorageInterface().GetEntityState(Entity.Index);\n\t\tcheckf(EntityState == UE::Mass::IEntityStorageInterface::EEntityState::Reserved, TEXT(\"Trying to build entities that are not reserved. Check all handles are reserved or consider using BatchCreateEntities\"));\n\n\t\tconst int32 SerialNumber = GetEntityStorageInterface().GetSerialNumber(Entity.Index);\n\t\tEntity.SerialNumber = SerialNumber;\n\t\t\n\t\tGetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, TargetArchetypeHandle.DataPtr);\n\t}\n\n\tTargetArchetypeHandle.DataPtr->BatchAddEntities(EntityHandles, SharedFragmentValues, TargetArchetypeEntityRanges);\n\n\tif (EncodedEntitiesWithPayload.GetPayload().IsEmpty() == false)\n\t{\n\t\t// at this point all the entities are in the target archetype, we can set the values\n\t\t// note that even though the \"subchunk\" information could have changed the order of entities is the same and \n\t\t// corresponds to the order in FMassArchetypeEntityCollectionWithPayload's payload\n\t\tTargetArchetypeHandle.DataPtr->BatchSetFragmentValues(TargetArchetypeEntityRanges, EncodedEntitiesWithPayload.GetPayload());\n\t}\n\n\t// With this call we're either creating a fresh context populated with EntityHandles, or it will append \n\t// EntityHandles to active context.\n\t// Not creating the context sooner since we want to reuse TargetArchetypeEntityRanges by moving it over to the context.\n\t// Note that we can afford to create this context so late since all previous operations were on the archetype level\n\t// and as such won't cause observers triggering (which usually is prevented by context's existence), and that we \n\t// strongly assume the all entity creation/building (not to be mistaken with \"reserving\") takes place in a single thread\n\t// @todo add checks/ensures enforcing the assumption mentioned above.\n\treturn GetOrMakeCreationContext(EntityHandles\n\t\t, FMassArchetypeEntityCollection(TargetArchetypeHandle, MoveTemp(TargetArchetypeEntityRanges)));\n}\n\nTSharedRef<FMassEntityManager::FEntityCreationContext> FMassEntityManager::BatchCreateReservedEntities(const FMassArchetypeHandle& ArchetypeHandle\n\t, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, TConstArrayView<FMassEntityHandle> ReservedEntities)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchCreateReservedEntities);\n\n\tcheckf(IsProcessing() == false, TEXT(\"Synchronous API function %hs called during mass processing. Use asynchronous API instead.\"), __FUNCTION__);\n\tcheckf(!ReservedEntities.IsEmpty(), TEXT(\"No reserved entities given to batch create.\"));\n\n\treturn InternalBatchCreateReservedEntities(\n\t\tGetOrCreateSuitableArchetype(ArchetypeHandle, SharedFragmentValues.GetSharedFragmentBitSet(), SharedFragmentValues.GetConstSharedFragmentBitSet())\n\t\t, SharedFragmentValues, ReservedEntities);\n}\n\nTSharedRef<FMassEntityManager::FEntityCreationContext> FMassEntityManager::BatchCreateEntities(const FMassArchetypeHandle& ArchetypeHandle\n\t, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, const int32 Count, TArray<FMassEntityHandle>& InOutEntities)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchCreateEntities);\n\n\tcheckf(IsProcessing() == false, TEXT(\"Synchronous API function %hs called during mass processing. Use asynchronous API instead.\"), __FUNCTION__);\n\ttestableCheckfReturn(ArchetypeHandle.IsValid(), return GetOrMakeCreationContext()\n\t\t, TEXT(\"%hs expecting a valid ArchetypeHandle\"), __FUNCTION__);\n\n\tTConstArrayView<FMassEntityHandle> ReservedEntities = BatchReserveEntities(Count, InOutEntities);\n\t\n\treturn InternalBatchCreateReservedEntities(\n\t\tGetOrCreateSuitableArchetype(ArchetypeHandle, SharedFragmentValues.GetSharedFragmentBitSet(), SharedFragmentValues.GetConstSharedFragmentBitSet())\n\t\t, SharedFragmentValues, ReservedEntities);\n}\n\nTSharedRef<FMassEntityManager::FEntityCreationContext> FMassEntityManager::InternalBatchCreateReservedEntities(const FMassArchetypeHandle& ArchetypeHandle\n\t, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, TConstArrayView<FMassEntityHandle> ReservedEntities)\n{\n\t// Functions calling into this one are required to verify that the archetype handle is valid\n\tFMassArchetypeData* ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandle(ArchetypeHandle);\n\tcheckf(ArchetypeData, TEXT(\"Functions calling into this one are required to verify that the archetype handle is valid\"));\n\n\tfor (FMassEntityHandle Entity : ReservedEntities)\n\t{\n\t\tcheck(IsEntityValid(Entity));\n\t\tconst UE::Mass::IEntityStorageInterface::EEntityState EntityState = GetEntityStorageInterface().GetEntityState(Entity.Index);\n\t\tcheckf(EntityState == UE::Mass::IEntityStorageInterface::EEntityState::Reserved, TEXT(\"Trying to build entities that are not reserved. Check all handles are reserved or consider using BatchCreateEntities\"));\n\t\t\n\t\tGetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, ArchetypeHandle.DataPtr);\n\t}\n\n\tFMassArchetypeEntityCollection::FEntityRangeArray TargetArchetypeEntityRanges;\n\tArchetypeData->BatchAddEntities(ReservedEntities, SharedFragmentValues, TargetArchetypeEntityRanges);\n\n\treturn GetOrMakeCreationContext(ReservedEntities, FMassArchetypeEntityCollection(ArchetypeHandle, MoveTemp(TargetArchetypeEntityRanges)));\n}\n\nvoid FMassEntityManager::DestroyEntity(FMassEntityHandle Entity)\n{\n\tcheckf(IsProcessing() == false, TEXT(\"Synchronous API function %hs called during mass processing. Use asynchronous API instead.\"), __FUNCTION__);\n\t\n\tCheckIfEntityIsActive(Entity);\n\n\tFMassArchetypeData* Archetype = GetEntityStorageInterface().GetArchetype(Entity.Index);\n\n\tif (Archetype)\n\t{\n\t\tObserverManager.OnPreEntityDestroyed(Archetype->GetCompositionDescriptor(), Entity);\n\t\tArchetype->RemoveEntity(Entity);\n\t}\n\n\tInternalReleaseEntity(Entity);\n}\n\nvoid FMassEntityManager::BatchDestroyEntities(TConstArrayView<FMassEntityHandle> InEntities)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchDestroyEntities);\n\n\tcheckf(IsProcessing() == false, TEXT(\"Synchronous API function %hs called during mass processing. Use asynchronous API instead.\"), __FUNCTION__);\n\tcheckf(IsDuringEntityCreation() == false, TEXT(\"%hs: Trying to destroy entities while entity creation is under way. This operation is not supported.\"), __FUNCTION__);\n\n\tfor (const FMassEntityHandle Entity : InEntities)\n\t{\n\t\tif (GetEntityStorageInterface().IsValidIndex(Entity.Index) == false)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst int32 SerialNumber = GetEntityStorageInterface().GetSerialNumber(Entity.Index);\n\t\tif (SerialNumber != Entity.SerialNumber)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (FMassArchetypeData* Archetype = GetEntityStorageInterface().GetArchetype(Entity.Index))\n\t\t{\n\t\t\tObserverManager.OnPreEntityDestroyed(Archetype->GetCompositionDescriptor(), Entity);\n\t\t\tArchetype->RemoveEntity(Entity);\n\t\t}\n\t\t// else it's a \"reserved\" entity so it has not been assigned to an archetype yet, no archetype nor observers to notify\n\t}\n\n\tGetEntityStorageInterface().Release(InEntities);\n}\n\nvoid FMassEntityManager::BatchDestroyEntityChunks(const FMassArchetypeEntityCollection& EntityCollection)\n{\n\tBatchDestroyEntityChunks(MakeArrayView(&EntityCollection, 1));\n}\n\nvoid FMassEntityManager::BatchDestroyEntityChunks(TConstArrayView<FMassArchetypeEntityCollection> Collections)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchDestroyEntityChunks);\n\n\tcheckf(IsProcessing() == false, TEXT(\"Synchronous API function %hs called during mass processing. Use asynchronous API instead.\"), __FUNCTION__);\n\tcheckf(IsDuringEntityCreation() == false, TEXT(\"%hs: Trying to destroy entities while entity creation is under way. This operation is not supported.\"), __FUNCTION__);\n\n\tTArray<FMassEntityHandle> EntitiesRemoved;\n\t// note that it's important to place the context instance in the same scope as the loop below that updates \n\t// FMassEntityManager.EntityData, otherwise, if there are commands flushed as part of FMassProcessingContext's \n\t// destruction the commands will work on outdated information (which might result in crashes).\n\tFMassProcessingContext ProcessingContext(*this, /*TimeDelta=*/0.0f);\n\tProcessingContext.bFlushCommandBuffer = false;\n\tProcessingContext.CommandBuffer = MakeShareable(new FMassCommandBuffer());\n\n\tfor (const FMassArchetypeEntityCollection& EntityCollection : Collections)\n\t{\n\t\tEntitiesRemoved.Reset();\n\t\tif (EntityCollection.GetArchetype().IsValid())\n\t\t{\n\t\t\tObserverManager.OnPreEntitiesDestroyed(ProcessingContext, EntityCollection);\n\n\t\t\tFMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(EntityCollection.GetArchetype());\n\t\t\tArchetypeData.BatchDestroyEntityChunks(EntityCollection.GetRanges(), EntitiesRemoved);\n\t\t\n\t\t\tGetEntityStorageInterface().Release(EntitiesRemoved);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUE::Mass::Private::ConvertArchetypelessSubchunksIntoEntityHandles(EntityCollection.GetRanges(), EntitiesRemoved);\n\t\t\tGetEntityStorageInterface().ForceRelease(EntitiesRemoved);\n\t\t}\n\t}\n}\n\nvoid FMassEntityManager::AddFragmentToEntity(FMassEntityHandle Entity, const UScriptStruct* FragmentType)\n{\n\tcheckf(FragmentType, TEXT(\"Null fragment type passed in to %hs\"), __FUNCTION__);\n\tcheckf(IsProcessing() == false, TEXT(\"Synchronous API function %hs called during mass processing. Use asynchronous API instead.\"), __FUNCTION__);\n\n\tCheckIfEntityIsActive(Entity);\n\n\tconst FMassArchetypeCompositionDescriptor Descriptor(InternalAddFragmentListToEntityChecked(Entity, FMassFragmentBitSet(*FragmentType)));\n\n\tif (IsAllowedToTriggerObservers())\n\t{\n\t\tObserverManager.OnPostCompositionAdded(Entity, Descriptor);\n\t}\n}\n\nvoid FMassEntityManager::AddFragmentToEntity(FMassEntityHandle Entity, const UScriptStruct* FragmentType, const FStructInitializationCallback& Initializer)\n{\n\tcheckf(FragmentType, TEXT(\"Null fragment type passed in to %hs\"), __FUNCTION__);\n\tcheckf(IsProcessing() == false, TEXT(\"Synchronous API function %hs called during mass processing. Use asynchronous API instead.\"), __FUNCTION__);\n\n\tCheckIfEntityIsActive(Entity);\n\n\tFMassFragmentBitSet Fragments = InternalAddFragmentListToEntityChecked(Entity, FMassFragmentBitSet(*FragmentType));\n\tFMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);\n\tcheck(CurrentArchetype);\n\tvoid* FragmentData = CurrentArchetype->GetFragmentDataForEntity(FragmentType, Entity.Index);\n\tInitializer(FragmentData, *FragmentType);\n\n\tconst FMassArchetypeCompositionDescriptor Descriptor(MoveTemp(Fragments));\n\t\n\tif (IsAllowedToTriggerObservers())\n\t{\n\t\tObserverManager.OnPostCompositionAdded(Entity, Descriptor);\n\t}\n}\n\nvoid FMassEntityManager::AddFragmentListToEntity(FMassEntityHandle Entity, TConstArrayView<const UScriptStruct*> FragmentList)\n{\n\tCheckIfEntityIsActive(Entity);\n\n\tconst FMassArchetypeCompositionDescriptor Descriptor(InternalAddFragmentListToEntityChecked(Entity, FMassFragmentBitSet(FragmentList)));\n\t\n\tif (IsAllowedToTriggerObservers())\n\t{\n\t\tObserverManager.OnPostCompositionAdded(Entity, Descriptor);\n\t}\n}\n\nvoid FMassEntityManager::AddCompositionToEntity_GetDelta(FMassEntityHandle Entity, FMassArchetypeCompositionDescriptor& InDescriptor)\n{\n\tCheckIfEntityIsActive(Entity);\n\n\tFMassArchetypeData* OldArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);\n\tcheck(OldArchetype);\n\n\tInDescriptor.Fragments -= OldArchetype->GetCompositionDescriptor().Fragments;\n\tInDescriptor.Tags -= OldArchetype->GetCompositionDescriptor().Tags;\n\n\tensureMsgf(InDescriptor.ChunkFragments.IsEmpty(), TEXT(\"Adding new chunk fragments is not supported\"));\n\n\tif (InDescriptor.IsEmpty() == false)\n\t{\n\t\tFMassArchetypeCompositionDescriptor NewDescriptor = OldArchetype->GetCompositionDescriptor();\n\t\tNewDescriptor.Fragments += InDescriptor.Fragments;\n\t\tNewDescriptor.Tags += InDescriptor.Tags;\n\n\t\tconst FMassArchetypeHandle NewArchetypeHandle = CreateArchetype(NewDescriptor, FMassArchetypeCreationParams(*OldArchetype));\n\n\t\tif (ensure(NewArchetypeHandle.DataPtr.Get() != OldArchetype))\n\t\t{\n\t\t\t// Move the entity over\n\t\t\tFMassArchetypeData& NewArchetype = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(NewArchetypeHandle);\n\t\t\tNewArchetype.CopyDebugNamesFrom(*OldArchetype);\n\t\t\tOldArchetype->MoveEntityToAnotherArchetype(Entity, NewArchetype);\n\n\t\t\tGetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);\n\n\t\t\tif (IsAllowedToTriggerObservers())\n\t\t\t{\n\t\t\t\tObserverManager.OnPostCompositionAdded(Entity, InDescriptor);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid FMassEntityManager::RemoveCompositionFromEntity(FMassEntityHandle Entity, const FMassArchetypeCompositionDescriptor& InDescriptor)\n{\n\tCheckIfEntityIsActive(Entity);\n\n\tif(InDescriptor.IsEmpty() == false)\n\t{\n\t\tFMassArchetypeData* OldArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);\n\t\tcheck(OldArchetype);\n\n\t\tFMassArchetypeCompositionDescriptor NewDescriptor = OldArchetype->GetCompositionDescriptor();\n\t\tNewDescriptor.Fragments -= InDescriptor.Fragments;\n\t\tNewDescriptor.Tags -= InDescriptor.Tags;\n\n\t\tensureMsgf(InDescriptor.ChunkFragments.IsEmpty(), TEXT(\"Removing chunk fragments is not supported\"));\n\t\tensureMsgf(InDescriptor.SharedFragments.IsEmpty(), TEXT(\"Removing shared fragments is not supported\"));\n\n\t\tif (NewDescriptor.IsEquivalent(OldArchetype->GetCompositionDescriptor()) == false)\n\t\t{\n\t\t\tensureMsgf(OldArchetype->GetCompositionDescriptor().HasAll(InDescriptor), TEXT(\"Some of the elements being removed are already missing from entity\\'s composition.\"));\n\t\t\t\n\t\t\tif (IsAllowedToTriggerObservers())\n\t\t\t{\n\t\t\t\tObserverManager.OnPreCompositionRemoved(Entity, InDescriptor);\n\t\t\t}\n\n\t\t\tconst FMassArchetypeHandle NewArchetypeHandle = CreateArchetype(NewDescriptor, FMassArchetypeCreationParams(*OldArchetype));\n\n\t\t\tif (ensure(NewArchetypeHandle.DataPtr.Get() != OldArchetype))\n\t\t\t{\n\t\t\t\t// Move the entity over\n\t\t\t\tFMassArchetypeData& NewArchetype = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(NewArchetypeHandle);\n\t\t\t\tNewArchetype.CopyDebugNamesFrom(*OldArchetype);\n\t\t\t\tOldArchetype->MoveEntityToAnotherArchetype(Entity, NewArchetype);\n\t\t\t\tGetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst FMassArchetypeCompositionDescriptor& FMassEntityManager::GetArchetypeComposition(const FMassArchetypeHandle& ArchetypeHandle) const\n{\n\tconst FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);\n\treturn ArchetypeData.GetCompositionDescriptor();\n}\n\nvoid FMassEntityManager::InternalBuildEntity(FMassEntityHandle Entity, const FMassArchetypeHandle& ArchetypeHandle, const FMassArchetypeSharedFragmentValues& SharedFragmentValues)\n{\n\tconst TSharedPtr<FMassArchetypeData>& NewArchetype = ArchetypeHandle.DataPtr;\n\tGetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, ArchetypeHandle.DataPtr);\n\tNewArchetype->AddEntity(Entity, SharedFragmentValues);\n\n\tif (IsAllowedToTriggerObservers())\n\t{\n\t\tObserverManager.OnPostCompositionAdded(Entity, NewArchetype->GetCompositionDescriptor());\n\t}\n}\n\nvoid FMassEntityManager::InternalReleaseEntity(FMassEntityHandle Entity)\n{\n\t// Using force release by bypass serial number check since we have verified the validity of the handle earlier.\n\tGetEntityStorageInterface().ForceReleaseOne(Entity);\n}\n\nFMassFragmentBitSet FMassEntityManager::InternalAddFragmentListToEntityChecked(FMassEntityHandle Entity, const FMassFragmentBitSet& InFragments)\n{\n\tTSharedPtr<FMassArchetypeData>& OldArchetype = GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index);\n\tcheck(OldArchetype);\n\n\tUE_CLOG(OldArchetype->GetFragmentBitSet().HasAny(InFragments), LogMass, Log\n\t\t, TEXT(\"Trying to add a new fragment type to an entity, but it already has some of them. (%s)\")\n\t\t, *InFragments.GetOverlap(OldArchetype->GetFragmentBitSet()).DebugGetStringDesc());\n\n\tFMassFragmentBitSet NewFragments = InFragments - OldArchetype->GetFragmentBitSet();\n\tif (NewFragments.IsEmpty() == false)\n\t{\n\t\tInternalAddFragmentListToEntity(Entity, NewFragments);\n\t}\n\treturn MoveTemp(NewFragments);\n}\n\nvoid FMassEntityManager::InternalAddFragmentListToEntity(FMassEntityHandle Entity, const FMassFragmentBitSet& InFragments)\n{\n\tcheckf(InFragments.IsEmpty() == false, TEXT(\"%hs is intended for internal calls with non empty NewFragments parameter\"), __FUNCTION__);\n\tcheck(GetEntityStorageInterface().IsValidIndex(Entity.Index));\n\tTSharedPtr<FMassArchetypeData>& OldArchetype = GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index);\n\tcheck(OldArchetype.IsValid());\n\n\t// fetch or create the new archetype\n\tconst FMassArchetypeHandle NewArchetypeHandle = CreateArchetype(OldArchetype, InFragments);\n\tcheckf(NewArchetypeHandle.DataPtr != OldArchetype, TEXT(\"%hs is intended for internal calls with non overlapping fragment list.\"), __FUNCTION__);\n\n\t// Move the entity over\n\tFMassArchetypeData& NewArchetype = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(NewArchetypeHandle);\n\tNewArchetype.CopyDebugNamesFrom(*OldArchetype);\n\tOldArchetype->MoveEntityToAnotherArchetype(Entity, NewArchetype);\n\n\tGetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);\n}\n\nvoid FMassEntityManager::AddFragmentInstanceListToEntity(FMassEntityHandle Entity, TConstArrayView<FInstancedStruct> FragmentInstanceList)\n{\n\tcheckf(IsProcessing() == false, TEXT(\"Synchronous API function %hs called during mass processing. Use asynchronous API instead.\"), __FUNCTION__);\n\n\tCheckIfEntityIsActive(Entity);\n\tcheckf(FragmentInstanceList.Num() > 0, TEXT(\"Need to specify at least one fragment instances for this operation\"));\n\n\tconst FMassArchetypeCompositionDescriptor Descriptor(InternalAddFragmentListToEntityChecked(Entity, FMassFragmentBitSet(FragmentInstanceList)));\n\t\n\tFMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);\n\tcheck(CurrentArchetype);\n\tCurrentArchetype->SetFragmentsData(Entity, FragmentInstanceList);\n\n\tif (IsAllowedToTriggerObservers())\n\t{\n\t\tObserverManager.OnPostCompositionAdded(Entity, Descriptor);\n\t}\n}\n\nvoid FMassEntityManager::RemoveFragmentFromEntity(FMassEntityHandle Entity, const UScriptStruct* FragmentType)\n{\n\tRemoveFragmentListFromEntity(Entity, MakeArrayView(&FragmentType, 1));\n}\n\nvoid FMassEntityManager::RemoveFragmentListFromEntity(FMassEntityHandle Entity, TConstArrayView<const UScriptStruct*> FragmentList)\n{\n\tcheckf(IsProcessing() == false, TEXT(\"Synchronous API function %hs called during mass processing. Use asynchronous API instead.\"), __FUNCTION__);\n\n\tCheckIfEntityIsActive(Entity);\n\t\n\tFMassArchetypeData* OldArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);\n\tcheck(OldArchetype);\n\n\tconst FMassFragmentBitSet FragmentsToRemove(FragmentList);\n\n\tif (OldArchetype->GetFragmentBitSet().HasAny(FragmentsToRemove))\n\t{\n\t\t// If all the fragments got removed this will result in fetching of the empty archetype\n\t\tconst FMassArchetypeCompositionDescriptor NewComposition(OldArchetype->GetFragmentBitSet() - FragmentsToRemove\n\t\t\t, OldArchetype->GetTagBitSet()\n\t\t\t, OldArchetype->GetChunkFragmentBitSet()\n\t\t\t, OldArchetype->GetSharedFragmentBitSet()\n\t\t\t, OldArchetype->GetConstSharedFragmentBitSet());\n\t\tconst FMassArchetypeHandle NewArchetypeHandle = CreateArchetype(NewComposition, FMassArchetypeCreationParams(*OldArchetype));\n\n\t\tFMassArchetypeCompositionDescriptor CompositionDelta;\n\t\t// Find overlap.  It isn't guaranteed that the old archetype has all of the fragments being removed.\n\t\tCompositionDelta.Fragments = OldArchetype->GetFragmentBitSet().GetOverlap(FragmentsToRemove);\n\n\t\tif (IsAllowedToTriggerObservers())\n\t\t{\n\t\t\tObserverManager.OnPreCompositionRemoved(Entity, CompositionDelta);\n\t\t}\n\n\t\t// Move the entity over\n\t\tFMassArchetypeData& NewArchetype = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(NewArchetypeHandle);\n\t\tNewArchetype.CopyDebugNamesFrom(*OldArchetype);\n\t\tOldArchetype->MoveEntityToAnotherArchetype(Entity, NewArchetype);\n\t\t\n\t\tGetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);\n\t}\n}\n\nvoid FMassEntityManager::SwapTagsForEntity(FMassEntityHandle Entity, const UScriptStruct* OldTagType, const UScriptStruct* NewTagType)\n{\n\tcheckf(IsProcessing() == false, TEXT(\"Synchronous API function %hs called during mass processing. Use asynchronous API instead.\"), __FUNCTION__);\n\n\tCheckIfEntityIsActive(Entity);\n\n\tcheckf((OldTagType != nullptr) && OldTagType->IsChildOf(FMassTag::StaticStruct()), TEXT(\"%hs works only with tags while '%s' is not one.\"), __FUNCTION__, *GetPathNameSafe(OldTagType));\n\tcheckf((NewTagType != nullptr) && NewTagType->IsChildOf(FMassTag::StaticStruct()), TEXT(\"%hs works only with tags while '%s' is not one.\"), __FUNCTION__, *GetPathNameSafe(NewTagType));\n\t\n\tTSharedPtr<FMassArchetypeData>& CurrentArchetype = GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index);\n\tcheck(CurrentArchetype);\n\n\tFMassTagBitSet NewTagBitSet = CurrentArchetype->GetTagBitSet();\n\tNewTagBitSet.Remove(*OldTagType);\n\tNewTagBitSet.Add(*NewTagType);\n\t\n\tif (NewTagBitSet != CurrentArchetype->GetTagBitSet())\n\t{\n\t\tconst FMassArchetypeHandle NewArchetypeHandle = InternalCreateSimilarArchetype(CurrentArchetype, NewTagBitSet);\n\t\tcheckSlow(NewArchetypeHandle.IsValid());\n\n\t\t// Move the entity over\n\t\tCurrentArchetype->MoveEntityToAnotherArchetype(Entity, *NewArchetypeHandle.DataPtr.Get());\n\t\t\n\t\tGetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);\n\t}\n}\n\nvoid FMassEntityManager::AddTagToEntity(FMassEntityHandle Entity, const UScriptStruct* TagType)\n{\n\tcheckf((TagType != nullptr) && TagType->IsChildOf(FMassTag::StaticStruct()), TEXT(\"%hs works only with tags while '%s' is not one.\"), __FUNCTION__, *GetPathNameSafe(TagType));\n\n\tCheckIfEntityIsActive(Entity);\n\t\n\tTSharedPtr<FMassArchetypeData>& CurrentArchetype = GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index);\n\tcheck(CurrentArchetype);\n\n\tif (CurrentArchetype->HasTagType(TagType) == false)\n\t{\n\t\t//FMassTagBitSet NewTags = CurrentArchetype->GetTagBitSet() - *TagType;\n\t\tFMassTagBitSet NewTags = CurrentArchetype->GetTagBitSet();\n\t\tNewTags.Add(*TagType);\n\t\tconst FMassArchetypeHandle NewArchetypeHandle = InternalCreateSimilarArchetype(CurrentArchetype, NewTags);\n\t\tcheckSlow(NewArchetypeHandle.IsValid());\n\n\t\t// Move the entity over\n\t\tCurrentArchetype->MoveEntityToAnotherArchetype(Entity, *NewArchetypeHandle.DataPtr.Get());\n\t\tGetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);\n\n\t\tFMassArchetypeCompositionDescriptor CompositionDelta;\n\t\tFMassTagBitSet TagDelta;\n\t\tTagDelta.Add(*TagType);\n\t\tCompositionDelta.Tags = TagDelta;\n\t\t\n\t\tif (IsAllowedToTriggerObservers())\n\t\t{\n\t\t\tObserverManager.OnPostCompositionAdded(Entity, CompositionDelta);\n\t\t}\n\t}\n}\n\t\nvoid FMassEntityManager::RemoveTagFromEntity(FMassEntityHandle Entity, const UScriptStruct* TagType)\n{\n\tcheckf((TagType != nullptr) && TagType->IsChildOf(FMassTag::StaticStruct()), TEXT(\"%hs works only with tags while '%s' is not one.\"), __FUNCTION__, *GetPathNameSafe(TagType));\n\n\tCheckIfEntityIsActive(Entity);\n\n\tTSharedPtr<FMassArchetypeData>& CurrentArchetype = GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index);\n\tcheck(CurrentArchetype);\n\n\tif (CurrentArchetype->HasTagType(TagType))\n\t{\n\t\tFMassArchetypeCompositionDescriptor CompositionDelta;\n\t\tFMassTagBitSet TagDelta;\n\t\tTagDelta.Add(*TagType);\n\t\tCompositionDelta.Tags = TagDelta;\n\t\t\n\t\tif (IsAllowedToTriggerObservers())\n\t\t{\n\t\t\tObserverManager.OnPreCompositionRemoved(Entity, CompositionDelta);\n\t\t}\n\t\t\n\t\t// CurrentArchetype->GetTagBitSet() -  *TagType\n\t\tconst FMassTagBitSet NewTagComposition = CurrentArchetype->GetTagBitSet() - TagDelta;\n\t\tconst FMassArchetypeHandle NewArchetypeHandle = InternalCreateSimilarArchetype(CurrentArchetype, NewTagComposition);\n\t\tcheckSlow(NewArchetypeHandle.IsValid());\n\n\t\t// Move the entity over\n\t\tCurrentArchetype->MoveEntityToAnotherArchetype(Entity, *NewArchetypeHandle.DataPtr.Get());\n\t\tGetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);\n\t}\n}\n\nbool FMassEntityManager::AddConstSharedFragmentToEntity(const FMassEntityHandle Entity, const FConstSharedStruct& InConstSharedFragment)\n{\n\tif (!ensureMsgf(InConstSharedFragment.IsValid(), TEXT(\"%hs parameter Fragment is expected to be valid\"), __FUNCTION__))\n\t{\n\t\treturn false;\n\t}\n\n\tCheckIfEntityIsActive(Entity);\n\t\n\tFMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index).Get();\n\tcheck(CurrentArchetype);\n\n\tconst UScriptStruct* StructType = InConstSharedFragment.GetScriptStruct();\n\tCA_ASSUME(StructType);\n\tif (CurrentArchetype->GetCompositionDescriptor().ConstSharedFragments.Contains(*StructType))\n\t{\n\t\tconst FMassArchetypeSharedFragmentValues& SharedFragmentValues = CurrentArchetype->GetSharedFragmentValues(Entity);\n\t\tFConstSharedStruct ExistingConstSharedStruct = SharedFragmentValues.GetConstSharedFragmentStruct(StructType);\n\t\tif (ExistingConstSharedStruct == InConstSharedFragment || ExistingConstSharedStruct.CompareStructValues(InConstSharedFragment))\n\t\t{\n\t\t\t// nothing to do\n\t\t\treturn true;\n\t\t}\n\t\tUE_LOG(LogMass, Warning, TEXT(\"Changing shared fragment value of entities is not supported\"));\n\t\treturn false;\n\t}\n\t\n\tFMassArchetypeCompositionDescriptor NewComposition(CurrentArchetype->GetCompositionDescriptor());\n\tNewComposition.ConstSharedFragments.Add(*StructType);\n\tconst FMassArchetypeHandle NewArchetypeHandle = CreateArchetype(NewComposition, FMassArchetypeCreationParams(*CurrentArchetype));\n\tcheck(NewArchetypeHandle.IsValid());\n\tFMassArchetypeData* NewArchetype = NewArchetypeHandle.DataPtr.Get();\n\tcheck(NewArchetype);\n\n\tconst FMassArchetypeSharedFragmentValues& OldSharedFragmentValues = CurrentArchetype->GetSharedFragmentValues(Entity.Index);\n\tcheck(!OldSharedFragmentValues.ContainsType(StructType));\n\tFMassArchetypeSharedFragmentValues NewSharedFragmentValues(OldSharedFragmentValues);\n\tNewSharedFragmentValues.AddConstSharedFragment(InConstSharedFragment);\n\tNewSharedFragmentValues.Sort();\n\n\tCurrentArchetype->MoveEntityToAnotherArchetype(Entity, *NewArchetype, &NewSharedFragmentValues);\n\n\t// Change the entity archetype\n\tGetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);\n\n\treturn true;\n}\n\nbool FMassEntityManager::RemoveConstSharedFragmentFromEntity(const FMassEntityHandle Entity, const UScriptStruct& ConstSharedFragmentType)\n{\n\tif (!ensureMsgf(ConstSharedFragmentType.IsChildOf(FMassConstSharedFragment::StaticStruct()), TEXT(\"%hs parameter ConstSharedFragmentType is expected to be a FMassConstSharedFragment\"), __FUNCTION__))\n\t{\n\t\treturn false;\n\t}\n\t\n\tCheckIfEntityIsActive(Entity);\n\t\n\tFMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index).Get();\n\tcheck(CurrentArchetype);\n\t\n\tif (!CurrentArchetype->GetCompositionDescriptor().ConstSharedFragments.Contains(ConstSharedFragmentType))\n\t{\n\t\t// Nothing to do. Returning false to indicate nothing has been removed, as per function's documentation \n\t\treturn false;\n\t}\n\n\tFMassArchetypeCompositionDescriptor NewComposition(CurrentArchetype->GetCompositionDescriptor());\n\tNewComposition.ConstSharedFragments.Remove(ConstSharedFragmentType);\n\tconst FMassArchetypeHandle NewArchetypeHandle = CreateArchetype(NewComposition);\n\tcheck(NewArchetypeHandle.IsValid());\n\tFMassArchetypeData* NewArchetype = NewArchetypeHandle.DataPtr.Get();\n\tcheck(NewArchetype);\n\t\n\tconst FMassArchetypeSharedFragmentValues& OldSharedFragmentValues = CurrentArchetype->GetSharedFragmentValues(Entity.Index);\n\tcheck(OldSharedFragmentValues.ContainsType(&ConstSharedFragmentType));\n\tFMassArchetypeSharedFragmentValues NewSharedFragmentValues(OldSharedFragmentValues);\n\t\n\tconst FMassConstSharedFragmentBitSet ToRemove(ConstSharedFragmentType);\n\tNewSharedFragmentValues.Remove(ToRemove);\n\tNewSharedFragmentValues.Sort();\n\t\n\tCurrentArchetype->MoveEntityToAnotherArchetype(Entity, *NewArchetype, &NewSharedFragmentValues);\n\n\t// Change the entity archetype\n\tGetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);\n\t\n\treturn true;\n}\n\nvoid FMassEntityManager::BatchChangeTagsForEntities(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, const FMassTagBitSet& TagsToAdd, const FMassTagBitSet& TagsToRemove)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchChangeTagsForEntities);\n\n\tconst FScopedCreationContextOperations CreationContextOperations(*this);\n\t\n\tfor (const FMassArchetypeEntityCollection& Collection : EntityCollections)\n\t{\n\t\tFMassArchetypeData* CurrentArchetype = Collection.GetArchetype().DataPtr.Get();\n\t\tconst FMassTagBitSet NewTagComposition = CurrentArchetype\n\t\t\t? (CurrentArchetype->GetTagBitSet() + TagsToAdd - TagsToRemove)\n\t\t\t: (TagsToAdd - TagsToRemove);\n\n\t\tif (ensure(CurrentArchetype) && CurrentArchetype->GetTagBitSet() != NewTagComposition)\n\t\t{\n\t\t\tFMassTagBitSet TagsAdded = TagsToAdd - CurrentArchetype->GetTagBitSet();\n\t\t\tFMassTagBitSet TagsRemoved = TagsToRemove.GetOverlap(CurrentArchetype->GetTagBitSet());\n\n\t\t\tif (CreationContextOperations.IsAllowedToTriggerObservers()\n\t\t\t\t&& ObserverManager.HasObserversForBitSet(TagsRemoved, EMassObservedOperation::Remove))\n\t\t\t{\n\t\t\t\t// @todo should use OnPreCompositionRemoved here instead, but we're missing a FMassArchetypeEntityCollection version\n\t\t\t\tObserverManager.OnCompositionChanged(Collection, FMassArchetypeCompositionDescriptor(MoveTemp(TagsRemoved)), EMassObservedOperation::Remove);\n\t\t\t}\n\t\t\tconst bool bTagsAddedAreObserved = ObserverManager.HasObserversForBitSet(TagsAdded, EMassObservedOperation::Add);\n\n\t\t\tFMassArchetypeHandle NewArchetypeHandle = InternalCreateSimilarArchetype(Collection.GetArchetype().DataPtr, NewTagComposition);\n\t\t\tcheckSlow(NewArchetypeHandle.IsValid());\n\n\t\t\t// Move the entity over\n\t\t\tFMassArchetypeEntityCollection::FEntityRangeArray NewArchetypeEntityRanges;\n\t\t\tTArray<FMassEntityHandle> EntitiesBeingMoved;\n\t\t\tCurrentArchetype->BatchMoveEntitiesToAnotherArchetype(Collection, *NewArchetypeHandle.DataPtr.Get(), EntitiesBeingMoved\n\t\t\t\t, bTagsAddedAreObserved ? &NewArchetypeEntityRanges : nullptr);\n\n\t\t\tfor (const FMassEntityHandle& Entity : EntitiesBeingMoved)\n\t\t\t{\n\t\t\t\tcheck(GetEntityStorageInterface().IsValidIndex(Entity.Index));\n\t\t\t\t\n\t\t\t\tGetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);\n\t\t\t}\n\n\t\t\tif (bTagsAddedAreObserved && CreationContextOperations.IsAllowedToTriggerObservers())\n\t\t\t{\n\t\t\t\t// @todo should use OnPostCompositionAdded here instead, but we're missing a FMassArchetypeEntityCollection version\n\t\t\t\tObserverManager.OnCompositionChanged(\n\t\t\t\t\tFMassArchetypeEntityCollection(NewArchetypeHandle, MoveTemp(NewArchetypeEntityRanges))\n\t\t\t\t\t, FMassArchetypeCompositionDescriptor(MoveTemp(TagsAdded))\n\t\t\t\t\t, EMassObservedOperation::Add);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid FMassEntityManager::BatchChangeFragmentCompositionForEntities(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, const FMassFragmentBitSet& FragmentsToAdd, const FMassFragmentBitSet& FragmentsToRemove)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchChangeFragmentCompositionForEntities);\n\n\tFScopedCreationContextOperations CreationContextOperations(*this);\n\n\tfor (const FMassArchetypeEntityCollection& Collection : EntityCollections)\n\t{\n\t\tFMassArchetypeData* CurrentArchetype = Collection.GetArchetype().DataPtr.Get();\n\t\tconst FMassFragmentBitSet NewFragmentComposition = CurrentArchetype\n\t\t\t? (CurrentArchetype->GetFragmentBitSet() + FragmentsToAdd - FragmentsToRemove)\n\t\t\t: (FragmentsToAdd - FragmentsToRemove);\n\n\t\tif (CurrentArchetype)\n\t\t{\n\t\t\tif (CurrentArchetype->GetFragmentBitSet() != NewFragmentComposition)\n\t\t\t{\n\t\t\t\tFMassFragmentBitSet FragmentsAdded = FragmentsToAdd - CurrentArchetype->GetFragmentBitSet();\n\t\t\t\tconst bool bFragmentsAddedAreObserved = ObserverManager.HasObserversForBitSet(FragmentsAdded, EMassObservedOperation::Add);\n\t\t\t\tFMassFragmentBitSet FragmentsRemoved = FragmentsToRemove.GetOverlap(CurrentArchetype->GetFragmentBitSet());\n\t\t\t\t\n\t\t\t\tif (CreationContextOperations.IsAllowedToTriggerObservers()\n\t\t\t\t\t&& ObserverManager.HasObserversForBitSet(FragmentsRemoved, EMassObservedOperation::Remove))\n\t\t\t\t{\n\t\t\t\t\tObserverManager.OnCompositionChanged(Collection, FMassArchetypeCompositionDescriptor(MoveTemp(FragmentsRemoved)), EMassObservedOperation::Remove);\n\t\t\t\t}\n\n\t\t\t\tFMassArchetypeHandle NewArchetypeHandle = InternalCreateSimilarArchetype(Collection.GetArchetype().DataPtr, NewFragmentComposition);\n\t\t\t\tcheckSlow(NewArchetypeHandle.IsValid());\n\n\t\t\t\t// Move the entity over\n\t\t\t\tFMassArchetypeEntityCollection::FEntityRangeArray NewArchetypeEntityRanges;\n\t\t\t\tTArray<FMassEntityHandle> EntitiesBeingMoved;\n\t\t\t\tCurrentArchetype->BatchMoveEntitiesToAnotherArchetype(Collection, *NewArchetypeHandle.DataPtr.Get(), EntitiesBeingMoved\n\t\t\t\t\t, bFragmentsAddedAreObserved ? &NewArchetypeEntityRanges : nullptr);\n\n\t\t\t\tfor (const FMassEntityHandle& Entity : EntitiesBeingMoved)\n\t\t\t\t{\n\t\t\t\t\tcheck(GetEntityStorageInterface().IsValidIndex(Entity.Index));\n\n\t\t\t\t\tGetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);\n\t\t\t\t}\n\n\t\t\t\tif (bFragmentsAddedAreObserved && CreationContextOperations.IsAllowedToTriggerObservers())\n\t\t\t\t{\n\t\t\t\t\tObserverManager.OnCompositionChanged(\n\t\t\t\t\t\tFMassArchetypeEntityCollection(NewArchetypeHandle, MoveTemp(NewArchetypeEntityRanges))\n\t\t\t\t\t\t, FMassArchetypeCompositionDescriptor(MoveTemp(FragmentsAdded))\n\t\t\t\t\t\t, EMassObservedOperation::Add);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tBatchBuildEntities(FMassArchetypeEntityCollectionWithPayload(Collection), NewFragmentComposition, FMassArchetypeSharedFragmentValues());\n\t\t}\n\t}\n}\n\nvoid FMassEntityManager::BatchAddFragmentInstancesForEntities(TConstArrayView<FMassArchetypeEntityCollectionWithPayload> EntityCollections, const FMassFragmentBitSet& FragmentsAffected)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchAddFragmentInstancesForEntities);\n\n\t// here's the scenario:\n\t// * we get entities from potentially different archetypes\n\t// * adding a fragment instance consists of two operations: A) add fragment type & B) set fragment value\n\t//\t\t* some archetypes might already have the \"added\" fragments so no need for step A\n\t//\t\t* there might be an \"empty\" archetype in the mix - then step A results in archetype creation and assigning\n\t//\t\t* if step A is required then the initial FMassArchetypeEntityCollection instance is no longer valid\n\t// * setting value can be done uniformly for all entities, remembering some might be in different chunks already\n\t// * @todo note that after adding fragment type some entities originally in different archetypes end up in the same \n\t//\t\tarchetype. This could be utilized as a basis for optimization. To be investigated.\n\t// \n\n\tFScopedCreationContextOperations CreationContextOperations(*this);\n\n\tfor (const FMassArchetypeEntityCollectionWithPayload& EntityRangesWithPayload : EntityCollections)\n\t{\n\t\tFMassArchetypeHandle TargetArchetypeHandle = EntityRangesWithPayload.GetEntityCollection().GetArchetype();\n\t\tFMassArchetypeData* CurrentArchetype = TargetArchetypeHandle.DataPtr.Get();\n\n\t\tif (CurrentArchetype)\n\t\t{\n\t\t\tFMassArchetypeEntityCollection::FEntityRangeArray TargetArchetypeEntityRanges;\n\t\t\tbool bFragmentsAddedAreObserved = false;\n\t\t\tFMassFragmentBitSet NewFragmentComposition = CurrentArchetype\n\t\t\t\t? (CurrentArchetype->GetFragmentBitSet() + FragmentsAffected)\n\t\t\t\t: FragmentsAffected;\n\t\t\tFMassFragmentBitSet FragmentsAdded;\n\n\t\t\tif (CurrentArchetype->GetFragmentBitSet() != NewFragmentComposition)\n\t\t\t{\n\t\t\t\tFragmentsAdded = FragmentsAffected - CurrentArchetype->GetFragmentBitSet();\n\t\t\t\tbFragmentsAddedAreObserved = ObserverManager.HasObserversForBitSet(FragmentsAdded, EMassObservedOperation::Add);\n\n\t\t\t\tFMassArchetypeHandle NewArchetypeHandle = InternalCreateSimilarArchetype(TargetArchetypeHandle.DataPtr, NewFragmentComposition);\n\t\t\t\tcheckSlow(NewArchetypeHandle.IsValid());\n\n\t\t\t\t// Move the entity over\n\t\t\t\tTArray<FMassEntityHandle> EntitiesBeingMoved;\n\t\t\t\tCurrentArchetype->BatchMoveEntitiesToAnotherArchetype(EntityRangesWithPayload.GetEntityCollection(), *NewArchetypeHandle.DataPtr.Get()\n\t\t\t\t\t, EntitiesBeingMoved, &TargetArchetypeEntityRanges);\n\n\t\t\t\tfor (const FMassEntityHandle& Entity : EntitiesBeingMoved)\n\t\t\t\t{\n\t\t\t\t\tcheck(GetEntityStorageInterface().IsValidIndex(Entity.Index));\n\n\t\t\t\t\tGetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);\n\t\t\t\t}\n\n\t\t\t\tTargetArchetypeHandle = NewArchetypeHandle;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tTargetArchetypeEntityRanges = EntityRangesWithPayload.GetEntityCollection().GetRanges();\n\t\t\t}\n\n\t\t\t// at this point all the entities are in the target archetype, we can set the values\n\t\t\t// note that even though the \"subchunk\" information could have changed the order of entities is the same and \n\t\t\t// corresponds to the order in FMassArchetypeEntityCollectionWithPayload's payload\n\t\t\tTargetArchetypeHandle.DataPtr->BatchSetFragmentValues(TargetArchetypeEntityRanges, EntityRangesWithPayload.GetPayload());\n\t\t\t\n\t\t\tif (bFragmentsAddedAreObserved && CreationContextOperations.IsAllowedToTriggerObservers())\n\t\t\t{\n\t\t\t\tObserverManager.OnCompositionChanged(\n\t\t\t\t\tFMassArchetypeEntityCollection(TargetArchetypeHandle, MoveTemp(TargetArchetypeEntityRanges))\n\t\t\t\t\t, FMassArchetypeCompositionDescriptor(MoveTemp(FragmentsAdded))\n\t\t\t\t\t, EMassObservedOperation::Add);\n\t\t\t}\n\t\t}\n\t\telse \n\t\t{\n\t\t\tBatchBuildEntities(EntityRangesWithPayload, FragmentsAffected, FMassArchetypeSharedFragmentValues());\n\t\t}\n\t}\n}\n\nvoid FMassEntityManager::BatchAddSharedFragmentsForEntities(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections\n\t, const FMassArchetypeSharedFragmentValues& AddedFragmentValues)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchAddConstSharedFragmentForEntities);\n\n\tfor (const FMassArchetypeEntityCollection& Collection : EntityCollections)\n\t{\n\t\tFMassArchetypeData* CurrentArchetype = Collection.GetArchetype().DataPtr.Get();\n\t\ttestableCheckfReturn(CurrentArchetype, continue, TEXT(\"Adding shared fragments to archetype-less entities is not supported\"));\n\n\t\tFMassArchetypeCompositionDescriptor NewComposition(CurrentArchetype->GetCompositionDescriptor());\n\t\tNewComposition.SharedFragments += AddedFragmentValues.GetSharedFragmentBitSet();\n\t\tNewComposition.ConstSharedFragments += AddedFragmentValues.GetConstSharedFragmentBitSet();\n\n\t\tconst FMassArchetypeHandle NewArchetypeHandle = CreateArchetype(NewComposition, FMassArchetypeCreationParams(*CurrentArchetype));\n\t\tcheck(NewArchetypeHandle.IsValid());\n\t\tFMassArchetypeData* NewArchetype = NewArchetypeHandle.DataPtr.Get();\n\t\tcheck(NewArchetype);\n\t\tif (!testableEnsureMsgf(CurrentArchetype != NewArchetype, TEXT(\"Setting shared fragment values without archetype change is not supported\")))\n\t\t{\n\t\t\tUE_LOG(LogMass, Warning, TEXT(\"Trying to set shared fragment values, without adding new shared fragments, is not supported.\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\tTArray<FMassEntityHandle> EntitiesBeingMoved;\n\t\tCurrentArchetype->BatchMoveEntitiesToAnotherArchetype(Collection, *NewArchetype, EntitiesBeingMoved, /*OutNewChunks=*/nullptr, &AddedFragmentValues);\n\n\t\tfor (const FMassEntityHandle& Entity : EntitiesBeingMoved)\n\t\t{\n\t\t\tcheck(GetEntityStorageInterface().IsValidIndex(Entity.Index));\n\t\t\t\n\t\t\tGetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);\n\t\t}\n\t}\n}\n\nvoid FMassEntityManager::MoveEntityToAnotherArchetype(FMassEntityHandle Entity, FMassArchetypeHandle NewArchetypeHandle)\n{\n\tCheckIfEntityIsActive(Entity);\n\n\tFMassArchetypeData& NewArchetype = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(NewArchetypeHandle);\n\n\t// Move the entity over\n\tFMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);\n\tcheck(CurrentArchetype);\n\tCurrentArchetype->MoveEntityToAnotherArchetype(Entity, NewArchetype);\n\tGetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);\n}\n\nvoid FMassEntityManager::SetEntityFragmentsValues(FMassEntityHandle Entity, TArrayView<const FInstancedStruct> FragmentInstanceList)\n{\n\tCheckIfEntityIsActive(Entity);\n\n\tFMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);\n\tcheck(CurrentArchetype);\n\tCurrentArchetype->SetFragmentsData(Entity, FragmentInstanceList);\n}\n\nvoid FMassEntityManager::BatchSetEntityFragmentsValues(const FMassArchetypeEntityCollection& SparseEntities, TArrayView<const FInstancedStruct> FragmentInstanceList)\n{\n\tif (FragmentInstanceList.Num())\n\t{\n\t\tBatchSetEntityFragmentsValues(MakeArrayView(&SparseEntities, 1), FragmentInstanceList);\n\t}\n}\n\nvoid FMassEntityManager::BatchSetEntityFragmentsValues(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, TArrayView<const FInstancedStruct> FragmentInstanceList)\n{\n\tif (FragmentInstanceList.IsEmpty())\n\t{\n\t\treturn;\n\t}\n\n\tfor (const FMassArchetypeEntityCollection& SparseEntities : EntityCollections)\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchSetEntityFragmentsValues);\n\n\t\tFMassArchetypeData* Archetype = SparseEntities.GetArchetype().DataPtr.Get();\n\t\tcheck(Archetype);\n\n\t\tfor (const FInstancedStruct& FragmentTemplate : FragmentInstanceList)\n\t\t{\n\t\t\tArchetype->SetFragmentData(SparseEntities.GetRanges(), FragmentTemplate);\n\t\t}\n\t}\n}\n\nvoid* FMassEntityManager::InternalGetFragmentDataChecked(FMassEntityHandle Entity, const UScriptStruct* FragmentType) const\n{\n\t// note that FragmentType is guaranteed to be of valid type - it's either statically checked by the template versions\n\t// or `checkf`ed by the non-template one\n\tCheckIfEntityIsActive(Entity);\n\tconst FMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);\n\tcheck(CurrentArchetype);\n\treturn CurrentArchetype->GetFragmentDataForEntityChecked(FragmentType, Entity.Index);\n}\n\nvoid* FMassEntityManager::InternalGetFragmentDataPtr(FMassEntityHandle Entity, const UScriptStruct* FragmentType) const\n{\n\t// note that FragmentType is guaranteed to be of valid type - it's either statically checked by the template versions\n\t// or `checkf`ed by the non-template one\n\tCheckIfEntityIsActive(Entity);\n\tconst FMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);\n\tcheck(CurrentArchetype);\n\treturn CurrentArchetype->GetFragmentDataForEntity(FragmentType, Entity.Index);\n}\n\nconst FConstSharedStruct* FMassEntityManager::InternalGetConstSharedFragmentPtr(FMassEntityHandle Entity, const UScriptStruct* ConstSharedFragmentType) const\n{\n\t// note that ConstSharedFragmentType is guaranteed to be of valid type - it's either statically checked by the template versions\n\t// or `checkf`ed by the non-template one\n\tCheckIfEntityIsActive(Entity);\n\tconst FMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);\n\tcheck(CurrentArchetype);\n\tconst FConstSharedStruct* SharedFragment = CurrentArchetype->GetSharedFragmentValues(Entity).GetConstSharedFragments().FindByPredicate(FStructTypeEqualOperator(ConstSharedFragmentType));\n\treturn SharedFragment;\n}\n\nconst FSharedStruct* FMassEntityManager::InternalGetSharedFragmentPtr(FMassEntityHandle Entity, const UScriptStruct* SharedFragmentType) const\n{\n\t// note that SharedFragmentType is guaranteed to be of valid type - it's either statically checked by the template versions\n\t// or `checkf`ed by the non-template one\n\tCheckIfEntityIsActive(Entity);\n\tconst FMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);\n\tcheck(CurrentArchetype);\n\tconst FSharedStruct* SharedFragment = CurrentArchetype->GetSharedFragmentValues(Entity).GetSharedFragments().FindByPredicate(FStructTypeEqualOperator(SharedFragmentType));\n\treturn SharedFragment;\n}\n\nbool FMassEntityManager::IsEntityValid(FMassEntityHandle Entity) const\n{\n\treturn (Entity.Index != UE::Mass::Private::InvalidEntityIndex) \n\t\t&& GetEntityStorageInterface().IsValidIndex(Entity.Index) \n\t\t&& (GetEntityStorageInterface().GetSerialNumber(Entity.Index) == Entity.SerialNumber);\n}\n\nbool FMassEntityManager::IsEntityBuilt(FMassEntityHandle Entity) const\n{\n\tCheckIfEntityIsValid(Entity);\n\tconst UE::Mass::IEntityStorageInterface::EEntityState CurrentState = GetEntityStorageInterface().GetEntityState(Entity.Index);\n\treturn CurrentState == UE::Mass::IEntityStorageInterface::EEntityState::Created;\n}\n\nvoid FMassEntityManager::CheckIfEntityIsValid(FMassEntityHandle Entity) const\n{\n\tcheckf(IsEntityValid(Entity), TEXT(\"Invalid entity (ID: %d, SN:%d, %s)\"), Entity.Index, Entity.SerialNumber,\n\t\t   (Entity.Index == 0) ? TEXT(\"was never initialized\") : TEXT(\"already destroyed\"));\n}\n\nvoid FMassEntityManager::CheckIfEntityIsActive(FMassEntityHandle Entity) const\n{\n\tcheckf(IsEntityBuilt(Entity), TEXT(\"Entity not yet created(ID: %d, SN:%d)\"), Entity.Index, Entity.SerialNumber);\n}\n\nvoid FMassEntityManager::GetMatchingArchetypes(const FMassFragmentRequirements& Requirements, TArray<FMassArchetypeHandle>& OutValidArchetypes, const uint32 FromArchetypeDataVersion) const\n{\n\tfor (int32 ArchetypeIndex = FromArchetypeDataVersion; ArchetypeIndex < AllArchetypes.Num(); ++ArchetypeIndex)\n\t{\n\t\tcheckf(AllArchetypes[ArchetypeIndex].IsValid(), TEXT(\"We never expect to get any invalid shared ptrs in AllArchetypes\"));\n\n\t\tFMassArchetypeData& Archetype = *(AllArchetypes[ArchetypeIndex].Get());\n\n\t\t// Only return archetypes with a newer created version than the specified version, this is for incremental query updates\n\t\tensureMsgf(Archetype.GetCreatedArchetypeDataVersion() > FromArchetypeDataVersion\n\t\t\t, TEXT(\"There's a stron assumption that archetype's data version corresponds to its index in AllArchetypes\"));\n\n\t\tif (Requirements.DoesArchetypeMatchRequirements(Archetype.GetCompositionDescriptor()))\n\t\t{\n\t\t\tOutValidArchetypes.Add(AllArchetypes[ArchetypeIndex]);\n\t\t}\n#if WITH_MASSENTITY_DEBUG\n\t\telse\n\t\t{\n\t\t\tUE_VLOG_UELOG(GetOwner(), LogMass, VeryVerbose, TEXT(\"%s\")\n\t\t\t\t, *FMassDebugger::GetArchetypeRequirementCompatibilityDescription(Requirements, Archetype.GetCompositionDescriptor()));\n\t\t}\n#endif // WITH_MASSENTITY_DEBUG\n\t}\n}\n\nFMassExecutionContext FMassEntityManager::CreateExecutionContext(const float DeltaSeconds)\n{\n\tFMassExecutionContext ExecutionContext(*this, DeltaSeconds);\n\tExecutionContext.SetDeferredCommandBuffer(DeferredCommandBuffers[OpenedCommandBufferIndex]);\n\treturn MoveTemp(ExecutionContext);\n}\n\nvoid FMassEntityManager::FlushCommands(TSharedPtr<FMassCommandBuffer>& InCommandBuffer)\n{\n\tif (!ensureMsgf(IsInGameThread(), TEXT(\"Calling %hs is supported only on the Game Tread\"), __FUNCTION__))\n\t{\n\t\treturn;\n\t}\n\tif (!ensureMsgf(IsProcessing() == false, TEXT(\"Calling %hs is not supported while Mass Processing is active. Call FMassEntityManager::AppendCommands instead.\"), __FUNCTION__))\n\t{\n\t\treturn;\n\t}\n\n\tif (InCommandBuffer && InCommandBuffer->HasPendingCommands()\n\t\t&& (Algo::Find(DeferredCommandBuffers, InCommandBuffer) == nullptr))\n\t{\n\t\tAppendCommands(InCommandBuffer);\n\t}\n\tFlushCommands();\n}\n\nvoid FMassEntityManager::FlushCommands()\n{\n\tconstexpr int32 MaxIterations = 5;\n\n\tif (!ensureMsgf(IsInGameThread(), TEXT(\"Calling %hs is supported only on the Game Tread\"), __FUNCTION__))\n\t{\n\t\treturn;\n\t}\n\tif (!ensureMsgf(IsProcessing() == false, TEXT(\"Calling %hs is not supported while Mass Processing is active. Call FMassEntityManager::AppendCommands instead.\"), __FUNCTION__))\n\t{\n\t\treturn;\n\t}\n\n\tif (bCommandBufferFlushingInProgress == false && IsProcessing() == false)\n\t{\n\t\tON_SCOPE_EXIT\n\t\t{\n\t\t\tbCommandBufferFlushingInProgress = false;\n\t\t};\n\t\tbCommandBufferFlushingInProgress = true;\n\n\t\tint32 IterationCount = 0;\n\t\tdo \n\t\t{\n\t\t\tconst int32 CommandBufferIndexToFlush = OpenedCommandBufferIndex;\n\n\t\t\t// buffer swap. Code instigated by observers can still use Defer() to push commands.\n\t\t\tOpenedCommandBufferIndex = (OpenedCommandBufferIndex + 1) % DeferredCommandBuffers.Num();\n\t\t\tensureMsgf(DeferredCommandBuffers[OpenedCommandBufferIndex]->HasPendingCommands() == false\n\t\t\t\t, TEXT(\"The freshly opened command buffer is expected to be empty upon switching\"));\n\n\t\t\tDeferredCommandBuffers[CommandBufferIndexToFlush]->Flush(*this);\n\n\t\t\t// repeat if there were commands submitted while commands were being flushed (by observers for example)\n\t\t} while (DeferredCommandBuffers[OpenedCommandBufferIndex]->HasPendingCommands() && ++IterationCount < MaxIterations);\n\n\t\tUE_CVLOG_UELOG(IterationCount >= MaxIterations, GetOwner(), LogMass, Error, TEXT(\"Reached loop count limit while flushing commands. Limiting the number of commands pushed during commands flushing could help.\"));\n\t}\n}\n\nvoid FMassEntityManager::AppendCommands(TSharedPtr<FMassCommandBuffer>& InOutCommandBuffer)\n{\n\tif (!ensureMsgf(Algo::Find(DeferredCommandBuffers, InOutCommandBuffer) == nullptr\n\t\t, TEXT(\"We don't expect AppendCommands to be called with EntityManager's command buffer as the input parameter\")))\n\t{\n\t\treturn;\n\t}\n\tDefer().MoveAppend(*InOutCommandBuffer.Get());\n}\n\nTSharedRef<FMassEntityManager::FEntityCreationContext> FMassEntityManager::GetOrMakeCreationContext()\n{\n\tif (ActiveCreationContext.IsValid())\n\t{\n\t\treturn ActiveCreationContext.Pin().ToSharedRef();\n\t}\n\telse\n\t{\n\t\tFEntityCreationContext* CreationContext = new FEntityCreationContext(*this);\n\t\tTSharedRef<FEntityCreationContext> SharedContext = MakeShareable(CreationContext);\n\t\tActiveCreationContext = SharedContext;\n\t\treturn SharedContext;\n\t}\n}\n\nTSharedRef<FMassEntityManager::FEntityCreationContext> FMassEntityManager::GetOrMakeCreationContext(TConstArrayView<FMassEntityHandle> ReservedEntities\n\t, FMassArchetypeEntityCollection&& EntityCollection)\n{\n\tif (ActiveCreationContext.IsValid())\n\t{\n\t\tTSharedPtr<FEntityCreationContext> SharedContext = ActiveCreationContext.Pin();\n\t\tCA_ASSUME(SharedContext);\n\t\tSharedContext->AppendEntities(ReservedEntities, MoveTemp(EntityCollection));\n\t\treturn SharedContext.ToSharedRef();\n\t}\n\telse\n\t{\n\t\tFEntityCreationContext* CreationContext = new FEntityCreationContext(*this, ReservedEntities, MoveTemp(EntityCollection));\n\t\tTSharedRef<FEntityCreationContext> SharedContext = MakeShareable(CreationContext);\n\t\tActiveCreationContext = SharedContext;\n\t\treturn SharedContext;\n\t}\n}\n\nbool FMassEntityManager::DirtyCreationContext()\n{\n\tif (TSharedPtr<FEntityCreationContext> AsSharedPtr = ActiveCreationContext.Pin())\n\t{\n\t\tAsSharedPtr->MarkDirty();\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool FMassEntityManager::DebugDoCollectionsOverlapCreationContext(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections) const\n{\n\tif (TSharedPtr<FEntityCreationContext> AsSharedPtr = ActiveCreationContext.Pin())\n\t{\n\t\tTConstArrayView<FMassArchetypeEntityCollection> CreationCollections = AsSharedPtr->EntityCollections;\n\t\treturn CreationCollections.GetData() <= EntityCollections.GetData()\n\t\t\t&& EntityCollections.GetData() <= CreationCollections.GetData() + CreationCollections.Num();\n\t}\n\n\treturn false;\n}\n\nvoid FMassEntityManager::SetDebugName(const FString& NewDebugGame) \n{ \n#if WITH_MASSENTITY_DEBUG\n\tDebugName = NewDebugGame; \n#endif // WITH_MASSENTITY_DEBUG\n}\n\n#if WITH_MASSENTITY_DEBUG\nvoid FMassEntityManager::DebugPrintArchetypes(FOutputDevice& Ar, const bool bIncludeEmpty) const\n{\n\tAr.Logf(ELogVerbosity::Log, TEXT(\"Listing archetypes contained in EntityManager owned by %s\"), *GetPathNameSafe(GetOwner()));\n\n\tint32 NumBuckets = 0;\n\tint32 NumArchetypes = 0;\n\tint32 LongestArchetypeBucket = 0;\n\tfor (const auto& KVP : FragmentHashToArchetypeMap)\n\t{\n\t\tfor (const TSharedPtr<FMassArchetypeData>& ArchetypePtr : KVP.Value)\n\t\t{\n\t\t\tif (ArchetypePtr.IsValid() && (bIncludeEmpty == true || ArchetypePtr->GetChunkCount() > 0))\n\t\t\t{\n\t\t\t\tArchetypePtr->DebugPrintArchetype(Ar);\n\t\t\t}\n\t\t}\n\n\t\tconst int32 NumArchetypesInBucket = KVP.Value.Num();\n\t\tLongestArchetypeBucket = FMath::Max(LongestArchetypeBucket, NumArchetypesInBucket);\n\t\tNumArchetypes += NumArchetypesInBucket;\n\t\t++NumBuckets;\n\t}\n\n\tAr.Logf(ELogVerbosity::Log, TEXT(\"FragmentHashToArchetypeMap: %d archetypes across %d buckets, longest bucket is %d\"),\n\t\tNumArchetypes, NumBuckets, LongestArchetypeBucket);\n}\n\nvoid FMassEntityManager::DebugGetArchetypesStringDetails(FOutputDevice& Ar, const bool bIncludeEmpty) const\n{\n\tAr.SetAutoEmitLineTerminator(true);\n\tfor (auto Pair : FragmentHashToArchetypeMap)\n\t{\n\t\tAr.Logf(ELogVerbosity::Log, TEXT(\"\\n-----------------------------------\\nHash: %u\"), Pair.Key);\n\t\tfor (TSharedPtr<FMassArchetypeData> Archetype : Pair.Value)\n\t\t{\n\t\t\tif (Archetype.IsValid() && (bIncludeEmpty == true || Archetype->GetChunkCount() > 0))\n\t\t\t{\n\t\t\t\tArchetype->DebugPrintArchetype(Ar);\n\t\t\t\tAr.Logf(ELogVerbosity::Log, TEXT(\"+++++++++++++++++++++++++\\n\"));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid FMassEntityManager::DebugGetArchetypeFragmentTypes(const FMassArchetypeHandle& Archetype, TArray<const UScriptStruct*>& InOutFragmentList) const\n{\n\tif (Archetype.IsValid())\n\t{\n\t\tconst FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(Archetype);\n\t\tArchetypeData.GetCompositionDescriptor().Fragments.ExportTypes(InOutFragmentList);\n\t}\n}\n\nint32 FMassEntityManager::DebugGetArchetypeEntitiesCount(const FMassArchetypeHandle& Archetype) const\n{\n\treturn Archetype.IsValid() ? FMassArchetypeHelper::ArchetypeDataFromHandleChecked(Archetype).GetNumEntities() : 0;\n}\n\nint32 FMassEntityManager::DebugGetArchetypeEntitiesCountPerChunk(const FMassArchetypeHandle& Archetype) const\n{\n\treturn Archetype.IsValid() ? FMassArchetypeHelper::ArchetypeDataFromHandleChecked(Archetype).GetNumEntitiesPerChunk() : 0;\n}\n\nint32 FMassEntityManager::DebugGetEntityCount() const\n{\n\treturn GetEntityStorageInterface().Num() - NumReservedEntities - GetEntityStorageInterface().ComputeFreeSize();\n}\n\nint32 FMassEntityManager::DebugGetArchetypesCount() const\n{\n\treturn AllArchetypes.Num();\n}\n\nvoid FMassEntityManager::DebugRemoveAllEntities()\n{\n\tfor (int EntityIndex = NumReservedEntities, EndIndex = GetEntityStorageInterface().Num(); EntityIndex < EndIndex; ++EntityIndex)\n\t{\n\t\tif (GetEntityStorageInterface().IsValid(EntityIndex) == false)\n\t\t{\n\t\t\t// already dead\n\t\t\tcontinue;\n\t\t}\n\t\tFMassArchetypeData* Archetype = GetEntityStorageInterface().GetArchetype(EntityIndex);\n\t\tcheck(Archetype);\n\t\tFMassEntityHandle Entity;\n\t\tEntity.Index = EntityIndex;\n\t\tEntity.SerialNumber = GetEntityStorageInterface().GetSerialNumber(EntityIndex);\n\t\tArchetype->RemoveEntity(Entity);\n\n\t\tGetEntityStorageInterface().ForceReleaseOne(Entity);\n\t}\n}\n\nvoid FMassEntityManager::DebugForceArchetypeDataVersionBump()\n{\n\t++ArchetypeDataVersion;\n}\n\nvoid FMassEntityManager::DebugGetArchetypeStrings(const FMassArchetypeHandle& Archetype, TArray<FName>& OutFragmentNames, TArray<FName>& OutTagNames)\n{\n\tif (Archetype.IsValid() == false)\n\t{\n\t\treturn;\n\t}\n\n\tconst FMassArchetypeData& ArchetypeRef = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(Archetype);\n\t\n\tOutFragmentNames.Reserve(ArchetypeRef.GetFragmentConfigs().Num());\n\tfor (const FMassArchetypeFragmentConfig& FragmentConfig : ArchetypeRef.GetFragmentConfigs())\n\t{\n\t\tcheckSlow(FragmentConfig.FragmentType);\n\t\tOutFragmentNames.Add(FragmentConfig.FragmentType->GetFName());\n\t}\n\n\tArchetypeRef.GetTagBitSet().DebugGetIndividualNames(OutTagNames);\n}\n\nFMassEntityHandle FMassEntityManager::DebugGetEntityIndexHandle(const int32 EntityIndex) const\n{\n\treturn GetEntityStorageInterface().IsValidIndex(EntityIndex) ? FMassEntityHandle(EntityIndex, GetEntityStorageInterface().GetSerialNumber(EntityIndex)) : FMassEntityHandle();\n}\n\nconst FString& FMassEntityManager::DebugGetName() const\n{\n\treturn DebugName;\n}\n\nFMassRequirementAccessDetector& FMassEntityManager::GetRequirementAccessDetector()\n{\n\treturn RequirementAccessDetector;\n}\n\n#endif // WITH_MASSENTITY_DEBUG\n\n\n//-----------------------------------------------------------------------------\n// DEPRECATED\n//-----------------------------------------------------------------------------\n\nconst FMassArchetypeEntityCollection& FMassEntityManager::FEntityCreationContext::GetEntityCollection() const\n{\n\tstatic FMassArchetypeEntityCollection EmptyCollection;\n\treturn EntityCollections.Num() ? EntityCollections[0] : EmptyCollection;\n}\n",
      "lines": 2091
    },
    {
      "file_path": "MassEntity\\Private\\MassEntityManagerStorage.cpp",
      "extension": ".cpp",
      "size_bytes": 20813,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEntityManagerStorage.h\"\n\n#include \"MassEntityManagerConstants.h\"\n#include \"MassEntityTypes.h\"\n#include \"Templates/SharedPointer.h\"\n\nnamespace UE::Mass\n{\n\t//-----------------------------------------------------------------------------\n\t// IEntityStorageInterface\n\t//-----------------------------------------------------------------------------\n\tint32 IEntityStorageInterface::Acquire(const int32 Count, TArray<FMassEntityHandle>& OutEntityHandles)\n\t{\n\t\tif (Count)\n\t\t{\n\t\t\tconst int32 StartingIndex = OutEntityHandles.Num();\n\t\t\tOutEntityHandles.AddZeroed(Count);\n\t\t\tconst int32 NumberAdded = Acquire(MakeArrayView(&OutEntityHandles[StartingIndex], Count));\n\t\t\tif (UNLIKELY(NumberAdded < Count))\n\t\t\t{\n\t\t\t\t// need to remove the redundantly reserved entries\n\t\t\t\tOutEntityHandles.RemoveAt(StartingIndex + NumberAdded, Count - NumberAdded, EAllowShrinking::No);\n\t\t\t}\n\t\t\treturn NumberAdded;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t//-----------------------------------------------------------------------------\n\t// FSingleThreadedEntityStorage\n\t//-----------------------------------------------------------------------------\n\n\tvoid FSingleThreadedEntityStorage::Initialize(const FMassEntityManager_InitParams_SingleThreaded&)\n\t{\n\t\t// Index 0 is reserved so we can treat that index as an invalid entity handle\n\t\tconst FMassEntityHandle SentinelEntity = AcquireOne();\n\t\tcheck(SentinelEntity.Index == UE::Mass::Private::InvalidEntityIndex);\n\t}\n\n\tFMassArchetypeData* FSingleThreadedEntityStorage::GetArchetype(int32 Index)\n\t{\n\t\treturn Entities[Index].CurrentArchetype.Get();\n\t}\n\n\tconst FMassArchetypeData* FSingleThreadedEntityStorage::GetArchetype(int32 Index) const\n\t{\n\t\treturn Entities[Index].CurrentArchetype.Get();\n\t}\n\n\tTSharedPtr<FMassArchetypeData>& FSingleThreadedEntityStorage::GetArchetypeAsShared(int32 Index)\n\t{\n\t\treturn Entities[Index].CurrentArchetype;\n\t}\n\n\tconst TSharedPtr<FMassArchetypeData>& FSingleThreadedEntityStorage::GetArchetypeAsShared(int32 Index) const\n\t{\n\t\treturn Entities[Index].CurrentArchetype;\n\t}\n\n\tvoid FSingleThreadedEntityStorage::SetArchetypeFromShared(int32 Index, TSharedPtr<FMassArchetypeData>& Archetype)\n\t{\n\t\tEntities[Index].CurrentArchetype = Archetype;\n\t}\n\n\tvoid FSingleThreadedEntityStorage::SetArchetypeFromShared(int32 Index, const TSharedPtr<FMassArchetypeData>& Archetype)\n\t{\n\t\tEntities[Index].CurrentArchetype = Archetype;\n\t}\n\n\tIEntityStorageInterface::EEntityState FSingleThreadedEntityStorage::GetEntityState(int32 Index) const\n\t{\n\t\tconst uint32 CurrentSerialNumber = Entities[Index].SerialNumber;\n\n\t\tif (CurrentSerialNumber != 0)\n\t\t{\n\t\t\treturn Entities[Index].CurrentArchetype.Get()\n\t\t\t\t? EEntityState::Created \n\t\t\t\t: EEntityState::Reserved;\n\t\t}\n\n\t\treturn EEntityState::Free;\t\n\t}\n\n\tint32 FSingleThreadedEntityStorage::GetSerialNumber(int32 Index) const\n\t{\n\t\treturn Entities[Index].SerialNumber;\n\t}\n\n\tbool FSingleThreadedEntityStorage::IsValidIndex(int32 Index) const\n\t{\n\t\treturn Entities.IsValidIndex(Index);\n\t}\n\n\tSIZE_T FSingleThreadedEntityStorage::GetAllocatedSize() const\n\t{\n\t\treturn Entities.GetAllocatedSize() + EntityFreeIndexList.GetAllocatedSize();\n\t}\n\n\tbool FSingleThreadedEntityStorage::IsValid(int32 Index) const\n\t{\n\t\treturn Entities[Index].IsValid();\n\t}\n\n\tFMassEntityHandle FSingleThreadedEntityStorage::AcquireOne()\n\t{\n\t\tconst int32 SerialNumber = SerialNumberGenerator.fetch_add(1);\n\t\tconst int32 Index = (EntityFreeIndexList.Num() > 0) ? EntityFreeIndexList.Pop(EAllowShrinking::No) : Entities.Add();\n\t\tEntities[Index].SerialNumber = SerialNumber;\n\n\t\tFMassEntityHandle Handle;\n\t\tHandle.SerialNumber = SerialNumber;\n\t\tHandle.Index = Index;\n\t\treturn Handle;\n\t}\n\n\tint32 FSingleThreadedEntityStorage::Acquire(TArrayView<FMassEntityHandle> OutEntityHandles)\n\t{\n\t\tconst int32 NumToAdd = OutEntityHandles.Num();\n\n\t\tconst int32 SerialNumber = SerialNumberGenerator.fetch_add(1);\n\n\t\tint32 NumAdded = 0;\n\t\tint32 CurrentEntityHandleIndex = 0;\n\n\t\tconst int32 NumAvailableFromFreeList = FMath::Min(NumToAdd, EntityFreeIndexList.Num());\n\t\tif (NumAvailableFromFreeList > 0)\n\t\t{\n\t\t\tconst int32 FirstIndexToUse = EntityFreeIndexList.Num() - NumAvailableFromFreeList;\n\t\t\tfor (int32 Index = FirstIndexToUse; Index < EntityFreeIndexList.Num(); ++Index)\n\t\t\t{\n\t\t\t\tconst int32 EntityIndex = EntityFreeIndexList[Index];\n\t\t\t\tEntities[EntityIndex].SerialNumber = SerialNumber;\n\t\t\t\tOutEntityHandles[CurrentEntityHandleIndex++] = { EntityIndex, SerialNumber };\n\t\t\t}\n\t\t\tEntityFreeIndexList.RemoveAt(FirstIndexToUse, NumAvailableFromFreeList, EAllowShrinking::No);\n\t\t\tNumAdded = NumAvailableFromFreeList;\n\t\t}\n\n\t\tif (NumAdded < NumToAdd)\n\t\t{\n\t\t\tconst int32 RemainingCount = NumToAdd - NumAdded;\n\t\t\tconst int32 StartingIndex = Entities.Num();\n\t\t\tEntities.Add(RemainingCount);\n\t\t\tfor (int32 EntityIndex = StartingIndex; EntityIndex < Entities.Num(); ++EntityIndex)\n\t\t\t{\n\t\t\t\tEntities[EntityIndex].SerialNumber = SerialNumber;\n\t\t\t\tOutEntityHandles[CurrentEntityHandleIndex++] = { EntityIndex, SerialNumber };\n\t\t\t}\n\t\t\tNumAdded += RemainingCount;\n\t\t}\n\n\t\treturn NumAdded;\n\t}\n\n\tint32 FSingleThreadedEntityStorage::Release(TConstArrayView<FMassEntityHandle> Handles)\n\t{\n\t\tint DeallocateCount = 0;\n\n\t\tEntityFreeIndexList.Reserve(EntityFreeIndexList.Num() + Handles.Num());\n\n\t\tfor (const FMassEntityHandle& Handle : Handles)\n\t\t{\n\t\t\tFEntityData& EntityData = Entities[Handle.Index];\n\t\t\tif (EntityData.SerialNumber == Handle.SerialNumber)\n\t\t\t{\n\t\t\t\tEntityData.Reset();\n\t\t\t\tEntityFreeIndexList.Add(Handle.Index);\n\t\t\t\t++DeallocateCount;\n\t\t\t}\n\t\t}\n\t\n\t\treturn DeallocateCount;\n\t}\n\n\tint32 FSingleThreadedEntityStorage::ReleaseOne(FMassEntityHandle Handle)\n\t{\n\t\treturn Release(MakeArrayView(&Handle, 1));\n\t}\n\n\tint32 FSingleThreadedEntityStorage::ForceRelease(TConstArrayView<FMassEntityHandle> Handles)\n\t{\n\t\tEntityFreeIndexList.Reserve(EntityFreeIndexList.Num() + Handles.Num());\n\t\tfor (const FMassEntityHandle& Handle : Handles)\n\t\t{\n\t\t\tFEntityData& EntityData = Entities[Handle.Index];\n\t\t\tEntityData.Reset();\n\t\t\tEntityFreeIndexList.Add(Handle.Index);\n\t\t}\n\t\treturn Handles.Num();\n\t}\n\n\tint32 FSingleThreadedEntityStorage::ForceReleaseOne(FMassEntityHandle Handle)\n\t{\n\t\treturn ForceRelease(MakeArrayView(&Handle, 1));\n\t}\n\n\tint32 FSingleThreadedEntityStorage::Num() const\n\t{\n\t\treturn Entities.Num();\n\t}\n\n\tint32 FSingleThreadedEntityStorage::ComputeFreeSize() const\n\t{\n\t\treturn EntityFreeIndexList.Num();\n\t}\n\n\t//-----------------------------------------------------------------------------\n\t// FSingleThreadedEntityStorage::FEntityData\n\t//-----------------------------------------------------------------------------\n\n\tFSingleThreadedEntityStorage::FEntityData::~FEntityData() = default;\n\n\tvoid FSingleThreadedEntityStorage::FEntityData::Reset()\n\t{\n\t\tCurrentArchetype.Reset();\n\t\tSerialNumber = 0;\n\t}\n\n\tbool FSingleThreadedEntityStorage::FEntityData::IsValid() const\n\t{\n\t\treturn SerialNumber != 0 && CurrentArchetype.IsValid();\n\t}\n\n\t//-----------------------------------------------------------------------------\n\t// FConcurrentEntityStorage\n\t//-----------------------------------------------------------------------------\n\n\tvoid FConcurrentEntityStorage::Initialize(const FMassEntityManager_InitParams_Concurrent& InInitializationParams)\n\t{\n\t\t// Compute number of pages required\n\t\tcheck(FMath::IsPowerOfTwo(InInitializationParams.MaxEntitiesPerPage));\n\t\tcheck(FMath::IsPowerOfTwo(InInitializationParams.MaxEntityCount));\n\t\tMaxEntitiesPerPage = InInitializationParams.MaxEntitiesPerPage;\n\t\tMaximumEntityCountShift = FMath::FloorLog2(InInitializationParams.MaxEntityCount);\n\t\tcheckf(MaximumEntityCountShift < 32, TEXT(\"Invalid maximum entity count, cannot exceed 31 bits\"));\n\n\t\tconst uint64 PagePointerCount = InInitializationParams.MaxEntityCount / InInitializationParams.MaxEntitiesPerPage;\n\n\t\tconst uint64 EntityPageSize = sizeof(void*) * PagePointerCount;\n\t\tEntityPages = static_cast<FEntityData**>(FMemory::Malloc(EntityPageSize, alignof(FEntityData**)));\n\t\tFMemory::Memzero(EntityPages, EntityPageSize);\t\n\t}\n\n\tFConcurrentEntityStorage::~FConcurrentEntityStorage()\n\t{\n\t\tif (EntityPages != nullptr)\n\t\t{\n\t\t\tfor (uint32 Index = 0; Index < PageCount; ++Index)\n\t\t\t{\n\t\t\t\tFMemory::Free(EntityPages[Index]);\n\t\t\t\tEntityPages[Index] = nullptr;\n\t\t\t}\n\t\t\tFMemory::Free(EntityPages);\n\t\t\tEntityPages = nullptr;\n\t\t}\n\t}\n\n\tFMassArchetypeData* FConcurrentEntityStorage::GetArchetype(int32 Index)\n\t{\n\t\treturn LookupEntity(Index).CurrentArchetype.Get();\n\t}\n\n\tconst FMassArchetypeData* FConcurrentEntityStorage::GetArchetype(int32 Index) const\n\t{\n\t\treturn LookupEntity(Index).CurrentArchetype.Get();\n\t}\n\n\tTSharedPtr<FMassArchetypeData>& FConcurrentEntityStorage::GetArchetypeAsShared(int32 Index)\n\t{\n\t\treturn LookupEntity(Index).CurrentArchetype;\n\t}\n\n\tconst TSharedPtr<FMassArchetypeData>& FConcurrentEntityStorage::GetArchetypeAsShared(int32 Index) const\n\t{\n\t\treturn LookupEntity(Index).CurrentArchetype;\n\t}\n\n\tvoid FConcurrentEntityStorage::SetArchetypeFromShared(int32 Index, TSharedPtr<FMassArchetypeData>& Archetype)\n\t{\n\t\tLookupEntity(Index).CurrentArchetype = Archetype;\n\t}\n\n\tvoid FConcurrentEntityStorage::SetArchetypeFromShared(int32 Index, const TSharedPtr<FMassArchetypeData>& Archetype)\n\t{\n\t\tLookupEntity(Index).CurrentArchetype = Archetype;\n\t}\n\n\tIEntityStorageInterface::EEntityState FConcurrentEntityStorage::GetEntityState(int32 Index) const\n\t{\n\t\t//\n\t\t// || Archetype || bIsAllocated || Result    |\n\t\t//  |  nullptr   |      0       |  Free     |\n\t\t//  |  nullptr   |      1       |  Reserved |\n\t\t//  | !nullptr   |      1       |  Created  |\n\t\t//\n\t\n\t\tconst FEntityData& EntityData = LookupEntity(Index);\n\t\tif (EntityData.CurrentArchetype != nullptr)\n\t\t{\n\t\t\treturn EEntityState::Created;\n\t\t}\n\t\treturn EntityData.bIsAllocated\n\t\t\t? EEntityState::Reserved\n\t\t\t: EEntityState::Free;\n\t}\n\n\tint32 FConcurrentEntityStorage::GetSerialNumber(int32 Index) const\n\t{\n\t\treturn LookupEntity(Index).GenerationId;\n\t}\n\n\tbool FConcurrentEntityStorage::IsValidIndex(int32 Index) const\n\t{\n\t\t// Page Index is which page in the array of pages we need to access\n\t\tif (Index >= 0)\n\t\t{\n\t\t\tconst uint32 PageIndex = static_cast<uint32>(Index) >> FMath::FloorLog2(MaxEntitiesPerPage);\n\t\t\treturn PageIndex < PageCount;\n\t\t}\n\t\treturn false;\n\t}\n\n\tSIZE_T FConcurrentEntityStorage::GetAllocatedSize() const\n\t{\n\t\tconst SIZE_T EntityFreeListSizeBytes = EntityFreeIndexList.GetAllocatedSize();\n\n\t\t// Allocated size to pages\n\t\tconst SIZE_T PageSizeBytes = ComputePageSize();\n\t\tconst SIZE_T PageAllocatedSizeBytes = PageCount * PageSizeBytes;\n\n\t\t// Size of page pointer array\n\t\tconst uint32 MaxEntities = 1 << MaximumEntityCountShift;\n\t\tconst uint32 MagPageCount = (MaxEntities / MaxEntitiesPerPage);\n\t\tconst SIZE_T PagePointerArraySizeBytes = MagPageCount * sizeof(FEntityData**);\n\t\n\t\treturn PageAllocatedSizeBytes + PagePointerArraySizeBytes + EntityFreeListSizeBytes;\n\t}\n\n\tbool FConcurrentEntityStorage::IsValid(int32 Index) const\n\t{\n\t\treturn LookupEntity(Index).CurrentArchetype != nullptr;\n\t}\n\n\tbool FConcurrentEntityStorage::AddPage()\n\t{\n\t\tcheck(FreeListMutex.IsLocked());\n\t\tUE::TUniqueLock PageAllocateLock(PageAllocateMutex);\n\n\t\t// Allocate new page\n\t\tconst uint32 NewPageIndex = PageCount;\n\t\tcheckf((NewPageIndex + 1) * MaxEntitiesPerPage < (1llu << MaximumEntityCountShift), TEXT(\"Exhausted number of entities\"));\n\n\t\tconst uint64 PageSize = ComputePageSize();\n\t\tFEntityData* Page = static_cast<FEntityData*>(FMemory::Malloc(PageSize, alignof(FEntityData)));\n\t\t\n\t\tif (Page == nullptr)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t/*for (int32 Index = 0, End = MaxEntitiesPerPage; Index < End; ++Index)\n\t\t{\n\t\t\tnew (Page + Index) FEntityData();\n\t\t}*/\n\t\tFMemory::Memzero(Page, PageSize);\n\n\t\tEntityPages[PageCount] = Page;\n\t\t++PageCount;\n\n\t\t// Somewhat tricksy thing here to be aware of\n\t\t// MassEntityManager expects the very first allocated entity to be at index 0\n\t\tstatic_assert(UE::Mass::Private::InvalidEntityIndex == 0, \"Free Entity list algorithm depends on InvalidEntityIndex being 0\");\n\t\tint32 NewEntityIndexStart;\n\t\tif (LIKELY(NewPageIndex != 0))\n\t\t{\n\t\t\tNewEntityIndexStart = NewPageIndex * MaxEntitiesPerPage;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNewEntityIndexStart = 1;\n\t\t\t// Allocate the 0th entity. It will always be the sentinel entity that InvalidEntityIndex points to.\n\t\t\tFEntityData* SentinelEntity = new (Page + UE::Mass::Private::InvalidEntityIndex) FEntityData();\n\t\t\tSentinelEntity->bIsAllocated = 1;\n\t\t\t++SentinelEntity->GenerationId;\n\t\t}\n\t\t\n\t\tconst int32 NewEntityIndexEnd = (NewPageIndex + 1) * MaxEntitiesPerPage;\n\n\t\tEntityFreeIndexList.Reserve(NewEntityIndexEnd - NewEntityIndexStart);\n\n\t\t// Push free entities indices onto the stack backwards so new entities pop off in order\n\t\tfor (int32 NewEntityIndex = NewEntityIndexEnd - 1; NewEntityIndex >= NewEntityIndexStart; --NewEntityIndex)\n\t\t{\n\t\t\t// Setup the free list\n\t\t\tEntityFreeIndexList.Push(NewEntityIndex);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tFMassEntityHandle FConcurrentEntityStorage::AcquireOne()\n\t{\n\t\tint32 EntityIndex;\n\t\t{\n\t\t\tUE::TUniqueLock FreeListLock(FreeListMutex);\n\t\t\n\t\t\tif (UNLIKELY(EntityFreeIndexList.IsEmpty()))\n\t\t\t{\n\t\t\t\tAddPage();\n\t\t\t}\n\n\t\t\tEntityIndex = EntityFreeIndexList.Pop(EAllowShrinking::No);\n\t\t}\n\n\t\tFEntityData& EntityData = LookupEntity(EntityIndex);\n\t\t// NOTE: Technically should not be necessary, however FEntityHandle::IsValid() makes the assumption\n\t\t// that SerialNum == 0 means an invalid Entity.  FMassArchetypeEntityCollection uses this assumption\n\t\t// and will fail IsValid() checks otherwise.\n\t\t++EntityData.GenerationId;\n\t\tEntityData.bIsAllocated = 1;\n\t\tint32 SerialNumber = EntityData.GetSerialNumber();\n\n\t\tEntityCount.fetch_add(1llu);\n\t\n\t\tFMassEntityHandle Handle;\n\t\tHandle.SerialNumber = SerialNumber;\n\t\tHandle.Index = EntityIndex;\n\t\treturn Handle;\n\t}\n\n\tint32 FConcurrentEntityStorage::Acquire(TArrayView<FMassEntityHandle> OutEntityHandles)\n\t{\n\t\tconst int32 NumberToAdd = OutEntityHandles.Num();\n\n\t\tint32 CountAdded = 0;\n\t\tint32 CountLeft = NumberToAdd;\n\t\tint32 CurrentEntityHandleIndex = 0;\n\n\t\twhile (CountLeft > 0)\n\t\t{\n\t\t\tUE::TUniqueLock FreeListLock(FreeListMutex);\n\n\t\t\tif (UNLIKELY(EntityFreeIndexList.IsEmpty()))\n\t\t\t{\n\t\t\t\tif (AddPage() == false)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst int32 CountToProcess = FMath::Min(CountLeft, EntityFreeIndexList.Num());\n\n\t\t\tfor (int32 Iteration = 0; Iteration < CountToProcess; ++Iteration)\n\t\t\t{\n\t\t\t\tconst int32 EntityIndex = EntityFreeIndexList.Pop(EAllowShrinking::No);\n\n\t\t\t\tFEntityData& EntityData = LookupEntity(EntityIndex);\n\t\t\t\t// NOTE: Technically should not be necessary, however FEntityHandle::IsValid() makes the assumption\n\t\t\t\t// that SerialNum == 0 means an invalid Entity.  FMassArchetypeEntityCollection uses this assumption\n\t\t\t\t// and will fail IsValid() checks otherwise.\n\t\t\t\t++EntityData.GenerationId;\n\t\t\t\tEntityData.bIsAllocated = 1;\n\t\t\t\tconst int32 SerialNumber = EntityData.GetSerialNumber();\n\n\t\t\t\tOutEntityHandles[CurrentEntityHandleIndex++] = { EntityIndex, SerialNumber };\n\t\t\t}\n\t\t\t\n\t\t\tCountAdded += CountToProcess;\n\t\t\tCountLeft -= CountToProcess;\n\t\t}\n\n\t\tEntityCount.fetch_add(CountAdded);\n\n\t\treturn CountAdded;\n\t}\n\n\tint32 FConcurrentEntityStorage::Release(TConstArrayView<FMassEntityHandle> Handles)\n\t{\n\t\tint32 DeallocateCount = 0;\n\t\n\t\tint32 BeginHandlesIndexToFree = 0;\n\t\tint32 AllocatedRunLength = 0;\n\n\t\t// Helper to add a range of handles to the EntityFreeIndexList\n\t\tauto FreeRunOfHandles = [this, &BeginHandlesIndexToFree, &AllocatedRunLength, Handles]()\n\t\t{\n\t\t\tif (AllocatedRunLength > 0) // Cheaper than taking the lock for each in case of runs of unallocated handles\n\t\t\t{\n\t\t\t\tUE::TUniqueLock FreeListLock(FreeListMutex);\n\t\t\t\tEntityFreeIndexList.Reserve(EntityFreeIndexList.Num() + AllocatedRunLength);\n\t\t\t\tfor (int32 IndexToFree = BeginHandlesIndexToFree; IndexToFree < BeginHandlesIndexToFree + AllocatedRunLength; ++IndexToFree)\n\t\t\t\t{\n\t\t\t\t\tconst FMassEntityHandle& HandleToFree = Handles[IndexToFree];\n\t\t\t\t\tEntityFreeIndexList.Add(HandleToFree.Index);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBeginHandlesIndexToFree += (AllocatedRunLength + 1); // +1 to skip to next iteration\n\t\t\tAllocatedRunLength = 0;\n\t\t};\n\t\n\t\tfor (int32 Index = 0, End = Handles.Num(); Index < End; ++Index)\n\t\t{\n\t\t\tconst FMassEntityHandle& Handle = Handles[Index];\n\t\t\tFEntityData& EntityData = LookupEntity(Handle.Index);\n\t\t\tif (EntityData.GetSerialNumber() == Handle.SerialNumber)\n\t\t\t{\n\t\t\t\t++AllocatedRunLength;\n\t\t\t\n\t\t\t\t++EntityData.GenerationId;\n\t\t\t\tEntityData.bIsAllocated = 0;\n\t\t\t\tEntityData.CurrentArchetype.Reset();\n\t\t\t\n\t\t\t\t++DeallocateCount;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Skip, this one isn't allocated\n\t\t\t\t// Return the last run to the free list\n\t\t\t\t// Ideally this code never runs but we cannot control what is passed into the Release() function\n\t\t\t\tFreeRunOfHandles();\n\t\t\t}\n\t\t}\n\n\t\t// Free any remaining handles\n\t\tFreeRunOfHandles();\n\n\t\tEntityCount.fetch_sub(DeallocateCount);\n\t\n\t\treturn DeallocateCount;\n\t}\n\n\tint32 FConcurrentEntityStorage::ReleaseOne(FMassEntityHandle Handle)\n\t{\n\t\treturn Release(MakeArrayView(&Handle, 1));\n\t}\n\n\tint32 FConcurrentEntityStorage::ForceRelease(TConstArrayView<FMassEntityHandle> Handles)\n\t{\n\t\t// ForceRelease assumes the caller knows all handles are allocated\n\t\t// no need to have complexity of tracking \"runs\" of handles \n\t\tfor (const FMassEntityHandle& Handle : Handles)\n\t\t{\n\t\t\tFEntityData& EntityData = LookupEntity(Handle.Index);\n\n\t\t\t++EntityData.GenerationId;\n\t\t\tEntityData.bIsAllocated = 0;\n\t\t\tEntityData.CurrentArchetype.Reset();\n\t\t}\n\n\t\t{\n\t\t\tUE::TUniqueLock FreeListLock(FreeListMutex);\n\t\t\tEntityFreeIndexList.Reserve(EntityFreeIndexList.Num() + Handles.Num());\n\t\t\tfor (const FMassEntityHandle& Handle : Handles)\n\t\t\t{\n\t\t\t\tEntityFreeIndexList.Add(Handle.Index);\n\t\t\t}\n\t\t}\n\n\t\tEntityCount.fetch_sub(Handles.Num());\n\t\n\t\treturn Handles.Num();\n\t}\n\n\tint32 FConcurrentEntityStorage::ForceReleaseOne(FMassEntityHandle Handle)\n\t{\n\t\treturn ForceRelease(MakeArrayView(&Handle, 1));\n\t}\n\n\tint32 FConcurrentEntityStorage::Num() const\n\t{\n\t\treturn MaxEntitiesPerPage * PageCount;;\n\t}\n\n\tint32 FConcurrentEntityStorage::ComputeFreeSize() const\n\t{\n\t\treturn EntityFreeIndexList.Num();\n\t}\n\n\tFConcurrentEntityStorage::FEntityData& FConcurrentEntityStorage::LookupEntity(int32 Index)\n\t{\n\t\tcheck(Index >= 0);\n\t\t// PageIndex is which Page in the array of pages we need to access\n\t\tconst uint32 PageIndex = static_cast<uint32>(Index) >> FMath::FloorLog2(MaxEntitiesPerPage);\n\n\t\t// Convert the entity index into the index with respect to the page\n\t\tconst uint32 EntityOffset = (PageIndex * MaxEntitiesPerPage);\n\t\tcheck(Index >= static_cast<int32>(EntityOffset)); // Check against negative values\n\t\tconst uint32 InternalPageIndex = static_cast<uint32>(Index) - EntityOffset;\n\n\t\t// Pointer to start of page\n\t\tFEntityData* PageStart = EntityPages[PageIndex];\n\t\tFEntityData& EntityData = PageStart[InternalPageIndex];\n\t\treturn EntityData;\n\t}\n\n\tconst FConcurrentEntityStorage::FEntityData& FConcurrentEntityStorage::LookupEntity(int32 Index) const\n\t{\n\t\treturn const_cast<FConcurrentEntityStorage*>(this)->LookupEntity(Index);\n\t}\n\n\tuint64 FConcurrentEntityStorage::ComputePageSize() const\n\t{\n\t\treturn sizeof(FEntityData) * MaxEntitiesPerPage;\n\t}\n\n#if WITH_MASSENTITY_DEBUG\n\tbool FConcurrentEntityStorage::DebugAssumptionsSelfTest()\n\t{\n\t\t// future proofing in case FEntityData's or TSharedPtr's internals change and make MemZero-ing not produce \n\t\t// the same results as default FEntityData's constructor\n\t\tFEntityData DefaultData;\n\t\tFEntityData ZeroedData;\n\t\tFMemory::Memzero(&ZeroedData, sizeof(FEntityData));\n\n\t\tif (DefaultData != ZeroedData)\n\t\t{\n\t\t\tUE_LOG(LogMass, Error, TEXT(\"%hs assumption about default FEntityData values is no longer true.\"), __FUNCTION__);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n#endif // WITH_MASSENTITY_DEBUG\n\n\t//-----------------------------------------------------------------------------\n\t// FConcurrentEntityStorage::FEntityData\n\t//-----------------------------------------------------------------------------\n\tFConcurrentEntityStorage::FEntityData::~FEntityData() = default;\n\n\tint32 FConcurrentEntityStorage::FEntityData::GetSerialNumber() const\n\t{\n\t\treturn static_cast<int32>(GenerationId);\n\t}\n\n\tbool FConcurrentEntityStorage::FEntityData::operator==(const FEntityData& Other) const\n\t{\n\t\treturn CurrentArchetype == Other.CurrentArchetype\n\t\t\t&& GenerationId == Other.GenerationId\n\t\t\t&& bIsAllocated == Other.bIsAllocated;\n\t}\n}\n",
      "lines": 643
    },
    {
      "file_path": "MassEntity\\Private\\MassEntityModule.cpp",
      "extension": ".cpp",
      "size_bytes": 838,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Modules/ModuleInterface.h\"\n#include \"MassEntityTypes.h\"\n#include \"MassProcessingTypes.h\"\n#include \"Modules/ModuleManager.h\"\n\n#define LOCTEXT_NAMESPACE \"Mass\"\n\nclass FMassEntityModule : public IModuleInterface\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n};\n\nIMPLEMENT_MODULE(FMassEntityModule, MassEntity)\n\nvoid FMassEntityModule::StartupModule()\n{\n#if WITH_UNREAL_DEVELOPER_TOOLS\n\tFModuleManager::Get().LoadModule(\"MassEntityTestSuite\");\n#endif // WITH_UNREAL_DEVELOPER_TOOLS\n\n#if MASS_DO_PARALLEL\n\tUE_LOG(LogMass, Log, TEXT(\"MassEntity running with MULTITHREADING support.\"));\n#else\n\tUE_LOG(LogMass, Log, TEXT(\"MassEntity running in game thread.\"));\n#endif // MASS_DO_PARALLEL\n}\n\n#undef LOCTEXT_NAMESPACE \n",
      "lines": 31
    },
    {
      "file_path": "MassEntity\\Private\\MassEntityQuery.cpp",
      "extension": ".cpp",
      "size_bytes": 19729,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEntityQuery.h\"\n#include \"MassDebugger.h\"\n#include \"MassEntityManager.h\"\n#include \"MassArchetypeData.h\"\n#include \"MassCommandBuffer.h\"\n#include \"MassExecutionContext.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"Async/ParallelFor.h\"\n#include \"Containers/UnrealString.h\"\n#include \"MassProcessor.h\"\n#include \"MassProcessorDependencySolver.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(MassEntityQuery)\n\n#if WITH_MASSENTITY_DEBUG\n#include \"MassRequirementAccessDetector.h\"\n#endif // WITH_MASSENTITY_DEBUG\n\n\nnamespace UE::Mass::Tweakables\n{\n\t/**\n\t * Controls whether ParallelForEachEntityChunk actually performs ParallelFor operations. If `false` the call is passed\n\t * the the regular ForEachEntityChunk call.\n\t */\n\tbool bAllowParallelExecution = true;\n\n\tnamespace\n\t{\n\t\tstatic FAutoConsoleVariableRef AnonymousCVars[] = {\n\t\t\t{\tTEXT(\"mass.AllowQueryParallelFor\"), bAllowParallelExecution, TEXT(\"Controls whether EntityQueries are allowed to utilize ParallelFor construct\"), ECVF_Cheat }\n\t\t};\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// FScopedSubsystemRequirementsRestore\n//-----------------------------------------------------------------------------\nFMassEntityQuery::FScopedSubsystemRequirementsRestore::FScopedSubsystemRequirementsRestore(FMassExecutionContext& ExecutionContext)\n\t: CachedExecutionContext(ExecutionContext)\n{\n\tCachedExecutionContext.GetSubsystemRequirementBits(ConstSubsystemsBitSet, MutableSubsystemsBitSet);\n}\n\nFMassEntityQuery::FScopedSubsystemRequirementsRestore::~FScopedSubsystemRequirementsRestore()\n{\n\tCachedExecutionContext.SetSubsystemRequirementBits(ConstSubsystemsBitSet, MutableSubsystemsBitSet);\n}\n\n//-----------------------------------------------------------------------------\n// FMassEntityQuery\n//-----------------------------------------------------------------------------\nFMassEntityQuery::FMassEntityQuery()\n{\n}\n\nFMassEntityQuery::FMassEntityQuery(std::initializer_list<UScriptStruct*> InitList)\n\t: FMassEntityQuery()\n{\n\tfor (const UScriptStruct* FragmentType : InitList)\n\t{\n\t\tAddRequirement(FragmentType, EMassFragmentAccess::ReadWrite, EMassFragmentPresence::All);\n\t}\n}\n\nFMassEntityQuery::FMassEntityQuery(TConstArrayView<const UScriptStruct*> InitList)\n\t: FMassEntityQuery()\n{\n\tfor (const UScriptStruct* FragmentType : InitList)\n\t{\n\t\tAddRequirement(FragmentType, EMassFragmentAccess::ReadWrite, EMassFragmentPresence::All);\n\t}\n}\n\nFMassEntityQuery::FMassEntityQuery(UMassProcessor& Owner)\n{\n\tRegisterWithProcessor(Owner);\n}\n\nvoid FMassEntityQuery::RegisterWithProcessor(UMassProcessor& Owner)\n{\n\tExpectedContextType = EMassExecutionContextType::Processor;\n\tOwner.RegisterQuery(*this);\n#if WITH_MASSENTITY_DEBUG\n\tbRegistered = true;\n#endif // WITH_MASSENTITY_DEBUG\n}\n\nvoid FMassEntityQuery::CacheArchetypes(const FMassEntityManager& InEntityManager)\n{\n\tconst uint32 InEntityManagerHash = PointerHash(&InEntityManager);\n\n\t// Do an incremental update if the last updated archetype data version is different \n    bool bUpdateArchetypes = InEntityManager.GetArchetypeDataVersion() != LastUpdatedArchetypeDataVersion;\n\n\t// Force a full update if the entity system changed or if the requirements changed\n\tif (EntitySubsystemHash != InEntityManagerHash || HasIncrementalChanges())\n\t{\n\t\tbUpdateArchetypes = true;\n\t\tEntitySubsystemHash = InEntityManagerHash;\n\t\tValidArchetypes.Reset();\n\t\tLastUpdatedArchetypeDataVersion = 0;\n\t\tArchetypeFragmentMapping.Reset();\n\n\t\tif (HasIncrementalChanges())\n\t\t{\n\t\t\tConsumeIncrementalChangesCount();\n\t\t\tif (CheckValidity())\n\t\t\t{\n\t\t\t\tSortRequirements();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbUpdateArchetypes = false;\n\t\t\t\tUE_VLOG_UELOG(InEntityManager.GetOwner(), LogMass, Error, TEXT(\"FMassEntityQuery::CacheArchetypes: requirements not valid: %s\"), *FMassDebugger::GetRequirementsDescription(*this));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Process any new archetype that is newer than the LastUpdatedArchetypeDataVersion\n\tif (bUpdateArchetypes)\n\t{\n\t\tTArray<FMassArchetypeHandle> NewValidArchetypes;\n\t\tInEntityManager.GetMatchingArchetypes(*this, NewValidArchetypes, LastUpdatedArchetypeDataVersion);\n\t\tLastUpdatedArchetypeDataVersion = InEntityManager.GetArchetypeDataVersion();\n\t\tif (NewValidArchetypes.Num())\n\t\t{\n\t\t\tconst int32 FirstNewArchetype = ValidArchetypes.Num();\n\t\t\tValidArchetypes.Append(NewValidArchetypes);\n\n\t\t\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"Mass RequirementsBinding\")\n\t\t\tconst TConstArrayView<FMassFragmentRequirementDescription> LocalRequirements = GetFragmentRequirements();\n\t\t\tArchetypeFragmentMapping.AddDefaulted(NewValidArchetypes.Num());\n\t\t\tfor (int i = FirstNewArchetype; i < ValidArchetypes.Num(); ++i)\n\t\t\t{\n\t\t\t\tFMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ValidArchetypes[i]);\n\t\t\t\tArchetypeData.GetRequirementsFragmentMapping(LocalRequirements, ArchetypeFragmentMapping[i].EntityFragments);\n\t\t\t\tif (ChunkFragmentRequirements.Num())\n\t\t\t\t{\n\t\t\t\t\tArchetypeData.GetRequirementsChunkFragmentMapping(ChunkFragmentRequirements, ArchetypeFragmentMapping[i].ChunkFragments);\n\t\t\t\t}\n\t\t\t\tif (ConstSharedFragmentRequirements.Num())\n\t\t\t\t{\n\t\t\t\t\tArchetypeData.GetRequirementsConstSharedFragmentMapping(ConstSharedFragmentRequirements, ArchetypeFragmentMapping[i].ConstSharedFragments);\n\t\t\t\t}\n\t\t\t\tif (SharedFragmentRequirements.Num())\n\t\t\t\t{\n\t\t\t\t\tArchetypeData.GetRequirementsSharedFragmentMapping(SharedFragmentRequirements, ArchetypeFragmentMapping[i].SharedFragments);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid FMassEntityQuery::ForEachEntityChunkInCollections(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext, const FMassExecuteFunction& ExecuteFunction)\n{\n\tfor (const FMassArchetypeEntityCollection& EntityCollection : EntityCollections)\n\t{\n\t\tForEachEntityChunk(EntityCollection, EntityManager, ExecutionContext, ExecuteFunction);\n\t}\n}\n\nvoid FMassEntityQuery::ForEachEntityChunk(const FMassArchetypeEntityCollection& EntityCollection, FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext, const FMassExecuteFunction& ExecuteFunction)\n{\n\t// mz@todo I don't like that we're copying data here.\n\tExecutionContext.SetEntityCollection(EntityCollection);\n\tForEachEntityChunk(EntityManager, ExecutionContext, ExecuteFunction);\n\tExecutionContext.ClearEntityCollection();\n}\n\nvoid FMassEntityQuery::ForEachEntityChunk(FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext, const FMassExecuteFunction& ExecuteFunction)\n{\n#if WITH_MASSENTITY_DEBUG\n\tcheckf(ExecutionContext.ExecutionType == ExpectedContextType && (ExpectedContextType == EMassExecutionContextType::Local || bRegistered)\n\t\t, TEXT(\"ExecutionContextType mismatch, make sure all the queries run as part of processor execution are registered with some processor with a FMassEntityQuery::RegisterWithProcessor call\"));\n\n\tEntityManager.GetRequirementAccessDetector().RequireAccess(*this);\n#endif\n\n\tFScopedSubsystemRequirementsRestore SubsystemRestore(ExecutionContext);\n\n\tif (ExecutionContext.CacheSubsystemRequirements(*this) == false)\n\t{\n\t\t// required subsystems are not available, bail out.\n\t\treturn;\n\t}\n\n\tif (FMassFragmentRequirements::IsEmpty())\n\t{\n\t\tif (ensureMsgf(ExecutionContext.GetEntityCollection().IsSet(), TEXT(\"Using empty queries is only supported in combination with Entity Collections that explicitly indicate entities to process\")))\n\t\t{\n\t\t\tstatic const FMassQueryRequirementIndicesMapping EmptyMapping;\n\n\t\t\tconst FMassArchetypeHandle& ArchetypeHandle = ExecutionContext.GetEntityCollection().GetArchetype();\n\t\t\tFMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);\n\t\t\tArchetypeData.ExecuteFunction(ExecutionContext, ExecuteFunction\n\t\t\t\t, EmptyMapping\n\t\t\t\t, ExecutionContext.GetEntityCollection().GetRanges()\n\t\t\t\t, ChunkCondition);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// note that the following function will usually only resort to verifying that the data is up to date by\n\t\t\t// checking the version number. In rare cases when it would result in non trivial cost we actually\n\t\t\t// do need those calculations.\n\t\tCacheArchetypes(EntityManager);\n\n\t\t// if there's a chunk collection set by the external code - use that\n\t\tif (ExecutionContext.GetEntityCollection().IsSet())\n\t\t{\n\t\t\tconst FMassArchetypeHandle& ArchetypeHandle = ExecutionContext.GetEntityCollection().GetArchetype();\n\t\t\tconst int32 ArchetypeIndex = ValidArchetypes.Find(ArchetypeHandle);\n\n\t\t\t// if given ArchetypeHandle cannot be found in ValidArchetypes then it doesn't match the query's requirements\n\t\t\tif (ArchetypeIndex == INDEX_NONE)\n\t\t\t{\n\t\t\t\tUE_VLOG_UELOG(EntityManager.GetOwner(), LogMass, Log, TEXT(\"Attempted to execute FMassEntityQuery with an incompatible Archetype: %s\")\n\t\t\t\t\t, *FMassDebugger::GetArchetypeRequirementCompatibilityDescription(*this, ArchetypeHandle));\n\n#if WITH_MASSENTITY_DEBUG\n\t\t\t\tEntityManager.GetRequirementAccessDetector().ReleaseAccess(*this);\n#endif // WITH_MASSENTITY_DEBUG\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tExecutionContext.SetFragmentRequirements(*this);\n\n\t\t\tFMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);\n\t\t\tArchetypeData.ExecuteFunction(ExecutionContext, ExecuteFunction\n\t\t\t\t, GetRequirementsMappingForArchetype(ArchetypeHandle)\n\t\t\t\t, ExecutionContext.GetEntityCollection().GetRanges()\n\t\t\t\t, ChunkCondition);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// it's important to set requirements after caching archetypes due to that call potentially sorting the requirements and the order is relevant here.\n\t\t\tExecutionContext.SetFragmentRequirements(*this);\n\n\t\t\tfor (int i = 0; i < ValidArchetypes.Num(); ++i)\n\t\t\t{\n\t\t\t\tconst FMassArchetypeHandle& ArchetypeHandle = ValidArchetypes[i];\n\t\t\t\tFMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);\n\t\t\t\tArchetypeData.ExecuteFunction(ExecutionContext, ExecuteFunction, ArchetypeFragmentMapping[i], ChunkCondition);\n\t\t\t\tExecutionContext.ClearFragmentViews();\n\t\t\t}\n\t\t}\n\t}\n\n#if WITH_MASSENTITY_DEBUG\n\tEntityManager.GetRequirementAccessDetector().ReleaseAccess(*this);\n#endif\n\n\tExecutionContext.ClearExecutionData();\n\tExecutionContext.FlushDeferred();\n}\n\nvoid FMassEntityQuery::ParallelForEachEntityChunkInCollection(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections\n\t, FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext, const FMassExecuteFunction& ExecuteFunction\n\t, const EParallelForMode ParallelMode)\n{\n\tif (UE::Mass::Tweakables::bAllowParallelExecution == false && ParallelMode != ForceParallelExecution)\n\t{\n\t\tForEachEntityChunkInCollections(EntityCollections, EntityManager, ExecutionContext, ExecuteFunction);\n\t\treturn;\n\t}\n\n\tParallelFor(EntityCollections.Num(), [this, &EntityManager, &ExecutionContext, &ExecuteFunction, &EntityCollections, ParallelMode](const int32 JobIndex)\n\t{\n\t\tFMassExecutionContext LocalExecutionContext = ExecutionContext; \n\t\tLocalExecutionContext.SetEntityCollection(EntityCollections[JobIndex]);\n\t\tParallelForEachEntityChunk(EntityManager, LocalExecutionContext, ExecuteFunction, ParallelMode);\n\t});\n}\n\nvoid FMassEntityQuery::ParallelForEachEntityChunk(FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext\n\t, const FMassExecuteFunction& ExecuteFunction, const EParallelForMode ParallelMode)\n{\n\tif (UE::Mass::Tweakables::bAllowParallelExecution == false && ParallelMode != ForceParallelExecution)\n\t{\n\t\tForEachEntityChunk(EntityManager, ExecutionContext, ExecuteFunction);\n\t\treturn;\n\t}\n\n#if WITH_MASSENTITY_DEBUG\n\tcheckf(ExecutionContext.ExecutionType == ExpectedContextType && (ExpectedContextType == EMassExecutionContextType::Local || bRegistered)\n\t\t, TEXT(\"ExecutionContextType mismatch, make sure all the queries run as part of processor execution are registered with some processor with a FMassEntityQuery::RegisterWithProcessor call\"));\n\n\tEntityManager.GetRequirementAccessDetector().RequireAccess(*this);\n#endif\n\n\tFScopedSubsystemRequirementsRestore SubsystemRestore(ExecutionContext);\n\n\tif (ExecutionContext.CacheSubsystemRequirements(*this) == false)\n\t{\n\t\t// required subsystems are not available, bail out.\n\t\treturn;\n\t}\n\n\tstruct FChunkJob\n\t{\n\t\tFMassArchetypeData& Archetype;\n\t\tconst int32 ArchetypeIndex;\n\t\tconst FMassArchetypeEntityCollection::FArchetypeEntityRange EntityRange;\n\t};\n\tTArray<FChunkJob> Jobs;\n\n\tif (FMassFragmentRequirements::IsEmpty())\n\t{\n\t\tif (ensureMsgf(ExecutionContext.GetEntityCollection().IsSet(), TEXT(\"Using empty queries is only supported in combination with Entity Collections that explicitly indicate entities to process\")))\n\t\t{\n\t\t\tconst FMassArchetypeHandle& ArchetypeHandle = ExecutionContext.GetEntityCollection().GetArchetype();\n\t\t\tFMassArchetypeData& ArchetypeRef = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);\n\t\t\tfor (const FMassArchetypeEntityCollection::FArchetypeEntityRange& EntityRange : ExecutionContext.GetEntityCollection().GetRanges())\n\t\t\t{\n\t\t\t\tJobs.Add({ ArchetypeRef, INDEX_NONE, EntityRange });\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\n\t\t// note that the following function will usualy only resort to verifying that the data is up to date by\n\t\t// checking the version number. In rare cases when it would result in non trivial cost we actually\n\t\t// do need those calculations.\n\t\tCacheArchetypes(EntityManager);\n\n\t\t// if there's a chunk collection set by the external code - use that\n\t\tif (ExecutionContext.GetEntityCollection().IsSet())\n\t\t{\n\t\t\tconst FMassArchetypeHandle& ArchetypeHandle = ExecutionContext.GetEntityCollection().GetArchetype();\n\t\t\tconst int32 ArchetypeIndex = ValidArchetypes.Find(ArchetypeHandle);\n\n\t\t\t// if given ArchetypeHandle cannot be found in ValidArchetypes then it doesn't match the query's requirements\n\t\t\tif (ArchetypeIndex == INDEX_NONE)\n\t\t\t{\n\t\t\t\tUE_VLOG_UELOG(EntityManager.GetOwner(), LogMass, Log, TEXT(\"Attempted to execute FMassEntityQuery with an incompatible Archetype: %s\")\n\t\t\t\t\t, *FMassDebugger::GetArchetypeRequirementCompatibilityDescription(*this, ExecutionContext.GetEntityCollection().GetArchetype()));\n\n#if WITH_MASSENTITY_DEBUG\n\t\t\t\tEntityManager.GetRequirementAccessDetector().ReleaseAccess(*this);\n#endif // WITH_MASSENTITY_DEBUG\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tExecutionContext.SetFragmentRequirements(*this);\n\n\t\t\tFMassArchetypeData& ArchetypeRef = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);\n\t\t\tfor (const FMassArchetypeEntityCollection::FArchetypeEntityRange& EntityRange : ExecutionContext.GetEntityCollection().GetRanges())\n\t\t\t{\n\t\t\t\tJobs.Add({ ArchetypeRef, ArchetypeIndex, EntityRange });\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tExecutionContext.SetFragmentRequirements(*this);\n\t\t\tfor (int ArchetypeIndex = 0; ArchetypeIndex < ValidArchetypes.Num(); ++ArchetypeIndex)\n\t\t\t{\n\t\t\t\tFMassArchetypeHandle& ArchetypeHandle = ValidArchetypes[ArchetypeIndex];\n\t\t\t\tFMassArchetypeData& ArchetypeRef = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);\n\t\t\t\tconst FMassArchetypeEntityCollection AsEntityCollection(ArchetypeHandle);\n\t\t\t\tfor (const FMassArchetypeEntityCollection::FArchetypeEntityRange& EntityRange : AsEntityCollection.GetRanges())\n\t\t\t\t{\n\t\t\t\t\tJobs.Add({ ArchetypeRef, ArchetypeIndex, EntityRange });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (Jobs.Num())\n\t{\n\t\tif (bAllowParallelCommands)\n\t\t{\n\t\t\tstruct FTaskContext\n\t\t\t{\n\t\t\t\tFTaskContext() = default;\n\n\t\t\t\tTSharedPtr<FMassCommandBuffer> GetCommandBuffer()\n\t\t\t\t{\n\t\t\t\t\tif (!CommandBuffer)\n\t\t\t\t\t{\n\t\t\t\t\t\t// lazily creating the command buffer to ensure we create it in the same thread it's going to be used in\n\t\t\t\t\t\tCommandBuffer = MakeShared<FMassCommandBuffer>();\n\t\t\t\t\t}\n\t\t\t\t\treturn CommandBuffer;\n\t\t\t\t}\n\t\t\tprivate:\n\t\t\t\tTSharedPtr<FMassCommandBuffer> CommandBuffer;\n\t\t\t};\n\n\t\t\tTArray<FTaskContext> TaskContext;\n\n\t\t\tParallelForWithTaskContext(TaskContext, Jobs.Num(), [this, &ExecutionContext, &ExecuteFunction, &Jobs](FTaskContext& TaskContext, const int32 JobIndex)\n\t\t\t\t{\n\t\t\t\t\tFMassExecutionContext LocalExecutionContext = ExecutionContext;\n\n\t\t\t\t\tLocalExecutionContext.SetDeferredCommandBuffer(TaskContext.GetCommandBuffer());\n\n\t\t\t\t\tJobs[JobIndex].Archetype.ExecutionFunctionForChunk(LocalExecutionContext, ExecuteFunction\n\t\t\t\t\t\t, Jobs[JobIndex].ArchetypeIndex != INDEX_NONE ? ArchetypeFragmentMapping[Jobs[JobIndex].ArchetypeIndex] : FMassQueryRequirementIndicesMapping()\n\t\t\t\t\t\t, Jobs[JobIndex].EntityRange\n\t\t\t\t\t\t, ChunkCondition);\n\t\t\t\t});\n\n\t\t\t// merge all command buffers\n\t\t\tfor (FTaskContext& CommandContext : TaskContext)\n\t\t\t{\n\t\t\t\tExecutionContext.Defer().MoveAppend(*CommandContext.GetCommandBuffer());\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tParallelFor(Jobs.Num(), [this, &ExecutionContext, &ExecuteFunction, &Jobs](const int32 JobIndex)\n\t\t\t\t{\n\t\t\t\t\tFMassExecutionContext LocalExecutionContext = ExecutionContext;\n\t\t\t\t\tJobs[JobIndex].Archetype.ExecutionFunctionForChunk(LocalExecutionContext, ExecuteFunction\n\t\t\t\t\t\t, Jobs[JobIndex].ArchetypeIndex != INDEX_NONE ? ArchetypeFragmentMapping[Jobs[JobIndex].ArchetypeIndex] : FMassQueryRequirementIndicesMapping()\n\t\t\t\t\t\t, Jobs[JobIndex].EntityRange\n\t\t\t\t\t\t, ChunkCondition);\n\t\t\t\t});\n\t\t}\n\t}\n\n#if WITH_MASSENTITY_DEBUG\n\tEntityManager.GetRequirementAccessDetector().ReleaseAccess(*this);\n#endif\n\n\tExecutionContext.ClearExecutionData();\n\tExecutionContext.FlushDeferred();\n}\n\nint32 FMassEntityQuery::GetNumMatchingEntities(FMassEntityManager& InEntityManager)\n{\n\tCacheArchetypes(InEntityManager);\n\tint32 TotalEntities = 0;\n\tfor (FMassArchetypeHandle& ArchetypeHandle : ValidArchetypes)\n\t{\n\t\tif (const FMassArchetypeData* Archetype = FMassArchetypeHelper::ArchetypeDataFromHandle(ArchetypeHandle))\n\t\t{\n\t\t\tTotalEntities += Archetype->GetNumEntities();\n\t\t}\n\t}\n\treturn TotalEntities;\n}\n\nint32 FMassEntityQuery::GetNumMatchingEntities(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections)\n{\n\tint32 TotalEntities = 0;\n\tfor (const FMassArchetypeEntityCollection& EntityCollection : EntityCollections)\n\t{\n\t\tif (DoesArchetypeMatchRequirements(EntityCollection.GetArchetype()))\n\t\t{\n\t\t\tfor (const FMassArchetypeEntityCollection::FArchetypeEntityRange& EntityRange : EntityCollection.GetRanges())\n\t\t\t{\n\t\t\t\tTotalEntities += EntityRange.Length;\n\t\t\t}\n\t\t}\n\t}\n\treturn TotalEntities;\n}\n\nbool FMassEntityQuery::HasMatchingEntities(FMassEntityManager& InEntityManager)\n{\n\tCacheArchetypes(InEntityManager);\n\n\tfor (FMassArchetypeHandle& ArchetypeHandle : ValidArchetypes)\n\t{\n\t\tconst FMassArchetypeData* Archetype = FMassArchetypeHelper::ArchetypeDataFromHandle(ArchetypeHandle);\n\t\tif (Archetype && Archetype->GetNumEntities() > 0)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nconst FMassQueryRequirementIndicesMapping& FMassEntityQuery::GetRequirementsMappingForArchetype(const FMassArchetypeHandle ArchetypeHandle) const\n{\n\tstatic const FMassQueryRequirementIndicesMapping FallbackEmptyMapping;\n\tcheckf(HasIncrementalChanges() == false, TEXT(\"Fetching cached fragments mapping while the query's cached data is out of sync!\"));\n\tconst int32 ArchetypeIndex = ValidArchetypes.Find(ArchetypeHandle);\n\treturn ArchetypeIndex != INDEX_NONE ? ArchetypeFragmentMapping[ArchetypeIndex] : FallbackEmptyMapping;\n}\n\nvoid FMassEntityQuery::ExportRequirements(FMassExecutionRequirements& OutRequirements) const\n{\n\tFMassSubsystemRequirements::ExportRequirements(OutRequirements);\n\tFMassFragmentRequirements::ExportRequirements(OutRequirements);\n}\n",
      "lines": 491
    },
    {
      "file_path": "MassEntity\\Private\\MassEntitySettings.cpp",
      "extension": ".cpp",
      "size_bytes": 7928,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEntitySettings.h\"\n#include \"MassProcessingPhaseManager.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"UObject/UObjectHash.h\"\n#include \"Misc/CoreDelegates.h\"\n#include \"MassArchetypeData.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(MassEntitySettings)\n\n#if WITH_EDITOR\n#include \"ObjectEditorUtils.h\"\n#include \"CoreGlobals.h\"\n#endif // WITH_EDITOR\n\n//----------------------------------------------------------------------//\n//  UMassEntitySettings\n//----------------------------------------------------------------------//\nUMassEntitySettings::UMassEntitySettings(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n\tfor (int i = 0; i < (int)EMassProcessingPhase::MAX; ++i)\n\t{\n\t\tProcessingPhasesConfig[i].PhaseName = *UEnum::GetDisplayValueAsText(EMassProcessingPhase(i)).ToString();\n\t}\n\n\tFCoreDelegates::OnPostEngineInit.AddUObject(this, &UMassEntitySettings::OnPostEngineInit);\n}\n\nvoid UMassEntitySettings::PostInitProperties()\n{\n\tSuper::PostInitProperties();\n\tChunkMemorySize = UE::Mass::SanitizeChunkMemorySize(ChunkMemorySize);\n}\n\nvoid UMassEntitySettings::BeginDestroy()\n{\n\tFCoreDelegates::OnPostEngineInit.RemoveAll(this);\n\tSuper::BeginDestroy();\n}\n\nvoid UMassEntitySettings::OnPostEngineInit()\n{\n\tbEngineInitialized = true;\n\tBuildProcessorListAndPhases();\n}\n\nvoid UMassEntitySettings::BuildProcessorListAndPhases()\n{\n\tif (bInitialized == true || bEngineInitialized == false)\n\t{\n\t\treturn;\n\t}\n\n\tBuildProcessorList();\n\tBuildPhases();\n\tbInitialized = true;\n\n\tOnInitializedEvent.Broadcast();\n}\n\nvoid UMassEntitySettings::BuildPhases()\n{\n#if WITH_EDITOR\n\tif (GIsEditor)\n\t{\n\t\tfor (int i = 0; i < int(EMassProcessingPhase::MAX); ++i)\n\t\t{\n\t\t\tFMassProcessingPhaseConfig& PhaseConfig = ProcessingPhasesConfig[i];\n\t\t\tPhaseConfig.PhaseProcessor = NewObject<UMassCompositeProcessor>(this, PhaseConfig.PhaseGroupClass\n\t\t\t\t, *FString::Printf(TEXT(\"ProcessingPhase_%s\"), *PhaseConfig.PhaseName.ToString()));\n\t\t\tPhaseConfig.PhaseProcessor->SetGroupName(PhaseConfig.PhaseName);\n\t\t\tPhaseConfig.PhaseProcessor->SetProcessingPhase(EMassProcessingPhase(i));\n\t\t\tconst FString PhaseDumpDependencyGraphFileName = !DumpDependencyGraphFileName.IsEmpty() ? DumpDependencyGraphFileName + TEXT(\"_\") + PhaseConfig.PhaseName.ToString() : FString();\n\n\t\t\tFMassProcessorDependencySolver::FResult Result;\n\t\t\tResult.DependencyGraphFileName = PhaseDumpDependencyGraphFileName;\n\t\t\tFMassPhaseProcessorConfigurationHelper Configurator(*PhaseConfig.PhaseProcessor, PhaseConfig, *this, EMassProcessingPhase(i));\n\t\t\tConfigurator.bInitializeCreatedProcessors = false;\n\t\t\tConfigurator.bIsGameRuntime = false;\n\t\t\tConfigurator.Configure({}, EProcessorExecutionFlags::All, /*EntityManager=*/nullptr, &Result);\n\n\t\t\tif (Result.PrunedProcessorClasses.Num() > 0)\n\t\t\t{\n\t\t\t\tUE_VLOG_UELOG(this, LogMass, Warning, TEXT(\"Calculating dependencies for phase %s resulted in pruned processors:\")\n\t\t\t\t\t, *PhaseConfig.PhaseName.ToString());\n\t\t\t\tfor (const TSubclassOf<UMassProcessor>& ProcessorClass : Result.PrunedProcessorClasses)\n\t\t\t\t{\n\t\t\t\t\tUE_VLOG_UELOG(this, LogMass, Warning, TEXT(\"\\t%s\"), *GetNameSafe(ProcessorClass));\n\t\t\t\t}\n\t\t\t\tUE_VLOG_UELOG(this, LogMass, Warning, TEXT(\"Make sure EntityQueries owned by these processors got registered or override UMassProcessor::ShouldAllowQueryBasedPruning to return the appropriate result\"));\n\t\t\t}\n\n\t\t\tFStringOutputDevice Ar;\n\t\t\tPhaseConfig.PhaseProcessor->DebugOutputDescription(Ar);\n\t\t\tPhaseConfig.Description = FText::FromString(Ar);\n\t\t}\n\t}\n#endif // WITH_EDITOR\n}\n\nvoid UMassEntitySettings::BuildProcessorList()\n{\n\tProcessorCDOs.Reset();\n\tfor (FMassProcessingPhaseConfig& PhaseConfig : ProcessingPhasesConfig)\n\t{\n\t\tPhaseConfig.ProcessorCDOs.Reset();\n\t}\n\n\tTArray<UClass*> SubClassess;\n\tGetDerivedClasses(UMassProcessor::StaticClass(), SubClassess);\n\n\tfor (int i = SubClassess.Num() - 1; i >= 0; --i)\n\t{\n\t\tif (SubClassess[i]->HasAnyClassFlags(CLASS_Abstract))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tUMassProcessor* ProcessorCDO = GetMutableDefault<UMassProcessor>(SubClassess[i]);\n\t\t// we explicitly restrict adding UMassCompositeProcessor. If needed by specific project a derived class can be added\n\t\tif (ProcessorCDO && SubClassess[i] != UMassCompositeProcessor::StaticClass()\n#if WITH_EDITOR\n\t\t\t&& ProcessorCDO->ShouldShowUpInSettings()\n#endif // WITH_EDITOR\n\t\t)\n\t\t{\n\t\t\tProcessorCDOs.Add(ProcessorCDO);\n\t\t\tif (ProcessorCDO->ShouldAutoAddToGlobalList())\n\t\t\t{\n\t\t\t\tProcessingPhasesConfig[int(ProcessorCDO->GetProcessingPhase())].ProcessorCDOs.Add(ProcessorCDO);\n\t\t\t}\n\t\t}\n\t}\n\n\tProcessorCDOs.Sort([](UMassProcessor& LHS, UMassProcessor& RHS) {\n\t\treturn LHS.GetName().Compare(RHS.GetName()) < 0;\n\t});\n}\n\nvoid UMassEntitySettings::AddToActiveProcessorsList(TSubclassOf<UMassProcessor> ProcessorClass)\n{\n\tif (UMassProcessor* ProcessorCDO = GetMutableDefault<UMassProcessor>(ProcessorClass))\n\t{\n\t\tif (ProcessorClass == UMassCompositeProcessor::StaticClass())\n\t\t{\n\t\t\tUE_VLOG_UELOG(this, LogMass, Log, TEXT(\"%s adding MassCompositeProcessor to the global processor list is unsupported\"), ANSI_TO_TCHAR(__FUNCTION__));\n\t\t}\n\t\telse if (ProcessorClass->HasAnyClassFlags(CLASS_Abstract))\n\t\t{\n\t\t\tUE_VLOG_UELOG(this, LogMass, Log, TEXT(\"%s unable to add %s due to it being an abstract class\"), ANSI_TO_TCHAR(__FUNCTION__), *ProcessorClass->GetName());\n\t\t}\n\t\telse if (ProcessorCDOs.Find(ProcessorCDO) != INDEX_NONE)\n\t\t{\n\t\t\tUE_VLOG_UELOG(this, LogMass, Log, TEXT(\"%s already in global processor list\"), *ProcessorCDO->GetName());\n\t\t}\n\t\telse \n\t\t{\n\t\t\tensureMsgf(ProcessorCDO->ShouldAutoAddToGlobalList() == false, TEXT(\"%s missing from the global list while it's already marked to be auto-added\"), *ProcessorCDO->GetName());\n\t\t\tProcessorCDOs.Add(ProcessorCDO);\n\t\t\tProcessorCDO->SetShouldAutoRegisterWithGlobalList(true);\n\t\t}\n\t}\n}\n\nTConstArrayView<FMassProcessingPhaseConfig> UMassEntitySettings::GetProcessingPhasesConfig()\n{\n\tBuildProcessorListAndPhases();\n\treturn MakeArrayView(ProcessingPhasesConfig, int32(EMassProcessingPhase::MAX));\n}\n\n#if WITH_EDITOR\nvoid UMassEntitySettings::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)\n{\n\tstatic const FName ProcessorCDOsName = GET_MEMBER_NAME_CHECKED(UMassEntitySettings, ProcessorCDOs);\n\tstatic const FName ChunkMemorySizeName = GET_MEMBER_NAME_CHECKED(UMassEntitySettings, ChunkMemorySize);\n\n\tSuper::PostEditChangeProperty(PropertyChangedEvent);\n\n\tif (PropertyChangedEvent.ChangeType == EPropertyChangeType::ArrayAdd)\n\t{\n\t\t// ignore adding elements to arrays since it would be 'None' at first\n\t\treturn;\n\t}\n\n\tif (PropertyChangedEvent.Property)\n\t{\n\t\tconst FName PropName = PropertyChangedEvent.Property->GetFName();\n\t\tif (PropName == ProcessorCDOsName)\n\t\t{\n\t\t\tBuildProcessorList();\n\t\t}\n\t\telse if (PropName == ChunkMemorySizeName)\n\t\t{\n\t\t\tChunkMemorySize = UE::Mass::SanitizeChunkMemorySize(ChunkMemorySize);\n\t\t}\n\n\t\tBuildPhases();\n\t\tOnSettingsChange.Broadcast(PropertyChangedEvent);\n\t}\n}\n\nvoid UMassEntitySettings::PostEditChangeChainProperty(struct FPropertyChangedChainEvent& PropertyChangedEvent)\n{\n\tstatic const FName AutoRegisterName = TEXT(\"bAutoRegisterWithProcessingPhases\");\n\n\tSuper::PostEditChangeChainProperty(PropertyChangedEvent);\n\n\tFProperty* Property = PropertyChangedEvent.Property;\n\tFProperty* MemberProperty = nullptr;\n\tFEditPropertyChain::TDoubleLinkedListNode* LastPropertyNode = PropertyChangedEvent.PropertyChain.GetActiveMemberNode();\n\twhile (LastPropertyNode && LastPropertyNode->GetNextNode())\n\t{\n\t\tLastPropertyNode = LastPropertyNode->GetNextNode();\n\t}\n\n\tif (LastPropertyNode)\n\t{\n\t\tMemberProperty = LastPropertyNode->GetValue();\n\t}\n\n\tif (MemberProperty && MemberProperty->GetFName() == AutoRegisterName)\n\t{\n\t\tBuildProcessorList();\n\t}\n}\n#endif // WITH_EDITOR\n\n",
      "lines": 229
    },
    {
      "file_path": "MassEntity\\Private\\MassEntitySubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 3577,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEntitySubsystem.h\"\n#include \"HAL/IConsoleManager.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(MassEntitySubsystem)\n\nnamespace UE::Mass::Private\n{\n\tstatic bool bEnableMassConcurrentReserveRuntime = true;\n\tstatic int32 ConcurrentReserveMaxEntityCount = 1 << 27;\n\tstatic int32 ConcurrentReserveMaxEntitiesPerPage = 1 << 16;\n\n\tnamespace\n\t{\n\t\tFAutoConsoleVariableRef CVars[] = {\n\t\t\t{\n\t\t\t\tTEXT(\"Mass.ConcurrentReserve.Enable\"),\n\t\t\t\tbEnableMassConcurrentReserveRuntime,\n\t\t\t\tTEXT(\"Enable Mass's concurrent reserve feature in runtime\"),\n\t\t\t\tECVF_Default\n\t\t\t},\n\t\t\t{\n\t\t\t\tTEXT(\"Mass.ConcurrentReserve.MaxEntityCount\"),\n\t\t\t\tConcurrentReserveMaxEntityCount,\n\t\t\t\tTEXT(\"Set maximum number of permissible entities.  Must be power of 2.\"),\n\t\t\t\tECVF_Default\n\t\t\t},\n\t\t\t{\n\t\t\t\tTEXT(\"Mass.ConcurrentReserve.EntitiesPerPage\"),\n\t\t\t\tConcurrentReserveMaxEntitiesPerPage,\n\t\t\t\tTEXT(\"Set number of entities per page. Must be power of 2. Larger reduces fixed memory overhead of FEntityData page lookup but requires bigger contiguous memory blocks per page\"),\n\t\t\t\tECVF_Default\n\t\t\t}\n\t\t};\n\t}\n}\n//////////////////////////////////////////////////////////////////////\n// UMassEntitySubsystem\n\nUMassEntitySubsystem::UMassEntitySubsystem()\n\t: EntityManager(MakeShareable(new FMassEntityManager(this)))\n{\n\t\n}\n\nvoid UMassEntitySubsystem::GetResourceSizeEx(FResourceSizeEx& CumulativeResourceSize)\n{\n\tSuper::GetResourceSizeEx(CumulativeResourceSize);\n\tEntityManager->GetResourceSizeEx(CumulativeResourceSize);\n}\n\nvoid UMassEntitySubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tSuper::Initialize(Collection);\n\n\tFMassEntityManagerStorageInitParams InitializationParams;\n\t\n\tif (UE::Mass::Private::bEnableMassConcurrentReserveRuntime)\n\t{\n\t\tInitializationParams.Emplace<FMassEntityManager_InitParams_Concurrent>(\n\t\t\tFMassEntityManager_InitParams_Concurrent\n\t\t\t{\n\t\t\t\t.MaxEntityCount = static_cast<uint32>(UE::Mass::Private::ConcurrentReserveMaxEntityCount),\n\t\t\t\t.MaxEntitiesPerPage = static_cast<uint32>(UE::Mass::Private::ConcurrentReserveMaxEntitiesPerPage)\n\t\t\t});\n\t}\n\telse\n\t{\n\t\tInitializationParams.Emplace<FMassEntityManager_InitParams_SingleThreaded>();\n\t}\n\t\n\tEntityManager->Initialize(InitializationParams);\n\tHandleLateCreation();\n}\n\nvoid UMassEntitySubsystem::PostInitialize()\n{\n\tSuper::PostInitialize();\n\t// this needs to be done after all the subsystems have been initialized since some processors might want to access\n\t// them during processors' initialization\n\tEntityManager->PostInitialize();\n}\n\nvoid UMassEntitySubsystem::Deinitialize()\n{\n\tEntityManager->Deinitialize();\n\tEntityManager.Reset();\n\tSuper::Deinitialize();\n}\n\n#if WITH_MASSENTITY_DEBUG\n//////////////////////////////////////////////////////////////////////\n// Debug commands\n\nFAutoConsoleCommandWithWorldArgsAndOutputDevice GPrintArchetypesCmd(\n\tTEXT(\"EntityManager.PrintArchetypes\"),\n\tTEXT(\"Prints information about all archetypes in the current world\"),\n\tFConsoleCommandWithWorldArgsAndOutputDeviceDelegate::CreateStatic(\n\t\t[](const TArray<FString>& Params, UWorld* World, FOutputDevice& Ar)\n\t\t{\n\t\t\tif (const UMassEntitySubsystem* EntitySubsystem = World ? World->GetSubsystem<UMassEntitySubsystem>() : nullptr)\n\t\t\t{\n\t\t\t\tEntitySubsystem->GetEntityManager().DebugPrintArchetypes(Ar);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAr.Logf(ELogVerbosity::Error, TEXT(\"Failed to find Entity Subsystem for world %s\"), *GetPathNameSafe(World));\n\t\t\t}\n\t\t}));\n#endif // WITH_MASSENTITY_DEBUG",
      "lines": 111
    },
    {
      "file_path": "MassEntity\\Private\\MassEntityTypes.cpp",
      "extension": ".cpp",
      "size_bytes": 10855,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEntityTypes.h\"\n\n#include \"MassArchetypeData.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(MassEntityTypes)\n\nDEFINE_STAT(STAT_Mass_Total);\n\nDEFINE_TYPEBITSET(FMassFragmentBitSet);\nDEFINE_TYPEBITSET(FMassTagBitSet);\nDEFINE_TYPEBITSET(FMassChunkFragmentBitSet);\nDEFINE_TYPEBITSET(FMassSharedFragmentBitSet);\nDEFINE_TYPEBITSET(FMassConstSharedFragmentBitSet);\nDEFINE_TYPEBITSET(FMassExternalSubsystemBitSet);\n\n//-----------------------------------------------------------------------------\n// FMassArchetypeSharedFragmentValues\n//-----------------------------------------------------------------------------\nFConstSharedStruct FMassArchetypeSharedFragmentValues::AddConstSharedFragment(const FConstSharedStruct& Fragment)\n{\n\tcheck(Fragment.IsValid());\n\tconst UScriptStruct* StructType = Fragment.GetScriptStruct();\n\tif (!ensureMsgf(ContainsType(StructType) == false, TEXT(\"Shared Fragment of type %s already added to FMassArchetypeSharedFragmentValues\"), *GetNameSafe(StructType)))\n\t{\n\t\tFConstSharedStruct ExistingSharedStruct = GetConstSharedFragmentStruct(StructType);\n\t\tensureMsgf(ExistingSharedStruct.IsValid(), TEXT(\"Shared Fragment of type %s already added as NON-CONST shared struct\"), *GetNameSafe(StructType));\n\t\treturn ExistingSharedStruct;\n\t}\n\n\tcheck(StructType);\n\tConstSharedFragmentBitSet.Add(*StructType);\n\tFConstSharedStruct& StructInstance = ConstSharedFragments.Add_GetRef(Fragment);\n\tDirtyHashCache();\n\treturn StructInstance;\n}\n\nFSharedStruct FMassArchetypeSharedFragmentValues::AddSharedFragment(const FSharedStruct& Fragment)\n{\n\tcheck(Fragment.IsValid());\n\tconst UScriptStruct* StructType = Fragment.GetScriptStruct();\n\tif (!ensureMsgf(ContainsType(StructType) == false, TEXT(\"Shared Fragment of type %s already added to FMassArchetypeSharedFragmentValues\"), *GetNameSafe(StructType)))\n\t{\n\t\tFSharedStruct ExistingSharedStruct = GetSharedFragmentStruct(StructType);\n\t\tensureMsgf(ExistingSharedStruct.IsValid(), TEXT(\"Shared Fragment of type %s already added as CONST shared struct\"), *GetNameSafe(StructType));\n\t\treturn ExistingSharedStruct;\n\t}\n\n\tcheck(StructType);\n\tSharedFragmentBitSet.Add(*StructType);\n\tFSharedStruct& StructInstance = SharedFragments.Add_GetRef(Fragment);\n\tDirtyHashCache();\n\treturn StructInstance;\n}\n\nvoid FMassArchetypeSharedFragmentValues::ReplaceSharedFragments(TConstArrayView<FSharedStruct> Fragments)\n{\n\tDirtyHashCache();\n\tfor (const FSharedStruct& NewFragment : Fragments)\n\t{\n\t\tconst UScriptStruct* NewFragScriptStruct = NewFragment.GetScriptStruct();\n\t\tcheck(NewFragScriptStruct);\n\n\t\tbool bEntryFound = false;\n\t\tfor (FSharedStruct& MyFragment : SharedFragments)\n\t\t{\n\t\t\tif (MyFragment.GetScriptStruct() == NewFragScriptStruct)\n\t\t\t{\n\t\t\t\tMyFragment = NewFragment;\n\t\t\t\tbEntryFound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tensureMsgf(bEntryFound, TEXT(\"Existing fragment of type %s could not be found\"), *GetNameSafe(NewFragScriptStruct));\n\t}\n}\n\nuint32 FMassArchetypeSharedFragmentValues::CalculateHash() const\n{\n\tif (!testableEnsureMsgf(bSorted, TEXT(\"Expecting the containers to be sorted for the hash caluclation to be consistent\")))\n\t{\n\t\treturn 0;\n\t}\n\n\t// Fragments are not part of the uniqueness \n\tuint32 Hash = 0;\n\tfor (const FConstSharedStruct& Fragment : ConstSharedFragments)\n\t{\n\t\tHash = PointerHash(Fragment.GetMemory(), Hash);\n\t}\n\n\tfor (const FSharedStruct& Fragment : SharedFragments)\n\t{\n\t\tHash = PointerHash(Fragment.GetMemory(), Hash);\n\t}\n\n\treturn Hash;\n}\n\nnamespace UE::Mass::Private\n{\n\ttemplate<typename TSharedStruct>\n\tint32 CountInvalid(const TArray<TSharedStruct>& View)\n\t{\n\t\tint32 Count = 0;\n\t\tfor (const TSharedStruct& SharedStruct : View)\n\t\t{\n\t\t\tconst UScriptStruct* StructType = SharedStruct.GetScriptStruct();\n\t\t\tCount += StructType ? 0 : 1;\n\t\t}\n\t\treturn Count;\n\t}\n\n\t/** Note that this function assumes that both ViewA and ViewB do not contain duplicates */\n\ttemplate<typename TSharedStruct, bool bSkipNulls=true>\n\tbool ArraysHaveSameContents(const TArray<TSharedStruct>& ViewA, const TArray<TSharedStruct>& ViewB)\n\t{\n\t\tif constexpr (bSkipNulls)\n\t\t{\n\t\t\tconst int32 NullstCountA = CountInvalid(ViewA);\n\t\t\tconst int32 NullstCountB = CountInvalid(ViewB);\n\t\t\tif (ViewA.Num() - NullstCountA != ViewB.Num() - NullstCountB)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (ViewA.Num() != ViewB.Num())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const TSharedStruct& SharedStruct : ViewA)\n\t\t{\n\t\t\tconst UScriptStruct* StructType = SharedStruct.GetScriptStruct();\n\t\t\tif constexpr (bSkipNulls)\n\t\t\t{\n\t\t\t\tif (StructType == nullptr)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst int32 FragmentIndex = ViewB.IndexOfByPredicate(FStructTypeEqualOperator(StructType));\n\t\t\tif (FragmentIndex == INDEX_NONE)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (ViewB[FragmentIndex].CompareStructValues(SharedStruct) == false)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\nbool FMassArchetypeSharedFragmentValues::HasSameValues(const FMassArchetypeSharedFragmentValues& Other) const\n{\n\tif (SharedFragmentBitSet.IsEquivalent(Other.SharedFragmentBitSet) == false\n\t\t|| ConstSharedFragmentBitSet.IsEquivalent(Other.ConstSharedFragmentBitSet) == false)\n\t{\n\t\treturn false;\n\t}\n\n\treturn UE::Mass::Private::ArraysHaveSameContents(SharedFragments, Other.GetSharedFragments())\n\t\t&& UE::Mass::Private::ArraysHaveSameContents(ConstSharedFragments, Other.GetConstSharedFragments());\n}\n\nint32 FMassArchetypeSharedFragmentValues::Append(const FMassArchetypeSharedFragmentValues& Other)\n{\n\tint32 AddedOrModifiedCount = 0;\n\n\tfor (const FSharedStruct& SharedStruct : Other.GetSharedFragments())\n\t{\n\t\tconst UScriptStruct* StructType = SharedStruct.GetScriptStruct();\n\t\tcheck(StructType);\n\t\tif (SharedFragmentBitSet.Contains(*StructType))\n\t\t{\n\t\t\tconst int32 FragmentIndex = SharedFragments.IndexOfByPredicate(FStructTypeEqualOperator(StructType));\n\t\t\tif (testableEnsureMsgf(FragmentIndex != INDEX_NONE, TEXT(\"%hs trying to switch const fragment to non-const, type %s\")\n\t\t\t\t, __FUNCTION__, *StructType->GetName()))\n\t\t\t{\n\t\t\t\tSharedFragments[FragmentIndex] = SharedStruct;\n\t\t\t\t++AddedOrModifiedCount;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSharedFragments.Add(SharedStruct);\n\t\t\t++AddedOrModifiedCount;\n\t\t}\n\t}\n\n\tfor (const FConstSharedStruct& SharedStruct : Other.GetConstSharedFragments())\n\t{\n\t\tconst UScriptStruct* StructType = SharedStruct.GetScriptStruct();\n\t\tcheck(StructType);\n\t\tif (ConstSharedFragmentBitSet.Contains(*StructType))\n\t\t{\n\t\t\tconst int32 FragmentIndex = ConstSharedFragments.IndexOfByPredicate(FStructTypeEqualOperator(StructType));\n\t\t\tif (testableEnsureMsgf(FragmentIndex != INDEX_NONE, TEXT(\"%hs trying to switch non-const fragment to const, type %s\")\n\t\t\t\t, __FUNCTION__, *StructType->GetName()))\n\t\t\t{\n\t\t\t\tConstSharedFragments[FragmentIndex] = SharedStruct;\n\t\t\t\t++AddedOrModifiedCount;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConstSharedFragments.Add(SharedStruct);\n\t\t\t++AddedOrModifiedCount;\n\t\t}\n\t}\n\n\tSharedFragmentBitSet += Other.SharedFragmentBitSet;\n\tConstSharedFragmentBitSet += Other.ConstSharedFragmentBitSet;\n\tDirtyHashCache();\n\n\treturn AddedOrModifiedCount;\n}\n\nint32 FMassArchetypeSharedFragmentValues::Remove(const FMassSharedFragmentBitSet& SharedFragmentToRemoveBitSet)\n{\n\tint32 RemovedCount = 0;\n\tFMassSharedFragmentBitSet CommonFragments = (SharedFragmentBitSet & SharedFragmentToRemoveBitSet);\n\tFMassSharedFragmentBitSet::FIndexIterator It = CommonFragments.GetIndexIterator();\n\twhile(It)\n\t{\n\t\tconst UScriptStruct* StructType = CommonFragments.GetTypeAtIndex(*It);\n\t\tcheck(StructType);\n\n\t\tconst int32 RegularFragmentIndex = SharedFragments.IndexOfByPredicate(FStructTypeEqualOperator(StructType));\n\t\tif (RegularFragmentIndex != INDEX_NONE)\n\t\t{\n\t\t\tSharedFragments[RegularFragmentIndex].Reset();\n\t\t\t++RemovedCount;\n\t\t}\n\n\t\t++It;\n\t}\n\n\tif (RemovedCount)\n\t{\n\t\tSharedFragments.RemoveAllSwap([](const FSharedStruct& SharedStruct) { return !SharedStruct.IsValid(); });\n\t\tSharedFragmentBitSet -= CommonFragments;\n\t\tDirtyHashCache();\n\t}\n\treturn RemovedCount;\n}\n\nint32 FMassArchetypeSharedFragmentValues::Remove(const FMassConstSharedFragmentBitSet& ConstSharedFragmentToRemoveBitSet)\n{\n\tint32 RemovedCount = 0;\n\tFMassConstSharedFragmentBitSet CommonFragments = (ConstSharedFragmentBitSet & ConstSharedFragmentToRemoveBitSet);\n\tFMassConstSharedFragmentBitSet::FIndexIterator It = CommonFragments.GetIndexIterator();\n\twhile(It)\n\t{\n\t\tconst UScriptStruct* StructType = CommonFragments.GetTypeAtIndex(*It);\n\t\tcheck(StructType);\n\n\t\tconst int32 RegularFragmentIndex = ConstSharedFragments.IndexOfByPredicate(FStructTypeEqualOperator(StructType));\n\t\tif (RegularFragmentIndex != INDEX_NONE)\n\t\t{\n\t\t\tConstSharedFragments[RegularFragmentIndex].Reset();\n\t\t\t++RemovedCount;\n\t\t}\n\n\t\t++It;\n\t}\n\n\tif (RemovedCount)\n\t{\n\t\tConstSharedFragments.RemoveAllSwap([](const FConstSharedStruct& SharedStruct) { return !SharedStruct.IsValid(); });\n\t\tConstSharedFragmentBitSet -= CommonFragments;\n\t\tDirtyHashCache();\n\t}\n\treturn RemovedCount;\n}\n\n//-----------------------------------------------------------------------------\n// FMassGenericPayloadView\n//-----------------------------------------------------------------------------\nvoid FMassGenericPayloadView::SwapElementsToEnd(const int32 StartIndex, int32 NumToMove)\n{\n\tcheck(StartIndex >= 0 && NumToMove >= 0);\n\n\tif (UNLIKELY(NumToMove <= 0 || StartIndex < 0))\n\t{\n\t\treturn;\n\t}\n\n\tTArray<uint8, TInlineAllocator<16>> MovedElements;\n\n\tfor (FStructArrayView& StructArrayView : Content)\n\t{\n\t\tcheck((StartIndex + NumToMove) <= StructArrayView.Num());\n\t\tif (StartIndex + NumToMove >= StructArrayView.Num() - 1)\n\t\t{\n\t\t\t// nothing to do here, the elements are already at the back\n\t\t\tcontinue;\n\t\t}\n\n\t\tuint8* ViewData = static_cast<uint8*>(StructArrayView.GetData());\n\t\tconst uint32 ElementSize = StructArrayView.GetTypeSize();\n\t\tconst uint32 MovedStartOffset = StartIndex * ElementSize;\n\t\tconst uint32 MovedSize = NumToMove * ElementSize;\n\t\tconst uint32 MoveOffset = (StructArrayView.Num() - (StartIndex + NumToMove)) * ElementSize;\n\n\t\tMovedElements.Reset();\n\t\tMovedElements.Append(ViewData + MovedStartOffset, MovedSize);\n\t\tFMemory::Memmove(ViewData + MovedStartOffset, ViewData + MovedStartOffset + MovedSize, MoveOffset);\n\t\tFMemory::Memcpy(ViewData + MovedStartOffset + MoveOffset, MovedElements.GetData(), MovedSize);\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// FMassArchetypeCreationParams\n//-----------------------------------------------------------------------------\nFMassArchetypeCreationParams::FMassArchetypeCreationParams(const FMassArchetypeData& Archetype)\n\t: ChunkMemorySize(static_cast<int32>(Archetype.GetChunkAllocSize()))\n{\n}",
      "lines": 323
    },
    {
      "file_path": "MassEntity\\Private\\MassEntityUtils.cpp",
      "extension": ".cpp",
      "size_bytes": 3362,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEntityUtils.h\"\n#include \"MassEntityTypes.h\"\n#include \"MassArchetypeTypes.h\"\n#include \"MassEntityManager.h\"\n#include \"MassEntitySubsystem.h\"\n#include \"Engine/EngineBaseTypes.h\"\n#include \"Engine/World.h\"\n#if WITH_EDITOR\n#include \"Editor.h\"\n#endif // WITH_EDITOR\n\nnamespace UE::Mass::Utils\n{\nEProcessorExecutionFlags GetProcessorExecutionFlagsForWorld(const UWorld& World)\n{\n#if WITH_EDITOR\n\tif (World.IsEditorWorld() && !World.IsGameWorld())\n\t{\n\t\treturn EProcessorExecutionFlags::EditorWorld;\n\t}\n#endif // WITH_EDITOR\n\n\tswitch (const ENetMode NetMode = World.GetNetMode())\n\t{\n\tcase NM_ListenServer:\n\t\treturn EProcessorExecutionFlags::Client | EProcessorExecutionFlags::Server;\n\tcase NM_DedicatedServer:\n\t\treturn EProcessorExecutionFlags::Server;\n\tcase NM_Client:\n\t\treturn EProcessorExecutionFlags::Client;\n\tcase NM_Standalone:\n\t\treturn EProcessorExecutionFlags::Standalone;\n\tdefault:\n\t\tcheckf(false, TEXT(\"Unsupported ENetMode type (%i) found while determining MASS processor execution flags.\"), NetMode);\n\t\treturn EProcessorExecutionFlags::None;\n\t}\n}\n\nEProcessorExecutionFlags DetermineProcessorExecutionFlags(const UWorld* World, EProcessorExecutionFlags ExecutionFlagsOverride)\n{\n\tif (ExecutionFlagsOverride != EProcessorExecutionFlags::None)\n\t{\n\t\treturn ExecutionFlagsOverride;\n\t}\n\tif (World)\n\t{\n\t\treturn GetProcessorExecutionFlagsForWorld(*World);\n\t}\n\n#if WITH_EDITOR\n\tif (GEditor)\n\t{\n\t\treturn EProcessorExecutionFlags::Editor;\n\t}\n#endif // WITH_EDITOR\n\treturn EProcessorExecutionFlags::All;\n}\n\nuint8 DetermineProcessorSupportedTickTypes(const UWorld* World)\n{\n#if WITH_EDITOR\n\tif (World != nullptr && GetProcessorExecutionFlagsForWorld(*World) == EProcessorExecutionFlags::EditorWorld)\n\t{\n\t\treturn MAX_uint8;\n\t}\n#endif // WITH_EDITOR\n\treturn (1 << LEVELTICK_All) | (1 << LEVELTICK_TimeOnly);\n}\n\nvoid CreateEntityCollections(const FMassEntityManager& EntityManager, const TConstArrayView<FMassEntityHandle> Entities\n\t, const FMassArchetypeEntityCollection::EDuplicatesHandling DuplicatesHandling, TArray<FMassArchetypeEntityCollection>& OutEntityCollections)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"Mass_CreateSparseChunks\");\n\n\tTMap<const FMassArchetypeHandle, TArray<FMassEntityHandle>> ArchetypeToEntities;\n\n\tfor (const FMassEntityHandle& Entity : Entities)\n\t{\n\t\tif (EntityManager.IsEntityValid(Entity))\n\t\t{\n\t\t\tFMassArchetypeHandle Archetype = EntityManager.GetArchetypeForEntityUnsafe(Entity);\n\t\t\tTArray<FMassEntityHandle>& PerArchetypeEntities = ArchetypeToEntities.FindOrAdd(Archetype);\n\t\t\tPerArchetypeEntities.Add(Entity);\n\t\t}\n\t}\n\n\tfor (auto& Pair : ArchetypeToEntities)\n\t{\n\t\tOutEntityCollections.Add(FMassArchetypeEntityCollection(Pair.Key, Pair.Value, DuplicatesHandling));\n\t}\n}\n\nFMassEntityManager* GetEntityManager(const UWorld* World)\n{\n\tUMassEntitySubsystem* EntityManager = UWorld::GetSubsystem<UMassEntitySubsystem>(World);\n\treturn EntityManager\n\t\t? &EntityManager->GetMutableEntityManager()\n\t\t: nullptr;\n}\n\nFMassEntityManager& GetEntityManagerChecked(const UWorld& World)\n{\n\tUMassEntitySubsystem* EntityManager = UWorld::GetSubsystem<UMassEntitySubsystem>(&World);\n\tcheck(EntityManager);\n\treturn EntityManager->GetMutableEntityManager();\n}\n\n} // namespace UE::Mass::Utils",
      "lines": 110
    },
    {
      "file_path": "MassEntity\\Private\\MassEntityView.cpp",
      "extension": ".cpp",
      "size_bytes": 3696,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEntityView.h\"\n#include \"MassEntityManager.h\"\n#include \"MassArchetypeData.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(MassEntityView)\n\n\n//////////////////////////////////////////////////////////////////////\n// FMassEntityView\nFMassEntityView::FMassEntityView(const FMassArchetypeHandle& ArchetypeHandle, FMassEntityHandle InEntity)\n{\n\tEntity = InEntity;\n\tArchetype = &FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);\n\tEntityDataHandle = Archetype->MakeEntityHandle(Entity);\n}\n\nFMassEntityView::FMassEntityView(const FMassEntityManager& EntityManager, FMassEntityHandle InEntity)\n{\n\tEntity = InEntity;\n\tconst FMassArchetypeHandle ArchetypeHandle = EntityManager.GetArchetypeForEntity(Entity);\n\tArchetype = &FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);\n\tEntityDataHandle = Archetype->MakeEntityHandle(Entity);\n}\n\nFMassEntityView FMassEntityView::TryMakeView(const FMassEntityManager& EntityManager, FMassEntityHandle InEntity)\n{\n\tconst FMassArchetypeHandle ArchetypeHandle = EntityManager.GetArchetypeForEntity(InEntity);\n\treturn ArchetypeHandle.IsValid() ? FMassEntityView(ArchetypeHandle, InEntity) : FMassEntityView();\n}\n\nvoid* FMassEntityView::GetFragmentPtr(const UScriptStruct& FragmentType) const\n{\n\tcheckSlow(Archetype && EntityDataHandle.IsValid());\n\tif (const int32* FragmentIndex = Archetype->GetFragmentIndex(&FragmentType))\n\t{\n\t\t// failing the below Find means given entity's archetype is missing given FragmentType\n\t\treturn Archetype->GetFragmentData(*FragmentIndex, EntityDataHandle);\n\t}\n\treturn nullptr;\n}\n\nvoid* FMassEntityView::GetFragmentPtrChecked(const UScriptStruct& FragmentType) const\n{\n\tcheckSlow(Archetype && EntityDataHandle.IsValid());\n\tconst int32 FragmentIndex = Archetype->GetFragmentIndexChecked(&FragmentType);\n\treturn Archetype->GetFragmentData(FragmentIndex, EntityDataHandle);\n}\n\nconst void* FMassEntityView::GetConstSharedFragmentPtr(const UScriptStruct& FragmentType) const\n{\n\tconst FConstSharedStruct* SharedFragment = Archetype->GetSharedFragmentValues(Entity).GetConstSharedFragments().FindByPredicate(FStructTypeEqualOperator(&FragmentType));\n\treturn (SharedFragment != nullptr) ? SharedFragment->GetMemory() : nullptr;\n}\n\nconst void* FMassEntityView::GetConstSharedFragmentPtrChecked(const UScriptStruct& FragmentType) const\n{\n\tconst FConstSharedStruct* SharedFragment = Archetype->GetSharedFragmentValues(Entity).GetConstSharedFragments().FindByPredicate(FStructTypeEqualOperator(&FragmentType));\n\tcheck(SharedFragment != nullptr);\n\treturn SharedFragment->GetMemory();\n}\n\nvoid* FMassEntityView::GetSharedFragmentPtr(const UScriptStruct& FragmentType) const\n{\n\tconst FSharedStruct* SharedFragment = Archetype->GetSharedFragmentValues(Entity).GetSharedFragments().FindByPredicate(FStructTypeEqualOperator(&FragmentType));\n\t// @todo: fix constness, should the getter be non-const too?\n\treturn (SharedFragment != nullptr) ? const_cast<uint8*>(SharedFragment->GetMemory()) : nullptr;\n}\n\nvoid* FMassEntityView::GetSharedFragmentPtrChecked(const UScriptStruct& FragmentType) const\n{\n\tconst FSharedStruct* SharedFragment = Archetype->GetSharedFragmentValues(Entity).GetSharedFragments().FindByPredicate(FStructTypeEqualOperator(&FragmentType));\n\tcheck(SharedFragment != nullptr);\n\t// @todo: fix constness, should the getter be non-const too?\n\treturn const_cast<uint8*>(SharedFragment->GetMemory());\n}\n\nbool FMassEntityView::HasTag(const UScriptStruct& TagType) const\n{\n\tcheckSlow(Archetype && EntityDataHandle.IsValid());\n\treturn Archetype->HasTagType(&TagType);\n}\n",
      "lines": 83
    },
    {
      "file_path": "MassEntity\\Private\\MassExecutionContext.cpp",
      "extension": ".cpp",
      "size_bytes": 2812,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassExecutionContext.h\"\n#include \"MassArchetypeData.h\"\n\n\n//////////////////////////////////////////////////////////////////////////\n// FMassExecutionContext\n\nFMassExecutionContext::FMassExecutionContext(FMassEntityManager& InEntityManager, const float InDeltaTimeSeconds, const bool bInFlushDeferredCommands)\n\t: SubsystemAccess(InEntityManager.GetWorld())\n\t, DeltaTimeSeconds(InDeltaTimeSeconds)\n\t, EntityManager(InEntityManager.AsShared())\n\t, bFlushDeferredCommands(bInFlushDeferredCommands)\n{\n}\n\nvoid FMassExecutionContext::FlushDeferred()\n{\n\tif (bFlushDeferredCommands && DeferredCommandBuffer)\n\t{\n\t\tEntityManager->FlushCommands(DeferredCommandBuffer);\n\t}\n}\n\nvoid FMassExecutionContext::ClearExecutionData()\n{\n\tFragmentViews.Reset();\n\tChunkFragmentViews.Reset();\n\tConstSharedFragmentViews.Reset();\n\tSharedFragmentViews.Reset();\n\tCurrentArchetypeCompositionDescriptor.Reset();\n\tChunkSerialModificationNumber = -1;\n}\n\nbool FMassExecutionContext::CacheSubsystemRequirements(const FMassSubsystemRequirements& SubsystemRequirements)\n{\n\treturn SubsystemAccess.CacheSubsystemRequirements(SubsystemRequirements);\n}\n\nvoid FMassExecutionContext::SetEntityCollection(const FMassArchetypeEntityCollection& InEntityCollection)\n{\n\tcheck(EntityCollection.IsEmpty());\n\tEntityCollection = InEntityCollection;\n}\n\nvoid FMassExecutionContext::SetEntityCollection(FMassArchetypeEntityCollection&& InEntityCollection)\n{\n\tcheck(EntityCollection.IsEmpty());\n\tEntityCollection = MoveTemp(InEntityCollection);\n}\n\nvoid FMassExecutionContext::SetFragmentRequirements(const FMassFragmentRequirements& FragmentRequirements)\n{\n\tFragmentViews.Reset();\n\tfor (const FMassFragmentRequirementDescription& Requirement : FragmentRequirements.GetFragmentRequirements())\n\t{\n\t\tif (Requirement.RequiresBinding())\n\t\t{\n\t\t\tFragmentViews.Emplace(Requirement);\n\t\t}\n\t}\n\n\tChunkFragmentViews.Reset();\n\tfor (const FMassFragmentRequirementDescription& Requirement : FragmentRequirements.GetChunkFragmentRequirements())\n\t{\n\t\tif (Requirement.RequiresBinding())\n\t\t{\n\t\t\tChunkFragmentViews.Emplace(Requirement);\n\t\t}\n\t}\n\n\tConstSharedFragmentViews.Reset();\n\tfor (const FMassFragmentRequirementDescription& Requirement : FragmentRequirements.GetConstSharedFragmentRequirements())\n\t{\n\t\tif (Requirement.RequiresBinding())\n\t\t{\n\t\t\tConstSharedFragmentViews.Emplace(Requirement);\n\t\t}\n\t}\n\n\tSharedFragmentViews.Reset();\n\tfor (const FMassFragmentRequirementDescription& Requirement : FragmentRequirements.GetSharedFragmentRequirements())\n\t{\n\t\tif (Requirement.RequiresBinding())\n\t\t{\n\t\t\tSharedFragmentViews.Emplace(Requirement);\n\t\t}\n\t}\n}\n\nUWorld* FMassExecutionContext::GetWorld() \n{ \n\treturn EntityManager->GetWorld(); \n}\n",
      "lines": 95
    },
    {
      "file_path": "MassEntity\\Private\\MassExecutor.cpp",
      "extension": ".cpp",
      "size_bytes": 9652,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassExecutor.h\"\n#include \"MassProcessingTypes.h\"\n#include \"MassProcessor.h\"\n#include \"MassCommandBuffer.h\"\n#include \"MassExecutionContext.h\"\n#include \"ProfilingDebugging/CpuProfilerTrace.h\"\n\nnamespace UE::Mass::Executor\n{\n\nFORCEINLINE void ExecuteProcessors(FMassEntityManager& EntityManager, TArrayView<UMassProcessor* const> Processors, FMassExecutionContext& ExecutionContext)\n{\n\tfor (UMassProcessor* Proc : Processors)\n\t{\n\t\tProc->CallExecute(EntityManager, ExecutionContext);\n\t}\n}\n\nvoid Run(FMassRuntimePipeline& RuntimePipeline, FMassProcessingContext& ProcessingContext)\n{\n\tif (!ensure(ProcessingContext.EntityManager) || \n\t\t!ensure(ProcessingContext.DeltaSeconds >= 0.f) ||\n\t\t!ensure(RuntimePipeline.GetProcessors().Find(nullptr) == INDEX_NONE))\n\t{\n\t\treturn;\n\t}\n\n\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"MassExecutor Run Pipeline\")\n\tRunProcessorsView(RuntimePipeline.GetMutableProcessors(), ProcessingContext);\n}\n\nvoid RunSparse(FMassRuntimePipeline& RuntimePipeline, FMassProcessingContext& ProcessingContext, FMassArchetypeHandle Archetype, TConstArrayView<FMassEntityHandle> Entities)\n{\n\tif (!ensure(ProcessingContext.EntityManager) ||\n\t\t!ensure(RuntimePipeline.GetProcessors().Find(nullptr) == INDEX_NONE) ||\n\t\tRuntimePipeline.Num() == 0 ||\n\t\t!ensureMsgf(Archetype.IsValid(), TEXT(\"The Archetype passed in to UE::Mass::Executor::RunSparse is invalid\")))\n\t{\n\t\treturn;\n\t}\n\n\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"MassExecutor RunSparseEntities\");\n\n\tconst FMassArchetypeEntityCollection EntityCollection(Archetype, Entities, FMassArchetypeEntityCollection::NoDuplicates);\n\tRunProcessorsView(RuntimePipeline.GetMutableProcessors(), ProcessingContext, MakeArrayView(&EntityCollection, 1));\n}\n\nvoid RunSparse(FMassRuntimePipeline& RuntimePipeline, FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection& EntityCollection)\n{\n\tif (!ensure(ProcessingContext.EntityManager) ||\n\t\t!ensure(RuntimePipeline.GetProcessors().Find(nullptr) == INDEX_NONE) ||\n\t\tRuntimePipeline.Num() == 0 ||\n\t\t!ensureMsgf(EntityCollection.GetArchetype().IsValid(), TEXT(\"The Archetype of EntityCollection passed in to UE::Mass::Executor::RunSparse is invalid\")))\n\t{\n\t\treturn;\n\t}\n\n\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"MassExecutor RunSparse\");\n\n\tRunProcessorsView(RuntimePipeline.GetMutableProcessors(), ProcessingContext, MakeArrayView(&EntityCollection, 1));\n}\n\nvoid Run(UMassProcessor& Processor, FMassProcessingContext& ProcessingContext)\n{\n\tif (!ensure(ProcessingContext.EntityManager) || !ensure(ProcessingContext.DeltaSeconds >= 0.f))\n\t{\n\t\treturn;\n\t}\n\n\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"MassExecutor Run\")\n\n\tUMassProcessor* ProcPtr = &Processor;\n\tRunProcessorsView(MakeArrayView(&ProcPtr, 1), ProcessingContext);\n}\n\nvoid RunProcessorsView(TArrayView<UMassProcessor* const> Processors, FMassProcessingContext& ProcessingContext, TConstArrayView<FMassArchetypeEntityCollection> EntityCollections)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE(RunProcessorsView);\n\n\tif (!ProcessingContext.EntityManager)\n\t{\n\t\tUE_LOG(LogMass, Error, TEXT(\"%s ProcessingContext.EntityManager is null. Baling out.\"), ANSI_TO_TCHAR(__FUNCTION__));\n\t\treturn;\n\t}\n#if WITH_MASSENTITY_DEBUG\n\tif (Processors.Find(nullptr) != INDEX_NONE)\n\t{\n\t\tUE_LOG(LogMass, Error, TEXT(\"%s input Processors contains nullptr. Baling out.\"), ANSI_TO_TCHAR(__FUNCTION__));\n\t\treturn;\n\t}\n#endif // WITH_MASSENTITY_DEBUG\n\n\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"MassExecutor RunProcessorsView\")\n\n\tFMassExecutionContext ExecutionContext(*ProcessingContext.EntityManager.Get(), ProcessingContext.DeltaSeconds);\n\n\t// if ProcessingContext points at a valid CommandBuffer use that one, otherwise manually create a new command buffer \n\t// to let the default one still be used by code unaware of mass processing\n\tTSharedPtr<FMassCommandBuffer> CommandBuffer = ProcessingContext.CommandBuffer \n\t\t? ProcessingContext.CommandBuffer : MakeShareable(new FMassCommandBuffer());\n\tExecutionContext.SetDeferredCommandBuffer(CommandBuffer);\n\tExecutionContext.SetFlushDeferredCommands(false);\n\tExecutionContext.SetAuxData(ProcessingContext.AuxData);\n\tExecutionContext.SetExecutionType(EMassExecutionContextType::Processor);\n\n\tFMassEntityManager& EntityManager = *ProcessingContext.EntityManager.Get();\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"Execute Processors\")\n\t\t\n\t\tFMassEntityManager::FScopedProcessing ProcessingScope = EntityManager.NewProcessingScope();\n\n\t\tif (EntityCollections.Num() == 0)\n\t\t{\n\t\t\tExecuteProcessors(*ProcessingContext.EntityManager, Processors, ExecutionContext);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// @todo change ExecutionContext to contain a TConstArrayView of collections. Will lead up to changes in the entity query as well.\n\t\t\tfor (const FMassArchetypeEntityCollection& Collection : EntityCollections)\n\t\t\t{\n\t\t\t\tExecutionContext.SetEntityCollection(Collection);\n\t\t\t\tExecuteProcessors(*ProcessingContext.EntityManager, Processors, ExecutionContext);\n\t\t\t\tExecutionContext.ClearEntityCollection();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (ProcessingContext.bFlushCommandBuffer)\n\t{\t\t\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"Flush Deferred Commands\")\n\t\t\n\t\tExecutionContext.SetFlushDeferredCommands(true);\n\t\t// append the commands added from other, non-processor sources (like MassAgentSubsystem)\n\t\tensure(!EntityManager.Defer().IsFlushing());\n\t\tensure(!ExecutionContext.Defer().IsFlushing());\n\t\tExecutionContext.Defer().MoveAppend(EntityManager.Defer());\n\t\tExecutionContext.FlushDeferred();\n\t}\n\t// else make sure we don't just lose the commands. Append to the command buffer requested via\n\t// ProcessingContext.CommandBuffer or to the default EntityManager's command buffer.\n\telse if (CommandBuffer->HasPendingCommands() && CommandBuffer != ProcessingContext.CommandBuffer)\n\t{\n\t\tif (ProcessingContext.CommandBuffer)\n\t\t{\n\t\t\tProcessingContext.CommandBuffer->MoveAppend(*CommandBuffer.Get());\n\t\t}\n\t\telse if (CommandBuffer.Get() != &EntityManager.Defer())\n\t\t{\n\t\t\tEntityManager.AppendCommands(CommandBuffer);\n\t\t}\n\t}\n}\n\nstruct FMassExecutorDoneTask\n{\n\tFMassExecutorDoneTask(const FMassExecutionContext& InExecutionContext, TFunction<void()> InOnDoneNotification, const FString& InDebugName)\n\t\t: ExecutionContext(InExecutionContext)\n\t\t, OnDoneNotification(InOnDoneNotification)\n\t\t, DebugName(InDebugName)\n\t{\n\t}\n\tstatic TStatId GetStatId()\n\t{\n\t\tRETURN_QUICK_DECLARE_CYCLE_STAT(FMassExecutorDoneTask, STATGROUP_TaskGraphTasks);\n\t}\n\n\tstatic ENamedThreads::Type GetDesiredThread() { return ENamedThreads::GameThread; }\n\tstatic ESubsequentsMode::Type GetSubsequentsMode() { return ESubsequentsMode::TrackSubsequents; }\n\tvoid DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"Flush Deferred Commands Parallel\");\n\t\tSCOPE_CYCLE_COUNTER(STAT_Mass_Total);\n\n\t\tFMassEntityManager& EntityManagerRef = ExecutionContext.GetEntityManagerChecked();\n\n\t\tif (&ExecutionContext.Defer() != &EntityManagerRef.Defer())\n\t\t{\n\t\t\tExecutionContext.Defer().MoveAppend(EntityManagerRef.Defer());\n\t\t}\n\n\t\tUE_LOG(LogMass, Verbose, TEXT(\"MassExecutor %s tasks DONE\"), *DebugName);\n\t\tExecutionContext.SetFlushDeferredCommands(true);\n\t\tExecutionContext.FlushDeferred();\n\n\t\tOnDoneNotification();\n\t}\nprivate:\n\tFMassExecutionContext ExecutionContext;\n\tTFunction<void()> OnDoneNotification;\n\tFString DebugName;\n};\n\nFGraphEventRef TriggerParallelTasks(UMassProcessor& Processor, FMassProcessingContext& ProcessingContext, TFunction<void()> OnDoneNotification)\n{\n\tif (!ProcessingContext.EntityManager)\n\t{\n\t\tUE_LOG(LogMass, Error, TEXT(\"%s ProcessingContext.EntityManager is null. Baling out.\"), ANSI_TO_TCHAR(__FUNCTION__));\n\t\treturn FGraphEventRef();\n\t}\n\n\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"MassExecutor RunParallel\")\n\n\t// not going through FMassEntityManager::CreateExecutionContext on purpose - we do need a separate command buffer\n\tFMassExecutionContext ExecutionContext(*ProcessingContext.EntityManager.Get(), ProcessingContext.DeltaSeconds);\n\tTSharedPtr<FMassCommandBuffer> CommandBuffer = ProcessingContext.CommandBuffer\n\t\t? ProcessingContext.CommandBuffer : MakeShareable(new FMassCommandBuffer());\n\tExecutionContext.SetDeferredCommandBuffer(CommandBuffer);\n\tExecutionContext.SetFlushDeferredCommands(false);\n\tExecutionContext.SetAuxData(ProcessingContext.AuxData);\n\tExecutionContext.SetExecutionType(EMassExecutionContextType::Processor);\n\n\tFGraphEventRef CompletionEvent;\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"Dispatch Processors\")\n\t\tCompletionEvent = Processor.DispatchProcessorTasks(ProcessingContext.EntityManager, ExecutionContext, {});\n\t}\n\n\tif (CompletionEvent.IsValid())\n\t{\n\t\tconst FGraphEventArray Prerequisites = { CompletionEvent };\n\t\tCompletionEvent = TGraphTask<FMassExecutorDoneTask>::CreateTask(&Prerequisites)\n\t\t\t.ConstructAndDispatchWhenReady(ExecutionContext, OnDoneNotification, Processor.GetName());\n\t}\n\n\treturn CompletionEvent;\n}\n\n//-----------------------------------------------------------------------------\n// DEPRECATED\n//-----------------------------------------------------------------------------\nvoid RunProcessorsView(TArrayView<UMassProcessor* const> Processors, FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection* EntityCollection)\n{\n\tif (EntityCollection)\n\t{\n\t\tRunProcessorsView(Processors, ProcessingContext, MakeArrayView(EntityCollection, 1));\n\t}\n\telse\n\t{\n\t\tRunProcessorsView(Processors, ProcessingContext);\n\t}\n}\n\n} // namespace UE::Mass::Executor\n",
      "lines": 245
    },
    {
      "file_path": "MassEntity\\Private\\MassObserverManager.cpp",
      "extension": ".cpp",
      "size_bytes": 13655,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassObserverManager.h\"\n#include \"MassEntityManager.h\"\n#include \"MassEntitySubsystem.h\"\n#include \"MassExecutor.h\"\n#include \"MassProcessingTypes.h\"\n#include \"MassObserverRegistry.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(MassObserverManager)\n\nnamespace UE::Mass::ObserverManager\n{\n\tnamespace Tweakables\n\t{\n\t\t// Used as a template parameter for TInlineAllocator that we use when gathering UScriptStruct* of the observed types to process.\n\t\tconstexpr int InlineAllocatorElementsForOverlapTypes = 8;\n\t} // Tweakables\n\n\tnamespace Private\n\t{\n\t// a helper function to reduce code duplication in FMassObserverManager::Initialize\n\ttemplate<typename TBitSet, typename TPointerType>\n\tvoid SetUpObservers(FMassEntityManager& EntityManager, const EProcessorExecutionFlags WorldExecutionFlags, UObject& Owner\n\t\t, const TMap<TPointerType, FMassProcessorClassCollection>& RegisteredObserverTypes, TBitSet& ObservedBitSet, FMassObserversMap& Observers)\n\t{\n\t\tObservedBitSet.Reset();\n\n\t\tfor (auto It : RegisteredObserverTypes)\n\t\t{\n\t\t\tif (It.Value.ClassCollection.Num() == 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tObservedBitSet.Add(*It.Key);\n\t\t\tFMassRuntimePipeline& Pipeline = (*Observers).FindOrAdd(It.Key);\n\n\t\t\tfor (const TSubclassOf<UMassProcessor>& ProcessorClass : It.Value.ClassCollection)\n\t\t\t{\n\t\t\t\tif (ProcessorClass->GetDefaultObject<UMassProcessor>()->ShouldExecute(WorldExecutionFlags))\n\t\t\t\t{\n\t\t\t\t\tPipeline.AppendProcessor(ProcessorClass, Owner);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPipeline.Initialize(Owner);\n\t\t}\n\t};\n\t} // Private\n} // UE::Mass::ObserverManager\n\n//----------------------------------------------------------------------//\n// FMassObserverManager\n//----------------------------------------------------------------------//\nFMassObserverManager::FMassObserverManager()\n\t: EntityManager(GetMutableDefault<UMassEntitySubsystem>()->GetMutableEntityManager())\n{\n\n}\n\nFMassObserverManager::FMassObserverManager(FMassEntityManager& Owner)\n\t: EntityManager(Owner)\n{\n\n}\n\nvoid FMassObserverManager::Initialize()\n{\n\t// instantiate initializers\n\tconst UMassObserverRegistry& Registry = UMassObserverRegistry::Get();\n\n\tUObject* Owner = EntityManager.GetOwner();\n\tcheck(Owner);\n\tconst UWorld* World = Owner->GetWorld();\n\tconst EProcessorExecutionFlags WorldExecutionFlags = UE::Mass::Utils::DetermineProcessorExecutionFlags(World);\n\n\tusing UE::Mass::ObserverManager::Private::SetUpObservers;\n\tfor (int i = 0; i < (int)EMassObservedOperation::MAX; ++i)\n\t{\n\t\tSetUpObservers(EntityManager, WorldExecutionFlags, *Owner, *Registry.FragmentObservers[i], ObservedFragments[i], FragmentObservers[i]);\n\t\tSetUpObservers(EntityManager, WorldExecutionFlags, *Owner, *Registry.TagObservers[i], ObservedTags[i], TagObservers[i]);\n\t}\n}\n\nvoid FMassObserverManager::DeInitialize()\n{\n\tfor (int32 i = 0; i < (int32)EMassObservedOperation::MAX; ++i)\n\t{\n\t\t(*FragmentObservers[i]).Empty();\n\t\t(*TagObservers[i]).Empty();\n\t}\n}\n\nbool FMassObserverManager::OnPostEntitiesCreated(const FMassArchetypeEntityCollection& EntityCollection)\n{\n\treturn OnPostEntitiesCreated(MakeArrayView(&EntityCollection , 1));\n}\n\nbool FMassObserverManager::OnPostEntitiesCreated(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections)\n{\n\tFMassProcessingContext ProcessingContext(EntityManager, /*DeltaSeconds=*/0.f);\n\t// requesting not to flush commands since handling creation of new entities can result in multiple collections of\n\t// processors being executed and flushing commands between these runs would ruin EntityCollection since entities could\n\t// get their composition changed and get moved to new archetypes\n\tProcessingContext.bFlushCommandBuffer = false;\n\tProcessingContext.CommandBuffer = MakeShareable(new FMassCommandBuffer());\n\n\tif (OnPostEntitiesCreated(ProcessingContext, EntityCollections))\n\t{\n\t\tEntityManager.FlushCommands(ProcessingContext.CommandBuffer);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n// DEPRECATED\nbool FMassObserverManager::OnPostEntitiesCreated(FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection& EntityCollection)\n{\n\treturn OnPostEntitiesCreated(ProcessingContext, MakeArrayView(&EntityCollection, 1));\n}\n\nbool FMassObserverManager::OnPostEntitiesCreated(FMassProcessingContext& ProcessingContext, TConstArrayView<FMassArchetypeEntityCollection> EntityCollections)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"OnPostEntitiesCreated\")\n\n\tcheck(ProcessingContext.EntityManager);\n\n\tbool bReturnValue = false;\n\n\tfor (const FMassArchetypeEntityCollection& Collection : EntityCollections)\n\t{\n\t\tconst FMassArchetypeCompositionDescriptor& ArchetypeComposition = ProcessingContext.EntityManager->GetArchetypeComposition(Collection.GetArchetype());\n\t\tbReturnValue = OnCompositionChanged(ProcessingContext, Collection, ArchetypeComposition, EMassObservedOperation::Add) || bReturnValue;\n\t}\n\n\treturn bReturnValue;\n}\n\nbool FMassObserverManager::OnPreEntitiesDestroyed(const FMassArchetypeEntityCollection& EntityCollection)\n{\n\tFMassProcessingContext ProcessingContext(EntityManager, /*DeltaSeconds=*/0.f);\n\tProcessingContext.bFlushCommandBuffer = false;\n\tProcessingContext.CommandBuffer = MakeShareable(new FMassCommandBuffer());\n\n\tif (OnPreEntitiesDestroyed(ProcessingContext, EntityCollection))\n\t{\n\t\tEntityManager.FlushCommands(ProcessingContext.CommandBuffer);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool FMassObserverManager::OnPreEntitiesDestroyed(FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection& EntityCollection)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"OnPreEntitiesDestroyed\")\n\n\tcheck(ProcessingContext.EntityManager);\n\tconst FMassArchetypeCompositionDescriptor& ArchetypeComposition = ProcessingContext.EntityManager->GetArchetypeComposition(EntityCollection.GetArchetype());\n\t\n\treturn OnCompositionChanged(ProcessingContext, EntityCollection, ArchetypeComposition, EMassObservedOperation::Remove);\n}\n\nbool FMassObserverManager::OnPreEntityDestroyed(const FMassArchetypeCompositionDescriptor& ArchetypeComposition, const FMassEntityHandle Entity)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"OnPreEntityDestroyed\")\n\treturn OnCompositionChanged(Entity, ArchetypeComposition, EMassObservedOperation::Remove);\n}\n\nbool FMassObserverManager::OnCompositionChanged(FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection& EntityCollection, const FMassArchetypeCompositionDescriptor& CompositionDelta, const EMassObservedOperation Operation)\n{\n\tusing UE::Mass::ObserverManager::Tweakables::InlineAllocatorElementsForOverlapTypes;\n\n\tconst FMassFragmentBitSet FragmentOverlap = ObservedFragments[(uint8)Operation].GetOverlap(CompositionDelta.Fragments);\n\tconst bool bHasFragmentsOverlap = !FragmentOverlap.IsEmpty();\n\tconst FMassTagBitSet TagOverlap = ObservedTags[(uint8)Operation].GetOverlap(CompositionDelta.Tags);\n\tconst bool bHasTagsOverlap = !TagOverlap.IsEmpty();\n\n\tif (bHasFragmentsOverlap || bHasTagsOverlap)\n\t{\n\t\tTArray<const UScriptStruct*, TInlineAllocator<InlineAllocatorElementsForOverlapTypes>> ObservedTypesOverlap;\n\n\t\tif (bHasFragmentsOverlap)\n\t\t{\n\t\t\tFragmentOverlap.ExportTypes(ObservedTypesOverlap);\n\n\t\t\tHandleFragmentsImpl(ProcessingContext, EntityCollection, ObservedTypesOverlap, FragmentObservers[(uint8)Operation]);\n\t\t}\n\n\t\tif (bHasTagsOverlap)\n\t\t{\n\t\t\tObservedTypesOverlap.Reset();\n\t\t\tTagOverlap.ExportTypes(ObservedTypesOverlap);\n\n\t\t\tHandleFragmentsImpl(ProcessingContext, EntityCollection, ObservedTypesOverlap, TagObservers[(uint8)Operation]);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool FMassObserverManager::OnCompositionChanged(const FMassEntityHandle Entity, const FMassArchetypeCompositionDescriptor& CompositionDelta, const EMassObservedOperation Operation)\n{\n\tusing UE::Mass::ObserverManager::Tweakables::InlineAllocatorElementsForOverlapTypes;\n\n\tconst FMassFragmentBitSet FragmentOverlap = ObservedFragments[(uint8)Operation].GetOverlap(CompositionDelta.Fragments);\n\tconst bool bHasFragmentsOverlap = !FragmentOverlap.IsEmpty();\n\tconst FMassTagBitSet TagOverlap = ObservedTags[(uint8)Operation].GetOverlap(CompositionDelta.Tags);\n\tconst bool bHasTagsOverlap = !TagOverlap.IsEmpty();\n\n\tif (bHasFragmentsOverlap || bHasTagsOverlap)\n\t{\n\t\tTArray<const UScriptStruct*, TInlineAllocator<InlineAllocatorElementsForOverlapTypes>> ObservedTypesOverlap;\n\t\tFMassProcessingContext ProcessingContext(EntityManager, /*DeltaSeconds=*/0.f);\n\t\tProcessingContext.bFlushCommandBuffer = false;\n\t\tconst FMassArchetypeHandle ArchetypeHandle = EntityManager.GetArchetypeForEntity(Entity);\n\n\t\tif (bHasFragmentsOverlap)\n\t\t{\n\t\t\tFragmentOverlap.ExportTypes(ObservedTypesOverlap);\n\n\t\t\tHandleFragmentsImpl(ProcessingContext, FMassArchetypeEntityCollection(ArchetypeHandle, MakeArrayView(&Entity, 1)\n\t\t\t\t, FMassArchetypeEntityCollection::NoDuplicates), ObservedTypesOverlap, FragmentObservers[(uint8)Operation]);\n\t\t}\n\n\t\tif (bHasTagsOverlap)\n\t\t{\n\t\t\tObservedTypesOverlap.Reset();\n\t\t\tTagOverlap.ExportTypes(ObservedTypesOverlap);\n\n\t\t\tHandleFragmentsImpl(ProcessingContext, FMassArchetypeEntityCollection(ArchetypeHandle, MakeArrayView(&Entity, 1)\n\t\t\t\t, FMassArchetypeEntityCollection::NoDuplicates), ObservedTypesOverlap, TagObservers[(uint8)Operation]);\n\t\t}\n\t}\n\n\treturn bHasFragmentsOverlap || bHasTagsOverlap;\n}\n\nvoid FMassObserverManager::OnFragmentOrTagOperation(const UScriptStruct& FragmentOrTagType, const FMassArchetypeEntityCollection& EntityCollection, const EMassObservedOperation Operation)\n{\n\tcheck(FragmentOrTagType.IsChildOf(FMassFragment::StaticStruct()) || FragmentOrTagType.IsChildOf(FMassTag::StaticStruct()));\n\n\tif (FragmentOrTagType.IsChildOf(FMassFragment::StaticStruct()))\n\t{\n\t\tif (ObservedFragments[(uint8)Operation].Contains(FragmentOrTagType))\n\t\t{\n\t\t\tHandleSingleEntityImpl(FragmentOrTagType, EntityCollection, FragmentObservers[(uint8)Operation]);\n\t\t}\n\t}\n\telse if (ObservedTags[(uint8)Operation].Contains(FragmentOrTagType))\n\t{\n\t\tHandleSingleEntityImpl(FragmentOrTagType, EntityCollection, TagObservers[(uint8)Operation]);\n\t}\n}\n\nvoid FMassObserverManager::HandleFragmentsImpl(FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection& EntityCollection\n\t, TArrayView<const UScriptStruct*> ObservedTypes\n\t/*, const FMassFragmentBitSet& FragmentsBitSet*/, FMassObserversMap& HandlersContainer)\n{\t\n\tTRACE_CPUPROFILER_EVENT_SCOPE(MassObserver_HandleFragmentsImpl);\n\n\tcheck(ObservedTypes.Num() > 0);\n\n\tfor (const UScriptStruct* Type : ObservedTypes)\n\t{\t\t\n\t\tProcessingContext.AuxData.InitializeAs(Type);\n\t\tFMassRuntimePipeline& Pipeline = (*HandlersContainer).FindChecked(Type);\n\n\t\tUE::Mass::Executor::RunProcessorsView(Pipeline.GetMutableProcessors(), ProcessingContext, MakeArrayView(&EntityCollection, 1));\n\t}\n}\n\nvoid FMassObserverManager::HandleSingleEntityImpl(const UScriptStruct& FragmentType, const FMassArchetypeEntityCollection& EntityCollection, FMassObserversMap& HandlersContainer)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE(MassObserver_HandleSingleEntityImpl);\n\n\tFMassProcessingContext ProcessingContext(EntityManager, /*DeltaSeconds=*/0.f);\n\tProcessingContext.bFlushCommandBuffer = false;\n\tProcessingContext.AuxData.InitializeAs(&FragmentType);\n\tFMassRuntimePipeline& Pipeline = (*HandlersContainer).FindChecked(&FragmentType);\n\n\tUE::Mass::Executor::RunProcessorsView(Pipeline.GetMutableProcessors(), ProcessingContext, MakeArrayView(&EntityCollection, 1));\n}\n\nvoid FMassObserverManager::AddObserverInstance(const UScriptStruct& FragmentOrTagType, const EMassObservedOperation Operation, UMassProcessor& ObserverProcessor)\n{\n\tcheckSlow(FragmentOrTagType.IsChildOf(FMassFragment::StaticStruct()) || FragmentOrTagType.IsChildOf(FMassTag::StaticStruct()));\n\n\tFMassRuntimePipeline* Pipeline = nullptr;\n\n\tif (FragmentOrTagType.IsChildOf(FMassFragment::StaticStruct()))\n\t{\n\t\tPipeline = &(*FragmentObservers[(uint8)Operation]).FindOrAdd(&FragmentOrTagType);\n\t\tObservedFragments[(uint8)Operation].Add(FragmentOrTagType);\n\t}\n\telse\n\t{\n\t\tPipeline = &(*TagObservers[(uint8)Operation]).FindOrAdd(&FragmentOrTagType);\n\t\tObservedTags[(uint8)Operation].Add(FragmentOrTagType);\n\t}\n\tPipeline->AppendProcessor(ObserverProcessor);\n\n\t// calling initialize to ensure the given processor is related to the same EntityManager\n\tif (UObject* Owner = EntityManager.GetOwner())\n\t{\t\n\t\tObserverProcessor.Initialize(*Owner);\n\t}\n}\n\nvoid FMassObserverManager::RemoveObserverInstance(const UScriptStruct& FragmentOrTagType, const EMassObservedOperation Operation, UMassProcessor& ObserverProcessor)\n{\n\tif (!ensure(FragmentOrTagType.IsChildOf(FMassFragment::StaticStruct()) || FragmentOrTagType.IsChildOf(FMassTag::StaticStruct())))\n\t{\n\t\treturn;\n\t}\n\n\tbool bIsFragmentObserver = FragmentOrTagType.IsChildOf(FMassFragment::StaticStruct());\n\n\tTMap<TObjectPtr<const UScriptStruct>, FMassRuntimePipeline>& ObserversMap =\n\t\tbIsFragmentObserver ? *FragmentObservers[(uint8)Operation] : *TagObservers[(uint8)Operation];\n\n\tFMassRuntimePipeline* Pipeline = ObserversMap.Find(&FragmentOrTagType);\n\tif (!ensureMsgf(Pipeline, TEXT(\"Trying to remove an observer for a fragment/tag that does not seem to be observed.\")))\n\t{\n\t\treturn;\n\t}\n\tPipeline->RemoveProcessor(ObserverProcessor);\n\n\tif (Pipeline->Num() == 0)\n\t{\n\t\tObserversMap.Remove(&FragmentOrTagType);\n\t\tif (bIsFragmentObserver)\n\t\t{\n\t\t\tObservedFragments[(uint8)Operation].Remove(FragmentOrTagType);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tObservedTags[(uint8)Operation].Remove(FragmentOrTagType);\n\t\t}\n\t}\n}\n",
      "lines": 342
    },
    {
      "file_path": "MassEntity\\Private\\MassObserverProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 1403,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassObserverProcessor.h\"\n#include \"MassObserverRegistry.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(MassObserverProcessor)\n\n//----------------------------------------------------------------------//\n// UMassObserverProcessor\n//----------------------------------------------------------------------//\nUMassObserverProcessor::UMassObserverProcessor()\n{\n\tbAutoRegisterWithProcessingPhases = false;\n#if WITH_EDITORONLY_DATA\n\tbCanShowUpInSettings = false;\n#endif // WITH_EDITORONLY_DATA\n}\n\nvoid UMassObserverProcessor::PostInitProperties()\n{\n\tSuper::PostInitProperties();\n\n\tUClass* MyClass = GetClass();\n\tCA_ASSUME(MyClass);\n\n\tif (HasAnyFlags(RF_ClassDefaultObject) && MyClass->HasAnyClassFlags(CLASS_Abstract) == false)\n\t{\n\t\tif (ensure(ObservedType != nullptr && Operation != EMassObservedOperation::MAX))\n\t\t{\n\t\t\tRegister();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUE_LOG(LogMass, Error, TEXT(\"%s attempting to register %s while it\\'s misconfigured, Type: %s, Operation: %s\")\n\t\t\t\t, ANSI_TO_TCHAR(__FUNCTION__), *MyClass->GetName(), *GetNameSafe(ObservedType), *UEnum::GetValueAsString(Operation));\n\t\t}\n\t}\n}\n\nvoid UMassObserverProcessor::Register()\n{\n\tif (bAutoRegisterWithObserverRegistry)\n\t{\n\t\tcheck(ObservedType);\n\t\tUMassObserverRegistry::GetMutable().RegisterObserver(*ObservedType, Operation, GetClass());\n\t}\n}\n\n\n",
      "lines": 49
    },
    {
      "file_path": "MassEntity\\Private\\MassObserverRegistry.cpp",
      "extension": ".cpp",
      "size_bytes": 1081,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassObserverRegistry.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(MassObserverRegistry)\n\n//----------------------------------------------------------------------//\n// UMassObserverRegistry\n//----------------------------------------------------------------------//\nUMassObserverRegistry::UMassObserverRegistry()\n{\n\t// there can be only one!\n\tcheck(HasAnyFlags(RF_ClassDefaultObject));\n}\n\nvoid UMassObserverRegistry::RegisterObserver(const UScriptStruct& ObservedType, const EMassObservedOperation Operation, TSubclassOf<UMassProcessor> ObserverClass)\n{\n\tcheck(ObserverClass);\n\tcheckSlow(ObservedType.IsChildOf(FMassFragment::StaticStruct()) || ObservedType.IsChildOf(FMassTag::StaticStruct()));\n\n\tif (ObservedType.IsChildOf(FMassFragment::StaticStruct()))\n\t{\n\t\t(*FragmentObservers[(uint8)Operation]).FindOrAdd(&ObservedType).ClassCollection.AddUnique(ObserverClass);\n\t}\n\telse\n\t{\n\t\t(*TagObservers[(uint8)Operation]).FindOrAdd(&ObservedType).ClassCollection.AddUnique(ObserverClass);\n\t}\n}\n\n\n",
      "lines": 31
    },
    {
      "file_path": "MassEntity\\Private\\MassProcessingPhaseManager.cpp",
      "extension": ".cpp",
      "size_bytes": 17557,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassProcessingPhaseManager.h\"\n#include \"MassProcessingTypes.h\"\n#include \"MassDebugger.h\"\n#include \"MassProcessor.h\"\n#include \"MassExecutor.h\"\n#include \"MassEntityManager.h\"\n#include \"MassEntitySubsystem.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"Engine/World.h\"\n#include \"MassCommandBuffer.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(MassProcessingPhaseManager)\n\n#define LOCTEXT_NAMESPACE \"Mass\"\n\nDECLARE_CYCLE_STAT(TEXT(\"Mass Phase Tick\"), STAT_Mass_PhaseTick, STATGROUP_Mass);\n\nnamespace UE::Mass::Tweakables\n{\n\tbool bFullyParallel = MASS_DO_PARALLEL;\n\tbool bMakePrePhysicsTickFunctionHighPriority = true;\n\n\tFAutoConsoleVariableRef CVars[] = {\n\t\t{TEXT(\"mass.FullyParallel\"), bFullyParallel, TEXT(\"Enables mass processing distribution to all available thread (via the task graph)\")},\n\t\t{TEXT(\"mass.MakePrePhysicsTickFunctionHighPriority\"), bMakePrePhysicsTickFunctionHighPriority, TEXT(\"Whether to make the PrePhysics tick function high priority - can minimise GameThread waits by starting parallel work as soon as possible\")},\n\t};\n}\n\nnamespace UE::Mass::Private\n{\n\tETickingGroup PhaseToTickingGroup[int(EMassProcessingPhase::MAX)]\n\t{\n\t\tETickingGroup::TG_PrePhysics, // EMassProcessingPhase::PrePhysics\n\t\tETickingGroup::TG_StartPhysics, // EMassProcessingPhase::StartPhysics\n\t\tETickingGroup::TG_DuringPhysics, // EMassProcessingPhase::DuringPhysics\n\t\tETickingGroup::TG_EndPhysics,\t// EMassProcessingPhase::EndPhysics\n\t\tETickingGroup::TG_PostPhysics,\t// EMassProcessingPhase::PostPhysics\n\t\tETickingGroup::TG_LastDemotable, // EMassProcessingPhase::FrameEnd\n\t};\n} // UE::Mass::Private\n\n//----------------------------------------------------------------------//\n//  FMassProcessingPhase\n//----------------------------------------------------------------------//\nFMassProcessingPhase::FMassProcessingPhase()\n{\n\tbCanEverTick = true;\n\tbStartWithTickEnabled = false;\n\tSupportedTickTypes = (1 << LEVELTICK_All) | (1 << LEVELTICK_TimeOnly);\n}\n\nvoid FMassProcessingPhase::ExecuteTick(float DeltaTime, ELevelTick TickType, ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)\n{\n\tif (ShouldTick(TickType) == false)\n\t{\n\t\treturn;\n\t}\n\n\tSCOPE_CYCLE_COUNTER(STAT_Mass_PhaseTick);\n\tSCOPE_CYCLE_COUNTER(STAT_Mass_Total);\n\n\tcheckf(PhaseManager, TEXT(\"Manager is null which is not a supported case. Either this FMassProcessingPhase has not been initialized properly or it's been left dangling after the FMassProcessingPhase owner got destroyed.\"));\n\n\tTRACE_CPUPROFILER_EVENT_SCOPE_TEXT(*FString::Printf(TEXT(\"FMassProcessingPhase::ExecuteTick %s\"), *UEnum::GetValueAsString(Phase)));\n\n\tPhaseManager->OnPhaseStart(*this);\n\t{\n\t\tLLM_SCOPE_BYNAME(TEXT(\"Mass/PhaseStartDelegate\"));\n\t\tOnPhaseStart.Broadcast(DeltaTime);\n\t}\n\n\tcheck(PhaseProcessor);\n\t\n\tFMassEntityManager& EntityManager = PhaseManager->GetEntityManagerRef();\n\tFMassProcessingContext Context(EntityManager, DeltaTime);\n\n\tbIsDuringMassProcessing = true;\n\n\tif (bRunInParallelMode)\n\t{\n\t\tbool bWorkRequested = false;\n\t\tif (PhaseProcessor->IsEmpty() == false)\n\t\t{\n\t\t\tconst FGraphEventRef PipelineCompletionEvent = UE::Mass::Executor::TriggerParallelTasks(*PhaseProcessor, Context, [this, DeltaTime]()\n\t\t\t\t{\n\t\t\t\t\tOnParallelExecutionDone(DeltaTime);\n\t\t\t\t});\n\n\t\t\tif (PipelineCompletionEvent.IsValid())\n\t\t\t{\n\t\t\t\tMyCompletionGraphEvent->DontCompleteUntil(PipelineCompletionEvent);\n\t\t\t\tbWorkRequested = true;\n\t\t\t}\n\t\t}\n\t\tif (bWorkRequested == false)\n\t\t{\n\t\t\tOnParallelExecutionDone(DeltaTime);\n\t\t}\n\t}\n\telse\n\t{\n\t\tUE::Mass::Executor::Run(*PhaseProcessor, Context);\n\n\t\t{\n\t\t\tLLM_SCOPE_BYNAME(TEXT(\"Mass/PhaseEndDelegate\"));\n\t\t\tOnPhaseEnd.Broadcast(DeltaTime);\n\t\t}\n\t\tPhaseManager->OnPhaseEnd(*this);\n\t\tbIsDuringMassProcessing = false;\n\t}\n}\n\nvoid FMassProcessingPhase::OnParallelExecutionDone(const float DeltaTime)\n{\n\tbIsDuringMassProcessing = false;\n\t{\n\t\tLLM_SCOPE_BYNAME(TEXT(\"Mass/PhaseEndDelegate\"));\n\t\tOnPhaseEnd.Broadcast(DeltaTime);\n\t}\n\tcheck(PhaseManager);\n\tPhaseManager->OnPhaseEnd(*this);\n}\n\nFString FMassProcessingPhase::DiagnosticMessage()\n{\n\treturn (PhaseManager ? PhaseManager->GetName() : TEXT(\"NULL-MassProcessingPhaseManager\")) + TEXT(\"[ProcessingPhaseTick]\");\n}\n\nFName FMassProcessingPhase::DiagnosticContext(bool bDetailed)\n{\n\treturn TEXT(\"MassProcessingPhase\");\n}\n\nvoid FMassProcessingPhase::Initialize(FMassProcessingPhaseManager& InPhaseManager, const EMassProcessingPhase InPhase, const ETickingGroup InTickGroup, UMassCompositeProcessor& InPhaseProcessor)\n{\n\tPhaseManager = &InPhaseManager;\n\tPhase = InPhase;\n\tTickGroup = InTickGroup;\n\tPhaseProcessor = &InPhaseProcessor;\n}\n\n//----------------------------------------------------------------------//\n// FPhaseProcessorConfigurator\n//----------------------------------------------------------------------//\nvoid FMassPhaseProcessorConfigurationHelper::Configure(TArrayView<UMassProcessor* const> DynamicProcessors\n\t, EProcessorExecutionFlags InWorldExecutionFlags, const TSharedPtr<FMassEntityManager>& EntityManager\n\t, FMassProcessorDependencySolver::FResult* OutOptionalResult)\n{\n\tFMassRuntimePipeline TmpPipeline(InWorldExecutionFlags);\n\tTmpPipeline.CreateFromArray(PhaseConfig.ProcessorCDOs, ProcessorOuter);\n\tfor (UMassProcessor* Processor : DynamicProcessors)\n\t{\n\t\tcheckf(Processor != nullptr, TEXT(\"Dynamic processor provided to MASS is null.\"));\n\t\tif (Processor->GetProcessingPhase() == Phase)\n\t\t{\n\t\t\tTmpPipeline.AppendProcessor(*Processor);\n\t\t}\n\t}\n\n\tTArray<FMassProcessorOrderInfo> SortedProcessors;\n\tFMassProcessorDependencySolver Solver(TmpPipeline.GetMutableProcessors(), bIsGameRuntime);\n\n\tSolver.ResolveDependencies(SortedProcessors, EntityManager, OutOptionalResult);\n\n\tPhaseProcessor.UpdateProcessorsCollection(SortedProcessors, InWorldExecutionFlags);\n\n#if WITH_MASSENTITY_DEBUG\n\tfor (const FMassProcessorOrderInfo& ProcessorOrderInfo : SortedProcessors)\n\t{\n\t\tTmpPipeline.RemoveProcessor(*ProcessorOrderInfo.Processor);\n\t}\n\t\n\tif (TmpPipeline.Num())\n\t{\n\t\tUE_VLOG_UELOG(&PhaseProcessor, LogMass, Verbose, TEXT(\"Discarding processors due to not having anything to do (no relevant Archetypes):\"));\n\t\tfor (UMassProcessor* Processor : TmpPipeline.GetProcessors())\n\t\t{\n\t\t\tUE_VLOG_UELOG(&PhaseProcessor, LogMass, Verbose, TEXT(\"\\t%s\"), *Processor->GetProcessorName());\n\t\t\t// we're ignoring dynamic processors since these instances were explicitly created by the user, and we don't\n\t\t\t// want to destroy them - the user would need to re-add them every time we recalculate the dependency graph\n\t\t\tif (Processor->IsDynamic() == false)\n\t\t\t{\n\t\t\t\tProcessor->MarkAsGarbage();\n\t\t\t}\n\t\t}\n\t}\n#endif // WITH_MASSENTITY_DEBUG\n\n\tif (Solver.IsSolvingForSingleThread() == false)\n\t{\n\t\tPhaseProcessor.BuildFlatProcessingGraph(SortedProcessors);\n\t}\n\n\tif (bInitializeCreatedProcessors)\n\t{\n\t\tPhaseProcessor.Initialize(ProcessorOuter);\n\t}\n}\n\n//----------------------------------------------------------------------//\n// FMassProcessingPhaseManager\n//----------------------------------------------------------------------//\nvoid FMassProcessingPhaseManager::Initialize(UObject& InOwner, TConstArrayView<FMassProcessingPhaseConfig> InProcessingPhasesConfig, const FString& DependencyGraphFileName)\n{\n\tUWorld* World = InOwner.GetWorld();\n#if WITH_EDITOR\n\tconst bool bCreateProcessorGraphPreview = (World != nullptr) && (World->IsEditorWorld() && !World->IsGameWorld());\n#endif // WITH_EDITOR\n\tOwner = &InOwner;\n\tProcessingPhasesConfig = InProcessingPhasesConfig;\n\n\tProcessorExecutionFlags = UE::Mass::Utils::DetermineProcessorExecutionFlags(World, ProcessorExecutionFlags);\n\tconst uint8 SupportedTickTypes = UE::Mass::Utils::DetermineProcessorSupportedTickTypes(World);\n\n\tfor (int PhaseAsInt = 0; PhaseAsInt < int(EMassProcessingPhase::MAX); ++PhaseAsInt)\n\t{\t\t\n\t\tconst EMassProcessingPhase Phase = EMassProcessingPhase(PhaseAsInt);\n\t\tFMassProcessingPhase& ProcessingPhase = ProcessingPhases[PhaseAsInt];\n\n\t\tUMassCompositeProcessor* PhaseProcessor = NewObject<UMassCompositeProcessor>(&InOwner, UMassCompositeProcessor::StaticClass()\n\t\t\t, *FString::Printf(TEXT(\"ProcessingPhase_%s\"), *UEnum::GetDisplayValueAsText(Phase).ToString()));\n\t\n\t\tcheck(PhaseProcessor);\n\t\tProcessingPhase.Initialize(*this, Phase, UE::Mass::Private::PhaseToTickingGroup[PhaseAsInt], *PhaseProcessor);\n\t\tProcessingPhase.SupportedTickTypes = SupportedTickTypes;\n\n\t\tREDIRECT_OBJECT_TO_VLOG(PhaseProcessor, &InOwner);\n\t\tPhaseProcessor->SetProcessingPhase(Phase);\n\t\tPhaseProcessor->SetGroupName(FName(FString::Printf(TEXT(\"%s Group\"), *UEnum::GetDisplayValueAsText(Phase).ToString())));\n\n#if WITH_MASSENTITY_DEBUG\n\t\tFStringOutputDevice Ar;\n\t\tPhaseProcessor->DebugOutputDescription(Ar);\n\t\tUE_VLOG(&InOwner, LogMass, Log, TEXT(\"Setting new group processor for phase %s:\\n%s\"), *UEnum::GetValueAsString(Phase), *Ar);\n#endif // WITH_MASSENTITY_DEBUG\n\n#if WITH_EDITOR\n\t\tif (bCreateProcessorGraphPreview)\n\t\t{\n\t\t\t// populating the phase processor with initial data for editor world so that the default processing graph\n\t\t\t// can be investigated in the editor without running PIE.\n\t\t\t// Runtime processing graph are initialized at runtime base on the actual archetypes instantiated at call time.\n\t\t\tFMassProcessorDependencySolver::FResult Result;\n\t\t\tResult.DependencyGraphFileName = DependencyGraphFileName;\n\t\t\tFMassPhaseProcessorConfigurationHelper Configurator(*PhaseProcessor, ProcessingPhasesConfig[PhaseAsInt], InOwner, EMassProcessingPhase(PhaseAsInt));\n\t\t\tConfigurator.bIsGameRuntime = false;\n\t\t\t// passing EProcessorExecutionFlags::All here to gather all available processors since bCreateProcessorGraphPreview \n\t\t\t// is true when we want to preview processors that might be available at runtime.\n\t\t\tConfigurator.Configure({}, EProcessorExecutionFlags::All, /*EntityManager=*/nullptr, &Result);\n\t\t}\n#endif // WITH_EDITOR\n\t}\n\n\tbIsAllowedToTick = true;\n}\n\nvoid FMassProcessingPhaseManager::Deinitialize()\n{\n\tfor (FMassProcessingPhase& Phase : ProcessingPhases)\n\t{\n\t\tPhase.PhaseProcessor = nullptr;\n\t}\n\n\tDynamicProcessors.Reset();\n}\n\nconst FGraphEventRef& FMassProcessingPhaseManager::TriggerPhase(const EMassProcessingPhase Phase, const float DeltaTime, const FGraphEventRef& MyCompletionGraphEvent)\n{\n\tcheck(Phase != EMassProcessingPhase::MAX);\n\n\tif (bIsAllowedToTick)\n\t{\n\t\tProcessingPhases[(int)Phase].ExecuteTick(DeltaTime, LEVELTICK_All, ENamedThreads::GameThread, MyCompletionGraphEvent);\n\t}\n\n\treturn MyCompletionGraphEvent;\n}\n\nvoid FMassProcessingPhaseManager::Start(UWorld& World)\n{\n\tUMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(&World);\n\n\tif (ensure(EntitySubsystem))\n\t{\n\t\tStart(EntitySubsystem->GetMutableEntityManager().AsShared());\n\t}\n\telse\n\t{\n\t\tUE_VLOG_UELOG(Owner.Get(), LogMass, Error, TEXT(\"Called %s while missing the EntitySubsystem\"), ANSI_TO_TCHAR(__FUNCTION__));\n\t}\n}\n\nvoid FMassProcessingPhaseManager::Start(const TSharedPtr<FMassEntityManager>& InEntityManager)\n{\n\tEntityManager = InEntityManager;\n\n\tOnNewArchetypeHandle = EntityManager->GetOnNewArchetypeEvent().AddRaw(this, &FMassProcessingPhaseManager::OnNewArchetype);\n\n\tif (UWorld* World = InEntityManager->GetWorld())\n\t{\n\t\tEnableTickFunctions(*World);\n\t}\n\n\tbIsAllowedToTick = true;\n}\n\nvoid FMassProcessingPhaseManager::AddReferencedObjects(FReferenceCollector& Collector)\n{\n\tfor (FMassProcessingPhase& Phase : ProcessingPhases)\n\t{\n\t\tif (Phase.PhaseProcessor)\n\t\t{\n\t\t\tCollector.AddReferencedObject(Phase.PhaseProcessor);\n\t\t}\n\t}\n\n\tfor (auto& DynamicProcessor : DynamicProcessors)\n\t{\n\t\tif (DynamicProcessor)\n\t\t{\n\t\t\tCollector.AddReferencedObject(DynamicProcessor);\n\t\t}\n\t}\n}\n\nvoid FMassProcessingPhaseManager::EnableTickFunctions(const UWorld& World)\n{\n\tcheck(EntityManager);\n\n\tconst bool bIsGameWorld = World.IsGameWorld();\n\n\tfor (FMassProcessingPhase& Phase : ProcessingPhases)\n\t{\n\t\tif (UE::Mass::Tweakables::bMakePrePhysicsTickFunctionHighPriority && (Phase.Phase == EMassProcessingPhase::PrePhysics))\n\t\t{\n\t\t\tconstexpr bool bHighPriority = true;\n\t\t\tPhase.SetPriorityIncludingPrerequisites(bHighPriority);\n\t\t}\n\n\t\tPhase.RegisterTickFunction(World.PersistentLevel);\n\t\tPhase.SetTickFunctionEnable(true);\n#if WITH_MASSENTITY_DEBUG\n\t\tif (Phase.PhaseProcessor && bIsGameWorld)\n\t\t{\n\t\t\t// not logging this in the editor mode since it messes up the game-recorded vislog display (with its progressively larger timestamp)\n\t\t\tFStringOutputDevice Ar;\n\t\t\tPhase.PhaseProcessor->DebugOutputDescription(Ar);\n\t\t\tUE_VLOG_UELOG(Owner.Get(), LogMass, Log, TEXT(\"Enabling phase %s tick:\\n%s\")\n\t\t\t\t, *UEnum::GetValueAsString(Phase.Phase), *Ar);\n\t\t}\n#endif // WITH_MASSENTITY_DEBUG\n\t}\n\n\tif (bIsGameWorld)\n\t{\n\t\t// not logging this in the editor mode since it messes up the game-recorded vislog display (with its progressively larger timestamp)\n\t\tUE_VLOG_UELOG(Owner.Get(), LogMass, Log, TEXT(\"MassProcessingPhaseManager %s.%s has been started\")\n\t\t\t, *GetNameSafe(Owner.Get()), *GetName());\n\t}\n}\n\nvoid FMassProcessingPhaseManager::Stop()\n{\n\tbIsAllowedToTick = false;\n\n\tif (EntityManager)\n\t{\n\t\tEntityManager->GetOnNewArchetypeEvent().Remove(OnNewArchetypeHandle);\n\t\tEntityManager.Reset();\n\t}\n\t\n\tfor (FMassProcessingPhase& Phase : ProcessingPhases)\n\t{\n\t\tPhase.SetTickFunctionEnable(false);\n\t}\n\n\tif (UObject* LocalOwner = Owner.Get())\n\t{\n\t\tUWorld* World = LocalOwner->GetWorld();\n\t\tif (World && World->IsGameWorld())\n\t\t{\n\t\t\t// not logging this in editor mode since it messes up the game-recorded vislog display (with its progressively larger timestamp) \n\t\t\tUE_VLOG_UELOG(LocalOwner, LogMass, Log, TEXT(\"MassProcessingPhaseManager %s.%s has been stopped\")\n\t\t\t\t, *GetNameSafe(LocalOwner), *GetName());\n\t\t}\n\t}\n}\n\nvoid FMassProcessingPhaseManager::OnPhaseStart(const FMassProcessingPhase& Phase)\n{\n\tensure(CurrentPhase == EMassProcessingPhase::MAX);\n\tCurrentPhase = Phase.Phase;\n\n\tconst int32 PhaseAsInt = int32(Phase.Phase);\n\tif (Owner.IsValid()\n\t\t&& ensure(Phase.Phase != EMassProcessingPhase::MAX)\n\t\t&& (ProcessingGraphBuildStates[PhaseAsInt].bNewArchetypes || ProcessingGraphBuildStates[PhaseAsInt].bProcessorsNeedRebuild)\n\t\t// if not a valid index then we're not able to recalculate dependencies \n\t\t&& ensure(ProcessingPhasesConfig.IsValidIndex(PhaseAsInt)))\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"Mass Rebuild Phase Graph\");\n\n\t\tFPhaseGraphBuildState& GraphBuildState = ProcessingGraphBuildStates[PhaseAsInt];\n\t\tif (GraphBuildState.bInitialized == false \n\t\t\t|| ProcessingGraphBuildStates[PhaseAsInt].bProcessorsNeedRebuild\n\t\t\t|| FMassProcessorDependencySolver::IsResultUpToDate(GraphBuildState.LastResult, EntityManager) == false)\n\t\t{\n\t\t\tUMassCompositeProcessor* PhaseProcessor = ProcessingPhases[PhaseAsInt].PhaseProcessor;\n\t\t\tcheck(PhaseProcessor);\n\n\t\t\tGraphBuildState.LastResult.Reset();\n\n\t\t\tFMassPhaseProcessorConfigurationHelper Configurator(*PhaseProcessor, ProcessingPhasesConfig[PhaseAsInt], *Owner.Get(), Phase.Phase);\n\t\t\tConfigurator.Configure(DynamicProcessors, ProcessorExecutionFlags, EntityManager, &GraphBuildState.LastResult);\n\n\t\t\tGraphBuildState.bInitialized = true;\n\n#if WITH_MASSENTITY_DEBUG\n\t\t\tUObject* OwnerPtr = Owner.Get();\n\t\t\t// print it all out to vislog\n\t\t\tUE_VLOG_UELOG(OwnerPtr, LogMass, Verbose, TEXT(\"Phases initialization done. Current composition:\"));\n\n\t\t\tFStringOutputDevice OutDescription;\n\t\t\tPhaseProcessor->DebugOutputDescription(OutDescription);\n\t\t\tUE_VLOG_UELOG(OwnerPtr, LogMass, Verbose, TEXT(\"--- %s\"), *OutDescription);\n\t\t\tOutDescription.Reset();\n#endif // WITH_MASSENTITY_DEBUG\n\t\t}\n\n\t\tProcessingGraphBuildStates[PhaseAsInt].bProcessorsNeedRebuild = false;\n\t\tProcessingGraphBuildStates[PhaseAsInt].bNewArchetypes = false;\n\t}\n}\n\nvoid FMassProcessingPhaseManager::OnPhaseEnd(FMassProcessingPhase& Phase)\n{\n\tensure(CurrentPhase == Phase.Phase);\n\tCurrentPhase = EMassProcessingPhase::MAX;\n\n\t// switch between parallel and single-thread versions only after a given batch of processing has been wrapped up\t\n\tif (Phase.IsConfiguredForParallelMode() != UE::Mass::Tweakables::bFullyParallel)\n\t{\n\t\tif (UE::Mass::Tweakables::bFullyParallel)\n\t\t{\n\t\t\tPhase.ConfigureForParallelMode();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPhase.ConfigureForSingleThreadMode();\n\t\t}\n\t}\n}\n\nFString FMassProcessingPhaseManager::GetName() const\n{\n\treturn GetNameSafe(Owner.Get()) + TEXT(\"_MassProcessingPhaseManager\");\n}\n\nvoid FMassProcessingPhaseManager::RegisterDynamicProcessor(UMassProcessor& Processor)\n{\n\tDynamicProcessors.Add(&Processor);\n\tProcessor.MarkAsDynamic();\n\tProcessingGraphBuildStates[uint32(Processor.GetProcessingPhase())].bProcessorsNeedRebuild = true;\n}\n\nvoid FMassProcessingPhaseManager::UnregisterDynamicProcessor(UMassProcessor& Processor)\n{\n\tint32 Index;\n\tif (DynamicProcessors.Find(&Processor, Index))\n\t{\n\t\tDynamicProcessors.RemoveAt(Index);\n\t\tProcessingGraphBuildStates[uint32(Processor.GetProcessingPhase())].bProcessorsNeedRebuild = true;\n\t}\n\telse\n\t{\n\t\tcheckf(false, TEXT(\"Unable to remove Processor '%s', as it was never added or already removed.\"), *Processor.GetName());\n\t}\n}\n\nvoid FMassProcessingPhaseManager::OnNewArchetype(const FMassArchetypeHandle& NewArchetype)\n{\n\tfor (FPhaseGraphBuildState& GraphBuildState : ProcessingGraphBuildStates)\n\t{\n\t\tGraphBuildState.bNewArchetypes = true;\n\t}\n}\n\n#undef LOCTEXT_NAMESPACE\n",
      "lines": 490
    },
    {
      "file_path": "MassEntity\\Private\\MassProcessingTypes.cpp",
      "extension": ".cpp",
      "size_bytes": 8399,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassProcessingTypes.h\"\n#include \"MassProcessor.h\"\n#include \"Misc/OutputDevice.h\"\n#include \"MassEntityUtils.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassDebugger.h\"\n#include \"Misc/CoreDelegates.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(MassProcessingTypes)\n\nDEFINE_LOG_CATEGORY(LogMass);\n\n//----------------------------------------------------------------------//\n//  FMassProcessingContext\n//----------------------------------------------------------------------//\nFMassProcessingContext::FMassProcessingContext(FMassEntityManager& InEntityManager, const float InDeltaSeconds)\n\t: EntityManager(InEntityManager.AsShared()), DeltaSeconds(InDeltaSeconds)\n{\n\n}\n\nFMassProcessingContext::FMassProcessingContext(TSharedPtr<FMassEntityManager>& InEntityManager, const float InDeltaSeconds)\n\t: EntityManager(InEntityManager), DeltaSeconds(InDeltaSeconds)\n{\n\n}\n\nFMassProcessingContext::~FMassProcessingContext()\n{\n\tif (CommandBuffer && CommandBuffer.IsUnique() && CommandBuffer->HasPendingCommands())\n\t{\n\t\tUE_CLOG(!EntityManager, LogMass, Error, TEXT(\"Unable to auto-flush FMassProcessingContext\\'s commands due to missing EntityManager\"));\n\t\tif (ensure(EntityManager))\n\t\t{\n\t\t\tUE_VLOG(EntityManager->GetOwner(), LogMass, Log, TEXT(\"Auto-flushing command buffer as part of FMassProcessingContext destruction\"));\n\t\t\tcheckf(CommandBuffer->IsFlushing() == false, TEXT(\"A totally unexpected scenario.\"));\n\t\t\tEntityManager->FlushCommands(CommandBuffer);\n\t\t}\n\t}\n}\n\n//----------------------------------------------------------------------//\n//  FMassRuntimePipeline\n//----------------------------------------------------------------------//\nvoid FMassRuntimePipeline::Reset()\n{\n\tProcessors.Reset();\n}\n\nvoid FMassRuntimePipeline::Initialize(UObject& Owner)\n{\n\t// having nulls in Processors should be rare so we run the \"remove all nulls\" operation below only if we know \n\t// for sure that there are any nulls to be removed\n\tbool bNullsFound = false;\n\n\tfor (UMassProcessor* Proc : Processors)\n\t{\n\t\tif (Proc)\n\t\t{\n\t\t\tif (Proc->IsInitialized() == false)\n\t\t\t{\n\t\t\t\tREDIRECT_OBJECT_TO_VLOG(Proc, &Owner);\n\t\t\t\tProc->Initialize(Owner);\n\t\t\t\tensureMsgf(Proc->IsInitialized(), TEXT(\"Missing Super::Initialize call for %s\"), *Proc->GetFullName());\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbNullsFound = true;\n\t\t}\n\t}\n\n\tif (bNullsFound)\n\t{\n\t\tProcessors.RemoveAll([](const UMassProcessor* Proc) { return Proc == nullptr; });\n\t}\n}\n\nvoid FMassRuntimePipeline::SetProcessors(TArray<UMassProcessor*>&& InProcessors)\n{\n\tReset();\n\tProcessors = InProcessors;\n}\n\nvoid FMassRuntimePipeline::CreateFromArray(TConstArrayView<const UMassProcessor*> InProcessors, UObject& InOwner)\n{\n\tReset();\n\tAppendOrOverrideRuntimeProcessorCopies(InProcessors, InOwner);\n}\n\nvoid FMassRuntimePipeline::InitializeFromArray(TConstArrayView<const UMassProcessor*> InProcessors, UObject& InOwner)\n{\n\tCreateFromArray(InProcessors, InOwner);\n\tInitialize(InOwner);\n}\n\nvoid FMassRuntimePipeline::InitializeFromClassArray(TConstArrayView<TSubclassOf<UMassProcessor>> InProcessorClasses, UObject& InOwner)\n{\n\tReset();\n\n\tconst UWorld* World = InOwner.GetWorld();\n\tconst EProcessorExecutionFlags WorldExecutionFlags = UE::Mass::Utils::DetermineProcessorExecutionFlags(World, ExecutionFlags);\n\n\tfor (const TSubclassOf<UMassProcessor>& ProcessorClass : InProcessorClasses)\n\t{\n\t\tif (ProcessorClass)\n\t\t{\n\t\t\tUMassProcessor* CDO = ProcessorClass.GetDefaultObject();\n\t\t\tif (CDO && CDO->ShouldExecute(WorldExecutionFlags))\n\t\t\t{\n\t\t\t\tUMassProcessor* ProcInstance = NewObject<UMassProcessor>(&InOwner, ProcessorClass);\n\t\t\t\tProcessors.Add(ProcInstance);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tUE_CVLOG(CDO, &InOwner, LogMass, Log, TEXT(\"Skipping %s due to ExecutionFlags\"), *CDO->GetName());\n\t\t\t}\n\t\t}\n\t}\n\n\tInitialize(InOwner);\n}\n\nbool FMassRuntimePipeline::HasProcessorOfExactClass(TSubclassOf<UMassProcessor> InClass) const\n{\n\tUClass* TestClass = InClass.Get();\n\treturn Processors.FindByPredicate([TestClass](const UMassProcessor* Proc){ return Proc != nullptr && Proc->GetClass() == TestClass; }) != nullptr;\n}\n\nvoid FMassRuntimePipeline::AppendUniqueRuntimeProcessorCopies(TConstArrayView<const UMassProcessor*> InProcessors, UObject& InOwner)\n{\n\tconst UWorld* World = InOwner.GetWorld();\n\tconst EProcessorExecutionFlags WorldExecutionFlags = UE::Mass::Utils::DetermineProcessorExecutionFlags(World, ExecutionFlags);\n\tconst int32 StartingCount = Processors.Num();\n\t\t\n\tfor (const UMassProcessor* Proc : InProcessors)\n\t{\n\t\tif (Proc && Proc->ShouldExecute(WorldExecutionFlags)\n\t\t\t&& (Proc->ShouldAllowMultipleInstances() || (HasProcessorOfExactClass(Proc->GetClass()) == false)))\n\t\t{\n\t\t\t// unfortunately the const cast is required since NewObject doesn't support const Template object\n\t\t\tUMassProcessor* ProcCopy = NewObject<UMassProcessor>(&InOwner, Proc->GetClass(), FName(), RF_NoFlags, const_cast<UMassProcessor*>(Proc));\n\t\t\tProcessors.Add(ProcCopy);\n\t\t}\n#if WITH_MASSENTITY_DEBUG\n\t\telse if (Proc)\n\t\t{\n\t\t\tif (Proc->ShouldExecute(WorldExecutionFlags) == false)\n\t\t\t{\n\t\t\t\tUE_VLOG(&InOwner, LogMass, Log, TEXT(\"Skipping %s due to ExecutionFlags\"), *Proc->GetName());\n\t\t\t}\n\t\t\telse if (Proc->ShouldAllowMultipleInstances() == false)\n\t\t\t{\n\t\t\t\tUE_VLOG(&InOwner, LogMass, Log, TEXT(\"Skipping %s due to it being a duplicate\"), *Proc->GetName());\n\t\t\t}\n\t\t}\n#endif // WITH_MASSENTITY_DEBUG\n\t}\n\n\tfor (int32 NewProcIndex = StartingCount; NewProcIndex < Processors.Num(); ++NewProcIndex)\n\t{\n\t\tUMassProcessor* Proc = Processors[NewProcIndex];\n\t\tcheck(Proc);\n\t\t\n\t\tif (Proc->IsInitialized() == false)\n\t\t{\n\t\t\tREDIRECT_OBJECT_TO_VLOG(Proc, &InOwner);\n\t\t\tProc->Initialize(InOwner);\n\t\t\tensureMsgf(Proc->IsInitialized(), TEXT(\"Missing Super::Initialize call for %s\"), *Proc->GetFullName());\n\t\t}\n\t}\n}\n\nvoid FMassRuntimePipeline::AppendOrOverrideRuntimeProcessorCopies(TConstArrayView<const UMassProcessor*> InProcessors, UObject& InOwner)\n{\n\tconst UWorld* World = InOwner.GetWorld();\n\tconst EProcessorExecutionFlags WorldExecutionFlags = UE::Mass::Utils::DetermineProcessorExecutionFlags(World, ExecutionFlags);\n\n\tfor (const UMassProcessor* Proc : InProcessors)\n\t{\n\t\tif (Proc && Proc->ShouldExecute(WorldExecutionFlags))\n\t\t{\n\t\t\t// unfortunately the const cast is required since NewObject doesn't support const Template object\n\t\t\tUMassProcessor* ProcCopy = NewObject<UMassProcessor>(&InOwner, Proc->GetClass(), FName(), RF_NoFlags, const_cast<UMassProcessor*>(Proc));\n\t\t\tcheck(ProcCopy);\n\n\t\t\tif (ProcCopy->ShouldAllowMultipleInstances())\n\t\t\t{\n\t\t\t\t// we don't care if there are instances of this class in Processors already\n\t\t\t\tProcessors.Add(ProcCopy);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tconst UClass* TestClass = Proc->GetClass();\n\t\t\t\tTObjectPtr<UMassProcessor>* PrevProcessor = Processors.FindByPredicate([TestClass, ProcCopy](const UMassProcessor* Proc) {\n\t\t\t\t\treturn Proc != nullptr && Proc->GetClass() == TestClass;\n\t\t\t\t});\n\n\t\t\t\tif (PrevProcessor)\n\t\t\t\t{\n\t\t\t\t\t*PrevProcessor = ProcCopy;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tProcessors.Add(ProcCopy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUE_CVLOG(Proc, &InOwner, LogMass, Log, TEXT(\"Skipping %s due to ExecutionFlags\"), *Proc->GetName());\n\t\t}\n\t}\n}\n\nvoid FMassRuntimePipeline::AppendProcessor(UMassProcessor& Processor)\n{\n\tProcessors.Add(&Processor);\n}\n\nvoid FMassRuntimePipeline::AppendProcessor(TSubclassOf<UMassProcessor> ProcessorClass, UObject& InOwner)\n{\n\tcheck(ProcessorClass);\n\tUMassProcessor* ProcInstance = NewObject<UMassProcessor>(&InOwner, ProcessorClass);\n\tAppendProcessor(*ProcInstance);\n}\n\nvoid FMassRuntimePipeline::RemoveProcessor(UMassProcessor& InProcessor)\n{\n\tProcessors.Remove(&InProcessor);\n}\n\nUMassCompositeProcessor* FMassRuntimePipeline::FindTopLevelGroupByName(FName GroupName)\n{\n\tfor (UMassProcessor* Processor : Processors)\n\t{\n\t\tUMassCompositeProcessor* CompositeProcessor = Cast<UMassCompositeProcessor>(Processor);\n\t\tif (CompositeProcessor && CompositeProcessor->GetGroupName() == GroupName)\n\t\t{\n\t\t\treturn CompositeProcessor;\n\t\t}\n\t}\n\treturn nullptr;\n}\n\nuint32 GetTypeHash(const FMassRuntimePipeline& Instance)\n{ \n\tuint32 Hash = 0;\n\tfor (const UMassProcessor* Proc : Instance.Processors)\n\t{\n\t\tHash = HashCombine(Hash, PointerHash(Proc));\n\t}\n\treturn Hash;\n}\n\n",
      "lines": 257
    },
    {
      "file_path": "MassEntity\\Private\\MassProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 21115,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassProcessor.h\"\n#include \"MassEntitySettings.h\"\n#include \"MassProcessorDependencySolver.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"Engine/World.h\"\n#include \"MassCommandBuffer.h\"\n#include \"MassExecutionContext.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(MassProcessor)\n\nDECLARE_CYCLE_STAT(TEXT(\"MassProcessor Group Completed\"), Mass_GroupCompletedTask, STATGROUP_TaskGraphTasks);\nDECLARE_CYCLE_STAT(TEXT(\"Mass Processor Task\"), STAT_Mass_DoTask, STATGROUP_Mass);\n\n#if WITH_MASSENTITY_DEBUG\nnamespace UE::Mass::Debug\n{\n\tbool bLogProcessingGraph = false;\n\tFAutoConsoleVariableRef CVarLogProcessingGraph(TEXT(\"mass.LogProcessingGraph\"), bLogProcessingGraph\n\t\t, TEXT(\"When enabled will log task graph tasks created while dispatching processors to other threads, along with their dependencies\"), ECVF_Cheat);\n}\n\n#define PROCESSOR_LOG(Verbosity, Fmt, ...) UE_VLOG_UELOG(this, LogMass, Verbosity, Fmt, ##__VA_ARGS__)\n\n// change to 1 to enable more detailed processing tasks logging\n#if 0\n#define PROCESSOR_TASK_LOG(Fmt, ...) UE_VLOG_UELOG(this, LogMass, Verbose, Fmt, ##__VA_ARGS__)\n#else\n#define PROCESSOR_TASK_LOG(...) \n#endif // 0\n\n#else \n#define PROCESSOR_LOG(...)\n#define PROCESSOR_TASK_LOG(...) \n#endif // WITH_MASSENTITY_DEBUG\n\nclass FMassProcessorTask\n{\npublic:\n\tFMassProcessorTask(const TSharedPtr<FMassEntityManager>& InEntityManager, const FMassExecutionContext& InExecutionContext, UMassProcessor& InProc, bool bInManageCommandBuffer = true)\n\t\t: EntityManager(InEntityManager)\n\t\t, ExecutionContext(InExecutionContext)\n\t\t, Processor(&InProc)\n\t\t, bManageCommandBuffer(bInManageCommandBuffer)\n\t{}\n\n\tstatic TStatId GetStatId()\n\t{\n\t\tRETURN_QUICK_DECLARE_CYCLE_STAT(FMassProcessorTask, STATGROUP_TaskGraphTasks);\n\t}\n\n\tstatic ESubsequentsMode::Type GetSubsequentsMode() { return ESubsequentsMode::TrackSubsequents; }\n\n\tstatic ENamedThreads::Type GetDesiredThread()\n\t{\n\t\treturn ENamedThreads::AnyHiPriThreadHiPriTask;\n\t}\n\n\tvoid DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)\n\t{\n\t\tcheckf(Processor, TEXT(\"Expecting a valid processor to execute\"));\n\n\t\tPROCESSOR_TASK_LOG(TEXT(\"+--+ Task %s started on %u\"), *Processor->GetProcessorName(), FPlatformTLS::GetCurrentThreadId());\n\t\tSCOPE_CYCLE_COUNTER(STAT_Mass_DoTask);\n\t\tSCOPE_CYCLE_COUNTER(STAT_Mass_Total);\n\n\t\tcheck(EntityManager);\n\t\tFMassEntityManager& EntityManagerRef = *EntityManager.Get();\n\t\tFMassEntityManager::FScopedProcessing ProcessingScope = EntityManagerRef.NewProcessingScope();\n\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"Mass Processor Task\");\n\t\t\n\t\tif (bManageCommandBuffer)\n\t\t{\n\t\t\tTSharedPtr<FMassCommandBuffer> MainSharedPtr = ExecutionContext.GetSharedDeferredCommandBuffer();\n\t\t\tExecutionContext.SetDeferredCommandBuffer(MakeShareable(new FMassCommandBuffer()));\n\t\t\tProcessor->CallExecute(EntityManagerRef, ExecutionContext);\n\t\t\tMainSharedPtr->MoveAppend(ExecutionContext.Defer());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tProcessor->CallExecute(EntityManagerRef, ExecutionContext);\n\t\t}\n\t\tPROCESSOR_TASK_LOG(TEXT(\"+--+ Task %s finished\"), *Processor->GetProcessorName());\n\t}\n\nprivate:\n\tTSharedPtr<FMassEntityManager> EntityManager;\n\tFMassExecutionContext ExecutionContext;\n\tUMassProcessor* Processor = nullptr;\n\t/** \n\t * indicates whether this task is responsible for creation of a dedicated command buffer and transferring over the \n\t * commands after processor's execution;\n\t */\n\tbool bManageCommandBuffer = true;\n};\n\nclass FMassProcessorsTask_GameThread : public FMassProcessorTask\n{\npublic:\n\tFMassProcessorsTask_GameThread(const TSharedPtr<FMassEntityManager>& InEntityManager, const FMassExecutionContext& InExecutionContext, UMassProcessor& InProc)\n\t\t: FMassProcessorTask(InEntityManager, InExecutionContext, InProc)\n\t{}\n\n\tstatic ENamedThreads::Type GetDesiredThread()\n\t{\n\t\treturn ENamedThreads::GameThread;\n\t}\n};\n\n//----------------------------------------------------------------------//\n// UMassProcessor \n//----------------------------------------------------------------------//\nUMassProcessor::UMassProcessor(const FObjectInitializer& ObjectInitializer)\n\t: UMassProcessor()\n{\n}\n\nUMassProcessor::UMassProcessor()\n\t: ExecutionFlags((int32)(EProcessorExecutionFlags::Server | EProcessorExecutionFlags::Standalone))\n{\n}\n\nvoid UMassProcessor::Initialize(UObject& Owner)\n{\n\tbInitialized = true;\n}\n\nvoid UMassProcessor::SetShouldAutoRegisterWithGlobalList(const bool bAutoRegister)\n{\t\n\tif (ensureMsgf(HasAnyFlags(RF_ClassDefaultObject), TEXT(\"Setting bAutoRegisterWithProcessingPhases for non-CDOs has no effect\")))\n\t{\n\t\tbAutoRegisterWithProcessingPhases = bAutoRegister;\n#if WITH_EDITOR\n\t\tif (UClass* Class = GetClass())\n\t\t{\n\t\t\tif (FProperty* AutoRegisterProperty = Class->FindPropertyByName(GET_MEMBER_NAME_CHECKED(UMassProcessor, bAutoRegisterWithProcessingPhases)))\n\t\t\t{\n\t\t\t\tUpdateSinglePropertyInConfigFile(AutoRegisterProperty, *GetDefaultConfigFilename());\n\t\t\t}\n\t\t}\n#endif // WITH_EDITOR\n\t}\n}\n\nvoid UMassProcessor::GetArchetypesMatchingOwnedQueries(const FMassEntityManager& EntityManager, TArray<FMassArchetypeHandle>& OutArchetype)\n{\n\tfor (FMassEntityQuery* QueryPtr : OwnedQueries)\n\t{\n\t\tCA_ASSUME(QueryPtr);\n\t\tQueryPtr->CacheArchetypes(EntityManager);\n\n\t\tfor (const FMassArchetypeHandle& ArchetypeHandle : QueryPtr->GetArchetypes())\n\t\t{\n\t\t\tOutArchetype.AddUnique(ArchetypeHandle);\n\t\t}\n\t}\n}\n\nbool UMassProcessor::DoesAnyArchetypeMatchOwnedQueries(const FMassEntityManager& EntityManager)\n{\n\tfor (FMassEntityQuery* QueryPtr : OwnedQueries)\n\t{\n\t\tCA_ASSUME(QueryPtr);\n\t\tQueryPtr->CacheArchetypes(EntityManager);\n\n\t\tif (QueryPtr->GetArchetypes().Num() > 0)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid UMassProcessor::PostInitProperties()\n{\n\tSuper::PostInitProperties();\n\n\t// We want even the CDO processors to be fully set up so that we can reason about processors based on CDOs, without \n\t// needing to instantiate processors based on a given class.\n\t// Note that we skip abstract processors because we're not going to instantiate them at runtime anyway.\n\tif (GetClass()->HasAnyClassFlags(CLASS_Abstract) == false)\n\t{\n\t\tConfigureQueries();\n\n\t\tbool bNeedsGameThread = ProcessorRequirements.DoesRequireGameThreadExecution();\n\t\tfor (const FMassEntityQuery* QueryPtr : OwnedQueries)\n\t\t{\n\t\t\tCA_ASSUME(QueryPtr);\n\t\t\tbNeedsGameThread = (bNeedsGameThread || QueryPtr->DoesRequireGameThreadExecution());\n\t\t}\n\n\t\tUE_CLOG(bRequiresGameThreadExecution != bNeedsGameThread, LogMass, Verbose\n\t\t\t, TEXT(\"%s is marked bRequiresGameThreadExecution = %s, while the registered queries' or processor requirements indicate the opposite\")\n\t\t\t, *GetProcessorName(), bRequiresGameThreadExecution ? TEXT(\"TRUE\") : TEXT(\"FALSE\"));\n\n\t\t// better safe than sorry - if queries or processor requirements indicate the game thread execution is required, then we marked the whole processor as such\n\t\tbRequiresGameThreadExecution = bRequiresGameThreadExecution || bNeedsGameThread;\n\t}\n#if CPUPROFILERTRACE_ENABLED\n\tStatId = GetProcessorName();\n#endif\n}\n\nvoid UMassProcessor::CallExecute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE_TEXT(*StatId);\n\tLLM_SCOPE_BYNAME(TEXT(\"Mass/ExecuteProcessor\"));\n\t// Not using a more specific scope by default (i.e. LLM_SCOPE_BYNAME(*StatId)) since LLM is more strict regarding the provided string (no spaces or '_')\n\n#if WITH_MASSENTITY_DEBUG\n\tContext.DebugSetExecutionDesc(FString::Printf(TEXT(\"%s (%s)\"), *GetProcessorName(), EntityManager.GetWorld() ? *ToString(EntityManager.GetWorld()->GetNetMode()) : TEXT(\"No World\")));\n#endif\n\t// CacheSubsystemRequirements will return true only if all requirements declared with ProcessorRequirements are met\n\t// meaning if it fails there's no point in calling Execute.\n\t// Note that we're not testing individual queries in OwnedQueries - processors can function just fine with some \n\t// of their queries not having anything to do.\n\tif (Context.CacheSubsystemRequirements(ProcessorRequirements))\n\t{\n\t\tExecute(EntityManager, Context);\n\t}\n\telse\n\t{\n\t\tPROCESSOR_LOG(VeryVerbose, TEXT(\"%s Skipping Execute due to subsystem requirements not being met\"), *GetProcessorName());\n\t}\n}\n\nbool UMassProcessor::ShouldAllowQueryBasedPruning(const bool bRuntimeMode) const\n{\n\treturn bRuntimeMode;\n}\n\nEMassProcessingPhase UMassProcessor::GetProcessingPhase() const\n{\n\treturn ProcessingPhase;\n}\n\nvoid UMassProcessor::SetProcessingPhase(EMassProcessingPhase Phase)\n{\n\tProcessingPhase = Phase;\n}\n\nvoid UMassProcessor::ExportRequirements(FMassExecutionRequirements& OutRequirements) const\n{\n\tfor (FMassEntityQuery* Query : OwnedQueries)\n\t{\n\t\tCA_ASSUME(Query);\n\t\tQuery->ExportRequirements(OutRequirements);\n\t}\n}\n\nvoid UMassProcessor::RegisterQuery(FMassEntityQuery& Query)\n{\n\tconst uintptr_t ThisStart = (uintptr_t)this;\n\tconst uintptr_t ThisEnd = ThisStart + GetClass()->GetStructureSize();\n\tconst uintptr_t QueryStart = (uintptr_t)&Query;\n\tconst uintptr_t QueryEnd = QueryStart + sizeof(FMassEntityQuery);\n\n\tif (QueryStart >= ThisStart && QueryEnd <= ThisEnd)\n\t{\n\t\tOwnedQueries.AddUnique(&Query);\n\t}\n\telse\n\t{\n\t\tstatic constexpr TCHAR MessageFormat[] = TEXT(\"Registering entity query for %s while the query is not given processor's member variable. Skipping.\");\n\t\tcheckf(false, MessageFormat, *GetProcessorName());\n\t\tUE_LOG(LogMass, Error, MessageFormat, *GetProcessorName());\n\t}\n}\n\nFGraphEventRef UMassProcessor::DispatchProcessorTasks(const TSharedPtr<FMassEntityManager>& EntityManager, FMassExecutionContext& ExecutionContext, const FGraphEventArray& Prerequisites)\n{\n\tFGraphEventRef ReturnVal;\n\tif (bRequiresGameThreadExecution)\n\t{\n\t\tReturnVal = TGraphTask<FMassProcessorsTask_GameThread>::CreateTask(&Prerequisites).ConstructAndDispatchWhenReady(EntityManager, ExecutionContext, *this);\n\t}\n\telse\n\t{\n\t\tReturnVal = TGraphTask<FMassProcessorTask>::CreateTask(&Prerequisites).ConstructAndDispatchWhenReady(EntityManager, ExecutionContext, *this);\n\t}\t\n\treturn ReturnVal;\n}\n\nFString UMassProcessor::GetProcessorName() const\n{\n\treturn GetName();\n}\n\nvoid UMassProcessor::DebugOutputDescription(FOutputDevice& Ar, int32 Indent) const\n{\n#if WITH_MASSENTITY_DEBUG\n\tAr.Logf(TEXT(\"%*s%s\"), Indent, TEXT(\"\"), *GetProcessorName());\n#endif // WITH_MASSENTITY_DEBUG\n}\n\n//----------------------------------------------------------------------//\n//  UMassCompositeProcessor\n//----------------------------------------------------------------------//\nUMassCompositeProcessor::UMassCompositeProcessor()\n\t: GroupName(TEXT(\"None\"))\n{\n\t// not auto-registering composite processors since the idea of the global processors list is to indicate all \n\t// the processors doing the work while composite processors are just containers. Having said that subclasses \n\t// can change this behavior if need be.\n\tbAutoRegisterWithProcessingPhases = false;\n}\n\nvoid UMassCompositeProcessor::SetChildProcessors(TArray<UMassProcessor*>&& InProcessors)\n{\n\tChildPipeline.SetProcessors(MoveTemp(InProcessors));\n}\n\nvoid UMassCompositeProcessor::ConfigureQueries()\n{\n\t// nothing to do here since ConfigureQueries will get automatically called for all the processors in ChildPipeline\n\t// via their individual PostInitProperties call\n}\n\nFGraphEventRef UMassCompositeProcessor::DispatchProcessorTasks(const TSharedPtr<FMassEntityManager>& EntityManager, FMassExecutionContext& ExecutionContext, const FGraphEventArray& InPrerequisites)\n{\n\tFGraphEventArray Events;\n\tEvents.Reserve(FlatProcessingGraph.Num());\n\t\t\n\tfor (FDependencyNode& ProcessingNode : FlatProcessingGraph)\n\t{\n\t\tFGraphEventArray Prerequisites;\n\t\tfor (const int32 DependencyIndex : ProcessingNode.Dependencies)\n\t\t{\n\t\t\tPrerequisites.Add(Events[DependencyIndex]);\n\t\t}\n\n\t\t// we don't expect any group nodes at this point. If we get any there's a bug in dependencies solving\n\t\tif (ensure(ProcessingNode.Processor))\n\t\t{\n\t\t\tEvents.Add(ProcessingNode.Processor->DispatchProcessorTasks(EntityManager, ExecutionContext, Prerequisites));\n\t\t}\n\t}\n\n\n#if WITH_MASSENTITY_DEBUG\n\tif (UE::Mass::Debug::bLogProcessingGraph)\n\t{\n\t\tfor (int i = 0; i < FlatProcessingGraph.Num(); ++i)\n\t\t{\n\t\t\tFDependencyNode& ProcessingNode = FlatProcessingGraph[i];\n\t\t\tFString DependenciesDesc;\n\t\t\tfor (const int32 DependencyIndex : ProcessingNode.Dependencies)\n\t\t\t{\n\t\t\t\tDependenciesDesc += FString::Printf(TEXT(\"%s, \"), *FlatProcessingGraph[DependencyIndex].Name.ToString());\n\t\t\t}\n\n\t\t\tcheck(ProcessingNode.Processor);\n\t\t\tPROCESSOR_TASK_LOG(TEXT(\"Task %u %s%s%s\"), Events[i]->GetTraceId(), *ProcessingNode.Processor->GetProcessorName()\n\t\t\t\t, DependenciesDesc.Len() > 0 ? TEXT(\" depends on \") : TEXT(\"\"), *DependenciesDesc);\n\t\t}\n\t}\n#endif // WITH_MASSENTITY_DEBUG\n\n\tFGraphEventRef CompletionEvent = FFunctionGraphTask::CreateAndDispatchWhenReady([this](){}\n\t\t, GET_STATID(Mass_GroupCompletedTask), &Events, ENamedThreads::AnyHiPriThreadHiPriTask);\n\n\treturn CompletionEvent;\n}\n\nvoid UMassCompositeProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tfor (UMassProcessor* Proc : ChildPipeline.GetMutableProcessors())\n\t{\n\t\tcheck(Proc);\n\t\tProc->CallExecute(EntityManager, Context);\n\t}\n}\n\nvoid UMassCompositeProcessor::Initialize(UObject& Owner)\n{\n\tChildPipeline.Initialize(Owner);\n\tSuper::Initialize(Owner);\n}\n\nvoid UMassCompositeProcessor::SetProcessors(TArrayView<UMassProcessor*> InProcessorInstances, const TSharedPtr<FMassEntityManager>& EntityManager)\n{\n\t// figure out dependencies\n\tFMassProcessorDependencySolver Solver(InProcessorInstances);\n\tTArray<FMassProcessorOrderInfo> SortedProcessors;\n\tSolver.ResolveDependencies(SortedProcessors, EntityManager);\n\n\tUpdateProcessorsCollection(SortedProcessors);\n\n\tif (Solver.IsSolvingForSingleThread() == false)\n\t{\n\t\tBuildFlatProcessingGraph(SortedProcessors);\n\t}\n}\n\nvoid UMassCompositeProcessor::BuildFlatProcessingGraph(TConstArrayView<FMassProcessorOrderInfo> SortedProcessors)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE(Mass_BuildFlatProcessingGraph);\n#if !MASS_DO_PARALLEL\n\tUE_LOG(LogMass, Warning\n\t\t, TEXT(\"MassCompositeProcessor::BuildFlatProcessingGraph is not expected to run in a single-threaded Mass setup. The flat graph will not be used at runtime.\"));\n#endif // MASS_DO_PARALLEL\n\n\tFlatProcessingGraph.Reset();\n\n\t// this part is creating an ordered, flat list of processors that can be executed in sequence\n\t// with subsequent task only depending on the elements prior on the list\n\tTMap<FName, int32> NameToDependencyIndex;\n\tNameToDependencyIndex.Reserve(SortedProcessors.Num());\n\tTArray<int32> SuperGroupDependency;\n\tfor (const FMassProcessorOrderInfo& Element : SortedProcessors)\n\t{\n\t\tNameToDependencyIndex.Add(Element.Name, FlatProcessingGraph.Num());\n\n\t\t// we don't expect to get any \"group\" nodes here. If it happens it indicates a bug in dependency solving\n\t\tcheckSlow(Element.Processor);\n\t\tFDependencyNode& Node = FlatProcessingGraph.Add_GetRef({ Element.Name, Element.Processor });\n\t\tNode.Dependencies.Reserve(Element.Dependencies.Num());\n\t\tfor (FName DependencyName : Element.Dependencies)\n\t\t{\n\t\t\tcheckSlow(DependencyName.IsNone() == false);\n\t\t\tNode.Dependencies.Add(NameToDependencyIndex.FindChecked(DependencyName));\n\t\t}\n#if WITH_MASSENTITY_DEBUG\n\t\tNode.SequenceIndex = Element.SequenceIndex;\n#endif // WITH_MASSENTITY_DEBUG\n\t}\n\n#if WITH_MASSENTITY_DEBUG\n\tFScopedCategoryAndVerbosityOverride LogOverride(TEXT(\"LogMass\"), ELogVerbosity::Log);\n\tUE_LOG(LogMass, Log, TEXT(\"%s flat processing graph:\"), *GroupName.ToString());\n\n\tint32 Index = 0;\n\tfor (const FDependencyNode& ProcessingNode : FlatProcessingGraph)\n\t{\n\t\tFString DependenciesDesc;\n\t\tfor (const int32 DependencyIndex : ProcessingNode.Dependencies)\n\t\t{\n\t\t\tDependenciesDesc += FString::Printf(TEXT(\"%d, \"), DependencyIndex);\n\t\t}\n\t\tif (ProcessingNode.Processor)\n\t\t{\n\t\t\tUE_LOG(LogMass, Log, TEXT(\"[%2d]%*s%s%s%s\"), Index, ProcessingNode.SequenceIndex * 2, TEXT(\"\"), *ProcessingNode.Processor->GetProcessorName()\n\t\t\t\t, DependenciesDesc.Len() > 0 ? TEXT(\" depends on \") : TEXT(\"\"), *DependenciesDesc);\n\t\t}\n\t\t++Index;\n\t}\n#endif // WITH_MASSENTITY_DEBUG\n}\n\nvoid UMassCompositeProcessor::UpdateProcessorsCollection(TArrayView<FMassProcessorOrderInfo> InOutOrderedProcessors, EProcessorExecutionFlags InWorldExecutionFlags)\n{\n\tTArray<TObjectPtr<UMassProcessor>> ExistingProcessors(ChildPipeline.GetMutableProcessors());\n\tChildPipeline.Reset();\n\n\tconst UWorld* World = GetWorld();\n\tconst EProcessorExecutionFlags WorldExecutionFlags = UE::Mass::Utils::DetermineProcessorExecutionFlags(World, InWorldExecutionFlags);\n\tconst FMassProcessingPhaseConfig& PhaseConfig = GET_MASS_CONFIG_VALUE(GetProcessingPhaseConfig(ProcessingPhase));\n\n\tfor (FMassProcessorOrderInfo& ProcessorInfo : InOutOrderedProcessors)\n\t{\n\t\tif (ensureMsgf(ProcessorInfo.NodeType == FMassProcessorOrderInfo::EDependencyNodeType::Processor, TEXT(\"Encountered unexpected FMassProcessorOrderInfo::EDependencyNodeType while populating %s\"), *GetGroupName().ToString()))\n\t\t{\n\t\t\tcheckSlow(ProcessorInfo.Processor);\n\t\t\tif (ProcessorInfo.Processor->ShouldExecute(WorldExecutionFlags))\n\t\t\t{\n\t\t\t\t// we want to reuse existing processors to maintain state. It's recommended to keep processors state-less\n\t\t\t\t// but we already have processors that do have some state, like signaling processors.\n\t\t\t\t// the following search only makes sense for \"single instance\" processors\n\t\t\t\tif (ProcessorInfo.Processor->ShouldAllowMultipleInstances() == false)\n\t\t\t\t{\n\t\t\t\t\tTObjectPtr<UMassProcessor>* FoundProcessor = ExistingProcessors.FindByPredicate([ProcessorClass = ProcessorInfo.Processor->GetClass()](TObjectPtr<UMassProcessor>& Element)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn Element && (Element->GetClass() == ProcessorClass);\n\t\t\t\t\t\t});\n\n\t\t\t\t\tif (FoundProcessor)\n\t\t\t\t\t{\n\t\t\t\t\t\t// overriding the stored value since the InOutOrderedProcessors can get used after the call and it \n\t\t\t\t\t\t// needs to reflect the actual work performed\n\t\t\t\t\t\tProcessorInfo.Processor = FoundProcessor->Get();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tCA_ASSUME(ProcessorInfo.Processor);\n\t\t\t\tChildPipeline.AppendProcessor(*ProcessorInfo.Processor);\n\t\t\t}\n\t\t}\n\t}\n}\n\nFString UMassCompositeProcessor::GetProcessorName() const\n{\n\treturn GroupName.ToString();\n}\n\nvoid UMassCompositeProcessor::DebugOutputDescription(FOutputDevice& Ar, int32 Indent) const\n{\n#if WITH_MASSENTITY_DEBUG\n\tif (ChildPipeline.Num() == 0)\n\t{\n\t\tAr.Logf(TEXT(\"%*sGroup %s: []\"), Indent, TEXT(\"\"), *GroupName.ToString());\n\t}\n\telse\n\t{\n\t\tAr.Logf(TEXT(\"%*sGroup %s:\"), Indent, TEXT(\"\"), *GroupName.ToString());\n\t\tfor (UMassProcessor* Proc : ChildPipeline.GetProcessors())\n\t\t{\n\t\t\tcheck(Proc);\n\t\t\tAr.Logf(TEXT(\"\\n\"));\n\t\t\tProc->DebugOutputDescription(Ar, Indent + 3);\n\t\t}\n\t}\n#endif // WITH_MASSENTITY_DEBUG\n}\n\nvoid UMassCompositeProcessor::SetProcessingPhase(EMassProcessingPhase Phase)\n{\n\tSuper::SetProcessingPhase(Phase);\n\tfor (UMassProcessor* Proc : ChildPipeline.GetMutableProcessors())\n\t{\n\t\tProc->SetProcessingPhase(Phase);\n\t}\n}\n\nvoid UMassCompositeProcessor::SetGroupName(FName NewName)\n{\n\tGroupName = NewName;\n#if CPUPROFILERTRACE_ENABLED\n\tStatId = GroupName.ToString();\n#endif\n}\n\nvoid UMassCompositeProcessor::AddGroupedProcessor(FName RequestedGroupName, UMassProcessor& Processor)\n{\n\tif (RequestedGroupName.IsNone() || RequestedGroupName == GroupName)\n\t{\n\t\tChildPipeline.AppendProcessor(Processor);\n\t}\n\telse\n\t{\n\t\tFString RemainingGroupName;\n\t\tUMassCompositeProcessor* GroupProcessor = FindOrAddGroupProcessor(RequestedGroupName, &RemainingGroupName);\n\t\tcheck(GroupProcessor);\n\t\tGroupProcessor->AddGroupedProcessor(FName(*RemainingGroupName), Processor);\n\t}\n}\n\nUMassCompositeProcessor* UMassCompositeProcessor::FindOrAddGroupProcessor(FName RequestedGroupName, FString* OutRemainingGroupName)\n{\n\tUMassCompositeProcessor* GroupProcessor = nullptr;\n\tconst FString NameAsString = RequestedGroupName.ToString();\n\tFString TopGroupName;\n\tif (NameAsString.Split(TEXT(\".\"), &TopGroupName, OutRemainingGroupName))\n\t{\n\t\tRequestedGroupName = FName(*TopGroupName);\n\t}\n\tGroupProcessor = ChildPipeline.FindTopLevelGroupByName(RequestedGroupName);\n\n\tif (GroupProcessor == nullptr)\n\t{\n\t\tcheck(GetOuter());\n\t\tGroupProcessor = NewObject<UMassCompositeProcessor>(GetOuter());\n\t\tGroupProcessor->SetGroupName(RequestedGroupName);\n\t\tChildPipeline.AppendProcessor(*GroupProcessor);\n\t}\n\n\treturn GroupProcessor;\n}\n\n//-----------------------------------------------------------------------------\n// DEPRECATED\n//-----------------------------------------------------------------------------\nvoid UMassCompositeProcessor::Populate(TConstArrayView<FMassProcessorOrderInfo> OrderedProcessors)\n{\n\tTArray<FMassProcessorOrderInfo> OrderedProcessorsCopy(OrderedProcessors);\n\tUpdateProcessorsCollection(OrderedProcessorsCopy, EProcessorExecutionFlags::None);\n}\n",
      "lines": 579
    },
    {
      "file_path": "MassEntity\\Private\\MassProcessorDependencySolver.cpp",
      "extension": ".cpp",
      "size_bytes": 48502,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassProcessorDependencySolver.h\"\n#include \"MassProcessingTypes.h\"\n#include \"MassProcessor.h\"\n#include \"Logging/MessageLog.h\"\n#include \"HAL/FileManager.h\"\n#include \"Misc/Paths.h\"\n#include \"Engine/World.h\"\n\n#define LOCTEXT_NAMESPACE \"Mass\"\n\nnamespace UE::Mass::Private\n{\n\tFString NameViewToString(TConstArrayView<FName> View)\n\t{\n\t\tif (View.Num() == 0)\n\t\t{\n\t\t\treturn TEXT(\"[]\");\n\t\t}\n\t\tFString ReturnVal = FString::Printf(TEXT(\"[%s\"), *View[0].ToString());\n\t\tfor (int i = 1; i < View.Num(); ++i)\n\t\t{\n\t\t\tReturnVal += FString::Printf(TEXT(\", %s\"), *View[i].ToString());\n\t\t}\n\t\treturn ReturnVal + TEXT(\"]\");\n\t}\n\n\tbool DoArchetypeContainersOverlap(TConstArrayView<FMassArchetypeHandle> A, const TArray<FMassArchetypeHandle>& B)\n\t{\n\t\tfor (const FMassArchetypeHandle& HandleA : A)\n\t\t{\n\t\t\tif (B.Contains(HandleA))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\n//----------------------------------------------------------------------//\n//  FMassExecutionRequirements\n//----------------------------------------------------------------------//\nvoid FMassExecutionRequirements::Append(const FMassExecutionRequirements& Other)\n{\n\tfor (int i = 0; i < EMassAccessOperation::MAX; ++i)\n\t{\n\t\tFragments[i] += Other.Fragments[i];\n\t\tChunkFragments[i] += Other.ChunkFragments[i];\n\t\tSharedFragments[i] += Other.SharedFragments[i];\n\t\tRequiredSubsystems[i] += Other.RequiredSubsystems[i];\n\t}\n\tConstSharedFragments.Read += Other.ConstSharedFragments.Read;\n\n\tRequiredAllTags += Other.RequiredAllTags;\n\tRequiredAnyTags += Other.RequiredAnyTags;\n\tRequiredNoneTags += Other.RequiredNoneTags;\n\t// note that we're deliberately ignoring optional tags, they play no role here.\n\n\t// signal that it requires recalculation;\n\tResourcesUsedCount = INDEX_NONE;\n}\n\nvoid FMassExecutionRequirements::CountResourcesUsed()\n{\n\tResourcesUsedCount = ConstSharedFragments.Read.CountStoredTypes();\n\n\tfor (int i = 0; i < EMassAccessOperation::MAX; ++i)\n\t{\n\t\tResourcesUsedCount += Fragments[i].CountStoredTypes();\n\t\tResourcesUsedCount += ChunkFragments[i].CountStoredTypes();\n\t\tResourcesUsedCount += SharedFragments[i].CountStoredTypes();\n\t\tResourcesUsedCount += RequiredSubsystems[i].CountStoredTypes();\n\t}\n}\n\nint32 FMassExecutionRequirements::GetTotalBitsUsedCount()\n{\n\tCountResourcesUsed();\n\n\treturn ResourcesUsedCount + RequiredAllTags.CountStoredTypes()\n\t\t+ RequiredAnyTags.CountStoredTypes() + RequiredNoneTags.CountStoredTypes();\n}\n\nbool FMassExecutionRequirements::IsEmpty() const\n{\n\treturn Fragments.IsEmpty() && ChunkFragments.IsEmpty() \n\t\t&& SharedFragments.IsEmpty() && ConstSharedFragments.IsEmpty() && RequiredSubsystems.IsEmpty()\n\t\t&& RequiredAllTags.IsEmpty() && RequiredAnyTags.IsEmpty() && RequiredNoneTags.IsEmpty();\n}\n\nFMassArchetypeCompositionDescriptor FMassExecutionRequirements::AsCompositionDescriptor() const\n{\n\treturn FMassArchetypeCompositionDescriptor(Fragments.Read + Fragments.Write\n\t\t, RequiredAllTags + RequiredAnyTags\n\t\t, ChunkFragments.Read + ChunkFragments.Write\n\t\t, SharedFragments.Read + SharedFragments.Write\n\t\t, ConstSharedFragments.Read);\n}\n\n//----------------------------------------------------------------------//\n//  FProcessorDependencySolver::FResourceUsage\n//----------------------------------------------------------------------//\nFMassProcessorDependencySolver::FResourceUsage::FResourceUsage(const TArray<FNode>& InAllNodes)\n\t: AllNodesView(InAllNodes)\n{\n\tfor (int i = 0; i < EMassAccessOperation::MAX; ++i)\n\t{\n\t\tFragmentsAccess[i].Access.AddZeroed(FMassFragmentBitSet::GetMaxNum());\n\t\tChunkFragmentsAccess[i].Access.AddZeroed(FMassChunkFragmentBitSet::GetMaxNum());\n\t\tSharedFragmentsAccess[i].Access.AddZeroed(FMassSharedFragmentBitSet::GetMaxNum());\n\t\tRequiredSubsystemsAccess[i].Access.AddZeroed(FMassExternalSubsystemBitSet::GetMaxNum());\n\t}\n}\n\ntemplate<typename TBitSet>\nvoid FMassProcessorDependencySolver::FResourceUsage::HandleElementType(TMassExecutionAccess<FResourceAccess>& ElementAccess\n\t, const TMassExecutionAccess<TBitSet>& TestedRequirements, FMassProcessorDependencySolver::FNode& InOutNode, const int32 NodeIndex)\n{\n\tusing UE::Mass::Private::DoArchetypeContainersOverlap;\n\n\t// for every bit set in TestedRequirements we do the following:\n\t// 1. For every read-only requirement we make InOutNode depend on the currently stored Writer of this resource\n\t//    - note that this operation is not destructive, meaning we don't destructively consume the data, since all \n\t//      subsequent read access to the given resource will also depend on the Writer\n\t//    - note 2: we also fine tune what we store as a dependency for InOutNode by checking if InOutNode's archetype\n\t//      overlap with whoever the current Writer is \n\t//    - this will result in InOutNode wait for the current Writer to finish before starting its own work and \n\t//      that's exactly what we need to do to avoid accessing data while it's potentially being written\n\t// 2. For every read-write requirement we make InOutNode depend on all the readers and writers currently stored. \n\t//    - once that's done we clean currently stored Readers and Writers since every subsequent operation on this \n\t//      resource will be blocked by currently considered InOutNode (as the new Writer)\n\t//    - again, we do check corresponding archetype collections overlap\n\t//    - similarly to the read operation waiting on write operations in pt 1. we want to hold off the write \n\t//      operations to be performed by InOutNode until all currently registered (and conflicting) writers and readers \n\t//      are done with their operations \n\t// 3. For all accessed resources we store information that InOutNode is accessing it\n\t//    - we do this so that the following nodes know that they'll have to wait for InOutNode if an access \n\t//      conflict arises. \n\n\t// 1. For every read only requirement we make InOutNode depend on the currently stored Writer of this resource\n\tfor (auto It = TestedRequirements.Read.GetIndexIterator(); It; ++It)\n\t{\n\t\tfor (int32 UserIndex : ElementAccess.Write.Access[*It].Users)\n\t\t{\n\t\t\tif (DoArchetypeContainersOverlap(AllNodesView[UserIndex].ValidArchetypes, InOutNode.ValidArchetypes))\n\t\t\t{\n\t\t\t\tInOutNode.OriginalDependencies.Add(UserIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. For every read-write requirement we make InOutNode depend on all the readers and writers currently stored. \n\tfor (auto It = TestedRequirements.Write.GetIndexIterator(); It; ++It)\n\t{\n\t\tfor (int32 i = ElementAccess.Read.Access[*It].Users.Num() - 1; i >= 0; --i)\n\t\t{\n\t\t\tconst int32 UserIndex = ElementAccess.Read.Access[*It].Users[i];\n\t\t\tif (DoArchetypeContainersOverlap(AllNodesView[UserIndex].ValidArchetypes, InOutNode.ValidArchetypes))\n\t\t\t{\t\n\t\t\t\tInOutNode.OriginalDependencies.Add(UserIndex);\n\t\t\t\tElementAccess.Read.Access[*It].Users.RemoveAtSwap(i);\n\t\t\t}\n\t\t}\n\n\t\tfor (int32 i = ElementAccess.Write.Access[*It].Users.Num() - 1; i >= 0; --i)\n\t\t{\n\t\t\tconst int32 UserIndex = ElementAccess.Write.Access[*It].Users[i];\n\t\t\tif (DoArchetypeContainersOverlap(AllNodesView[UserIndex].ValidArchetypes, InOutNode.ValidArchetypes))\n\t\t\t{\n\t\t\t\tInOutNode.OriginalDependencies.Add(UserIndex);\n\t\t\t\tElementAccess.Write.Access[*It].Users.RemoveAtSwap(i);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 3. For all accessed resources we store information that InOutNode is accessing it\n\tfor (auto It = TestedRequirements.Read.GetIndexIterator(); It; ++It)\n\t{\n\t\t// mark Element at index indicated by It as being used in mode EMassAccessOperation(i) by NodeIndex\n\t\tElementAccess.Read.Access[*It].Users.Add(NodeIndex);\n\t}\n\tfor (auto It = TestedRequirements.Write.GetIndexIterator(); It; ++It)\n\t{\n\t\t// mark Element at index indicated by It as being used in mode EMassAccessOperation(i) by NodeIndex\n\t\tElementAccess.Write.Access[*It].Users.Add(NodeIndex);\n\t}\n}\n\ntemplate<typename TBitSet>\nbool FMassProcessorDependencySolver::FResourceUsage::CanAccess(const TMassExecutionAccess<TBitSet>& StoredElements, const TMassExecutionAccess<TBitSet>& TestedElements)\n{\n\t// see if there's an overlap of tested write operations with existing read & write operations, as well as \n\t// tested read operations with existing write operations\n\t\n\treturn !(\n\t\t// if someone's already writing to what I want to write\n\t\tTestedElements.Write.HasAny(StoredElements.Write)\n\t\t// or if someone's already reading what I want to write\n\t\t|| TestedElements.Write.HasAny(StoredElements.Read)\n\t\t// or if someone's already writing what I want to read\n\t\t|| TestedElements.Read.HasAny(StoredElements.Write)\n\t);\n}\n\nbool FMassProcessorDependencySolver::FResourceUsage::HasArchetypeConflict(TMassExecutionAccess<FResourceAccess> ElementAccess, const TArray<FMassArchetypeHandle>& InArchetypes) const\n{\n\tusing UE::Mass::Private::DoArchetypeContainersOverlap;\n\n\t// this function is being run when we've already determined there's an access conflict on given ElementsAccess,\n\t// meaning whoever's asking is trying to access Elements that are already being used. We can still grant access \n\t// though provided that none of the current users of Element access the same archetypes the querier does (as provided \n\t// by InArchetypes).\n\t// @todo this operation could be even more efficient and precise if we tracked which operation (read/write) and which\n\t// specific Element were conflicting and the we could limit the check to that. That would however significantly \n\t// complicate the code and would require a major refactor to keep things clean.\n\tfor (int i = 0; i < EMassAccessOperation::MAX; ++i)\n\t{\n\t\tfor (const FResourceUsers& Resource : ElementAccess[i].Access)\n\t\t{\n\t\t\tfor (const int32 UserIndex : Resource.Users)\n\t\t\t{\n\t\t\t\tif (DoArchetypeContainersOverlap(AllNodesView[UserIndex].ValidArchetypes, InArchetypes))\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool FMassProcessorDependencySolver::FResourceUsage::CanAccessRequirements(const FMassExecutionRequirements& TestedRequirements, const TArray<FMassArchetypeHandle>& InArchetypes) const\n{\n\t// note that on purpose we're not checking ConstSharedFragments - those are always only read, no danger of conflicting access\n\tbool bCanAccess = (CanAccess<FMassFragmentBitSet>(Requirements.Fragments, TestedRequirements.Fragments) || !HasArchetypeConflict(FragmentsAccess, InArchetypes))\n\t\t&& (CanAccess<FMassChunkFragmentBitSet>(Requirements.ChunkFragments, TestedRequirements.ChunkFragments) || !HasArchetypeConflict(ChunkFragmentsAccess, InArchetypes))\n\t\t&& (CanAccess<FMassSharedFragmentBitSet>(Requirements.SharedFragments, TestedRequirements.SharedFragments) || !HasArchetypeConflict(SharedFragmentsAccess, InArchetypes))\n\t\t&& CanAccess<FMassExternalSubsystemBitSet>(Requirements.RequiredSubsystems, TestedRequirements.RequiredSubsystems);\n\n\treturn bCanAccess;\n}\n\nvoid FMassProcessorDependencySolver::FResourceUsage::SubmitNode(const int32 NodeIndex, FNode& InOutNode)\n{\n\tHandleElementType<FMassFragmentBitSet>(FragmentsAccess, InOutNode.Requirements.Fragments, InOutNode, NodeIndex);\n\tHandleElementType<FMassChunkFragmentBitSet>(ChunkFragmentsAccess, InOutNode.Requirements.ChunkFragments, InOutNode, NodeIndex);\n\tHandleElementType<FMassSharedFragmentBitSet>(SharedFragmentsAccess, InOutNode.Requirements.SharedFragments, InOutNode, NodeIndex);\n\tHandleElementType<FMassExternalSubsystemBitSet>(RequiredSubsystemsAccess, InOutNode.Requirements.RequiredSubsystems, InOutNode, NodeIndex);\n\t// note that on purpose we're not pushing ConstSharedFragments - those are always only read, no danger of conflicting access\n\t// so there's no point in tracking them\n\n\tRequirements.Append(InOutNode.Requirements);\n}\n\n//----------------------------------------------------------------------//\n//  FProcessorDependencySolver::FNode\n//----------------------------------------------------------------------//\nvoid FMassProcessorDependencySolver::FNode::IncreaseWaitingNodesCount(TArrayView<FMassProcessorDependencySolver::FNode> InAllNodes)\n{\n\t// cycle-protection check. If true it means we have a cycle and the whole algorithm result will be unreliable \n\tif (TotalWaitingNodes >= FMath::Square(InAllNodes.Num()))\n\t{\n\t\treturn;\n\t}\n\n\t++TotalWaitingNodes;\n\n\tfor (const int32 DependencyIndex : OriginalDependencies)\n\t{\n\t\tcheck(&InAllNodes[DependencyIndex] != this);\n\t\tInAllNodes[DependencyIndex].IncreaseWaitingNodesCount(InAllNodes);\n\t}\n}\n//----------------------------------------------------------------------//\n//  FProcessorDependencySolver\n//----------------------------------------------------------------------//\nFMassProcessorDependencySolver::FMassProcessorDependencySolver(TArrayView<UMassProcessor* const> InProcessors, const bool bIsGameRuntime)\n\t: Processors(InProcessors)\n\t, bGameRuntime(bIsGameRuntime)\n{}\n\nbool FMassProcessorDependencySolver::PerformSolverStep(FResourceUsage& ResourceUsage, TArray<int32>& InOutIndicesRemaining, TArray<int32>& OutNodeIndices)\n{\n\tint32 AcceptedNodeIndex = INDEX_NONE;\n\tint32 FallbackAcceptedNodeIndex = INDEX_NONE;\n\n\tfor (int32 i = 0; i < InOutIndicesRemaining.Num(); ++i)\n\t{\n\t\tconst int32 NodeIndex = InOutIndicesRemaining[i];\n\t\tif (AllNodes[NodeIndex].TransientDependencies.Num() == 0)\n\t\t{\n\t\t\t// if we're solving dependencies for a single thread use we don't need to fine-tune the order based on resources nor archetypes\n\t\t\tif (bSingleThreadTarget || ResourceUsage.CanAccessRequirements(AllNodes[NodeIndex].Requirements, AllNodes[NodeIndex].ValidArchetypes))\n\t\t\t{\n\t\t\t\tAcceptedNodeIndex = NodeIndex;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (FallbackAcceptedNodeIndex == INDEX_NONE)\n\t\t\t{\n\t\t\t\t// if none of the nodes left can \"cleanly\" execute (i.e. without conflicting with already stored nodes)\n\t\t\t\t// we'll just pick this one up and go with it. \n\t\t\t\tFallbackAcceptedNodeIndex = NodeIndex;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (AcceptedNodeIndex != INDEX_NONE || FallbackAcceptedNodeIndex != INDEX_NONE)\n\t{\n\t\tconst int32 NodeIndex = AcceptedNodeIndex != INDEX_NONE ? AcceptedNodeIndex : FallbackAcceptedNodeIndex;\n\n\t\tFNode& Node = AllNodes[NodeIndex];\n\n\t\t// Note that this is not an unexpected event and will happen during every dependency solving. It's a part \n\t\t// of the algorithm. We initially look for all the things we can run without conflicting with anything else. \n\t\t// But that can't last forever, at some point we'll end up in a situation where every node left waits for \n\t\t// something that has been submitted already. Then we just pick one of the waiting ones (the one indicated by \n\t\t// FallbackAcceptedNodeIndex), \"run it\" and proceed.\n\t\tUE_CLOG(AcceptedNodeIndex == INDEX_NONE, LogMass, Verbose, TEXT(\"No dependency-free node can be picked, due to resource requirements. Picking %s as the next node.\")\n\t\t\t, *Node.Name.ToString());\n\n\t\tResourceUsage.SubmitNode(NodeIndex, Node);\n\t\tInOutIndicesRemaining.RemoveSingle(NodeIndex);\n\t\tOutNodeIndices.Add(NodeIndex);\n\t\tfor (const int32 DependencyIndex : Node.OriginalDependencies)\n\t\t{\n\t\t\tNode.SequencePositionIndex = FMath::Max(Node.SequencePositionIndex, AllNodes[DependencyIndex].SequencePositionIndex);\n\t\t}\n\t\t++Node.SequencePositionIndex;\n\n\t\tfor (const int32 RemainingNodeIndex : InOutIndicesRemaining)\n\t\t{\n\t\t\tAllNodes[RemainingNodeIndex].TransientDependencies.RemoveSingleSwap(NodeIndex, EAllowShrinking::No);\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid FMassProcessorDependencySolver::CreateSubGroupNames(FName InGroupName, TArray<FString>& SubGroupNames)\n{\n\t// the function will convert composite group name into a series of progressively more precise group names\n\t// so \"A.B.C\" will result in [\"A\", \"A.B\", \"A.B.C\"]\n\n\tSubGroupNames.Reset();\n\tFString GroupNameAsString = InGroupName.ToString();\n\tFString TopGroupName;\n\n\twhile (GroupNameAsString.Split(TEXT(\".\"), &TopGroupName, &GroupNameAsString))\n\t{\n\t\tSubGroupNames.Add(TopGroupName);\n\t}\n\tSubGroupNames.Add(GroupNameAsString);\n\t\n\tfor (int i = 1; i < SubGroupNames.Num(); ++i)\n\t{\n\t\tSubGroupNames[i] = FString::Printf(TEXT(\"%s.%s\"), *SubGroupNames[i - 1], *SubGroupNames[i]);\n\t}\n}\n\nint32 FMassProcessorDependencySolver::CreateNodes(UMassProcessor& Processor)\n{\n\tcheck(Processor.GetClass());\n\t// for processors supporting multiple instances we use processor name rather than processor's class name for\n\t// dependency calculations. This makes the user responsible for fine-tuning per-processor dependencies. \n\tconst FName ProcName = Processor.ShouldAllowMultipleInstances() \n\t\t? Processor.GetFName()\n\t\t: Processor.GetClass()->GetFName();\n\n\tif (const int32* NodeIndexPtr = NodeIndexMap.Find(ProcName))\n\t{\n\t\tif (Processor.ShouldAllowMultipleInstances())\n\t\t{\n\t\t\tUE_LOG(LogMass, Warning, TEXT(\"%hs Processor %s, name %s, already registered. This processor class does suport duplicates, but individual instances need to have a unique name.\")\n\t\t\t\t, __FUNCTION__, *Processor.GetFullName(), *ProcName.ToString());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUE_LOG(LogMass, Warning, TEXT(\"%hs Processor %s already registered. Duplicates are not supported by this processor class.\")\n\t\t\t\t, __FUNCTION__, *ProcName.ToString());\n\t\t}\n\t\treturn *NodeIndexPtr;\n\t}\n\n\tconst FMassProcessorExecutionOrder& ExecutionOrder = Processor.GetExecutionOrder();\n\n\t// first figure out the groups so that the group nodes come before the processor nodes, this is required for child\n\t// nodes to inherit group's dependencies like in scenarios where some processor required to ExecuteBefore a given group\n\tint32 ParentGroupNodeIndex = INDEX_NONE;\n\tif (ExecutionOrder.ExecuteInGroup.IsNone() == false)\n\t{\n\t\tTArray<FString> AllGroupNames;\n\t\tCreateSubGroupNames(ExecutionOrder.ExecuteInGroup, AllGroupNames);\n\t\n\t\tcheck(AllGroupNames.Num() > 0);\n\n\t\tfor (const FString& GroupName : AllGroupNames)\n\t\t{\n\t\t\tconst FName GroupFName(GroupName);\n\t\t\tint32* LocalGroupIndex = NodeIndexMap.Find(GroupFName);\n\t\t\t// group name hasn't been encountered yet - create it\n\t\t\tif (LocalGroupIndex == nullptr)\n\t\t\t{\n\t\t\t\tint32 NewGroupNodeIndex = AllNodes.Num();\n\t\t\t\tNodeIndexMap.Add(GroupFName, NewGroupNodeIndex);\n\t\t\t\tFNode& GroupNode = AllNodes.Add_GetRef({ GroupFName, nullptr, NewGroupNodeIndex });\n\t\t\t\t// just ignore depending on the dummy \"root\" node\n\t\t\t\tif (ParentGroupNodeIndex != INDEX_NONE)\n\t\t\t\t{\n\t\t\t\t\tGroupNode.OriginalDependencies.Add(ParentGroupNodeIndex);\n\t\t\t\t\tAllNodes[ParentGroupNodeIndex].SubNodeIndices.Add(NewGroupNodeIndex);\n\t\t\t\t}\n\n\t\t\t\tParentGroupNodeIndex = NewGroupNodeIndex;\n\t\t\t}\n\t\t\telse\n\t\t\t{\t\n\t\t\t\tParentGroupNodeIndex = *LocalGroupIndex;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tconst int32 NodeIndex = AllNodes.Num();\n\tNodeIndexMap.Add(ProcName, NodeIndex);\n\tFNode& ProcessorNode = AllNodes.Add_GetRef({ ProcName, &Processor, NodeIndex });\n\n\tProcessorNode.ExecuteAfter.Append(ExecutionOrder.ExecuteAfter);\n\tProcessorNode.ExecuteBefore.Append(ExecutionOrder.ExecuteBefore);\n\tProcessor.ExportRequirements(ProcessorNode.Requirements);\n\tProcessorNode.Requirements.CountResourcesUsed();\n\n\tif (ParentGroupNodeIndex > 0)\n\t{\n\t\tAllNodes[ParentGroupNodeIndex].SubNodeIndices.Add(NodeIndex);\n\t}\n\n\treturn NodeIndex;\n}\n\nvoid FMassProcessorDependencySolver::BuildDependencies()\n{\n\t// at this point we have collected all the known processors and groups in AllNodes so we can transpose \n\t// A.ExecuteBefore(B) type of dependencies into B.ExecuteAfter(A)\n\tfor (int32 NodeIndex = 0; NodeIndex < AllNodes.Num(); ++NodeIndex)\n\t{\n\t\tfor (int i = 0; i < AllNodes[NodeIndex].ExecuteBefore.Num(); ++i)\n\t\t{\n\t\t\tconst FName BeforeDependencyName = AllNodes[NodeIndex].ExecuteBefore[i];\n\t\t\tint32 DependentNodeIndex = INDEX_NONE;\n\t\t\tint32* DependentNodeIndexPtr = NodeIndexMap.Find(BeforeDependencyName);\n\t\t\tif (DependentNodeIndexPtr == nullptr)\n\t\t\t{\n\t\t\t\t// missing dependency. Adding a \"dummy\" node representing those to still support ordering based on missing groups or processors \n\t\t\t\t// For example, if Processor A and B declare dependency, respectively, \"Before C\" and \"After C\" we still \n\t\t\t\t// expect A to come before B regardless of whether C exists or not.\n\t\t\t\t\n\t\t\t\tDependentNodeIndex = AllNodes.Num();\n\t\t\t\tNodeIndexMap.Add(BeforeDependencyName, DependentNodeIndex);\n\t\t\t\tAllNodes.Add({ BeforeDependencyName, nullptr, DependentNodeIndex });\n\n\t\t\t\tUE_LOG(LogMass, Log, TEXT(\"Unable to find dependency \\\"%s\\\" declared by %s. Creating a dummy dependency node.\")\n\t\t\t\t\t, *BeforeDependencyName.ToString(), *AllNodes[NodeIndex].Name.ToString());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDependentNodeIndex = *DependentNodeIndexPtr;\n\t\t\t}\n\n\t\t\tcheck(AllNodes.IsValidIndex(DependentNodeIndex));\n\t\t\tAllNodes[DependentNodeIndex].ExecuteAfter.Add(AllNodes[NodeIndex].Name);\n\t\t}\n\t\tAllNodes[NodeIndex].ExecuteBefore.Reset();\n\t}\n\n\t// at this point all nodes contain:\n\t// - single \"original dependency\" pointing at its parent group\n\t// - ExecuteAfter populated with node names\n\n\t// Now, for every Name in ExecuteAfter we do the following:\n\t//\tif Name represents a processor, add it as \"original dependency\"\n\t//\telse, if Name represents a group:\n\t//\t\t- append all group's child node names to ExecuteAfter\n\t// \n\tfor (int32 NodeIndex = 0; NodeIndex < AllNodes.Num(); ++NodeIndex)\n\t{\n\t\tfor (int i = 0; i < AllNodes[NodeIndex].ExecuteAfter.Num(); ++i)\n\t\t{\n\t\t\tconst FName AfterDependencyName = AllNodes[NodeIndex].ExecuteAfter[i];\n\t\t\tint32* PrerequisiteNodeIndexPtr = NodeIndexMap.Find(AfterDependencyName);\n\t\t\tint32 PrerequisiteNodeIndex = INDEX_NONE;\n\n\t\t\tif (PrerequisiteNodeIndexPtr == nullptr)\n\t\t\t{\n\t\t\t\t// missing dependency. Adding a \"dummy\" node representing those to still support ordering based on missing groups or processors \n\t\t\t\t// For example, if Processor A and B declare dependency, respectively, \"Before C\" and \"After C\" we still \n\t\t\t\t// expect A to come before B regardless of whether C exists or not.\n\n\t\t\t\tPrerequisiteNodeIndex = AllNodes.Num();\n\t\t\t\tNodeIndexMap.Add(AfterDependencyName, PrerequisiteNodeIndex);\n\t\t\t\tAllNodes.Add({ AfterDependencyName, nullptr, PrerequisiteNodeIndex });\n\n\t\t\t\tUE_LOG(LogMass, Log, TEXT(\"Unable to find dependency \\\"%s\\\" declared by %s. Creating a dummy dependency node.\")\n\t\t\t\t\t, *AfterDependencyName.ToString(), *AllNodes[NodeIndex].Name.ToString());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tPrerequisiteNodeIndex = *PrerequisiteNodeIndexPtr;\n\t\t\t}\n\n\t\t\tconst FNode& PrerequisiteNode = AllNodes[PrerequisiteNodeIndex];\n\n\t\t\tif (PrerequisiteNode.IsGroup())\n\t\t\t{\n\t\t\t\tfor (int32 SubNodeIndex : PrerequisiteNode.SubNodeIndices)\n\t\t\t\t{\n\t\t\t\t\tAllNodes[NodeIndex].ExecuteAfter.AddUnique(AllNodes[SubNodeIndex].Name);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAllNodes[NodeIndex].OriginalDependencies.AddUnique(PrerequisiteNodeIndex);\n\t\t\t}\n\t\t}\n\n\t\t// if this node is a group push all the dependencies down on all the children\n\t\t// by design all child nodes come after group nodes so the child nodes' dependencies have not been processed yet\n\t\tif (AllNodes[NodeIndex].IsGroup() && AllNodes[NodeIndex].SubNodeIndices.Num())\n\t\t{\n\t\t\tfor (int32 PrerequisiteNodeIndex : AllNodes[NodeIndex].OriginalDependencies)\n\t\t\t{\n\t\t\t\tcheckSlow(PrerequisiteNodeIndex != NodeIndex);\n\t\t\t\t// in case of processor nodes we can store it directly\n\t\t\t\tif (AllNodes[PrerequisiteNodeIndex].IsGroup() == false)\n\t\t\t\t{\n\t\t\t\t\tfor (int32 ChildNodeIndex : AllNodes[NodeIndex].SubNodeIndices)\n\t\t\t\t\t{\n\t\t\t\t\t\tAllNodes[ChildNodeIndex].OriginalDependencies.AddUnique(PrerequisiteNodeIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// special case - if dependency is a group and we haven't processed that group yet, we need to add it by name\n\t\t\t\telse if (PrerequisiteNodeIndex > NodeIndex)\n\t\t\t\t{\n\t\t\t\t\tconst FName& PrerequisiteName = AllNodes[PrerequisiteNodeIndex].Name;\n\t\t\t\t\tfor (int32 ChildNodeIndex : AllNodes[NodeIndex].SubNodeIndices)\n\t\t\t\t\t{\n\t\t\t\t\t\tAllNodes[ChildNodeIndex].ExecuteAfter.AddUnique(PrerequisiteName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid FMassProcessorDependencySolver::LogNode(const FNode& Node, int Indent)\n{\n\tusing UE::Mass::Private::NameViewToString;\n\n\tif (Node.IsGroup())\n\t{\n\t\tUE_LOG(LogMass, Log, TEXT(\"%*s%s before:%s after:%s\"), Indent, TEXT(\"\"), *Node.Name.ToString()\n\t\t\t, *NameViewToString(Node.ExecuteBefore)\n\t\t\t, *NameViewToString(Node.ExecuteAfter));\n\n\t\tfor (const int32 NodeIndex : Node.SubNodeIndices)\n\t\t{\n\t\t\tLogNode(AllNodes[NodeIndex], Indent + 4);\n\t\t}\n\t}\n\telse\n\t{\n\t\tCA_ASSUME(Node.Processor); // as implied by Node.IsGroup() == false\n\t\tUE_LOG(LogMass, Log, TEXT(\"%*s%s before:%s after:%s\"), Indent, TEXT(\"\"), *Node.Name.ToString()\n\t\t\t, *NameViewToString(Node.Processor->GetExecutionOrder().ExecuteBefore)\n\t\t\t, *NameViewToString(Node.Processor->GetExecutionOrder().ExecuteAfter));\n\t}\n}\n\n#if 0 // disabled the graph building for now, leaving the old code here for reference\nstruct FDumpGraphDependencyUtils\n{\n\tstatic void DumpGraphNode(FArchive& LogFile, const FProcessorDependencySolver::FNode& Node, int Indent, TSet<const FProcessorDependencySolver::FNode*>& AllNodes, const bool bRoot)\n\t{\n\t\tconst FString NodeName = Node.Name.ToString();\n\t\tif (!Node.Processor)\n\t\t{\n\t\t\tconst FString ClusterNodeName = NodeName.Replace(TEXT(\".\"), TEXT(\"_\"));\n\t\t\tconst FString GraphNodeName = NodeName.Replace(TEXT(\".\"), TEXT(\" \"));\n\n\t\t\tint32 Index = -1;\n\t\t\tNode.Name.ToString().FindLastChar(TEXT('.'), Index);\n\t\t\tconst FString GroupName = NodeName.Mid(Index+1);\n\n\t\t\tLogFile.Logf(TEXT(\"%*ssubgraph cluster_%s\"), Indent, TEXT(\"\"), *ClusterNodeName);\n\t\t\tLogFile.Logf(TEXT(\"%*s{\"), Indent, TEXT(\"\"));\n\t\t\tLogFile.Logf(TEXT(\"%*slabel =\\\"%s\\\";\"), Indent + 4, TEXT(\"\"), *GroupName);\n\t\t\tLogFile.Logf(TEXT(\"%*s\\\"%s Start\\\"%s;\"), Indent + 4, TEXT(\"\"), *GraphNodeName, bRoot ? TEXT(\"\") : TEXT(\"[shape=point style=invis]\"));\n\t\t\tLogFile.Logf(TEXT(\"%*s\\\"%s End\\\"%s;\"), Indent + 4, TEXT(\"\"), *GraphNodeName, bRoot ? TEXT(\"\") : TEXT(\"[shape=point style=invis]\"));\n\t\t\tfor (const FProcessorDependencySolver::FNode& SubNode : Node.SubNodes)\n\t\t\t{\n\t\t\t\tDumpGraphNode(LogFile, SubNode, Indent + 4, AllNodes, false);\n\t\t\t}\n\t\t\tLogFile.Logf(TEXT(\"%*s}\"), Indent, TEXT(\"\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLogFile.Logf(TEXT(\"%*s\\\"%s\\\"\"), Indent, TEXT(\"\"), *NodeName);\n\t\t\tAllNodes.Add(&Node);\n\t\t}\n\t}\n\n\tstatic const FProcessorDependencySolver::FNode* FindDepNodeInParents(const TArray<const FProcessorDependencySolver::FNode*>& Parents, FName DependencyName)\n\t{\n\t\tfor (int32 i = Parents.Num() - 1; i >= 0; --i)\n\t\t{\n\t\t\tconst FProcessorDependencySolver::FNode* CurNode = Parents[i];\n\t\t\tint32 DependencyIndex = CurNode->FindNodeIndex(DependencyName);\n\t\t\twhile(DependencyIndex != INDEX_NONE)\n\t\t\t{\n\t\t\t\tif(CurNode->SubNodes[DependencyIndex].Name == DependencyName)\n\t\t\t\t{\n\t\t\t\t\treturn &CurNode->SubNodes[DependencyIndex];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Dig down the chain\n\t\t\t\t\tCurNode = &CurNode->SubNodes[DependencyIndex];\n\t\t\t\t\tDependencyIndex = CurNode->FindNodeIndex(DependencyName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nullptr;\n\t};\n\n\tstatic bool DoAllSubNodeHasDependency(const FProcessorDependencySolver::FNode& Node, const FName DependencyName, bool bBeforeDep)\n\t{\n\t\tbool bDepExistInAllSibling = true;\n\t\tfor (const FProcessorDependencySolver::FNode& SiblingSubNode : Node.SubNodes)\n\t\t{\n\t\t\tif (SiblingSubNode.Processor)\n\t\t\t{\n\t\t\t\tconst TArray<FName>& ExecuteDep = bBeforeDep ? SiblingSubNode.Processor->GetExecutionOrder().ExecuteBefore : SiblingSubNode.Processor->GetExecutionOrder().ExecuteAfter;\n\t\t\t\tif (ExecuteDep.Find(DependencyName) == INDEX_NONE)\n\t\t\t\t{\n\t\t\t\t\tbDepExistInAllSibling = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!DoAllSubNodeHasDependency(SiblingSubNode, DependencyName, bBeforeDep))\n\t\t\t{\n\t\t\t\tbDepExistInAllSibling = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn bDepExistInAllSibling;\n\t}\n\n\tstatic bool DoesDependencyExistIndirectly(const TArray<const FProcessorDependencySolver::FNode*>& Parents, const FProcessorDependencySolver::FNode& Node, const FName DepNameToFind, bool bBeforeDep)\n\t{\n\t\tcheck(Node.Processor);\n\t\tconst TArray<FName>& ExecuteDep = bBeforeDep ? Node.Processor->GetExecutionOrder().ExecuteBefore : Node.Processor->GetExecutionOrder().ExecuteAfter;\n\t\tfor (const FName& DependencyName : ExecuteDep)\n\t\t{\n\t\t\tif (DependencyName == DepNameToFind)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (const FProcessorDependencySolver::FNode* DepNode = FindDepNodeInParents(Parents, DependencyName))\n\t\t\t{\n\t\t\t\tif(DepNode->Processor)\n\t\t\t\t{\n\t\t\t\t\tconst TArray<FName>& ExecuteDepDep = bBeforeDep ? DepNode->Processor->GetExecutionOrder().ExecuteBefore : DepNode->Processor->GetExecutionOrder().ExecuteAfter;\n\t\t\t\t\tif(ExecuteDepDep.Find(DepNameToFind) != INDEX_NONE)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(DoAllSubNodeHasDependency(*DepNode, DepNameToFind, bBeforeDep))\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic void RemoveAllProcessorFromSet(const FProcessorDependencySolver::FNode& DepNode, TSet<const FProcessorDependencySolver::FNode*>& Set)\n\t{\n\t\tif (DepNode.Processor)\n\t\t{\n\t\t\tSet.Remove(&DepNode);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (const FProcessorDependencySolver::FNode& SubNode : DepNode.SubNodes)\n\t\t\t{\n\t\t\t\tRemoveAllProcessorFromSet(SubNode, Set);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic bool AreAllProcessorInSet(const FProcessorDependencySolver::FNode& DepNode, TSet<const FProcessorDependencySolver::FNode*>& Set)\n\t{\n\t\tif (DepNode.Processor)\n\t\t{\n\t\t\tif (!Set.Contains(&DepNode))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (const FProcessorDependencySolver::FNode& SubNode : DepNode.SubNodes)\n\t\t\t{\n\t\t\t\tif (!AreAllProcessorInSet(SubNode, Set))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic void DumpGraphDependencies(FArchive& LogFile, const FProcessorDependencySolver::FNode& Node, TArray<const FProcessorDependencySolver::FNode*> Parents, TArray<const FProcessorDependencySolver::FNode*> CommonBeforeDep, TArray<const FProcessorDependencySolver::FNode*> CommonAfterDep, TSet<const FProcessorDependencySolver::FNode*>& DependsOnStart, TSet<const FProcessorDependencySolver::FNode*>& LinkToEnd)\n\t{\n\t\tconst FString NodeName = Node.Name.ToString();\n\t\tconst FProcessorDependencySolver::FNode* ParentNode = Parents.Num() > 0 ? Parents.Last() : nullptr;\n\t\tconst FString ParentNodeName = ParentNode ? ParentNode->Name.ToString() : TEXT(\"\");\n\t\tconst FString ParentGraphNodeName = ParentNodeName.Replace(TEXT(\".\"), TEXT(\" \"));\n\t\tconst FString ParentClusterNodeName = ParentNodeName.Replace(TEXT(\".\"), TEXT(\"_\"));\n\t\tif (Node.Processor)\n\t\t{\n\t\t\tfor (const FName& DependencyName : Node.Processor->GetExecutionOrder().ExecuteBefore)\n\t\t\t{\n\t\t\t\tif (const FProcessorDependencySolver::FNode* DepNode = FindDepNodeInParents(Parents, DependencyName))\n\t\t\t\t{\n\t\t\t\t\tLinkToEnd.Remove(&Node);\n\t\t\t\t\tRemoveAllProcessorFromSet(*DepNode, DependsOnStart);\n\n\t\t\t\t\tif (CommonBeforeDep.Find(DepNode) != INDEX_NONE)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (DoesDependencyExistIndirectly(Parents, Node, DependencyName, true))\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst FString DepNodeName = DepNode->Name.ToString();\n\t\t\t\t\tif (DepNode->Processor)\n\t\t\t\t\t{\n\t\t\t\t\t\tLogFile.Logf(TEXT(\"    \\\"%s\\\" -> \\\"%s\\\";\"), *NodeName, *DepNodeName);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tconst FString DepClusterNodeName = DepNodeName.Replace(TEXT(\".\"), TEXT(\"_\"));\n\t\t\t\t\t\tconst FString DepGraphNodeName = DepNodeName.Replace(TEXT(\".\"), TEXT(\" \"));\n\t\t\t\t\t\tLogFile.Logf(TEXT(\"    \\\"%s\\\" -> \\\"%s Start\\\"[lhead=cluster_%s];\"), *NodeName, *DepGraphNodeName, *DepClusterNodeName);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const FName& DependencyName : Node.Processor->GetExecutionOrder().ExecuteAfter)\n\t\t\t{\n\t\t\t\tif (const FProcessorDependencySolver::FNode* DepNode = FindDepNodeInParents(Parents, DependencyName))\n\t\t\t\t{\n\t\t\t\t\tDependsOnStart.Remove(&Node);\n\t\t\t\t\tRemoveAllProcessorFromSet(*DepNode, LinkToEnd);\n\n\t\t\t\t\tif (CommonAfterDep.Find(DepNode) != INDEX_NONE)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (DoesDependencyExistIndirectly(Parents, Node, DependencyName, false))\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst FString DepNodeName = DepNode->Name.ToString();\n\t\t\t\t\tif (DepNode->Processor)\n\t\t\t\t\t{\n\t\t\t\t\t\tLogFile.Logf(TEXT(\"    \\\"%s\\\" -> \\\"%s\\\";\"), *DepNodeName, *NodeName);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tconst FString DepClusterNodeName = DepNodeName.Replace(TEXT(\".\"), TEXT(\"_\"));\n\t\t\t\t\t\tconst FString DepGraphNodeName = DepNodeName.Replace(TEXT(\".\"), TEXT(\" \"));\n\t\t\t\t\t\tLogFile.Logf(TEXT(\"    \\\"%s End\\\" -> \\\"%s\\\"[ltail=cluster_%s];\"), *DepGraphNodeName, *NodeName, *DepClusterNodeName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Layouting\n\t\t\tLogFile.Logf(TEXT(\"    \\\"%s Start\\\" -> \\\"%s\\\" -> \\\"%s End\\\"[style=invis];\"), *ParentGraphNodeName, *NodeName, *ParentGraphNodeName);\n\t\t}\n\t\telse if (ParentNode)\n\t\t{\n\n\t\t\tconst FString ClusterNodeName = NodeName.Replace(TEXT(\".\"), TEXT(\"_\"));\n\t\t\tconst FString GraphNodeName = NodeName.Replace(TEXT(\".\"), TEXT(\" \"));\n\n\t\t\t// Find common dependency through out all sub nodes\n \t\t\tTSet<FName> BeforeDepOuputed;\n \t\t\tTSet<FName> AfterDepOutputed;\n\t\t\tfor (const FProcessorDependencySolver::FNode& SubNode : Node.SubNodes)\n\t\t\t{\n\t\t\t\tif(SubNode.Processor)\n\t\t\t\t{\n\t\t\t\t\tfor (const FName& DependencyName : SubNode.Processor->GetExecutionOrder().ExecuteBefore)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (const FProcessorDependencySolver::FNode* DepNode = FindDepNodeInParents(Parents, DependencyName))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (DoAllSubNodeHasDependency(Node, DependencyName, true /*bBeforeDep*/))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCommonBeforeDep.Add(DepNode);\n\n\t\t\t\t\t\t\t\tif (!DoesDependencyExistIndirectly(Parents, SubNode, DependencyName, true))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (BeforeDepOuputed.Contains(DependencyName))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tBeforeDepOuputed.Add(DependencyName);\n\n\t\t\t\t\t\t\t\t\tconst FString DepNodeName = DepNode->Name.ToString();\n\t\t\t\t\t\t\t\t\tif (DepNode->Processor)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tLogFile.Logf(TEXT(\"    \\\"%s End\\\" -> \\\"%s\\\"[ltail=cluster_%s];\"), *GraphNodeName, *DepNodeName, *ClusterNodeName);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tconst FString DepClusterNodeName = DepNodeName.Replace(TEXT(\".\"), TEXT(\"_\"));\n\t\t\t\t\t\t\t\t\t\tconst FString DepGraphNodeName = DepNodeName.Replace(TEXT(\".\"), TEXT(\" \"));\n\t\t\t\t\t\t\t\t\t\tLogFile.Logf(TEXT(\"    \\\"%s End\\\" -> \\\"%s Start\\\"[ltail=cluster_%s, lhead=cluster_%s];\"), *GraphNodeName, *DepGraphNodeName, *ClusterNodeName, *DepClusterNodeName);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const FName& DependencyName : SubNode.Processor->GetExecutionOrder().ExecuteAfter)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (const FProcessorDependencySolver::FNode* DepNode = FindDepNodeInParents(Parents, DependencyName))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (DoAllSubNodeHasDependency(Node, DependencyName, false /*bBeforeDep*/))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCommonAfterDep.Add(DepNode);\n\n\t\t\t\t\t\t\t\tif (!DoesDependencyExistIndirectly(Parents, SubNode, DependencyName, false))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (AfterDepOutputed.Contains(DependencyName))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tAfterDepOutputed.Add(DependencyName);\n\n\t\t\t\t\t\t\t\t\tconst FString DepNodeName = DepNode->Name.ToString();\n\t\t\t\t\t\t\t\t\tif (DepNode->Processor)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tLogFile.Logf(TEXT(\"    \\\"%s\\\" -> \\\"%s Start\\\"[lhead=cluster_%s];\"), *DepNodeName, *GraphNodeName, *ClusterNodeName);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tconst FString DepClusterNodeName = DepNodeName.Replace(TEXT(\".\"), TEXT(\"_\"));\n\t\t\t\t\t\t\t\t\t\tconst FString DepGraphNodeName = DepNodeName.Replace(TEXT(\".\"), TEXT(\" \"));\n\t\t\t\t\t\t\t\t\t\tLogFile.Logf(TEXT(\"    \\\"%s End\\\" -> \\\"%s Start\\\"[ltail=cluster_%s, lhead=cluster_%s];\"), *DepGraphNodeName,*GraphNodeName, *DepClusterNodeName, *ClusterNodeName);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n \t\t\t// Layouting\n\t\t\tLogFile.Logf(TEXT(\"    \\\"%s Start\\\" -> \\\"%s Start\\\" -> \\\"%s End\\\" -> \\\"%s End\\\"[style=invis];\"), *ParentGraphNodeName, *GraphNodeName, *GraphNodeName, *ParentGraphNodeName);\n\t\t}\n\n\t\tParents.Push(&Node);\n\t\tfor (const FProcessorDependencySolver::FNode& SubNode : Node.SubNodes)\n\t\t{\n\t\t\tDumpGraphDependencies(LogFile, SubNode, Parents, CommonBeforeDep, CommonAfterDep, DependsOnStart, LinkToEnd);\n\t\t}\n\t}\n\n\tstatic void PromoteStartAndEndDependency(FArchive& LogFile, const FString& GraphName, const FProcessorDependencySolver::FNode& Node, TSet<const FProcessorDependencySolver::FNode*>& DependsOnStart, TSet<const FProcessorDependencySolver::FNode*>& LinkToEnd)\n\t{\n\t\tif (Node.Processor)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tbool bAllDependsOnStart = true;\n\t\tbool bAllLinkedToEnd = true;\n\t\tfor (const FProcessorDependencySolver::FNode& SubNode : Node.SubNodes)\n\t\t{\n\t\t\tif (!AreAllProcessorInSet(SubNode, DependsOnStart))\n\t\t\t{\n\t\t\t\tbAllDependsOnStart = false;\n\t\t\t}\n\n\t\t\tif (!AreAllProcessorInSet(SubNode, LinkToEnd))\n\t\t\t{\n\t\t\t\tbAllLinkedToEnd = false;\n\t\t\t}\n\n\t\t\tif (!bAllDependsOnStart && !bAllLinkedToEnd)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst FString NodeName = Node.Name.ToString();\n\t\tconst FString ClusterNodeName = NodeName.Replace(TEXT(\".\"), TEXT(\"_\"));\n\t\tconst FString GraphNodeName = NodeName.Replace(TEXT(\".\"), TEXT(\" \"));\n\t\tif (bAllDependsOnStart)\n\t\t{\n\t\t\tRemoveAllProcessorFromSet(Node, DependsOnStart);\n\t\t\tLogFile.Logf(TEXT(\"    \\\"%s Start\\\" -> \\\"%s Start\\\"[lhead=cluster_%s, weight=0];\"), *GraphName, *GraphNodeName, *ClusterNodeName);\n\t\t}\n\n\t\tif (bAllLinkedToEnd)\n\t\t{\n\t\t\tRemoveAllProcessorFromSet(Node, LinkToEnd);\n\t\t\tLogFile.Logf(TEXT(\"    \\\"%s End\\\" -> \\\"%s End\\\"[ltail=cluster_%s, weight=0];\"), *GraphNodeName, *GraphName, *ClusterNodeName);\n\t\t}\n\n\t\tif(!bAllDependsOnStart || !bAllLinkedToEnd)\n\t\t{\n\t\t\tfor (const FProcessorDependencySolver::FNode& SubNode : Node.SubNodes)\n\t\t\t{\n\t\t\t\tPromoteStartAndEndDependency(LogFile, GraphName, SubNode, DependsOnStart, LinkToEnd);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void DumpAllGraphDependencies(FArchive& LogFile, const FProcessorDependencySolver::FNode& GroupRootNode, const TSet<const FProcessorDependencySolver::FNode*>& AllNodes)\n\t{\n\t\tTSet<const FProcessorDependencySolver::FNode*> DependsOnStart = AllNodes;\n\t\tTSet<const FProcessorDependencySolver::FNode*> LinkToEnd = AllNodes;\n\t\tconst FString GraphName = GroupRootNode.Name.ToString();\n\t\tFDumpGraphDependencyUtils::DumpGraphDependencies(LogFile, GroupRootNode, TArray<const FProcessorDependencySolver::FNode*>(), TArray<const FProcessorDependencySolver::FNode*>(), TArray<const FProcessorDependencySolver::FNode*>(), DependsOnStart, LinkToEnd);\n\t\tFDumpGraphDependencyUtils::PromoteStartAndEndDependency(LogFile, GraphName, GroupRootNode, DependsOnStart, LinkToEnd);\n\t\tfor (const FProcessorDependencySolver::FNode* Node : DependsOnStart)\n\t\t{\n\t\t\tLogFile.Logf(TEXT(\"    \\\"%s Start\\\" -> \\\"%s\\\"[weight=0];\"), *GraphName, *Node->Name.ToString());\n\t\t}\n\t\tfor (const FProcessorDependencySolver::FNode* Node : LinkToEnd)\n\t\t{\n\t\t\tLogFile.Logf(TEXT(\"    \\\"%s\\\" -> \\\"%s End\\\"[weight=0];\"), *Node->Name.ToString(), *GraphName);\n\t\t}\n\t}\n};\n\nvoid FProcessorDependencySolver::DumpGraph(FArchive& LogFile) const\n{\n\tTSet<const FNode*> AllNodes;\n\tLogFile.Logf(TEXT(\"digraph MassProcessorGraph\"));\n\tLogFile.Logf(TEXT(\"{\"));\n\tLogFile.Logf(TEXT(\"    compound = true;\"));\n\tLogFile.Logf(TEXT(\"    newrank = true;\"));\n\tFDumpGraphDependencyUtils::DumpGraphNode(LogFile, GroupRootNode, 4/* Indent */, AllNodes, true/* bRoot */);\n\tFDumpGraphDependencyUtils::DumpAllGraphDependencies(LogFile, GroupRootNode, AllNodes);\n\tLogFile.Logf(TEXT(\"}\"));\n}\n\n#endif // 0; disabled the graph building for now, leaving the old code here for reference\n\nvoid FMassProcessorDependencySolver::Solve(TArray<FMassProcessorOrderInfo>& OutResult)\n{\n\tusing UE::Mass::Private::NameViewToString;\n\n\tif (AllNodes.Num() == 0)\n\t{\n\t\treturn;\n\t}\n\n\tfor (FNode& Node : AllNodes)\n\t{\n\t\tNode.TransientDependencies = Node.OriginalDependencies;\n\t\tNode.TotalWaitingNodes = 0;\n\t}\n\n\tTArray<int32> IndicesRemaining;\n\tIndicesRemaining.Reserve(AllNodes.Num());\n\tfor (int32 i = 0; i < AllNodes.Num(); ++i)\n\t{\n\t\t// skip all the group nodes, all group dependencies have already been converted to individual processor dependencies\n\t\tif (AllNodes[i].IsGroup() == false)\n\t\t{\n\t\t\tIndicesRemaining.Add(i);\n\t\t\tAllNodes[i].IncreaseWaitingNodesCount(AllNodes);\n\t\t}\n\t}\n\n\tIndicesRemaining.Sort([this](const int32 IndexA, const int32 IndexB){\n\t\treturn AllNodes[IndexA].TotalWaitingNodes > AllNodes[IndexB].TotalWaitingNodes;\n\t});\n\n\t// this is where we'll be tracking what's being accessed by whom\n\tFResourceUsage ResourceUsage(AllNodes);\n\n\tTArray<int32> SortedNodeIndices;\n\tSortedNodeIndices.Reserve(AllNodes.Num());\n\n\twhile (IndicesRemaining.Num())\n\t{\n\t\tconst bool bStepSuccessful = PerformSolverStep(ResourceUsage, IndicesRemaining, SortedNodeIndices);\n\n\t\tif (bStepSuccessful == false)\n\t\t{\n\t\t\tbAnyCyclesDetected = true;\n\n\t\t\tUE_LOG(LogMass, Error, TEXT(\"Detected processing dependency cycle:\"));\n\t\t\tfor (const int32 Index : IndicesRemaining)\n\t\t\t{\n\t\t\t\tUMassProcessor* Processor = AllNodes[Index].Processor;\n\t\t\t\tif (Processor)\n\t\t\t\t{\n\t\t\t\t\tUE_LOG(LogMass, Warning, TEXT(\"\\t%s, group: %s, before: %s, after %s\")\n\t\t\t\t\t\t, *Processor->GetName()\n\t\t\t\t\t\t, *Processor->GetExecutionOrder().ExecuteInGroup.ToString()\n\t\t\t\t\t\t, *NameViewToString(Processor->GetExecutionOrder().ExecuteBefore)\n\t\t\t\t\t\t, *NameViewToString(Processor->GetExecutionOrder().ExecuteAfter));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// group\n\t\t\t\t\tUE_LOG(LogMass, Warning, TEXT(\"\\tGroup %s\"), *AllNodes[Index].Name.ToString());\n\t\t\t\t}\n\t\t\t}\n\t\t\tUE_LOG(LogMass, Warning, TEXT(\"Cutting the chain at an arbitrary location.\"));\n\n\t\t\t// remove first dependency\n\t\t\t// note that if we're in a cycle handling scenario every node does have some dependencies left\n\t\t\tconst int32 DependencyNodeIndex = AllNodes[IndicesRemaining[0]].TransientDependencies.Pop(EAllowShrinking::No);\n\t\t\t// we need to remove this dependency from original dependencies as well, otherwise we'll still have the cycle\n\t\t\t// in the data being produces as a result of the whole algorithm\n\t\t\tAllNodes[IndicesRemaining[0]].OriginalDependencies.Remove(DependencyNodeIndex);\n\t\t}\n\t}\n\n\t// now we have the desired order in SortedNodeIndices. We have to traverse it to add to OutResult\n\tfor (int i = 0; i < SortedNodeIndices.Num(); ++i)\n\t{\n\t\tconst int32 NodeIndex = SortedNodeIndices[i];\n\n\t\tTArray<FName> DependencyNames;\n\t\tfor (const int32 DependencyIndex : AllNodes[NodeIndex].OriginalDependencies)\n\t\t{\n\t\t\tDependencyNames.AddUnique(AllNodes[DependencyIndex].Name);\n\t\t}\n\n\t\t// at this point we expect SortedNodeIndices to only point to regular processors (i.e. no groups)\n\t\tif (ensure(AllNodes[NodeIndex].Processor != nullptr))\n\t\t{\n\t\t\tOutResult.Add({ AllNodes[NodeIndex].Name, AllNodes[NodeIndex].Processor, FMassProcessorOrderInfo::EDependencyNodeType::Processor, DependencyNames, AllNodes[NodeIndex].SequencePositionIndex });\n\t\t}\n\t}\n}\n\nvoid FMassProcessorDependencySolver::ResolveDependencies(TArray<FMassProcessorOrderInfo>& OutResult, TSharedPtr<FMassEntityManager> EntityManager, FMassProcessorDependencySolver::FResult* InOutOptionalResult)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"Mass ResolveDependencies\");\n\n\tif (Processors.Num() == 0)\n\t{\n\t\treturn;\n\t}\n\n\tFScopedCategoryAndVerbosityOverride LogOverride(TEXT(\"LogMass\"), ELogVerbosity::Log);\n\n\tif (InOutOptionalResult)\n\t{\n\t\tDependencyGraphFileName = InOutOptionalResult->DependencyGraphFileName;\n\t}\n\n\tbAnyCyclesDetected = false;\n\n\tUE_LOG(LogMass, Log, TEXT(\"Gathering dependencies data:\"));\n\n\tAllNodes.Reset();\n\tNodeIndexMap.Reset();\n\t// as the very first node we add a \"root\" node that represents the \"top level group\" and also simplifies the rest\n\t// of the lookup code - if a processor declares it's in group None or depends on Node it we don't need to check that \n\t// explicitly. \n\tAllNodes.Add(FNode(FName(), nullptr, 0));\n\tNodeIndexMap.Add(FName(), 0);\n\n\tconst bool bCreateVirtualArchetypes = (!EntityManager);\n\tif (bCreateVirtualArchetypes)\n\t{\n\t\t// create FMassEntityManager instance that we'll use to sort out processors' overlaps\n\t\t// the idea for this is that for every processor we have we create an archetype matching given processor's requirements. \n\t\t// Once that's done we have a collection of \"virtual\" archetypes our processors expect. Then we ask every processor \n\t\t// to cache the archetypes they'd accept, using processors' owned queries. The idea is that some of the nodes will \n\t\t// end up with more than just the virtual archetype created for that specific node. The practice proved the idea correct. \n\t\tEntityManager = MakeShareable(new FMassEntityManager());\n\t}\n\n\t// gather the processors information first\n\tfor (UMassProcessor* Processor : Processors)\n\t{\n\t\tif (Processor == nullptr)\n\t\t{\n\t\t\tUE_LOG(LogMass, Warning, TEXT(\"%s nullptr found in Processors collection being processed\"), ANSI_TO_TCHAR(__FUNCTION__));\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst int32 ProcessorNodeIndex = CreateNodes(*Processor);\n\n\t\tif (bCreateVirtualArchetypes)\n\t\t{\n\t\t\t// this line is a part of a nice trick we're doing here utilizing EntityManager's archetype creation based on \n\t\t\t// what each processor expects, and EntityQuery's capability to cache archetypes matching its requirements (used below)\n\t\t\tEntityManager->CreateArchetype(AllNodes[ProcessorNodeIndex].Requirements.AsCompositionDescriptor());\n\t\t}\n\t}\n\n\tUE_LOG(LogMass, Verbose, TEXT(\"Pruning processors...\"));\n\n\tint32 PrunedProcessorsCount = 0;\n\tfor (FNode& Node : AllNodes)\n\t{\n\t\tif (Node.IsGroup() == false)\n\t\t{\n\t\t\tCA_ASSUME(Node.Processor); // as implied by Node.IsGroup() == false\n\n\t\t\t// for each processor-representing node we cache information on which archetypes among the once we've created \n\t\t\t// above (see the EntityManager.CreateArchetype call in the previous loop) match this processor. \n\t\t\tNode.Processor->GetArchetypesMatchingOwnedQueries(*EntityManager.Get(), Node.ValidArchetypes);\n\n\t\t\t// prune the archetype-less processors\n\t\t\tif (Node.ValidArchetypes.Num() == 0 && Node.Processor->ShouldAllowQueryBasedPruning(bGameRuntime))\n\t\t\t{\n\t\t\t\tUE_LOG(LogMass, Verbose, TEXT(\"\\t%s\"), *Node.Processor->GetName());\n\n\t\t\t\tif (InOutOptionalResult)\n\t\t\t\t{\n\t\t\t\t\tInOutOptionalResult->PrunedProcessorClasses.Add(Node.Processor->GetClass());\n\t\t\t\t}\n\n\t\t\t\t// clearing out the processor will result in the rest of the algorithm to treat it as a group - we still \n\t\t\t\t// want to preserve the configured ExecuteBefore and ExecuteAfter dependencies\n\t\t\t\tNode.Processor = nullptr;\n\t\t\t\t++PrunedProcessorsCount;\n\t\t\t}\n\t\t}\n\t}\n\n\tUE_LOG(LogMass, Verbose, TEXT(\"Number of processors pruned: %d\"), PrunedProcessorsCount);\n\n\tcheck(AllNodes.Num());\n\tLogNode(AllNodes[0]);\n\n\tBuildDependencies();\n\n\t// now none of the processor nodes depend on groups - we replaced these dependencies with depending directly \n\t// on individual processors. However, we keep the group nodes around since we store the dependencies via index, so \n\t// removing nodes would mess that up. Solve below ignores group nodes and OutResult will not have any groups once its done.\n\n\tSolve(OutResult);\n\n\tUE_LOG(LogMass, Verbose, TEXT(\"Dependency order:\"));\n\tfor (const FMassProcessorOrderInfo& Info : OutResult)\n\t{\n\t\tUE_LOG(LogMass, Verbose, TEXT(\"\\t%s\"), *Info.Name.ToString());\n\t}\n\n\tint32 MaxSequenceLength = 0;\n\tfor (FNode& Node : AllNodes)\n\t{\n\t\tMaxSequenceLength = FMath::Max(MaxSequenceLength, Node.SequencePositionIndex);\n\t}\n\n\tUE_LOG(LogMass, Verbose, TEXT(\"Max sequence length: %d\"), MaxSequenceLength);\n\n\tif (InOutOptionalResult)\n\t{\n\t\tInOutOptionalResult->MaxSequenceLength = MaxSequenceLength;\n\t\tInOutOptionalResult->ArchetypeDataVersion = EntityManager->GetArchetypeDataVersion();\n\t}\n}\n\nbool FMassProcessorDependencySolver::IsResultUpToDate(const FMassProcessorDependencySolver::FResult& InResult, TSharedPtr<FMassEntityManager> EntityManager)\n{\n\tif (InResult.PrunedProcessorClasses.Num() == 0 || !EntityManager || InResult.ArchetypeDataVersion == EntityManager->GetArchetypeDataVersion())\n\t{\n\t\treturn true;\n\t}\n\n\t// this is inefficient right now since we're using CDOs and need to check all archetypes every time.\n\t// Would be more efficient if we had a common place where all processors live, both active and inactive, so that we can utilize those. \n\tfor (const TSubclassOf<UMassProcessor>& ProcessorClass : InResult.PrunedProcessorClasses)\n\t{\n\t\tif (UMassProcessor* ProcessorCDO = ProcessorClass.GetDefaultObject())\n\t\t{\n\t\t\tif (ProcessorCDO->DoesAnyArchetypeMatchOwnedQueries(*EntityManager.Get()))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n#undef LOCTEXT_NAMESPACE ",
      "lines": 1210
    },
    {
      "file_path": "MassEntity\\Private\\MassRequirementAccessDetector.cpp",
      "extension": ".cpp",
      "size_bytes": 2308,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassRequirementAccessDetector.h\"\n#if WITH_MASSENTITY_DEBUG\n#include \"MassEntityQuery.h\"\n#include \"HAL/IConsoleManager.h\"\n\nnamespace UE::Mass::Private\n{\n\tbool bTrackRequirementsAccess = false;\n\t\n\tFAutoConsoleVariableRef CVarTrackRequirementsAccess(TEXT(\"mass.debug.TrackRequirementsAccess\"), bTrackRequirementsAccess\n\t\t, TEXT(\"Enables Mass processing debugging mode where we monitor thread-safety of query requirements access.\"));\n}\n\nvoid FMassRequirementAccessDetector::Initialize()\n{\n\tcheck(IsInGameThread());\n\tAddDetectors(FMassFragmentBitSet::FStructTrackerWrapper::StructTracker);\n\tAddDetectors(FMassChunkFragmentBitSet::FStructTrackerWrapper::StructTracker);\n\tAddDetectors(FMassSharedFragmentBitSet::FStructTrackerWrapper::StructTracker);\n\tAddDetectors(FMassExternalSubsystemBitSet::FStructTrackerWrapper::StructTracker);\n}\n\nvoid FMassRequirementAccessDetector::AddDetectors(const FStructTracker& StructTracker)\n{\n\tTConstArrayView<TWeakObjectPtr<const UStruct>> Types = StructTracker.DebugGetAllStructTypes<UStruct>();\n\tfor (TWeakObjectPtr<const UStruct> Type : Types)\n\t{\n\t\tcheck(Type.Get());\n\t\tDetectors.Add(Type.Get(), MakeShareable(new FRWAccessDetector()));\n\t}\n}\n\nvoid FMassRequirementAccessDetector::RequireAccess(const FMassEntityQuery& Query)\n{\n\tif (UE::Mass::Private::bTrackRequirementsAccess)\n\t{\n\t\tOperation(Query.RequiredConstSubsystems, &FRWAccessDetector::AcquireReadAccess);\n\t\tOperation(Query.RequiredMutableSubsystems, &FRWAccessDetector::AcquireWriteAccess);\n\t\t\n\t\tAquire(Query.FragmentRequirements);\n\t\tAquire(Query.ChunkFragmentRequirements);\n\t\tAquire(Query.ConstSharedFragmentRequirements);\n\t\tAquire(Query.SharedFragmentRequirements);\n\t}\n}\n\nvoid FMassRequirementAccessDetector::ReleaseAccess(const FMassEntityQuery& Query)\n{\n\tif (UE::Mass::Private::bTrackRequirementsAccess)\n\t{\n\t\tOperation(Query.RequiredConstSubsystems, &FRWAccessDetector::ReleaseReadAccess);\n\t\tOperation(Query.RequiredMutableSubsystems, &FRWAccessDetector::ReleaseWriteAccess);\n\n\t\tRelease(Query.FragmentRequirements);\n\t\tRelease(Query.ChunkFragmentRequirements);\n\t\tRelease(Query.ConstSharedFragmentRequirements);\n\t\tRelease(Query.SharedFragmentRequirements);\n\t}\n}\n\n#endif // WITH_MASSENTITY_DEBUG",
      "lines": 63
    },
    {
      "file_path": "MassEntity\\Private\\MassRequirements.cpp",
      "extension": ".cpp",
      "size_bytes": 9541,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassRequirements.h\"\n#include \"MassArchetypeData.h\"\n#include \"MassProcessorDependencySolver.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(MassRequirements)\n\n#if WITH_MASSENTITY_DEBUG\n#include \"MassRequirementAccessDetector.h\"\n#endif // WITH_MASSENTITY_DEBUG\n\n\nnamespace UE::Mass::Private\n{\n\ttemplate<typename TContainer>\n\tvoid ExportRequirements(TConstArrayView<FMassFragmentRequirementDescription> Requirements, TMassExecutionAccess<TContainer>& Out)\n\t{\n\t\tfor (const FMassFragmentRequirementDescription& Requirement : Requirements)\n\t\t{\n\t\t\tif (Requirement.Presence != EMassFragmentPresence::None)\n\t\t\t{\n\t\t\t\tcheck(Requirement.StructType);\n\t\t\t\tif (Requirement.AccessMode == EMassFragmentAccess::ReadOnly)\n\t\t\t\t{\n\t\t\t\t\tOut.Read.Add(*Requirement.StructType);\n\t\t\t\t}\n\t\t\t\telse if (Requirement.AccessMode == EMassFragmentAccess::ReadWrite)\n\t\t\t\t{\n\t\t\t\t\tOut.Write.Add(*Requirement.StructType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttemplate<>\n\tvoid ExportRequirements<FMassConstSharedFragmentBitSet>(TConstArrayView<FMassFragmentRequirementDescription> Requirements\n\t\t, TMassExecutionAccess<FMassConstSharedFragmentBitSet>& Out)\n\t{\n\t\tfor (const FMassFragmentRequirementDescription& Requirement : Requirements)\n\t\t{\n\t\t\tif (Requirement.Presence != EMassFragmentPresence::None)\n\t\t\t{\n\t\t\t\tcheck(Requirement.StructType);\n\t\t\t\tif (ensureMsgf(Requirement.AccessMode == EMassFragmentAccess::ReadOnly, TEXT(\"ReadOnly is the only supported AccessMode for ConstSharedFragments\")))\n\t\t\t\t{\n\t\t\t\t\tOut.Read.Add(*Requirement.StructType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n//////////////////////////////////////////////////////////////////////\n// FMassSubsystemRequirements\n\nvoid FMassSubsystemRequirements::ExportRequirements(FMassExecutionRequirements& OutRequirements) const\n{\n\tOutRequirements.RequiredSubsystems.Read += RequiredConstSubsystems;\n\tOutRequirements.RequiredSubsystems.Write += RequiredMutableSubsystems;\n}\n\nvoid FMassSubsystemRequirements::Reset()\n{\n\tRequiredConstSubsystems.Reset();\n\tRequiredMutableSubsystems.Reset();\n\tbRequiresGameThreadExecution = false;\n}\n\n//////////////////////////////////////////////////////////////////////\n// FMassFragmentRequirements\n\nFMassFragmentRequirements::FMassFragmentRequirements(std::initializer_list<UScriptStruct*> InitList)\n{\n\tfor (const UScriptStruct* FragmentType : InitList)\n\t{\n\t\tAddRequirement(FragmentType, EMassFragmentAccess::ReadWrite, EMassFragmentPresence::All);\n\t}\n}\n\nFMassFragmentRequirements::FMassFragmentRequirements(TConstArrayView<const UScriptStruct*> InitList)\n{\n\tfor (const UScriptStruct* FragmentType : InitList)\n\t{\n\t\tAddRequirement(FragmentType, EMassFragmentAccess::ReadWrite, EMassFragmentPresence::All);\n\t}\n}\n\nFMassFragmentRequirements& FMassFragmentRequirements::ClearTagRequirements(const FMassTagBitSet& TagsToRemoveBitSet)\n{\n\tRequiredAllTags.Remove(TagsToRemoveBitSet);\n\tRequiredAnyTags.Remove(TagsToRemoveBitSet);\n\tRequiredNoneTags.Remove(TagsToRemoveBitSet);\n\tRequiredOptionalTags.Remove(TagsToRemoveBitSet);\n\n\treturn *this;\n}\n\nvoid FMassFragmentRequirements::SortRequirements()\n{\n\t// we're sorting the Requirements the same way ArchetypeData's FragmentConfig is sorted (see FMassArchetypeData::Initialize)\n\t// so that when we access ArchetypeData.FragmentConfigs in FMassArchetypeData::BindRequirementsWithMapping\n\t// (via GetFragmentData call) the access is sequential (i.e. not random) and there's a higher chance the memory\n\t// FragmentConfigs we want to access have already been fetched and are available in processor cache.\n\tFragmentRequirements.Sort(FScriptStructSortOperator());\n\tChunkFragmentRequirements.Sort(FScriptStructSortOperator());\n\tConstSharedFragmentRequirements.Sort(FScriptStructSortOperator());\n\tSharedFragmentRequirements.Sort(FScriptStructSortOperator());\n}\n\nFORCEINLINE void FMassFragmentRequirements::CachePropreties() const\n{\n\tif (bPropertiesCached == false)\n\t{\n\t\tbHasPositiveRequirements = !(RequiredAllTags.IsEmpty()\n\t\t\t&& RequiredAnyTags.IsEmpty()\n\t\t\t&& RequiredAllFragments.IsEmpty()\n\t\t\t&& RequiredAnyFragments.IsEmpty()\n\t\t\t&& RequiredAllChunkFragments.IsEmpty()\n\t\t\t&& RequiredAllSharedFragments.IsEmpty()\n\t\t\t&& RequiredAllConstSharedFragments.IsEmpty());\n\n\t\tbHasNegativeRequirements = !(RequiredNoneTags.IsEmpty()\n\t\t\t&& RequiredNoneFragments.IsEmpty()\n\t\t\t&& RequiredNoneChunkFragments.IsEmpty()\n\t\t\t&& RequiredNoneSharedFragments.IsEmpty()\n\t\t\t&& RequiredNoneConstSharedFragments.IsEmpty());\n\n\t\tbHasOptionalRequirements = !(RequiredOptionalFragments.IsEmpty()\n\t\t\t\t&& RequiredOptionalTags.IsEmpty()\n\t\t\t\t&& RequiredOptionalChunkFragments.IsEmpty()\n\t\t\t\t&& RequiredOptionalSharedFragments.IsEmpty()\n\t\t\t\t&& RequiredOptionalConstSharedFragments.IsEmpty());\n\n\t\tbPropertiesCached = true;\n\t}\n}\n\nbool FMassFragmentRequirements::CheckValidity() const\n{\n\tCachePropreties();\n\t// @todo we need to add more sophisticated testing somewhere to detect contradicting requirements - like having and not having a given tag.\n\treturn bHasPositiveRequirements || bHasNegativeRequirements || bHasOptionalRequirements;\n}\n\nbool FMassFragmentRequirements::IsEmpty() const\n{\n\tCachePropreties();\n\t// note that even though at the moment the following condition is the same as negation of current CheckValidity value\n\t// that will change in the future (with additional validity checks).\n\treturn !bHasPositiveRequirements && !bHasNegativeRequirements && !bHasOptionalRequirements;\n}\n\nbool FMassFragmentRequirements::DoesMatchAnyOptionals(const FMassArchetypeCompositionDescriptor& ArchetypeComposition) const\n{\n\treturn bHasOptionalRequirements\n\t\t&& (ArchetypeComposition.Fragments.HasAny(RequiredOptionalFragments)\n\t\t\t|| ArchetypeComposition.Tags.HasAny(RequiredOptionalTags)\n\t\t\t|| ArchetypeComposition.ChunkFragments.HasAny(RequiredOptionalChunkFragments)\n\t\t\t|| ArchetypeComposition.SharedFragments.HasAny(RequiredOptionalSharedFragments)\n\t\t\t|| ArchetypeComposition.ConstSharedFragments.HasAny(RequiredOptionalConstSharedFragments));\n}\n\nbool FMassFragmentRequirements::DoesArchetypeMatchRequirements(const FMassArchetypeHandle& ArchetypeHandle) const\n{\n\tcheck(ArchetypeHandle.IsValid());\n\tconst FMassArchetypeData* Archetype = FMassArchetypeHelper::ArchetypeDataFromHandle(ArchetypeHandle);\n\tCA_ASSUME(Archetype);\n\n\treturn DoesArchetypeMatchRequirements(Archetype->GetCompositionDescriptor());\n}\n\t\nbool FMassFragmentRequirements::DoesArchetypeMatchRequirements(const FMassArchetypeCompositionDescriptor& ArchetypeComposition) const\n{\n\tCachePropreties();\n\n\tconst bool bPassNegativeFilter = bHasNegativeRequirements == false\n\t\t|| (ArchetypeComposition.Fragments.HasNone(RequiredNoneFragments)\n\t\t\t&& ArchetypeComposition.Tags.HasNone(RequiredNoneTags)\n\t\t\t&& ArchetypeComposition.ChunkFragments.HasNone(RequiredNoneChunkFragments)\n\t\t\t&& ArchetypeComposition.SharedFragments.HasNone(RequiredNoneSharedFragments)\n\t\t\t&& ArchetypeComposition.ConstSharedFragments.HasNone(RequiredNoneConstSharedFragments));\n\t\n\tif (bPassNegativeFilter)\n\t{\n\t\tif (bHasPositiveRequirements)\n\t\t{\n\t\t\treturn ArchetypeComposition.Fragments.HasAll(RequiredAllFragments)\n\t\t\t\t&& (RequiredAnyFragments.IsEmpty() || ArchetypeComposition.Fragments.HasAny(RequiredAnyFragments))\n\t\t\t\t&& ArchetypeComposition.Tags.HasAll(RequiredAllTags)\n\t\t\t\t&& (RequiredAnyTags.IsEmpty() || ArchetypeComposition.Tags.HasAny(RequiredAnyTags))\n\t\t\t\t&& ArchetypeComposition.ChunkFragments.HasAll(RequiredAllChunkFragments)\n\t\t\t\t&& ArchetypeComposition.SharedFragments.HasAll(RequiredAllSharedFragments)\n\t\t\t\t&& ArchetypeComposition.ConstSharedFragments.HasAll(RequiredAllConstSharedFragments);\n\t\t}\n\t\telse if (bHasOptionalRequirements)\n\t\t{\n\t\t\treturn DoesMatchAnyOptionals(ArchetypeComposition);\n\t\t}\n\t\t// else - it's fine, we passed all the filters that have been set up\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid FMassFragmentRequirements::ExportRequirements(FMassExecutionRequirements& OutRequirements) const\n{\n\tusing UE::Mass::Private::ExportRequirements;\n\tExportRequirements<FMassFragmentBitSet>(FragmentRequirements, OutRequirements.Fragments);\n\tExportRequirements<FMassChunkFragmentBitSet>(ChunkFragmentRequirements, OutRequirements.ChunkFragments);\n\tExportRequirements<FMassSharedFragmentBitSet>(SharedFragmentRequirements, OutRequirements.SharedFragments);\n\tExportRequirements<FMassConstSharedFragmentBitSet>(ConstSharedFragmentRequirements, OutRequirements.ConstSharedFragments);\n\n\tOutRequirements.RequiredAllTags = RequiredAllTags;\n\tOutRequirements.RequiredAnyTags = RequiredAnyTags;\n\tOutRequirements.RequiredNoneTags = RequiredNoneTags;\n\t// not exporting optional tags by design\n}\n\nvoid FMassFragmentRequirements::Reset()\n{\n\tFragmentRequirements.Reset();\n\tChunkFragmentRequirements.Reset();\n\tConstSharedFragmentRequirements.Reset();\n\tSharedFragmentRequirements.Reset();\n\tRequiredAllTags.Reset();\n\tRequiredAnyTags.Reset();\n\tRequiredNoneTags.Reset();\n\tRequiredAllFragments.Reset();\n\tRequiredAnyFragments.Reset();\n\tRequiredOptionalFragments.Reset();\n\tRequiredNoneFragments.Reset();\n\tRequiredAllChunkFragments.Reset();\n\tRequiredOptionalChunkFragments.Reset();\n\tRequiredNoneChunkFragments.Reset();\n\tRequiredAllSharedFragments.Reset();\n\tRequiredOptionalSharedFragments.Reset();\n\tRequiredNoneSharedFragments.Reset();\n\tRequiredAllConstSharedFragments.Reset();\n\tRequiredOptionalConstSharedFragments.Reset();\n\tRequiredNoneConstSharedFragments.Reset();\n\n\tIncrementalChangesCount = 0;\n}\n",
      "lines": 244
    },
    {
      "file_path": "MassEntity\\Private\\MassSettings.cpp",
      "extension": ".cpp",
      "size_bytes": 1748,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSettings.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(MassSettings)\n\n\n//----------------------------------------------------------------------//\n//  UMassModuleSettings\n//----------------------------------------------------------------------//\nvoid UMassModuleSettings::PostInitProperties()\n{\n\tSuper::PostInitProperties();\n\n\tif (HasAnyFlags(RF_ClassDefaultObject) && !GetClass()->HasAnyClassFlags(CLASS_Abstract))\n\t{\n\t\t// register with UMassGameplaySettings\n\t\tGetMutableDefault<UMassSettings>()->RegisterModuleSettings(*this);\n\t}\n}\n\n//----------------------------------------------------------------------//\n//  UMassSettings\n//----------------------------------------------------------------------//\nvoid UMassSettings::RegisterModuleSettings(UMassModuleSettings& SettingsCDO)\n{\n\tensureMsgf(SettingsCDO.HasAnyFlags(RF_ClassDefaultObject), TEXT(\"Registered ModuleSettings need to be its class's CDO\"));\n\n\t// we should consider a replacement in case we're hot-reloading\n\tFName EntryName = SettingsCDO.GetClass()->GetFName();\n\n#if WITH_EDITOR\n\tstatic const FName DisplayNameMeta(TEXT(\"DisplayName\")); \n\t// try reading better name from meta data, available only in editor. Besides, we don't really care about this out \n\t// side of editor. We could even skip populating ModuleSettings but we'll leave it as is for now.\n\tconst FString& DisplayNameValue = SettingsCDO.GetClass()->GetMetaData(DisplayNameMeta);\n\tif (DisplayNameValue.Len())\n\t{\n\t\tEntryName = *DisplayNameValue;\n\t}\n#endif // WITH_EDITOR\n\n\tTObjectPtr<UMassModuleSettings>& FoundModuleEntry = ModuleSettings.FindOrAdd(EntryName, &SettingsCDO);\n\tFoundModuleEntry = &SettingsCDO;\n}\n\n",
      "lines": 46
    },
    {
      "file_path": "MassEntity\\Private\\MassSubsystemAccess.cpp",
      "extension": ".cpp",
      "size_bytes": 3825,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSubsystemAccess.h\"\n\n\nnamespace UE::Mass::Private\n{\n\ttemplate<typename T>\n\tTSubclassOf<T> ConvertToSubsystemClass(TSubclassOf<USubsystem> SubsystemClass)\n\t{\n\t\treturn *(reinterpret_cast<TSubclassOf<T>*>(&SubsystemClass));\n\t}\n}\n\n//////////////////////////////////////////////////////////////////////////\n// FMassSubsystemAccess\n\nFMassSubsystemAccess::FMassSubsystemAccess(UWorld* InWorld)\n\t: World(InWorld)\n{\n\tSubsystems.AddZeroed(FMassExternalSubsystemBitSet::GetMaxNum());\n}\n\nUSubsystem* FMassSubsystemAccess::FetchSubsystemInstance(UWorld* World, TSubclassOf<USubsystem> SubsystemClass)\n{\n\tQUICK_SCOPE_CYCLE_COUNTER(Mass_FetchSubsystemInstance);\n\n\tcheck(SubsystemClass);\n\tif (SubsystemClass->IsChildOf<UWorldSubsystem>())\n\t{\n\t\treturn World \n\t\t\t? World->GetSubsystemBase(UE::Mass::Private::ConvertToSubsystemClass<UWorldSubsystem>(SubsystemClass)) \n\t\t\t: nullptr;\n\t}\n\tif (SubsystemClass->IsChildOf<UEngineSubsystem>())\n\t{\n\t\treturn GEngine->GetEngineSubsystemBase(UE::Mass::Private::ConvertToSubsystemClass<UEngineSubsystem>(SubsystemClass));\n\t}\n\tif (SubsystemClass->IsChildOf<UGameInstanceSubsystem>())\n\t{\n\t\treturn (World && World->GetGameInstance())\n\t\t\t? World->GetGameInstance()->GetSubsystemBase(UE::Mass::Private::ConvertToSubsystemClass<UGameInstanceSubsystem>(SubsystemClass))\n\t\t\t: nullptr;\n\t}\n\tif (SubsystemClass->IsChildOf<ULocalPlayerSubsystem>())\n\t{\n\t\tconst ULocalPlayer* LocalPlayer = World ? World->GetFirstLocalPlayerFromController() : nullptr;\n\t\treturn LocalPlayer\n\t\t\t? LocalPlayer->GetSubsystemBase(UE::Mass::Private::ConvertToSubsystemClass<ULocalPlayerSubsystem>(SubsystemClass))\n\t\t\t: nullptr;\n\t}\n#if WITH_EDITOR\n\tif (SubsystemClass->IsChildOf<UEditorSubsystem>())\n\t{\n\t\treturn GEditor->GetEditorSubsystemBase(UE::Mass::Private::ConvertToSubsystemClass<UEditorSubsystem>(SubsystemClass));\n\t}\n#endif // WITH_EDITOR\n\treturn nullptr;\n}\n\nbool FMassSubsystemAccess::CacheSubsystemRequirements(const FMassSubsystemRequirements& SubsystemRequirements)\n{\n\tbool bResult = true;\n\n\tif (SubsystemRequirements.IsEmpty() == false)\n\t{\n\t\tfor (FMassExternalSubsystemBitSet::FIndexIterator It = SubsystemRequirements.GetRequiredConstSubsystems().GetIndexIterator(); It && bResult; ++It)\n\t\t{\n\t\t\tbResult = bResult && CacheSubsystem(*It);\n\t\t}\n\n\t\tfor (FMassExternalSubsystemBitSet::FIndexIterator It = SubsystemRequirements.GetRequiredMutableSubsystems().GetIndexIterator(); It && bResult; ++It)\n\t\t{\n\t\t\tbResult = bResult && CacheSubsystem(*It);\n\t\t}\n\t}\n\n\tif (bResult)\n\t{\n\t\tConstSubsystemsBitSet = SubsystemRequirements.GetRequiredConstSubsystems();\n\t\tMutableSubsystemsBitSet = SubsystemRequirements.GetRequiredMutableSubsystems();\n\t}\n\n\treturn bResult;\n}\n\nbool FMassSubsystemAccess::CacheSubsystem(const uint32 SystemIndex)\n{\n\tif (UNLIKELY(Subsystems.IsValidIndex(SystemIndex) == false))\n\t{\n\t\tSubsystems.AddZeroed(Subsystems.Num() - SystemIndex + 1);\n\t}\n\n\tif (Subsystems[SystemIndex])\n\t{\n\t\treturn true;\n\t}\n\n\tconst UClass* SubsystemClass = FMassExternalSubsystemBitSet::GetTypeAtIndex(SystemIndex);\n\tcheckSlow(SubsystemClass);\n\n\tTSubclassOf<USubsystem> SubsystemSubclass(const_cast<UClass*>(SubsystemClass));\n\tcheckSlow(*SubsystemSubclass);\n\n\tif (SubsystemSubclass)\n\t{\n\t\tUSubsystem* SystemInstance = FMassSubsystemAccess::FetchSubsystemInstance(World.Get(), SubsystemSubclass);\n\t\tSubsystems[SystemIndex] = SystemInstance;\n\t\treturn SystemInstance != nullptr;\n\t}\n\n\treturn false;\n}\n\nvoid FMassSubsystemAccess::SetSubsystemRequirements(const FMassSubsystemRequirements& SubsystemRequirements)\n{\n\tConstSubsystemsBitSet = SubsystemRequirements.GetRequiredConstSubsystems();\n\tMutableSubsystemsBitSet = SubsystemRequirements.GetRequiredMutableSubsystems();\n}\n",
      "lines": 119
    },
    {
      "file_path": "MassEntity\\Private\\MassSubsystemBase.cpp",
      "extension": ".cpp",
      "size_bytes": 5376,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSubsystemBase.h\"\n#include \"HAL/IConsoleManager.h\"\n#include \"Engine/World.h\"\n\n\nnamespace UE::Mass::Private\n{\n/** \n * A helper function calling PostInitialize and OnWorldBeginPlay for the given subsystem, provided the world has already begun play.\n * @see UMassSubsystemBase::HandleLateCreation for more detail\n */\nvoid HandleLateCreation(UWorldSubsystem& MassWorldSubsystem, const UE::Mass::Subsystems::FInitializationState InitializationState)\n{\n\t// handle late creation\n\tUWorld* World = MassWorldSubsystem.GetWorld();\n\tif (World)\n\t{\n\t\tif (World->IsInitialized() == true && InitializationState.bPostInitializeCalled == false)\n\t\t{\n\t\t\tMassWorldSubsystem.PostInitialize();\n\t\t}\n\t\tif (World->HasBegunPlay() == true && InitializationState.bOnWorldBeginPlayCalled == false)\n\t\t{\n\t\t\tMassWorldSubsystem.OnWorldBeginPlay(*World);\n\t\t}\n\t}\n}\n\nbool bRuntimeSubsystemsEnabled = true;\n\nnamespace\n{\n\tFAutoConsoleVariableRef AnonymousCVars[] =\n\t{\n\t\t{ TEXT(\"mass.RuntimeSubsystemsEnabled\")\n\t\t, bRuntimeSubsystemsEnabled\n\t\t, TEXT(\"true by default, setting to false will prevent auto-creation of game-time Mass-related subsystems. Needs to be set before world loading.\")\n\t\t, ECVF_Default }\n\t};\n}\n} // UE::Mass::Private\n\n\n//-----------------------------------------------------------------------------\n// UMassSubsystemBase\n//-----------------------------------------------------------------------------\nbool UMassSubsystemBase::AreRuntimeMassSubsystemsAllowed(UObject* Outer)\n{\n\treturn UE::Mass::Private::bRuntimeSubsystemsEnabled;\n}\n\nbool UMassSubsystemBase::ShouldCreateSubsystem(UObject* Outer) const \n{\n\treturn UMassSubsystemBase::AreRuntimeMassSubsystemsAllowed(Outer) && Super::ShouldCreateSubsystem(Outer);\n}\n\nvoid UMassSubsystemBase::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tSuper::Initialize(Collection);\n\n\t// This ensure is here to make sure we handle HandleLateCreation() gracefully, we dont expect it to ever trigger unless users start to manually call the functions\n\tensureMsgf(InitializationState.bInitializeCalled == false, TEXT(\"%hs called multiple times\"), __FUNCTION__);\n\tInitializationState.bInitializeCalled = true;\n}\n\nvoid UMassSubsystemBase::PostInitialize()\n{\n\tSuper::PostInitialize();\n\n\t// This ensure is here to make sure we handle HandleLateCreation() gracefully, we dont expect it to ever trigger unless users start to manually call the functions\n\tensureMsgf(InitializationState.bPostInitializeCalled == false, TEXT(\"%hs called multiple times\"), __FUNCTION__);\n\tInitializationState.bPostInitializeCalled = true;\n}\n\nvoid UMassSubsystemBase::Deinitialize()\n{\n\tInitializationState = UE::Mass::Subsystems::FInitializationState();\n\n\tSuper::Deinitialize();\n}\n\nvoid UMassSubsystemBase::OnWorldBeginPlay(UWorld& InWorld)\n{\n\tSuper::OnWorldBeginPlay(InWorld);\n\n\t// This ensure is here to make sure we handle HandleLateCreation() gracefully, we dont expect it to ever trigger unless users start to manually call the functions\n\tensureMsgf(InitializationState.bOnWorldBeginPlayCalled == false, TEXT(\"%hs called multiple times\"), __FUNCTION__);\n\tInitializationState.bOnWorldBeginPlayCalled = true;\n}\n\nvoid UMassSubsystemBase::HandleLateCreation()\n{\n\tUE::Mass::Private::HandleLateCreation(*this, InitializationState);\n}\n\n//-----------------------------------------------------------------------------\n// UMassTickableSubsystemBase\n//-----------------------------------------------------------------------------\nbool UMassTickableSubsystemBase::ShouldCreateSubsystem(UObject* Outer) const\n{\n\treturn UMassSubsystemBase::AreRuntimeMassSubsystemsAllowed(Outer) && Super::ShouldCreateSubsystem(Outer);\n}\n\nvoid UMassTickableSubsystemBase::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tSuper::Initialize(Collection);\n\n\t// This ensure is here to make sure we handle HandleLateCreation() gracefully, we dont expect it to ever trigger unless users start to manually call the functions\n\tensureMsgf(InitializationState.bInitializeCalled == false, TEXT(\"%hs called multiple times\"), __FUNCTION__);\n\tInitializationState.bInitializeCalled = true;\n}\n\nvoid UMassTickableSubsystemBase::PostInitialize()\n{\n\tSuper::PostInitialize();\n\n\t// This ensure is here to make sure we handle HandleLateCreation() gracefully, we dont expect it to ever trigger unless users start to manually call the functions\n\tensureMsgf(InitializationState.bPostInitializeCalled == false, TEXT(\"%hs called multiple times\"), __FUNCTION__);\n\tInitializationState.bPostInitializeCalled = true;\n}\n\nvoid UMassTickableSubsystemBase::Deinitialize()\n{\n\tInitializationState = UE::Mass::Subsystems::FInitializationState();\n\n\tSuper::Deinitialize();\n}\n\nvoid UMassTickableSubsystemBase::OnWorldBeginPlay(UWorld& InWorld)\n{\n\tSuper::OnWorldBeginPlay(InWorld);\n\n\t// This ensure is here to make sure we handle HandleLateCreation() gracefully, we dont expect it to ever trigger unless users start to manually call the functions\n\tensureMsgf(InitializationState.bOnWorldBeginPlayCalled == false, TEXT(\"%hs called multiple times\"), __FUNCTION__);\n\tInitializationState.bOnWorldBeginPlayCalled = true;\n}\n\nvoid UMassTickableSubsystemBase::HandleLateCreation()\n{\n\tUE::Mass::Private::HandleLateCreation(*this, InitializationState);\n}\n",
      "lines": 143
    },
    {
      "file_path": "MassGameplay\\MassActors\\Private\\MassActorHelper.cpp",
      "extension": ".cpp",
      "size_bytes": 2583,
      "content": "// Copyright Epic Games, Inc.All Rights Reserved.\n\n#include \"MassActorHelper.h\"\n#include \"MassActorTypes.h\"\n#include \"MassActorSubsystem.h\"\n#include \"MassEntityManager.h\"\n#include \"MassEntitySubsystem.h\"\n#include \"Engine/World.h\"\n\nnamespace UE::MassActor\n{\n\tbool AddEntityTagToActor(const AActor& Actor, const UScriptStruct& TagType)\n\t{\n\t\tUWorld* World = Actor.GetWorld();\n\t\tUMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(World);\n\t\tUMassActorSubsystem* MassActorSubsystem = UWorld::GetSubsystem<UMassActorSubsystem>(World);\n\t\tif (EntitySubsystem && MassActorSubsystem)\n\t\t{\n\t\t\tFMassEntityManager& EntityManager = EntitySubsystem->GetMutableEntityManager();\n\t\t\tconst FMassEntityHandle AgentHandle = MassActorSubsystem->GetEntityHandleFromActor(&Actor);\n\t\t\tif (AgentHandle.IsValid())\n\t\t\t{\n\t\t\t\tEntityManager.AddTagToEntity(AgentHandle, &TagType);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tUE_LOG(LogMassActor, Warning, TEXT(\"Failed to add tag %s to actor %s due to it not having an associated entity\")\n\t\t\t\t, *TagType.GetName(), *Actor.GetName());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUE_LOG(LogMassActor, Warning, TEXT(\"Failed to add tag %s to actor %s due to missing: %s%s\")\n\t\t\t\t, *TagType.GetName(), *Actor.GetName(), EntitySubsystem ? TEXT(\"EntitySubsystem, \") : TEXT(\"\")\n\t\t\t\t, MassActorSubsystem ? TEXT(\"MassActorSubsystem, \") : TEXT(\"\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\tbool RemoveEntityTagFromActor(const AActor& Actor, const UScriptStruct& TagType)\n\t{\n\t\tUWorld* World = Actor.GetWorld();\n\t\tUMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(World);\n\t\tUMassActorSubsystem* MassActorSubsystem = UWorld::GetSubsystem<UMassActorSubsystem>(World);\n\t\tif (EntitySubsystem && MassActorSubsystem)\n\t\t{\n\t\t\tconst FMassEntityHandle AgentHandle = MassActorSubsystem->GetEntityHandleFromActor(&Actor);\n\t\t\tif (AgentHandle.IsValid())\n\t\t\t{\n\t\t\t\tFMassEntityManager& EntityManager = EntitySubsystem->GetMutableEntityManager();\n\t\t\t\tEntityManager.RemoveTagFromEntity(AgentHandle, &TagType);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tUE_LOG(LogMassActor, Warning, TEXT(\"Failed to remove tag %s from actor %s due to it not having an associated entity\")\n\t\t\t\t, *TagType.GetName(), *Actor.GetName());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUE_LOG(LogMassActor, Warning, TEXT(\"Failed to remove tag %s from actor %s due to missing: %s%s\")\n\t\t\t\t, *TagType.GetName(), *Actor.GetName(), EntitySubsystem ? TEXT(\"EntitySubsystem, \") : TEXT(\"\")\n\t\t\t\t, MassActorSubsystem ? TEXT(\"MassActorSubsystem, \") : TEXT(\"\"));\n\t\t}\n\t\treturn false;\n\t}\n} // namespace UE::MassActor\n",
      "lines": 63
    },
    {
      "file_path": "MassGameplay\\MassActors\\Private\\MassActorPoolableInterface.cpp",
      "extension": ".cpp",
      "size_bytes": 214,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassActorPoolableInterface.h\"\n\n\nUMassActorPoolableInterface::UMassActorPoolableInterface(FObjectInitializer const& InOI)\n\t: UInterface(InOI)\n{\n}",
      "lines": 9
    },
    {
      "file_path": "MassGameplay\\MassActors\\Private\\MassActorsModule.cpp",
      "extension": ".cpp",
      "size_bytes": 761,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CoreMinimal.h\"\n#include \"IMassActorsModule.h\"\n\n\nclass FMassActorsModule : public IMassActorsModule\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nIMPLEMENT_MODULE(FMassActorsModule, MassActors)\n\n\n\nvoid FMassActorsModule::StartupModule()\n{\n\t// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)\n}\n\n\nvoid FMassActorsModule::ShutdownModule()\n{\n\t// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n\t// we call this function before unloading the module.\n}\n\n\n\n",
      "lines": 31
    },
    {
      "file_path": "MassGameplay\\MassActors\\Private\\MassActorSpawnerSubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 21820,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassActorSpawnerSubsystem.h\"\n#include \"MassAgentComponent.h\"\n#include \"MassSimulationSettings.h\"\n#include \"Engine/World.h\"\n#include \"MassActorTypes.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassActorPoolableInterface.h\"\n#include \"MassSimulationSubsystem.h\"\n#include \"Logging/LogScopedVerbosityOverride.h\"\n#include \"ProfilingDebugging/CsvProfiler.h\"\n#include \"Engine/Level.h\"\n\n\nCSV_DEFINE_CATEGORY(MassActors, true);\n\nnamespace UE::MassActors\n{\n\tint32 bUseActorPooling = 1;\n\tFAutoConsoleVariableRef CVarDebugRepresentationLOD(TEXT(\"ai.mass.actorpooling\"), bUseActorPooling, TEXT(\"Use Actor Pooling\"), ECVF_Scalability);\n}\n\n//----------------------------------------------------------------------//\n// UMassActorSpawnerSubsystem \n//----------------------------------------------------------------------//\nvoid UMassActorSpawnerSubsystem::RetryActorSpawnRequest(const FMassActorSpawnRequestHandle SpawnRequestHandle)\n{\n\tcheck(SpawnRequestHandleManager.IsValidHandle(SpawnRequestHandle));\n\tconst int32 Index = SpawnRequestHandle.GetIndex();\n\tcheck(SpawnRequests.IsValidIndex(Index));\n\tFMassActorSpawnRequest& SpawnRequest = SpawnRequests[SpawnRequestHandle.GetIndex()].GetMutable<FMassActorSpawnRequest>();\n\tif (ensureMsgf(SpawnRequest.SpawnStatus == ESpawnRequestStatus::Failed, TEXT(\"Can only retry failed spawn requests\")))\n\t{\n\t\tUWorld* World = GetWorld();\n\t\tcheck(World);\n\n\t\tSpawnRequest.SpawnStatus = ESpawnRequestStatus::RetryPending;\n\t\tSpawnRequest.SerialNumber = RequestSerialNumberCounter.fetch_add(1);\n\t\tSpawnRequest.RequestedTime = World->GetTimeSeconds();\n\t}\n}\n\nbool UMassActorSpawnerSubsystem::RemoveActorSpawnRequest(FMassActorSpawnRequestHandle& SpawnRequestHandle)\n{\n\tif (!ensureMsgf(SpawnRequestHandleManager.RemoveHandle(SpawnRequestHandle), TEXT(\"Invalid spawn request handle\")))\n\t{\n\t\treturn false;\n\t}\n\n\tcheck(SpawnRequests.IsValidIndex(SpawnRequestHandle.GetIndex()));\n\tFMassActorSpawnRequest& SpawnRequest = SpawnRequests[SpawnRequestHandle.GetIndex()].GetMutable<FMassActorSpawnRequest>();\n\tcheck(SpawnRequest.SpawnStatus != ESpawnRequestStatus::Processing);\n\tSpawnRequestHandle.Invalidate();\n\tSpawnRequest.Reset();\n\treturn true;\n}\n\nvoid UMassActorSpawnerSubsystem::ConditionalDestroyActor(UWorld& World, AActor& ActorToDestroy)\n{\n\tUWorld* ActorsWorld = ActorToDestroy.GetWorld();\n\n\t// we directly call DestroyActors only if they're tied to the current world.\n\t// Otherwise we rely on engine mechanics to get rid of them.\n\tif (ActorsWorld == &World)\n\t{\n\t\tWorld.DestroyActor(&ActorToDestroy);\n\t}\n\telse\n\t{\n\t\tensureMsgf(ActorToDestroy.HasActorBegunPlay() == false, TEXT(\"Failed to destroy %s due to world mismatch, while the actor is still being valid (as indicated by HasActorBegunPlay() == true)\")\n\t\t\t, *ActorToDestroy.GetName());\n\t}\n}\n\nvoid UMassActorSpawnerSubsystem::DestroyActor(AActor* Actor, bool bImmediate /*= false*/)\n{\n\tcheck(Actor);\n\n\t// We need to unregister immediately MassAgentComponent as it will become out of sync with mass\n\tif (UMassAgentComponent* AgentComp = Actor->FindComponentByClass<UMassAgentComponent>())\n\t{\n\t\t// All we want here it to unregister with the subsysem, not unregister the component as we want to keep it for futher usage if we put the actor in the pool.\n\t\tAgentComp->UnregisterWithAgentSubsystem();\n\t}\n\n\tif(bImmediate)\n\t{\n\t\tif (!ReleaseActorToPool(Actor))\n\t\t{\n\t\t\t// Couldn't release actor back to pool, so destroy it\n\t\t\tUWorld* World = GetWorld();\n\t\t\tcheck(World);\n\t\t\tConditionalDestroyActor(*World, *Actor);\n\n\t\t\t--NumActorSpawned;\n\t\t}\n\t}\n\telse\n\t{\n\t\tActorsToDestroy.Add(Actor);\n\t}\n}\n\nbool UMassActorSpawnerSubsystem::ReleaseActorToPool(AActor* Actor)\n{\n\tif (!IsActorPoolingEnabled())\n\t{\n\t\treturn false;\n\t}\n\n\tconst bool bIsPoolableActor = Actor->Implements<UMassActorPoolableInterface>();\n\tif (bIsPoolableActor && IMassActorPoolableInterface::Execute_CanBePooled(Actor))\n\t{\n\t\tUMassAgentComponent* AgentComp = Actor->FindComponentByClass<UMassAgentComponent>();\n\t\tif (!AgentComp || AgentComp->IsReadyForPooling())\n\t\t{\n\t\t\tIMassActorPoolableInterface::Execute_PrepareForPooling(Actor);\n\t\t\tActor->SetActorHiddenInGame(true);\n\t\t\tif (AgentComp)\n\t\t\t{\n\t\t\t\tAgentComp->UnregisterWithAgentSubsystem();\n\t\t\t}\n\n\t\t\tauto& Pool = PooledActors.FindOrAdd(Actor->GetClass());\n\t\t\tcheckf(Pool.Find(Actor) == INDEX_NONE, TEXT(\"Actor%s is already in the pool\"), *AActor::GetDebugName(Actor));\n\t\t\tPool.Add(Actor);\n\t\t\t++NumActorPooled;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nFMassActorSpawnRequestHandle UMassActorSpawnerSubsystem::RequestActorSpawnInternal(const FConstStructView SpawnRequestView)\n{\n\t// The handle manager has a freelist of the release indexes, so it can return us a index that we previously used.\n\tconst FMassActorSpawnRequestHandle SpawnRequestHandle = SpawnRequestHandleManager.GetNextHandle();\n\tconst int32 Index = SpawnRequestHandle.GetIndex();\n\n\t// Check if we need to grow the array, otherwise it is a previously released index that was returned.\n\tif (!SpawnRequests.IsValidIndex(Index))\n\t{\n\t\tcheckf(SpawnRequests.Num() == Index, TEXT(\"This case should only be when we need to grow the array of one element.\"));\n\t\tSpawnRequests.Emplace(SpawnRequestView);\n\t}\n\telse\n\t{\n\t\tSpawnRequests[Index] = SpawnRequestView;\n\t}\n\n\tUWorld* World = GetWorld();\n\tcheck(World);\n\n\t// Initialize the spawn request status\n\tFMassActorSpawnRequest& SpawnRequest = GetMutableSpawnRequest<FMassActorSpawnRequest>(SpawnRequestHandle);\n\tSpawnRequest.SpawnStatus = ESpawnRequestStatus::Pending;\n\tSpawnRequest.SerialNumber = RequestSerialNumberCounter.fetch_add(1);\n\tSpawnRequest.RequestedTime = World->GetTimeSeconds();\n\n\treturn SpawnRequestHandle;\n}\n\n// @todo investigate whether storing requests in a sorted array would improve overall perf - if AllHandles was sorted we\n// wouldn't need to do any tests other than just checking if a thing is valid and not completed (i.e. pending or retry-pending).\nFMassActorSpawnRequestHandle UMassActorSpawnerSubsystem::GetNextRequestToSpawn(int32& InOutHandleIndex) const\n{\n\tconst TArray<FMassActorSpawnRequestHandle>& AllHandles = SpawnRequestHandleManager.GetHandles();\n\tif (AllHandles.Num() == 0)\n\t{\n\t\tInOutHandleIndex = INDEX_NONE;\n\t\treturn FMassActorSpawnRequestHandle();\n\t}\n\n\tFMassActorSpawnRequestHandle BestSpawnRequestHandle;\n\tfloat BestPriority = MAX_FLT;\n\tbool bBestIsPending = false;\n\tuint32 BestSerialNumber = MAX_uint32;\n\tint32 BestIndex = INDEX_NONE;\n\t\t\n\tint32 HandleIndex = InOutHandleIndex != INDEX_NONE ? ((InOutHandleIndex + 1) % AllHandles.Num()) : 0;\n\tconst int32 IterationsLimit = (InOutHandleIndex == INDEX_NONE) ? AllHandles.Num() : (AllHandles.Num() - 1);\n\t\n\tfor (int32 IterationIndex = 0; IterationIndex < IterationsLimit; ++IterationIndex, HandleIndex = (HandleIndex + 1) % AllHandles.Num())\n\t{\n\t\tconst FMassActorSpawnRequestHandle SpawnRequestHandle = AllHandles[HandleIndex];\n\t\tif (!SpawnRequestHandle.IsValid())\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tconst FMassActorSpawnRequest& SpawnRequest = GetSpawnRequest<FMassActorSpawnRequest>(SpawnRequestHandle);\n\t\tif (SpawnRequest.SpawnStatus == ESpawnRequestStatus::Pending)\n\t\t{\n\t\t\tif (!bBestIsPending ||\n\t\t\t\tSpawnRequest.Priority < BestPriority ||\n\t\t\t\t(SpawnRequest.Priority == BestPriority && SpawnRequest.SerialNumber < BestSerialNumber))\n\t\t\t{\n\t\t\t\tBestSpawnRequestHandle = SpawnRequestHandle;\n\t\t\t\tBestSerialNumber = SpawnRequest.SerialNumber;\n\t\t\t\tBestPriority = SpawnRequest.Priority;\n\t\t\t\tbBestIsPending = true;\n\t\t\t\tBestIndex = HandleIndex;\n\t\t\t}\n\t\t}\n\t\telse if (!bBestIsPending && SpawnRequest.SpawnStatus == ESpawnRequestStatus::RetryPending)\n\t\t{\n\t\t\t// No priority on retries just FIFO\n\t\t\tif (SpawnRequest.SerialNumber < BestSerialNumber)\n\t\t\t{\n\t\t\t\tBestSpawnRequestHandle = SpawnRequestHandle;\n\t\t\t\tBestSerialNumber = SpawnRequest.SerialNumber;\n\t\t\t\tBestIndex = HandleIndex;\n\t\t\t}\n\t\t}\n\t}\n\n\tInOutHandleIndex = BestIndex;\n\treturn BestSpawnRequestHandle;\n}\n\nESpawnRequestStatus UMassActorSpawnerSubsystem::SpawnOrRetrieveFromPool(FConstStructView SpawnRequestView, TObjectPtr<AActor>& OutSpawnedActor)\n{\n\tconst FMassActorSpawnRequest& SpawnRequest = SpawnRequestView.Get<const FMassActorSpawnRequest>();\n\n\tif (IsActorPoolingEnabled())\n\t{\n\t\tauto* Pool = PooledActors.Find(SpawnRequest.Template);\n\n\t\tif (Pool && Pool->Num() > 0)\n\t\t{\n\t\t\tAActor* PooledActor = (*Pool)[0];\n\t\t\tPool->RemoveAt(0);\n\t\t\t--NumActorPooled;\n\t\t\tPooledActor->SetActorHiddenInGame(false);\n\t\t\tPooledActor->SetActorTransform(SpawnRequest.Transform, false, nullptr, ETeleportType::ResetPhysics);\n\n\t\t\tIMassActorPoolableInterface::Execute_PrepareForGame(PooledActor);\n\n\t\t\tif (UMassAgentComponent* AgentComp = PooledActor->FindComponentByClass<UMassAgentComponent>())\n\t\t\t{\n\t\t\t\t// normally this function gets called from UMassAgentComponent::OnRegister. We need to call it manually here\n\t\t\t\t// since we're bringing this actor our of a pool.\n\t\t\t\tAgentComp->RegisterWithAgentSubsystem();\n\t\t\t}\n\n\t\t\tOutSpawnedActor = PooledActor;\n\t\t\treturn ESpawnRequestStatus::Succeeded;\n\t\t}\n\t}\n\n\tFActorSpawnParameters ActorSpawnParameters;\n\tESpawnRequestStatus SpawnStatus = SpawnActor(SpawnRequestView, OutSpawnedActor, ActorSpawnParameters);\n\n\tif (SpawnStatus == ESpawnRequestStatus::Succeeded)\n\t{\n\t\tif (IsValidChecked(OutSpawnedActor))\n\t\t{\n\t\t\t++NumActorSpawned;\n\t\t}\n\t}\n\telse\n\t{\n\t\tUE_VLOG_CAPSULE(this, LogMassActor, Error,\n\t\t\t\t\tSpawnRequest.Transform.GetLocation(),\n\t\t\t\t\tSpawnRequest.Template.GetDefaultObject()->GetSimpleCollisionHalfHeight(),\n\t\t\t\t\tSpawnRequest.Template.GetDefaultObject()->GetSimpleCollisionRadius(),\n\t\t\t\t\tSpawnRequest.Transform.GetRotation(),\n\t\t\t\t\tFColor::Red,\n\t\t\t\t\tTEXT(\"Unable to spawn actor for Mass entity [%s]\"), *SpawnRequest.MassAgent.DebugGetDescription());\n\t}\n\n\treturn SpawnStatus;\n}\n\nTObjectPtr<AActor> UMassActorSpawnerSubsystem::FindActorByName(const FName ActorName, ULevel* OverrideLevel) const\n{\n\tTObjectPtr<AActor> FoundActor;\n\tcheck(GetWorld());\n\tOverrideLevel = OverrideLevel ? OverrideLevel : GetWorld()->GetCurrentLevel();\n\t\n\tif (UObject* FoundObject = StaticFindObjectFast(nullptr, OverrideLevel, ActorName))\n\t{\n\t\tFoundActor = Cast<AActor>(FoundObject);\n\t\tif (FoundObject)\n\t\t{\n\t\t\tif (IsValid(FoundActor) == false)\n\t\t\t{\n\t\t\t\tFoundActor->ClearGarbage();\n\t\t\t}\n\t\t}\n\t}\n\treturn FoundActor;\n}\n\n ESpawnRequestStatus UMassActorSpawnerSubsystem::SpawnActor(FConstStructView SpawnRequestView, TObjectPtr<AActor>& OutSpawnedActor, FActorSpawnParameters& InOutSpawnParameters) const\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE(UMassActorSpawnerSubsystem::SpawnActor);\n\n\tUWorld* World = GetWorld();\n\tcheck(World);\n\n\tconst FMassActorSpawnRequest& SpawnRequest = SpawnRequestView.Get<const FMassActorSpawnRequest>();\n\n\tif (SpawnRequest.Guid.IsValid())\n\t{\n\t\t// offsetting `D` by 1 since `0` has special meaning for FNames\n\t\tInOutSpawnParameters.Name = FName(FString::Printf(TEXT(\"%s_%ud_%ud_%ud\"), *SpawnRequest.Template->GetName(), SpawnRequest.Guid.A, SpawnRequest.Guid.B, SpawnRequest.Guid.C), SpawnRequest.Guid.D + 1);\n\t\t//InOutSpawnParameters.OverrideLevel = InOutSpawnParameters.OverrideLevel ? OverrideLevel : World->GetCurrentLevel();\n\n\t\tOutSpawnedActor = FindActorByName(InOutSpawnParameters.Name, InOutSpawnParameters.OverrideLevel ? InOutSpawnParameters.OverrideLevel : World->GetCurrentLevel());\n\t\tif (OutSpawnedActor)\n\t\t{\n\t\t\tOutSpawnedActor->SetActorEnableCollision(true);\n\t\t\tOutSpawnedActor->SetActorHiddenInGame(false);\n\t\t\treturn ESpawnRequestStatus::Succeeded;\n\t\t}\n\t}\n\t\n\tInOutSpawnParameters.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;\n\tOutSpawnedActor = World->SpawnActor<AActor>(SpawnRequest.Template, SpawnRequest.Transform, InOutSpawnParameters);\n\n\treturn IsValid(OutSpawnedActor) ? ESpawnRequestStatus::Succeeded : ESpawnRequestStatus::Failed;\n}\n\nvoid UMassActorSpawnerSubsystem::ProcessPendingSpawningRequest(const double MaxTimeSlicePerTick)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE(UMassActorSpawnerSubsystem::ProcessPendingSpawningRequest);\n\n\tSpawnRequestHandleManager.ShrinkHandles();\n\n\tconst double TimeSliceEnd = FPlatformTime::Seconds() + MaxTimeSlicePerTick;\n\n\tconst int32 IterationsLimit = SpawnRequestHandleManager.CalcNumUsedHandles();\n\tint32 IterationsCount = 0;\n\n\twhile (FPlatformTime::Seconds() < TimeSliceEnd && IterationsCount++ < IterationsLimit)\n\t{\n\t\tconst FMassActorSpawnRequestHandle SpawnRequestHandle = GetNextRequestToSpawn(StartingHandleIndex);\n\n\t\t// getting an invalid handle is fine - it indicates no more handles are there to be considered. \n\t\tif (!SpawnRequestHandle.IsValid() \n\t\t\t|| !SpawnRequestHandleManager.IsValidHandle(SpawnRequestHandle))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tFStructView SpawnRequestView = SpawnRequests[SpawnRequestHandle.GetIndex()];\n\t\tFMassActorSpawnRequest& SpawnRequest = SpawnRequestView.Get<FMassActorSpawnRequest>();\n\n\t\tif (!ensureMsgf(SpawnRequest.SpawnStatus == ESpawnRequestStatus::Pending ||\n\t\t\t\t\t\tSpawnRequest.SpawnStatus == ESpawnRequestStatus::RetryPending, TEXT(\"GetNextRequestToSpawn returned a request that was already processed, need to return only request with pending status.\")))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tESpawnRequestStatus Result = ProcessSpawnRequest(SpawnRequestHandle, SpawnRequestView, SpawnRequest);\n\t\tensureMsgf(Result != ESpawnRequestStatus::None, TEXT(\"Getting ESpawnRequestStatus::None as a result in this context is unexpected. Needs to be investigated.\"));\n\t}\n}\n\nESpawnRequestStatus UMassActorSpawnerSubsystem::ProcessSpawnRequest(const FMassActorSpawnRequestHandle SpawnRequestHandle)\n{\n\tif (!SpawnRequestHandle.IsValid()\n\t\t|| !SpawnRequestHandleManager.IsValidHandle(SpawnRequestHandle))\n\t{\n\t\treturn ESpawnRequestStatus::None;\n\t}\n\n\tFStructView SpawnRequestView = SpawnRequests[SpawnRequestHandle.GetIndex()];\n\tFMassActorSpawnRequest& SpawnRequest = SpawnRequestView.Get<FMassActorSpawnRequest>();\n\n\treturn ProcessSpawnRequest(SpawnRequestHandle, SpawnRequestView, SpawnRequest);\n}\n\nESpawnRequestStatus UMassActorSpawnerSubsystem::ProcessSpawnRequest(const FMassActorSpawnRequestHandle SpawnRequestHandle, FStructView SpawnRequestView, FMassActorSpawnRequest& SpawnRequest)\n{\n\tif (!ensureMsgf(SpawnRequest.IsFinished() == false, TEXT(\"Finished spawn requests are not expected to be processed again. Bailing out.\")))\n\t{\n\t\t// returning None rather than the actual SpawnRequest.SpawnStatus to indicate the issue has occurred. \n\t\treturn ESpawnRequestStatus::None;\n\t}\n\n\t// Do the spawning\n\tSpawnRequest.SpawnStatus = ESpawnRequestStatus::Processing;\n\n\t// Call the pre spawn delegate on the spawn request\n\tif (SpawnRequest.ActorPreSpawnDelegate.IsBound())\n\t{\n\t\tSpawnRequest.ActorPreSpawnDelegate.Execute(SpawnRequestHandle, SpawnRequestView);\n\t}\n\n\tSpawnRequest.SpawnStatus = SpawnOrRetrieveFromPool(SpawnRequestView, SpawnRequest.SpawnedActor);\n\n\tif (SpawnRequest.IsFinished())\n\t{\n\t\tif (SpawnRequest.SpawnStatus == ESpawnRequestStatus::Succeeded && IsValid(SpawnRequest.SpawnedActor))\n\t\t{\n\t\t\tif (UMassAgentComponent* AgentComp = SpawnRequest.SpawnedActor->FindComponentByClass<UMassAgentComponent>())\n\t\t\t{\n\t\t\t\tAgentComp->SetPuppetHandle(SpawnRequest.MassAgent);\n\t\t\t}\n\t\t}\n\n\t\tEMassActorSpawnRequestAction PostAction = EMassActorSpawnRequestAction::Remove;\n\n\t\t// Call the post spawn delegate on the spawn request\n\t\tif (SpawnRequest.ActorPostSpawnDelegate.IsBound())\n\t\t{\n\t\t\tPostAction = SpawnRequest.ActorPostSpawnDelegate.Execute(SpawnRequestHandle, SpawnRequestView);\n\t\t}\n\n\t\tif (PostAction == EMassActorSpawnRequestAction::Remove)\n\t\t{\n\t\t\t// If notified, remove the spawning request\n\t\t\tensureMsgf(SpawnRequestHandleManager.RemoveHandle(SpawnRequestHandle), TEXT(\"When providing a delegate, the spawn request gets automatically removed, no need to remove it on your side\"));\n\t\t}\n\t}\n\telse\n\t{\n\t\t// lower priority\n\t\tSpawnRequest.SpawnStatus = ESpawnRequestStatus::RetryPending;\n\t}\n\n\treturn SpawnRequest.SpawnStatus;\n}\n\nvoid UMassActorSpawnerSubsystem::ProcessPendingDestruction(const double MaxTimeSlicePerTick)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE(UMassActorSpawnerSubsystem::ProcessPendingDestruction);\n\n\tUWorld* World = GetWorld();\n\tcheck(World);\n\n\tconst ENetMode CurrentWorldNetMode = World->GetNetMode();\n\tconst bool bHasToDestroyAllActorsOnServerSide = CurrentWorldNetMode != NM_Client && CurrentWorldNetMode != NM_Standalone;\n\tconst double TimeSliceEnd = FPlatformTime::Seconds() + MaxTimeSlicePerTick;\n\n\t{\n\t\t// Try release to pool actors or destroy them\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(DestroyActors);\n\t\twhile ((DeactivatedActorsToDestroy.Num() || ActorsToDestroy.Num()) && \n\t\t\t   (bHasToDestroyAllActorsOnServerSide || FPlatformTime::Seconds() <= TimeSliceEnd))\n\t\t{\n\t\t\tAActor* ActorToDestroy = DeactivatedActorsToDestroy.Num() ? DeactivatedActorsToDestroy.Pop(EAllowShrinking::No) : ActorsToDestroy.Pop(EAllowShrinking::No);\n\t\t\tif (ActorToDestroy && !ReleaseActorToPool(ActorToDestroy))\n\t\t\t{\n\t\t\t\t// Couldn't release actor back to pool, so destroy it\n\t\t\t\tConditionalDestroyActor(*World, *ActorToDestroy);\n\t\t\t\t--NumActorSpawned;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(ActorsToDestroy.Num())\n\t{\n\t\t// Try release to pool remaining actors or deactivate them\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(DeactivateActors);\n\t\tfor (AActor* ActorToDestroy : ActorsToDestroy)\n\t\t{\n\t\t\tif (!ReleaseActorToPool(ActorToDestroy))\n\t\t\t{\n\t\t\t\t// Couldn't release actor back to pool, do simple deactivate instead\n\t\t\t\tActorToDestroy->SetActorEnableCollision(false);\n\t\t\t\tActorToDestroy->SetActorHiddenInGame(true);\n\t\t\t\tActorToDestroy->SetActorTickEnabled(false);\n\t\t\t\tDeactivatedActorsToDestroy.Add(ActorToDestroy);\n\t\t\t}\n\t\t}\n\t\tActorsToDestroy.Reset();\n\t}\n}\n\nvoid UMassActorSpawnerSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tUMassSimulationSubsystem* SimSystem = Collection.InitializeDependency<UMassSimulationSubsystem>();\n\tcheck(SimSystem);\n\n\tSuper::Initialize(Collection);\n\n\tSimSystem->GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).AddUObject(this, &UMassActorSpawnerSubsystem::OnPrePhysicsPhaseStarted);\n\tSimSystem->GetOnProcessingPhaseFinished(EMassProcessingPhase::PrePhysics).AddUObject(this, &UMassActorSpawnerSubsystem::OnPrePhysicsPhaseFinished);\n}\n\nvoid UMassActorSpawnerSubsystem::Deinitialize()\n{\n\tSuper::Deinitialize();\n\n\tif (const UWorld* World = GetWorld())\n\t{\n\t\tif (UMassSimulationSubsystem* SimSystem = UWorld::GetSubsystem<UMassSimulationSubsystem>(World))\n\t\t{\n\t\t\tSimSystem->GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).RemoveAll(this);\n\t\t\tSimSystem->GetOnProcessingPhaseFinished(EMassProcessingPhase::PrePhysics).RemoveAll(this);\n\t\t}\n\t}\n}\n\nvoid UMassActorSpawnerSubsystem::OnPrePhysicsPhaseStarted(const float DeltaSeconds)\n{\n\t// Spawn actors before processors run so they can operate on deterministic actor state for the frame\n\t// \n\t// Note: MassRepresentationProcessor relies on actor spawns being processed before it runs so it can confirm the\n\t// spawn and clean up the previous representation  \n\tProcessPendingSpawningRequest(GET_MASSSIMULATION_CONFIG_VALUE(DesiredActorSpawningTimeSlicePerTick));\n\n\tCSV_CUSTOM_STAT(MassActors, NumSpawned, NumActorSpawned, ECsvCustomStatOp::Accumulate);\n\tCSV_CUSTOM_STAT(MassActors, NumPooled, NumActorPooled, ECsvCustomStatOp::Accumulate);\n}\n\nvoid UMassActorSpawnerSubsystem::OnPrePhysicsPhaseFinished(const float DeltaSeconds)\n{\n\t// Destroy any actors queued for destruction this frame and hide any we didn't get to within the max processing time\n\t// \n\t// Note: MassRepresentationProcessor relies on actor destruction processing after it runs so it can clean up\n\t// unwanted actor representations that it has replaced for this frame. It also relies on this running before physics\n\t// so unwanted representations don't interfere with new physics enabled actors \n\tProcessPendingDestruction(GET_MASSSIMULATION_CONFIG_VALUE(DesiredActorDestructionTimeSlicePerTick));\n}\n\nvoid UMassActorSpawnerSubsystem::AddReferencedObjects(UObject* InThis, FReferenceCollector& Collector)\n{\n\tUMassActorSpawnerSubsystem* MASS = Cast<UMassActorSpawnerSubsystem>(InThis);\n\tif (MASS)\n\t{\n\t\tfor (auto It = MASS->PooledActors.CreateIterator(); It; ++It)\n\t\t{\n\t\t\tCollector.AddReferencedObjects<AActor>(It.Value());\n\t\t}\n\t}\n\n\tSuper::AddReferencedObjects(InThis, Collector);\n}\n\nvoid UMassActorSpawnerSubsystem::EnableActorPooling() \n{ \n\tbActorPoolingEnabled = true; \n}\n\nvoid UMassActorSpawnerSubsystem::DisableActorPooling() \n{\n\tbActorPoolingEnabled = false;\n\n\tReleaseAllResources();\n\n}\n\nbool UMassActorSpawnerSubsystem::IsActorPoolingEnabled()\n{\n\treturn UE::MassActors::bUseActorPooling && bActorPoolingEnabled;\n}\n\nvoid UMassActorSpawnerSubsystem::ReleaseAllResources()\n{\n\tif (UWorld* World = GetWorld())\n\t{\n\t\tfor (auto It = PooledActors.CreateIterator(); It; ++It)\n\t\t{\n\t\t\tauto& ActorArray = It.Value();\n\t\t\tfor (int i = 0; i < ActorArray.Num(); i++)\n\t\t\t{\n\t\t\t\tif (ActorArray[i])\n\t\t\t\t{\n\t\t\t\t\tConditionalDestroyActor(*World, *ActorArray[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tNumActorSpawned -= ActorArray.Num();\n\t\t}\n\t}\n\tPooledActors.Empty();\n\n\tNumActorPooled = 0;\n\tCSV_CUSTOM_STAT(MassActors, NumSpawned, NumActorSpawned, ECsvCustomStatOp::Accumulate);\n\tCSV_CUSTOM_STAT(MassActors, NumPooled, NumActorPooled, ECsvCustomStatOp::Accumulate);\n}\n\n//-----------------------------------------------------------------------------\n// DEPRECATED\n//-----------------------------------------------------------------------------\nFMassActorSpawnRequestHandle UMassActorSpawnerSubsystem::GetNextRequestToSpawn() const\n{\n\tint32 DummyIndex = 0;\n\treturn GetNextRequestToSpawn(DummyIndex);\n}\n",
      "lines": 583
    },
    {
      "file_path": "MassGameplay\\MassActors\\Private\\MassActorSubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 6053,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassActorSubsystem.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassActorTypes.h\"\n#include \"Engine/World.h\"\n#include \"MassEntityManager.h\"\n#include \"MassEntitySubsystem.h\"\n#include \"MassSimulationSubsystem.h\"\n#include \"VisualLogger/VisualLogger.h\"\n\n//----------------------------------------------------------------------//\n//  FMassActorFragment \n//----------------------------------------------------------------------//\n\nvoid FMassActorFragment::SetAndUpdateHandleMap(const FMassEntityHandle MassAgent, AActor* InActor, const bool bInIsOwnedByMass)\n{\n\tSetNoHandleMapUpdate(MassAgent, InActor, bInIsOwnedByMass);\n\n\tif (InActor)\n\t{\n\t\tUWorld* World = InActor->GetWorld();\n\t\tcheck(World);\n\t\tif (UMassActorSubsystem* MassActorSubsystem = UWorld::GetSubsystem<UMassActorSubsystem>(World))\n\t\t{\n\t\t\tMassActorSubsystem->SetHandleForActor(InActor, MassAgent);\n\t\t}\n\t}\n}\n\nvoid FMassActorFragment::ResetAndUpdateHandleMap(UMassActorSubsystem* CachedActorSubsystem)\n{\n\tif (AActor* ActorPtr = Cast<AActor>(Actor.Get()))\n\t{\n\t\tif (CachedActorSubsystem == nullptr)\n\t\t{\n\t\t\tUWorld* World = Actor->GetWorld();\n\t\t\tUE_CLOG(World == nullptr, LogMassActor, Warning, TEXT(\"%hs: got Null while fetching World for actor %s. Can cause issues down the line. Pass in the optional CachedActorSubsystem parameter to address\")\n\t\t\t\t, __FUNCTION__, *GetNameSafe(ActorPtr));\n\t\t\tCachedActorSubsystem = UWorld::GetSubsystem<UMassActorSubsystem>(World);\n\t\t}\n\n\t\tif (CachedActorSubsystem)\n\t\t{\n\t\t\tCachedActorSubsystem->RemoveHandleForActor(ActorPtr);\n\t\t}\n\t}\n\n\tResetNoHandleMapUpdate();\n}\n\nvoid FMassActorFragment::SetNoHandleMapUpdate(const FMassEntityHandle MassAgent, AActor* InActor, const bool bInIsOwnedByMass)\n{\n\tcheck(InActor);\n\tcheck(!Actor.IsValid());\n\tcheck(MassAgent.IsValid());\n\tActor = InActor;\n\tbIsOwnedByMass = bInIsOwnedByMass;\n}\n\nvoid FMassActorFragment::ResetNoHandleMapUpdate()\n{\n\tActor.Reset();\n\tbIsOwnedByMass = false;\n}\n\nAActor* FMassActorFragment::GetMutable(EActorAccess Access)\n{\n\tswitch (Access)\n\t{\n\tcase EActorAccess::OnlyWhenAlive:\n\t\treturn Actor.Get();\n\tcase EActorAccess::IncludePendingKill:\n\t\treturn Actor.Get(true);\n\tcase EActorAccess::IncludeUnreachable:\n\t\treturn Actor.GetEvenIfUnreachable();\n\tdefault:\n\t\tcheckf(false, TEXT(\"Invalid ActorAccess value: %i.\"), static_cast<int32>(Access));\n\t\treturn nullptr;\n\t}\n}\n\nconst AActor* FMassActorFragment::Get(EActorAccess Access) const\n{\n\treturn const_cast<FMassActorFragment*>(this)->GetMutable(Access);\n}\n\n//----------------------------------------------------------------------//\n//  UMassActorSubsystem \n//----------------------------------------------------------------------//\nvoid UMassActorSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tSuper::Initialize(Collection);\n\t// making sure UMassSimulationSubsystem gets created before the MassActorSubsystem\n\tCollection.InitializeDependency<UMassSimulationSubsystem>();\n\t\n\tif (UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(GetWorld()))\n\t{\n\t\tActorManager = MakeShareable(new FMassActorManager(EntitySubsystem->GetMutableEntityManager().AsShared()));\n\t}\n}\n\nvoid UMassActorSubsystem::Deinitialize()\n{\n\tActorManager.Reset();\n\tSuper::Deinitialize();\n}\n\n//----------------------------------------------------------------------//\n//  FMassActorManager\n//----------------------------------------------------------------------//\nFMassActorManager::FMassActorManager(const TSharedPtr<FMassEntityManager>& InEntityManager, UObject* InOwner)\n\t: EntityManager(InEntityManager)\n\t, Owner(InOwner)\n{\n\n}\n\nFMassEntityHandle FMassActorManager::GetEntityHandleFromActor(const TObjectKey<const AActor> Actor)\n{\n\tcheckSlow(EntityManager);\n\n\tUE_MT_SCOPED_READ_ACCESS(ActorHandleMapDetector);\n\tFMassEntityHandle* Entity = ActorHandleMap.Find(Actor);\n\tif (Entity == nullptr || EntityManager->IsEntityValid(*Entity) == false)\n\t{\n\t\treturn FMassEntityManager::InvalidEntity;\n\t}\n\n\tcheck(TObjectKey<const AActor>(GetActorFromHandle(*Entity, FMassActorFragment::EActorAccess::IncludeUnreachable)) == Actor);\n\treturn *Entity;\n}\n\nAActor* FMassActorManager::GetActorFromHandle(const FMassEntityHandle Handle, FMassActorFragment::EActorAccess Access) const\n{\n\tcheck(EntityManager);\n\tFMassActorFragment* Data = EntityManager->GetFragmentDataPtr<FMassActorFragment>(Handle);\n\treturn Data != nullptr ? Data->GetMutable(Access) : nullptr;\n}\n\nvoid FMassActorManager::SetHandleForActor(const TObjectKey<const AActor> Actor, const FMassEntityHandle Handle)\n{\n\tUE_MT_SCOPED_WRITE_ACCESS(ActorHandleMapDetector);\n\tActorHandleMap.Add(Actor, Handle);\n}\n\nvoid FMassActorManager::RemoveHandleForActor(const TObjectKey<const AActor> Actor)\n{\n\tUE_MT_SCOPED_WRITE_ACCESS(ActorHandleMapDetector);\n\tActorHandleMap.Remove(Actor);\n}\n\nvoid FMassActorManager::DisconnectActor(const TObjectKey<const AActor> Actor, const FMassEntityHandle Handle)\n{\n\tif (Handle.IsValid() == false)\n\t{\n\t\treturn;\n\t}\n\n\tFMassEntityHandle FoundEntity;\n\t{\n\t\tUE_MT_SCOPED_WRITE_ACCESS(ActorHandleMapDetector);\n\t\t// We're assuming the Handle does match Actor, so we're RemoveAndCopyValue. If if doesn't we'll add it back.\n\t\t// The expectation is that this won't happen on a regular basis..\n\t\tif (ActorHandleMap.RemoveAndCopyValue(Actor, FoundEntity) == false)\n\t\t{\n\t\t\t// the entity doesn't match the actor\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (FoundEntity == Handle)\n\t{\n\t\tcheck(EntityManager);\n\t\tif (FMassActorFragment* Data = EntityManager->GetFragmentDataPtr<FMassActorFragment>(Handle))\n\t\t{\n\t\t\tData->ResetAndUpdateHandleMap();\n\t\t}\n\t}\n\telse\n\t{\n\t\t// unexpected mismatch. Add back and notify.\n\t\tUE_VLOG_UELOG(Owner.Get(), LogMass, Warning, TEXT(\"%s: Trying to disconnect actor %s while the Handle given doesn't match the system\\'s records\")\n\t\t\t, ANSI_TO_TCHAR(__FUNCTION__), *AActor::GetDebugName(Actor.ResolveObjectPtr()));\n\t\tSetHandleForActor(Actor, Handle);\n\t}\n}\n",
      "lines": 187
    },
    {
      "file_path": "MassGameplay\\MassActors\\Private\\MassActorTypes.cpp",
      "extension": ".cpp",
      "size_bytes": 121,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassActorTypes.h\"\n\nDEFINE_LOG_CATEGORY(LogMassActor);\n",
      "lines": 5
    },
    {
      "file_path": "MassGameplay\\MassActors\\Private\\MassAgentComponent.cpp",
      "extension": ".cpp",
      "size_bytes": 21718,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassAgentComponent.h\"\n#include \"EngineUtils.h\"\n#include \"MassEntityView.h\"\n#include \"MassEntityManager.h\"\n#include \"MassEntitySubsystem.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassAgentSubsystem.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassActorSubsystem.h\"\n#include \"MassSpawner.h\"\n#include \"Net/UnrealNetwork.h\"\n#include \"MassReplicationSubsystem.h\"\n#include \"MassReplicationFragments.h\"\n#include \"MassMovementFragments.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n\n#define MASSAGENT_CHECK( condition, Format, ... ) \\\n\tUE_CVLOG(!(condition), GetOwner(), LogMass, Error, Format, ##__VA_ARGS__); \\\n\tcheckf( condition, Format, ##__VA_ARGS__ );\n\n//----------------------------------------------------------------------//\n// UMassAgentComponent\n//----------------------------------------------------------------------//\nUMassAgentComponent::UMassAgentComponent()\n\t: EntityConfig(*this)\n{\n#if WITH_EDITORONLY_DATA\n\tbAutoRegisterInEditorMode = true;\n#endif // WITH_EDITORONLY_DATA\n\tbAutoRegister = true;\n\tState = EAgentComponentState::None;\n\tSetIsReplicatedByDefault(true);\n}\n\n#if WITH_EDITOR\nvoid UMassAgentComponent::PostInitProperties() \n{\n\tSuper::PostInitProperties();\n\n\tif (HasAnyFlags(RF_ClassDefaultObject | RF_ArchetypeObject | RF_NeedLoad) || GetOuter() == nullptr || GetOuter()->HasAnyFlags(RF_ClassDefaultObject | RF_ArchetypeObject))\n\t{\n\t\treturn;\n\t}\n\t\n\tif (GetWorld())\n\t{\n\t\tbAutoRegister = bAutoRegisterInEditorMode || GetWorld()->IsGameWorld();\n\t}\n}\nvoid UMassAgentComponent::PostLoad()\n{\n\tSuper::PostLoad();\n\tif (HasAnyFlags(RF_ClassDefaultObject | RF_ArchetypeObject) || GetOuter() == nullptr || GetOuter()->HasAnyFlags(RF_ClassDefaultObject | RF_ArchetypeObject))\n\t{\n\t\treturn;\n\t}\n\n\tif (GetWorld())\n\t{\n\t\tbAutoRegister = bAutoRegisterInEditorMode || GetWorld()->IsGameWorld();\n\t}\n}\n#endif // WITH_EDITOR\n\nvoid UMassAgentComponent::OnRegister()\n{\n\tSuper::OnRegister();\n\n\tif (IsRunningCommandlet() || IsRunningCookCommandlet() || GIsCookerLoadingPackage)\n\t{\n\t\t// ignore, we're not doing any registration while cooking or running a commandlet\n\t\treturn;\n\t}\n\n\tif (GetOuter() == nullptr || GetOuter()->HasAnyFlags(RF_ClassDefaultObject | RF_ArchetypeObject) || HasAnyFlags(RF_ArchetypeObject))\n\t{\n\t\t// we won't try registering a CDO's component with Mass\n\t\tensure(false && \"temp, wanna know this happened\");\n\t\treturn;\n\t}\n\n\tUWorld* World = GetWorld();\n\tif (World == nullptr\n#if WITH_EDITOR\n\t\t|| World->IsPreviewWorld() || (bAutoRegisterInEditorMode == false && World->IsGameWorld() == false)\n#endif // WITH_EDITOR\n\t\t)\n\t{\n\t\t// we don't care about preview worlds. Those are transient, temporary worlds like the one created when opening a BP editor.\n\t\treturn;\n\t}\n\n\t// @todo hook up to pawn possessing stuff, maybe?\n\tRegisterWithAgentSubsystem();\n}\n\nbool UMassAgentComponent::IsReadyForPooling() const\n{\n\t// If we're waiting for puppet initialization, we could have some bad interactions\n\tif (IsPuppetPendingInitialization())\n\t{\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid UMassAgentComponent::RegisterWithAgentSubsystem()\n{\n\tUMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(GetWorld());\n\tUE_CVLOG_UELOG(AgentSubsystem == nullptr, GetOwner(), LogMass, Error, TEXT(\"Unable to find UMassAgentSubsystem instance. Make sure the world is initialized\"));\n\tif (ensureMsgf(AgentSubsystem, TEXT(\"Unable to find UMassAgentSubsystem instance. Make sure the world is initialized\")))\n\t{\n\t\tTemplateID = AgentSubsystem->RegisterAgentComponent(*this);\n\t}\n}\n\nvoid UMassAgentComponent::UnregisterWithAgentSubsystem()\n{\n\tif (State != EAgentComponentState::None)\n\t{\n\t\tif (UMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(GetWorld()))\n\t\t{\n\t\t\tUE_VLOG(GetOwner(), LogMass, Verbose, TEXT(\"%s\"), ANSI_TO_TCHAR(__FUNCTION__));\n\t\t\tAgentSubsystem->ShutdownAgentComponent(*this);\n\t\t\tMASSAGENT_CHECK(State == EAgentComponentState::None ||\n\t\t\t\tState == EAgentComponentState::PuppetPaused ||\n\t\t\t\tState == EAgentComponentState::PuppetReplicatedOrphan,\n\t\t\t\tTEXT(\"%s is expecting to be in state[None|PuppetPaused|PuppetReplicatedOrphan] state but is in %s\"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));\n\t\t}\n\t}\n\tDebugCheckStateConsistency();\n\tif (AgentHandle.IsValid())\n\t{\n\t\tClearEntityHandleInternal();\n\t}\n\n\tState = EAgentComponentState::None;\n\tTemplateID = FMassEntityTemplateID();\n}\n\nvoid UMassAgentComponent::OnUnregister()\n{\n\tUE_VLOG(GetOwner(), LogMass, Verbose, TEXT(\"%s\"), ANSI_TO_TCHAR(__FUNCTION__));\n\tUnregisterWithAgentSubsystem();\n\n\tSuper::OnUnregister();\n}\n\nvoid UMassAgentComponent::SetEntityHandle(const FMassEntityHandle NewHandle)\n{\n\tMASSAGENT_CHECK(State == EAgentComponentState::EntityPendingCreation,\n\t\tTEXT(\"%s is expecting to be in state[EntityPendingCreation] but is in %s\"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));\n\n\tSetEntityHandleInternal(NewHandle);\n\tSwitchToState(EAgentComponentState::EntityCreated);\n}\n\nvoid UMassAgentComponent::SetEntityHandleInternal(const FMassEntityHandle NewHandle)\n{\n\tensureMsgf((AgentHandle.IsValid() && NewHandle.IsValid()) == false, TEXT(\"Overriding an existing entity ID might result in a dangling entity still affecting the simulation\"));\n\tAgentHandle = NewHandle;\n\n\tUMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(GetWorld());\n#if\tUE_REPLICATION_COMPILE_SERVER_CODE\n\t// Fetch NetID if it exist\n\tif (EntitySubsystem)\n\t{\n\t\tif (const FMassNetworkIDFragment* NetIDFragment = EntitySubsystem->GetEntityManager().GetFragmentDataPtr<FMassNetworkIDFragment>(AgentHandle))\n\t\t{\n\t\t\tif (!IsNetSimulating())\n\t\t\t{\n\t\t\t\tNetID = NetIDFragment->NetID;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcheck(NetID == NetIDFragment->NetID);\n\t\t\t}\n\t\t}\n\t}\n#endif // UE_REPLICATION_COMPILE_SERVER_CODE\n\n\tif (const UMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(GetWorld()))\n\t{\n\t\tAgentSubsystem->NotifyMassAgentComponentEntityAssociated(*this);\n\t}\n\n\t// Sync up with mass\n\tif (EntitySubsystem)\n\t{\n\t\tif (IsNetSimulating())\n\t\t{\n\t\t\tconst FMassEntityView EntityView(EntitySubsystem->GetEntityManager(), AgentHandle);\n\n\t\t\t// @todo Find a way to add these initialization into either translator initializer or adding new fragments\n\t\t\t// Make sure to fetch the fragment after any release, as that action can move the entity around into new archetype and \n\t\t\t// by the same fact change the references to the fragments.\n\t\t\tif (FMassActorFragment* ActorInfo = EntityView.GetFragmentDataPtr<FMassActorFragment>())\n\t\t\t{\n\t\t\t\tcheckf(!ActorInfo->IsValid(), TEXT(\"Expecting ActorInfo fragment to be null\"));\n\t\t\t\tActorInfo->SetAndUpdateHandleMap(AgentHandle, GetOwner(), !IsNetSimulating()/*bIsOwnedByMass*/);\n\t\t\t}\n\n\t\t\t// Initialize location of the replicated actor to match the mass replicated one\n\t\t\tif (const FTransformFragment* TransformFragment = EntityView.GetFragmentDataPtr<FTransformFragment>())\n\t\t\t{\n\t\t\t\tGetOwner()->SetActorTransform(TransformFragment->GetTransform(), /*bSweep*/false, /*OutSweepHitResult*/nullptr, ETeleportType::TeleportPhysics);\n\t\t\t}\n\n\t\t\t// Initialize velocity of the replicated actor to match the mass replicated one\n\t\t\tif (const FMassVelocityFragment* Velocity = EntityView.GetFragmentDataPtr<FMassVelocityFragment>())\n\t\t\t{\n\t\t\t\tif (UCharacterMovementComponent* MovementComp = GetOwner()->FindComponentByClass<UCharacterMovementComponent>())\n\t\t\t\t{\n\t\t\t\t\tMovementComp->Velocity = Velocity->Value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid UMassAgentComponent::SetPuppetHandle(const FMassEntityHandle NewHandle)\n{\n\tMASSAGENT_CHECK(State == EAgentComponentState::EntityPendingCreation,\n\t\tTEXT(\"%s is expecting to be in state[EntityPendingCreation] but is in %s\"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));\n\tDebugCheckStateConsistency();\n\n\tcheckf(AgentHandle.IsValid() == false, TEXT(\"Can't set a new puppet handle of top of a regular agent handle. Entities would end up dangling.\"));\n\tSetEntityHandleInternal(NewHandle);\n\n\tif (UMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(GetWorld()))\n\t{\n\t\tAgentSubsystem->MakePuppet(*this);\n\t}\n}\n\nvoid UMassAgentComponent::PuppetInitializationPending()\n{\n\tMASSAGENT_CHECK(State == EAgentComponentState::EntityPendingCreation ||\n\t\tState == EAgentComponentState::PuppetPendingReplication ||\n\t\tState == EAgentComponentState::PuppetPaused ||\n\t\tState == EAgentComponentState::PuppetReplicatedOrphan,\n\t\tTEXT(\"%s is expecting to be in state[EntityPendingCreation|PuppetPendingReplication|PuppetPaused|PuppetReplicatedOrphan] but is in %s\"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));\n\tSwitchToState(EAgentComponentState::PuppetPendingInitialization);\n}\n\nvoid UMassAgentComponent::PuppetInitializationDone()\n{\n\tMASSAGENT_CHECK(State == EAgentComponentState::PuppetPendingInitialization,\n\t\tTEXT(\"%s is expecting to be in state[PuppetPendingInitialization] but is in %s\"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));\n\tSwitchToState(EAgentComponentState::PuppetInitialized);\n}\n\nvoid UMassAgentComponent::PuppetInitializationAborted()\n{\n\tMASSAGENT_CHECK(State == EAgentComponentState::PuppetPendingInitialization,\n\t\tTEXT(\"%s is expecting to be in state[PuppetPendingInitialization] but is in %s\"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));\n\tSwitchToState(EAgentComponentState::PuppetPaused);\n}\n\nvoid UMassAgentComponent::ClearEntityHandle()\n{\n\tMASSAGENT_CHECK(State == EAgentComponentState::EntityCreated,\n\t\tTEXT(\"%s is expecting to be in state[EntityCreated] but is in %s\"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));\n\n\tClearEntityHandleInternal();\n\tSwitchToState(EAgentComponentState::None);\n}\n\nvoid UMassAgentComponent::ClearEntityHandleInternal()\n{\n\tif (UWorld* World = GetWorld())\n\t{\n\t\tif (const UMassAgentSubsystem* AgentSubsystem = World->GetSubsystem<UMassAgentSubsystem>())\n\t\t{\n\t\t\tAgentSubsystem->NotifyMassAgentComponentEntityDetaching(*this);\n\t\t}\n\n\t\tif (IsNetSimulating())\n\t\t{\n\t\t\t// Sync up with mass\n\t\t\tif (const UMassEntitySubsystem* EntitySubsystem = World->GetSubsystem<UMassEntitySubsystem>())\n\t\t\t{\n\t\t\t\tconst FMassEntityView EntityView(EntitySubsystem->GetEntityManager(), AgentHandle);\n\t\t\t\tif (FMassActorFragment* ActorInfo = EntityView.GetFragmentDataPtr<FMassActorFragment>())\n\t\t\t\t{\n\t\t\t\t\tcheckf(!ActorInfo->IsValid() || ActorInfo->Get() == GetOwner(), TEXT(\"Expecting actor pointer to be the Component\\'s owner\"));\n\t\t\t\t\tActorInfo->ResetAndUpdateHandleMap(World->GetSubsystem<UMassActorSubsystem>());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tAgentHandle = FMassEntityManager::InvalidEntity;\n}\n\nvoid UMassAgentComponent::PuppetUnregistrationDone()\n{\t\n\tMASSAGENT_CHECK(State == EAgentComponentState::PuppetPaused ||\n\t\t\t State == EAgentComponentState::PuppetInitialized,\n\t\tTEXT(\"%s is expecting to be in state[PuppetPaused|PuppetInitialized] state but is in %s\"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));\n\n\tSwitchToState(EAgentComponentState::PuppetPaused);\n\n\tPuppetSpecificAddition.Reset();\n\n\t// AgentHandle on purpose. It's possible to unregister the AgentComponent just to\n\t// re-register it soon after in which case having this information stored is beneficial to avoid a need to \n\t// re-configure the component as a puppet\n}\n\nvoid UMassAgentComponent::EntityCreationPending()\n{\n\tMASSAGENT_CHECK(State == EAgentComponentState::None,\n\t\tTEXT(\"%s is expecting to be in state[None] but is in %s\"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));\n\tSwitchToState(EAgentComponentState::EntityPendingCreation);\n}\n\nvoid UMassAgentComponent::EntityCreationAborted()\n{\n\tMASSAGENT_CHECK(State == EAgentComponentState::EntityPendingCreation,\n\t\tTEXT(\"%s is expecting to be in state[EntityPendingCreation] but is in %s\"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));\n\tSwitchToState(EAgentComponentState::None);\n}\n\nvoid UMassAgentComponent::SwitchToState(EAgentComponentState NewState)\n{\n\tUE_VLOG(GetOwner(), LogMass, Verbose, TEXT(\"Entity[%s] %s From:%s To:%s\"), *AgentHandle.DebugGetDescription(), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State), *UEnum::GetValueAsString(NewState));\n\tState = NewState;\n\tDebugCheckStateConsistency();\n}\n\nvoid UMassAgentComponent::DebugCheckStateConsistency()\n{\n#if DO_CHECK\n\tswitch (State)\n\t{\n\t\tcase EAgentComponentState::None:\n\t\tcase EAgentComponentState::EntityPendingCreation:\n\t\t\tMASSAGENT_CHECK(AgentHandle.IsValid() == false, TEXT(\"Not expecting a valid mass agent handle in state %s\"), *UEnum::GetValueAsString(State));\n\t\t\tbreak;\n\t\tcase EAgentComponentState::EntityCreated:\n\t\t\tMASSAGENT_CHECK(AgentHandle.IsValid() == true, TEXT(\"Expecting a valid mass agent handle in state %s\"), *UEnum::GetValueAsString(State));\n\t\t\tbreak;\n\t\tcase EAgentComponentState::PuppetPendingInitialization:\n\t\tcase EAgentComponentState::PuppetInitialized:\n\t\tcase EAgentComponentState::PuppetPaused:\n\t\t{\n\t\t\tconst bool bValidAgentHandle = AgentHandle.IsValid();\n\t\t\tMASSAGENT_CHECK(bValidAgentHandle, TEXT(\"Expecting a valid mass agent handle in state %s\"), *UEnum::GetValueAsString(State));\n\t\t\tif (bValidAgentHandle)\n\t\t\t{\n\t\t\t\tif (const UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(GetWorld()))\n\t\t\t\t{\n\t\t\t\t\tconst FMassEntityManager& EntityManager = EntitySubsystem->GetEntityManager();\n\t\t\t\t\tconst bool bIsValidEntity = EntityManager.IsEntityValid(AgentHandle);\n\t\t\t\t\tMASSAGENT_CHECK(bIsValidEntity, TEXT(\"Exepecting a valid entity in state\"), *UEnum::GetValueAsString(State))\n\t\t\t\t\tif (bIsValidEntity)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst bool bIsBuiltEntity = EntityManager.IsEntityBuilt(AgentHandle);\n\t\t\t\t\t\tMASSAGENT_CHECK(bIsBuiltEntity, TEXT(\"Expecting a fully built entity in state %s\"), *UEnum::GetValueAsString(State));\n\t\t\t\t\t\tif (bIsBuiltEntity)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAActor* Owner = GetOwner();\n\t\t\t\t\t\t\tconst AActor* Actor = EntityManager.GetFragmentDataChecked<FMassActorFragment>(AgentHandle).Get();\n\t\t\t\t\t\t\tMASSAGENT_CHECK(Actor == nullptr || Actor == Owner, TEXT(\"Mass Actor and Owner mismatched in state %s\"), *UEnum::GetValueAsString(State));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase EAgentComponentState::PuppetPendingReplication:\n\t\t\tMASSAGENT_CHECK(IsNetSimulating(), TEXT(\"Expecting to be a replicated none authoritative actor in state %s\"), *UEnum::GetValueAsString(State));\n\t\t\tMASSAGENT_CHECK(AgentHandle.IsValid() == false, TEXT(\"Not expecting a valid mass agent handle in state %s\"), *UEnum::GetValueAsString(State));\n\t\t\tMASSAGENT_CHECK(NetID.IsValid() == false, TEXT(\"Not expecting a valid net id in state %s\"), *UEnum::GetValueAsString(State));\n\t\t\tbreak;\n\t\tcase EAgentComponentState::PuppetReplicatedOrphan:\n\t\t\tMASSAGENT_CHECK(IsNetSimulating(), TEXT(\"Expecting to be a replicated none authoritative actor in state %s\"), *UEnum::GetValueAsString(State));\n\t\t\tMASSAGENT_CHECK(AgentHandle.IsValid() == false, TEXT(\"Not expecting a valid mass agent handle in state %s\"), *UEnum::GetValueAsString(State));\n\t\t\tMASSAGENT_CHECK(NetID.IsValid() == true, TEXT(\"Expecting a valid net id in state %s\"), *UEnum::GetValueAsString(State));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMASSAGENT_CHECK(false, TEXT(\"Unsuported agent component state\"));\n\t\t\tbreak;\n\t}\n#endif // DO_CHECK\n}\n\nvoid UMassAgentComponent::SetEntityConfig(const FMassEntityConfig& InEntityConfig)\n{\n\tEntityConfig = InEntityConfig;\n\tEntityConfig.SetOwner(*this);\n}\n\nvoid UMassAgentComponent::Enable()\n{\n\tif (IsRegistered() == false)\n\t{\n\t\tUE_VLOG(GetOwner(), LogMass, Verbose, TEXT(\"%s\"), ANSI_TO_TCHAR(__FUNCTION__));\n\t\tRegisterComponent();\n\t}\n}\n\nvoid UMassAgentComponent::Disable()\n{\n\tif (IsRegistered())\n\t{\n\t\tUE_VLOG(GetOwner(), LogMass, Verbose, TEXT(\"%s\"), ANSI_TO_TCHAR(__FUNCTION__));\n\t\tUnregisterComponent();\n\t}\n}\n\n/* This method is evil and if it get called before while spawning the AgentHandle is not set yet and some early code was destroying actor after a certain time even if the kill entity did not worked. */\nvoid UMassAgentComponent::KillEntity(const bool bDestroyActor)\n{\n\tUE_VLOG(GetOwner(), LogMass, Verbose, TEXT(\"%s\"), ANSI_TO_TCHAR(__FUNCTION__));\n\n\tAActor* Owner = GetOwner();\n\tUWorld* World = GetWorld();\n\tif (Owner == nullptr)\n\t{\n\t\treturn;\n\t}\n\n\t// Caching the entity and if we have to disconnect actor as the next operation will invalidate that information\n\tconst FMassEntityHandle EntityHandleToDespawn = AgentHandle;\n\tconst bool bDisconnectActor = IsPuppet() && bDestroyActor == false;\n\tif (State != EAgentComponentState::None)\n\t{\n\t\tif (UMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(World))\n\t\t{\n\t\t\tAgentSubsystem->UnregisterAgentComponent(*this);\n\t\t\tMASSAGENT_CHECK(State == EAgentComponentState::None ||\n\t\t\t\tState == EAgentComponentState::PuppetPaused,\n\t\t\t\tTEXT(\"%s is expecting to be in state[None|PuppetPaused] but is in %s\"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));\n\t\t\t// We need to clear the entity now as it will be despawned below.\n\t\t\tClearEntityHandleInternal();\n\t\t\t// Since we cleared the entity handle, need to switch to none state to prevent the call to UnregisterAgentComponent upon actor destruction.\n\t\t\tSwitchToState(EAgentComponentState::None);\n\t\t}\n\t}\n\n\tif (bDisconnectActor)\n\t{\n\t\t// break connection between entity and actor so that the actor doesn't get destroyed as part of the entity's \n\t\t// removal. Removal is to be expected for puppet actors.\n\t\tif (UMassActorSubsystem* ActorSubsystem = UWorld::GetSubsystem<UMassActorSubsystem>(World))\n\t\t{\n\t\t\tActorSubsystem->DisconnectActor(Owner, EntityHandleToDespawn);\n\t\t}\n\t}\n\n\t// @todo temp hack to utilize the same path as Spawners (i.e. using EntityTemplate's deinitialization pipeline). \n\t// this will go away once we switch over to system-component based approach or monitors\n\tif (EntityHandleToDespawn.IsValid())\n\t{\n\t\tfor (TActorIterator<AMassSpawner> It(World); It; ++It)\n\t\t{\n\t\t\t(*It)->DespawnEntity(EntityHandleToDespawn);\n\t\t}\n\t}\n}\n\nvoid UMassAgentComponent::PausePuppet(const bool bPause)\n{\n\tMASSAGENT_CHECK(IsPuppet(), TEXT(\"%s can only be called when the the mass agent component acts as a puppet. Current state is %s\"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));\n\tif (IsPuppetPaused() != bPause)\n\t{\n\t\tif (UMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(GetWorld()))\n\t\t{\n\t\t\tif (bPause)\n\t\t\t{\n\t\t\t\tMASSAGENT_CHECK(State == EAgentComponentState::PuppetPendingInitialization ||\n\t\t\t\t\tState == EAgentComponentState::PuppetInitialized,\n\t\t\t\t\tTEXT(\"%s(true) is expecting to be in state[PuppetPendingInitialization|PuppetInitialized] but is in %s\"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));\n\n\t\t\t\tAgentSubsystem->UnregisterAgentComponent(*this);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tMASSAGENT_CHECK(State == EAgentComponentState::PuppetPaused,\n\t\t\t\t\tTEXT(\"%s(false) is expecting to be in state[PuppetPaused] but is in %s\"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));\n\n\t\t\t\tAgentSubsystem->RegisterAgentComponent(*this);\n\t\t\t}\n\t\t}\n\t}\n\tDebugCheckStateConsistency();\n}\n\nvoid UMassAgentComponent::PuppetReplicationPending()\n{\n\tcheckf(IsNetSimulating(), TEXT(\"Expecting a replicated pupet\"));\n\tMASSAGENT_CHECK(State == EAgentComponentState::None,\n\t\tTEXT(\"%s is expecting to be in state[None] but is in %s\"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));\n\n\tSwitchToState(EAgentComponentState::PuppetPendingReplication);\n}\n\nvoid UMassAgentComponent::SetReplicatedPuppetHandle(FMassEntityHandle NewHandle)\n{\n\tcheckf(IsNetSimulating(), TEXT(\"Expecting a replicated pupet\"));\n\tMASSAGENT_CHECK(State == EAgentComponentState::PuppetPendingReplication ||\n\t\tState == EAgentComponentState::PuppetReplicatedOrphan,\n\t\tTEXT(\"%s is expecting to be in state [PuppetPendingReplication|PuppetReplicatedOrphan] but is in %s\"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));\n\n\tSetEntityHandleInternal(NewHandle);\n}\n\nvoid UMassAgentComponent::ClearReplicatedPuppetHandle()\n{\n\tcheckf(IsNetSimulating(), TEXT(\"Expecting a replicated pupet\"));\n\tMASSAGENT_CHECK(State == EAgentComponentState::PuppetPaused,\n\t\tTEXT(\"%s is expecting to be in state [PuppetPaused] but is in %s\"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));\n\n\tif (UMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(GetWorld()))\n\t{\n\t\tUE_VLOG(GetOwner(), LogMass, Verbose, TEXT(\"%s\"), ANSI_TO_TCHAR(__FUNCTION__));\n\t\tAgentSubsystem->UnregisterAgentComponent(*this);\n\t}\n\tClearEntityHandleInternal();\n\tSwitchToState(EAgentComponentState::PuppetReplicatedOrphan);\n}\n\nvoid UMassAgentComponent::MakePuppetAReplicatedOrphan()\n{\n\tcheckf(IsNetSimulating(), TEXT(\"Expecting a replicated pupet\"));\n\n\tSwitchToState(EAgentComponentState::PuppetReplicatedOrphan);\n}\n\nvoid UMassAgentComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tFDoRepLifetimeParams SharedParams;\n\tDOREPLIFETIME_WITH_PARAMS_FAST(UMassAgentComponent, NetID, SharedParams);\n}\n\nvoid UMassAgentComponent::OnRep_NetID()\n{\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\tif (UMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(GetWorld()))\n\t{\n\t\tAgentSubsystem->NotifyMassAgentComponentReplicated(*this);\n\t}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n}\n",
      "lines": 551
    },
    {
      "file_path": "MassGameplay\\MassActors\\Private\\MassAgentSubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 17590,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassAgentSubsystem.h\"\n#include \"MassCommandBuffer.h\"\n#include \"Engine/World.h\"\n#include \"MassEntityManager.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassSimulationSubsystem.h\"\n#include \"MassSpawnerSubsystem.h\"\n#include \"MassActorTypes.h\"\n#include \"MassAgentComponent.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassEntityView.h\"\n#include \"MassReplicationSubsystem.h\"\n#include \"Engine/NetDriver.h\"\n#include \"MassEntityUtils.h\"\n\n\nnamespace FMassAgentSubsystemHelper\n{\n\ninline void InitializeAgentComponentFragments(const UMassAgentComponent& AgentComp, FMassEntityView& EntityView, const EMassTranslationDirection Direction\n\t, TConstArrayView<FMassEntityTemplateData::FObjectFragmentInitializerFunction> ObjectFragmentInitializers)\n{\n\tAActor* Owner = AgentComp.GetOwner();\n\tcheck(Owner);\n\tfor (const FMassEntityTemplateData::FObjectFragmentInitializerFunction& Initializer : ObjectFragmentInitializers)\n\t{\n\t\tInitializer(*Owner, EntityView, Direction);\n\t}\n}\n\n}\n\n//----------------------------------------------------------------------//\n// UMassAgentSubsystem \n//----------------------------------------------------------------------//\nvoid UMassAgentSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tSuper::Initialize(Collection);\n\n\t// making sure UMassSimulationSubsystem gets created before the MassAgentSubsystem\n\tCollection.InitializeDependency<UMassSimulationSubsystem>();\n\tCollection.InitializeDependency<UMassSpawnerSubsystem>();\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\tCollection.InitializeDependency<UMassReplicationSubsystem>();\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\t\n\tUWorld* World = GetWorld();\n\tcheck(World);\n\n\tEntityManager = UE::Mass::Utils::GetEntityManagerChecked(*World).AsShared();\n\n\tSpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(World);\n\n\tSimulationSystem = UWorld::GetSubsystem<UMassSimulationSubsystem>(World);\n\tSimulationSystem->GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).AddUObject(this, &UMassAgentSubsystem::OnProcessingPhaseStarted, EMassProcessingPhase::PrePhysics);\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\tReplicationSubsystem = UWorld::GetSubsystem<UMassReplicationSubsystem>(World);\n\tcheck(ReplicationSubsystem);\n\n\tReplicationSubsystem->GetOnMassAgentAdded().AddUObject(this, &UMassAgentSubsystem::OnMassAgentAddedToReplication);\n\tReplicationSubsystem->GetOnRemovingMassAgent().AddUObject(this, &UMassAgentSubsystem::OnMassAgentRemovedFromReplication);\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n}\n\nvoid UMassAgentSubsystem::Deinitialize()\n{\n\tEntityManager.Reset();\n\tSuper::Deinitialize();\n}\n\nFMassEntityTemplateID UMassAgentSubsystem::RegisterAgentComponent(UMassAgentComponent& AgentComp)\n{\n\tcheck(EntityManager);\n\tcheck(SpawnerSystem);\n\n\tif (AgentComp.IsPuppet())\n\t{\n\t\tMakePuppet(AgentComp);\n\t\treturn AgentComp.GetTemplateID();\n\t}\n\n\t// @todo note that this will happen when a regular actor with AgentComp gets unregister and then registered again.\n\tif (AgentComp.GetTemplateID().IsValid())\n\t{\n\t\tUE_VLOG_UELOG(this, LogMassActor, Warning, TEXT(\"UMassAgentSubsystem::RegisterAgentComponent called while the given agent component has already been registered (Owner: %s, entity handle %s, template ID %s)\")\n\t\t\t, *GetNameSafe(AgentComp.GetOwner()), *AgentComp.GetEntityHandle().DebugGetDescription(), *AgentComp.GetTemplateID().ToString());\n\t\treturn FMassEntityTemplateID();\n\t}\n\n\tAActor* AgentActor = AgentComp.GetOwner();\n\tcheck(AgentActor);\n\tUWorld* World = AgentActor->GetWorld();\n\tcheck(World);\n\n\tconst FMassEntityConfig& EntityConfig = AgentComp.GetEntityConfig();\n\tconst FMassEntityTemplate& EntityTemplate = EntityConfig.GetOrCreateEntityTemplate(*World);\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\tif (AgentComp.IsNetSimulating())\n\t{\n\t\tAgentComp.PuppetReplicationPending();\n\t}\n\telse\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\t{\n\t\tFMassAgentInitializationQueue& AgentQueue = PendingAgentEntities.FindOrAdd(EntityTemplate.GetTemplateID());\n\t\t// Agent already in the queue! Earlier conditions should have failed or data is inconsistent.\n\t\tcheck(AgentQueue.AgentComponents.Find(&AgentComp) == INDEX_NONE);\n\t\tAgentQueue.AgentComponents.Add(&AgentComp);\n\n\t\tUE_VLOG(this, LogMassActor, Verbose, TEXT(\"%s registered and PENDING entity creation.\"), *AgentActor->GetName());\n   \t\tAgentComp.EntityCreationPending();\n\t}\n\n\treturn EntityTemplate.GetTemplateID();\n}\n\nvoid UMassAgentSubsystem::UpdateAgentComponent(const UMassAgentComponent& AgentComp)\n{\n\tcheck(EntityManager);\n\tcheck(SpawnerSystem)\n\n\tif (!ensureMsgf(AgentComp.GetEntityHandle().IsValid(), TEXT(\"Caling %s is valid only for already registered MassAgentComponents\"), ANSI_TO_TCHAR(__FUNCTION__)))\n\t{\n\t\tUE_VLOG(this, LogMassActor, Warning, TEXT(\"%s: called while the given agent component has not been registered yet (Owner: %s)\")\n\t\t\t, ANSI_TO_TCHAR(__FUNCTION__), *GetNameSafe(AgentComp.GetOwner()));\n\t\treturn;\n\t}\n\n\tAActor* AgentActor = AgentComp.GetOwner();\n\tcheck(AgentActor);\n\tUWorld* World = AgentActor->GetWorld();\n\tcheck(World);\n\n\tconst FMassEntityConfig& EntityConfig = AgentComp.GetEntityConfig();\n\tconst FMassEntityTemplate& EntityTemplate = EntityConfig.GetOrCreateEntityTemplate(*World);\n\n\tconst FMassEntityHandle Entity = AgentComp.GetEntityHandle();\n\tconst FMassArchetypeHandle CurrentArchetypeHandle = EntityManager->GetArchetypeForEntity(Entity);\n\tif (CurrentArchetypeHandle == EntityTemplate.GetArchetype())\n\t{\n\t\tUE_VLOG(this, LogMassActor, Log, TEXT(\"%s called for %s but no archetype changes have been found\")\n\t\t\t, ANSI_TO_TCHAR(__FUNCTION__), *AgentActor->GetName());\n\t}\n\telse\n\t{\n\t\t// the tricky case: we want to move the entity over to the new archetype and initialize its fragments, \n\t\t// but only the ones that the previous archetype didn't have - \"delta initialize\"\n\t\tensureMsgf(false, TEXT(\"Not implemented yet\"));\n\t\t\t\n\t\t// @todo add override flag so that we always initialize a new when moving between archetypes\n\t}\n\n\tcheck(AgentComp.GetEntityHandle().IsValid());\n}\n\nvoid UMassAgentSubsystem::UnregisterAgentComponent(UMassAgentComponent& AgentComp)\n{\n\tif (!EntityManager || SpawnerSystem == nullptr || SimulationSystem == nullptr)\n\t{\n\t\treturn;\n\t}\n\n\tif (AgentComp.IsPuppet())\n\t{\n\t\tif (AgentComp.IsPuppetPendingInitialization())\n\t\t{\n\t\t\tFMassAgentInitializationQueue* PuppetQueue = PendingPuppets.Find(AgentComp.GetTemplateID());\n\t\t\n\t\t\tif (ensureMsgf(PuppetQueue, TEXT(\"Trying to remove a puppet's agent component from initialization queue but there's no such queue\")))\n\t\t\t{\n\t\t\t\tensureMsgf(PuppetQueue->AgentComponents.Remove(&AgentComp), TEXT(\"Trying to remove a puppet's agent component from initialization queue while it's not in the queue\"));\n\t\t\t}\n\t\t\tAgentComp.PuppetInitializationAborted();\n\t\t}\n\t\telse if (ensureMsgf(AgentComp.GetEntityHandle().IsValid(), TEXT(\"Trying to unregister a puppet's agent component while it's neither pending initialization nor having a valid entity handle\")) )\n\t\t{\n\t\t\tif (AgentComp.GetPuppetSpecificAddition().IsEmpty() == false)\n\t\t\t{\n\t\t\t\tconst FMassEntityHandle Entity = AgentComp.GetEntityHandle();\n\n\t\t\t    // remove fragments that have been added for the puppet agent\n\t\t\t    if (EntityManager->IsProcessing())\n\t\t\t    {\n\t\t\t\t    // need to request via command buffer since we can't move entities while processing is happening\n\t\t\t\t\tFMassArchetypeCompositionDescriptor Composition = AgentComp.GetPuppetSpecificAddition();\n\t\t\t\t\tEntityManager->Defer().PushCommand<FMassDeferredRemoveCommand>([Entity, Composition](FMassEntityManager& System)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (System.IsEntityValid(Entity) == false)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tSystem.RemoveCompositionFromEntity(Entity, Composition);\n\t\t\t\t\t\t});\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t\tEntityManager->RemoveCompositionFromEntity(Entity, AgentComp.GetPuppetSpecificAddition());\n\t\t\t    }\n\t\t\t}\n\t\t\tAgentComp.PuppetUnregistrationDone();\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (AgentComp.GetEntityHandle().IsValid())\n\t\t{\n\t\t\t// the entity has already been created. Destroy!\n\t\t\tconst FMassEntityTemplate* EntityTemplate = nullptr;\n\t\t\tAActor* AgentActor = AgentComp.GetOwner();\n\t\t\tUWorld* World = AgentActor ? AgentActor->GetWorld() : nullptr;\n\t\t\tif (ensure(World))\n\t\t\t{\n\t\t\t\tconst FMassEntityConfig& EntityConfig = AgentComp.GetEntityConfig();\n\t\t\t\tEntityTemplate = &EntityConfig.GetEntityTemplateChecked(*World);\n\t\t\t}\n\n\t\t\tFMassEntityHandle Entity = AgentComp.GetEntityHandle();\n\t\t\t// Clearing the entity before it become invalid as the clear contains notifications\n\t\t\tAgentComp.ClearEntityHandle();\n\n\t\t\t// Destroy the entity\n\t\t\tif (EntityManager->IsProcessing())\n\t\t\t{\n\t\t\t\t// need to request via command buffer since we can't move entities while processing is happening\n\t\t\t\tEntityManager->Defer().DestroyEntity(Entity);\n\t\t\t}\n\t\t\telse if (ensure(EntityTemplate))\n\t\t\t{\n\t\t\t\tSpawnerSystem->DestroyEntities(TArrayView<FMassEntityHandle>(&Entity, 1));\n\t\t\t}\n\t\t}\n\t\telse if (AgentComp.IsEntityPendingCreation())\n\t\t{\n\t\t\t// hasn't been registered yet. Just remove it from the queue\t\t\n\t\t\tFMassAgentInitializationQueue* AgentQueue = PendingAgentEntities.Find(AgentComp.GetTemplateID());\n\t\t\tif (ensureMsgf(AgentQueue, TEXT(\"Trying to remove an agent component from initialization queue but there's no such queue\")))\n\t\t\t{\n\t\t\t\tensureMsgf(AgentQueue->AgentComponents.Remove(&AgentComp), TEXT(\"Trying to remove an agent component from initialization queue it's missing from the queue\"));\n\t\t\t}\n\t\t\tAgentComp.EntityCreationAborted();\n\t\t}\n\t}\n}\n\nvoid UMassAgentSubsystem::ShutdownAgentComponent(UMassAgentComponent& AgentComp)\n{\n\tUnregisterAgentComponent(AgentComp);\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\tReplicatedAgentComponents.Remove(AgentComp.GetNetID());\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n}\n\nvoid UMassAgentSubsystem::MakePuppet(UMassAgentComponent& AgentComp)\n{\n\tif (!ensureMsgf(AgentComp.GetTemplateID().IsValid(), TEXT(\"%s tried to used %s as puppet but it doesn't have a valid entity template ID\"), ANSI_TO_TCHAR(__FUNCTION__), *GetNameSafe(AgentComp.GetOwner())))\n\t{\n\t\treturn;\n\t}\n\t\t\n\tif (AgentComp.IsEntityPendingCreation())\n\t{\n\t\tFMassAgentInitializationQueue* AgentQueue = PendingAgentEntities.Find(AgentComp.GetTemplateID());\n\t\tif (ensureMsgf(AgentQueue, TEXT(\"Trying to remove an agent component from initialization queue but there's no such queue\")))\n\t\t{\n\t\t\tensureMsgf(AgentQueue->AgentComponents.Remove(&AgentComp), TEXT(\"Trying to remove an agent component from initialization queue it's missing from the queue\"));\n\t\t}\n\t}\n\n\tFMassAgentInitializationQueue& PuppetQueue = PendingPuppets.FindOrAdd(AgentComp.GetTemplateID());\n\t// Agent already in the queue! Earlier conditions should have failed or data is inconsistent.\n\tcheck(PuppetQueue.AgentComponents.Find(&AgentComp) == INDEX_NONE);\n\tPuppetQueue.AgentComponents.Add(&AgentComp);\n\n\tAgentComp.PuppetInitializationPending();\n}\n\nvoid UMassAgentSubsystem::OnProcessingPhaseStarted(const float DeltaSeconds, const EMassProcessingPhase Phase)\n{\n\tswitch (Phase)\n\t{\n\tcase EMassProcessingPhase::PrePhysics:\n\t\t// initialize what needs initialization\n\t\tif (PendingAgentEntities.Num() > 0 || PendingPuppets.Num() > 0)\n\t\t{\n\t\t\tHandlePendingInitialization();\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t// unhandled phases, by design, not every phase needs to be handled by the Actor subsystem\n\t\tbreak;\n\t}\n}\n\nvoid UMassAgentSubsystem::HandlePendingInitialization()\n{\n\tcheck(EntityManager);\n\tcheck(SpawnerSystem);\n\tcheck(SimulationSystem);\n\tcheck(SimulationSystem->IsDuringMassProcessing() == false);\n\n\tfor (TTuple<FMassEntityTemplateID, FMassAgentInitializationQueue>& Data : PendingAgentEntities)\n\t{\n\t\tconst FMassEntityTemplateID EntityTemplateID = Data.Get<0>();\n\t\tconst TSharedRef<FMassEntityTemplate>* EntityTemplatePtr = SpawnerSystem->GetTemplateRegistryInstance().FindTemplateFromTemplateID(EntityTemplateID);\n\t\tcheck(EntityTemplatePtr);\n\t\tconst FMassEntityTemplate& EntityTemplate = EntityTemplatePtr->Get();\n\t\t\n\t\tTArray<TObjectPtr<UMassAgentComponent>>& AgentComponents = Data.Get<1>().AgentComponents;\n\t\tconst int32 NewEntityCount = AgentComponents.Num();\n\t\t\n\t\tif (NewEntityCount <= 0)\n\t\t{\n\t\t\t// this case is perfectly fine, all agents registered and unregistered before we processed the queue\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tTArray<FMassEntityHandle> Entities;\n\t\tSpawnerSystem->SpawnEntities(EntityTemplate, NewEntityCount, Entities);\n\t\tcheck(Entities.Num() == NewEntityCount);\n\n\t\tif (EntityTemplate.GetObjectFragmentInitializers().Num())\n\t\t{\n\t\t\tconst TConstArrayView<FMassEntityTemplateData::FObjectFragmentInitializerFunction> ObjectFragmentInitializers = EntityTemplate.GetObjectFragmentInitializers();\n\n\t\t\tfor (int AgentIndex = 0; AgentIndex < Entities.Num(); ++AgentIndex)\n\t\t\t{\n\t\t\t\tFMassEntityView EntityView(EntityTemplate.GetArchetype(), Entities[AgentIndex]);\n\t\t\t\tFMassAgentSubsystemHelper::InitializeAgentComponentFragments(*AgentComponents[AgentIndex], EntityView, EMassTranslationDirection::ActorToMass, ObjectFragmentInitializers);\n\t\t\t}\n\t\t}\n\n\t\tfor (int AgentIndex = 0; AgentIndex < Entities.Num(); ++AgentIndex)\n\t\t{\t\t\n\t\t\tAgentComponents[AgentIndex]->SetEntityHandle(Entities[AgentIndex]);\n\t\t}\n\t}\n\n\tPendingAgentEntities.Reset();\n\n\tfor (TTuple<FMassEntityTemplateID, FMassAgentInitializationQueue>& Data : PendingPuppets)\n\t{\n\t\tconst FMassEntityTemplateID EntityTemplateID = Data.Get<0>();\n\t\tconst TSharedRef<FMassEntityTemplate>* EntityTemplatePtr = SpawnerSystem->GetTemplateRegistryInstance().FindTemplateFromTemplateID(EntityTemplateID);\n\n\t\tif (!ensure(EntityTemplatePtr))\n\t\t{\n\t\t\t// note that this condition is temporary, we'll be switched to a `check` once we set up characters\n\t\t\tcontinue;\n\t\t}\n\t\tconst FMassEntityTemplate& EntityTemplate = EntityTemplatePtr->Get();\n\n\t\tconst FMassArchetypeCompositionDescriptor TemplateDescriptor = EntityTemplate.GetCompositionDescriptor();\n\n\t\tTArray<TObjectPtr<UMassAgentComponent>>& AgentComponents = Data.Get<1>().AgentComponents;\n\n\t\tfor (UMassAgentComponent* AgentComp : AgentComponents)\n\t\t{\n\t\t\tconst FMassEntityHandle PuppetEntity = AgentComp->GetEntityHandle();\n\t\t\tif (!ensureMsgf(PuppetEntity.IsSet(), TEXT(\"Trying to initialize puppet's fragments while the pupped doesn't have a corresponding Entity identifier set. This should not happen.\")))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFMassArchetypeCompositionDescriptor& PuppetDescriptor = AgentComp->GetMutablePuppetSpecificAddition();\n\t\t\tPuppetDescriptor = TemplateDescriptor;\n\t\t\tEntityManager->AddCompositionToEntity_GetDelta(PuppetEntity, PuppetDescriptor);\n\t\t\t\n\t\t\tif (EntityTemplate.GetObjectFragmentInitializers().Num())\n\t\t\t{\n\t\t\t\tconst FMassArchetypeHandle ArchetypeHandle = EntityManager->GetArchetypeForEntity(PuppetEntity);\n\t\t\t\tFMassEntityView EntityView(ArchetypeHandle, PuppetEntity);\n\t\t\t\tFMassAgentSubsystemHelper::InitializeAgentComponentFragments(*AgentComp, EntityView, EMassTranslationDirection::MassToActor, EntityTemplate.GetObjectFragmentInitializers());\n\t\t\t}\n\n\t\t\tAgentComp->PuppetInitializationDone();\n\t\t}\n\t}\n\n\tPendingPuppets.Reset();\n}\n\nvoid UMassAgentSubsystem::NotifyMassAgentComponentReplicated(UMassAgentComponent& AgentComp)\n{\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\tUWorld* World = GetWorld();\n\tif (World && ensureMsgf(World->IsNetMode(NM_Client), TEXT(\"%s: Expecting to only be called in network game on the client\"), ANSI_TO_TCHAR(__FUNCTION__)))\n\t{\n\t\tcheck(ReplicationSubsystem);\n\t\tcheck(AgentComp.GetNetID().IsValid());\n\t\tcheck(!ReplicatedAgentComponents.Find(AgentComp.GetNetID()));\n\t\tReplicatedAgentComponents.Add(AgentComp.GetNetID(), &AgentComp);\n\t\tconst FMassEntityHandle Entity = ReplicationSubsystem->FindEntity(AgentComp.GetNetID());\n\n\t\t// If not found, the NotifyMassAgentAddedToReplication will link it later once replicated.\n\t\tif (Entity.IsSet())\n\t\t{\n\t\t\tAgentComp.SetReplicatedPuppetHandle(FMassEntityHandle(Entity));\n\t\t\tMakePuppet(AgentComp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tAgentComp.MakePuppetAReplicatedOrphan();\n\t\t}\n\t}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n}\n\nvoid UMassAgentSubsystem::NotifyMassAgentComponentEntityAssociated(const UMassAgentComponent& AgentComp) const\n{\n\tOnMassAgentComponentEntityAssociated.Broadcast(AgentComp);\n}\n\nvoid UMassAgentSubsystem::NotifyMassAgentComponentEntityDetaching(const UMassAgentComponent& AgentComp) const\n{\n\tOnMassAgentComponentEntityDetaching.Broadcast(AgentComp);\n}\n\nvoid UMassAgentSubsystem::OnMassAgentAddedToReplication(FMassNetworkID NetID, FMassEntityHandle Entity)\n{\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\tUWorld* World = GetWorld();\n\tif (World && World->IsNetMode(NM_Client))\n\t{\n\t\tif (TObjectPtr<UMassAgentComponent>* AgentComp = ReplicatedAgentComponents.Find(NetID))\n\t\t{\n\t\t\t(*AgentComp)->SetReplicatedPuppetHandle(FMassEntityHandle(Entity));\n\t\t\tMakePuppet(**AgentComp);\n\t\t}\n\t}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n}\n\nvoid UMassAgentSubsystem::OnMassAgentRemovedFromReplication(FMassNetworkID NetID, FMassEntityHandle Entity)\n{\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\n\tUWorld* World = GetWorld();\n\tif (World && World->IsNetMode(NM_Client))\n\t{\n\t\tif (TObjectPtr<UMassAgentComponent>* AgentComp = ReplicatedAgentComponents.Find(NetID))\n\t\t{\n\t\t\tUnregisterAgentComponent(**AgentComp);\n\t\t\t(*AgentComp)->ClearReplicatedPuppetHandle();\n\t\t}\n\t}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n}\n",
      "lines": 453
    },
    {
      "file_path": "MassGameplay\\MassActors\\Private\\MassAgentTraits.cpp",
      "extension": ".cpp",
      "size_bytes": 8019,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassAgentTraits.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassEntityTemplate.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"Translators/MassCapsuleComponentTranslators.h\"\n#include \"Translators/MassCharacterMovementTranslators.h\"\n#include \"Translators/MassSceneComponentLocationTranslator.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassEntityView.h\"\n\nnamespace FMassAgentTraitsHelper \n{\n\ttemplate<typename T>\n\tT* AsComponent(UObject& Owner)\n\t{\n\t\tT* Component = nullptr;\n\t\tif (AActor* AsActor = Cast<AActor>(&Owner))\n\t\t{\n\t\t\tComponent = AsActor->FindComponentByClass<T>();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tComponent = Cast<T>(&Owner);\n\t\t}\n\n\t\tUE_CVLOG_UELOG(Component == nullptr, &Owner, LogMass, Error, TEXT(\"Trying to extract %s from %s failed\")\n\t\t\t, *T::StaticClass()->GetName(), *Owner.GetName());\n\n\t\treturn Component;\n\t}\n}\n\n//----------------------------------------------------------------------//\n//  UMassAgentCapsuleCollisionSyncTrait\n//----------------------------------------------------------------------//\nvoid UMassAgentCapsuleCollisionSyncTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tBuildContext.AddFragment<FCapsuleComponentWrapperFragment>();\n\tBuildContext.AddFragment<FAgentRadiusFragment>();\n\tif (bSyncTransform || BuildContext.IsInspectingData())\n\t{\n\t\tBuildContext.AddFragment<FTransformFragment>();\n\t}\n\t\n\tBuildContext.GetMutableObjectFragmentInitializers().Add([this](UObject& Owner, FMassEntityView& EntityView, const EMassTranslationDirection CurrentDirection)\n\t\t{\n\t\t\tif (UCapsuleComponent* CapsuleComponent = FMassAgentTraitsHelper::AsComponent<UCapsuleComponent>(Owner))\n\t\t\t{\n\t\t\t\tFCapsuleComponentWrapperFragment& CapsuleFragment = EntityView.GetFragmentData<FCapsuleComponentWrapperFragment>();\n\t\t\t\tCapsuleFragment.Component = CapsuleComponent;\n\n\t\t\t\tFAgentRadiusFragment& RadiusFragment = EntityView.GetFragmentData<FAgentRadiusFragment>();\n\t\t\t\tRadiusFragment.Radius = CapsuleComponent->GetScaledCapsuleRadius();\n\n\t\t\t\tif (bSyncTransform)\n\t\t\t\t{\n\t\t\t\t\tFTransformFragment& TransformFragment = EntityView.GetFragmentData<FTransformFragment>();\n\t\t\t\t\tTransformFragment.GetMutableTransform() = CapsuleComponent->GetComponentTransform();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\tif (bSyncTransform || BuildContext.IsInspectingData())\n\t{\n\t\tif (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::ActorToMass) || BuildContext.IsInspectingData())\n\t\t{\n\t\t\tBuildContext.AddTranslator<UMassCapsuleTransformToMassTranslator>();\n\t\t}\n\n\t\tif (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::MassToActor) || BuildContext.IsInspectingData())\n\t\t{\n\t\t\tBuildContext.AddTranslator<UMassTransformToActorCapsuleTranslator>();\n\t\t}\n\t}\n}\n\n//----------------------------------------------------------------------//\n//  UMassAgentMovementSyncTrait\n//----------------------------------------------------------------------//\nvoid UMassAgentMovementSyncTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tBuildContext.AddFragment<FCharacterMovementComponentWrapperFragment>();\n\tBuildContext.AddFragment<FMassVelocityFragment>();\n\t\n\tBuildContext.GetMutableObjectFragmentInitializers().Add([=](UObject& Owner, FMassEntityView& EntityView, const EMassTranslationDirection CurrentDirection)\n\t\t{\n\t\t\tif (UCharacterMovementComponent* MovementComp = FMassAgentTraitsHelper::AsComponent<UCharacterMovementComponent>(Owner))\n\t\t\t{\n\t\t\t\tFCharacterMovementComponentWrapperFragment& ComponentFragment = EntityView.GetFragmentData<FCharacterMovementComponentWrapperFragment>();\n\t\t\t\tComponentFragment.Component = MovementComp;\n\n\t\t\t\tFMassVelocityFragment& VelocityFragment = EntityView.GetFragmentData<FMassVelocityFragment>();\n\n\t\t\t\t// the entity is the authority\n\t\t\t\tif (CurrentDirection ==  EMassTranslationDirection::MassToActor)\n\t\t\t\t{\n\t\t\t\t\tMovementComp->bRunPhysicsWithNoController = true;\n\t\t\t\t\tMovementComp->SetMovementMode(EMovementMode::MOVE_Walking);\n\t\t\t\t\tMovementComp->Velocity = VelocityFragment.Value;\n\t\t\t\t}\n\t\t\t\t// actor is the authority\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tVelocityFragment.Value = MovementComp->GetLastUpdateVelocity();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\tif (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::ActorToMass) || BuildContext.IsInspectingData())\n\t{\n\t\tBuildContext.AddTranslator<UMassCharacterMovementToMassTranslator>();\n\t}\n\n\tif (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::MassToActor) || BuildContext.IsInspectingData())\n\t{\n\t\tBuildContext.AddTranslator<UMassCharacterMovementToActorTranslator>();\n\t}\n}\n\n//----------------------------------------------------------------------//\n//  UMassAgentOrientationSyncTrait\n//----------------------------------------------------------------------//\nvoid UMassAgentOrientationSyncTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tBuildContext.RequireFragment<FCharacterMovementComponentWrapperFragment>();\n\n\tif (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::ActorToMass) \n\t\t|| BuildContext.IsInspectingData())\n\t{\n\t\tBuildContext.AddTranslator<UMassCharacterOrientationToMassTranslator>();\n\t}\n\n\tif (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::MassToActor)\n\t\t|| BuildContext.IsInspectingData())\n\t{\n\t\tBuildContext.AddTranslator<UMassCharacterOrientationToActorTranslator>();\n\t}\n}\n\n//----------------------------------------------------------------------//\n//  UMassAgentFeetLocationSyncTrait\n//----------------------------------------------------------------------//\nvoid UMassAgentFeetLocationSyncTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tBuildContext.AddFragment<FMassSceneComponentWrapperFragment>();\n\tBuildContext.AddFragment<FTransformFragment>();\n\n\tBuildContext.GetMutableObjectFragmentInitializers().Add([=](UObject& Owner, FMassEntityView& EntityView, const EMassTranslationDirection CurrentDirection)\n\t\t{\n\t\t\tAActor* AsActor = Cast<AActor>(&Owner);\n\t\t\tif (AsActor && AsActor->GetRootComponent())\n\t\t\t{\n\t\t\t\tUSceneComponent* Component = AsActor->GetRootComponent();\n\t\t\t\tFMassSceneComponentWrapperFragment& ComponentFragment = EntityView.GetFragmentData<FMassSceneComponentWrapperFragment>();\n\t\t\t\tComponentFragment.Component = Component;\n\n\t\t\t\tFTransformFragment& TransformFragment = EntityView.GetFragmentData<FTransformFragment>();\n\n\t\t\t\tREDIRECT_OBJECT_TO_VLOG(Component, &Owner);\n\t\t\t\tUE_VLOG_LOCATION(&Owner, LogMass, Log, Component->GetComponentLocation(), 30, FColor::Yellow, TEXT(\"Initial component location\"));\n\t\t\t\tUE_VLOG_LOCATION(&Owner, LogMass, Log, TransformFragment.GetTransform().GetLocation(), 30, FColor::Red, TEXT(\"Initial entity location\"));\n\n\t\t\t\t// the entity is the authority\n\t\t\t\tif (CurrentDirection == EMassTranslationDirection::MassToActor)\n\t\t\t\t{\n\t\t\t\t\t// Temporary disabling this as it is already done earlier in the MassRepresentation and we needed to do a sweep to find the floor\n\t\t\t\t\t//Component->SetWorldLocation(FeetLocation, /*bSweep*/true, nullptr, ETeleportType::TeleportPhysics);\n\t\t\t\t}\n\t\t\t\t// actor is the authority\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tTransformFragment.GetMutableTransform().SetLocation(Component->GetComponentTransform().GetLocation() - FVector(0.f, 0.f, Component->Bounds.BoxExtent.Z));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\tif (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::ActorToMass)\n\t\t|| BuildContext.IsInspectingData())\n\t{\n\t\tBuildContext.AddTranslator<UMassSceneComponentLocationToMassTranslator>();\n\t}\n\n\tif (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::MassToActor)\n\t\t|| BuildContext.IsInspectingData())\n\t{\n\t\tBuildContext.AddTranslator<UMassSceneComponentLocationToActorTranslator>();\n\t}\n}\n\n",
      "lines": 195
    },
    {
      "file_path": "MassGameplay\\MassActors\\Private\\Translators\\MassCapsuleComponentTranslators.cpp",
      "extension": ".cpp",
      "size_bytes": 3564,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Translators/MassCapsuleComponentTranslators.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassEntityManager.h\"\n#include \"MassExecutionContext.h\"\n#include \"Components/CapsuleComponent.h\"\n\n\n//----------------------------------------------------------------------//\n// UMassCapsuleTransformToMassTranslator\n//----------------------------------------------------------------------//\nUMassCapsuleTransformToMassTranslator::UMassCapsuleTransformToMassTranslator()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tRequiredTags.Add<FMassCapsuleTransformCopyToMassTag>();\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::SyncWorldToMass;\n}\n\nvoid UMassCapsuleTransformToMassTranslator::ConfigureQueries()\n{\n\tAddRequiredTagsToQuery(EntityQuery);\n\tEntityQuery.AddRequirement<FCapsuleComponentWrapperFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassCapsuleTransformToMassTranslator::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t\t{\n\t\t\tconst TConstArrayView<FCapsuleComponentWrapperFragment> CapsuleComponentList = Context.GetFragmentView<FCapsuleComponentWrapperFragment>();\n\t\t\tconst TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();\n\t\t\tfor (int i = 0; i < CapsuleComponentList.Num(); ++i)\n\t\t\t{\n\t\t\t\tif (const UCapsuleComponent* CapsuleComp = CapsuleComponentList[i].Component.Get())\n\t\t\t\t{\n\t\t\t\t\tLocationList[i].GetMutableTransform() = CapsuleComp->GetComponentTransform();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n}\n\n//----------------------------------------------------------------------//\n// UMassTransformToActorCapsuleTranslator\n//----------------------------------------------------------------------//\nUMassTransformToActorCapsuleTranslator::UMassTransformToActorCapsuleTranslator()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tRequiredTags.Add<FMassCapsuleTransformCopyToActorTag>();\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::UpdateWorldFromMass;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Movement);\n\tbRequiresGameThreadExecution = true;\n}\n\nvoid UMassTransformToActorCapsuleTranslator::ConfigureQueries()\n{\n\tAddRequiredTagsToQuery(EntityQuery);\n\tEntityQuery.AddRequirement<FCapsuleComponentWrapperFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.RequireMutatingWorldAccess(); // due to mutating World by setting component transform\n}\n\nvoid UMassTransformToActorCapsuleTranslator::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t\t{\n\t\t\tconst TArrayView<FCapsuleComponentWrapperFragment> CapsuleComponentList = Context.GetMutableFragmentView<FCapsuleComponentWrapperFragment>();\n\t\t\tconst TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\t\t\tfor (int i = 0; i < CapsuleComponentList.Num(); ++i)\n\t\t\t{\n\t\t\t\tif (UCapsuleComponent* CapsuleComp = CapsuleComponentList[i].Component.Get())\n\t\t\t\t{\n\t\t\t\t\tCapsuleComp->SetWorldTransform(LocationList[i].GetTransform(), /*bSweep=*/false);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n}\n",
      "lines": 79
    },
    {
      "file_path": "MassGameplay\\MassActors\\Private\\Translators\\MassCharacterMovementTranslators.cpp",
      "extension": ".cpp",
      "size_bytes": 7989,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Translators/MassCharacterMovementTranslators.h\"\n#include \"Logging/LogMacros.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassEntityManager.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassSpawnerTypes.h\"\n\n//----------------------------------------------------------------------//\n//  UMassCharacterMovementToMassTranslator\n//----------------------------------------------------------------------//\nUMassCharacterMovementToMassTranslator::UMassCharacterMovementToMassTranslator()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::SyncWorldToMass;\n\tRequiredTags.Add<FMassCharacterMovementCopyToMassTag>();\n\tbRequiresGameThreadExecution = true;\n}\n\nvoid UMassCharacterMovementToMassTranslator::ConfigureQueries()\n{\n\tAddRequiredTagsToQuery(EntityQuery);\n\tEntityQuery.AddRequirement<FCharacterMovementComponentWrapperFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassCharacterMovementToMassTranslator::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tconst TConstArrayView<FCharacterMovementComponentWrapperFragment> ComponentList = Context.GetFragmentView<FCharacterMovementComponentWrapperFragment>();\n\t\tconst TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();\n\t\tconst TArrayView<FMassVelocityFragment> VelocityList = Context.GetMutableFragmentView<FMassVelocityFragment>();\n\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\n\t\tfor (int32 i = 0; i < NumEntities; ++i)\n\t\t{\n\t\t\tif (const UCharacterMovementComponent* AsMovementComponent = ComponentList[i].Component.Get())\n\t\t\t{\n\t\t\t\tLocationList[i].GetMutableTransform().SetLocation(AsMovementComponent->GetActorNavLocation());\n\t\t\t\t\n\t\t\t\tVelocityList[i].Value = AsMovementComponent->Velocity;\n\t\t\t}\n\t\t}\n\t});\n}\n\n//----------------------------------------------------------------------//\n//  UMassCharacterMovementToActorTranslator\n//----------------------------------------------------------------------//\nUMassCharacterMovementToActorTranslator::UMassCharacterMovementToActorTranslator()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::UpdateWorldFromMass;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Movement);\n\tRequiredTags.Add<FMassCharacterMovementCopyToActorTag>();\n\tbRequiresGameThreadExecution = true;\n}\n\nvoid UMassCharacterMovementToActorTranslator::ConfigureQueries()\n{\n\tAddRequiredTagsToQuery(EntityQuery);\n\tEntityQuery.AddRequirement<FCharacterMovementComponentWrapperFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadOnly);\n}\n\nvoid UMassCharacterMovementToActorTranslator::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tconst TArrayView<FCharacterMovementComponentWrapperFragment> ComponentList = Context.GetMutableFragmentView<FCharacterMovementComponentWrapperFragment>();\n\t\tconst TConstArrayView<FMassVelocityFragment> VelocityList = Context.GetFragmentView<FMassVelocityFragment>();\n\t\t\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\n\t\tfor (int32 i = 0; i < NumEntities; ++i)\n\t\t{\n\t\t\tif (UCharacterMovementComponent* AsMovementComponent = ComponentList[i].Component.Get())\n\t\t\t{\n\t\t\t\tAsMovementComponent->RequestDirectMove(VelocityList[i].Value, /*bForceMaxSpeed=*/false);\n\t\t\t}\n\t\t}\n\t});\n}\n\n//----------------------------------------------------------------------//\n//  UMassCharacterOrientationToMassTranslator\n//----------------------------------------------------------------------//\nUMassCharacterOrientationToMassTranslator::UMassCharacterOrientationToMassTranslator()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::SyncWorldToMass;\n\tRequiredTags.Add<FMassCharacterOrientationCopyToMassTag>();\n\tbRequiresGameThreadExecution = true;\n}\n\nvoid UMassCharacterOrientationToMassTranslator::ConfigureQueries()\n{\n\tAddRequiredTagsToQuery(EntityQuery);\n\tEntityQuery.AddRequirement<FCharacterMovementComponentWrapperFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassCharacterOrientationToMassTranslator::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tconst TConstArrayView<FCharacterMovementComponentWrapperFragment> ComponentList = Context.GetFragmentView<FCharacterMovementComponentWrapperFragment>();\n\t\tconst TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();\n\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\n\t\tfor (int32 i = 0; i < NumEntities; ++i)\n\t\t{\n\t\t\tif (const UCharacterMovementComponent* AsMovementComponent = ComponentList[i].Component.Get())\n\t\t\t{\n\t\t\t\tif (AsMovementComponent->UpdatedComponent != nullptr)\n\t\t\t\t{\n\t\t\t\t\tLocationList[i].GetMutableTransform().SetRotation(AsMovementComponent->UpdatedComponent->GetComponentTransform().GetRotation());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n}\n\n//----------------------------------------------------------------------//\n//  UMassCharacterOrientationToActorTranslator\n//----------------------------------------------------------------------//\nUMassCharacterOrientationToActorTranslator::UMassCharacterOrientationToActorTranslator()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::UpdateWorldFromMass;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Movement);\n\tRequiredTags.Add<FMassCharacterOrientationCopyToActorTag>();\n\tbRequiresGameThreadExecution = true;\n}\n\nvoid UMassCharacterOrientationToActorTranslator::ConfigureQueries()\n{\n\tAddRequiredTagsToQuery(EntityQuery);\n\tEntityQuery.AddRequirement<FCharacterMovementComponentWrapperFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.RequireMutatingWorldAccess(); // due to mutating World by setting component rotation\n}\n\nvoid UMassCharacterOrientationToActorTranslator::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tconst TArrayView<FCharacterMovementComponentWrapperFragment> ComponentList = Context.GetMutableFragmentView<FCharacterMovementComponentWrapperFragment>();\n\t\tconst TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();\n\t\t\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\n\t\tfor (int32 i = 0; i < NumEntities; ++i)\n\t\t{\n\t\t\tif (UCharacterMovementComponent* AsMovementComponent = ComponentList[i].Component.Get())\n\t\t\t{\n\t\t\t\tif (AsMovementComponent->UpdatedComponent != nullptr)\n\t\t\t\t{\n\t\t\t\t\tconst FTransformFragment& Transform = TransformList[i];\n\t\t\t\t\tAsMovementComponent->bOrientRotationToMovement = false;\n\t\t\t\t\tAsMovementComponent->UpdatedComponent->SetWorldRotation(Transform.GetTransform().GetRotation());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n}\n",
      "lines": 178
    },
    {
      "file_path": "MassGameplay\\MassActors\\Private\\Translators\\MassSceneComponentLocationTranslator.cpp",
      "extension": ".cpp",
      "size_bytes": 3788,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Translators/MassSceneComponentLocationTranslator.h\"\n#include \"MassCommonTypes.h\"\n#include \"Components/SceneComponent.h\"\n#include \"MassExecutionContext.h\"\n\n//----------------------------------------------------------------------//\n//  UMassSceneComponentLocationToMassTranslator\n//----------------------------------------------------------------------//\nUMassSceneComponentLocationToMassTranslator::UMassSceneComponentLocationToMassTranslator()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::SyncWorldToMass;\n\tRequiredTags.Add<FMassSceneComponentLocationCopyToMassTag>();\n}\n\nvoid UMassSceneComponentLocationToMassTranslator::ConfigureQueries()\n{\n\tAddRequiredTagsToQuery(EntityQuery);\n\tEntityQuery.AddRequirement<FMassSceneComponentWrapperFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassSceneComponentLocationToMassTranslator::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tconst TConstArrayView<FMassSceneComponentWrapperFragment> ComponentList = Context.GetFragmentView<FMassSceneComponentWrapperFragment>();\n\t\tconst TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();\n\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tfor (int32 i = 0; i < NumEntities; ++i)\n\t\t{\n\t\t\tif (const USceneComponent* AsComponent = ComponentList[i].Component.Get())\n\t\t\t{\n\t\t\t\tLocationList[i].GetMutableTransform().SetLocation(AsComponent->GetComponentTransform().GetLocation() - FVector(0.f, 0.f, AsComponent->Bounds.BoxExtent.Z));\n\t\t\t}\n\t\t}\n\t});\n}\n\n//----------------------------------------------------------------------//\n//  UMassSceneComponentLocationToActorTranslator\n//----------------------------------------------------------------------//\nUMassSceneComponentLocationToActorTranslator::UMassSceneComponentLocationToActorTranslator()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::UpdateWorldFromMass;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Movement);\n\tRequiredTags.Add<FMassSceneComponentLocationCopyToActorTag>();\n\tbRequiresGameThreadExecution = true;\n}\n\nvoid UMassSceneComponentLocationToActorTranslator::ConfigureQueries()\n{\n\tAddRequiredTagsToQuery(EntityQuery);\n\tEntityQuery.AddRequirement<FMassSceneComponentWrapperFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.RequireMutatingWorldAccess(); // due to mutating World by setting actor's location\n}\n\nvoid UMassSceneComponentLocationToActorTranslator::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t\t{\n\t\t\tconst TConstArrayView<FMassSceneComponentWrapperFragment> ComponentList = Context.GetFragmentView<FMassSceneComponentWrapperFragment>();\n\t\t\tconst TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();\n\n\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\tfor (int32 i = 0; i < NumEntities; ++i)\n\t\t\t{\n\t\t\t\tif (USceneComponent* AsComponent = ComponentList[i].Component.Get())\n\t\t\t\t{\n\t\t\t\t\tAsComponent->SetWorldLocation(LocationList[i].GetTransform().GetLocation() + FVector(0.f, 0.f, AsComponent->Bounds.BoxExtent.Z));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n}\n",
      "lines": 81
    },
    {
      "file_path": "MassGameplay\\MassActors\\Private\\Translators\\MassTranslators_BehaviorTree.cpp",
      "extension": ".cpp",
      "size_bytes": 497,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Translators/MassTranslators_BehaviorTree.h\"\n#include \"BehaviorTree/BehaviorTreeComponent.h\"\n#include \"MassEntityManager.h\"\n\nUMassTranslator_BehaviorTree::UMassTranslator_BehaviorTree()\n\t: EntityQuery(*this)\n{\n\tbAutoRegisterWithProcessingPhases = false;\n}\n\nvoid UMassTranslator_BehaviorTree::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FDataFragment_BehaviorTreeComponentWrapper>(EMassFragmentAccess::ReadWrite);\n}\n",
      "lines": 16
    },
    {
      "file_path": "MassGameplay\\MassCommon\\Private\\MassCommonModule.cpp",
      "extension": ".cpp",
      "size_bytes": 791,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CoreMinimal.h\"\n#include \"IMassCommonModule.h\"\n#include \"MassCommonTypes.h\"\n\n\nclass FMassCommonModule : public IMassCommonModule\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nIMPLEMENT_MODULE(FMassCommonModule, MassCommon)\n\n\n\nvoid FMassCommonModule::StartupModule()\n{\n\t// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)\n}\n\n\nvoid FMassCommonModule::ShutdownModule()\n{\n\t// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n\t// we call this function before unloading the module.\n}\n\n\n\n",
      "lines": 32
    },
    {
      "file_path": "MassGameplay\\MassCommon\\Private\\MassCommonTypes.cpp",
      "extension": ".cpp",
      "size_bytes": 84,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCommonTypes.h\"\n",
      "lines": 3
    },
    {
      "file_path": "MassGameplay\\MassCommon\\Private\\MassCommonUtils.cpp",
      "extension": ".cpp",
      "size_bytes": 1420,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassCommonUtils.h\"\n#include \"Misc/App.h\"\n\nnamespace UE::Mass::Private\n{\n    int32 RandomSeedOverride = 7;\n    FAutoConsoleVariableRef CVarRandomSeedOverride(\n\t\tTEXT(\"mass.RandomSeedOverride\"), \n\t\tRandomSeedOverride, \n\t\tTEXT(\"If FApp::bUseFixedSeed is true (e.g., -FixedSeed or -Deterministic) this value is used as random seed for all Mass uses.\"));\n}\n\nnamespace UE::Mass::Utils\n{\n\n\tTArray<FMassEntityHandle> EntityQueueToArray(TQueue<FMassEntityHandle, EQueueMode::Mpsc>& EntitiesQueue, const int32 EntitiesCount)\n\t{\n\t\tcheck(EntitiesCount > 0);\n\t\tTArray<FMassEntityHandle> EntitiesArray;\n\t\tEntitiesArray.AddUninitialized(EntitiesCount);\n\n\t\tFMassEntityHandle TempEntity;\n\t\tuint32 CurrentIndex = 0;\n\t\twhile (EntitiesQueue.Dequeue(TempEntity))\n\t\t{\n\t\t\tEntitiesArray[CurrentIndex++] = TempEntity;\n\t\t}\n\t\tensure(CurrentIndex == EntitiesCount);\n\n\t\treturn MoveTemp(EntitiesArray);\n\t}\n\n#if !UE_BUILD_SHIPPING\n\n\tbool IsDeterministic()\n\t{\n\t\treturn FApp::bUseFixedSeed;\n\t}\n\n\tint32 OverrideRandomSeedForTesting(int32 InSeed)\n\t{\n\t\tif (IsDeterministic())\n\t\t{\n\t\t\treturn UE::Mass::Private::RandomSeedOverride;\n\t\t}\n\t\treturn InSeed;\n\t}\n\n\tint32 GenerateRandomSeed()\n\t{\n\t\tif (IsDeterministic())\n\t\t{\n\t\t\treturn UE::Mass::Private::RandomSeedOverride;\n\t\t}\n\t\treturn FMath::Rand();\n\t}\n#endif\n\n} // namespace UE::Mass::Utils\n",
      "lines": 61
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Private\\MassEQS.cpp",
      "extension": ".cpp",
      "size_bytes": 163,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEQS.h\"\n\nDEFINE_LOG_CATEGORY(LogMassEQS);\n\nIMPLEMENT_GAME_MODULE(FMassEQSModule, MassEQS);\n",
      "lines": 7
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Private\\MassEQSBlueprintLibrary.cpp",
      "extension": ".cpp",
      "size_bytes": 4831,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEQSBlueprintLibrary.h\"\n\n#include \"MassCommonFragments.h\"\n#include \"MassSignalSubsystem.h\"\n#include \"MassEntitySubsystem.h\"\n\n#include \"Items/EnvQueryItemType_MassEntityHandle.h\"\n#include \"EnvironmentQuery/EnvQueryInstanceBlueprintWrapper.h\"\n\nUMassEQSBlueprintLibrary::UMassEQSBlueprintLibrary(const FObjectInitializer& ObjectInitializer)\n\t: UBlueprintFunctionLibrary(ObjectInitializer)\n{\n}\n\n//----------------------------------------------------------------------//\n// Commands\n//----------------------------------------------------------------------//\n\nvoid UMassEQSBlueprintLibrary::SendSignalToEntity(const AActor* Owner, const FMassEnvQueryEntityInfoBlueprintWrapper& EntityInfo, const FName Signal)\n{\n\tif (!ensureMsgf(Owner, TEXT(\"Must supply owner to function. Reference to self should suffice.\")))\n\t{\n\t\treturn;\n\t}\n\n\tconst UWorld* World = Owner->GetWorld();\n\tcheck(World);\n\n\tUMassEntitySubsystem* EntitySubsystem = World->GetSubsystem<UMassEntitySubsystem>();\n\tcheck(EntitySubsystem);\n\n\tUMassSignalSubsystem* SignalSubsystem = World->GetSubsystem<UMassSignalSubsystem>();\n\tcheck(SignalSubsystem);\n\n\tFMassEntityManager& EntityManager = EntitySubsystem->GetMutableEntityManager();\n\n\tFMassEntityHandle EntityHandle = EntityInfo.GetEntityHandle();\n\tif (!EntityManager.IsEntityValid(EntityHandle))\n\t{\n\t\treturn;\n\t}\n\n\tSignalSubsystem->SignalEntity(Signal, EntityHandle);\n}\n\n//----------------------------------------------------------------------//\n// Utils\n//----------------------------------------------------------------------//\n\nFVector UMassEQSBlueprintLibrary::GetCurrentEntityPosition(const AActor* Owner, const FMassEnvQueryEntityInfoBlueprintWrapper& EntityInfo)\n{\n\tif (!ensureMsgf(Owner, TEXT(\"Must supply owner to function. Reference to self should suffice.\")))\n\t{\n\t\treturn FVector::ZeroVector;\n\t}\n\n\tconst UWorld* World = Owner->GetWorld();\n\tcheck(World);\n\n\tUMassEntitySubsystem* EntitySubsystem = World->GetSubsystem<UMassEntitySubsystem>();\n\tcheck(EntitySubsystem);\n\n\tFMassEntityManager& EntityManager = EntitySubsystem->GetMutableEntityManager();\n\n\tconst FTransformFragment* TransformFragment = EntityManager.GetFragmentDataPtr<FTransformFragment>(EntityInfo.GetEntityHandle());\n\tif (TransformFragment)\n\t{\n\t\treturn TransformFragment->GetTransform().GetLocation();\n\t}\n\n\treturn FVector::ZeroVector;\n}\n\nbool UMassEQSBlueprintLibrary::ContainsEntity(const TArray<FMassEnvQueryEntityInfoBlueprintWrapper>& EntityList, const FMassEnvQueryEntityInfoBlueprintWrapper& EntityInfo)\n{\n\tfor (const FMassEnvQueryEntityInfoBlueprintWrapper& Entity : EntityList)\n\t{\n\t\tif (Entity == EntityInfo)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nTArray<FMassEnvQueryEntityInfoBlueprintWrapper> UMassEQSBlueprintLibrary::GetEnviromentQueryResultAsEntityInfo(const UEnvQueryInstanceBlueprintWrapper* QueryInstance)\n{\n\tcheck(QueryInstance);\n\n\tTArray<FMassEnvQueryEntityInfoBlueprintWrapper> ResultInfo = {};\n\n\tif (const FEnvQueryResult* QueryResult = QueryInstance->GetQueryResult())\n\t{\n\t\tconst TSubclassOf<UEnvQueryItemType> ItemType = QueryResult->ItemType;\n\t\tconst EEnvQueryRunMode::Type RunMode = QueryInstance->GetRunMode();\n\n\t\tif ((QueryResult->GetRawStatus() == EEnvQueryStatus::Success) \n\t\t\t&& ItemType && ItemType->IsChildOf(UEnvQueryItemType_MassEntityHandle::StaticClass()))\n\t\t{\n\t\t\tif (RunMode != EEnvQueryRunMode::AllMatching)\n\t\t\t{\n\t\t\t\tResultInfo.Add(GetItemAsEntityInfoBPWrapper(QueryResult, 0));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGetAllAsEntityInfoBPWrappers(QueryResult, ResultInfo);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ResultInfo;\n}\n\nFMassEnvQueryEntityInfoBlueprintWrapper UMassEQSBlueprintLibrary::GetItemAsEntityInfoBPWrapper(const FEnvQueryResult* QueryResult, int32 Index)\n{\n\tUEnvQueryItemType_MassEntityHandle* DefTypeOb = QueryResult->ItemType->GetDefaultObject<UEnvQueryItemType_MassEntityHandle>();\n\n\tcheck(DefTypeOb != nullptr);\n\tFMassEnvQueryEntityInfo EntityInfo = DefTypeOb->GetValue(QueryResult->RawData.GetData() + QueryResult->Items[Index].DataOffset);\n\n\treturn FMassEnvQueryEntityInfoBlueprintWrapper(EntityInfo);\n}\n\nvoid UMassEQSBlueprintLibrary::GetAllAsEntityInfoBPWrappers(const FEnvQueryResult* QueryResult, TArray<FMassEnvQueryEntityInfoBlueprintWrapper>& OutInfo)\n{\n\tUEnvQueryItemType_MassEntityHandle* DefTypeOb = QueryResult->ItemType->GetDefaultObject<UEnvQueryItemType_MassEntityHandle>();\n\tcheck(DefTypeOb != nullptr);\n\n\tOutInfo.Reserve(OutInfo.Num() + QueryResult->Items.Num());\n\n\tfor (const FEnvQueryItem& Item : QueryResult->Items)\n\t{\n\t\tFMassEnvQueryEntityInfo EntityInfo = DefTypeOb->GetValue(QueryResult->RawData.GetData() + Item.DataOffset);\n\t\tOutInfo.Add(FMassEnvQueryEntityInfoBlueprintWrapper(EntityInfo));\n\t}\n}",
      "lines": 139
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Private\\MassEQSSubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 4373,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEQSSubsystem.h\"\n\n#include \"MassCommandBuffer.h\"\n#include \"MassEntitySubsystem.h\"\n#include \"MassEQS.h\"\n\n#include \"Items/EnvQueryItemType_MassEntityHandle.h\"\n#include \"Generators/MassEnvQueryGenerator.h\"\n#include \"Tests/MassEnvQueryTest.h\"\n#include \"MassEQSUtils.h\"\n\n//----------------------------------------------------------------------//\n// RequestQueue\n//----------------------------------------------------------------------//\n\nFMassEQSRequestHandle UMassEQSSubsystem::PushRequest(const FEnvQueryInstance& QueryInstance, const int32 RequestQueueIndex, TUniquePtr<FMassEQSRequestData>&& Request)\n{\n\t// It's a \"read\" since the detector only cares about the RequestQueues array, not its elements\n\tUE_MT_SCOPED_READ_ACCESS(RequestAccessDetector);\n\tcheck(RequestQueueIndex >= 0);\n\n\tFMassEQSRequestHandle RequestHandle = HandleManager.GetNextHandle();\n\tRequest.Get()->RequestHandle = RequestHandle;\n\n\t// Fill up the Requests EntityHandle List with all Entities previously generated. \n\t// Won't do anything for Generators.\n\tFMassEQSUtils::GetAllAsEntityHandles(QueryInstance, Request->EntityHandles);\n\n\tRequestQueues[RequestQueueIndex].Enqueue(MoveTemp(Request));\n\n\treturn RequestHandle;\n}\n\n\nTUniquePtr<FMassEQSRequestData> UMassEQSSubsystem::PopRequest(const int32 RequestQueueIndex)\n{\n\t// It's a \"read\" since the detector only cares about the RequestQueues array, not its elements\n\tUE_MT_SCOPED_READ_ACCESS(RequestAccessDetector);\n\tcheck(RequestQueueIndex >= 0);\n\n\tTUniquePtr<FMassEQSRequestData> OutRequest = nullptr;\n\tRequestQueues[RequestQueueIndex].Dequeue(OutRequest);\n\n\treturn OutRequest;\n}\n\n//----------------------------------------------------------------------//\n// Results\n//----------------------------------------------------------------------//\n\nvoid UMassEQSSubsystem::SubmitResults(FMassEQSRequestHandle RequestHandle, TUniquePtr<FMassEQSRequestData>&& Result)\n{\n\tUE_MT_SCOPED_WRITE_ACCESS(ResultAccessDetector);\n\n\tcheck(RequestHandle.IsValid());\n\n\tint32 CancelledRequestIndex = CancelledRequests.Find(RequestHandle);\n\tif (CancelledRequestIndex >= 0)\n\t{\n\t\tCancelledRequests.RemoveAt(CancelledRequestIndex);\n\t\tFinalizeRequest(RequestHandle);\n\t\treturn;\n\t}\n\t\n\tResult->RequestHandle = RequestHandle;\n\tResults.Add(RequestHandle, MoveTemp(Result));\n}\n\nTUniquePtr<FMassEQSRequestData> UMassEQSSubsystem::TryAcquireResults(FMassEQSRequestHandle RequestHandle)\n{\n\tUE_MT_SCOPED_WRITE_ACCESS(ResultAccessDetector);\n\n\t// Should never try to Acquire invalid RequestHandle\n\tcheck(RequestHandle.IsValid());\n\n\tTUniquePtr<FMassEQSRequestData> Result = nullptr;\n\tif (Results.RemoveAndCopyValue(RequestHandle, Result))\n\t{\n\t\tFinalizeRequest(RequestHandle);\n\t}\n\t\n\treturn Result;\n}\n\n//----------------------------------------------------------------------//\n// Misc\n//----------------------------------------------------------------------//\n\nvoid UMassEQSSubsystem::FinalizeRequest(FMassEQSRequestHandle RequestHandle)\n{\n\tHandleManager.RemoveHandle(RequestHandle);\n}\n\nvoid UMassEQSSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tSuper::Initialize(Collection);\n\tbIsInitialized = true;\n}\n\nvoid UMassEQSSubsystem::Deinitialize()\n{\n\tUE_MT_SCOPED_WRITE_ACCESS(RequestAccessDetector);\n\tUE_MT_SCOPED_WRITE_ACCESS(ResultAccessDetector);\n\n\tSuper::Deinitialize();\n\n\tResults.Empty();\n\tRequestQueues.Empty();\n\tRequestQueueLookup.Reset();\n\n\tbIsInitialized = false;\n}\n\nint32 UMassEQSSubsystem::GetRequestQueueIndex(TSubclassOf<UEnvQueryNode> RequestClass)\n{\n\tif (int32* IndexPtr = RequestQueueLookup.Find(RequestClass))\n\t{\n\t\treturn *IndexPtr;\n\t}\n\n\tUE_MT_SCOPED_WRITE_ACCESS(RequestAccessDetector);\n\tRequestQueues.Emplace();\n\tint32 NewIndex = RequestQueues.Num() - 1;\n\t\n\treturn RequestQueueLookup.Add(RequestClass, NewIndex);\n}\n\nvoid UMassEQSSubsystem::CancelRequest(FMassEQSRequestHandle RequestHandle)\n{\n\t// Not necessary after De-initialization\n\tif (!bIsInitialized)\n\t{\n\t\treturn;\n\t}\n\n\tUE_MT_SCOPED_WRITE_ACCESS(ResultAccessDetector);\n\n\tint32 NumRemoved = Results.Remove(RequestHandle);\n\n\t// Log this query if its results are not yet present, we need to ignore results once they are submitted.\n\tif (NumRemoved == 0u)\n\t{\n\t\tCancelledRequests.Add(RequestHandle);\n\t}\n}\n",
      "lines": 147
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Private\\MassEQSTypes.cpp",
      "extension": ".cpp",
      "size_bytes": 2936,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEQSTypes.h\"\n#include \"EnvironmentQuery/EnvQueryTypes.h\"\n#include \"MassEQSSubsystem.h\"\n#include \"MassEQS.h\"\n\n\n//-----------------------------------------------------------------------------\n// FMassEnvQueryEntityInfo\n//-----------------------------------------------------------------------------\nFMassEnvQueryEntityInfo::FMassEnvQueryEntityInfo(int32 Index, int32 SerialNumber, const FTransform& Transform)\n\t: EntityHandle(Index, SerialNumber)\n\t, CachedTransform(Transform)\n{\n}\n\n//-----------------------------------------------------------------------------\n// FMassEQSRequestHandle\n//-----------------------------------------------------------------------------\nFMassEQSRequestHandle FMassEQSRequestHandle::Invalid = FMassEQSRequestHandle(INDEX_NONE, 0);\n\nFString FMassEQSRequestHandle::ToString() const\n{\n\treturn FString::Printf(TEXT(\"[%d,%u]\"), Index, SerialNumber);\n}\n\n//-----------------------------------------------------------------------------\n// IMassEQSRequestInterface::FMassEQSRequestHandler\n//-----------------------------------------------------------------------------\nvoid IMassEQSRequestInterface::FMassEQSRequestHandler::SendOrRecieveRequest(FEnvQueryInstance& QueryInstance, const IMassEQSRequestInterface& MassEQSRequestInterface)\n{\n#if WITH_EDITOR\n\tif (QueryInstance.World->IsEditorWorld() && !QueryInstance.World->IsPlayInEditor())\n\t{\n\t\tUE_LOG(LogEQS, Warning, TEXT(\"Asynchronous request type [%s] is only available when simulating the game.\"), *MassEQSRequestInterface.GetRequestClass()->GetName());\n\t\treturn;\n\t}\n#endif\n\tif (!MassEQSSubsystem)\n\t{\n\t\tcheck(QueryInstance.World)\n\n\t\tMassEQSSubsystem = QueryInstance.World->GetSubsystem<UMassEQSSubsystem>();\n\t\tCachedRequestQueueIndex = MassEQSSubsystem->GetRequestQueueIndex(MassEQSRequestInterface.GetRequestClass());\n\t\tcheck(MassEQSSubsystem);\n\t}\n\t\n\tif (RequestHandle > 0u)\n\t{\n\t\tfloat CurrentTime = QueryInstance.World->GetTimeSeconds();\n\t\tif (CurrentTime - RequestStartTime > MaxRequestTime)\n\t\t{\n\t\t\tCancelRequest();\n\t\t\tReset();\n\t\t}\n\t\telse if (MassEQSRequestInterface.TryAcquireResults(QueryInstance))\n\t\t{\n\t\t\tReset();\n\t\t}\n\t}\n\telse\n\t{\n\t\tRequestHandle = MassEQSSubsystem->PushRequest(QueryInstance, CachedRequestQueueIndex, MassEQSRequestInterface.GetRequestData(QueryInstance));\n\t\tRequestStartTime = QueryInstance.World->GetTimeSeconds();\n\t}\n}\n\nvoid IMassEQSRequestInterface::FMassEQSRequestHandler::CancelRequest() const\n{\n\tif (!IsPendingResults())\n\t{\n\t\t// No active request\n\t\treturn;\n\t}\n\n\tcheck(MassEQSSubsystem)\n\tMassEQSSubsystem->CancelRequest(RequestHandle);\n}\n\nvoid IMassEQSRequestInterface::FMassEQSRequestHandler::Reset()\n{\n\tRequestHandle = FMassEQSRequestHandle::Invalid;\n\tRequestStartTime = -1.f;\n}\n\nIMassEQSRequestInterface::FMassEQSRequestHandler::~FMassEQSRequestHandler()\n{\n\tCancelRequest();\n}\n",
      "lines": 90
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Private\\MassEQSUtils.cpp",
      "extension": ".cpp",
      "size_bytes": 2880,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEQSUtils.h\"\n\n#include \"MassEQSTypes.h\"\n#include \"EnvironmentQuery/EnvQueryTypes.h\"\n#include \"Items/EnvQueryItemType_MassEntityHandle.h\"\n\n#include \"MassEntityTypes.h\"\n\nFMassEnvQueryEntityInfo FMassEQSUtils::GetItemAsEntityInfo(const FEnvQueryInstance& QueryInstance, int32 Index)\n{\n\tUEnvQueryItemType_MassEntityHandle* DefTypeOb = QueryInstance.ItemType->GetDefaultObject<UEnvQueryItemType_MassEntityHandle>();\n\tcheck(DefTypeOb != nullptr);\n\n\treturn DefTypeOb->GetValue(QueryInstance.RawData.GetData() + QueryInstance.Items[Index].DataOffset);\n}\n\nFMassEnvQueryEntityInfo FMassEQSUtils::GetItemAsEntityInfo(const FEnvQueryResult& QueryResult, int32 Index)\n{\n\tUEnvQueryItemType_MassEntityHandle* DefTypeOb = QueryResult.ItemType->GetDefaultObject<UEnvQueryItemType_MassEntityHandle>();\n\tcheck(DefTypeOb != nullptr);\n\n\treturn DefTypeOb->GetValue(QueryResult.RawData.GetData() + QueryResult.Items[Index].DataOffset);\n}\n\nvoid FMassEQSUtils::GetAllAsEntityInfo(const FEnvQueryInstance& QueryInstance, TArray<FMassEnvQueryEntityInfo>& OutEntityInfo)\n{\n\tUEnvQueryItemType_MassEntityHandle* DefTypeOb = QueryInstance.ItemType->GetDefaultObject<UEnvQueryItemType_MassEntityHandle>();\n\tcheck(DefTypeOb != nullptr);\n\n\tOutEntityInfo.Reserve(OutEntityInfo.Num() + QueryInstance.Items.Num());\n\tfor (const FEnvQueryItem& Item : QueryInstance.Items)\n\t{\n\t\tOutEntityInfo.Add(DefTypeOb->GetValue(QueryInstance.RawData.GetData() + Item.DataOffset));\n\t}\n}\n\nvoid FMassEQSUtils::GetAllAsEntityInfo(const FEnvQueryResult& QueryResult, TArray<FMassEnvQueryEntityInfo>& OutEntityInfo)\n{\n\tUEnvQueryItemType_MassEntityHandle* DefTypeOb = QueryResult.ItemType->GetDefaultObject<UEnvQueryItemType_MassEntityHandle>();\n\tcheck(DefTypeOb != nullptr);\n\n\tOutEntityInfo.Reserve(OutEntityInfo.Num() + QueryResult.Items.Num());\n\tfor (const FEnvQueryItem& Item : QueryResult.Items)\n\t{\n\t\tOutEntityInfo.Add(DefTypeOb->GetValue(QueryResult.RawData.GetData() + Item.DataOffset));\n\t}\n}\n\nvoid FMassEQSUtils::GetEntityHandles(const TArray<FMassEnvQueryEntityInfo>& EntityInfo, TArray<FMassEntityHandle>& OutHandles)\n{\n\tOutHandles.Reserve(OutHandles.Num() + EntityInfo.Num());\n\tfor (const FMassEnvQueryEntityInfo& Info : EntityInfo)\n\t{\n\t\tOutHandles.Add(Info.EntityHandle);\n\t}\n}\n\nvoid FMassEQSUtils::GetAllAsEntityHandles(const FEnvQueryInstance& QueryInstance, TArray<FMassEntityHandle>& OutHandles)\n{\n\tUEnvQueryItemType_MassEntityHandle* DefTypeOb = QueryInstance.ItemType->GetDefaultObject<UEnvQueryItemType_MassEntityHandle>();\n\tcheck(DefTypeOb != nullptr);\n\n\tOutHandles.Reserve(OutHandles.Num() + QueryInstance.Items.Num());\n\tfor (const FEnvQueryItem& Item : QueryInstance.Items)\n\t{\n\t\tOutHandles.Add(DefTypeOb->GetValue(QueryInstance.RawData.GetData() + Item.DataOffset).EntityHandle);\n\t}\n}",
      "lines": 70
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Private\\Generators\\MassEnvQueryGenerator.cpp",
      "extension": ".cpp",
      "size_bytes": 445,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Generators/MassEnvQueryGenerator.h\"\n#include \"MassEQSSubsystem.h\"\n\nUMassEnvQueryGenerator::UMassEnvQueryGenerator(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n\tbCanRunAsync = true;\n}\n\nvoid UMassEnvQueryGenerator::GenerateItems(FEnvQueryInstance& QueryInstance) const\n{\n\tMassEQSRequestHandler.SendOrRecieveRequest(QueryInstance, *this);\n}\n",
      "lines": 15
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Private\\Generators\\MassEnvQueryGenerator_MassEntityHandles.cpp",
      "extension": ".cpp",
      "size_bytes": 1646,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Generators/MassEnvQueryGenerator_MassEntityHandles.h\"\n\n#include \"EnvironmentQuery/Contexts/EnvQueryContext_Querier.h\"\n#include \"Items/EnvQueryItemType_MassEntityHandle.h\"\n#include \"MassEQSSubsystem.h\"\n#include \"MassEQSUtils.h\"\n\n#include \"MassEntityTypes.h\"\n\nUMassEnvQueryGenerator_MassEntityHandles::UMassEnvQueryGenerator_MassEntityHandles(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n\tItemType = UEnvQueryItemType_MassEntityHandle::StaticClass();\n\n\tSearchRadius.DefaultValue = 500.0f;\n\tSearchCenter = UEnvQueryContext_Querier::StaticClass();\n}\n\nbool UMassEnvQueryGenerator_MassEntityHandles::TryAcquireResults(FEnvQueryInstance& QueryInstance) const\n{\n\tcheck(MassEQSRequestHandler.MassEQSSubsystem);\n\n\tTUniquePtr<FMassEQSRequestData> RawRequestData = MassEQSRequestHandler.MassEQSSubsystem->TryAcquireResults(MassEQSRequestHandler.RequestHandle);\n\tif (FMassEnvQueryResultData_MassEntityHandles* RequestData = FMassEQSUtils::TryAndEnsureCast<FMassEnvQueryResultData_MassEntityHandles>(RawRequestData))\n\t{\n\t\tQueryInstance.AddItemData<UEnvQueryItemType_MassEntityHandle>(RequestData->GeneratedEntityInfo);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nTUniquePtr<FMassEQSRequestData> UMassEnvQueryGenerator_MassEntityHandles::GetRequestData(FEnvQueryInstance& QueryInstance) const\n{\n\tTArray<FVector> PreparedContextPositions = {};\n\tQueryInstance.PrepareContext(SearchCenter, PreparedContextPositions);\n\n\treturn MakeUnique<FMassEQSRequestData_MassEntityHandles>(MoveTemp(PreparedContextPositions), SearchRadius.GetValue());\n}",
      "lines": 41
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Private\\Items\\EnvQueryItemType_MassEntityHandle.cpp",
      "extension": ".cpp",
      "size_bytes": 1109,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Items/EnvQueryItemType_MassEntityHandle.h\"\n\n#include \"EnvironmentQuery/EnvQueryTypes.h\"\n\n#include \"MassEntitySubsystem.h\"\n\nUEnvQueryItemType_MassEntityHandle::UEnvQueryItemType_MassEntityHandle()\n{\n\tValueSize = sizeof(FMassEnvQueryEntityInfo);\n}\n\nconst FMassEnvQueryEntityInfo& UEnvQueryItemType_MassEntityHandle::GetValue(const uint8* RawData)\n{\n\treturn GetValueFromMemory<FMassEnvQueryEntityInfo>(RawData);\n}\n\nvoid UEnvQueryItemType_MassEntityHandle::SetValue(uint8* RawData, const FMassEnvQueryEntityInfo& Value)\n{\n\treturn SetValueInMemory<FMassEnvQueryEntityInfo>(RawData, Value);\n}\n\nFVector UEnvQueryItemType_MassEntityHandle::GetItemLocation(const uint8* RawData) const\n{\n\tconst FMassEnvQueryEntityInfo& EntityInfo = GetValue(RawData);\t\n\treturn EntityInfo.CachedTransform.GetLocation();\n}\n\nFRotator UEnvQueryItemType_MassEntityHandle::GetItemRotation(const uint8* RawData) const\n{\n\tconst FMassEnvQueryEntityInfo& EntityInfo = GetValue(RawData);\n\treturn EntityInfo.CachedTransform.GetRotation().Rotator();\n}\n",
      "lines": 34
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Private\\Processors\\MassEnvQueryGeneratorProcessor_MassEntityHandles.cpp",
      "extension": ".cpp",
      "size_bytes": 3801,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Processors/MassEnvQueryGeneratorProcessor_MassEntityHandles.h\"\n\n#include \"MassExecutionContext.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassObserverRegistry.h\"\n\n#include \"MassEQSUtils.h\"\n#include \"MassEQSSubsystem.h\"\n\n#include \"EnvironmentQuery/EnvQueryTypes.h\"\n#include \"Items/EnvQueryItemType_MassEntityHandle.h\"\n#include \"Generators/MassEnvQueryGenerator_MassEntityHandles.h\"\n\nUMassEnvQueryGeneratorProcessor_MassEntityHandles::UMassEnvQueryGeneratorProcessor_MassEntityHandles()\n\t: EntityQuery(*this)\n{\n\tCorrespondingRequestClass = UMassEnvQueryGenerator_MassEntityHandles::StaticClass();\n}\n\nvoid UMassEnvQueryGeneratorProcessor_MassEntityHandles::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tProcessorRequirements.AddSubsystemRequirement<UMassEQSSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassEnvQueryGeneratorProcessor_MassEntityHandles::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tconst UWorld* World = GetWorld();\n\tcheck(World);\n\n\tUMassEQSSubsystem* MassEQSSubsystem = Context.GetMutableSubsystem<UMassEQSSubsystem>();\n\tcheck(MassEQSSubsystem);\n\n\t// Check for any requests of this type from MassEQSSubsystem, complete one if found.\n\tTUniquePtr<FMassEQSRequestData> GeneratorDataUniquePtr = MassEQSSubsystem->PopRequest(CachedRequestQueryIndex);\n\tFMassEQSRequestData_MassEntityHandles* GeneratorData = FMassEQSUtils::TryAndEnsureCast<FMassEQSRequestData_MassEntityHandles>(GeneratorDataUniquePtr);\n\tif (!GeneratorData)\n\t{\n\t\treturn;\n\t}\n\n\tconst float SearchRadius = GeneratorData->SearchRadius;\n\tconst TArray<FVector>& ContextPositions = GeneratorData->ContextPositions;\n\n\tTArray<FMassEnvQueryEntityInfo> Items = {};\n\tif (SearchRadius <= 0)\n\t{\n\t\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [&GeneratorData, &Items, &SearchRadius, &ContextPositions](FMassExecutionContext& ChunkContext)\n\t\t{\n\t\t\tconst TConstArrayView<FTransformFragment> TransformFragmentList = ChunkContext.GetFragmentView<FTransformFragment>();\n\t\t\tconst int32 NumEntities = ChunkContext.GetNumEntities();\n\t\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t\t{\n\t\t\t\tFMassEntityHandle EntityHandle = ChunkContext.GetEntity(EntityIndex);\n\t\t\t\tItems.Emplace(EntityHandle.Index, EntityHandle.SerialNumber, TransformFragmentList[EntityIndex].GetTransform());\n\t\t\t}\n\t\t});\n\t}\n\telse\n\t{\n\t\tFVector::FReal SearchRadiusSqr = FMath::Square(SearchRadius);\n\t\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [&GeneratorData, &Items, &SearchRadiusSqr, &ContextPositions](FMassExecutionContext& ChunkContext)\n\t\t{\n\t\t\tconst TConstArrayView<FTransformFragment> TransformFragmentList = ChunkContext.GetFragmentView<FTransformFragment>();\n\t\t\tconst int32 NumEntities = ChunkContext.GetNumEntities();\n\t\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t\t{\n\t\t\t\tconst FTransformFragment& TransformFragment = TransformFragmentList[EntityIndex];\n\t\t\t\tconst FVector& EntityPosition = TransformFragment.GetTransform().GetTranslation();\n\t\t\t\tfor (const FVector& ContextPosition : ContextPositions)\n\t\t\t\t{\n\t\t\t\t\tconst FVector::FReal ContextDistanceToEntitySqr = FVector::DistSquared(EntityPosition, ContextPosition);\n\n\t\t\t\t\tif (ContextDistanceToEntitySqr <= SearchRadiusSqr)\n\t\t\t\t\t{\n\t\t\t\t\t\tFMassEntityHandle EntityHandle = ChunkContext.GetEntity(EntityIndex);\n\t\t\t\t\t\tItems.Emplace(EntityHandle.Index, EntityHandle.SerialNumber, TransformFragmentList[EntityIndex].GetTransform());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\tMassEQSSubsystem->SubmitResults(GeneratorData->RequestHandle, MakeUnique<FMassEnvQueryResultData_MassEntityHandles>(MoveTemp(Items)));\n}",
      "lines": 87
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Private\\Processors\\MassEnvQueryProcessorBase.cpp",
      "extension": ".cpp",
      "size_bytes": 539,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Processors/MassEnvQueryProcessorBase.h\"\n\n#include \"MassEQSSubsystem.h\"\n\nvoid UMassEnvQueryProcessorBase::Initialize(UObject& Owner)\n{\n\tSuper::Initialize(Owner);\n\n\tif (CorrespondingRequestClass)\n\t{\n\t\tUWorld* World = Owner.GetWorld();\n\t\tcheck(World);\n\t\tUMassEQSSubsystem* MassEQSSubsystem = World->GetSubsystem<UMassEQSSubsystem>();\n\t\tcheck(MassEQSSubsystem)\n\t\n\t\tCachedRequestQueryIndex = MassEQSSubsystem->GetRequestQueueIndex(CorrespondingRequestClass);\n\t}\n}",
      "lines": 20
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Private\\Processors\\MassEnvQueryTestProcessor_MassEntityTags.cpp",
      "extension": ".cpp",
      "size_bytes": 5707,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Processors/MassEnvQueryTestProcessor_MassEntityTags.h\"\n\n#include \"Tests/MassEnvQueryTest_MassEntityTags.h\"\n\n#include \"MassEQSSubsystem.h\"\n#include \"MassEQSTypes.h\"\n#include \"MassEQSUtils.h\"\n#include \"MassEQS.h\"\n\n#include \"MassCommonFragments.h\"\n#include \"MassExecutionContext.h\"\n\nnamespace Mass::EQS::Utils\n{\n\n\tbool TestChunkForAnyTags(const TArray<FInstancedStruct>& Tags, const FMassExecutionContext& Context);\n\tbool TestChunkForAllTags(const TArray<FInstancedStruct>& Tags, const FMassExecutionContext& Context);\n\tbool TestChunkForNoTags(const TArray<FInstancedStruct>& Tags, const FMassExecutionContext& Context);\n\n} // namespace Mass::EQS::Utils\n\n\nUMassEnvQueryTestProcessor_MassEntityTags::UMassEnvQueryTestProcessor_MassEntityTags()\n\t: EntityQuery(*this)\n{\n\tCorrespondingRequestClass = UMassEnvQueryTest_MassEntityTags::StaticClass();\n}\n\nvoid UMassEnvQueryTestProcessor_MassEntityTags::ConfigureQueries()\n{\n\tProcessorRequirements.AddSubsystemRequirement<UMassEQSSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassEnvQueryTestProcessor_MassEntityTags::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext)\n{\n\tconst UWorld* World = GetWorld();\n\tcheck(World);\n\n\tUMassEQSSubsystem* MassEQSSubsystem = ExecutionContext.GetMutableSubsystem<UMassEQSSubsystem>();\n\tcheck(MassEQSSubsystem);\n\n\t// Check for any requests of this type from MassEQSSubsystem, complete one if found.\n\tTUniquePtr<FMassEQSRequestData> TestDataUniquePtr = MassEQSSubsystem->PopRequest(CachedRequestQueryIndex);\n\tFMassEQSRequestData_MassEntityTags* TestData = FMassEQSUtils::TryAndEnsureCast<FMassEQSRequestData_MassEntityTags>(TestDataUniquePtr);\n\tif (!TestData)\n\t{\n\t\treturn;\n\t}\n\tif (TestDataUniquePtr->EntityHandles.IsEmpty())\n\t{\n\t\tUE_LOG(LogMassEQS, Error, TEXT(\"Request: [%s] Acquired by UMassEnvQueryTestProcessor_MassEntityTags, but had no Entities to query.\"), *TestDataUniquePtr->RequestHandle.ToString());\n\t\treturn;\n\t}\n\n\tconst EMassEntityTagsTestMode TagTestMode = TestData->TagTestMode;\n\tconst TArray<FInstancedStruct> Tags = TestData->Tags;\n\n\tTFunction<bool(const TArray<FInstancedStruct>&, const FMassExecutionContext&)> ScoringFunction;\n\tTMap<FMassEntityHandle, bool> ScoreMap = {};\n\n\tswitch (TagTestMode)\n\t{\n\tcase EMassEntityTagsTestMode::Any:\n\t{\n\t\tScoringFunction = Mass::EQS::Utils::TestChunkForAnyTags;\n\t\tbreak;\n\t}\n\tcase EMassEntityTagsTestMode::All:\n\t{\n\t\tScoringFunction = Mass::EQS::Utils::TestChunkForAllTags;\n\t\tbreak;\n\t}\n\tcase EMassEntityTagsTestMode::None:\n\t{\n\t\tScoringFunction = Mass::EQS::Utils::TestChunkForNoTags;\n\t\tbreak;\n\t}\n\tdefault:\n\t{\n\t\tScoringFunction = [](const TArray<FInstancedStruct>& Tags, const FMassExecutionContext& Context) { return false; };\n\t\tbreak;\n\t}\n\t}\n\n\tensureMsgf(ExecutionContext.GetEntityCollection().IsEmpty(), TEXT(\"We don't expect any collections to be set at this point. The data is going to be overridden.\"));\n\n\tTArray<FMassArchetypeEntityCollection> EntityCollectionsToTest;\n\tUE::Mass::Utils::CreateEntityCollections(EntityManager, TestDataUniquePtr->EntityHandles, FMassArchetypeEntityCollection::NoDuplicates, EntityCollectionsToTest);\n\n\tEntityQuery.ForEachEntityChunkInCollections(EntityCollectionsToTest, EntityManager, ExecutionContext\n\t\t, [&ScoreMap, &ScoringFunction, &Tags](FMassExecutionContext& Context)\n\t\t{\n\t\t\tbool ChunkSuccess = ScoringFunction(Tags, Context);\n\n\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t\t{\n\t\t\t\tconst FMassEntityHandle EntityHandle = Context.GetEntity(EntityIndex);\n\t\t\t\tScoreMap.Add(EntityHandle, ChunkSuccess);\n\t\t\t}\n\t\t});\n\n\tMassEQSSubsystem->SubmitResults(TestData->RequestHandle, MakeUnique<FMassEnvQueryResultData_MassEntityTags>(MoveTemp(ScoreMap)));\n}\n\n\nbool Mass::EQS::Utils::TestChunkForAnyTags(const TArray<FInstancedStruct>& Tags, const FMassExecutionContext& Context)\n{\n\tfor (const FInstancedStruct& Tag : Tags)\n\t{\n\t\tconst UScriptStruct* TagScriptStruct = Tag.GetScriptStruct();\n#if !UE_BUILD_SHIPPING\n\t\tif (!ensureMsgf(TagScriptStruct && TagScriptStruct->IsChildOf(FMassTag::StaticStruct()), TEXT(\"Non Tag Element Detected in Enviroment Query Mass-Entity-Tags-Test. Likely left empty.\")))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tif (Context.DoesArchetypeHaveTag(*Tag.GetScriptStruct()))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool Mass::EQS::Utils::TestChunkForAllTags(const TArray<FInstancedStruct>& Tags, const FMassExecutionContext& Context)\n{\n\tfor (const FInstancedStruct& Tag : Tags)\n\t{\n\t\tconst UScriptStruct* TagScriptStruct = Tag.GetScriptStruct();\n#if !UE_BUILD_SHIPPING\n\t\tif (!ensureMsgf(TagScriptStruct && TagScriptStruct->IsChildOf(FMassTag::StaticStruct()), TEXT(\"Non Tag Element Detected in Enviroment Query Mass-Entity-Tags-Test. Likely left empty.\")))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tif (!Context.DoesArchetypeHaveTag(*Tag.GetScriptStruct()))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool Mass::EQS::Utils::TestChunkForNoTags(const TArray<FInstancedStruct>& Tags, const FMassExecutionContext& Context)\n{\n\tfor (const FInstancedStruct& Tag : Tags)\n\t{\n\t\tconst UScriptStruct* TagScriptStruct = Tag.GetScriptStruct();\n#if !UE_BUILD_SHIPPING\n\t\tif (!ensureMsgf(TagScriptStruct && TagScriptStruct->IsChildOf(FMassTag::StaticStruct()), TEXT(\"Non Tag Element Detected in Enviroment Query Mass-Entity-Tags-Test. Likely left empty.\")))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tif (Context.DoesArchetypeHaveTag(*Tag.GetScriptStruct()))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\n\n\n\n\n\n\n",
      "lines": 175
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Private\\Tests\\MassEnvQueryTest.cpp",
      "extension": ".cpp",
      "size_bytes": 389,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Tests/MassEnvQueryTest.h\"\n#include \"MassEQSSubsystem.h\"\n\nUMassEnvQueryTest::UMassEnvQueryTest(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid UMassEnvQueryTest::RunTest(FEnvQueryInstance& QueryInstance) const\n{\n\tMassEQSRequestHandler.SendOrRecieveRequest(QueryInstance, *this);\n}",
      "lines": 14
    },
    {
      "file_path": "MassGameplay\\MassEQS\\Private\\Tests\\MassEnvQueryTest_MassEntityTags.cpp",
      "extension": ".cpp",
      "size_bytes": 2280,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Tests/MassEnvQueryTest_MassEntityTags.h\"\n\n#include \"Items/EnvQueryItemType_MassEntityHandle.h\"\n\n#include \"MassEQSUtils.h\"\n#include \"MassEQSTypes.h\"\n#include \"MassEQSSubsystem.h\"\n\n#include \"MassCommandBuffer.h\"\n#include \"MassEntityManager.h\"\n#include \"MassEntitySubsystem.h\"\n\nUMassEnvQueryTest_MassEntityTags::UMassEnvQueryTest_MassEntityTags(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n\tCost = EEnvTestCost::Low;\n\tTestPurpose = EEnvTestPurpose::Type::Filter;\n\tFilterType = EEnvTestFilterType::Type::Match;\n\n\tValidItemType = UEnvQueryItemType_MassEntityHandle::StaticClass();\n\n\tSetWorkOnFloatValues(false);\n\n}\n\nTUniquePtr<FMassEQSRequestData> UMassEnvQueryTest_MassEntityTags::GetRequestData(FEnvQueryInstance& QueryInstance) const\n{\n\treturn MakeUnique<FMassEQSRequestData_MassEntityTags>(TagTestMode, Tags);\n}\n\nbool UMassEnvQueryTest_MassEntityTags::TryAcquireResults(FEnvQueryInstance& QueryInstance) const\n{\n\tcheck(MassEQSRequestHandler.MassEQSSubsystem)\n\tTUniquePtr<FMassEQSRequestData> RawRequestData = MassEQSRequestHandler.MassEQSSubsystem->TryAcquireResults(MassEQSRequestHandler.RequestHandle);\n\tFMassEnvQueryResultData_MassEntityTags* RequestData = FMassEQSUtils::TryAndEnsureCast<FMassEnvQueryResultData_MassEntityTags>(RawRequestData);\n\tif (!RequestData)\n\t{\n\t\treturn false;\n\t}\n\n\tFEnvQueryInstance::ItemIterator It(this, QueryInstance);\n\tfor (It.IgnoreTimeLimit(); It; ++It)\n\t{\n\t\tconst FMassEnvQueryEntityInfo& EntityInfo = FMassEQSUtils::GetItemAsEntityInfo(QueryInstance, It.GetIndex());\n\n\t\tconst bool bSuccess = RequestData->ResultMap.Contains(EntityInfo.EntityHandle) && RequestData->ResultMap[EntityInfo.EntityHandle];\n\n\t\tIt.SetScore(TestPurpose, FilterType, bSuccess, true);\n\t}\n\n\treturn true;\n}\n\nFText UMassEnvQueryTest_MassEntityTags::GetDescriptionTitle() const\n{\n\treturn FText::FromString(FString::Printf(TEXT(\"Mass Entity Tags Test : Match %s Tags\"),\n\t\tTagTestMode == EMassEntityTagsTestMode::Any ? TEXT(\"Any\") :\n\t\tTagTestMode == EMassEntityTagsTestMode::All ? TEXT(\"All\") : TEXT(\"None\")));\n}\n\nFText UMassEnvQueryTest_MassEntityTags::GetDescriptionDetails() const\n{\n\treturn DescribeFloatTestParams();\n}",
      "lines": 66
    },
    {
      "file_path": "MassGameplay\\MassGameplayDebug\\Private\\AssignDebugVisProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 2773,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"AssignDebugVisProcessor.h\"\n#include \"MassGameplayDebugTypes.h\"\n#include \"MassDebugVisualizationComponent.h\"\n#include \"MassDebuggerSubsystem.h\"\n#include \"MassExecutionContext.h\"\n\n//----------------------------------------------------------------------//\n// UAssignDebugVisProcessor\n//----------------------------------------------------------------------//\nUAssignDebugVisProcessor::UAssignDebugVisProcessor()\n\t: EntityQuery(*this)\n{\n\tbAutoRegisterWithProcessingPhases = false;\n\tbRequiresGameThreadExecution = true; // due to UMassDebuggerSubsystem\n\tObservedType = FSimDebugVisFragment::StaticStruct();\n\tOperation = EMassObservedOperation::Add;\n}\n\nvoid UAssignDebugVisProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FSimDebugVisFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddSubsystemRequirement<UMassDebuggerSubsystem>(EMassFragmentAccess::ReadWrite);\n\n\tProcessorRequirements.AddSubsystemRequirement<UMassDebuggerSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UAssignDebugVisProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n#if WITH_EDITORONLY_DATA\n\tQUICK_SCOPE_CYCLE_COUNTER(AssignDebugVisProcessor_Execute);\n\t\n\t// @todo this code bit is temporary, so is the Visualizer->DirtyVisuals at the end of the function. Will be wrapped in\n\t// \"executable task\" once that's implemented. \n\tUMassDebugVisualizationComponent* Visualizer = nullptr;\n\tUMassDebuggerSubsystem& Debugger = Context.GetMutableSubsystemChecked<UMassDebuggerSubsystem>();\n\tcheck(Debugger.GetVisualizationComponent());\n\tVisualizer = Debugger.GetVisualizationComponent();\n\t// note that this function will create the \"visual components\" only it they're missing or out of sync. \n\tDebugger.GetVisualizationComponent()->ConditionallyConstructVisualComponent();\n\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tUMassDebuggerSubsystem& Debugger = Context.GetMutableSubsystemChecked<UMassDebuggerSubsystem>();\n\t\tUMassDebugVisualizationComponent* Visualizer = Debugger.GetVisualizationComponent();\n\t\tcheck(Visualizer);\n\n\t\tconst TArrayView<FSimDebugVisFragment> DebugVisList = Context.GetMutableFragmentView<FSimDebugVisFragment>();\n\t\tfor (FSimDebugVisFragment& VisualComp : DebugVisList)\n\t\t{\n\t\t\t// VisualComp.VisualType needs to be assigned by now. Should be performed as part of spawning, copied from the AgentTemplate\n\t\t\tif (ensure(VisualComp.VisualType != INDEX_NONE))\n\t\t\t{\n\t\t\t\tVisualComp.InstanceIndex = Visualizer->AddDebugVisInstance(VisualComp.VisualType);\n\t\t\t}\n\t\t}\n\t});\n\n\tif (ensure(Visualizer))\n\t{\n\t\tVisualizer->DirtyVisuals();\n\t}\n#endif // WITH_EDITORONLY_DATA\n}\n",
      "lines": 65
    },
    {
      "file_path": "MassGameplay\\MassGameplayDebug\\Private\\DebugVisLocationProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 5067,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"DebugVisLocationProcessor.h\"\n#include \"MassDebuggerSubsystem.h\"\n#include \"MassDebugVisualizationComponent.h\"\n#include \"MassCommonFragments.h\"\n#include \"Components/HierarchicalInstancedStaticMeshComponent.h\"\n#include \"MassEntityManager.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassMovementFragments.h\"\n\n//----------------------------------------------------------------------//\n// UDebugVisLocationProcessor\n//----------------------------------------------------------------------//\nUDebugVisLocationProcessor::UDebugVisLocationProcessor()\n\t: EntityQuery(*this)\n{\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::SyncWorldToMass);\n\tbRequiresGameThreadExecution = true; // due to UMassDebuggerSubsystem access\n}\n\nvoid UDebugVisLocationProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FSimDebugVisFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddTagRequirement<FMassDebuggableTag>(EMassFragmentPresence::All);\n\tEntityQuery.AddSubsystemRequirement<UMassDebuggerSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UDebugVisLocationProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n#if WITH_EDITORONLY_DATA\n\tQUICK_SCOPE_CYCLE_COUNTER(DebugVisLocationProcessor_Run);\n\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tUMassDebuggerSubsystem& Debugger = Context.GetMutableSubsystemChecked<UMassDebuggerSubsystem>();\n\t\tUMassDebugVisualizationComponent* Visualizer = Debugger.GetVisualizationComponent();\n\t\tcheck(Visualizer);\n\t\tTArrayView<UHierarchicalInstancedStaticMeshComponent* const> VisualDataISMCs = Visualizer->GetVisualDataISMCs();\n\t\tif (VisualDataISMCs.Num() > 0)\n\t\t{\n\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\tconst TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\t\t\tconst TConstArrayView<FSimDebugVisFragment> DebugVisList = Context.GetFragmentView<FSimDebugVisFragment>();\n\n\t\t\tfor (int32 i = 0; i < NumEntities; ++i)\n\t\t\t{\n\t\t\t\tconst FSimDebugVisFragment& VisualComp = DebugVisList[i];\n\n\t\t\t\t// @todo: remove this code once the asset is exported with correct alignment SM_Mannequin.uasset\n\t\t\t\tFTransform SMTransform = LocationList[i].GetTransform();\n\t\t\t\tFQuat FromEngineToSM(FVector::UpVector, -HALF_PI);\n\t\t\t\tSMTransform.SetRotation(FromEngineToSM * SMTransform.GetRotation());\n\n\t\t\t\tVisualDataISMCs[VisualComp.VisualType]->UpdateInstanceTransform(VisualComp.InstanceIndex, SMTransform, true);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUE_LOG(LogMassDebug, Log, TEXT(\"UDebugVisLocationProcessor: Trying to update InstanceStaticMeshes while none created. Check your debug visualization setup\"));\n\t\t}\n\t});\n\n\tUMassDebuggerSubsystem* Debugger = UWorld::GetSubsystem<UMassDebuggerSubsystem>(EntityManager.GetWorld());\n\tif (ensure(Debugger))\n\t{\n\t\tDebugger->GetVisualizationComponent()->DirtyVisuals();\n\t}\n#endif // WITH_EDITORONLY_DATA\n}\n\n//----------------------------------------------------------------------//\n//  UMassProcessor_UpdateDebugVis\n//----------------------------------------------------------------------//\nUMassProcessor_UpdateDebugVis::UMassProcessor_UpdateDebugVis()\n\t: EntityQuery(*this)\n{\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::UpdateWorldFromMass);\n\tbRequiresGameThreadExecution = true; // due to UMassDebuggerSubsystem access\n}\n\nvoid UMassProcessor_UpdateDebugVis::ConfigureQueries() \n{\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FDataFragment_DebugVis>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FAgentRadiusFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddTagRequirement<FMassDebuggableTag>(EMassFragmentPresence::All);\n\n\tProcessorRequirements.AddSubsystemRequirement<UMassDebuggerSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassProcessor_UpdateDebugVis::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tQUICK_SCOPE_CYCLE_COUNTER(UMassProcessor_UpdateDebugVis_Run);\n\n\tUMassDebuggerSubsystem& Debugger = Context.GetMutableSubsystemChecked<UMassDebuggerSubsystem>();\n\tDebugger.ResetDebugShapes();\n\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [&Debugger](FMassExecutionContext& Context)\n\t\t{\n\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\tconst TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\t\t\tconst TArrayView<FDataFragment_DebugVis> DebugVisList = Context.GetMutableFragmentView<FDataFragment_DebugVis>();\n\t\t\tconst TArrayView<FAgentRadiusFragment> RadiiList = Context.GetMutableFragmentView<FAgentRadiusFragment>();\n\n\t\t\tfor (int32 i = 0; i < NumEntities; ++i)\n\t\t\t{\n\t\t\t\tDebugger.AddShape(DebugVisList[i].Shape, LocationList[i].GetTransform().GetLocation(), RadiiList[i].Radius);\n\t\t\t}\n\t\t});\n}\n",
      "lines": 112
    },
    {
      "file_path": "MassGameplay\\MassGameplayDebug\\Private\\MassDebuggerSubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 3898,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassDebuggerSubsystem.h\"\n#include \"EngineUtils.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassSimulationSubsystem.h\"\n#include \"MassDebugVisualizationComponent.h\"\n#include \"MassEntityManager.h\"\n#include \"MassDebugVisualizer.h\"\n#include \"MassDebugger.h\"\n#include \"MassEntityManager.h\"\n\n\nvoid UMassDebuggerSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tCollection.InitializeDependency(UMassSimulationSubsystem::StaticClass());\n\tSuper::Initialize(Collection);\n\n\tUMassSimulationSubsystem* SimSystem = UWorld::GetSubsystem<UMassSimulationSubsystem>(GetWorld());\n\tcheck(SimSystem);\n\tSimSystem->GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).AddUObject(this, &UMassDebuggerSubsystem::OnProcessingPhaseStarted);\n\n#if WITH_MASSENTITY_DEBUG\n\tOnEntitySelectedHandle = FMassDebugger::OnEntitySelectedDelegate.AddUObject(this, &UMassDebuggerSubsystem::OnEntitySelected);\n#endif // WITH_MASSENTITY_DEBUG\n}\n\nvoid UMassDebuggerSubsystem::Deinitialize()\n{\n#if WITH_MASSENTITY_DEBUG\n\tFMassDebugger::OnEntitySelectedDelegate.Remove(OnEntitySelectedHandle);\n#endif // WITH_MASSENTITY_DEBUG\n\tSuper::Deinitialize();\n}\n\n#if WITH_MASSENTITY_DEBUG\nvoid UMassDebuggerSubsystem::OnEntitySelected(const FMassEntityManager& EntityManager, const FMassEntityHandle EntityHandle)\n{\n\tif (EntityManager.GetWorld() == GetWorld())\n\t{\n\t\tSetSelectedEntity(EntityHandle);\n\t}\n}\n#endif // WITH_MASSENTITY_DEBUG\n\nvoid UMassDebuggerSubsystem::ResetDebugShapes()\n{\n\t// get ready to receive new debug info\n\tfor (TArray<FShapeDesc>& Array : Shapes)\n\t{\n\t\tArray.Reset();\n\t}\n}\n\nvoid UMassDebuggerSubsystem::PreTickProcessors()\n{\n\tEntities.Reset();\n\tLocations.Reset();\n\tSelectedEntityDetails.Empty();\n}\n\nvoid UMassDebuggerSubsystem::OnProcessingPhaseStarted(const float DeltaSeconds)\n{\n\tPreTickProcessors();\n}\n\nvoid UMassDebuggerSubsystem::SetSelectedEntity(const FMassEntityHandle InSelectedEntity)\n{\n\tSelectedEntity = InSelectedEntity;\n\tSelectedEntityDetails.Empty();\n}\n\nvoid UMassDebuggerSubsystem::AppendSelectedEntityInfo(const FString& Info)\n{\n\tSelectedEntityDetails += Info;\n}\n\nUMassDebugVisualizationComponent* UMassDebuggerSubsystem::GetVisualizationComponent()\n{ \n#if WITH_EDITORONLY_DATA\n\tif (VisualizationComponent == nullptr)\n\t{\n\t\tif (!ensureMsgf(DebugVisualizer == nullptr, TEXT(\"If we do have a DebugVisualizer but don't have VisualizationComponent then somethin's wrong\")))\n\t\t{\n\t\t\tVisualizationComponent = &DebugVisualizer->GetDebugVisComponent();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (UWorld* World = GetWorld())\n\t\t\t{\n\t\t\t\tconst AMassDebugVisualizer& VisualizerActor = GetOrSpawnDebugVisualizer(*World);\n\t\t\t\tVisualizationComponent = &VisualizerActor.GetDebugVisComponent();\n\t\t\t}\n\t\t}\n\t}\n\tensureMsgf(VisualizationComponent,  TEXT(\"In editor builds we always expect to have a visualizer component available\"));\n#endif // WITH_EDITORONLY_DATA\n\treturn VisualizationComponent;\n}\n\n#if WITH_EDITORONLY_DATA\nAMassDebugVisualizer& UMassDebuggerSubsystem::GetOrSpawnDebugVisualizer(UWorld& InWorld)\n{\n\tif (DebugVisualizer)\n\t{\n\t\treturn *DebugVisualizer;\n\t}\n\n\t// see if there is one already and we've missed it somehow\n\tfor (const TActorIterator<AMassDebugVisualizer> It(&InWorld); It;)\n\t{\n\t\tDebugVisualizer = *It;\n\t\treturn *DebugVisualizer;\n\t}\n\n\tFActorSpawnParameters SpawnInfo;\n\tSpawnInfo.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;\n\t// The helper actor is created on demand and only once per world so we can allow it to spawn during construction script.\n\tSpawnInfo.bAllowDuringConstructionScript = true;\n\tDebugVisualizer = InWorld.SpawnActor<AMassDebugVisualizer>(SpawnInfo);\n\tcheck(DebugVisualizer);\n\tVisualizationComponent = &DebugVisualizer->GetDebugVisComponent();\n\n\treturn *DebugVisualizer;\n}\n#endif",
      "lines": 126
    },
    {
      "file_path": "MassGameplay\\MassGameplayDebug\\Private\\MassDebugVisualizationComponent.cpp",
      "extension": ".cpp",
      "size_bytes": 2671,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassDebugVisualizationComponent.h\"\n#include \"Components/HierarchicalInstancedStaticMeshComponent.h\"\n\n\n#if WITH_EDITORONLY_DATA\n#include \"MassDebugVisualizer.h\"\n\nvoid UMassDebugVisualizationComponent::PostInitProperties()\n{\n\tSuper::PostInitProperties();\n\tif (HasAnyFlags(RF_ClassDefaultObject) == false && GetOuter())\n\t{\n\t\tensureMsgf(GetOuter()->GetClass()->IsChildOf(AMassDebugVisualizer::StaticClass()), TEXT(\"UMassDebugVisualizationComponent should only be added to AMassDebugVisualizer-like instances\"));\n\t}\n}\n\nvoid UMassDebugVisualizationComponent::DirtyVisuals()\n{\n\tfor (UHierarchicalInstancedStaticMeshComponent* ISM : VisualDataISMCs)\n\t{\n\t\tif (ensure(ISM))\n\t\t{\n\t\t\tISM->MarkRenderStateDirty();\n\t\t}\n\t}\n}\n\nint32 UMassDebugVisualizationComponent::AddDebugVisInstance(const uint16 VisualType)\n{\n\treturn VisualDataISMCs[VisualType]->AddInstance(FTransform::Identity);\n}\n\nvoid UMassDebugVisualizationComponent::ConditionallyConstructVisualComponent()\n{\n\tif (VisualDataISMCs.Num() == 0 || VisualDataISMCs.Num() != VisualDataTable.Num())\n\t{\n\t\tConstructVisualComponent();\n\t}\n}\n\nvoid UMassDebugVisualizationComponent::ConstructVisualComponent()\n{\n\tAActor* ActorOwner = GetOwner();\n\tcheck(ActorOwner);\n\t\n\t// add HISMCs only for types not added yet\n\tfor (int NewTypeIndex = VisualDataISMCs.Num(); NewTypeIndex < VisualDataTable.Num(); ++NewTypeIndex)\n\t{\n\t\tconst FAgentDebugVisualization& VisualData = VisualDataTable[NewTypeIndex];\n\t\tUHierarchicalInstancedStaticMeshComponent* HISMC = NewObject<UHierarchicalInstancedStaticMeshComponent>(ActorOwner);\n\t\tHISMC->SetStaticMesh(VisualData.Mesh);\n\t\tif (VisualData.MaterialOverride != nullptr)\n\t\t{\n\t\t\tHISMC->SetMaterial(0, VisualData.MaterialOverride);\n\t\t}\n\n\t\tHISMC->SetCullDistances(VisualData.VisualNearCullDistance, VisualData.VisualFarCullDistance);\n\t\tHISMC->SetupAttachment(ActorOwner->GetRootComponent());\n\t\tHISMC->SetCanEverAffectNavigation(false);\n\t\tHISMC->bDisableCollision = true;\n\t\tHISMC->SetCastShadow(false);\n\t\tHISMC->RegisterComponent();\n\n\t\tVisualDataISMCs.Add(HISMC);\n\t}\n}\n\nuint16 UMassDebugVisualizationComponent::AddDebugVisType(const FAgentDebugVisualization& Data)\n{\n\tconst int32 Index = VisualDataTable.Add(Data);\n\tcheck(VisualDataTable.Num() <= (int32)MAX_uint16);\n\treturn (uint16)Index;\n}\n\nvoid UMassDebugVisualizationComponent::Clear()\n{\n\tfor (UHierarchicalInstancedStaticMeshComponent* ISM : VisualDataISMCs)\n\t{\n\t\tif (ensure(ISM))\n\t\t{\n\t\t\tISM->ClearInstances();\n\t\t\tISM->UnregisterComponent();\n\t\t}\n\t}\n\tVisualDataISMCs.Reset();\n}\n#endif // WITH_EDITORONLY_DATA\n",
      "lines": 89
    },
    {
      "file_path": "MassGameplay\\MassGameplayDebug\\Private\\MassDebugVisualizationTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 1859,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassDebugVisualizationTrait.h\"\n#include \"MassDebuggerSubsystem.h\"\n#include \"MassDebugVisualizationComponent.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"MassCommonFragments.h\"\n#include \"Engine/World.h\"\n\nvoid UMassDebugVisualizationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n#if WITH_EDITORONLY_DATA\n\tconst UStaticMesh* const DebugMesh = DebugShape.Mesh;\n#else\n\tconst UStaticMesh* const DebugMesh = nullptr;\n#endif\n\t\n\tif (DebugMesh || BuildContext.IsInspectingData())\n\t{\n#if WITH_EDITORONLY_DATA\n\t\tFSimDebugVisFragment& DebugVisFragment = BuildContext.AddFragment_GetRef<FSimDebugVisFragment>();\n\t\tif (!BuildContext.IsInspectingData())\n\t\t{\n\t\t\tUMassDebuggerSubsystem* Debugger = World.GetSubsystem<UMassDebuggerSubsystem>();\n\t\t\tif (ensure(Debugger))\n\t\t\t{\n\t\t\t\tUMassDebugVisualizationComponent* DebugVisComponent = Debugger->GetVisualizationComponent();\n\t\t\t\tif (ensure(DebugVisComponent))\n\t\t\t\t{\n\t\t\t\t\tDebugVisFragment.VisualType = DebugVisComponent->AddDebugVisType(DebugShape);\n\t\t\t\t}\n\t\t\t\t// @todo this path requires a fragment destructor that will remove the mesh from the debugger.\n\t\t\t}\n\t\t}\n#endif // WITH_EDITORONLY_DATA\n\t}\n\t// add fragments needed whenever we have debugging capabilities\n#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)\n\tBuildContext.AddTag<FMassDebuggableTag>();\n#if WITH_EDITORONLY_DATA\n\tBuildContext.AddFragment_GetRef<FDataFragment_DebugVis>().Shape = DebugShape.WireShape;\n#else\n\t// DebugShape unavailable, will used default instead\n\tBuildContext.AddFragment<FDataFragment_DebugVis>();\n#endif // WITH_EDITORONLY_DATA\n\tBuildContext.AddFragment<FAgentRadiusFragment>();\n\n\tBuildContext.AddFragment<FTransformFragment>();\n#endif // if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)\n\n}",
      "lines": 51
    },
    {
      "file_path": "MassGameplay\\MassGameplayDebug\\Private\\MassDebugVisualizer.cpp",
      "extension": ".cpp",
      "size_bytes": 471,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassDebugVisualizer.h\"\n\n#if WITH_EDITORONLY_DATA\n#include \"MassDebugVisualizationComponent.h\"\n#endif // WITH_EDITORONLY_DATA\n\nAMassDebugVisualizer::AMassDebugVisualizer()\n{\n#if WITH_EDITORONLY_DATA\n\tRootComponent = CreateDefaultSubobject<USceneComponent>(TEXT(\"SceneComp\"));\n\tDebugVisComponent = CreateDefaultSubobject<UMassDebugVisualizationComponent>(TEXT(\"VisualizerComponent\"));\n#endif\n}\n\n",
      "lines": 16
    },
    {
      "file_path": "MassGameplay\\MassGameplayDebug\\Private\\MassGameplayDebugModule.cpp",
      "extension": ".cpp",
      "size_bytes": 619,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleManager.h\"\n#include \"IMassGameplayDebugModule.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassGameplayDebugTypes.h\"\n\nDEFINE_LOG_CATEGORY(LogMassDebug);\n\nclass FMassGameplayDebug : public IMassGameplayDebugModule\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nIMPLEMENT_MODULE(FMassGameplayDebug, MassGameplayDebug)\n\nvoid FMassGameplayDebug::StartupModule()\n{\n}\n\nvoid FMassGameplayDebug::ShutdownModule()\n{\n}\n\n\n\n",
      "lines": 29
    },
    {
      "file_path": "MassGameplay\\MassGameplayDebug\\Private\\MassGameplayDebugTypes.cpp",
      "extension": ".cpp",
      "size_bytes": 1374,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassGameplayDebugTypes.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassEntityManager.h\"\n#if WITH_MASSGAMEPLAY_DEBUG\n#include \"MassDebugger.h\"\n\n\nnamespace UE::Mass::Debug\n{\n\nvoid GetDebugEntitiesAndLocations(const FMassEntityManager& EntityManager, TArray<FMassEntityHandle>& OutEntities, TArray<FVector>& OutLocations)\n{\n\tint32 DebugEntityEnd, DebugEntityBegin;\n\tif (GetDebugEntitiesRange(DebugEntityEnd, DebugEntityBegin) == false)\n\t{\n\t\treturn;\n\t}\n\n\tOutEntities.Reserve(DebugEntityEnd - DebugEntityBegin);\n\tOutLocations.Reserve(DebugEntityEnd - DebugEntityBegin);\n\n\tfor (int32 i = DebugEntityBegin; i <= DebugEntityEnd; ++i)\n\t{\n\t\tconst FMassEntityHandle EntityHandle = ConvertEntityIndexToHandle(EntityManager, i);\n\t\tif (EntityHandle.IsSet())\n\t\t{\n\t\t\tif (const FTransformFragment* TransformFragment = EntityManager.GetFragmentDataPtr<FTransformFragment>(EntityHandle))\n\t\t\t{\n\t\t\t\tOutEntities.Add(EntityHandle);\n\t\t\t\tOutLocations.Add(TransformFragment->GetTransform().GetLocation());\n\t\t\t}\n\t\t}\n\t}\n}\n\nFMassEntityHandle ConvertEntityIndexToHandle(const FMassEntityManager& EntityManager, const int32 EntityIndex)\n{\n\treturn EntityManager.DebugGetEntityIndexHandle(EntityIndex);\n}\n\n} // namespace UE::Mass::Debug\n#endif // WITH_MASSGAMEPLAY_DEBUG",
      "lines": 45
    },
    {
      "file_path": "MassGameplay\\MassGameplayEditor\\Private\\MassActorEditorSubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 846,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassActorEditorSubsystem.h\"\n#include \"MassActorSubsystem.h\"\n#include \"MassEntityManager.h\"\n#include \"MassEntityEditorSubsystem.h\"\n\n\n//----------------------------------------------------------------------//\n//  UMassActorEditorSubsystem\n//----------------------------------------------------------------------//\nvoid UMassActorEditorSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tUMassEntityEditorSubsystem* MassEditorEditorSubsystem = Collection.InitializeDependency<UMassEntityEditorSubsystem>();\n\tcheck(MassEditorEditorSubsystem);\n\tTSharedRef<FMassEntityManager> MassEntityManager = MassEditorEditorSubsystem->GetMutableEntityManager();\n\tActorManager = MakeShareable(new FMassActorManager(MassEntityManager));\n\n\tSuper::Initialize(Collection);\n}\n",
      "lines": 20
    },
    {
      "file_path": "MassGameplay\\MassGameplayEditor\\Private\\MassGameplayEditorModule.cpp",
      "extension": ".cpp",
      "size_bytes": 1283,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassGameplayEditorModule.h\"\n#include \"Modules/ModuleManager.h\"\n#include \"PropertyEditorModule.h\"\n\n\n#define LOCTEXT_NAMESPACE \"MassGameplayEditor\"\n\nIMPLEMENT_MODULE(FMassGameplayEditorModule, MassGameplayEditor)\n\nvoid FMassGameplayEditorModule::StartupModule()\n{\n\t// Register the details customizers\n\tFPropertyEditorModule& PropertyModule = FModuleManager::LoadModuleChecked<FPropertyEditorModule>(\"PropertyEditor\");\n\n\tRegisterSectionMappings();\n\t\n\tPropertyModule.NotifyCustomizationModuleChanged();\n}\n\nvoid FMassGameplayEditorModule::ShutdownModule()\n{\n}\n\nvoid FMassGameplayEditorModule::RegisterSectionMappings()\n{\n\tstatic const FName PropertyEditor(\"PropertyEditor\");\n\tFPropertyEditorModule& PropertyModule = FModuleManager::GetModuleChecked<FPropertyEditorModule>(PropertyEditor);\n\n\t{\n\t\tTSharedRef<FPropertySection> Section = PropertyModule.FindOrCreateSection(\"MassSpawner\", \"Mass\", LOCTEXT(\"Mass\", \"Mass\"));\n\t\tSection->AddCategory(\"Mass\");\n\t\tSection->AddCategory(\"Debug\");\n\t}\n\n\t{\n\t\tTSharedRef<FPropertySection> Section = PropertyModule.FindOrCreateSection(\"MassAgentComponent\", \"Mass\", LOCTEXT(\"Mass\", \"Mass\"));\n\t\tSection->AddCategory(\"Mass\");\n\t}\n}\n#undef LOCTEXT_NAMESPACE\n",
      "lines": 42
    },
    {
      "file_path": "MassGameplay\\MassGameplayEditor\\Private\\MassTraitRepository.cpp",
      "extension": ".cpp",
      "size_bytes": 17030,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n \n#include \"MassTraitRepository.h\"\n#include \"MassEntityTraitBase.h\"\n#include \"Engine/Engine.h\"\n#include \"Engine/World.h\"\n#include \"Misc/CoreDelegates.h\"\n#include \"UObject/UObjectIterator.h\"\n#include \"Editor.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"Misc/UObjectToken.h\"\n#include \"Framework/Docking/TabManager.h\"\n#include \"Logging/MessageLog.h\"\n#include \"MassAssortedFragmentsTrait.h\"\n#include \"DataValidationFixers.h\"\n#include \"MassEntityConfigAsset.h\"\n#include \"MassEntityEditor.h\"\n\n#define LOCTEXT_NAMESPACE \"Mass\"\n\n\nnamespace UE::Mass\n{\n\tnamespace Editor\n\t{\n\t\tTConstArrayView<FName> GetTraitsNameAddingElements(const FName ElementName)\n\t\t{\n\t\t\tif (UMassTraitRepository* TraitRepo = GEditor->GetEditorSubsystem<UMassTraitRepository>())\n\t\t\t{\n\t\t\t\treturn TraitRepo->GetTraitsNameAddingElements(ElementName);\n\t\t\t}\n\t\t\treturn TConstArrayView<FName>();\n\t\t}\n\t}\n\n\tnamespace Private\n\t{\n\t\t/** a helper function that wraps up code for fixing the WeakConfig by adding a trait of class WeakTraitClass */\n\t\tFFixResult AddTraitToConfigFix(const TWeakObjectPtr<UMassEntityConfigAsset>& WeakConfig, const TWeakObjectPtr<UClass>& WeakTraitClass)\n\t\t{\n\t\t\tif (UMassEntityConfigAsset* ConfigAsset = WeakConfig.Get())\n\t\t\t{\n\t\t\t\tif (TSubclassOf<UMassEntityTraitBase> TraitClass = WeakTraitClass.Get())\n\t\t\t\t{\n\t\t\t\t\tif (ConfigAsset->AddTrait(TraitClass) != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn FFixResult::Success();\n\t\t\t\t\t}\n\t\t\t\t\treturn FFixResult::Failure(LOCTEXT(\"FailedToCreateTrait\", \"Failed to create an instance of the trait.\"));\n\t\t\t\t}\n\t\t\t\treturn FFixResult::Failure(LOCTEXT(\"TraitClassNoLongerAvailable\", \"Trait class no longer available.\"));\n\t\t\t}\n\t\t\treturn FFixResult::Failure(LOCTEXT(\"ConfigAssetNoLongerAvailable\", \"Config asset no longer available.\"));\n\t\t}\n\t}\n};\n\n//-----------------------------------------------------------------------------\n// FMassTraitInspectionContext\n//-----------------------------------------------------------------------------\nFMassTraitInspectionContext::FMassTraitInspectionContext()\n\t: EntityTemplate()\n\t, BuildContext(EntityTemplate)\n{\n\tBuildContext.EnableDataInvestigationMode();\n}\n\nFMassTraitInspectionContext::FInvestigationContext::FInvestigationContext(FMassEntityTemplateData& InTemplate)\n\t: Super(InTemplate)\n{\n}\n\nvoid FMassTraitInspectionContext::FInvestigationContext::SetTrait(const UMassEntityTraitBase& Trait)\n{\n\tSetTraitBeingProcessed(&Trait);\n}\n\n//-----------------------------------------------------------------------------\n// UMassTraitRepository\n//-----------------------------------------------------------------------------\nTWeakObjectPtr<UWorld> UMassTraitRepository::GlobalInvestigationWorld;\n\nvoid UMassTraitRepository::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tSuper::Initialize(Collection);\n\n#if WITH_MASSENTITY_DEBUG\n\tOnNewTraitTypeHandle = UMassEntityTraitBase::GetOnNewTraitTypeEvent().AddUObject(this, &UMassTraitRepository::OnNewTraitType);\n\tFMassDebugger::OnDebugEvent.AddUObject(this, &UMassTraitRepository::OnDebugEvent);\n#endif // WITH_MASSENTITY_DEBUG\n}\n\n// @todo we have an opportunity here to make it really flexible. Every message name could be associated with a \n// dedicated TFunction (via some map) that would handle the given message type. This way users could extend or override\n// the way certain events are handled. \n#if WITH_MASSENTITY_DEBUG\nvoid UMassTraitRepository::OnDebugEvent(const FName EventName, FConstStructView Payload, EMassDebugMessageSeverity SeverityOverride)\n{\n\tstatic const FName MissingTraitMessageName = FMassMissingTraitMessage::StaticStruct()->GetFName();\n\tstatic const FName DuplicateElementsMessageName = FMassDuplicateElementsMessage::StaticStruct()->GetFName();\n\n#define OVERRIDABLE_SEVERITY(DefaultSeverity) UE::Mass::Debug::MassSeverityToMessageSeverity(DefaultSeverity, SeverityOverride)\n\n\tif (EventName == MissingTraitMessageName)\n\t{\n\t\tif (const FMassMissingTraitMessage* MissingTraitMessage = Payload.GetPtr<const FMassMissingTraitMessage>())\n\t\t{\n\t\t\tFMessageLog MessageLog(UE::Mass::Editor::MessageLogPageName);\n\n\t\t\tTArray<TSharedRef<FTokenizedMessage>> Messages;\n\n\t\t\tconst FName MissingElement = GetFNameSafe(MissingTraitMessage->MissingType);\n\t\t\tconst FName TraitClassName = MissingTraitMessage->RequestingTrait ? GetFNameSafe(MissingTraitMessage->RequestingTrait->GetClass()) : FName();\n\n\t\t\tTSharedRef<FTokenizedMessage> IntroMessage = Messages.Add_GetRef(FTokenizedMessage::Create(OVERRIDABLE_SEVERITY(EMessageSeverity::Error)))\n\t\t\t\t->AddToken(FAssetNameToken::Create(GetPathNameSafe(MissingTraitMessage->RequestingTrait)\n\t\t\t\t\t, FText::FormatOrdered(LOCTEXT(\"MissingElementSuggestionHeader\"\n\t\t\t\t\t\t, \"Trait {0}\")\n\t\t\t\t\t\t, FText::FromName(TraitClassName))\n\t\t\t\t));\n\n\t\t\t// if the missing elements has been added but removed by some trait that's all we need to tell the user:\n\t\t\tif (MissingTraitMessage->RemovedByTrait)\n\t\t\t{\n\t\t\t\tIntroMessage->AddText(FText::FormatOrdered(LOCTEXT(\"MissingElementSuggestionRemoved\"\n\t\t\t\t\t, \"has unsatisfied dependency of {0}. The type has been explicitly removed by {1}.\")\n\t\t\t\t\t, FText::FromName(MissingElement)\n\t\t\t\t\t, FText::FromName(MissingTraitMessage->RemovedByTrait->GetFName())));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tUMassTraitRepository* TraitRepo = GEditor->GetEditorSubsystem<UMassTraitRepository>();\n\t\t\t\tTConstArrayView<FName> SuggestedTraitNames = TraitRepo\n\t\t\t\t\t? TraitRepo->GetTraitsNameAddingElements(MissingElement)\n\t\t\t\t\t: TConstArrayView<FName>();\n\n\t\t\t\tif (SuggestedTraitNames.Num())\n\t\t\t\t{\n\t\t\t\t\t// The FixController will coordinate IFixer instances and the relevant FFixToken to\n\t\t\t\t\t// ensure that only one of them can be applied. Once any of the fixes is applied\n\t\t\t\t\t// the rest will become inactive (the FFixToken tokens will become grayed out and non-clickable).\n\t\t\t\t\t// @todo at the moment FMutuallyExclusiveFixSet doesn't care whether fixing was successful. \n\t\t\t\t\t//\t\tShould be relatively easy to address but needs to be coordinated with the author\n\t\t\t\t\tTSharedRef<UE::DataValidation::FMutuallyExclusiveFixSet> FixController = MakeShareable(new UE::DataValidation::FMutuallyExclusiveFixSet());\n\n\t\t\t\t\tIntroMessage->AddText(FText::FormatOrdered(LOCTEXT(\"MissingElementSuggestionOptions\"\n\t\t\t\t\t\t, \"has unsatisfied dependency of {0}. The following actions can address it:\")\n\t\t\t\t\t\t, FText::FromName(MissingElement)));\n\n\t\t\t\t\tfor (const FName& SuggestedTraitName : SuggestedTraitNames)\n\t\t\t\t\t{\n\t\t\t\t\t\tbool bFixable = false;\n\t\t\t\t\t\tif (MissingTraitMessage->RequestingTrait)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTWeakObjectPtr<UClass> WeakTraitClass = GetTraitClass(SuggestedTraitName);\n\t\t\t\t\t\t\tUMassEntityConfigAsset* EntityConfigAsset = Cast<UMassEntityConfigAsset>(MissingTraitMessage->RequestingTrait->GetOuter());\n\n\t\t\t\t\t\t\tif (EntityConfigAsset && WeakTraitClass.IsValid())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbFixable = true;\n\n\t\t\t\t\t\t\t\tTWeakObjectPtr<UMassEntityConfigAsset> WeakConfig = EntityConfigAsset;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// capturing FixController to make sure it exists as long as the fixes are alive. The lambda will\n\t\t\t\t\t\t\t\t// be destroyed once the Fixer tokens get destroyed, for example during MessageLog page clearing.\n\t\t\t\t\t\t\t\tTFunction<FFixResult()> ApplyFix = [WeakConfig, WeakTraitClass, _ = FixController]()\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\treturn UE::Mass::Private::AddTraitToConfigFix(WeakConfig, WeakTraitClass);\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tconst TSharedRef<UE::DataValidation::IFixer> Fixer = UE::DataValidation::MakeFix(MoveTemp(ApplyFix));\n\n\t\t\t\t\t\t\t\tFixController->Add(FText::FormatOrdered(LOCTEXT(\"AddMissingTrait\", \"Add {0} trait to {1} entity config\")\n\t\t\t\t\t\t\t\t\t\t\t, FText::FromName(SuggestedTraitName)\n\t\t\t\t\t\t\t\t\t\t\t, FText::FromName(EntityConfigAsset->GetFName()))\n\t\t\t\t\t\t\t\t\t\t, Fixer);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\tif (bFixable == false)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// unfixable (since we're unable to determine the UMassEntityConfigAsset outer), so just report\n\t\t\t\t\t\t\tMessages.Add_GetRef(FTokenizedMessage::Create(OVERRIDABLE_SEVERITY(EMessageSeverity::Info)))\n\t\t\t\t\t\t\t\t->AddText(FText::FormatOrdered(LOCTEXT(\"MissingElementSuggestionUnfixable\", \"\\t{0}\")\n\t\t\t\t\t\t\t\t\t, FText::FromName(SuggestedTraitName)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// for every IFixer instance we created in the loop above the call bellow will create a FFixToken\n\t\t\t\t\t// related to that specific \"fix\". We attach all the tokens to the initial \"here are your options\" message\n\t\t\t\t\tFixController->CreateTokens([IntroMessage](TSharedRef<FFixToken> FixToken)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIntroMessage->AddToken(FixToken);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tIntroMessage->AddText(FText::FormatOrdered(LOCTEXT(\"MissingElementSuggestionNoOptions\"\n\t\t\t\t\t\t, \"has unsatisfied dependency of {0}. There are no registered Traits that provide the type. Try using {1}.\")\n\t\t\t\t\t\t, FText::FromName(MissingElement)\n\t\t\t\t\t\t, FText::FromName(UMassAssortedFragmentsTrait::StaticClass()->GetFName())));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tMessageLog.AddMessages(Messages);\n\t\t}\n\t}\n\telse if (EventName == UE::Mass::Debug::TraitFailedValidation)\n\t{\n\t\tif (const FMassGenericDebugEvent* GenericEvent = Payload.GetPtr<const FMassGenericDebugEvent>())\n\t\t{\n\t\t\tconst UMassEntityTraitBase* Trait = Cast<UMassEntityTraitBase>(GenericEvent->Context);\n\t\t\tFMessageLog MessageLog(UE::Mass::Editor::MessageLogPageName);\n\t\t\tMessageLog.AddMessage(FTokenizedMessage::Create(OVERRIDABLE_SEVERITY(EMessageSeverity::Error)))\n\t\t\t\t->AddToken(FUObjectToken::Create(Trait))\n\t\t\t\t->AddToken(FTextToken::Create(LOCTEXT(\"TraitFailedValidation\", \"trait-specific validation failed\")));\n\t\t}\n\t}\n\telse if (EventName == UE::Mass::Debug::TraitIgnored)\n\t{\n\t\tif (const FMassGenericDebugEvent* GenericEvent = Payload.GetPtr<const FMassGenericDebugEvent>())\n\t\t{\n\t\t\tconst UMassEntityTraitBase* Trait = Cast<UMassEntityTraitBase>(GenericEvent->Context);\n\t\t\tFMessageLog MessageLog(UE::Mass::Editor::MessageLogPageName);\n\t\t\tMessageLog.AddMessage(FTokenizedMessage::Create(OVERRIDABLE_SEVERITY(EMessageSeverity::Warning)))\n\t\t\t\t->AddToken(FUObjectToken::Create(Trait))\n\t\t\t\t->AddToken(FTextToken::Create(LOCTEXT(\"TraitIgnoredTrait\", \"trait was ignored. Check if it's not a duplicate.\")));\n\t\t}\n\t}\n\telse if (EventName == DuplicateElementsMessageName)\n\t{\n\t\tif (const FMassDuplicateElementsMessage* DuplicateElementsMessage = Payload.GetPtr<const FMassDuplicateElementsMessage>())\n\t\t{\n\t\t\tFMessageLog MessageLog(UE::Mass::Editor::MessageLogPageName);\n\t\t\tMessageLog.AddMessage(FTokenizedMessage::Create(OVERRIDABLE_SEVERITY(EMessageSeverity::Warning)))\n\t\t\t\t->AddToken(FUObjectToken::Create(DuplicateElementsMessage->DuplicatingTrait))\n\t\t\t\t->AddToken(FTextToken::Create(FText::FormatOrdered(\n\t\t\t\t\tLOCTEXT(\"TraitFragmentDuplicationWarning\", \"trying to add fragment of type {0} while it has already been added by\")\n\t\t\t\t\t, FText::FromName(GetFNameSafe(DuplicateElementsMessage->Element))\n\t\t\t\t\t)))\n\t\t\t\t->AddToken(FUObjectToken::Create(DuplicateElementsMessage->OriginalTrait))\n\t\t\t\t->AddToken(FTextToken::Create(LOCTEXT(\"TraitFragmentDuplicationWarningCheckConflicts\", \"Check your entity config for conflicting traits\")));\n\t\t}\n\t}\n\n#undef OVERRIDABLE_SEVERITY\n}\n#endif // WITH_MASSENTITY_DEBUG\n\nTConstArrayView<FName> UMassTraitRepository::GetTraitsNameAddingElements(const FName ElementName)\n{\n\tif (bIsRepositoryInitialized == false)\n\t{\n\t\tInitRepository();\n\t}\n\n\tif (TArray<FName>* FoundTraits = ElementTypeToTraitMap.Find(ElementName))\n\t{\n\t\treturn MakeArrayView(*FoundTraits);\n\t}\n\n\treturn TConstArrayView<FName>();\n}\n\nvoid UMassTraitRepository::InitRepository()\n{\n\tif (bIsRepositoryInitialized == true)\n\t{\n\t\treturn;\n\t}\n\n#if WITH_MASSENTITY_DEBUG\n\tUWorld::InitializationValues IVS;\n\tIVS.InitializeScenes(false)\n\t\t.AllowAudioPlayback(false)\n\t\t.RequiresHitProxies(false)\n\t\t.CreatePhysicsScene(false)\n\t\t.CreateNavigation(false)\n\t\t.CreateAISystem(false)\n\t\t.ShouldSimulatePhysics(false)\n\t\t.EnableTraceCollision(false)\n\t\t.SetTransactional(false)\n\t\t.CreateFXSystem(false);\n\n\tInvestigationWorld = UWorld::CreateWorld(EWorldType::Inactive\n\t\t, /*bInformEngineOfWorld=*/false\n\t\t, /*WorldName=*/TEXT(\"MassTraitRepository_InvestigationWorld\")\n\t\t, /*Package=*/nullptr\n\t\t, /*bAddToRoot=*/false\n\t\t, /*InFeatureLevel=*/ERHIFeatureLevel::Num\n\t\t, &IVS\n\t\t, /*bInSkipInitWorld=*/true);\n\tGlobalInvestigationWorld = InvestigationWorld;\n\tcheck(InvestigationWorld);\n\tInvestigationWorld->InitWorld(IVS);\n\n\t// Marking as \"initialized\" so that the OnNewTraitType calls below do their job as expected. \n\tbIsRepositoryInitialized = true;\n\n\t// Using RF_NoFlags to include CDOs (filtered out by default), since that's all we care about.\n\tfor (TObjectIterator<UMassEntityTraitBase> ClassIterator(/*AdditionalExclusionFlags=*/RF_NoFlags); ClassIterator; ++ClassIterator)\n\t{\n\t\tif (ClassIterator && ClassIterator->HasAnyFlags(RF_ClassDefaultObject))\n\t\t{\n\t\t\tOnNewTraitType(**ClassIterator);\n\t\t}\n\t}\n#endif // WITH_MASSENTITY_DEBUG\n}\n\nvoid UMassTraitRepository::Deinitialize()\n{\n#if WITH_MASSENTITY_DEBUG\n\tUMassEntityTraitBase::GetOnNewTraitTypeEvent().Remove(OnNewTraitTypeHandle);\n\n\tif (IsValid(InvestigationWorld))\n\t{\n\t\tInvestigationWorld->DestroyWorld(/*bInformEngineOfWorld=*/false);\n\t}\n#endif // WITH_MASSENTITY_DEBUG\n\n\tSuper::Deinitialize();\n}\n\n#if WITH_MASSENTITY_DEBUG\nvoid UMassTraitRepository::OnNewTraitType(UMassEntityTraitBase& Trait)\n{\n\tif (bIsRepositoryInitialized == false)\n\t{\n\t\t// since the repository is not initialized yet we assume we don't need to collect the information about Trait just yet.\n\t\t// Once InitRepository is called all existing Trait CDOs will be collected and processed.\n\t\treturn;\n\t}\n\n\t// simply ignore abstract classes, we don't care about these since the user will never be able to use them anyway.\n\tif (Trait.GetClass()->HasAnyClassFlags(CLASS_Abstract))\n\t{\n\t\treturn;\n\t}\n\n\tcheckf(Trait.HasAnyFlags(RF_ClassDefaultObject), TEXT(\"Only CDOs are expected here.\"));\n\tcheck(InvestigationWorld);\n\n\tconst FName TraitName = Trait.GetClass()->GetFName();\n\tFTraitAndElements TraitData;\n\n\t// first check if we have this one already. If so we need to remove and re-add in the type got updated\n\tif (TraitClassNameToDataMap.RemoveAndCopyValue(TraitName, TraitData))\n\t{\n\t\tfor (const FName TypeName : TraitData.ElementNames)\n\t\t{\n\t\t\tElementTypeToTraitMap.FindChecked(TypeName).RemoveSingleSwap(TraitName, EAllowShrinking::No);\n\t\t}\n\t}\n\n\tTraitData.TraitClass = Trait.GetClass();\n\tTraitData.ElementNames.Reset();\n\n\tFMassTraitInspectionContext InvestigationContext;\n\tInvestigationContext.BuildContext.SetTrait(Trait);\n\tTrait.BuildTemplate(InvestigationContext.BuildContext, *InvestigationWorld);\n\n\tconst FMassArchetypeCompositionDescriptor& Composition = InvestigationContext.EntityTemplate.GetCompositionDescriptor();\n\n\tfor (FMassFragmentBitSet::FIndexIterator It = Composition.Fragments.GetIndexIterator(); It; ++It)\n\t{\n\t\tconst FName StructName = Composition.Fragments.DebugGetStructTypeName(*It);\n\t\tTraitData.ElementNames.Add(StructName);\n\t}\n\n\tfor (FMassTagBitSet::FIndexIterator It = Composition.Tags.GetIndexIterator(); It; ++It)\n\t{\n\t\tconst FName StructName = Composition.Tags.DebugGetStructTypeName(*It);\n\t\tTraitData.ElementNames.Add(StructName);\n\t}\n\n\tfor (FMassChunkFragmentBitSet::FIndexIterator It = Composition.ChunkFragments.GetIndexIterator(); It; ++It)\n\t{\n\t\tconst FName StructName = Composition.ChunkFragments.DebugGetStructTypeName(*It);\n\t\tTraitData.ElementNames.Add(StructName);\n\t}\n\n\tfor (FMassSharedFragmentBitSet::FIndexIterator It = Composition.SharedFragments.GetIndexIterator(); It; ++It)\n\t{\n\t\tconst FName StructName = Composition.SharedFragments.DebugGetStructTypeName(*It);\n\t\tTraitData.ElementNames.Add(StructName);\n\t}\n\n\tfor (FMassConstSharedFragmentBitSet::FIndexIterator It = Composition.ConstSharedFragments.GetIndexIterator(); It; ++It)\n\t{\n\t\tconst FName StructName = Composition.ConstSharedFragments.DebugGetStructTypeName(*It);\n\t\tTraitData.ElementNames.Add(StructName);\n\t}\n\n\tfor (const FName ElementTypeName : TraitData.ElementNames)\n\t{\n\t\tElementTypeToTraitMap.FindOrAdd(ElementTypeName).Add(TraitName);\n\t}\n\tTraitClassNameToDataMap.Add(TraitName, MoveTemp(TraitData));\n}\n#endif // WITH_MASSENTITY_DEBUG\n\nUWorld* UMassTraitRepository::GetInvestigationWorld()\n{\n\treturn GlobalInvestigationWorld.Get();\n}\n\nTWeakObjectPtr<UClass> UMassTraitRepository::GetTraitClass(const FName TraitClassName) const\n{\n\tif (const FTraitAndElements* Data = TraitClassNameToDataMap.Find(TraitClassName))\n\t{\n\t\treturn Data->TraitClass;\n\t}\n\treturn TWeakObjectPtr<UClass>();\n}\n\n//-----------------------------------------------------------------------------\n// UMassDebugEntitySubsystem\n//-----------------------------------------------------------------------------\nbool UMassDebugEntitySubsystem::ShouldCreateSubsystem(UObject* Outer) const\n{\n\treturn Outer != nullptr && Outer == UMassTraitRepository::GetInvestigationWorld();\n}\n\n#undef LOCTEXT_NAMESPACE ",
      "lines": 426
    },
    {
      "file_path": "MassGameplay\\MassGameplayExternalTraits\\Private\\MassGameplayExternalTraitsModule.cpp",
      "extension": ".cpp",
      "size_bytes": 280,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"IMassGameplayExternalTraitsModule.h\"\n\nclass FMassGameplayExternalTraitsModule : public IMassGameplayExternalTraitsModule\n{\n\n};\n\nIMPLEMENT_MODULE(FMassGameplayExternalTraitsModule, MassGameplayExternalTraits)\n",
      "lines": 10
    },
    {
      "file_path": "MassGameplay\\MassGameplayTestSuite\\Private\\MassEntityTemplateTest.cpp",
      "extension": ".cpp",
      "size_bytes": 9631,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"AITestsCommon.h\"\n#include \"MassEntityTypes.h\"\n#include \"MassEntityTestTypes.h\"\n#include \"MassEntityTemplate.h\"\n#include \"MassEntityTemplateRegistry.h\"\n\n#define LOCTEXT_NAMESPACE \"MassTest\"\n\nUE_DISABLE_OPTIMIZATION_SHIP\n\nnamespace FMassEntityTemplateTest\n{\n\nstruct FEntityTemplateBase : FExecutionTestBase\n{\n\tFMassEntityTemplateRegistry TemplateRegistry;\n\n\tvirtual bool SetUp() override\n\t{\n\t\tif (FExecutionTestBase::SetUp())\n\t\t{\n\t\t\tTemplateRegistry.Initialize(EntityManager);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n};\n\n\nstruct FEntityTemplate_Empty : FEntityTemplateBase\n{\n\tvirtual bool InstantTest() override\n\t{\n\t\tconst FMassEntityTemplateID InitialTemplateID = FMassEntityTemplateIDFactory::Make(FGuid::NewGuid());\n\t\tFMassEntityTemplateData TemplateData;\n\n\t\tconst TSharedRef<FMassEntityTemplate>& FinalizedTemplate = TemplateRegistry.FindOrAddTemplate(InitialTemplateID, MoveTemp(TemplateData));\n\t\t\n\t\tconst FMassEntityTemplateID TemplateID = FinalizedTemplate->GetTemplateID();\n\t\tAITEST_TRUE(\"Empty template is expected to be registered as a valid template\", TemplateID.IsValid());\n\t\tAITEST_EQUAL(\"Empty template's ID is expected to be the same as the input template\", TemplateID, InitialTemplateID);\n\n\t\tconst FMassArchetypeHandle& ArchetypeHandle = FinalizedTemplate->GetArchetype();\n\t\tAITEST_TRUE(\"Empty template is expected to produce a valid (if empty) archetype\", ArchetypeHandle.IsValid());\n\n\t\tconst FMassArchetypeCompositionDescriptor& ArchetypeDescription = EntityManager->GetArchetypeComposition(ArchetypeHandle);\n\t\tAITEST_TRUE(\"Empty template is expected to produce an empty-composition archetype\", ArchetypeDescription.IsEmpty());\n\n\t\treturn true;\n\t}\n};\nIMPLEMENT_AI_INSTANT_TEST(FEntityTemplate_Empty, \"System.Mass.EntityTemplate.Empty\");\n\n\nstruct FEntityTemplate_Composition : FEntityTemplateBase\n{\n\tvirtual bool InstantTest() override\n\t{\n\t\tFMassEntityTemplateData TemplateData;\n\n\t\tTemplateData.AddFragment<FTestFragment_Int>();\n\t\tTemplateData.AddFragment<FTestFragment_Float>();\n\t\tTemplateData.AddChunkFragment<FTestChunkFragment_Int>();\n\t\t{\n\t\t\tFSharedStruct SharedFragment = EntityManager->GetOrCreateSharedFragment<FTestSharedFragment_Int>(0);\n\t\t\tTemplateData.AddSharedFragment(SharedFragment);\n\t\t}\n\t\t{\n\t\t\tFSharedStruct SharedFragment = EntityManager->GetOrCreateSharedFragment<FTestSharedFragment_Float>(1);\n\t\t\tTemplateData.AddSharedFragment(SharedFragment);\n\t\t}\n\t\tTemplateData.Sort();\n\n\t\tFMassArchetypeCompositionDescriptor ExpectedComposition;\n\t\tExpectedComposition.Fragments.Add<FTestFragment_Int>();\n\t\tExpectedComposition.Fragments.Add<FTestFragment_Float>();\n\t\tExpectedComposition.ChunkFragments.Add<FTestChunkFragment_Int>();\n\t\tExpectedComposition.SharedFragments.Add<FTestSharedFragment_Int>();\n\t\tExpectedComposition.SharedFragments.Add<FTestSharedFragment_Float>();\n\n\t\tAITEST_TRUE(\"The composition should end up being the same regardless of whether the data is added via a template data or a composition descriptor\"\n\t\t\t, ExpectedComposition.IsEquivalent(TemplateData.GetCompositionDescriptor()));\n\n\t\tconst FMassEntityTemplateID TemplateID = FMassEntityTemplateIDFactory::Make(FGuid::NewGuid());\n\t\tconst TSharedRef<FMassEntityTemplate>& FinalizedTemplate = TemplateRegistry.FindOrAddTemplate(TemplateID, MoveTemp(TemplateData));\n\n\t\tconst FMassArchetypeHandle& ArchetypeHandle = FinalizedTemplate->GetArchetype();\n\t\tAITEST_TRUE(\"Empty template is expected to produce a valid (if empty) archetype\", ArchetypeHandle.IsValid());\n\n\t\tconst FMassArchetypeCompositionDescriptor& ArchetypeDescription = EntityManager->GetArchetypeComposition(ArchetypeHandle);\n\t\tAITEST_TRUE(\"Empty template is expected to produce an empty-composition archetype\", ArchetypeDescription.IsEquivalent(ExpectedComposition));\n\n\t\treturn true;\n\t}\n};\nIMPLEMENT_AI_INSTANT_TEST(FEntityTemplate_Composition, \"System.Mass.EntityTemplate.Composition\");\n\n\nstruct FEntityTemplate_Trivial : FEntityTemplateBase\n{\n\tvirtual bool InstantTest() override\n\t{\n\t\tFMassEntityTemplateData EmptyTemplateData;\n\t\tFMassEntityTemplateData TemplateDataA;\n\t\tFMassEntityTemplateData TemplateDataB;\n\n\t\tTemplateDataA.AddFragment<FTestFragment_Int>();\n\t\tTemplateDataB.AddFragment<FTestFragment_Int>();\n\t\tconst FGuid NonEmptyTemplateGuid = FGuid::NewGuid();\n\n\t\tconst TSharedRef<FMassEntityTemplate>& FinalizedEmptyTemplate = TemplateRegistry.FindOrAddTemplate(FMassEntityTemplateIDFactory::Make(FGuid::NewGuid()), MoveTemp(EmptyTemplateData));\n\t\tconst TSharedRef<FMassEntityTemplate>& FinalizedTemplateA = TemplateRegistry.FindOrAddTemplate(FMassEntityTemplateIDFactory::Make(NonEmptyTemplateGuid), MoveTemp(TemplateDataA));\n\t\tconst TSharedRef<FMassEntityTemplate>& FinalizedTemplateB = TemplateRegistry.FindOrAddTemplate(FMassEntityTemplateIDFactory::Make(NonEmptyTemplateGuid), MoveTemp(TemplateDataB));\n\n\t\tAITEST_NOT_EQUAL(\"Non-empty template data should result in a finalized template different from the empty one\", FinalizedEmptyTemplate->GetTemplateID(), FinalizedTemplateA->GetTemplateID());\n\t\tAITEST_EQUAL(\"Non-empty template data should result in the very same finalized template\", FinalizedTemplateA, FinalizedTemplateB);\n\n\t\tconst FMassArchetypeHandle& ArchetypeHandle = FinalizedTemplateA->GetArchetype();\n\t\tAITEST_TRUE(\"Non-empty template is expected to produce a valid archetype\", ArchetypeHandle.IsValid());\n\n\t\treturn true;\n\t}\n};\nIMPLEMENT_AI_INSTANT_TEST(FEntityTemplate_Trivial, \"System.Mass.EntityTemplate.Trivial\");\n\n\nstruct FEntityTemplate_Modified : FEntityTemplateBase\n{\n\tvirtual bool InstantTest() override\n\t{\n\t\tUScriptStruct* IntFragmentType = FTestFragment_Int::StaticStruct();\n\t\tFMassArchetypeHandle IntsArchetype = EntityManager->CreateArchetype(MakeArrayView(&IntFragmentType, 1));\n\n\t\tFMassEntityTemplateData OriginalTemplateData;\n\t\tFTestFragment_Int& IntFragment = OriginalTemplateData.AddFragment_GetRef<FTestFragment_Int>();\n\t\tIntFragment.Value = FTestFragment_Int::TestIntValue;\n\n\t\tFMassEntityTemplateData MovedOriginalTemplateData = OriginalTemplateData;\n\t\tconst TSharedRef<FMassEntityTemplate>& FinalizedOriginalTemplate = TemplateRegistry.FindOrAddTemplate(FMassEntityTemplateIDFactory::Make(FGuid::NewGuid()), MoveTemp(MovedOriginalTemplateData));\n\n\t\tFMassEntityTemplateData NewTemplateData(*FinalizedOriginalTemplate);\n\n\t\tAITEST_TRUE(\"Template data created from a finalized template should match the composition of the original data\"\n\t\t\t, NewTemplateData.GetCompositionDescriptor().IsEquivalent(OriginalTemplateData.GetCompositionDescriptor()));\n\n\t\t// need to set a new name, otherwise the hash calculated while creating finalized template will end up being the \n\t\t// same as the original template's. This is the case since we're not using struct's contents while calculating hash (yet).\n\t\tNewTemplateData.SetTemplateName(TEXT(\"ModifiedTemplate\"));\n\t\tFTestFragment_Int* CoppiedFragment = NewTemplateData.GetMutableFragment<FTestFragment_Int>();\n\t\tAITEST_NOT_NULL(\"The fragment instance is expected to be found\", CoppiedFragment);\n\t\tAITEST_EQUAL(\"The fragment instance is expected to have the same value as the original one\", CoppiedFragment->Value, IntFragment.Value);\n\t\tCoppiedFragment->Value = FTestFragment_Int::TestIntValue + 1;\n\t\tAITEST_NOT_EQUAL(\"Modifying the coppied instance of the fragment doesn't affect the original\", CoppiedFragment->Value, IntFragment.Value);\n\n\t\tconst FMassEntityTemplateID NewTemplateID = FMassEntityTemplateIDFactory::MakeFlavor(FinalizedOriginalTemplate->GetTemplateID(), 1);\n\t\tconst TSharedRef<FMassEntityTemplate>& FinalizedModifiedTemplate = TemplateRegistry.FindOrAddTemplate(NewTemplateID, MoveTemp(NewTemplateData));\n\n\t\tAITEST_NOT_EQUAL(\"The original and modified templates should end up resulting in two different templates\", FinalizedModifiedTemplate->GetTemplateID(), FinalizedOriginalTemplate->GetTemplateID());\n\t\tAITEST_EQUAL(\"The original and modified templates should still point at the same archetype\", FinalizedModifiedTemplate->GetArchetype(), FinalizedOriginalTemplate->GetArchetype());\n\n\t\tAITEST_EQUAL(\"The resulting archetype should match the IntArchetypeHandle\", FinalizedModifiedTemplate->GetArchetype(), IntsArchetype);\n\n\t\treturn true;\n\t}\n};\nIMPLEMENT_AI_INSTANT_TEST(FEntityTemplate_Modified, \"System.Mass.EntityTemplate.Modification\");\n\n\n//struct FEntityTemplate_Modified : FEntityTemplateBase\n//{\n//\tvirtual bool InstantTest() override\n//\t{\n//\t\tFMassEntityTemplateData OriginalTemplateData;\n//\t\tOriginalTemplateData.AddFragment<FTestFragment_Int>();\n//\n//\t\tFMassEntityTemplateData OriginalTemplateDataCopy = OriginalTemplateData;\n//\t\tconst TSharedRef<FMassEntityTemplate>& FinalizedOriginalTemplate = TemplateRegistry.FindOrAddTemplate(MoveTemp(OriginalTemplateData));\n//\t\t\n//\n//\t\tAITEST_NOT_EQUAL(\"Non-empty template data should result in a finalized template different from the empty one\", FinalizedEmptyTemplate->GetTemplateID(), FinalizedTemplateA->GetTemplateID());\n//\t\tAITEST_EQUAL(\"Non-empty template data should result in the very same finalized template\", FinalizedTemplateA, FinalizedTemplateB);\n//\n//\t\tconst FMassArchetypeHandle& ArchetypeHandle = FinalizedTemplateA->GetArchetype();\n//\t\tAITEST_TRUE(\"Non-empty template is expected to produce a valid archetype\", ArchetypeHandle.IsValid());*/\n//\n//\t\treturn true;\n//\t}\n//};\n//IMPLEMENT_AI_INSTANT_TEST(FEntityTemplate_Modified, \"System.Mass.EntityTemplate.Modification\");\n\n} // FMassEntityTemplateTest\n\nUE_ENABLE_OPTIMIZATION_SHIP\n\n#undef LOCTEXT_NAMESPACE\n",
      "lines": 197
    },
    {
      "file_path": "MassGameplay\\MassGameplayTestSuite\\Private\\MassGameplayTestSuiteModule.cpp",
      "extension": ".cpp",
      "size_bytes": 320,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassGameplayTestSuiteModule.h\"\n\n#define LOCTEXT_NAMESPACE \"MassTest\"\n\nclass FMassGameplayTestSuiteModule : public IMassGameplayTestSuiteModule\n{\n};\n\nIMPLEMENT_MODULE(FMassGameplayTestSuiteModule, MassGameplayTestSuite)\n\n#undef LOCTEXT_NAMESPACE\n",
      "lines": 13
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Private\\MassLODCollectorProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 4859,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassLODCollectorProcessor.h\"\n#include \"MassLODUtils.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassExecutionContext.h\"\n#include \"Engine/World.h\"\n#include \"MassSimulationLOD.h\"\n\nUMassLODCollectorProcessor::UMassLODCollectorProcessor()\n{\n\tbAutoRegisterWithProcessingPhases = false;\n\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::LODCollector;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::SyncWorldToMass);\n}\n\nvoid UMassLODCollectorProcessor::ConfigureQueries()\n{\n\tFMassEntityQuery BaseQuery;\n\tBaseQuery.AddTagRequirement<FMassCollectLODViewerInfoTag>(EMassFragmentPresence::All);\n\tBaseQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tBaseQuery.AddRequirement<FMassViewerInfoFragment>(EMassFragmentAccess::ReadWrite);\n\tBaseQuery.AddChunkRequirement<FMassSimulationVariableTickChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tBaseQuery.AddChunkRequirement<FMassVisualizationChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tBaseQuery.SetChunkFilter([](const FMassExecutionContext& Context)\n\t{\n\t\treturn FMassVisualizationChunkFragment::IsChunkHandledThisFrame(Context)\n\t\t\t|| FMassSimulationVariableTickChunkFragment::IsChunkHandledThisFrame(Context);\n\t});\n\n\tEntityQuery_VisibleRangeAndOnLOD = BaseQuery;\n\tEntityQuery_VisibleRangeAndOnLOD.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::None);\n\tEntityQuery_VisibleRangeAndOnLOD.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);\n\tEntityQuery_VisibleRangeAndOnLOD.RegisterWithProcessor(*this);\n\n\tEntityQuery_VisibleRangeOnly = BaseQuery;\n\tEntityQuery_VisibleRangeOnly.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::None);\n\tEntityQuery_VisibleRangeOnly.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::All);\n\tEntityQuery_VisibleRangeOnly.RegisterWithProcessor(*this);\n\n\tEntityQuery_OnLODOnly = BaseQuery;\n\tEntityQuery_OnLODOnly.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::All);\n\tEntityQuery_OnLODOnly.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);\n\tEntityQuery_OnLODOnly.RegisterWithProcessor(*this);\n\n\tEntityQuery_NotVisibleRangeAndOffLOD = BaseQuery;\n\tEntityQuery_NotVisibleRangeAndOffLOD.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::All);\n\tEntityQuery_NotVisibleRangeAndOffLOD.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::All);\n\tEntityQuery_NotVisibleRangeAndOffLOD.RegisterWithProcessor(*this);\n\n\tProcessorRequirements.AddSubsystemRequirement<UMassLODSubsystem>(EMassFragmentAccess::ReadOnly);\n}\n\ntemplate <bool bLocalViewersOnly>\nvoid UMassLODCollectorProcessor::CollectLODForChunk(FMassExecutionContext& Context)\n{\n\tTConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\tTArrayView<FMassViewerInfoFragment> ViewerInfoList = Context.GetMutableFragmentView<FMassViewerInfoFragment>();\n\n\tCollector.CollectLODInfo<FTransformFragment, FMassViewerInfoFragment, bLocalViewersOnly, true/*bCollectDistanceToFrustum*/>(Context, LocationList, ViewerInfoList);\n}\n\ntemplate <bool bLocalViewersOnly>\nvoid UMassLODCollectorProcessor::ExecuteInternal(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(Close);\n\t\tEntityQuery_VisibleRangeAndOnLOD.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context) { CollectLODForChunk<bLocalViewersOnly>(Context); });\n\t\tEntityQuery_VisibleRangeOnly.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context) { CollectLODForChunk<bLocalViewersOnly>(Context); });\n\t\tEntityQuery_OnLODOnly.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context) { CollectLODForChunk<bLocalViewersOnly>(Context); });\n\t}\n\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(Far);\n\t\tEntityQuery_NotVisibleRangeAndOffLOD.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context) { CollectLODForChunk<bLocalViewersOnly>(Context); });\n\t}\n}\n\nvoid UMassLODCollectorProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tconst UMassLODSubsystem& LODSubsystem = Context.GetSubsystemChecked<UMassLODSubsystem>();\n\tconst TArray<FViewerInfo>& Viewers = LODSubsystem.GetViewers();\n\tCollector.PrepareExecution(Viewers);\n\n\tUWorld* World = EntityManager.GetWorld();\n\tcheck(World);\n\tif (World->IsNetMode(NM_DedicatedServer))\n\t{\n\t\tExecuteInternal<false/*bLocalViewersOnly*/>(EntityManager, Context);\n\t}\n\telse\n\t{\n\t\tExecuteInternal<true/*bLocalViewersOnly*/>(EntityManager, Context);\n\t}\n\n}\n",
      "lines": 99
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Private\\MassLODDistanceCollectorProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 5445,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassLODDistanceCollectorProcessor.h\"\n#include \"MassLODUtils.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassExecutionContext.h\"\n#include \"Engine/World.h\"\n#include \"MassSimulationLOD.h\"\n\n\n//-----------------------------------------------------------------------------\n// UMassLODDistanceCollectorProcessor\n//-----------------------------------------------------------------------------\nUMassLODDistanceCollectorProcessor::UMassLODDistanceCollectorProcessor()\n{\n\tbAutoRegisterWithProcessingPhases = true;\n\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::LODCollector;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::SyncWorldToMass);\n}\n\nvoid UMassLODDistanceCollectorProcessor::ConfigureQueries()\n{\n\tFMassEntityQuery BaseQuery;\n\tBaseQuery.AddTagRequirement<FMassCollectDistanceLODViewerInfoTag>(EMassFragmentPresence::All);\n\tBaseQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tBaseQuery.AddRequirement<FMassViewerInfoFragment>(EMassFragmentAccess::ReadWrite);\n\tBaseQuery.AddChunkRequirement<FMassSimulationVariableTickChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tBaseQuery.AddChunkRequirement<FMassVisualizationChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tBaseQuery.SetChunkFilter([](const FMassExecutionContext& Context)\n\t{\n\t\treturn FMassVisualizationChunkFragment::IsChunkHandledThisFrame(Context)\n\t\t\t|| FMassSimulationVariableTickChunkFragment::IsChunkHandledThisFrame(Context);\n\t});\n\n\tEntityQuery_RelevantRangeAndOnLOD = BaseQuery;\n\tEntityQuery_RelevantRangeAndOnLOD.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::None);\n\tEntityQuery_RelevantRangeAndOnLOD.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);\n\tEntityQuery_RelevantRangeAndOnLOD.RegisterWithProcessor(*this);\n\n\tEntityQuery_RelevantRangeOnly = BaseQuery;\n\tEntityQuery_RelevantRangeOnly.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::None);\n\tEntityQuery_RelevantRangeOnly.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::All);\n\tEntityQuery_RelevantRangeOnly.RegisterWithProcessor(*this);\n\n\tEntityQuery_OnLODOnly = BaseQuery;\n\tEntityQuery_OnLODOnly.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::All);\n\tEntityQuery_OnLODOnly.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);\n\tEntityQuery_OnLODOnly.RegisterWithProcessor(*this);\n\n\tEntityQuery_NotRelevantRangeAndOffLOD = BaseQuery;\n\tEntityQuery_NotRelevantRangeAndOffLOD.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::All);\n\tEntityQuery_NotRelevantRangeAndOffLOD.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::All);\n\tEntityQuery_NotRelevantRangeAndOffLOD.RegisterWithProcessor(*this);\n\n\tProcessorRequirements.AddSubsystemRequirement<UMassLODSubsystem>(EMassFragmentAccess::ReadOnly);\n}\n\ntemplate <bool bLocalViewersOnly>\nvoid UMassLODDistanceCollectorProcessor::CollectLODForChunk(FMassExecutionContext& Context)\n{\n\tTConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\tTArrayView<FMassViewerInfoFragment> ViewerInfoList = Context.GetMutableFragmentView<FMassViewerInfoFragment>();\n\n\tCollector.CollectLODInfo<FTransformFragment, FMassViewerInfoFragment, bLocalViewersOnly, false/*bCollectDistanceToFrustum*/>(Context, LocationList, ViewerInfoList);\n}\n\ntemplate <bool bLocalViewersOnly>\nvoid UMassLODDistanceCollectorProcessor::ExecuteInternal(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(LODDistanceCollector_Close);\n\t\t{\n\t\t\tTRACE_CPUPROFILER_EVENT_SCOPE(LODDistanceCollector_Close_RelevantRangeAndOnLOD);\n\t\t\tEntityQuery_RelevantRangeAndOnLOD.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context) { CollectLODForChunk<bLocalViewersOnly>(Context); });\n\t\t}\n\t\t{\n\t\t\tTRACE_CPUPROFILER_EVENT_SCOPE(LODDistanceCollector_Close_OnLODOnly);\n\t\t\tEntityQuery_RelevantRangeOnly.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context) { CollectLODForChunk<bLocalViewersOnly>(Context); });\n\t\t}\n\t\t{\n\t\t\tTRACE_CPUPROFILER_EVENT_SCOPE(LODDistanceCollector_Close_OnLODOnly);\n\t\t\tEntityQuery_OnLODOnly.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context) { CollectLODForChunk<bLocalViewersOnly>(Context); });\n\t\t}\n\t}\n\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(LODDistanceCollector_Far);\n\t\tEntityQuery_NotRelevantRangeAndOffLOD.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context) { CollectLODForChunk<bLocalViewersOnly>(Context); });\n\t}\n}\n\nvoid UMassLODDistanceCollectorProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tconst UMassLODSubsystem& LODSubsystem = Context.GetSubsystemChecked<UMassLODSubsystem>();\n\tconst TArray<FViewerInfo>& Viewers = LODSubsystem.GetViewers();\n\tCollector.PrepareExecution(Viewers);\n\n\tUWorld* World = EntityManager.GetWorld();\n\tcheck(World);\n\tif (World->IsNetMode(NM_DedicatedServer))\n\t{\n\t\tExecuteInternal<false/*bLocalViewersOnly*/>(EntityManager, Context);\n\t}\n\telse\n\t{\n\t\tExecuteInternal<true/*bLocalViewersOnly*/>(EntityManager, Context);\n\t}\n}\n",
      "lines": 111
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Private\\MassLODLogic.cpp",
      "extension": ".cpp",
      "size_bytes": 2232,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassLODLogic.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nvoid FMassLODBaseLogic::CacheViewerInformation(TConstArrayView<FViewerInfo> ViewerInfos)\n{\n\tif(Viewers.Num() < ViewerInfos.Num())\n\t{\n\t\tViewers.AddDefaulted(ViewerInfos.Num() - Viewers.Num());\n\t}\n\n\t// Cache viewer info\n\tfor (int ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)\n\t{\n\t\tconst FViewerInfo& Viewer =  ViewerInfos.IsValidIndex(ViewerIdx) ? ViewerInfos[ViewerIdx] : FViewerInfo();\n\t\tconst FMassViewerHandle ViewerHandle =  Viewer.bEnabled ? Viewer.Handle : FMassViewerHandle();\n\n\t\t// Check if it is the same client as before\n\t\tFViewerLODInfo& ViewerLOD = Viewers[ViewerIdx];\n\t\tViewerLOD.bClearData = Viewers[ViewerIdx].Handle != ViewerHandle;\n\t\tViewerLOD.Handle = ViewerHandle;\n\t\tViewerLOD.bLocal = Viewer.IsLocal();\n\n\t\tif (ViewerHandle.IsValid())\n\t\t{\n\t\t\tViewerLOD.Location = Viewer.Location;\n\t\t\tViewerLOD.Direction = Viewer.Rotation.Vector();\n\n\t\t\tif (bBuildFrustumData)\n\t\t\t{\n\t\t\t\tconst float HalfHorizontalFOVAngle = Viewer.FOV * 0.5f;\n\t\t\t\tconst float HalfVerticalFOVAngle = FMath::RadiansToDegrees(FMath::Atan(FMath::Tan(FMath::DegreesToRadians(HalfHorizontalFOVAngle)) * Viewer.AspectRatio));\n\n\t\t\t\tconst FVector RightPlaneNormal = Viewer.Rotation.RotateVector(FRotator(0.0f, HalfHorizontalFOVAngle, 0.0f).RotateVector(FVector::RightVector));\n\t\t\t\tconst FVector LeftPlaneNormal = Viewer.Rotation.RotateVector(FRotator(0.0f, -HalfHorizontalFOVAngle, 0.0f).RotateVector(FVector::LeftVector));\n\t\t\t\tconst FVector TopPlaneNormal = Viewer.Rotation.RotateVector(FRotator(HalfVerticalFOVAngle, 0.0f, 0.0f).RotateVector(FVector::UpVector));\n\t\t\t\tconst FVector BottomPlaneNormal = Viewer.Rotation.RotateVector(FRotator(-HalfVerticalFOVAngle, 0.0f, 0.0f).RotateVector(FVector::DownVector));\n\n\t\t\t\tTArray<FPlane, TInlineAllocator<6>> Planes;\n\t\t\t\tPlanes.Emplace(ViewerLOD.Location, RightPlaneNormal);\n\t\t\t\tPlanes.Emplace(ViewerLOD.Location, LeftPlaneNormal);\n\t\t\t\tPlanes.Emplace(ViewerLOD.Location, TopPlaneNormal);\n\t\t\t\tPlanes.Emplace(ViewerLOD.Location, BottomPlaneNormal);\n\n\t\t\t\tViewerLOD.Frustum = FConvexVolume(Planes);\n\t\t\t}\n\t\t}\n\t}\n}",
      "lines": 51
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Private\\MassLODModule.cpp",
      "extension": ".cpp",
      "size_bytes": 776,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CoreMinimal.h\"\n#include \"IMassLODModule.h\"\n#include \"UObject/CoreRedirects.h\"\n\n\nclass FMassLODModule : public IMassLODModule\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nIMPLEMENT_MODULE(FMassLODModule, MassLOD)\n\n\n\nvoid FMassLODModule::StartupModule()\n{\n\t// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)\n}\n\n\nvoid FMassLODModule::ShutdownModule()\n{\n\t// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n\t// we call this function before unloading the module.\n}\n\n\n\n",
      "lines": 32
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Private\\MassLODSubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 23454,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassLODSubsystem.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"WorldPartition/WorldPartition.h\"\n#include \"WorldPartition/WorldPartitionStreamingSource.h\"\n#include \"Engine/World.h\"\n#include \"MassSimulationSubsystem.h\"\n#include \"Camera/PlayerCameraManager.h\"\n#include \"GameFramework/Pawn.h\"\n#if WITH_EDITOR\n#include \"CoreGlobals.h\" // GIsEditor\n#include \"Editor.h\" // GEditor\n#include \"LevelEditorViewport.h\"\n#include \"Editor/EditorEngine.h\"\n#endif // WITH_EDITOR\n\nnamespace UE::MassLOD\n{\n\tFColor LODColors[] =\n\t{\n\t\tFColor::Red,\n\t\tFColor::Yellow,\n\t\tFColor::Emerald,\n\t\tFColor::White,\n\t};\n\t\n\tnamespace Tweakables\n\t{\n\n\t\tbool bLODSubsystemIncludeAllPlayerControllers = true;\n\t\tnamespace\n\t\t{\n\t\t\tstatic FAutoConsoleVariableRef AnonymousCVars[] = {\n\t\t\t\t{ TEXT(\"mass.LODSubsystem.IncludeAllPlayerControllers\"), bLODSubsystemIncludeAllPlayerControllers, TEXT(\"Include all player controllers, even those without a camera or pawn.\"), ECVF_Default }\n\t\t\t};\n\t\t}\n\t}  // UE::Mass::Tweakables\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\tnamespace Debug\n\t{\n\t\t/** Returns whether getting the UMassLODSubsystem and the bool parameter was successful */\n\t\tbool GetSubsystemAndBoolArgument(const TArray<FString>& Args, UWorld* World, UMassLODSubsystem*& OutMassLODSubsystem, bool& bOutBool)\n\t\t{\n\t\t\tif (!World)\n\t\t\t{\n\t\t\t\tUE_LOG(LogConsoleResponse, Display, TEXT(\"Error: invalid world\"));\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tOutMassLODSubsystem = World->GetSubsystem<UMassLODSubsystem>();\n\t\t\tif (OutMassLODSubsystem == nullptr)\n\t\t\t{\n\t\t\t\tUE_LOG(LogConsoleResponse, Display, TEXT(\"Error: Unable to fetch MassLODSubsystem instance\"));\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (Args.Num() < 1)\n\t\t\t{\n\t\t\t\tUE_LOG(LogConsoleResponse, Display, TEXT(\"Error: Expecting 1 parameter\"));\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!LexTryParseString<bool>(bOutBool, *Args[0]))\n\t\t\t{\n\t\t\t\tUE_LOG(LogConsoleResponse, Display, TEXT(\"Error: parameter must be an integer or a boolean\"));\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tFAutoConsoleCommandWithWorldArgsAndOutputDevice ToggleUsePlayerLocationCmd(\n\t\t\tTEXT(\"mass.debug.LODSubsystem.UsePlayerLocation\"),\n\t\t\tTEXT(\"Sets UMassLODSubsystem::bUsePlayerPawnLocationInsteadOfCamera. Note that this is a command that doesn't retain state and usually needs running both for the client and the server\"),\n\t\t\tFConsoleCommandWithWorldArgsAndOutputDeviceDelegate::CreateLambda([](const TArray<FString>& Args, UWorld* World, FOutputDevice& Ar)\n\t\t\t\t{\n\t\t\t\t\tUMassLODSubsystem* MassLODSubsystem = nullptr;\n\t\t\t\t\tbool bNewValue = false;\n\n\t\t\t\t\tif (GetSubsystemAndBoolArgument(Args, World, MassLODSubsystem, bNewValue))\n\t\t\t\t\t{\n\t\t\t\t\t\tMassLODSubsystem->DebugSetUsePlayerPawnLocationInsteadOfCamera(bNewValue);\n\t\t\t\t\t}\n\t\t\t\t}));\n\n\t\tFAutoConsoleCommandWithWorldArgsAndOutputDevice ToggleGatherPlayers(\n\t\t\tTEXT(\"mass.debug.LODSubsystem.GatherPlayers\"),\n\t\t\tTEXT(\"Sets UMassLODSubsystem::bGatherPlayerControllers. Note that this is a command that doesn't retain state and usually needs running both for the client and the server\"),\n\t\t\tFConsoleCommandWithWorldArgsAndOutputDeviceDelegate::CreateLambda([](const TArray<FString>& Args, UWorld* World, FOutputDevice& Ar)\n\t\t\t\t{\n\t\t\t\t\tUMassLODSubsystem* MassLODSubsystem = nullptr;\n\t\t\t\t\tbool bNewValue = false;\n\n\t\t\t\t\tif (GetSubsystemAndBoolArgument(Args, World, MassLODSubsystem, bNewValue))\n\t\t\t\t\t{\n\t\t\t\t\t\tMassLODSubsystem->DebugSetGatherPlayers(bNewValue);\n\t\t\t\t\t}\n\t\t\t\t})); \n\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n}\n\n//-----------------------------------------------------------------------------\n// UMassLODSubsystem\n//-----------------------------------------------------------------------------\nvoid UMassLODSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tCollection.InitializeDependency(UMassSimulationSubsystem::StaticClass());\n\n\tSuper::Initialize(Collection);\n\t\n\tif (UWorld* World = GetWorld())\n\t{\n\t\tUMassSimulationSubsystem* SimSystem = World->GetSubsystem<UMassSimulationSubsystem>();\n\t\tcheck(SimSystem);\n\t\tSimSystem->GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).AddUObject(this, &UMassLODSubsystem::OnPrePhysicsPhaseStarted);\n#if WITH_EDITOR\n\t\tbIgnorePlayerControllersDueToSimulation = (GEditor && GEditor->IsSimulateInEditorInProgress());\n\t\tbUseEditorLevelViewports = bIgnorePlayerControllersDueToSimulation || (GIsEditor && World->WorldType == EWorldType::Editor);\n#endif // WITH_EDITOR\n\t}\n\n\tSynchronizeViewers();\n}\n\nvoid UMassLODSubsystem::OnPrePhysicsPhaseStarted(float DeltaTime)\n{\n\tSynchronizeViewers();\n}\n\nvoid UMassLODSubsystem::Deinitialize()\n{\n\t// Remove all viewers from the viewer info list\n\tfor (FViewerInfo& ViewerInfo : Viewers)\n\t{\n\t\tif (ViewerInfo.Handle.IsValid())\n\t\t{\n\t\t\t// Safe to remove while iterating as it is a sparse array with a free list\n\t\t\tRemoveViewer(ViewerInfo.Handle);\n\t\t}\n\t}\n\t\n\tif (UWorld* World = GetWorld())\n\t{\n\t\tif (UMassSimulationSubsystem* SimSystem = World->GetSubsystem<UMassSimulationSubsystem>())\n\t\t{\n\t\t\tSimSystem->GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).RemoveAll(this);\n\t\t}\n\t}\n\n\tSuper::Deinitialize();\n}\n\nint32 UMassLODSubsystem::GetValidViewerIdx(const FMassViewerHandle& ViewerHandle) const\n{\n\t// Check against invalid handle\n\tif (!ViewerHandle.IsValid())\n\t{\n\t\treturn INDEX_NONE;\n\t}\n\n\t// Check against removed viewers\n\tconst int32 ViewerIdx = ViewerHandle.GetIndex();\n\tif (ViewerIdx >= Viewers.Num() || ViewerHandle != Viewers[ViewerIdx].Handle)\n\t{\n\t\treturn INDEX_NONE;\n\t}\n\n\treturn ViewerIdx;\n}\n\nconst TArray<FViewerInfo>& UMassLODSubsystem::GetSynchronizedViewers()\n{\n\tSynchronizeViewers();\n\n\treturn Viewers;\n}\n\nFMassViewerHandle UMassLODSubsystem::GetViewerHandleFromActor(const AActor& Actor) const\n{\n\tconst FMassViewerHandle* Handle = ViewerMap.Find(GetTypeHash(Actor.GetFName()));\n\treturn Handle ? *Handle : FMassViewerHandle();\n}\n\n\nFMassViewerHandle UMassLODSubsystem::GetViewerHandleFromStreamingSource(const FName StreamingSourceName) const\n{\n\tconst FMassViewerHandle* Handle = ViewerMap.Find(GetTypeHash(StreamingSourceName));\n\treturn Handle ? *Handle : FMassViewerHandle();\n}\n\nAPlayerController* UMassLODSubsystem::GetPlayerControllerFromViewerHandle(const FMassViewerHandle& ViewerHandle) const\n{\n\tconst int32 ViewerIdx = GetValidViewerIdx(ViewerHandle);\n\treturn ViewerIdx != INDEX_NONE ? Viewers[ViewerIdx].GetPlayerController() : nullptr;\n}\n\nvoid UMassLODSubsystem::SynchronizeViewers()\n{\n\tif (LastSynchronizedFrame == GFrameCounter)\n\t{\n\t\treturn;\n\t}\n\tLastSynchronizedFrame = GFrameCounter;\n\n\tbool bNeedShrinking = false;\n\n\tconst UWorld* World = GetWorld();\n\tUWorldPartition* WorldPartition = World ? World->GetWorldPartition() : nullptr;\n\tconst TArray<FWorldPartitionStreamingSource>& StreamingSources = WorldPartition ? WorldPartition->GetStreamingSources() : TArray<FWorldPartitionStreamingSource>();\n\n\t// Go through the list and check validity and store the valid one into a map\n\tTMap<uint32, FMassViewerHandle> LocalViewerMap;\n\tfor (int32 ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)\n\t{\n\t\tFViewerInfo& ViewerInfo = Viewers[ViewerIdx];\n\t\tif (!ViewerInfo.Handle.IsValid())\n\t\t{\n\t\t\tcheck(ViewerFreeIndices.Find(ViewerIdx) != INDEX_NONE);\n\t\t\tcontinue;\n\t\t}\n\n\t\tAPlayerController* ViewerAsPlayerController = ViewerInfo.GetPlayerController();\n\t\tif (ViewerAsPlayerController != nullptr\n#if WITH_EDITOR\n\t\t\t&& bIgnorePlayerControllersDueToSimulation == false\n#endif // WITH_EDITOR\n\t\t\t)\n\t\t{\n\t\t\tLocalViewerMap.Add(GetTypeHash(ViewerAsPlayerController->GetFName()), ViewerInfo.Handle);\n\t\t}\n\t\telse if (!ViewerInfo.StreamingSourceName.IsNone() && StreamingSources.FindByPredicate([&ViewerInfo](const FWorldPartitionStreamingSource& Source){ return Source.Name == ViewerInfo.StreamingSourceName; }) != nullptr)\n\t\t{\n\t\t\tLocalViewerMap.Add(GetTypeHash(ViewerInfo.StreamingSourceName), ViewerInfo.Handle);\n\t\t}\n#if WITH_EDITOR\n\t\telse if (bUseEditorLevelViewports && ViewerInfo.EditorViewportClientIndex != INDEX_NONE\n\t\t\t&& GEditor && GEditor->GetLevelViewportClients().IsValidIndex(ViewerInfo.EditorViewportClientIndex)\n\t\t\t&& GEditor->GetLevelViewportClients()[ViewerInfo.EditorViewportClientIndex])\n\t\t{\n\t\t\t\n\t\t\tconst int32 HashValue = GetTypeHash(GEditor->GetLevelViewportClients()[ViewerInfo.EditorViewportClientIndex]);\n\t\t\tLocalViewerMap.Add(HashValue, ViewerInfo.Handle);\n\t\t}\n#endif // WITH_EDITOR\n\t\telse\n\t\t{\n\t\t\t// Safe to remove while iterating as it is a sparse array with a free list\n\t\t\tRemoveViewer(ViewerInfo.Handle);\n\t\t\tbNeedShrinking |= ViewerIdx == Viewers.Num() - 1;\n\t\t}\n\t}\n\n\tif (World)\n\t{\n\t\tif (bGatherPlayerControllers)\n\t\t{\n\t\t\t// Now go through all current player controllers and add if they do not exist\n\t\t\tfor (FConstPlayerControllerIterator PlayerIterator = World->GetPlayerControllerIterator(); PlayerIterator; ++PlayerIterator)\n\t\t\t{\n\t\t\t\tAPlayerController* PlayerController = (*PlayerIterator).Get();\n\t\t\t\tcheck(PlayerController);\n\n\t\t\t\t// Check if the controller already exists by trying to remove it from the map which was filled up with controllers we were tracking\n\t\t\t\tif (LocalViewerMap.Remove(GetTypeHash(PlayerController->GetFName())) == 0)\n\t\t\t\t{\n\t\t\t\t\t// If not add it to the list\n\t\t\t\t\tAddPlayerViewer(*PlayerController);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (bGatherStreamingSources)\n\t\t{\n\t\t\t// Now go through all current streaming source and add if they do not exist\n\t\t\tfor (const FWorldPartitionStreamingSource& StreamingSource : StreamingSources)\n\t\t\t{\n\t\t\t\tif (LocalViewerMap.Remove(GetTypeHash(StreamingSource.Name)) == 0)\n\t\t\t\t{\n\t\t\t\t\tAddStreamingSourceViewer(StreamingSource.Name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (bAllowNonPlayerViwerActors)\n\t\t{\n\t\t\tfor (int32 ActorViewerIndex = RegisteredActorViewers.Num() - 1; ActorViewerIndex >= 0; --ActorViewerIndex)\n\t\t\t{\n\t\t\t\tif (RegisteredActorViewers[ActorViewerIndex])\n\t\t\t\t{\n\t\t\t\t\tAddActorViewer(*RegisteredActorViewers[ActorViewerIndex]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tRegisteredActorViewers.RemoveAtSwap(ActorViewerIndex, EAllowShrinking::No);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#if WITH_EDITOR\n\tif (bUseEditorLevelViewports)\n\t{\n\t\tCA_ASSUME(GEditor);\n\t\tfor (int32 ClientIndex = 0; ClientIndex < GEditor->GetLevelViewportClients().Num(); ++ClientIndex)\n\t\t{\n\t\t\tconst FLevelEditorViewportClient* LevelVC = GEditor->GetLevelViewportClients()[ClientIndex];\n\t\t\tif (LevelVC && LevelVC->IsPerspective())\n\t\t\t{\n\t\t\t\tconst int32 HashValue = GetTypeHash(LevelVC);\n\t\t\t\tif (LocalViewerMap.Remove(HashValue) == 0)\n\t\t\t\t{\n\t\t\t\t\tAddEditorViewer(HashValue, ClientIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n#endif // WITH_EDITOR\n\n\t// Anything left in the map need to be removed from the list\n\tfor (TMap<uint32, FMassViewerHandle>::TIterator Itr = LocalViewerMap.CreateIterator(); Itr; ++Itr)\n\t{\n\t\tconst int32 ViewerIdx = Itr->Value.GetIndex();\n\t\tRemoveViewer(Viewers[ViewerIdx].Handle);\n\t\tbNeedShrinking |= ViewerIdx == Viewers.Num() - 1;\n\t}\n\n\tif (bNeedShrinking)\n\t{\n\t\t// Check to shrink the array of viewers if possible\n\t\twhile (Viewers.Num() > 0 && ViewerFreeIndices.Num() > 0 && ViewerFreeIndices.Remove(Viewers.Num() - 1))\n\t\t{\n\t\t\tViewers.Pop(EAllowShrinking::No);\n\t\t}\n\t}\n\n\t// Update location and direction for every type of viewer\n\tfor (FViewerInfo& ViewerInfo : Viewers)\n\t{\n\t\tif (!ViewerInfo.Handle.IsValid())\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (APlayerController* ViewerAsPlayerController = ViewerInfo.GetPlayerController())\n\t\t{\n\t\t\tViewerInfo.bEnabled = !WorldPartition || ViewerAsPlayerController->bEnableStreamingSource;\n\n\t\t\t// Note: Using bUsePlayerPawnLocationInsteadOfCamera will not work correctly with FOV based LOD, since the\n\t\t\t// camera will be at wrong location.  \n\t\t\t// @todo: separate \"player location\" and \"view location\", and use the player location on distance based LOD \n\t\t\t// calculations for stability, and view location in FOV based LOD for view precision.\n\t\t\tif (bUsePlayerPawnLocationInsteadOfCamera && ViewerAsPlayerController->GetPawn())\n\t\t\t{\n\t\t\t\tViewerInfo.Location = ViewerAsPlayerController->GetPawn()->GetActorLocation();\n\t\t\t\tViewerInfo.Rotation = ViewerAsPlayerController->GetPawn()->GetActorRotation();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFVector PlayerCameraLocation(ForceInitToZero);\n\t\t\t\tFRotator PlayerCameraRotation(FRotator::ZeroRotator);\n\t\t\t\tViewerAsPlayerController->GetPlayerViewPoint(PlayerCameraLocation, PlayerCameraRotation);\n\t\t\t\tViewerInfo.Location = PlayerCameraLocation;\n\t\t\t\tViewerInfo.Rotation = PlayerCameraRotation;\n\t\t\t}\n\n\t\t\t// Try to fetch a more precise FOV\n\t\t\tif (ViewerAsPlayerController->PlayerCameraManager)\n\t\t\t{\n\t\t\t\tViewerInfo.FOV = ViewerAsPlayerController->PlayerCameraManager->GetFOVAngle();\n\n\t\t\t\t// @todo need to find a way to retrieve aspect ratio, this does not seems to work\n\t\t\t\t//ViewerInfo.AspectRatio = MinViewInfo.AspectRatio;\n\t\t\t}\n\t\t}\n\t\telse if (AActor* Actor = ViewerInfo.ActorViewer.Get())\n\t\t{\n\t\t\tViewerInfo.Location = Actor->GetActorLocation();\n\t\t\tViewerInfo.Rotation = Actor->GetActorRotation();\n\t\t}\n#if WITH_EDITOR\n\t\telse if (bUseEditorLevelViewports && ViewerInfo.EditorViewportClientIndex != INDEX_NONE)\n\t\t{\n\t\t\tCA_ASSUME(GEditor);\n\t\t\tconst FLevelEditorViewportClient* LevelVC = GEditor->GetLevelViewportClients()[ViewerInfo.EditorViewportClientIndex];\n\t\t\tcheckSlow(LevelVC);\n\t\t\tViewerInfo.bEnabled = LevelVC && LevelVC->IsPerspective();\n\t\t\tViewerInfo.Location = LevelVC->GetViewLocation();\n\t\t\tViewerInfo.Rotation = LevelVC->GetViewRotation();\n\t\t\t\n\t\t}\n#endif // WITH_EDITOR\n\t\telse\n\t\t{\n\t\t\tcheckf(!ViewerInfo.StreamingSourceName.IsNone(), TEXT(\"Expecting to have a streamingsourcename if the playercontroller is null\"));\n\t\t\tconst FWorldPartitionStreamingSource* StreamingSource = StreamingSources.FindByPredicate([&ViewerInfo](const FWorldPartitionStreamingSource& Source) { return Source.Name == ViewerInfo.StreamingSourceName; });\n\t\t\tcheckf(StreamingSource, TEXT(\"Expecting to be pointing to a valid streaming source\"));\n\t\t\tViewerInfo.bEnabled = StreamingSource != nullptr;\n\t\t\tif (StreamingSource)\n\t\t\t{\n\t\t\t\tViewerInfo.Location = StreamingSource->Location;\n\t\t\t\tViewerInfo.Rotation = StreamingSource->Rotation;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid UMassLODSubsystem::AddViewer(APlayerController* PlayerController, FName StreamingSourceName /* = NAME_None*/)\n{\n\tif (PlayerController)\n\t{\n\t\tAddPlayerViewer(*PlayerController);\n\t}\n\telse\n\t{\n\t\tAddStreamingSourceViewer(StreamingSourceName);\n\t}\n}\n\nvoid UMassLODSubsystem::AddPlayerViewer(APlayerController& PlayerController)\n{\n#if WITH_EDITOR\n\tif (bIgnorePlayerControllersDueToSimulation)\n\t{\n\t\treturn;\n\t}\n#endif // WITH_EDITOR\n\n\t// ignore players that don't have a pawn nor a camera\n\tif (UE::MassLOD::Tweakables::bLODSubsystemIncludeAllPlayerControllers == false &&\n\t\tPlayerController.GetPawn() == nullptr\n\t\t&& (bool(PlayerController.PlayerCameraManager) == false\n\t\t\t|| PlayerController.PlayerCameraManager->GetLastFrameCameraCacheTime() == 0.f)\n\t\t)\t\n\t{\n\t\treturn;\n\t}\n\n\tconst int32 HashValue = GetTypeHash(PlayerController.GetFName());\n\n\tFMassViewerHandle& ViewerHandle = ViewerMap.FindOrAdd(HashValue, FMassViewerHandle());\n\tif (ViewerHandle.IsValid())\n\t{\n\t\t// We are only interested to set the player controller if it was not already set.\n\t\tconst int32 ViewerHandleIdx = GetValidViewerIdx(ViewerHandle);\n\t\tcheck(ViewerHandleIdx != INDEX_NONE);\n\n\t\tFViewerInfo& ViewerInfo = Viewers[ViewerHandleIdx];\n\t\tcheck(ViewerInfo.ActorViewer == nullptr);\n\t\tViewerInfo.ActorViewer = &PlayerController;\n\t}\n\telse\n\t{\n\t\t// Add new viewer\n#if UE_ALLOW_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER\n\t\t//for debugging / profiling purposes create DebugNumberViwersPerController\n\t\t//in this case ViewerMap will only contain a hash to the most recent viewer handle created.\n\t\tfor (int Idx = 0; Idx < UE::MassLOD::DebugNumberViewersPerController; ++Idx)\n#endif //UE_ALLOW_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER\n\t\t{\n\t\t\tconst bool bAddNew = ViewerFreeIndices.Num() == 0;\n\t\t\tconst int NewIdx = bAddNew ? Viewers.Num() : ViewerFreeIndices.Pop();\n\t\t\tFViewerInfo& NewViewerInfo = bAddNew ? Viewers.AddDefaulted_GetRef() : Viewers[NewIdx];\n\t\t\tNewViewerInfo.ActorViewer = &PlayerController;\n\t\t\tNewViewerInfo.Handle.Index = NewIdx;\n\t\t\tNewViewerInfo.Handle.SerialNumber = GetNextViewerSerialNumber();\n\t\t\tNewViewerInfo.HashValue = HashValue;\n\n\t\t\tViewerHandle = NewViewerInfo.Handle;\n\n\t\t\tOnViewerAddedDelegate.Broadcast(NewViewerInfo);\n\t\t}\n\t}\n\n\tPlayerController.OnEndPlay.AddUniqueDynamic(this, &UMassLODSubsystem::OnPlayerControllerEndPlay);\n}\n\nvoid UMassLODSubsystem::AddStreamingSourceViewer(const FName StreamingSourceName)\n{\n\tconst int32 HashValue = GetTypeHash(StreamingSourceName);\n\n\tFMassViewerHandle& ViewerHandle = ViewerMap.FindOrAdd(HashValue, FMassViewerHandle());\n\t// only add new viewer if it hasn't been added yet\n\tif (ViewerHandle.IsValid() == false)\n\t{\n\t\tconst bool bAddNew = ViewerFreeIndices.Num() == 0;\n\t\tconst int NewIdx = bAddNew ? Viewers.Num() : ViewerFreeIndices.Pop();\n\t\tFViewerInfo& NewViewerInfo = bAddNew ? Viewers.AddDefaulted_GetRef() : Viewers[NewIdx];\n\t\tNewViewerInfo.StreamingSourceName = StreamingSourceName;\n\t\tNewViewerInfo.Handle.Index = NewIdx;\n\t\tNewViewerInfo.Handle.SerialNumber = GetNextViewerSerialNumber();\n\t\tNewViewerInfo.HashValue = HashValue;\n\n\t\tViewerHandle = NewViewerInfo.Handle;\n\n\t\tOnViewerAddedDelegate.Broadcast(NewViewerInfo);\n\t}\n}\n\nvoid UMassLODSubsystem::AddActorViewer(AActor& ActorViewer)\n{\n\t// @todo we might need to use PathName instead \n\tconst int32 HashValue = GetTypeHash(ActorViewer.GetFName());\n\n\tFMassViewerHandle& ViewerHandle = ViewerMap.FindOrAdd(HashValue, FMassViewerHandle());\n\tif (ViewerHandle.IsValid())\n\t{\n\t\t// We are only interested to set the player controller if it was not already set.\n\t\tconst int32 ViewerHandleIdx = GetValidViewerIdx(ViewerHandle);\n\t\tcheck(ViewerHandleIdx != INDEX_NONE);\n\n\t\tFViewerInfo& ViewerInfo = Viewers[ViewerHandleIdx];\n\t\tViewerInfo.ActorViewer = &ActorViewer;\n\t}\n\telse\n\t{\n\t\t// Add new viewer\n\t\tconst bool bAddNew = ViewerFreeIndices.Num() == 0;\n\t\tconst int NewIdx = bAddNew ? Viewers.Num() : ViewerFreeIndices.Pop();\n\n\t\tFViewerInfo& NewViewerInfo = bAddNew ? Viewers.AddDefaulted_GetRef() : Viewers[NewIdx];\n\t\tNewViewerInfo.ActorViewer = &ActorViewer;\n\t\tNewViewerInfo.Handle.Index = NewIdx;\n\t\tNewViewerInfo.Handle.SerialNumber = GetNextViewerSerialNumber();\n\t\tNewViewerInfo.HashValue = HashValue;\n\t\tViewerHandle = NewViewerInfo.Handle;\n\n\t\tOnViewerAddedDelegate.Broadcast(NewViewerInfo);\n\t}\n}\n\n#if WITH_EDITOR\nvoid UMassLODSubsystem::AddEditorViewer(const int32 HashValue, const int32 ClientIndex)\n{\n\tFMassViewerHandle& ViewerHandle = ViewerMap.FindOrAdd(HashValue, FMassViewerHandle());\n\t// only add new viewer if it hasn't been added yet\n\tif (ViewerHandle.IsValid() == false)\n\t{\n\t\tconst bool bAddNew = ViewerFreeIndices.Num() == 0;\n\t\tconst int NewIdx = bAddNew ? Viewers.Num() : ViewerFreeIndices.Pop();\n\t\tFViewerInfo& NewViewerInfo = bAddNew ? Viewers.AddDefaulted_GetRef() : Viewers[NewIdx];\n\n\t\tusing ClientIndexType = decltype(NewViewerInfo.EditorViewportClientIndex);\n\t\tcheck(ClientIndex >= std::numeric_limits<ClientIndexType>::min() && ClientIndex <= std::numeric_limits<ClientIndexType>::max());\n\t\tNewViewerInfo.EditorViewportClientIndex = static_cast<ClientIndexType>(ClientIndex);\n\t\tNewViewerInfo.Handle.Index = NewIdx;\n\t\tNewViewerInfo.Handle.SerialNumber = GetNextViewerSerialNumber();\n\t\tNewViewerInfo.HashValue = HashValue;\n\n\t\tViewerHandle = NewViewerInfo.Handle;\n\n\t\tOnViewerAddedDelegate.Broadcast(NewViewerInfo);\n\t}\n}\n#endif // WITH_EDITOR\n\nvoid UMassLODSubsystem::RemoveViewer(const FMassViewerHandle& ViewerHandle)\n{\n#if UE_ALLOW_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER\n\n\tconst int32 ViewerHandleIdx = GetValidViewerIdx(ViewerHandle);\n\tcheck(ViewerHandleIdx != INDEX_NONE);\n\n\t//find all the viewer handles the slow way and remove them\n\tfor (int32 ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)\n\t{\n\t\tFViewerInfo& ViewerInfo = Viewers[ViewerIdx];\n\n\t\tif (ViewerInfo.PlayerController == Viewers[ViewerHandleIdx].PlayerController)\n\t\t{\n\t\t\tRemoveViewerInternal(ViewerInfo.Handle);\n\t\t}\n\t}\n\n#else\n\n\tRemoveViewerInternal(ViewerHandle);\n\n#endif //UE_ALLOW_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER\n}\n\nvoid UMassLODSubsystem::RemoveViewerInternal(const FMassViewerHandle& ViewerHandle)\n{\n\tconst int32 ViewerIdx = GetValidViewerIdx(ViewerHandle);\n\tcheck(ViewerIdx != INDEX_NONE);\n\tFViewerInfo& ViewerInfo = Viewers[ViewerIdx];\n\n\tOnViewerRemovedDelegate.Broadcast(ViewerInfo);\n\n\tif (APlayerController* ViewerAsPlayerController = ViewerInfo.GetPlayerController())\n\t{\n\t\tViewerAsPlayerController->OnEndPlay.RemoveDynamic(this, &UMassLODSubsystem::OnPlayerControllerEndPlay);\n\t}\n\n\tViewerMap.Remove(ViewerInfo.HashValue);\n\n\tViewerInfo.Reset();\n\tViewerFreeIndices.Push(ViewerIdx);\n}\n\nvoid UMassLODSubsystem::OnPlayerControllerEndPlay(AActor* Actor, EEndPlayReason::Type EndPlayReason)\n{\n\tAPlayerController* PlayerController = Cast<APlayerController>(Actor);\n\tif (ensure(PlayerController))\n\t{\n\t\tconst FMassViewerHandle ViewerHandle = GetViewerHandleFromActor(*PlayerController);\n\t\tif (ensure(ViewerHandle.IsValid()))\n\t\t{\n\t\t\tRemoveViewer(ViewerHandle);\n\t\t}\n\t}\n}\n\nvoid UMassLODSubsystem::RegisterActorViewer(AActor& ActorViewer)\n{\n\tRegisteredActorViewers.AddUnique(&ActorViewer);\n}\n\nvoid UMassLODSubsystem::UnregisterActorViewer(AActor& ActorViewer)\n{\n\tif (RegisteredActorViewers.RemoveSingleSwap(&ActorViewer, EAllowShrinking::No))\n\t{\n\t\tconst FMassViewerHandle ViewerHandle = GetViewerHandleFromActor(ActorViewer);\n\t\tif (ensure(ViewerHandle.IsValid()))\n\t\t{\n\t\t\tRemoveViewer(ViewerHandle);\n\t\t}\n\t}\n}\n\nFMassViewerHandle UMassLODSubsystem::GetViewerHandleFromPlayerController(const APlayerController* PlayerController) const\n{\n\tPRAGMA_DISABLE_DEPRECATION_WARNINGS\n\treturn PlayerController ? GetViewerHandleFromActor(*PlayerController) : FMassViewerHandle();\n\tPRAGMA_ENABLE_DEPRECATION_WARNINGS\n}\n\n#if WITH_MASSGAMEPLAY_DEBUG\nvoid UMassLODSubsystem::DebugUnregisterActorViewer()\n{\n\tfor (const TObjectPtr<AActor>& RegisteredActorViewer : RegisteredActorViewers)\n\t{\n\t\tif (const AActor* ActorViewer = RegisteredActorViewer)\n\t\t{\n\t\t\tconst FMassViewerHandle ViewerHandle = GetViewerHandleFromActor(*ActorViewer);\n\t\t\tif (ensure(ViewerHandle.IsValid()))\n\t\t\t{\n\t\t\t\tRemoveViewer(ViewerHandle);\n\t\t\t}\n\t\t}\n\t}\n\tRegisteredActorViewers.Reset();\n}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n//-----------------------------------------------------------------------------\n// FViewerInfo\n//-----------------------------------------------------------------------------\nvoid FViewerInfo::Reset()\n{\n\tHandle.Invalidate();\n\tActorViewer = nullptr;\n#if WITH_EDITOR\n\tEditorViewportClientIndex = INDEX_NONE;\n#endif // WITH_EDITOR\n\tHashValue = 0;\n}\n\nbool FViewerInfo::IsLocal() const\n{\n\tAPlayerController* ViewerAsPlayerController = GetPlayerController();\n\treturn (ViewerAsPlayerController && ViewerAsPlayerController->IsLocalController()) || !StreamingSourceName.IsNone()\n#if WITH_EDITOR\n\t\t|| EditorViewportClientIndex != INDEX_NONE\n#endif // WITH_EDITOR\n\t\t;\n}\n\nAPlayerController* FViewerInfo::GetPlayerController() const\n{\n\treturn Cast<APlayerController>(ActorViewer.Get());\n}\n",
      "lines": 684
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Private\\MassLODTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 3131,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassLODTrait.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"Engine/World.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassLODFragments.h\"\n#include \"MassEntityUtils.h\"\n\n\n//-----------------------------------------------------------------------------\n// UMassLODCollectorTrait\n//-----------------------------------------------------------------------------\nvoid UMassLODCollectorTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tBuildContext.AddFragment<FMassViewerInfoFragment>();\n\tBuildContext.AddTag<FMassCollectLODViewerInfoTag>();\n\tBuildContext.RequireFragment<FTransformFragment>();\n}\n\n//-----------------------------------------------------------------------------\n// UMassDistanceLODCollectorTrait\n//-----------------------------------------------------------------------------\nvoid UMassDistanceLODCollectorTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tBuildContext.AddFragment<FMassViewerInfoFragment>();\n\tBuildContext.AddTag<FMassCollectDistanceLODViewerInfoTag>();\n\tBuildContext.RequireFragment<FTransformFragment>();\n}\n\n//-----------------------------------------------------------------------------\n// UMassSimulationLODTrait\n//-----------------------------------------------------------------------------\nvoid UMassSimulationLODTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tBuildContext.RequireFragment<FMassViewerInfoFragment>();\n\tBuildContext.RequireFragment<FTransformFragment>();\n\n\tFMassSimulationLODFragment& LODFragment = BuildContext.AddFragment_GetRef<FMassSimulationLODFragment>();\n\n\t// Start all simulation LOD in the Off \n\tif (Params.bSetLODTags || bEnableVariableTicking || BuildContext.IsInspectingData())\n\t{\n\t\tLODFragment.LOD = EMassLOD::Off;\n\t\tBuildContext.AddTag<FMassOffLODTag>();\n\t}\n\n\tFMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(World);\n\n\tFConstSharedStruct ParamsFragment = EntityManager.GetOrCreateConstSharedFragment(Params);\n\tBuildContext.AddConstSharedFragment(ParamsFragment);\n\n\tFSharedStruct SharedFragment = EntityManager.GetOrCreateSharedFragment<FMassSimulationLODSharedFragment>(FConstStructView::Make(Params), Params);\n\tBuildContext.AddSharedFragment(SharedFragment);\n\n\t// Variable ticking from simulation LOD\n\tif (bEnableVariableTicking || BuildContext.IsInspectingData())\n\t{\n\t\tBuildContext.AddFragment<FMassSimulationVariableTickFragment>();\n\t\tBuildContext.AddChunkFragment<FMassSimulationVariableTickChunkFragment>();\n\n\t\tFConstSharedStruct VariableTickParamsFragment = EntityManager.GetOrCreateConstSharedFragment(VariableTickParams);\n\t\tBuildContext.AddConstSharedFragment(VariableTickParamsFragment);\n\n\t\tFSharedStruct VariableTickSharedFragment = EntityManager.GetOrCreateSharedFragment<FMassSimulationVariableTickSharedFragment>(FConstStructView::Make(VariableTickParams), VariableTickParams);\n\t\tBuildContext.AddSharedFragment(VariableTickSharedFragment);\n\t}\n}\n",
      "lines": 68
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Private\\MassLODUtils.cpp",
      "extension": ".cpp",
      "size_bytes": 2646,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassLODUtils.h\"\n#include \"MassCommandBuffer.h\"\n#include \"HAL/IConsoleManager.h\"\n\nDEFINE_LOG_CATEGORY(LogMassLOD);\n#if WITH_MASSGAMEPLAY_DEBUG\nnamespace UE::MassLOD::Debug\n{\n\tbool bLODCalculationsPaused = false;\n\t\n\tFAutoConsoleVariableRef CVarLODPause(TEXT(\"mass.lod.pause\"), bLODCalculationsPaused, TEXT(\"If non zero will pause all LOD calculations\"));\n} // UE::MassLOD::Debug\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\nnamespace UE::MassLOD\n{\nvoid PushSwapTagsCommand(FMassCommandBuffer& CommandBuffer, const FMassEntityHandle Entity, const EMassLOD::Type PrevLOD, const EMassLOD::Type NewLOD)\n{\n#define CASE_SWAP_TAGS(OldLOD, NewLOD) \\\ncase NewLOD: \\\n\tCommandBuffer.SwapTags<TMassLODTagForLevel<OldLOD>::FTag, TMassLODTagForLevel<NewLOD>::FTag>(Entity); \\\n\tbreak\n\n#define CASE_ADD_TAG(NewLOD) \\\ncase NewLOD: \\\n\tCommandBuffer.AddTag<TMassLODTagForLevel<NewLOD>::FTag>(Entity); \\\n\tbreak\n\n#define DEFAULT_REMOVE_TAG(OldLOD) \\\ncase EMassLOD::Max: /* fall through on purpose */ \\\ndefault: \\\n\tCommandBuffer.RemoveTag<TMassLODTagForLevel<OldLOD>::FTag>(Entity); \\\n\tbreak\n\n\tcheck(PrevLOD != NewLOD);\n\n\tswitch (PrevLOD)\n\t{\n\tcase EMassLOD::High:\n\t\tswitch (NewLOD)\n\t\t{\n\t\t\tCASE_SWAP_TAGS(EMassLOD::High, EMassLOD::Medium);\n\t\t\tCASE_SWAP_TAGS(EMassLOD::High, EMassLOD::Low);\n\t\t\tCASE_SWAP_TAGS(EMassLOD::High, EMassLOD::Off);\n\t\t\tDEFAULT_REMOVE_TAG(EMassLOD::High);\n\t\t}\n\t\tbreak;\n\tcase EMassLOD::Medium:\n\t\tswitch (NewLOD)\n\t\t{\n\t\t\tCASE_SWAP_TAGS(EMassLOD::Medium, EMassLOD::High);\n\t\t\tCASE_SWAP_TAGS(EMassLOD::Medium, EMassLOD::Low);\n\t\t\tCASE_SWAP_TAGS(EMassLOD::Medium, EMassLOD::Off);\n\t\t\tDEFAULT_REMOVE_TAG(EMassLOD::Medium);\n\t\t}\n\t\tbreak;\n\tcase EMassLOD::Low:\n\t\tswitch (NewLOD)\n\t\t{\n\t\t\tCASE_SWAP_TAGS(EMassLOD::Low, EMassLOD::High);\n\t\t\tCASE_SWAP_TAGS(EMassLOD::Low, EMassLOD::Medium);\n\t\t\tCASE_SWAP_TAGS(EMassLOD::Low, EMassLOD::Off);\n\t\t\tDEFAULT_REMOVE_TAG(EMassLOD::Low);\n\t\t}\n\t\tbreak;\n\tcase EMassLOD::Off:\n\t\tswitch (NewLOD)\n\t\t{\n\t\t\tCASE_SWAP_TAGS(EMassLOD::Off, EMassLOD::High);\n\t\t\tCASE_SWAP_TAGS(EMassLOD::Off, EMassLOD::Medium);\n\t\t\tCASE_SWAP_TAGS(EMassLOD::Off, EMassLOD::Low);\n\t\t\tDEFAULT_REMOVE_TAG(EMassLOD::Off);\n\t\t}\n\t\tbreak;\n\tcase EMassLOD::Max:\n\t\tswitch (NewLOD)\n\t\t{\n\t\t\tCASE_ADD_TAG(EMassLOD::High);\n\t\t\tCASE_ADD_TAG(EMassLOD::Medium);\n\t\t\tCASE_ADD_TAG(EMassLOD::Low);\n\t\t\tCASE_ADD_TAG(EMassLOD::Off);\n\t\t\tdefault:\n\t\t\t\tcheckf(false, TEXT(\"Unsupported LOD types!\"));\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tcheckf(false, TEXT(\"Unsupported LOD type!\"));\n\t\tbreak;\n\t}\n\n#undef CASE_SWAP_TAGS\n#undef DEFAULT_REMOVE_TAG\n}\n}",
      "lines": 97
    },
    {
      "file_path": "MassGameplay\\MassLOD\\Private\\MassSimulationLOD.cpp",
      "extension": ".cpp",
      "size_bytes": 10361,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSimulationLOD.h\"\n\n#include \"MassCommonFragments.h\"\n#include \"MassExecutionContext.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassLODUtils.h\"\n\n//-----------------------------------------------------------------------------\n// FMassSimulationLODParameters\n//-----------------------------------------------------------------------------\nFMassSimulationLODParameters::FMassSimulationLODParameters()\n{\n\tLODDistance[EMassLOD::High] = 0.0f;\n\tLODDistance[EMassLOD::Medium] = 5000.0f;\n\tLODDistance[EMassLOD::Low] = 10000.0f;\n\tLODDistance[EMassLOD::Off] = 30000.0f;\n\n\tLODMaxCount[EMassLOD::High] = 100;\n\tLODMaxCount[EMassLOD::Medium] = 200;\n\tLODMaxCount[EMassLOD::Low] = 300;\n\tLODMaxCount[EMassLOD::Off] = INT_MAX;\n}\n\n//-----------------------------------------------------------------------------\n// FMassSimulationVariableTickParameters\n//-----------------------------------------------------------------------------\nFMassSimulationVariableTickParameters::FMassSimulationVariableTickParameters()\n{\n\tTickRates[EMassLOD::High] = 0.0f;\n\tTickRates[EMassLOD::Medium] = 0.5f;\n\tTickRates[EMassLOD::Low] = 1.0f;\n\tTickRates[EMassLOD::Off] = 1.5f;\n}\n\n//-----------------------------------------------------------------------------\n// FMassSimulationLODSharedFragment\n//-----------------------------------------------------------------------------\nFMassSimulationLODSharedFragment::FMassSimulationLODSharedFragment(const FMassSimulationLODParameters& LODParams)\n{\n\tLODCalculator.Initialize(LODParams.LODDistance, LODParams.BufferHysteresisOnDistancePercentage / 100.0f, LODParams.LODMaxCount);\n}\n\n//-----------------------------------------------------------------------------\n// FMassSimulationLODSharedFragment\n//-----------------------------------------------------------------------------\nFMassSimulationVariableTickSharedFragment::FMassSimulationVariableTickSharedFragment(const FMassSimulationVariableTickParameters& TickRateParams)\n{\n\tLODTickRateController.Initialize(TickRateParams.TickRates, TickRateParams.bSpreadFirstSimulationUpdate);\n}\n\n//-----------------------------------------------------------------------------\n// UMassSimulationLODProcessor\n//-----------------------------------------------------------------------------\n\nnamespace UE::MassLOD\n{\n\tint32 bDebugSimulationLOD = 0;\n\tFAutoConsoleVariableRef CVarDebugSimulationLODTest(TEXT(\"mass.debug.SimulationLOD\"), bDebugSimulationLOD, TEXT(\"Debug Simulation LOD\"), ECVF_Cheat);\n} // UE::MassLOD\n\nUMassSimulationLODProcessor::UMassSimulationLODProcessor()\n\t: EntityQuery(*this)\n\t, EntityQueryCalculateLOD(*this)\n\t, EntityQueryAdjustDistances(*this)\n\t, EntityQueryVariableTick(*this)\n\t, EntityQuerySetLODTag(*this)\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::LOD;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LODCollector);\n}\n\nvoid UMassSimulationLODProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassViewerInfoFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassSimulationLODFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddConstSharedRequirement<FMassSimulationLODParameters>();\n\tEntityQuery.AddSharedRequirement<FMassSimulationLODSharedFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddChunkRequirement<FMassSimulationVariableTickChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tEntityQuery.AddSharedRequirement<FMassSimulationVariableTickSharedFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\n\tEntityQueryCalculateLOD = EntityQuery;\n\tEntityQueryCalculateLOD.SetChunkFilter(FMassSimulationVariableTickSharedFragment::ShouldCalculateLODForChunk);\n\n\tEntityQueryAdjustDistances = EntityQuery;\n\tEntityQueryAdjustDistances.SetChunkFilter([](const FMassExecutionContext& Context)\n\t{\n\t\tconst FMassSimulationLODSharedFragment& LODSharedFragment = Context.GetSharedFragment<FMassSimulationLODSharedFragment>();\n\t\treturn LODSharedFragment.bHasAdjustedDistancesFromCount && FMassSimulationVariableTickSharedFragment::ShouldAdjustLODFromCountForChunk(Context);\n\t});\n\n\tEntityQueryVariableTick.AddRequirement<FMassSimulationLODFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQueryVariableTick.AddRequirement<FMassSimulationVariableTickFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQueryVariableTick.AddConstSharedRequirement<FMassSimulationVariableTickParameters>();\n\tEntityQueryVariableTick.AddChunkRequirement<FMassSimulationVariableTickChunkFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQueryVariableTick.AddSharedRequirement<FMassSimulationVariableTickSharedFragment>(EMassFragmentAccess::ReadWrite);\n\n\t// In case where the variableTick isn't enabled, we might need to set LOD tags as if the users still wants them\n\tEntityQuerySetLODTag.AddRequirement<FMassSimulationLODFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuerySetLODTag.AddRequirement<FMassSimulationVariableTickFragment>(EMassFragmentAccess::ReadWrite, EMassFragmentPresence::None);\n\tEntityQuerySetLODTag.AddConstSharedRequirement<FMassSimulationLODParameters>();\n\tEntityQuerySetLODTag.SetChunkFilter([](const FMassExecutionContext& Context)\n\t{\n\t\tconst FMassSimulationLODParameters& LODParams = Context.GetConstSharedFragment<FMassSimulationLODParameters>();\n\t\treturn LODParams.bSetLODTags;\n\t});\n\n\tProcessorRequirements.AddSubsystemRequirement<UMassLODSubsystem>(EMassFragmentAccess::ReadOnly);\n}\n\nvoid UMassSimulationLODProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE(SimulationLOD)\n\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(PrepareExecution);\n\n\t\tconst UMassLODSubsystem& LODSubsystem = Context.GetSubsystemChecked<UMassLODSubsystem>();\n\t\tconst TArray<FViewerInfo>& Viewers = LODSubsystem.GetViewers();\n\n\t\tEntityManager.ForEachSharedFragment<FMassSimulationLODSharedFragment>([&Viewers](FMassSimulationLODSharedFragment& LODSharedFragment)\n\t\t{\n\t\t\tLODSharedFragment.LODCalculator.PrepareExecution(Viewers);\n\t\t});\n\t}\n\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(CalculateLOD);\n\t\tEntityQueryCalculateLOD.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)\n\t\t{\n\t\t\tFMassSimulationLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassSimulationLODSharedFragment>();\n\t\t\tTConstArrayView<FMassViewerInfoFragment> ViewersInfoList = Context.GetFragmentView<FMassViewerInfoFragment>();\n\t\t\tTArrayView<FMassSimulationLODFragment> SimulationLODFragments = Context.GetMutableFragmentView<FMassSimulationLODFragment>();\n\t\t\tLODSharedFragment.LODCalculator.CalculateLOD(Context, ViewersInfoList, SimulationLODFragments);\n\t\t});\n\t}\n\n\tif (bDoAdjustmentFromCount)\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(AdjustDistancesAndLODFromCount);\n\t\tEntityManager.ForEachSharedFragment<FMassSimulationLODSharedFragment>([](FMassSimulationLODSharedFragment& LODSharedFragment)\n\t\t{\n\t\t\tLODSharedFragment.bHasAdjustedDistancesFromCount = LODSharedFragment.LODCalculator.AdjustDistancesFromCount();\n\t\t});\n\n\t\tEntityQueryAdjustDistances.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)\n\t\t{\n\t\t\tFMassSimulationLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassSimulationLODSharedFragment>();\n\t\t\tTConstArrayView<FMassViewerInfoFragment> ViewersInfoList = Context.GetFragmentView<FMassViewerInfoFragment>();\n\t\t\tTArrayView<FMassSimulationLODFragment> SimulationLODFragments = Context.GetMutableFragmentView<FMassSimulationLODFragment>();\n\t\t\tLODSharedFragment.LODCalculator.AdjustLODFromCount(Context, ViewersInfoList, SimulationLODFragments);\n\t\t});\n\t}\n\n\tUWorld* World = EntityManager.GetWorld();\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(VariableTickRates)\n\t\tcheck(World);\n\t\tconst double Time = World->GetTimeSeconds();\n\t\tEntityQueryVariableTick.ForEachEntityChunk(EntityManager, Context, [Time](FMassExecutionContext& Context)\n\t\t{\n\t\t\tFMassSimulationVariableTickSharedFragment& TickRateSharedFragment = Context.GetMutableSharedFragment<FMassSimulationVariableTickSharedFragment>();\n\t\t\tTConstArrayView<FMassSimulationLODFragment> SimulationLODFragments = Context.GetFragmentView<FMassSimulationLODFragment>();\n\t\t\tTArrayView<FMassSimulationVariableTickFragment> SimulationVariableTickFragments = Context.GetMutableFragmentView<FMassSimulationVariableTickFragment>();\n\n\t\t\tTickRateSharedFragment.LODTickRateController.UpdateTickRateFromLOD(Context, SimulationLODFragments, SimulationVariableTickFragments, Time);\n\t\t});\n\t}\n\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(SetLODTags)\n\t\tcheck(World);\n\t\tEntityQuerySetLODTag.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)\n\t\t{\n\t\t\tTConstArrayView<FMassSimulationLODFragment> SimulationLODFragments = Context.GetFragmentView<FMassSimulationLODFragment>();\n\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\tfor (int32 Index = 0; Index < NumEntities; ++Index)\n\t\t\t{\n\t\t\t\tconst FMassSimulationLODFragment& EntityLOD = SimulationLODFragments[Index];\n\t\t\t\tif (EntityLOD.PrevLOD != EntityLOD.LOD)\n\t\t\t\t{\n\t\t\t\t\tconst FMassEntityHandle Entity = Context.GetEntity(Index);\n\t\t\t\t\tUE::MassLOD::PushSwapTagsCommand(Context.Defer(), Entity, EntityLOD.PrevLOD, EntityLOD.LOD);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\t// Optional debug display\n\tif (UE::MassLOD::bDebugSimulationLOD)\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(DebugDisplayLOD);\n\t\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [World](FMassExecutionContext& Context)\n\t\t{\n\t\t\tFMassSimulationLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassSimulationLODSharedFragment>();\n\t\t\tTConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\t\t\tTConstArrayView<FMassSimulationLODFragment> SimulationLODList = Context.GetFragmentView<FMassSimulationLODFragment>();\n\t\t\tLODSharedFragment.LODCalculator.DebugDisplayLOD(Context, SimulationLODList, LocationList, World);\n\t\t});\n\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n}\n",
      "lines": 208
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Private\\MassMovementDelegates.cpp",
      "extension": ".cpp",
      "size_bytes": 296,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassMovementDelegates.h\"\n#include \"CoreMinimal.h\"\n\nnamespace UE::MassMovement::Delegates\n{\n#if WITH_EDITOR\n\tFOnMassMovementNamesChanged MASSMOVEMENT_API OnMassMovementNamesChanged;\n#endif\n} // UEUE::MassMovement::Delegates\n",
      "lines": 11
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Private\\MassMovementFragments.cpp",
      "extension": ".cpp",
      "size_bytes": 1111,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassMovementFragments.h\"\n\nvoid FMassMovementParameters::Update()\n{\n\tfor (FMassMovementStyleParameters& Style : MovementStyles)\n\t{\n\t\tif (Style.DesiredSpeeds.IsEmpty())\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Calculate probability threshold for the speeds, so that a speed can be looked up based in a float in range [0...1]. \n\t\tfloat Total = 0.0f;\n\t\tfor (const FMassMovementStyleSpeedParameters& Speed : Style.DesiredSpeeds)\n\t\t{\n\t\t\tTotal += Speed.Probability;\n\t\t}\n\n\t\tif (Total > KINDA_SMALL_NUMBER)\n\t\t{\n\t\t\tconst float Scale = 1.0f / Total;\n\t\t\tfloat Sum = 0.0f;\n\t\t\tfor (FMassMovementStyleSpeedParameters& Speed : Style.DesiredSpeeds)\n\t\t\t{\n\t\t\t\tSum += Speed.Probability;\n\t\t\t\tSpeed.ProbabilityThreshold = FMath::Min(Sum * Scale, 1.0f);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst float Scale = 1.0f / static_cast<float>(Style.DesiredSpeeds.Num());\n\t\t\tfloat Sum = 0.0f;\n\t\t\tfor (FMassMovementStyleSpeedParameters& Speed : Style.DesiredSpeeds)\n\t\t\t{\n\t\t\t\tSum += 1.0f;\n\t\t\t\tSpeed.ProbabilityThreshold = FMath::Min(Sum * Scale, 1.0f);\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "lines": 42
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Private\\MassMovementModule.cpp",
      "extension": ".cpp",
      "size_bytes": 811,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CoreMinimal.h\"\n#include \"IMassMovementModule.h\"\n#include \"UObject/CoreRedirects.h\"\n\n\nclass FMassMovementModule : public IMassMovementModule\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nIMPLEMENT_MODULE(FMassMovementModule, MassMovement)\n\n\n\nvoid FMassMovementModule::StartupModule()\n{\n\t// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)\n}\n\n\nvoid FMassMovementModule::ShutdownModule()\n{\n\t// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n\t// we call this function before unloading the module.\n}\n\n\n\n",
      "lines": 32
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Private\\MassMovementProcessors.cpp",
      "extension": ".cpp",
      "size_bytes": 3117,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Movement/MassMovementProcessors.h\"\n#include \"MassCommonUtils.h\"\n#include \"MassCommandBuffer.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassMovementFragments.h\"\n#include \"Math/UnrealMathUtility.h\"\n#include \"MassSimulationLOD.h\"\n\n#define UNSAFE_FOR_MT 0\n#define MOVEMENT_DEBUGDRAW 0\t// Set to 1 to see heading debugdraw\n\n//----------------------------------------------------------------------//\n//  UMassApplyMovementProcessor\n//----------------------------------------------------------------------//\n\nUMassApplyMovementProcessor::UMassApplyMovementProcessor()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Movement;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Avoidance);\n}\n\nvoid UMassApplyMovementProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassForceFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);\n\tEntityQuery.AddConstSharedRequirement<FMassMovementParameters>(EMassFragmentPresence::All);\n}\n\nvoid UMassApplyMovementProcessor::Execute(FMassEntityManager& EntityManager,\n\t\t\t\t\t\t\t\t\t\t\t\t\tFMassExecutionContext& Context)\n{\n\t// Clamp max delta time to avoid force explosion on large time steps (i.e. during initialization).\n\tconst float DeltaTime = FMath::Min(0.1f, Context.GetDeltaTimeSeconds());\n\n\tQUICK_SCOPE_CYCLE_COUNTER(HighRes);\n\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this, DeltaTime](FMassExecutionContext& Context)\n\t{\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\n\t\tconst FMassMovementParameters& MovementParams = Context.GetConstSharedFragment<FMassMovementParameters>();\n\n\t\tconst TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();\n\t\tconst TArrayView<FMassForceFragment> ForceList = Context.GetMutableFragmentView<FMassForceFragment>();\n\t\tconst TArrayView<FMassVelocityFragment> VelocityList = Context.GetMutableFragmentView<FMassVelocityFragment>();\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tFMassForceFragment& Force = ForceList[EntityIndex];\n\t\t\tFMassVelocityFragment& Velocity = VelocityList[EntityIndex];\n\t\t\tFTransform& CurrentTransform = LocationList[EntityIndex].GetMutableTransform();\n\n\t\t\t// Update velocity from steering forces.\n\t\t\tVelocity.Value += Force.Value * DeltaTime;\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\t\tif (UE::MassMovement::bFreezeMovement)\n\t\t\t{\n\t\t\t\tVelocity.Value = FVector::ZeroVector;\n\t\t\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t\t\tFVector CurrentLocation = CurrentTransform.GetLocation();\n\t\t\tCurrentLocation += Velocity.Value * DeltaTime;\n\t\t\tCurrentTransform.SetTranslation(CurrentLocation);\n\n\t\t}\n\t});\n}\n\n#undef UNSAFE_FOR_MT\n",
      "lines": 78
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Private\\MassMovementSettings.cpp",
      "extension": ".cpp",
      "size_bytes": 2296,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassMovementSettings.h\"\n#include \"MassMovementDelegates.h\"\n#include \"MassMovementTypes.h\"\n\n//----------------------------------------------------------------------//\n// UMassMovementSettings\n//----------------------------------------------------------------------//\n\nUMassMovementSettings::UMassMovementSettings(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n\t// Create default style\n\tFMassMovementStyle& Style = MovementStyles.AddDefaulted_GetRef();\n\tStyle.Name = FName(TEXT(\"Default\"));\n\tStyle.ID = FGuid::NewGuid();\n}\n\n\n#if WITH_EDITOR\nvoid UMassMovementSettings::PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent)\n{\n\tSuper::PostEditChangeChainProperty(PropertyChangedEvent);\n\n\tFProperty* Property = PropertyChangedEvent.Property;\n\tFProperty* MemberProperty = nullptr;\n\tif (PropertyChangedEvent.PropertyChain.GetActiveMemberNode())\n\t{\n\t\tMemberProperty = PropertyChangedEvent.PropertyChain.GetActiveMemberNode()->GetValue();\n\t}\n\n\tif (MemberProperty && Property)\n\t{\n\t\tif (MemberProperty->GetFName() == GET_MEMBER_NAME_CHECKED(UMassMovementSettings, MovementStyles))\n\t\t{\n\t\t\tconst int32 ArrayIndex = PropertyChangedEvent.GetArrayIndex(MemberProperty->GetFName().ToString());\n\n\t\t\t// Ensure unique ID on duplicated items.\n\t\t\tif (PropertyChangedEvent.ChangeType == EPropertyChangeType::ArrayAdd)\n\t\t\t{\n\t\t\t\tif (MovementStyles.IsValidIndex(ArrayIndex))\n\t\t\t\t{\n\t\t\t\t\tMovementStyles[ArrayIndex].ID = FGuid::NewGuid();\n\t\t\t\t\tMovementStyles[ArrayIndex].Name = FName(TEXT(\"Movement Style\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (PropertyChangedEvent.ChangeType == EPropertyChangeType::Duplicate)\n\t\t\t{\n\t\t\t\tif (MovementStyles.IsValidIndex(ArrayIndex))\n\t\t\t\t{\n\t\t\t\t\tMovementStyles[ArrayIndex].ID = FGuid::NewGuid();\n\t\t\t\t\tMovementStyles[ArrayIndex].Name = FName(MovementStyles[ArrayIndex].Name.ToString() + TEXT(\" Duplicate\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUE::MassMovement::Delegates::OnMassMovementNamesChanged.Broadcast();\n\t\t}\n\t}\n}\n#endif // WITH_EDITOR\n\nconst FMassMovementStyle* UMassMovementSettings::GetMovementStyleByID(const FGuid ID) const\n{\n\treturn MovementStyles.FindByPredicate([ID](const FMassMovementStyle& Style) { return Style.ID == ID; });\n}\n\n",
      "lines": 67
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Private\\MassMovementTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 968,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n#include \"Movement/MassMovementTrait.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassMovementTypes.h\"\n#include \"Engine/World.h\"\n#include \"MassEntityUtils.h\"\n\n\nvoid UMassMovementTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tFMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(World);\n\n\tBuildContext.RequireFragment<FAgentRadiusFragment>();\n\tBuildContext.RequireFragment<FTransformFragment>();\n\n\tBuildContext.AddFragment<FMassVelocityFragment>();\n\tBuildContext.AddFragment<FMassForceFragment>();\n\n\tconst FMassMovementParameters MovementValidated = Movement.GetValidated();\n\tconst FConstSharedStruct MovementFragment = EntityManager.GetOrCreateConstSharedFragment(MovementValidated);\n\tBuildContext.AddConstSharedFragment(MovementFragment);\n}\n",
      "lines": 24
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Private\\MassMovementTypes.cpp",
      "extension": ".cpp",
      "size_bytes": 365,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassMovementTypes.h\"\n#include \"HAL/IConsoleManager.h\"\n\nnamespace UE::MassMovement\n{\n\tint32 bFreezeMovement = 0;\n\tFAutoConsoleVariableRef CVarFreezeMovement(TEXT(\"mass.debug.FreezeMovement\"), bFreezeMovement, TEXT(\"Freeze any movement by common movement processors.\"));\n\n} // UE::MassMovement\n",
      "lines": 11
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Private\\MassSimpleMovementTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 3112,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Example/MassSimpleMovementTrait.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"Engine/World.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassSimulationLOD.h\"\n\n\n//----------------------------------------------------------------------//\n//  UMassSimpleMovementTrait\n//----------------------------------------------------------------------//\nvoid UMassSimpleMovementTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tBuildContext.AddFragment<FTransformFragment>();\n\tBuildContext.AddFragment<FMassVelocityFragment>();\n\tBuildContext.AddTag<FMassSimpleMovementTag>();\t\n}\n\n//----------------------------------------------------------------------//\n//  UMassSimpleMovementProcessor\n//----------------------------------------------------------------------//\nUMassSimpleMovementProcessor::UMassSimpleMovementProcessor()\n\t: EntityQuery(*this)\n{\n\tbAutoRegisterWithProcessingPhases = true;\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Avoidance;\n}\n\nvoid UMassSimpleMovementProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddTagRequirement<FMassSimpleMovementTag>(EMassFragmentPresence::All);\n\n\tEntityQuery.AddRequirement<FMassSimulationVariableTickFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tEntityQuery.AddChunkRequirement<FMassSimulationVariableTickChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\tEntityQuery.SetChunkFilter(&FMassSimulationVariableTickChunkFragment::ShouldTickChunkThisFrame);\n}\n\nvoid UMassSimpleMovementProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, ([this](FMassExecutionContext& Context)\n\t\t{\n\t\t\tconst TConstArrayView<FMassVelocityFragment> VelocitiesList = Context.GetFragmentView<FMassVelocityFragment>();\n\t\t\tconst TArrayView<FTransformFragment> TransformsList = Context.GetMutableFragmentView<FTransformFragment>();\n\t\t\tconst TConstArrayView<FMassSimulationVariableTickFragment> SimVariableTickList = Context.GetFragmentView<FMassSimulationVariableTickFragment>();\n\t\t\tconst bool bHasVariableTick = (SimVariableTickList.Num() > 0);\n\t\t\tconst float WorldDeltaTime = Context.GetDeltaTimeSeconds();\n\t\t\n\t\t\tfor (int32 EntityIndex = 0; EntityIndex < Context.GetNumEntities(); ++EntityIndex)\n\t\t\t{\n\t\t\t\tconst FMassVelocityFragment& Velocity = VelocitiesList[EntityIndex];\n\t\t\t\tFTransform& Transform = TransformsList[EntityIndex].GetMutableTransform();\n\t\t\t\tconst float DeltaTime = bHasVariableTick ? SimVariableTickList[EntityIndex].DeltaTime : WorldDeltaTime;\n\t\t\t\tTransform.SetTranslation(Transform.GetTranslation() + Velocity.Value * DeltaTime);\n\t\t\t}\n\t\t}));\n}\n",
      "lines": 62
    },
    {
      "file_path": "MassGameplay\\MassMovement\\Private\\MassVelocityRandomizerTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 2747,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Example/MassVelocityRandomizerTrait.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"MassExecutionContext.h\"\n#include \"Engine/World.h\"\n#include \"MassMovementFragments.h\"\n#include \"MassCommonUtils.h\"\n\n//----------------------------------------------------------------------//\n//  UMassVelocityRandomizerTrait\n//----------------------------------------------------------------------//\nvoid UMassVelocityRandomizerTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tFMassVelocityFragment& VelocityTemplate = BuildContext.AddFragment_GetRef<FMassVelocityFragment>();\n\t// This is a small @hack to support sending parameters to initializer.\n\t// A proper solution will allow users to specify a \"lambda\" initializer that will be used during creation\n\tVelocityTemplate.Value.X = MinSpeed;\n\tVelocityTemplate.Value.Y = MaxSpeed;\n\tVelocityTemplate.Value.Z = bSetZComponent ? 1.f : 0.f;\n}\n\n//----------------------------------------------------------------------//\n//  UMassRandomVelocityInitializer\n//----------------------------------------------------------------------//\nUMassRandomVelocityInitializer::UMassRandomVelocityInitializer()\n\t: EntityQuery(*this)\n{\n\tObservedType = FMassVelocityFragment::StaticStruct();\n\tOperation = EMassObservedOperation::Add;\n\tRandomStream.Initialize(UE::Mass::Utils::GenerateRandomSeed());\n}\n\nvoid UMassRandomVelocityInitializer::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassRandomVelocityInitializer::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\t// note: the author is aware that the vectors produced below are not distributed uniformly, but it's good enough\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, ([this](FMassExecutionContext& Context)\n\t\t{\n\t\t\tconst TArrayView<FMassVelocityFragment> VelocitiesList = Context.GetMutableFragmentView<FMassVelocityFragment>();\n\t\t\tfor (FMassVelocityFragment& VelocityFragment : VelocitiesList)\n\t\t\t{\n\t\t\t\t// the given VelocityFragment's value is encoding the initialization parameters, as per comment in\n\t\t\t\t// UMassVelocityRandomizerTrait::BuildTemplate\n\t\t\t\tconst FVector RandomVector = VelocityFragment.Value.Z != 0.f \n\t\t\t\t\t? FVector(RandomStream.FRandRange(-1.f, 1.f), RandomStream.FRandRange(-1.f, 1.f), RandomStream.FRandRange(-1.f, 1.f)).GetSafeNormal()\n\t\t\t\t\t: FVector(RandomStream.FRandRange(-1.f, 1.f), RandomStream.FRandRange(-1.f, 1.f), 0).GetSafeNormal();\n\n\t\t\t\tVelocityFragment.Value = RandomVector * RandomStream.FRandRange(VelocityFragment.Value.X, VelocityFragment.Value.Y);\n\t\t\t}\n\t\t}));\n}\n",
      "lines": 56
    },
    {
      "file_path": "MassGameplay\\MassMovementEditor\\Private\\MassMovementEditorModule.cpp",
      "extension": ".cpp",
      "size_bytes": 1227,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassMovementEditorModule.h\"\n#include \"AssetToolsModule.h\"\n#include \"MassMovementStyleRefDetails.h\"\n#include \"Modules/ModuleManager.h\"\n#include \"PropertyEditorModule.h\"\n#include \"ToolMenus.h\"\n\n#define LOCTEXT_NAMESPACE \"MassMovementEditor\"\n\nIMPLEMENT_MODULE(FMassMovementEditorModule, MassMovementEditor)\n\nvoid FMassMovementEditorModule::StartupModule()\n{\n\t// Register the details customizer\n\tFPropertyEditorModule& PropertyModule = FModuleManager::LoadModuleChecked<FPropertyEditorModule>(\"PropertyEditor\");\n\tPropertyModule.RegisterCustomPropertyTypeLayout(TEXT(\"MassMovementStyleRef\"), FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FMassMovementStyleRefDetails::MakeInstance));\n}\n\nvoid FMassMovementEditorModule::ShutdownModule()\n{\n\tUToolMenus::UnRegisterStartupCallback(this);\n\tUToolMenus::UnregisterOwner(this);\n\n\tif (FModuleManager::Get().IsModuleLoaded(TEXT(\"PropertyEditor\")))\n\t{\n\t\tFPropertyEditorModule& PropertyModule = FModuleManager::GetModuleChecked<FPropertyEditorModule>(TEXT(\"PropertyEditor\"));\n\t\tPropertyModule.UnregisterCustomPropertyTypeLayout(TEXT(\"MassMovementStyleRef\"));\n\t}\n}\n\n#undef LOCTEXT_NAMESPACE\n",
      "lines": 33
    },
    {
      "file_path": "MassGameplay\\MassMovementEditor\\Private\\MassMovementStyleRefDetails.cpp",
      "extension": ".cpp",
      "size_bytes": 5120,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n#include \"MassMovementStyleRefDetails.h\"\n#include \"Widgets/DeclarativeSyntaxSupport.h\"\n#include \"DetailWidgetRow.h\"\n#include \"DetailLayoutBuilder.h\"\n#include \"IPropertyUtilities.h\"\n#include \"IDetailChildrenBuilder.h\"\n#include \"Widgets/Input/SComboButton.h\"\n#include \"Framework/MultiBox/MultiBoxBuilder.h\"\n#include \"ScopedTransaction.h\"\n#include \"MassSettings.h\"\n#include \"MassMovementSettings.h\"\n#include \"Modules/ModuleManager.h\"\n#include \"ISettingsModule.h\"\n#include \"MassMovementPropertyUtils.h\"\n\n#define LOCTEXT_NAMESPACE \"MassMovementEditor\"\n\nTSharedRef<IPropertyTypeCustomization> FMassMovementStyleRefDetails::MakeInstance()\n{\n\treturn MakeShareable(new FMassMovementStyleRefDetails);\n}\n\nvoid FMassMovementStyleRefDetails::CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils)\n{\n\tStructProperty = StructPropertyHandle;\n\tPropUtils = StructCustomizationUtils.GetPropertyUtilities().Get();\n\t\n\tNameProperty = StructProperty->GetChildHandle(TEXT(\"Name\"));\n\tIDProperty = StructProperty->GetChildHandle(TEXT(\"ID\"));\n\n\tHeaderRow\n\t\t.NameContent()\n\t\t[\n\t\t\tStructPropertyHandle->CreatePropertyNameWidget()\n\t\t]\n\t\t.ValueContent()\n\t\t[\n\t\t\tSNew(SComboButton)\n\t\t\t.OnGetMenuContent(this, &FMassMovementStyleRefDetails::OnGetProfileContent)\n\t\t\t.ButtonContent()\n\t\t\t[\n\t\t\t\tSNew(STextBlock)\n\t\t\t\t.Text(this, &FMassMovementStyleRefDetails::GetCurrentProfileDesc)\n\t\t\t\t.Font(IDetailLayoutBuilder::GetDetailFont())\n\t\t\t]\n\t\t];\n}\n\nvoid FMassMovementStyleRefDetails::CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder& StructBuilder, IPropertyTypeCustomizationUtils& StructCustomizationUtils)\n{\n}\n\nvoid FMassMovementStyleRefDetails::OnProfileComboChange(int32 Idx)\n{\n\tif (Idx == -1)\n\t{\n\t\tconst UMassSettings* MassSettings = GetDefault<UMassSettings>();\n\t\tcheck(MassSettings);\n\t\t\n\t\t// Goto settings to create new Profile\n\t\tFModuleManager::LoadModuleChecked<ISettingsModule>(\"Settings\").ShowViewer(MassSettings->GetContainerName(), MassSettings->GetCategoryName(), MassSettings->GetSectionName());\n\t\treturn;\n\t}\n\n\tconst UMassMovementSettings* MovementSettings = GetDefault<UMassMovementSettings>();\n\tcheck(MovementSettings);\n\n\tTConstArrayView<FMassMovementStyle> MovementStyles = MovementSettings->GetMovementStyles();\n\tif (MovementStyles.IsValidIndex(Idx))\n\t{\n\t\tconst FMassMovementStyle& Style = MovementStyles[Idx];\n\n\t\tFScopedTransaction Transaction(FText::Format(LOCTEXT(\"SetPropertyValue\", \"Set {0}\"), StructProperty->GetPropertyDisplayName()));\n\n\t\tif (NameProperty)\n\t\t{\n\t\t\tNameProperty->SetValue(Style.Name, EPropertyValueSetFlags::NotTransactable);\n\t\t}\n\n\t\tif (IDProperty)\n\t\t{\n\t\t\tUE::MassMovement::PropertyUtils::SetValue<FGuid>(IDProperty, Style.ID, EPropertyValueSetFlags::NotTransactable);\n\t\t}\n\n\t\tif (PropUtils)\n\t\t{\n\t\t\tPropUtils->ForceRefresh();\n\t\t}\n\t}\n}\n\nTSharedRef<SWidget> FMassMovementStyleRefDetails::OnGetProfileContent() const\n{\n\tFMenuBuilder MenuBuilder(true, NULL);\n\tconst UMassMovementSettings* Settings = GetDefault<UMassMovementSettings>();\n\tcheck(Settings);\n\n\tFUIAction NewItemAction(FExecuteAction::CreateSP(const_cast<FMassMovementStyleRefDetails*>(this), &FMassMovementStyleRefDetails::OnProfileComboChange, -1));\n\tMenuBuilder.AddMenuEntry(LOCTEXT(\"CreateOrEditStyles\", \"Create or Edit Movement Style...\"), TAttribute<FText>(), FSlateIcon(), NewItemAction);\n\tMenuBuilder.AddMenuSeparator();\n\n\tTConstArrayView<FMassMovementStyle> MovementStyles = Settings->GetMovementStyles();\n\tfor (int32 Index = 0; Index < MovementStyles.Num(); Index++)\n\t{\n\t\tconst FMassMovementStyle& Style = MovementStyles[Index];\n\t\tFUIAction ItemAction(FExecuteAction::CreateSP(const_cast<FMassMovementStyleRefDetails*>(this), &FMassMovementStyleRefDetails::OnProfileComboChange, Index));\n\t\tMenuBuilder.AddMenuEntry(FText::FromName(Style.Name), TAttribute<FText>(), FSlateIcon(), ItemAction);\n\t}\n\treturn MenuBuilder.MakeWidget();\n}\n\nFText FMassMovementStyleRefDetails::GetCurrentProfileDesc() const\n{\n\tTOptional<FGuid> IDOpt = UE::MassMovement::PropertyUtils::GetValue<FGuid>(IDProperty);\n\tif (IDOpt.IsSet())\n\t{\n\t\tconst FGuid ID = IDOpt.GetValue();\n\t\tif (ID.IsValid())\n\t\t{\n\t\t\tconst UMassMovementSettings* Settings = GetDefault<UMassMovementSettings>();\n\t\t\tcheck(Settings);\n\t\t\t\n\t\t\tconst FMassMovementStyle* Style = Settings->GetMovementStyleByID(ID);\n\t\t\tif (Style)\n\t\t\t{\n\t\t\t\treturn FText::FromName(Style->Name);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFName OldProfileName;\n\t\t\t\tif (NameProperty && NameProperty->GetValue(OldProfileName) == FPropertyAccess::Success)\n\t\t\t\t{\n\t\t\t\t\tFFormatNamedArguments Args;\n\t\t\t\t\tArgs.Add(TEXT(\"Identifier\"), FText::FromName(OldProfileName));\n\t\t\t\t\treturn FText::Format(LOCTEXT(\"InvalidStyle\", \"Invalid Style {Identifier}\"), Args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn LOCTEXT(\"Invalid\", \"Invalid\");\n\t\t}\n\t}\n\t// TODO: handle multiple values\n\treturn FText();\n}\n\n#undef LOCTEXT_NAMESPACE",
      "lines": 149
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Private\\MassClientBubbleInfoBase.cpp",
      "extension": ".cpp",
      "size_bytes": 3240,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassClientBubbleInfoBase.h\"\n#include \"MassClientBubbleSerializerBase.h\"\n#include \"MassClientBubbleHandler.h\"\n\nAMassClientBubbleInfoBase::AMassClientBubbleInfoBase(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n\tbReplicates = true;\n\tbOnlyRelevantToOwner = true;\n\tbNetUseOwnerRelevancy = true;\n\n\tPrimaryActorTick.bCanEverTick = true;\n\tPrimaryActorTick.TickGroup = TG_LastDemotable;\n\tPrimaryActorTick.bStartWithTickEnabled = false;\n}\n\nvoid AMassClientBubbleInfoBase::SetClientHandle(FMassClientHandle InClientHandle)\n{\n\tfor (const FMassClientBubbleSerializerBase* Serializer : Serializers)\n\t{\n\t\tcheck(Serializer->GetClientHandler());\n\n\t\tSerializer->GetClientHandler()->SetClientHandle(InClientHandle);\n\t}\n}\n\nvoid AMassClientBubbleInfoBase::PostInitProperties()\n{\n\tSuper::PostInitProperties();\n\n\tif (HasAnyFlags(RF_ClassDefaultObject) == false)\n\t{\n\t\tUWorld* World = GetWorld();\n\t\t// This logic can't be done in BeginPlay() as the FMassClientBubbleSerializer::PostReplicatedAdd / PostReplicatedChange will already have been called\n\t\t// but it does need to be done after the world has been initialized.\n\t\tif (World != nullptr && World->bIsWorldInitialized)\n\t\t{\n\t\t\tInitializeForWorld(*World);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOnPostWorldInitDelegateHandle = FWorldDelegates::OnPostWorldInitialization.AddUObject(this, &AMassClientBubbleInfoBase::OnPostWorldInit);\n\t\t}\n\t}\n}\n\nvoid AMassClientBubbleInfoBase::OnPostWorldInit(UWorld* World, const UWorld::InitializationValues)\n{\n\tif (World == GetWorld())\n\t{\n\t\tFWorldDelegates::OnPostWorldInitialization.Remove(OnPostWorldInitDelegateHandle);\n\t\tInitializeForWorld(*World);\n\t}\n}\n\nvoid AMassClientBubbleInfoBase::InitializeForWorld(UWorld& World)\n{\n\tfor (const FMassClientBubbleSerializerBase* Serializer : Serializers)\n\t{\n\t\tIClientBubbleHandlerInterface* Handler = Serializer->GetClientHandler();\n\n\t\tcheckf(Handler, TEXT(\"Handler not set up. Call TClientBubbleHandlerBase::Initialize() before InitializeForWorld gets called\"));\n\t\tHandler->InitializeForWorld(World);\n\t}\n}\n\nvoid AMassClientBubbleInfoBase::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tUWorld* World = GetWorld();\n\tcheck(World);\n\n\t// Allow tick function WITH_MASSGAMEPLAY_DEBUG as we have debug functionality there, otherwise only on the clients.\n#if WITH_MASSGAMEPLAY_DEBUG\n\tPrimaryActorTick.SetTickFunctionEnable(true);\n#else\n\tif (World && World->GetNetMode() == NM_Client)\n\t{\n\t\tPrimaryActorTick.SetTickFunctionEnable(true);\n\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n}\n\nvoid AMassClientBubbleInfoBase::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tfor (FMassClientBubbleSerializerBase* Serializer : Serializers)\n\t{\n\t\tif (ensure(Serializer))\n\t\t{\n\t\t\tSerializer->ShutDown();\n\n\t\t\tcheck(Serializer->GetClientHandler());\n\t\t\tSerializer->GetClientHandler()->Reset();\n\t\t}\n\t}\n\n\tSuper::EndPlay(EndPlayReason);\n}\n\nvoid AMassClientBubbleInfoBase::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfor (const FMassClientBubbleSerializerBase* Serializer : Serializers)\n\t{\n\t\tcheck(Serializer->GetClientHandler());\n\n\t\tSerializer->GetClientHandler()->Tick(DeltaTime);\n\t}\n}\n",
      "lines": 113
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Private\\MassClientBubbleSerializerBase.cpp",
      "extension": ".cpp",
      "size_bytes": 1527,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassClientBubbleSerializerBase.h\"\n#include \"MassClientBubbleHandler.h\"\n#include \"MassEntityUtils.h\"\n\n\nvoid FMassClientBubbleSerializerBase::ShutDown()\n{\n\tEntityManager = nullptr;\n\tWorld = nullptr;\n\tSpawnerSubsystem = nullptr;\n\tReplicationSubsystem = nullptr;\n}\n\nvoid FMassClientBubbleSerializerBase::InitializeForWorld(UWorld& InWorld)\n{\n\tWorld = &InWorld;\n\n\tSpawnerSubsystem = InWorld.GetSubsystem<UMassSpawnerSubsystem>();\n\tcheck(SpawnerSubsystem);\n\n\tReplicationSubsystem = InWorld.GetSubsystem<UMassReplicationSubsystem>();\n\n\tEntityManager = UE::Mass::Utils::GetEntityManagerChecked(InWorld).AsShared();\n\n\tcheckf(ClientHandler, TEXT(\"ClientHandler must be setup! See SetClientHandler()\"));\n}\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\nvoid FMassClientBubbleSerializerBase::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize) const\n{\n\tcheck(ClientHandler);\n\n\tClientHandler->PreReplicatedRemove(RemovedIndices, FinalSize);\n}\n\nvoid FMassClientBubbleSerializerBase::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize) const\n{\n\tcheck(ClientHandler);\n\n\tClientHandler->PostReplicatedAdd(AddedIndices, FinalSize);\n}\n\nvoid FMassClientBubbleSerializerBase::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize) const\n{\n\tcheck(ClientHandler);\n\n\tClientHandler->PostReplicatedChange(ChangedIndices, FinalSize);\n}\n#endif //UE_REPLICATION_COMPILE_CLIENT_CODE\n",
      "lines": 51
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Private\\MassReplicationFragments.cpp",
      "extension": ".cpp",
      "size_bytes": 3705,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassReplicationFragments.h\"\n#include \"MassReplicationSubsystem.h\"\n#include \"MassReplicationProcessor.h\"\n#include \"MassExecutionContext.h\"\n#include \"Engine/World.h\"\n\n//----------------------------------------------------------------------//\n// UMassNetworkIDFragmentInitializer \n//----------------------------------------------------------------------//\nUMassNetworkIDFragmentInitializer::UMassNetworkIDFragmentInitializer()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)(EProcessorExecutionFlags::Standalone | EProcessorExecutionFlags::Server);\n\tObservedType = FMassNetworkIDFragment::StaticStruct();\n\tOperation = EMassObservedOperation::Add;\n}\n\nvoid UMassNetworkIDFragmentInitializer::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassNetworkIDFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddSubsystemRequirement<UMassReplicationSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassNetworkIDFragmentInitializer::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tQUICK_SCOPE_CYCLE_COUNTER(MassProcessor_InitNetworkID_Run);\n\n\tconst UWorld* World = EntityManager.GetWorld();\n\tconst ENetMode NetMode = World->GetNetMode();\n\n\tif (NetMode != NM_Client)\n\t{\n#if UE_REPLICATION_COMPILE_SERVER_CODE\n\t\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)\n\t\t\t{\n\t\t\t\tUMassReplicationSubsystem& ReplicationSubsystem = Context.GetMutableSubsystemChecked<UMassReplicationSubsystem>();\n\n\t\t\t\tconst TArrayView<FMassNetworkIDFragment> NetworkIDList = Context.GetMutableFragmentView<FMassNetworkIDFragment>();\n\t\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\n\t\t\t\tfor (int32 Idx = 0; Idx < NumEntities; ++Idx)\n\t\t\t\t{\n\t\t\t\t\tNetworkIDList[Idx].NetID = ReplicationSubsystem.GetNextAvailableMassNetID();\n\t\t\t\t}\n\t\t\t});\n#endif //UE_REPLICATION_COMPILE_SERVER_CODE\n\t}\n}\n\n//----------------------------------------------------------------------//\n//  FMassReplicationParameters\n//----------------------------------------------------------------------//\n\nFMassReplicationParameters::FMassReplicationParameters()\n{\n\tLODDistance[EMassLOD::High] = 0.f;\n\tLODDistance[EMassLOD::Medium] = 1000.f;\n\tLODDistance[EMassLOD::Low] = 2500.f;\n\tLODDistance[EMassLOD::Off] = 5000.f;\n\n\tLODMaxCount[EMassLOD::High] = 1600;\n\tLODMaxCount[EMassLOD::Medium] = 3200;\n\tLODMaxCount[EMassLOD::Low] = 48000;\n\tLODMaxCount[EMassLOD::Off] = 0;\n\n\tLODMaxCountPerViewer[EMassLOD::High] = 100;\n\tLODMaxCountPerViewer[EMassLOD::Medium] = 200;\n\tLODMaxCountPerViewer[EMassLOD::Low] = 300;\n\tLODMaxCountPerViewer[EMassLOD::Off] = 0;\n\n\tUpdateInterval[EMassLOD::High] = 0.1f;\n\tUpdateInterval[EMassLOD::Medium] = 0.2f;\n\tUpdateInterval[EMassLOD::Low] = 0.3f;\n\tUpdateInterval[EMassLOD::Off] = 0.5f;\n}\n\n//----------------------------------------------------------------------//\n//  FMassReplicationSharedFragment\n//----------------------------------------------------------------------//\nFMassReplicationSharedFragment::FMassReplicationSharedFragment(UMassReplicationSubsystem& ReplicationSubsystem, const FMassReplicationParameters& Params)\n{\n\tLODCalculator.Initialize(Params.LODDistance, Params.BufferHysteresisOnDistancePercentage / 100.0f, Params.LODMaxCountPerViewer); // Setting the LODMaxCoundPerViewer as the MAXCount as the processor will be called for each client and will recalculate it per client\n\tBubbleInfoClassHandle = ReplicationSubsystem.GetBubbleInfoClassHandle(Params.BubbleInfoClass);\n\n\tCachedReplicator = Params.ReplicatorClass.GetDefaultObject();\n\tcheckf(CachedReplicator, TEXT(\"Expecting a valid replicator class\"))\n}",
      "lines": 89
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Private\\MassReplicationGridProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 8635,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassReplicationGridProcessor.h\"\n#include \"MassReplicationSubsystem.h\"\n#include \"MassReplicationTypes.h\"\n#include \"MassReplicationFragments.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassExecutionContext.h\"\n#include \"Engine/World.h\"\n\n//----------------------------------------------------------------------//\n//  UMassReplicationGridProcessor\n//----------------------------------------------------------------------//\nUMassReplicationGridProcessor::UMassReplicationGridProcessor()\n\t: AddToGridEntityQuery(*this)\n\t, UpdateGridEntityQuery(*this)\n\t, RemoveFromGridEntityQuery(*this)\n{\n#if !UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE\n\tExecutionFlags = int32(EProcessorExecutionFlags::Server);\n#else\n\tExecutionFlags = int32(EProcessorExecutionFlags::AllNetModes);\n#endif // UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE\n\n\tProcessingPhase = EMassProcessingPhase::PostPhysics;\n}\n\nvoid UMassReplicationGridProcessor::ConfigureQueries()\n{\n\tAddToGridEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tAddToGridEntityQuery.AddRequirement<FMassReplicationGridCellLocationFragment>(EMassFragmentAccess::ReadWrite);\n\tAddToGridEntityQuery.AddSubsystemRequirement<UMassReplicationSubsystem>(EMassFragmentAccess::ReadWrite);\n\n\t// copying AddToGridEntityQuery to RemoveFromGridEntityQuery now because RemoveFromGridEntityQuery doesn't utilize \n\t// the other fragments AddToGridEntityQuery relies on\n\tRemoveFromGridEntityQuery = AddToGridEntityQuery;\n\n\t// FAgentRadiusFragment is optional since it's not strictly required for the provided functionality \n\tAddToGridEntityQuery.AddRequirement<FAgentRadiusFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);\n\t// we don't care about \"off-lod\" entities\n\tAddToGridEntityQuery.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);\n\n\t// storing the state in UpdateGridEntityQuery, after that both queries diverge in terms of requirements\n\tUpdateGridEntityQuery = AddToGridEntityQuery;\n\t\t\n\tAddToGridEntityQuery.AddTagRequirement<FMassInReplicationGridTag>(EMassFragmentPresence::None);\n\t\t\n\tUpdateGridEntityQuery.AddTagRequirement<FMassInReplicationGridTag>(EMassFragmentPresence::All);\n\n\tRemoveFromGridEntityQuery.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::All);\n\tRemoveFromGridEntityQuery.AddTagRequirement<FMassInReplicationGridTag>(EMassFragmentPresence::All);\n}\n\nvoid UMassReplicationGridProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tAddToGridEntityQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)\n\t{\n\t\tUMassReplicationSubsystem& ReplicationSubsystem = Context.GetMutableSubsystemChecked<UMassReplicationSubsystem>();\n\t\tFReplicationHashGrid2D& ReplicationGrid = ReplicationSubsystem.GetGridMutable();\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\n\t\tTConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\t\tTConstArrayView<FAgentRadiusFragment> RadiusList = Context.GetFragmentView<FAgentRadiusFragment>();\n\t\tTArrayView<FMassReplicationGridCellLocationFragment> ReplicationCellLocationList = Context.GetMutableFragmentView<FMassReplicationGridCellLocationFragment>();\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\t// Add to the grid\n\t\t\tconst FVector NewPos = LocationList[EntityIndex].GetTransform().GetLocation();\n\t\t\t// note that 0-radius is fine, the underlying THierarchicalHashGrid2D supports that just fine\n\t\t\tconst float Radius = RadiusList.IsEmpty() ? 0.f : RadiusList[EntityIndex].Radius;\n\n\t\t\tconst FMassEntityHandle EntityHandle = Context.GetEntity(EntityIndex);\n\t\t\tconst FBox NewBounds(NewPos - FVector(Radius, Radius, 0.f), NewPos + FVector(Radius, Radius, 0.f));\n\t\t\tReplicationCellLocationList[EntityIndex].CellLoc = ReplicationGrid.Add(EntityHandle, NewBounds);\n\n\t\t\tContext.Defer().AddTag<FMassInReplicationGridTag>(EntityHandle);\n\t\t}\n\t});\n\n\tUpdateGridEntityQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)\n\t{\n\t\tUMassReplicationSubsystem& ReplicationSubsystem = Context.GetMutableSubsystemChecked<UMassReplicationSubsystem>();\n\t\tFReplicationHashGrid2D& ReplicationGrid = ReplicationSubsystem.GetGridMutable();\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\n\t\tTConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\t\tTConstArrayView<FAgentRadiusFragment> RadiusList = Context.GetFragmentView<FAgentRadiusFragment>();\n\t\tTArrayView<FMassReplicationGridCellLocationFragment> ReplicationCellLocationList = Context.GetMutableFragmentView<FMassReplicationGridCellLocationFragment>();\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\t// Update position in grid\n\t\t\tconst FVector NewPos = LocationList[EntityIndex].GetTransform().GetLocation();\n\t\t\t// note that 0-radius is fine, the underlying THierarchicalHashGrid2D supports that just fine\n\t\t\tconst float Radius = RadiusList.IsEmpty() ? 0.f : RadiusList[EntityIndex].Radius;\n\t\t\tconst FMassEntityHandle EntityHandle = Context.GetEntity(EntityIndex);\n\t\t\tconst FBox NewBounds(NewPos - FVector(Radius, Radius, 0.f), NewPos + FVector(Radius, Radius, 0.f));\n\t\t\tReplicationCellLocationList[EntityIndex].CellLoc = ReplicationGrid.Move(EntityHandle, ReplicationCellLocationList[EntityIndex].CellLoc, NewBounds);\n\n#if WITH_MASSGAMEPLAY_DEBUG && 0\n\t\t\tconst FDebugContext BaseDebugContext(this, LogMassReplication, nullptr, EntityHandle);\n\t\t\tif (DebugIsSelected(EntityHandle))\n\t\t\t{\n\t\t\t\tFBox Box = ReplicationGrid.CalcCellBounds(ReplicationCellLocationList[EntityIndex].CellLoc);\n\t\t\t\tBox.Max.Z += 200.f;\n\t\t\t\tDebugDrawBox(BaseDebugContext, Box, FColor::Yellow);\n\t\t\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t\t}\n\t});\n\n\tRemoveFromGridEntityQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)\n\t{\n\t\tUMassReplicationSubsystem& ReplicationSubsystem = Context.GetMutableSubsystemChecked<UMassReplicationSubsystem>();\n\t\tFReplicationHashGrid2D& ReplicationGrid = ReplicationSubsystem.GetGridMutable();\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\n\t\tTArrayView<FMassReplicationGridCellLocationFragment> ReplicationCellLocationList = Context.GetMutableFragmentView<FMassReplicationGridCellLocationFragment>();\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tconst FMassEntityHandle EntityHandle = Context.GetEntity(EntityIndex);\n\t\t\tReplicationGrid.Remove(EntityHandle, ReplicationCellLocationList[EntityIndex].CellLoc);\n\t\t\tReplicationCellLocationList[EntityIndex].CellLoc = FReplicationHashGrid2D::FCellLocation();\n\n\t\t\tContext.Defer().RemoveTag<FMassInReplicationGridTag>(EntityHandle);\n\t\t}\n\t});\n}\n\n//----------------------------------------------------------------------//\n//  UMassReplicationGridRemoverProcessor\n//----------------------------------------------------------------------//\nUMassReplicationGridRemoverProcessor::UMassReplicationGridRemoverProcessor()\n\t: EntityQuery(*this)\n{\n\tObservedType = FMassReplicationGridCellLocationFragment::StaticStruct();\n\tOperation = EMassObservedOperation::Remove;\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n}\n\nvoid UMassReplicationGridRemoverProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassReplicationGridCellLocationFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddSubsystemRequirement<UMassReplicationSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassReplicationGridRemoverProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)\n\t{\n\t\tUMassReplicationSubsystem& ReplicationSubsystem = Context.GetMutableSubsystemChecked<UMassReplicationSubsystem>();\n\t\tFReplicationHashGrid2D& ReplicationGrid = ReplicationSubsystem.GetGridMutable();\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tconst TArrayView<FMassReplicationGridCellLocationFragment> ReplicationCellLocationList = Context.GetMutableFragmentView<FMassReplicationGridCellLocationFragment>();\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tconst FMassEntityHandle EntityHandle = Context.GetEntity(EntityIndex);\n\t\t\tReplicationGrid.Remove(EntityHandle, ReplicationCellLocationList[EntityIndex].CellLoc);\n\t\t\tReplicationCellLocationList[EntityIndex].CellLoc = FReplicationHashGrid2D::FCellLocation();\n\t\t}\n\t});\n}",
      "lines": 164
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Private\\MassReplicationModule.cpp",
      "extension": ".cpp",
      "size_bytes": 796,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CoreMinimal.h\"\n#include \"IMassReplicationModule.h\"\n\n\nclass FMassReplicationModule : public IMassReplicationModule\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nIMPLEMENT_MODULE(FMassReplicationModule, MassReplication)\n\n\n\nvoid FMassReplicationModule::StartupModule()\n{\n\t// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)\n}\n\n\nvoid FMassReplicationModule::ShutdownModule()\n{\n\t// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n\t// we call this function before unloading the module.\n}\n\n\n\n",
      "lines": 31
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Private\\MassReplicationProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 18660,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.UMassSimulationSettings\n\n#include \"MassReplicationProcessor.h\"\n#include \"MassClientBubbleHandler.h\"\n#include \"MassLODSubsystem.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassExecutionContext.h\"\n\nnamespace UE::Mass::Replication\n{\n\tint32 DebugClientReplicationLOD = -1;\n\tFAutoConsoleVariableRef CVarDebugReplicationViewerLOD(TEXT(\"mass.debug.ClientReplicationLOD\"), DebugClientReplicationLOD, TEXT(\"Debug Replication LOD of the specified client index\"), ECVF_Cheat);\n} // UE::Mass::Crowd\n\n//----------------------------------------------------------------------//\n//  UMassReplicationProcessor\n//----------------------------------------------------------------------//\nUMassReplicationProcessor::UMassReplicationProcessor()\n\t: SyncClientData(*this)\n\t, CollectViewerInfoQuery(*this)\n\t, CalculateLODQuery(*this)\n\t, AdjustLODDistancesQuery(*this)\n\t, EntityQuery(*this)\n{\n#if !UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE\n\tExecutionFlags = int32(EProcessorExecutionFlags::Server);\n#else\n\tExecutionFlags = int32(EProcessorExecutionFlags::AllNetModes);\n#endif // UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE\n\n\tProcessingPhase = EMassProcessingPhase::PostPhysics;\n\n\t// Processor might need to create UObjects when synchronizing clients and viewers\n\t// (e.g. SpawnActor from UMassReplicationSubsystem::SynchronizeClientsAndViewers())\n\tbRequiresGameThreadExecution = true;\n}\n\nvoid UMassReplicationProcessor::ConfigureQueries()\n{\n\tSyncClientData.AddRequirement<FMassReplicationLODFragment>(EMassFragmentAccess::ReadWrite);\n\tSyncClientData.AddRequirement<FMassReplicatedAgentFragment>(EMassFragmentAccess::ReadWrite);\n\n\tCollectViewerInfoQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tCollectViewerInfoQuery.AddRequirement<FMassReplicationViewerInfoFragment>(EMassFragmentAccess::ReadWrite);\n\tCollectViewerInfoQuery.AddSharedRequirement<FMassReplicationSharedFragment>(EMassFragmentAccess::ReadWrite);\n\n\tCalculateLODQuery.AddRequirement<FMassReplicationViewerInfoFragment>(EMassFragmentAccess::ReadOnly);\n\tCalculateLODQuery.AddRequirement<FMassReplicationLODFragment>(EMassFragmentAccess::ReadWrite);\n\tCalculateLODQuery.AddConstSharedRequirement<FMassReplicationParameters>();\n\tCalculateLODQuery.AddSharedRequirement<FMassReplicationSharedFragment>(EMassFragmentAccess::ReadWrite);\n\n\tAdjustLODDistancesQuery.AddRequirement<FMassReplicationViewerInfoFragment>(EMassFragmentAccess::ReadOnly);\n\tAdjustLODDistancesQuery.AddRequirement<FMassReplicationLODFragment>(EMassFragmentAccess::ReadWrite);\n\tAdjustLODDistancesQuery.AddSharedRequirement<FMassReplicationSharedFragment>(EMassFragmentAccess::ReadWrite);\n\tAdjustLODDistancesQuery.SetChunkFilter([](const FMassExecutionContext& Context)\n\t{\n\t\tconst FMassReplicationSharedFragment& LODSharedFragment = Context.GetSharedFragment<FMassReplicationSharedFragment>();\n\t\treturn LODSharedFragment.bHasAdjustedDistancesFromCount;\n\t});\n\n\tEntityQuery.AddRequirement<FMassNetworkIDFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FReplicationTemplateIDFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassReplicationLODFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassReplicatedAgentFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddConstSharedRequirement<FMassReplicationParameters>();\n\tEntityQuery.AddSharedRequirement<FMassReplicationSharedFragment>(EMassFragmentAccess::ReadWrite);\n\n\tProcessorRequirements.AddSubsystemRequirement<UMassLODSubsystem>(EMassFragmentAccess::ReadOnly);\n}\n\nvoid UMassReplicationProcessor::Initialize(UObject& Owner)\n{\n\tSuper::Initialize(Owner);\n\n#if UE_REPLICATION_COMPILE_SERVER_CODE\n\tUWorld* World = Owner.GetWorld();\n\tReplicationSubsystem = UWorld::GetSubsystem<UMassReplicationSubsystem>(World);\n\n\tcheck(ReplicationSubsystem);\n#endif //UE_REPLICATION_COMPILE_SERVER_CODE\n}\n\nvoid UMassReplicationProcessor::PrepareExecution(FMassEntityManager& EntityManager)\n{\n#if UE_REPLICATION_COMPILE_SERVER_CODE\n\n\tcheck(ReplicationSubsystem);\n\n\t//first synchronize clients and viewers\n\tReplicationSubsystem->SynchronizeClientsAndViewers();\n\n\tEntityManager.ForEachSharedFragment<FMassReplicationSharedFragment>([this](FMassReplicationSharedFragment& RepSharedFragment)\n\t{\n\t\tif (!ensureMsgf(RepSharedFragment.BubbleInfoClassHandle.IsValid()\n\t\t\t, TEXT(\"BubbleInfoClassHandle is not valid which means no class has been indicated or the class used has not been registered pre creation of the handle.\")))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (!RepSharedFragment.bEntityQueryInitialized)\n\t\t{\n\t\t\tRepSharedFragment.EntityQuery = EntityQuery;\n\t\t\tRepSharedFragment.EntityQuery.SetChunkFilter([&RepSharedFragment](const FMassExecutionContext& Context)\n\t\t\t{\n\t\t\t\tconst FMassReplicationSharedFragment& CurRepSharedFragment = Context.GetSharedFragment<FMassReplicationSharedFragment>();\n\t\t\t\treturn &CurRepSharedFragment == &RepSharedFragment;\n\t\t\t});\n\t\t\tRepSharedFragment.CachedReplicator->AddRequirements(RepSharedFragment.EntityQuery);\n\t\t\tRepSharedFragment.bEntityQueryInitialized = true;\n\t\t}\n\n\t\tconst TArray<FMassClientHandle>& CurrentClientHandles = ReplicationSubsystem->GetClientReplicationHandles();\n\t\tconst int32 MinNumHandles = FMath::Min(RepSharedFragment.CachedClientHandles.Num(), CurrentClientHandles.Num()); // Why is this the min not the max?\n\n\t\t//check to see if we don't have enough cached client handles\n\t\tif (RepSharedFragment.CachedClientHandles.Num() < CurrentClientHandles.Num())\n\t\t{\n\t\t\tRepSharedFragment.CachedClientHandles.Reserve(CurrentClientHandles.Num());\n\t\t\tRepSharedFragment.BubbleInfos.Reserve(CurrentClientHandles.Num());\n\n\t\t\tfor (int32 Idx = RepSharedFragment.CachedClientHandles.Num(); Idx < CurrentClientHandles.Num(); ++Idx)\n\t\t\t{\n\t\t\t\tconst FMassClientHandle& CurrentClientHandle = CurrentClientHandles[Idx];\n\n\t\t\t\tRepSharedFragment.CachedClientHandles.Add(CurrentClientHandle);\n\t\t\t\tAMassClientBubbleInfoBase* Info = CurrentClientHandle.IsValid() ?\n\t\t\t\t\tReplicationSubsystem->GetClientBubbleChecked(RepSharedFragment.BubbleInfoClassHandle, CurrentClientHandle) :\n\t\t\t\t\tnullptr;\n\n\t\t\t\tcheck(Info);\n\n\t\t\t\tRepSharedFragment.BubbleInfos.Add(Info);\n\t\t\t}\n\t\t}\n\t\t//check to see if we have too many cached client handles\n\t\telse if (RepSharedFragment.CachedClientHandles.Num() > CurrentClientHandles.Num())\n\t\t{\n\t\t\tconst int32 NumRemove = RepSharedFragment.CachedClientHandles.Num() - CurrentClientHandles.Num();\n\n\t\t\tRepSharedFragment.CachedClientHandles.RemoveAt(CurrentClientHandles.Num(), NumRemove, EAllowShrinking::No);\n\t\t\tRepSharedFragment.BubbleInfos.RemoveAt(CurrentClientHandles.Num(), NumRemove, EAllowShrinking::No);\n\t\t}\n\n\t\t//check to see if any cached client handles have changed, if they have set the BubbleInfo[] appropriately\n\t\tfor (int32 Idx = 0; Idx < MinNumHandles; ++Idx)\n\t\t{\n\t\t\tconst FMassClientHandle& CurrentClientHandle = CurrentClientHandles[Idx];\n\t\t\tFMassClientHandle& CachedClientHandle = RepSharedFragment.CachedClientHandles[Idx];\n\n\t\t\tconst bool bChanged = (CurrentClientHandle != CachedClientHandle);\n\t\t\tif (bChanged)\n\t\t\t{\n\t\t\t\tAMassClientBubbleInfoBase* Info = CurrentClientHandle.IsValid() ?\n\t\t\t\t\tReplicationSubsystem->GetClientBubbleChecked(RepSharedFragment.BubbleInfoClassHandle, CurrentClientHandle) :\n\t\t\t\t\tnullptr;\n\n\t\t\t\tRepSharedFragment.BubbleInfos[Idx] = Info;\n\t\t\t\tCachedClientHandle = CurrentClientHandle;\n\t\t\t}\n\t\t}\n\t});\n\n#endif //UE_REPLICATION_COMPILE_SERVER_CODE\n}\n\nvoid UMassReplicationProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n#if UE_REPLICATION_COMPILE_SERVER_CODE\n\tUWorld* World = EntityManager.GetWorld();\n\tcheck(World);\n\tcheck(ReplicationSubsystem);\n\n\t{\n\t\tQUICK_SCOPE_CYCLE_COUNTER(UMassReplicationProcessor_Preperation);\n\t\tPrepareExecution(EntityManager);\n\t}\n\n\tconst UMassLODSubsystem& LODSubsystem = Context.GetSubsystemChecked<UMassLODSubsystem>();\n\tconst TArray<FViewerInfo>& AllViewersInfo = LODSubsystem.GetViewers();\n\tconst TArray<FMassClientHandle>& ClientHandles = ReplicationSubsystem->GetClientReplicationHandles();\n\tfor (const FMassClientHandle ClientHandle : ClientHandles)\n\t{\n\t\tif (ReplicationSubsystem->IsValidClientHandle(ClientHandle) == false)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tFMassClientReplicationInfo& ClientReplicationInfo = ReplicationSubsystem->GetMutableClientReplicationInfoChecked(ClientHandle);\n\n\t\t// Figure out all viewer of this client\n\t\tTArray<FViewerInfo> Viewers;\n\t\tfor (const FMassViewerHandle ClientViewerHandle : ClientReplicationInfo.Handles)\n\t\t{\n\t\t\tconst FViewerInfo* ViewerInfo = AllViewersInfo.FindByPredicate([ClientViewerHandle](const FViewerInfo& ViewerInfo) { return ClientViewerHandle == ViewerInfo.Handle; });\n\t\t\tif (ensureMsgf(ViewerInfo, TEXT(\"Expecting to find the client viewer handle in the all viewers info list\")))\n\t\t\t{\n\t\t\t\tViewers.Add(*ViewerInfo);\n\t\t\t}\n\t\t}\n\n\t\t// Prepare LOD collector and calculator\n\t\t// Remember the max LOD distance from each\n\t\tfloat MaxLODDistance = 0.0f;\n\t\tEntityManager.ForEachSharedFragment<FMassReplicationSharedFragment>([&Viewers,&MaxLODDistance](FMassReplicationSharedFragment& RepSharedFragment)\n\t\t{\n\t\t\tRepSharedFragment.LODCollector.PrepareExecution(Viewers);\n\t\t\tRepSharedFragment.LODCalculator.PrepareExecution(Viewers);\n\t\t\tMaxLODDistance = FMath::Max(MaxLODDistance, RepSharedFragment.LODCalculator.GetMaxLODDistance());\n\t\t});\n\n\t\t// Fetch all entities to process\n\t\tconst FVector HalfExtent(MaxLODDistance, MaxLODDistance, 0.0f);\n\t\tTArray<FMassEntityHandle> EntitiesInRange;\n\t\tfor (const FViewerInfo& Viewer : Viewers)\n\t\t{\n\t\t\tFBox Bounds(Viewer.Location - HalfExtent, Viewer.Location + HalfExtent);\n\t\t\tReplicationSubsystem->GetGrid().Query(Bounds, EntitiesInRange);\n\t\t}\n\n\t\tEntityQuery.CacheArchetypes(EntityManager);\n\t\tif (EntityQuery.GetArchetypes().Num() > 0)\n\t\t{\n\t\t\t// EntitySet stores array of entities per specified archetype, may contain duplicates.\n\t\t\tstruct FEntitySet\n\t\t\t{\n\t\t\t\tvoid Reset()\n\t\t\t\t{\n\t\t\t\t\tEntities.Reset();\n\t\t\t\t}\n\n\t\t\t\tFMassArchetypeHandle Archetype;\n\t\t\t\tTArray<FMassEntityHandle> Entities;\n\t\t\t};\n\t\t\tTArray<FEntitySet> EntitySets;\n\n\t\t\tfor (const FMassArchetypeHandle& Archetype : EntityQuery.GetArchetypes())\n\t\t\t{\n\t\t\t\tFEntitySet& Set = EntitySets.AddDefaulted_GetRef();\n\t\t\t\tSet.Archetype = Archetype;\n\t\t\t}\n\n\t\t\tauto BuildEntitySet = [&EntitySets, &EntityManager](const TArray<FMassEntityHandle>& Entities)\n\t\t\t{\n\t\t\t\tFEntitySet* PrevSet = Entities.Num() ? &EntitySets[0] : nullptr;\n\t\t\t\tfor (const FMassEntityHandle Entity : Entities)\n\t\t\t\t{\n\t\t\t\t\t// Add to set of supported archetypes. Dont process if we don't care about the type.\n\t\t\t\t\tconst FMassArchetypeHandle Archetype = EntityManager.GetArchetypeForEntity(Entity);\n\t\t\t\t\tFEntitySet* Set = PrevSet && PrevSet->Archetype == Archetype ? PrevSet : EntitySets.FindByPredicate([&Archetype](const FEntitySet& Set) { return Archetype == Set.Archetype; });\n\t\t\t\t\tif (Set != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\t// We don't care about duplicates here, the FMassArchetypeEntityCollection creation below will handle it\n\t\t\t\t\t\tSet->Entities.Add(Entity);\n\t\t\t\t\t\tPrevSet = Set;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tBuildEntitySet(ClientReplicationInfo.HandledEntities);\n\t\t\tBuildEntitySet(EntitiesInRange);\n\n\t\t\tfor (FEntitySet& Set : EntitySets)\n\t\t\t{\n\t\t\t\tif (Set.Entities.Num() == 0)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tContext.SetEntityCollection(FMassArchetypeEntityCollection(Set.Archetype, Set.Entities, FMassArchetypeEntityCollection::FoldDuplicates));\n\n\t\t\t\t{\n\t\t\t\t\tQUICK_SCOPE_CYCLE_COUNTER(UMassReplicationProcessor_SyncToMass);\n\t\t\t\t\tSyncClientData.ForEachEntityChunk(EntityManager, Context, [&ClientReplicationInfo](FMassExecutionContext& Context)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst TArrayView<FMassReplicationLODFragment> ViewerLODList = Context.GetMutableFragmentView<FMassReplicationLODFragment>();\n\t\t\t\t\t\tTArrayView<FMassReplicatedAgentFragment> ReplicatedAgentList = Context.GetMutableFragmentView<FMassReplicatedAgentFragment>();\n\n\t\t\t\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\t\t\t\tfor (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFMassEntityHandle EntityHandle = Context.GetEntity(EntityIdx);\n\t\t\t\t\t\t\tFMassReplicatedAgentFragment& AgentFragment = ReplicatedAgentList[EntityIdx];\n\t\t\t\t\t\t\tFMassReplicationLODFragment& LODFragment = ViewerLODList[EntityIdx];\n\n\t\t\t\t\t\t\tif (FMassReplicatedAgentData* AgentData = ClientReplicationInfo.AgentsData.Find(EntityHandle))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tLODFragment.LOD = AgentData->LOD;\n\t\t\t\t\t\t\t\tAgentFragment.AgentData = *AgentData;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tLODFragment.LOD = EMassLOD::Off;\n\t\t\t\t\t\t\t\tAgentFragment.AgentData.Invalidate();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tQUICK_SCOPE_CYCLE_COUNTER(UMassReplicationProcessor_LODCollection);\n\t\t\t\t\tCollectViewerInfoQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();\n\t\t\t\t\t\tconst TArrayView<FMassReplicationViewerInfoFragment> ViewersInfoList = Context.GetMutableFragmentView<FMassReplicationViewerInfoFragment>();\n\t\t\t\t\t\tFMassReplicationSharedFragment& RepSharedFragment = Context.GetMutableSharedFragment<FMassReplicationSharedFragment>();\n\t\t\t\t\t\tRepSharedFragment.LODCollector.CollectLODInfo(Context, LocationList, ViewersInfoList, ViewersInfoList);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tQUICK_SCOPE_CYCLE_COUNTER(UMassReplicationProcessor_LODCaculation);\n\t\t\t\t\tCalculateLODQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst TConstArrayView<FMassReplicationViewerInfoFragment> ViewersInfoList = Context.GetFragmentView<FMassReplicationViewerInfoFragment>();\n\t\t\t\t\t\tconst TArrayView<FMassReplicationLODFragment> ViewerLODList = Context.GetMutableFragmentView<FMassReplicationLODFragment>();\n\t\t\t\t\t\tFMassReplicationSharedFragment& RepSharedFragment = Context.GetMutableSharedFragment<FMassReplicationSharedFragment>();\n\t\t\t\t\t\tRepSharedFragment.LODCalculator.CalculateLOD(Context, ViewersInfoList, ViewerLODList, ViewersInfoList);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tContext.ClearEntityCollection();\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tQUICK_SCOPE_CYCLE_COUNTER(UMassReplicationProcessor_LODAdjustDistance);\n\t\t\t\tEntityManager.ForEachSharedFragment<FMassReplicationSharedFragment>([](FMassReplicationSharedFragment& RepSharedFragment)\n\t\t\t\t{\n\t\t\t\t\tRepSharedFragment.bHasAdjustedDistancesFromCount = RepSharedFragment.LODCalculator.AdjustDistancesFromCount();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfor (FEntitySet& Set : EntitySets)\n\t\t\t{\n\t\t\t\tif (Set.Entities.Num() == 0)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tContext.SetEntityCollection(FMassArchetypeEntityCollection(Set.Archetype, Set.Entities, FMassArchetypeEntityCollection::FoldDuplicates));\n\n\t\t\t\t{\n\t\t\t\t\tQUICK_SCOPE_CYCLE_COUNTER(UMassReplicationProcessor_LODAdjustLODFromCount);\n\t\t\t\t\tAdjustLODDistancesQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst TConstArrayView<FMassReplicationViewerInfoFragment> ViewersInfoList = Context.GetFragmentView<FMassReplicationViewerInfoFragment>();\n\t\t\t\t\t\tconst TArrayView<FMassReplicationLODFragment> ViewerLODList = Context.GetMutableFragmentView<FMassReplicationLODFragment>();\n\t\t\t\t\t\tFMassReplicationSharedFragment& RepSharedFragment = Context.GetMutableSharedFragment<FMassReplicationSharedFragment>();\n\t\t\t\t\t\tRepSharedFragment.LODCalculator.AdjustLODFromCount(Context, ViewersInfoList, ViewerLODList, ViewersInfoList);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tQUICK_SCOPE_CYCLE_COUNTER(UMassReplicationProcessor_ProcessClientReplication);\n\t\t\t\t\tFMassReplicationContext ReplicationContext(*World, LODSubsystem, *ReplicationSubsystem);\n\t\t\t\t\tEntityManager.ForEachSharedFragment<FMassReplicationSharedFragment>([&EntityManager, &Context, &ReplicationContext, &ClientHandle](FMassReplicationSharedFragment& RepSharedFragment)\n\t\t\t\t\t{\n\t\t\t\t\t\tRepSharedFragment.CurrentClientHandle = ClientHandle;\n\n\t\t\t\t\t\tRepSharedFragment.EntityQuery.ForEachEntityChunk(EntityManager, Context, [&ReplicationContext, &RepSharedFragment](FMassExecutionContext& Context)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRepSharedFragment.CachedReplicator->ProcessClientReplication(Context, ReplicationContext);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tQUICK_SCOPE_CYCLE_COUNTER(UMassReplicationProcessor_SyncFromMass);\n\t\t\t\t\tSyncClientData.ForEachEntityChunk(EntityManager, Context, [&ClientReplicationInfo](FMassExecutionContext& Context)\n\t\t\t\t\t{\n\t\t\t\t\t\tTArrayView<FMassReplicatedAgentFragment> ReplicatedAgentList = Context.GetMutableFragmentView<FMassReplicatedAgentFragment>();\n\n\t\t\t\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\t\t\t\tfor (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFMassEntityHandle EntityHandle = Context.GetEntity(EntityIdx);\n\t\t\t\t\t\t\tFMassReplicatedAgentFragment& AgentFragment = ReplicatedAgentList[EntityIdx];\n\t\t\t\t\t\t\tClientReplicationInfo.AgentsData.Add(EntityHandle, AgentFragment.AgentData);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\t\t\t// Optional debug display\n\t\t\t\tif (UE::Mass::Replication::DebugClientReplicationLOD == ClientHandle.GetIndex())\n\t\t\t\t{\n\t\t\t\t\tEntityManager.ForEachSharedFragment<FMassReplicationSharedFragment>([World, &EntityManager, &Context](FMassReplicationSharedFragment& RepSharedFragment)\n\t\t\t\t\t{\n\t\t\t\t\t\tRepSharedFragment.EntityQuery.ForEachEntityChunk(EntityManager, Context, [World, &RepSharedFragment](FMassExecutionContext& Context)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();\n\t\t\t\t\t\t\tconst TConstArrayView<FMassReplicationLODFragment> ViewerLODList = Context.GetFragmentView<FMassReplicationLODFragment>();\n\t\t\t\t\t\t\tRepSharedFragment.LODCalculator.DebugDisplayLOD(Context, ViewerLODList, TransformList, World);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t\t\t\tContext.ClearEntityCollection();\n\t\t\t}\n\t\t}\n\t\tClientReplicationInfo.HandledEntities = MoveTemp(EntitiesInRange);\n\n\t\t// Cleanup any AgentData that isn't relevant anymore (that is EMassLOD::OFF)\n\t\tfor (FMassReplicationAgentDataMap::TIterator It = ClientReplicationInfo.AgentsData.CreateIterator(); It; ++It)\n\t\t{\n\t\t\tFMassReplicatedAgentData& AgentData = It.Value();\n\t\t\tif (AgentData.LOD == EMassLOD::Off)\n\t\t\t{\n\t\t\t\tcheckf(!AgentData.Handle.IsValid(), TEXT(\"This replicated agent should have been removed from this client and was not\"));\n\t\t\t\tIt.RemoveCurrent();\n\t\t\t}\n\t\t}\n\t}\n#endif //UE_REPLICATION_COMPILE_SERVER_CODE\n}\n",
      "lines": 413
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Private\\MassReplicationSubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 27433,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassReplicationSubsystem.h\"\n#include \"Engine/World.h\"\n#include \"Engine/ChildConnection.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassEntityManager.h\"\n#include \"MassClientBubbleHandler.h\"\n#include \"MassClientBubbleInfoBase.h\"\n#include \"MassReplicationSettings.h\"\n#include \"MassEntityUtils.h\"\n#include \"VisualLogger/VisualLogger.h\"\n\n\nuint32 UMassReplicationSubsystem::CurrentNetMassCounter = 0;\n\nvoid UMassReplicationSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tSuper::Initialize(Collection);\n\n\tWorld = GetWorld();\n\tcheck(World);\n\n\tMassLODSubsystem = Collection.InitializeDependency<UMassLODSubsystem>();\n\tcheck(MassLODSubsystem);\n\n\tEntityManager = UE::Mass::Utils::GetEntityManagerChecked(*World).AsShared();\n}\n\nvoid UMassReplicationSubsystem::Deinitialize()\n{\n\t// remove all Clients\n\tfor (const FMassClientHandle& Handle : ClientHandleManager.GetHandles())\n\t{\n\t\tif (Handle.IsValid())\n\t\t{\n\t\t\tRemoveClient(Handle);\n\t\t}\n\t}\n\n\t// make sure all the other data is reset\n\tClientHandleManager.Reset();\n\tBubbleInfoArray.Reset();\n\tClientsReplicationInfo.Reset();\n\tClientToViewerHandleArray.Reset();\n\tViewerToClientHandleArray.Reset();\n\n\tWorld = nullptr;\n\tMassLODSubsystem = nullptr;\n\tEntityManager.Reset();\n\n\tSuper::Deinitialize();\n}\n\nUMassReplicationSubsystem::UMassReplicationSubsystem()\n : ReplicationGrid(GetDefault<UMassReplicationSettings>()->GetReplicationGridCellSize())\n{\n}\n\nFMassNetworkID UMassReplicationSubsystem::GetNetIDFromHandle(const FMassEntityHandle Handle) const\n{\n\tcheck(EntityManager);\n\tconst FMassNetworkIDFragment& Data = EntityManager->GetFragmentDataChecked<FMassNetworkIDFragment>(Handle);\n\treturn Data.NetID;\n}\n\nnamespace UE { namespace Mass { namespace Replication {\n// Checks the parent net connection has APlayerController OwningActor, unfortunately GetParentConnection() prevents UChildConnection being const here.\nAPlayerController* GetValidParentNetConnection(UChildConnection& ChildConnection)\n{\n\treturn (ChildConnection.GetParentConnection() != nullptr) ? Cast<APlayerController>(ChildConnection.GetParentConnection()->OwningActor) : nullptr;\n}\n\nenum class ENetConnectionType : uint8\n{\n\tNone,\n\tParent,\n\tChild,\n};\n\n// Checks Controllers net connection is a parent net connection\nbool HasParentNetConnection(const APlayerController* Controller)\n{\n\treturn (Controller != nullptr) && Controller->NetConnection && (Cast<UChildConnection>(Controller->NetConnection) == nullptr);\n}\n\n// If Controller has a UChildConnection then this gets the parent net connection's APlayerController OwningActor otherwise nullptr\nAPlayerController* GetParentControllerFromChildNetConnection(const APlayerController* Controller)\n{\n\t//ChildConnection can't be const\n\tUChildConnection* ChildConnection = Controller ? Cast<UChildConnection>(Controller->NetConnection) : nullptr;\n\n\treturn ChildConnection ? GetValidParentNetConnection(*ChildConnection) : nullptr;\n}\n\n// Gets the ENetConnectionType for Controller. Tests if Controller's net connection is a parent or if Controller's net connection is a child and its parent net connection has a APlayerController OwningActor, \nENetConnectionType HasParentOrChildWithValidParentNetConnection(const APlayerController* Controller)\n{\n\tENetConnectionType ConnectionType = ENetConnectionType::None;\n\n\tif (Controller && Controller->NetConnection)\n\t{\n\t\tUChildConnection* ChildConnection = Cast<UChildConnection>(Controller->NetConnection);\n\n\t\t// if the NetConnection is either a parent connection or a child connection with APlayerController owning actor its valid \n\t\tif (ChildConnection == nullptr)\n\t\t{\n\t\t\tConnectionType = ENetConnectionType::Parent;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConnectionType = (GetValidParentNetConnection(*ChildConnection) != nullptr) ? ENetConnectionType::Child : ENetConnectionType::None;\n\t\t}\t\t\n\t}\n\n\treturn ConnectionType;\n}\n}}};\n\nbool UMassReplicationSubsystem::SynchronizeClients(const TArray<FViewerInfo>& Viewers)\n{\n\ttypedef TMap<FMassViewerHandle, FMassClientHandle> FControllerMap;\n\tstruct FClientAddData\n\t{\n\t\tFClientAddData(FMassViewerHandle InHandle, APlayerController* InController)\n\t\t\t: Handle(InHandle)\n\t\t\t, Controller(InController)\n\t\t{}\n\n\t\tFMassViewerHandle Handle;\n\t\tAPlayerController* Controller = nullptr;\n\t};\n\n\tbool bNeedShrinking = false;\n\n\t//we can only replicate if we have some BubbleInfos to use for replication\n\tif (BubbleInfoArray.Num() == 0)\n\t{\n\t\treturn bNeedShrinking;\n\t}\n\n\t// Arbitrarily use index 0, if there are more items the corresponding InfoData, Bubbles will be the same length and corresponding indices between the Bubbles\n\t// will have the same player controller owner.\n\tconst FMassClientBubbleInfoData& InfoData = BubbleInfoArray[0];\n\n\tcheck(MassLODSubsystem);\n\n\tFControllerMap ClientConnectionMap;\n\n\tTArray<FClientAddData> ClientsToAdd;\n\n\t{\n\t\t// Go through the stored Clients, add valid ones to the ClientConnectionMap and remove invalids.\n\t\t// Note this is only valid until we next add a client handle.\n\t\tconst TArray<FMassClientHandle>& ClientHandles = ClientHandleManager.GetHandles();\n\n\t\tfor (int32 Idx = 0; Idx < ClientHandles.Num(); ++Idx)\n\t\t{\n\t\t\tconst FMassClientHandle& ClientHandle = ClientHandles[Idx];\n\n\t\t\tif (ClientHandle.IsValid())\n\t\t\t{\n\t\t\t\tcheck(ClientToViewerHandleArray.IsValidIndex(ClientHandle.GetIndex()));\n\n\t\t\t\tconst FViewerClientPair ViewerClientPair = ClientToViewerHandleArray[ClientHandle.GetIndex()];\n\n\t\t\t\tcheck(ViewerClientPair.ViewerHandle.IsValid());\n\t\t\t\tcheck(ViewerClientPair.ClientHandle == ClientHandle);\n\t\t\t\tcheck(InfoData.Bubbles.IsValidIndex(ClientHandle.GetIndex()));\n\n\t\t\t\tconst AMassClientBubbleInfoBase* ClientBubble = InfoData.Bubbles[ClientHandle.GetIndex()];\n\t\t\t\tconst APlayerController* Controller = ClientBubble ? Cast<APlayerController>(ClientBubble->GetOwner()) : nullptr;\n\n//no need to check netconnection if UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE\n#if !UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE\n\t\t\t\t// must have a valid non child UNetConnection\n\t\t\t\tif (UE::Mass::Replication::HasParentNetConnection(Controller))\n#endif\n\t\t\t\t{\n\t\t\t\t\tClientConnectionMap.Add(ViewerClientPair.ViewerHandle, ClientHandle);\n\t\t\t\t}\n#if !UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// this is safe as Clients and their handles are free list arrays\n\t\t\t\t\tRemoveClient(ClientHandle);\n\t\t\t\t\tbNeedShrinking |= Idx == ClientHandles.Num() - 1;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\n\t\t// now go through all current Viewers and add if they do not exist\n\t\tfor (const FViewerInfo& Viewer : Viewers)\n\t\t{\n\t\t\t// must have valid Viewer and parent net connection\n\t\t\tif (Viewer.Handle.IsValid())\n\t\t\t{\n//no need to check netconnection if UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE\n#if !UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE\n\t\t\t\tAPlayerController* ViewerAsPlayerController = Viewer.GetPlayerController();\n\t\t\t\tif (UE::Mass::Replication::HasParentNetConnection(ViewerAsPlayerController))\n#endif\n\t\t\t\t{\n\t\t\t\t\t// check if the controller already exists by trying to remove it from the map which was filled up with controllers we were tracking\n\t\t\t\t\tif (ClientConnectionMap.Remove(Viewer.Handle) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// If not add it to ClientsToAdd. Its important AddClient isn't called until necessary Clients are removed, as we may reuse \n\t\t\t\t\t\t// array indices that are already in use.\n\t\t\t\t\t\tClientsToAdd.Emplace(Viewer.Handle, ViewerAsPlayerController);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// anything left in the map needs to be removed from the list\n\t\tfor (FControllerMap::TIterator Itr = ClientConnectionMap.CreateIterator(); Itr; ++Itr)\n\t\t{\n\t\t\tconst int32 ViewerIdx = Itr->Value.GetIndex();\n\n\t\t\tRemoveClient(Itr->Value);\n\n\t\t\t//InfoData must be valid here as ClientConnectionMap can only have items if ClientHandleManager.GetHandles() was greater than 0 \n\t\t\t//when we entered the function.\n\t\t\tbNeedShrinking |= (ViewerIdx == (InfoData.Bubbles.Num() - 1));\n\t\t}\n\t}\n\n\t// resize the ViewerToClientHandleArray array to match the viewer handles array (for consistency)\n\tif (ViewerToClientHandleArray.Num() > Viewers.Num())\n\t{\n\t\tViewerToClientHandleArray.RemoveAt(Viewers.Num(), ViewerToClientHandleArray.Num() - Viewers.Num(), EAllowShrinking::No);\n\t}\n\n\tfor (FClientAddData& ClientAdd : ClientsToAdd)\n\t{\n\t\t//TODO make AddClients (ie plural) functionality\n\t\tAddClient(ClientAdd.Handle, *ClientAdd.Controller);\n\t}\n\n\treturn bNeedShrinking;\n}\n\n// synchronize the ClientViewers\nvoid UMassReplicationSubsystem::SynchronizeClientViewers(const TArray<FViewerInfo>& Viewers)\n{\n\tcheck(MassLODSubsystem);\n\n\tstruct FMassClientViewerHandle\n\t{\n\t\tFMassClientViewerHandle(FMassClientHandle InClientHandle, FMassViewerHandle InViewerHandle)\n\t\t\t: ClientHandle(InClientHandle)\n\t\t\t, ViewerHandle(InViewerHandle)\n\t\t{}\n\n\t\tFMassClientHandle ClientHandle;\n\t\tFMassViewerHandle ViewerHandle;\n\t};\n\n\t// go through the ClientReplicationInfo and check validity and store the valid ones into a map\n\ttypedef TMap<APlayerController*, FMassClientViewerHandle> FViewerMap;\n\n\tFViewerMap ClientViewerMap;\n\t{\n\t\tconst TArray<FMassClientHandle> ClientHandles = ClientHandleManager.GetHandles();\n\n\t\tfor (const FMassClientHandle& ClientHandle : ClientHandles)\n\t\t{\n\t\t\t//as this is a fresh handle then we only need to check against !IsInvalid\n\t\t\tif (ClientHandle.IsValid())\n\t\t\t{\n\t\t\t\tFMassClientReplicationInfo& ClientReplicationInfo = ClientsReplicationInfo[ClientHandle.GetIndex()];\n\n\t\t\t\tint32 ViewerIdx = 0;\n\n\t\t\t\twhile (ViewerIdx < ClientReplicationInfo.Handles.Num())\n\t\t\t\t{\n\t\t\t\t\tconst FMassViewerHandle& ClientViewer = ClientReplicationInfo.Handles[ViewerIdx];\n\n\t\t\t\t\tAPlayerController* Controller = MassLODSubsystem->GetPlayerControllerFromViewerHandle(ClientViewer);\n\n\t\t\t\t\tconst UE::Mass::Replication::ENetConnectionType ConnectionType = UE::Mass::Replication::HasParentOrChildWithValidParentNetConnection(Controller);\n\n\t\t\t\t\tif (ConnectionType != UE::Mass::Replication::ENetConnectionType::None)\n\t\t\t\t\t{\n\t\t\t\t\t\t++ViewerIdx;\n\n\t\t\t\t\t\t// we don't verify or remove Parent Connections here as that was done when we synchronized the client bubbles\n\t\t\t\t\t\tif (ConnectionType == UE::Mass::Replication::ENetConnectionType::Child)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tClientViewerMap.Add(Controller, FMassClientViewerHandle(ClientHandle, ClientViewer));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse //remove invalid ClientViewer, but dont increment the ViewerIdx\n\t\t\t\t\t{\n\t\t\t\t\t\tClientReplicationInfo.Handles.RemoveAt(ViewerIdx, EAllowShrinking::No);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// now go through all current Viewers and add if they are a valid ClientViewer with a child UNetconnection if they do not exist\n\t\tfor (const FViewerInfo& Viewer : Viewers)\n\t\t{\n\t\t\t// we are only interested in valid Viewers\n\t\t\tif (Viewer.Handle.IsValid())\n\t\t\t{\n\t\t\t\t// we are only processing child UNetConnections that have a valid APlayerController OwningActor\n\t\t\t\tAPlayerController* ViewerAsPlayerController = Viewer.GetPlayerController();\n\t\t\t\tconst APlayerController* ParentController = UE::Mass::Replication::GetParentControllerFromChildNetConnection(ViewerAsPlayerController);\n\n\t\t\t\t// check if the parent controller is valid and already exists\n\t\t\t\tif (ParentController && (ClientViewerMap.Find(ViewerAsPlayerController) == nullptr))\n\t\t\t\t{\n\t\t\t\t\tFMassViewerHandle ParentViewerHandle = MassLODSubsystem->GetViewerHandleFromActor(*ParentController);\n\n\t\t\t\t\tif (ensureMsgf(ParentViewerHandle.IsValid(), TEXT(\"MassLODSubsystem handles are out of sync with PlayerController NetConnections!\")))\n\t\t\t\t\t{\n\t\t\t\t\t\t// note all clients (parent NetConnections) should already be set up so we would expect valid handles here\n\t\t\t\t\t\tcheck(ViewerToClientHandleArray.IsValidIndex(ParentViewerHandle.GetIndex()));\n\n\t\t\t\t\t\tconst FViewerClientPair& ParentViewerClientPair = ViewerToClientHandleArray[ParentViewerHandle.GetIndex()];\n\n\t\t\t\t\t\tcheck(MassLODSubsystem->IsValidViewer(ParentViewerClientPair.ViewerHandle));\n\t\t\t\t\t\tcheck(ClientHandleManager.IsValidHandle(ParentViewerClientPair.ClientHandle));\n\n\t\t\t\t\t\t// remove APlayerController from the ClientViewerMap and Add the viewer to the ClientsReplicationInfo\n\t\t\t\t\t\tClientViewerMap.Remove(ViewerAsPlayerController);\n\n\t\t\t\t\t\tFMassClientReplicationInfo& ClientReplicationInfo = ClientsReplicationInfo[ParentViewerClientPair.ClientHandle.GetIndex()];\n\n\t\t\t\t\t\tClientReplicationInfo.Handles.Add(Viewer.Handle);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t{\n\t\t// anything left in the map needs to be removed from the list\n\t\tfor (FViewerMap::TIterator Itr = ClientViewerMap.CreateIterator(); Itr; ++Itr)\n\t\t{\n\t\t\tconst FMassClientViewerHandle& HandleData = Itr->Value;\n\n\t\t\tFMassClientReplicationInfo& ClientReplicationInfo = ClientsReplicationInfo[HandleData.ClientHandle.GetIndex()];\n\n\t\t\tClientReplicationInfo.Handles.RemoveSingle(HandleData.ViewerHandle);\n\t\t}\n\t}\n}\n\nvoid UMassReplicationSubsystem::SynchronizeClientsAndViewers()\n{\n\t// only execute this code at most once per frame\n\tif (LastSynchronizedFrame == GFrameCounter)\n\t{\n\t\treturn;\n\t}\n\tLastSynchronizedFrame = GFrameCounter;\n\n\tif (MassLODSubsystem == nullptr)\n\t{\n\t\tcheckNoEntry();\n\t\treturn;\n\t}\n\n\t// makes sure the LOD manager Viewers are synced before we process them\n\tconst TArray<FViewerInfo>& Viewers = MassLODSubsystem->GetSynchronizedViewers();\n\n\tconst bool bNeedShrinking = SynchronizeClients(Viewers);\n\n\t//only synchronize the client viewers outside of the debug functionality for now\n#if !UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE\n\tSynchronizeClientViewers(Viewers);\n#endif //UE_ALLOW_REPLICATION_DEBUG_BUBBLES_IN_STANDALONE\n\n\tif (bNeedShrinking)\n\t{\n\t\tconst int32 NumItems = ClientHandleManager.ShrinkHandles();\n\t\t \n\t\tClientsReplicationInfo.RemoveAt(NumItems, ClientsReplicationInfo.Num() - NumItems, EAllowShrinking::No);\n\t\tClientToViewerHandleArray.RemoveAt(NumItems, ClientToViewerHandleArray.Num() - NumItems, EAllowShrinking::No);\n\n\t\tfor (FMassClientBubbleInfoData& InfoData : BubbleInfoArray)\n\t\t{\n\t\t\tInfoData.Bubbles.RemoveAt(NumItems, InfoData.Bubbles.Num() - NumItems, EAllowShrinking::No);\n\t\t}\n\t}\n}\n\nFMassBubbleInfoClassHandle UMassReplicationSubsystem::RegisterBubbleInfoClass(const TSubclassOf<AMassClientBubbleInfoBase>& BubbleInfoClass)\n{\n\tcheckf(BubbleInfoClass.Get() != nullptr, TEXT(\"BubbleInfoClass must have been set!\"));\n\n\tif (ClientHandleManager.GetHandles().Num() > 0)\n\t{\n\t\tcheckf(false, TEXT(\"RegisterBubbleInfoClass() must not be called after AddClient, BubbleInfoClass has not been registered\"));\n\t\treturn FMassBubbleInfoClassHandle();\n\t}\n\n\tconst int32 IdxFound = BubbleInfoArray.IndexOfByPredicate([BubbleInfoClass](const FMassClientBubbleInfoData& Data)\n\t\t{\n\t\t\treturn BubbleInfoClass == Data.BubbleClass;\n\t\t});\n\n\tif (IdxFound != INDEX_NONE)\n\t{\n\t\tUE_LOG(LogMassReplication, Log, TEXT(\"UMassReplicationSubsystem: Trying to RegisterBubbleInfoClass() twice with the same BubbleInfoClass, Only one BubbleInfoClass will be registered for this type\"));\n\t\treturn FMassBubbleInfoClassHandle(IdxFound);\n\t}\n\n\tconst int32 Idx = BubbleInfoArray.Emplace(BubbleInfoClass);\n\n\treturn FMassBubbleInfoClassHandle(Idx);\n}\n\nFMassBubbleInfoClassHandle UMassReplicationSubsystem::GetBubbleInfoClassHandle(const TSubclassOf<AMassClientBubbleInfoBase>& BubbleInfoClass) const\n{\n\tFMassBubbleInfoClassHandle Handle;\n\n\tfor (int32 Idx = 0; Idx < BubbleInfoArray.Num(); ++Idx)\n\t{\n\t\tconst FMassClientBubbleInfoData& BubbleData = BubbleInfoArray[Idx];\n\n\t\tif (BubbleData.BubbleClass == BubbleInfoClass)\n\t\t{\n\t\t\tHandle.SetIndex(Idx);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tUE_CVLOG_UELOG(Handle.IsValid() == false, this, LogMassReplication, Error, TEXT(\"%hs failed to find required Bubble Info class\"), __FUNCTION__);\n\n\treturn Handle;\n}\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\nvoid UMassReplicationSubsystem::SetEntity(const FMassNetworkID NetworkID, const FMassEntityHandle Entity)\n{\n\tFMassReplicationEntityInfo* EntityInfo = FindMassEntityInfoMutable(NetworkID);\n\tcheck(EntityInfo && !EntityInfo->Entity.IsSet());\n\tEntityInfo->Entity = Entity;\n\n\tOnMassAgentAdded.Broadcast(NetworkID, Entity);\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\nFMassEntityHandle UMassReplicationSubsystem::ResetEntityIfValid(const FMassNetworkID NetworkID, int32 ReplicationID)\n{\n\tFMassEntityHandle EntityReset;\n\n\tFMassReplicationEntityInfo* EntityInfo = FindMassEntityInfoMutable(NetworkID);\n\n\tcheckf(EntityInfo, TEXT(\"EntityData must have been added to EntityInfoMap!\"));\n\tcheckf(EntityInfo->ReplicationID >= ReplicationID, TEXT(\"We must not be removing an item we've never added!\"));\n\n\t// Only reset the item if its currently Set / Valid and its the most recent ReplicationID. Stale removes after more recent adds are ignored\n\t// We do need to check the ReplicationID in this case\n\tif (EntityInfo->Entity.IsSet() && (EntityInfo->ReplicationID == ReplicationID))\n\t{\n\t\tOnRemovingMassAgent.Broadcast(NetworkID, EntityReset);\n\n\t\tEntityReset = EntityInfo->Entity;\n\n\t\t//Unset the Entity handle, this indicates that its currently removed from the bubble\n\t\tEntityInfo->Entity = FMassEntityHandle();\n\t}\n\n\treturn EntityReset;\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\nvoid UMassReplicationSubsystem::RemoveFromEntityInfoMap(const FMassNetworkID NetworkID)\n{\n\tcheck(NetworkID.IsValid());\n\tFMassReplicationEntityInfo Info;\n\tensureMsgf(EntityInfoMap.RemoveAndCopyValue(NetworkID, Info), TEXT(\"Removing a non-existant NetworkID(%s)!\"), *NetworkID.Describe());\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\nUMassReplicationSubsystem::EFindOrAddMassEntityInfo UMassReplicationSubsystem::FindAndUpdateOrAddMassEntityInfo(const FMassNetworkID NetworkID, int32 ReplicationID, const FMassReplicationEntityInfo*& OutMassEntityInfo)\n{\n\tFMassReplicationEntityInfo* MassEntityInfo = FindMassEntityInfoMutable(NetworkID);\n\tEFindOrAddMassEntityInfo FindOrAddStatus = EFindOrAddMassEntityInfo::FoundOlderReplicationID;\n\n\tif (MassEntityInfo)\n\t{\n\t\t// Currently we don't think this should be needed, but are leaving it in for bomb proofing\n\t\tif (ensure(MassEntityInfo->ReplicationID < ReplicationID))\n\t\t{\n\t\t\t// Update the replication ID to the latest\n\t\t\tMassEntityInfo->ReplicationID = ReplicationID;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFindOrAddStatus = EFindOrAddMassEntityInfo::FoundNewerReplicationID;\n\t\t}\n\t}\n\telse\n\t{\n\t\tMassEntityInfo = &EntityInfoMap.Add(NetworkID, FMassReplicationEntityInfo(FMassEntityHandle(), ReplicationID));\n\t\tFindOrAddStatus = EFindOrAddMassEntityInfo::Added;\n\t}\n\n\tOutMassEntityInfo = MassEntityInfo;\n\treturn FindOrAddStatus;\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\nconst FMassReplicationEntityInfo* UMassReplicationSubsystem::FindMassEntityInfo(const FMassNetworkID NetworkID) const\n{\n\tcheck(NetworkID.IsValid());\n\treturn EntityInfoMap.Find(NetworkID);\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\nFMassReplicationEntityInfo* UMassReplicationSubsystem::FindMassEntityInfoMutable(const FMassNetworkID NetworkID)\n{\n\tcheck(NetworkID.IsValid());\n\treturn EntityInfoMap.Find(NetworkID);\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\n#if UE_REPLICATION_COMPILE_CLIENT_CODE\nFMassEntityHandle UMassReplicationSubsystem::FindEntity(const FMassNetworkID NetworkID) const\n{\n\tcheck(NetworkID.IsValid());\n\tconst FMassReplicationEntityInfo* Info = EntityInfoMap.Find(NetworkID);\n\treturn Info ? Info->Entity : FMassEntityHandle();\n}\n#endif // UE_REPLICATION_COMPILE_CLIENT_CODE\n\nvoid UMassReplicationSubsystem::DebugCheckArraysAreInSync()\n{\n#if UE_DEBUG_REPLICATION\n\n\tcheckf((ClientToViewerHandleArray.Num() == ClientsReplicationInfo.Num()), TEXT(\"Client arrays out of sync with each other!\"));\n\n\tconst int32 NumEntries = (BubbleInfoArray.Num() > 0) ? BubbleInfoArray[0].Bubbles.Num() : 0;\n\n\tfor (int32 IdxOuter = 0; IdxOuter < BubbleInfoArray.Num(); ++IdxOuter)\n\t{\n\t\tFMassClientBubbleInfoData& InfoDataOuter = BubbleInfoArray[IdxOuter];\n\n\t\tcheckf((InfoDataOuter.Bubbles.Num() == ClientsReplicationInfo.Num()), TEXT(\"BubbleInfoArray arrays out of sync with ClientsReplicationInfo!\"));\n\t\tcheckf(InfoDataOuter.Bubbles.Num() == NumEntries, TEXT(\"Bubbles have different numbers of items!\"));\n\n\t\tfor (int32 IdxInner = IdxOuter + 1; IdxInner < BubbleInfoArray.Num(); ++IdxInner)\n\t\t{\n\t\t\tFMassClientBubbleInfoData& InfoDataInner = BubbleInfoArray[IdxInner];\n\n\t\t\tfor (int32 IdxBubble = 0; IdxBubble < InfoDataOuter.Bubbles.Num(); ++IdxBubble)\n\t\t\t{\n\t\t\t\tAMassClientBubbleInfoBase* InfoOuter = InfoDataOuter.Bubbles[IdxBubble];\n\t\t\t\tAMassClientBubbleInfoBase* InfoInner = InfoDataInner.Bubbles[IdxBubble];\n\n\t\t\t\tconst TArray<FMassClientHandle>& Handles = ClientHandleManager.GetHandles();\n\n\t\t\t\tif (ClientHandleManager.IsValidHandle(Handles[IdxBubble]))\n\t\t\t\t{\t\t\t\t\n\t\t\t\t\tcheck(InfoOuter && InfoInner);\n\n\t\t\t\t\tAPlayerController* OuterController = Cast<APlayerController>(InfoOuter->GetOwner());\n\t\t\t\t\tAPlayerController* InnerController = Cast<APlayerController>(InfoInner->GetOwner());\n\n\t\t\t\t\tcheckf((OuterController != nullptr) && (InnerController != nullptr), TEXT(\"Controller owners must be valid in BubbleInfoArray\"));\n\t\t\t\t\tcheckf(OuterController == InnerController, TEXT(\"Owner controllers at the same indices in different BubbleInfoArray items must be equal!\"));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcheck(!InfoOuter && !InfoInner);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n #endif // UE_DEBUG_REPLICATION\n};\n\nvoid UMassReplicationSubsystem::AddClient(FMassViewerHandle ViewerHandle, APlayerController& InController)\n{\n\tcheck(World);\n\tcheck(MassLODSubsystem);\n\tcheckf(MassLODSubsystem->IsValidViewer(ViewerHandle), TEXT(\"ViewerHandle must be valid\"));\n\n#if !UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE\n\tcheckf(UE::Mass::Replication::HasParentNetConnection(&InController), TEXT(\"InController must have a parent net connection or replication will not occur!\"));\n#endif\n\n\tif (!ensureMsgf(BubbleInfoArray.Num() > 0, TEXT(\"BubbleInfoClass has not been set Client will not be added to UMassReplicationSubsystem!\")))\n\t{\n\t\treturn;\n\t}\n\n\tif (ViewerHandle.GetIndex() >= ViewerToClientHandleArray.Num())\n\t{\n\t\t// making no assumptions about the order that ViewerHandles are added, make sure we add enough space to accomodate the new ViewerHandle index\n\t\tViewerToClientHandleArray.AddDefaulted(ViewerHandle.GetIndex() - ViewerToClientHandleArray.Num() + 1);\n\t}\n\telse \n\t{\n\t\tcheckf(ViewerToClientHandleArray[ViewerHandle.GetIndex()].ViewerHandle.IsValid() == false, TEXT(\"Adding a Client without removing the previous with the same Index!\"));\n\t}\n\n\tFActorSpawnParameters SpawnParams;\n\tSpawnParams.Owner = &InController;\n\n\tconst FMassClientHandle ClientHandle = ClientHandleManager.GetNextHandle();\n\n\tconst FViewerClientPair ViewerClientPair(ViewerHandle, ClientHandle);\n\n\tFViewerClientPair& ViewerToClientHandleItem = ViewerToClientHandleArray[ViewerHandle.GetIndex()];\n\n\tcheckf(ViewerToClientHandleItem.IsValid() == false, TEXT(\"Handles should have been reset when previous Viewer in this slot was removed\"));\n\n\tViewerToClientHandleItem = ViewerClientPair;\n\n\tcheckf(ClientHandle.GetIndex() <= ClientToViewerHandleArray.Num(), TEXT(\"ClientHandle out of sync with ClientToViewerHandleArray\"));\n\n\t// check if the handle is a new entry in the free list arrays or uses an existing entry\n\tif (ClientHandle.GetIndex() == ClientToViewerHandleArray.Num())\n\t{\n\t\tClientsReplicationInfo.AddDefaulted();\n\t\tClientToViewerHandleArray.Emplace(ViewerHandle, ClientHandle);\n\t}\n\telse\n\t{\n\t\tcheckf(ClientsReplicationInfo[ClientHandle.GetIndex()].IsEmpty(), TEXT(\"ClientsReplicationInfo being replaced must have been reset prior to being reused!\"));\n\n\t\tFViewerClientPair& ClientToViewerHandleItem = ClientToViewerHandleArray[ClientHandle.GetIndex()];\n\n\t\tcheckf(ClientToViewerHandleItem.IsValid() == false, TEXT(\"Handles should have been reset when previous Client in this slot was removed\"));\n\n\t\tClientToViewerHandleItem = ViewerClientPair;\n\t}\n\n\tFMassClientReplicationInfo& ClientReplicationInfo = ClientsReplicationInfo[ClientHandle.GetIndex()];\n\tClientReplicationInfo.Handles.Add(ViewerHandle);\n\n\tfor (FMassClientBubbleInfoData& InfoData : BubbleInfoArray)\n\t{\n\t\tAMassClientBubbleInfoBase* ClientBubbleInfo = World->SpawnActor<AMassClientBubbleInfoBase>(InfoData.BubbleClass, SpawnParams);\n\t\tClientBubbleInfo->SetClientHandle(ClientHandle);\n\n\t\tcheckf(ClientHandle.GetIndex() <= InfoData.Bubbles.Num(), TEXT(\"ClientHandle out of sync with Bubbles\"));\n\n\t\t// check if the handle is a new entry in the free list arrays or uses an existing entry\n\t\tif (ClientHandle.GetIndex() == InfoData.Bubbles.Num())\n\t\t{\n\t\t\tInfoData.Bubbles.Push(ClientBubbleInfo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTObjectPtr<AMassClientBubbleInfoBase>& BubbleUpdate = InfoData.Bubbles[ClientHandle.GetIndex()];\n\t\t\tcheckf(BubbleUpdate == nullptr, TEXT(\"ClientBubble being replaced must be nullptr it should have been removed first!\"));\n\n\t\t\tBubbleUpdate = ClientBubbleInfo;\n\t\t}\n\t}\n\tDebugCheckArraysAreInSync();\n}\n\nvoid UMassReplicationSubsystem::RemoveClient(FMassClientHandle ClientHandle)\n{\n\tcheck(World);\n\n\tcheckf(ClientHandleManager.IsValidHandle(ClientHandle), TEXT(\"ClientHandle must be a valid non stale handle\"));\n\n\tcheckf(ClientToViewerHandleArray.IsValidIndex(ClientHandle.GetIndex()), TEXT(\"ClientHandle is out of sync with ClientToViewerHandleArray!\"));\n\tFViewerClientPair& ClientToViewerHandleItem = ClientToViewerHandleArray[ClientHandle.GetIndex()];\n\n\tcheckf(ClientToViewerHandleItem.ViewerHandle.IsValid(), TEXT(\"Invalid ViewerHandle! ClientHandle is out of sync with ClientToViewerHandleArray!\"));\n\tcheckf(ClientToViewerHandleItem.ClientHandle == ClientHandle, TEXT(\"ClientHandle is out of sync with ClientToViewerHandleArray!\"));\n\n\t{\n\t\tFMassClientReplicationInfo& ClientReplicationInfo = ClientsReplicationInfo[ClientHandle.GetIndex()];\n\n\t\tcheckf(ClientReplicationInfo.Handles.Num() > 0, TEXT(\"There should always be atleast one client viewer handle (the parent NetConnection)\"));\n\n\t\tClientReplicationInfo.Reset();\n\t}\n\n\tcheckf(ViewerToClientHandleArray.IsValidIndex(ClientToViewerHandleItem.ViewerHandle.GetIndex()), TEXT(\"ViewerHandle is out of sync with ViewerToClientHandleArray!\"));\n\tFViewerClientPair& ViewerToClientHandleItem = ViewerToClientHandleArray[ClientToViewerHandleItem.ViewerHandle.GetIndex()];\n\n\tcheckf(ViewerToClientHandleItem == ClientToViewerHandleItem, TEXT(\"ClientToViewerHandleArray and ViewerToClientHandleArray out of sync!\"));\n\n\tViewerToClientHandleItem.Invalidate();\n\tClientToViewerHandleItem.Invalidate();\n\n\tfor (FMassClientBubbleInfoData& InfoData : BubbleInfoArray)\n\t{\n\t\tcheckf(InfoData.Bubbles.IsValidIndex(ClientHandle.GetIndex()), TEXT(\"ClientHandle is out of sync with Bubbles!\"));\n\t\tTObjectPtr<AMassClientBubbleInfoBase>& BubbleInfoItem = InfoData.Bubbles[ClientHandle.GetIndex()];\n\n\t\tif ((World != nullptr) && (BubbleInfoItem != nullptr))\n\t\t{\n\t\t\tWorld->DestroyActor(BubbleInfoItem);\n\t\t}\n\n\t\tBubbleInfoItem = nullptr;\n\t}\n\n\tClientHandleManager.RemoveHandle(ClientHandle);\n\n\tDebugCheckArraysAreInSync();\n}\n",
      "lines": 713
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Private\\MassReplicationTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 1942,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassReplicationTrait.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"Engine/World.h\"\n#include \"MassSpawnerTypes.h\"\n#include \"MassSimulationLOD.h\"\n#include \"MassReplicationTypes.h\"\n#include \"MassReplicationSubsystem.h\"\n#include \"MassEntityUtils.h\"\n\n\nvoid UMassReplicationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tif (World.IsNetMode(NM_Standalone) && !BuildContext.IsInspectingData())\n\t{\n\t\treturn;\n\t}\n\n\tFReplicationTemplateIDFragment& TemplateIDFragment = BuildContext.AddFragment_GetRef<FReplicationTemplateIDFragment>();\n\tTemplateIDFragment.ID = BuildContext.GetTemplateID();\n\n\tBuildContext.AddFragment<FMassNetworkIDFragment>();\n\tBuildContext.AddFragment<FMassReplicatedAgentFragment>();\n\tBuildContext.AddFragment<FMassReplicationViewerInfoFragment>();\n\tBuildContext.AddFragment<FMassReplicationLODFragment>();\n\tBuildContext.AddFragment<FMassReplicationGridCellLocationFragment>();\n\n\tFMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(World);\n\n\tUMassReplicationSubsystem* ReplicationSubsystem = UWorld::GetSubsystem<UMassReplicationSubsystem>(&World);\n\n\tFConstSharedStruct ParamsFragment = EntityManager.GetOrCreateConstSharedFragment(Params);\n\tBuildContext.AddConstSharedFragment(ParamsFragment);\n\n\tif (LIKELY(!BuildContext.IsInspectingData()))\n\t{\n\t\tcheck(ReplicationSubsystem);\n\t\tFSharedStruct SharedFragment = EntityManager.GetOrCreateSharedFragment<FMassReplicationSharedFragment>(FConstStructView::Make(Params), *ReplicationSubsystem, Params);\n\t\tBuildContext.AddSharedFragment(SharedFragment);\n\t}\n\telse\n\t{\n\t\t// in the investigation mode we only care about the fragment type\n\t\tFSharedStruct SharedFragment = EntityManager.GetOrCreateSharedFragment<FMassReplicationSharedFragment>();\n\t\tBuildContext.AddSharedFragment(SharedFragment);\n\t}\n}",
      "lines": 48
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Private\\MassReplicationTransformHandlers.cpp",
      "extension": ".cpp",
      "size_bytes": 1100,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassReplicationTransformHandlers.h\"\n#include \"MassEntityQuery.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassExecutionContext.h\"\n#include \"AIHelpers.h\"\n\nvoid FMassReplicationProcessorTransformHandlerBase::AddRequirements(FMassEntityQuery& InQuery)\n{\n\tInQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid FMassReplicationProcessorTransformHandlerBase::CacheFragmentViews(FMassExecutionContext& ExecContext)\n{\n\tTransformList = ExecContext.GetMutableFragmentView<FTransformFragment>();\n}\n\nvoid FMassReplicationProcessorPositionYawHandler::AddEntity(const int32 EntityIdx, FReplicatedAgentPositionYawData& InOutReplicatedPositionYawData) const\n{\n\tconst FTransformFragment& TransformFragment = TransformList[EntityIdx];\n\tInOutReplicatedPositionYawData.SetPosition(TransformFragment.GetTransform().GetLocation());\n\n\tconst FRotator::FReal Yaw = FMath::DegreesToRadians(TransformFragment.GetTransform().Rotator().Yaw);\n\tInOutReplicatedPositionYawData.SetYaw(static_cast<float>(Yaw));\n}\n",
      "lines": 26
    },
    {
      "file_path": "MassGameplay\\MassReplication\\Private\\MassReplicationTypes.cpp",
      "extension": ".cpp",
      "size_bytes": 133,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassReplicationTypes.h\"\n\nDEFINE_LOG_CATEGORY(LogMassReplication);\n",
      "lines": 5
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassDistanceLODProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 5509,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassDistanceLODProcessor.h\"\n#include \"MassRepresentationDebug.h\"\n#include \"MassExecutionContext.h\"\n\nUMassDistanceLODProcessor::UMassDistanceLODProcessor()\n{\n\tbAutoRegisterWithProcessingPhases = true;\n\tExecutionFlags = (int32)(EProcessorExecutionFlags::AllNetModes);\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::LOD;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LODCollector);\n}\n\nvoid UMassDistanceLODProcessor::ConfigureQueries()\n{\n\tFMassEntityQuery BaseQuery;\n\tBaseQuery.AddTagRequirement<FMassDistanceLODProcessorTag>(EMassFragmentPresence::All);\n\tBaseQuery.AddRequirement<FMassViewerInfoFragment>(EMassFragmentAccess::ReadOnly);\n\tBaseQuery.AddRequirement<FMassRepresentationLODFragment>(EMassFragmentAccess::ReadWrite);\n\tBaseQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tBaseQuery.AddConstSharedRequirement<FMassDistanceLODParameters>();\n\tBaseQuery.AddSharedRequirement<FMassDistanceLODSharedFragment>(EMassFragmentAccess::ReadWrite);\n\n\tCloseEntityQuery = BaseQuery;\n\tCloseEntityQuery.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::None);\n\tCloseEntityQuery.RegisterWithProcessor(*this);\n\n\tFarEntityQuery = BaseQuery;\n\tFarEntityQuery.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::All);\n\tFarEntityQuery.AddChunkRequirement<FMassVisualizationChunkFragment>(EMassFragmentAccess::ReadOnly);\n\tFarEntityQuery.SetChunkFilter(&FMassVisualizationChunkFragment::ShouldUpdateVisualizationForChunk);\n\tFarEntityQuery.RegisterWithProcessor(*this);\n\n\tDebugEntityQuery = BaseQuery;\n\tDebugEntityQuery.RegisterWithProcessor(*this);\n\n\tProcessorRequirements.AddSubsystemRequirement<UMassLODSubsystem>(EMassFragmentAccess::ReadOnly);\n}\n\nvoid UMassDistanceLODProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tif (bForceOFFLOD)\n\t{\n\t\tCloseEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t\t{\n\t\t\tFMassDistanceLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassDistanceLODSharedFragment>();\n\t\t\tTArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetMutableFragmentView<FMassRepresentationLODFragment>();\n\t\t\tLODSharedFragment.LODCalculator.ForceOffLOD(Context, RepresentationLODList);\n\t\t});\n\t\treturn;\n\t}\n\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(PrepareExecution)\n\t\tconst UMassLODSubsystem& LODSubsystem = Context.GetSubsystemChecked<UMassLODSubsystem>();\n\t\tconst TArray<FViewerInfo>& Viewers = LODSubsystem.GetViewers();\n\t\tEntityManager.ForEachSharedFragment<FMassDistanceLODSharedFragment>([this, &Viewers](FMassDistanceLODSharedFragment& LODSharedFragment)\n\t\t{\n\t\t\tif (FilterTag == LODSharedFragment.FilterTag)\n\t\t\t{\n\t\t\t\tLODSharedFragment.LODCalculator.PrepareExecution(Viewers);\n\t\t\t}\n\t\t});\n\t}\n\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(CalculateLOD)\n\n\t\tauto CalculateLOD = [this](FMassExecutionContext& Context)\n\t\t{\n\t\t\tFMassDistanceLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassDistanceLODSharedFragment>();\n\t\t\tTArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetMutableFragmentView<FMassRepresentationLODFragment>();\n\t\t\tTConstArrayView<FMassViewerInfoFragment> ViewerInfoList = Context.GetFragmentView<FMassViewerInfoFragment>();\n\t\t\tLODSharedFragment.LODCalculator.CalculateLOD(Context, ViewerInfoList, RepresentationLODList);\n\t\t};\n\t\tCloseEntityQuery.ForEachEntityChunk(EntityManager, Context, CalculateLOD);\n\t\tFarEntityQuery.ForEachEntityChunk(EntityManager, Context, CalculateLOD);\n\t}\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\t// Optional debug display\n\tif (UE::Mass::Representation::Debug::DebugRepresentationLOD == 1 || UE::Mass::Representation::Debug::DebugRepresentationLOD >= 3)\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(DebugDisplayLOD)\n\t\tUWorld* World = EntityManager.GetWorld();\n\t\tDebugEntityQuery.ForEachEntityChunk(EntityManager, Context, [World](FMassExecutionContext& Context)\n\t\t{\n\t\t\tFMassDistanceLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassDistanceLODSharedFragment>();\n\t\t\tTConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();\n\t\t\tTConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();\n\t\t\tLODSharedFragment.LODCalculator.DebugDisplaySignificantLOD(Context, RepresentationLODList, TransformList, World, UE::Mass::Representation::Debug::DebugRepresentationLODMaxSignificance);\n\t\t});\n\t}\n\t// Optional vislog\n\tif (UE::Mass::Representation::Debug::DebugRepresentationLOD >= 2)\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(VisLogLOD)\n\t\tDebugEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t\t{\n\t\t\tFMassDistanceLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassDistanceLODSharedFragment>();\n\t\t\tTConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();\n\t\t\tTConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();\n\t\t\tLODSharedFragment.LODCalculator.VisLogSignificantLOD(Context, RepresentationLODList, TransformList, this, UE::Mass::Representation::Debug::DebugRepresentationLODMaxSignificance);\n\t\t});\n\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n}\n",
      "lines": 108
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassDistanceVisualizationTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 5034,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassDistanceVisualizationTrait.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"MassRepresentationSubsystem.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassRepresentationFragments.h\"\n#include \"MassRepresentationActorManagement.h\"\n#include \"Engine/World.h\"\n#include \"MassLODFragments.h\"\n#include \"MassActorSubsystem.h\"\n#include \"MassEntityUtils.h\"\n#include \"MassDistanceLODProcessor.h\"\n#include \"MassRepresentationProcessor.h\"\n\n\nUMassDistanceVisualizationTrait::UMassDistanceVisualizationTrait()\n{\n\tRepresentationSubsystemClass = UMassRepresentationSubsystem::StaticClass();\n\n\tParams.RepresentationActorManagementClass = UMassRepresentationActorManagement::StaticClass();\n\tParams.LODRepresentation[EMassLOD::High] = EMassRepresentationType::HighResSpawnedActor;\n\tParams.LODRepresentation[EMassLOD::Medium] = EMassRepresentationType::LowResSpawnedActor;\n\tParams.LODRepresentation[EMassLOD::Low] = EMassRepresentationType::StaticMeshInstance;\n\tParams.LODRepresentation[EMassLOD::Off] = EMassRepresentationType::None;\n\n\tLODParams.LODDistance[EMassLOD::High] = 0.f;\n\tLODParams.LODDistance[EMassLOD::Medium] = 1000.f;\n\tLODParams.LODDistance[EMassLOD::Low] = 2500.f;\n\tLODParams.LODDistance[EMassLOD::Off] = 10000.f;\n\n\tLODParams.BufferHysteresisOnDistancePercentage = 10.0f;\n\n\tbAllowServerSideVisualization = false;\n}\n\nvoid UMassDistanceVisualizationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\t// This should not be ran on NM_Server network mode\n\tif (World.IsNetMode(NM_DedicatedServer) && !bAllowServerSideVisualization\n\t\t&& !BuildContext.IsInspectingData())\n\t{\n\t\treturn;\n\t}\n\n\tBuildContext.RequireFragment<FMassViewerInfoFragment>();\n\tBuildContext.RequireFragment<FTransformFragment>();\n\tBuildContext.RequireFragment<FMassActorFragment>();\n\n\tFMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(World);\n\n\tUMassRepresentationSubsystem* RepresentationSubsystem = Cast<UMassRepresentationSubsystem>(World.GetSubsystemBase(RepresentationSubsystemClass));\n\tif (RepresentationSubsystem == nullptr && !BuildContext.IsInspectingData())\n\t{\n\t\tUE_LOG(LogMassRepresentation, Error, TEXT(\"Expecting a valid class for the representation subsystem\"));\n\t\tRepresentationSubsystem = UWorld::GetSubsystem<UMassRepresentationSubsystem>(&World);\n\t\tcheck(RepresentationSubsystem);\n\t}\n\n\tFMassRepresentationSubsystemSharedFragment SubsystemSharedFragment;\n\tSubsystemSharedFragment.RepresentationSubsystem = RepresentationSubsystem;\n\tFSharedStruct SubsystemFragment = EntityManager.GetOrCreateSharedFragment<FMassRepresentationSubsystemSharedFragment>(SubsystemSharedFragment);\n\tBuildContext.AddSharedFragment(SubsystemFragment);\n\n\tif (!Params.RepresentationActorManagementClass && !BuildContext.IsInspectingData())\n\t{\n\t\tUE_LOG(LogMassRepresentation, Error, TEXT(\"Expecting a valid class for the representation actor management\"));\n\t}\n\tFConstSharedStruct ParamsFragment = EntityManager.GetOrCreateConstSharedFragment(Params);\n\tParamsFragment.Get<const FMassRepresentationParameters>().ComputeCachedValues();\n\tBuildContext.AddConstSharedFragment(ParamsFragment);\n\n\tFMassRepresentationFragment& RepresentationFragment = BuildContext.AddFragment_GetRef<FMassRepresentationFragment>();\n\tif (LIKELY(!BuildContext.IsInspectingData()))\n\t{\n\t\tif (bRegisterStaticMeshDesc && !BuildContext.IsInspectingData())\n\t\t{\n\t\t\tRepresentationFragment.StaticMeshDescHandle = RepresentationSubsystem->FindOrAddStaticMeshDesc(StaticMeshInstanceDesc);\n\t\t}\n\t\tRepresentationFragment.HighResTemplateActorIndex = HighResTemplateActor.Get() ? RepresentationSubsystem->FindOrAddTemplateActor(HighResTemplateActor.Get()) : INDEX_NONE;\n\t\tRepresentationFragment.LowResTemplateActorIndex = LowResTemplateActor.Get() ? RepresentationSubsystem->FindOrAddTemplateActor(LowResTemplateActor.Get()) : INDEX_NONE;\n\t}\n\n\tFConstSharedStruct LODParamsFragment = EntityManager.GetOrCreateConstSharedFragment(LODParams);\n\tBuildContext.AddConstSharedFragment(LODParamsFragment);\n\n\tFSharedStruct LODSharedFragment = EntityManager.GetOrCreateSharedFragment<FMassDistanceLODSharedFragment>(FConstStructView::Make(LODParams), LODParams);\n\tBuildContext.AddSharedFragment(LODSharedFragment);\n\n\tBuildContext.AddFragment<FMassRepresentationLODFragment>();\n\tBuildContext.AddTag<FMassVisibilityCulledByDistanceTag>();\n\tBuildContext.AddChunkFragment<FMassVisualizationChunkFragment>();\n\n\tBuildContext.AddTag<FMassDistanceLODProcessorTag>();\n\tBuildContext.AddTag<FMassVisualizationProcessorTag>();\n}\n\nvoid UMassDistanceVisualizationTrait::DestroyTemplate(const UWorld& World) const\n{\n\tif (UMassRepresentationSubsystem* RepresentationSubsystem = Cast<UMassRepresentationSubsystem>(World.GetSubsystemBase(RepresentationSubsystemClass)))\n\t{\n\t\tRepresentationSubsystem->ReleaseTemplate(HighResTemplateActor);\n\t\tRepresentationSubsystem->ReleaseTemplate(LowResTemplateActor);\n\t}\n}\n",
      "lines": 105
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassMovableVisualizationTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 614,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassMovableVisualizationTrait.h\"\n#include \"MassEntityTemplateRegistry.h\"\n\n\nvoid UMassMovableVisualizationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tif (!bAllowServerSideVisualization && World.IsNetMode(NM_DedicatedServer)\n\t\t&& !BuildContext.IsInspectingData())\n\t{\n\t\treturn;\n\t}\n\n\tfor (FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : StaticMeshInstanceDesc.Meshes)\n\t{\n\t\tMeshDesc.Mobility = EComponentMobility::Movable;\n\t}\n\n\tSuper::BuildTemplate(BuildContext, World);\n}\n",
      "lines": 21
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassRepresentationActorManagement.cpp",
      "extension": ".cpp",
      "size_bytes": 9161,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassRepresentationActorManagement.h\"\n#include \"MassRepresentationSubsystem.h\"\n#include \"MassRepresentationFragments.h\"\n#include \"MassCommandBuffer.h\"\n#include \"MassEntityView.h\"\n#include \"MassActorSubsystem.h\"\n\nfloat UMassRepresentationActorManagement::GetSpawnPriority(const FMassRepresentationLODFragment& Representation) const\n{\n\t// Bump up the spawning priority on the visible entities\n\treturn Representation.LODSignificance - (Representation.Visibility == EMassVisibility::CanBeSeen ? 1.0f : 0.0f);\n}\n\nAActor* UMassRepresentationActorManagement::GetOrSpawnActor(UMassRepresentationSubsystem& RepresentationSubsystem, FMassEntityManager& EntityManager\n\t, const FMassEntityHandle MassAgent, const FTransform& Transform, const int16 TemplateActorIndex\n\t, FMassActorSpawnRequestHandle& InOutSpawnRequestHandle, const float Priority) const\n{\n\tTSharedRef<FMassEntityManager> SharedEntityManager = EntityManager.AsShared();\n\n\treturn RepresentationSubsystem.GetOrSpawnActorFromTemplate(MassAgent, Transform, TemplateActorIndex, InOutSpawnRequestHandle, Priority,\n\t\tFMassActorPreSpawnDelegate::CreateUObject(this, &UMassRepresentationActorManagement::OnPreActorSpawn, SharedEntityManager),\n\t\tFMassActorPostSpawnDelegate::CreateUObject(this, &UMassRepresentationActorManagement::OnPostActorSpawn, SharedEntityManager));\n}\n\n\nvoid UMassRepresentationActorManagement::SetActorEnabled(const EMassActorEnabledType EnabledType, AActor& Actor, const int32 EntityIdx, FMassCommandBuffer& CommandBuffer) const\n{\n\tconst bool bEnabled = EnabledType != EMassActorEnabledType::Disabled;\n\tif (Actor.IsActorTickEnabled() != bEnabled)\n\t{\n\t\tActor.SetActorTickEnabled(bEnabled);\n\t}\n\tif (Actor.GetActorEnableCollision() != bEnabled)\n\t{\n\t\t// Deferring this as there is a callback internally that could end up doing things outside of the game thread and will fire checks(Chaos mostly)\n\t\tCommandBuffer.PushCommand<FMassDeferredSetCommand>([&Actor, bEnabled](FMassEntityManager&)\n\t\t{\n\t\t\tActor.SetActorEnableCollision(bEnabled);\n\t\t});\n\t}\n}\n\nvoid UMassRepresentationActorManagement::TeleportActor(const FTransform& Transform, AActor& Actor, FMassCommandBuffer& CommandBuffer) const\n{\n\tif (!Actor.GetTransform().Equals(Transform))\n\t{\n\t\tCommandBuffer.PushCommand<FMassDeferredSetCommand>([&Actor, Transform](FMassEntityManager&)\n\t\t{\n\t\t\tActor.SetActorTransform(Transform, /*bSweep*/false, /*OutSweepHitResult*/nullptr, ETeleportType::TeleportPhysics);\n\t\t});\n\t}\n}\n\nvoid UMassRepresentationActorManagement::OnPreActorSpawn(const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest, TSharedRef<FMassEntityManager> EntityManager) const\n{\n\tconst FMassActorSpawnRequest& MassActorSpawnRequest = SpawnRequest.Get<const FMassActorSpawnRequest>();\n\tconst FMassEntityView EntityView(*EntityManager, MassActorSpawnRequest.MassAgent);\n\tFMassActorFragment& ActorInfo = EntityView.GetFragmentData<FMassActorFragment>();\n\tFMassRepresentationFragment& Representation = EntityView.GetFragmentData<FMassRepresentationFragment>();\n\tUMassRepresentationSubsystem* RepresentationSubsystem = EntityView.GetSharedFragmentData<FMassRepresentationSubsystemSharedFragment>().RepresentationSubsystem;\n\tcheck(RepresentationSubsystem);\n\n\t// Release any existing actor\n\tif (AActor* Actor = ActorInfo.GetMutable())\n\t{\n\t\tcheckf(ActorInfo.IsOwnedByMass(), TEXT(\"If we reach here, we expect the actor to be owned by mass, otherwise we should not be spawning a new one one top of this one.\"));\n\n\t\t// WARNING!\n\t\t// Need to reset before ReleaseTemplateActor as this action might move the entity to a new archetype and\n\t\t// so the Fragment passed in parameters would not be valid anymore.\n\t\tActorInfo.ResetAndUpdateHandleMap();\n\n\t\tif (!RepresentationSubsystem->ReleaseTemplateActor(MassActorSpawnRequest.MassAgent, Representation.HighResTemplateActorIndex, Actor, /*bImmediate*/ true))\n\t\t{\n\t\t\tif (!RepresentationSubsystem->ReleaseTemplateActor(MassActorSpawnRequest.MassAgent, Representation.LowResTemplateActorIndex, Actor, /*bImmediate*/ true))\n\t\t\t{\n\t\t\t\tcheckf(false, TEXT(\"Expecting to be able to release spawned actor either the high res or low res one\"));\n\t\t\t}\n\t\t}\n\t}\n}\n\nEMassActorSpawnRequestAction UMassRepresentationActorManagement::OnPostActorSpawn(const FMassActorSpawnRequestHandle& SpawnRequestHandle\n\t, FConstStructView SpawnRequest, TSharedRef<FMassEntityManager> EntityManager) const\n{\n\tconst FMassActorSpawnRequest& MassActorSpawnRequest = SpawnRequest.Get<const FMassActorSpawnRequest>();\n\t\n\tif (MassActorSpawnRequest.SpawnedActor)\n\t{\n\t\t// Might be already done if the actor has a MassAgentComponent via the callback OnMassAgentComponentEntityAssociated on the MassRepresentationSubsystem\n\t\tFMassActorFragment& ActorInfo = EntityManager->GetFragmentDataChecked<FMassActorFragment>(MassActorSpawnRequest.MassAgent);\n\t\tif (ActorInfo.IsValid())\n\t\t{\n\t\t\t// If already set, make sure it is pointing to the same actor.\n\t\t\tcheckf(ActorInfo.Get() == MassActorSpawnRequest.SpawnedActor, TEXT(\"Expecting the pointer to the spawned actor in the actor fragment\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tActorInfo.SetAndUpdateHandleMap(MassActorSpawnRequest.MassAgent, MassActorSpawnRequest.SpawnedActor, true/*bIsOwnedByMass*/);\n\t\t}\n\n\t\t// by default we keep the spawn request since there's code in other places that will consume this request by \n\t\t// calling RemoveActorSpawnRequest (like UMassRepresentationSubsystem::GetOrSpawnActorFromTemplate)\n\t\treturn EMassActorSpawnRequestAction::Keep;\n\t}\n\n\treturn EMassActorSpawnRequestAction::Remove;\n}\n\nvoid UMassRepresentationActorManagement::ReleaseAnyActorOrCancelAnySpawning(FMassEntityManager& EntityManager, const FMassEntityHandle MassAgent)\n{\n\tFMassEntityView EntityView(EntityManager, MassAgent);\n\tFMassActorFragment& ActorInfo = EntityView.GetFragmentData<FMassActorFragment>();\n\tFMassRepresentationFragment& Representation = EntityView.GetFragmentData<FMassRepresentationFragment>();\n\tUMassRepresentationSubsystem* RepresentationSubsystem = EntityView.GetSharedFragmentData<FMassRepresentationSubsystemSharedFragment>().RepresentationSubsystem;\n\tcheck(RepresentationSubsystem);\n\tReleaseAnyActorOrCancelAnySpawning(*RepresentationSubsystem, MassAgent, ActorInfo, Representation);\n}\n\nvoid UMassRepresentationActorManagement::ReleaseAnyActorOrCancelAnySpawning(UMassRepresentationSubsystem& RepresentationSubsystem\n\t, const FMassEntityHandle MassAgent, FMassActorFragment& ActorInfo, FMassRepresentationFragment& Representation\n\t, UMassActorSubsystem* CachedActorSubsystem)\n{\n\t// This method can only release owned by mass actors\n\tAActor* Actor = ActorInfo.GetOwnedByMassMutable();\n\tif (Actor)\n\t{\n\t\t// WARNING!\n\t\t// Need to reset before ReleaseTemplateActorOrCancelSpawning as this action might move the entity to a new archetype and\n\t\t// so the Fragment passed in parameters would not be valid anymore.\n\t\tActorInfo.ResetAndUpdateHandleMap(CachedActorSubsystem);\n\t}\n\t// Try releasing both as we can have a low res actor and a high res spawning request\n\tif (Representation.HighResTemplateActorIndex != INDEX_NONE)\n\t{\n\t\tRepresentationSubsystem.ReleaseTemplateActorOrCancelSpawning(MassAgent, Representation.HighResTemplateActorIndex, Actor, Representation.ActorSpawnRequestHandle);\n\t}\t\n\tif (Representation.LowResTemplateActorIndex != Representation.HighResTemplateActorIndex && Representation.LowResTemplateActorIndex != INDEX_NONE)\n\t{\n\t\tRepresentationSubsystem.ReleaseTemplateActorOrCancelSpawning(MassAgent, Representation.LowResTemplateActorIndex, Actor, Representation.ActorSpawnRequestHandle);\n\t}\n\tcheck(!Representation.ActorSpawnRequestHandle.IsValid());\n}\n\n\n//-----------------------------------------------------------------------------\n// DEPRECATED\n//-----------------------------------------------------------------------------\nAActor* UMassRepresentationActorManagement::GetOrSpawnActor(UMassRepresentationSubsystem& RepresentationSubsystem, FMassEntityManager& EntityManager\n\t, const FMassEntityHandle MassAgent, FMassActorFragment&/* OutActorInfo*/, const FTransform& Transform, const int16 TemplateActorIndex\n\t, FMassActorSpawnRequestHandle& InOutSpawnRequestHandle, const float Priority) const\n{\n\treturn GetOrSpawnActor(RepresentationSubsystem, EntityManager\n\t\t, MassAgent, Transform, TemplateActorIndex\n\t\t, InOutSpawnRequestHandle, Priority);\n}\n\nvoid UMassRepresentationActorManagement::OnPreActorSpawn(const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest, FMassEntityManager* EntityManager) const\n{\n\tif (EntityManager)\n\t{\n\t\tOnPreActorSpawn(SpawnRequestHandle, SpawnRequest, EntityManager->AsShared());\n\t}\n}\n\nEMassActorSpawnRequestAction UMassRepresentationActorManagement::OnPostActorSpawn(const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest, FMassEntityManager* EntityManager) const\n{\n\tif (EntityManager)\n\t{\n\t\treturn OnPostActorSpawn(SpawnRequestHandle, SpawnRequest, EntityManager->AsShared());\n\t}\n\n\treturn EMassActorSpawnRequestAction::Remove;\n}\n",
      "lines": 176
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassRepresentationDebug.cpp",
      "extension": ".cpp",
      "size_bytes": 4838,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassRepresentationDebug.h\"\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\n#include \"DrawDebugHelpers.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassRepresentationFragments.h\"\n#include \"Math/Color.h\"\n#include \"VisualLogger/VisualLogger.h\"\n\nnamespace UE::Mass::Representation::Debug\n{\n\tFColor RepresentationColors[] =\n\t{\n\t\tFColor::Purple, // HighResSpawnedActor,\n\t\tFColor::Turquoise, // LowResSpawnedActor\n\t\tFColor::Orange, // StaticMeshInstance\n\t\tFColor::White, // None\n\t};\n\n\tint32 DebugRepresentation = 0;\n\tFAutoConsoleVariableRef CVarDebugRepresentation(TEXT(\"mass.debug.Representation\"), DebugRepresentation, TEXT(\"Debug current representation 0 = Off, 1 = Debug Draw, 2 = VisLog, 3 = Both\"), ECVF_Cheat);\n\n\tfloat DebugRepresentationMaxSignificance = float(EMassLOD::Max);\n\tFAutoConsoleVariableRef CVarDebugRepresentationMaxSignificance(TEXT(\"mass.debug.Representation.MaxSignificance\"), DebugRepresentationMaxSignificance, TEXT(\"Max LODSignificance for entities to draw / vislog with mass.debug.Representation enabled\"), ECVF_Cheat);\n\n\tint32 DebugRepresentationLOD = 0;\n\tFAutoConsoleVariableRef CVarDebugRepresentationLOD(TEXT(\"mass.debug.RepresentationLOD\"), DebugRepresentationLOD, TEXT(\"Debug representation LOD 0 = Off, 1 = Debug Draw, 2 = VisLog, 3 = Both\"), ECVF_Cheat);\n\n\tfloat DebugRepresentationLODMaxSignificance = float(EMassLOD::Max);\n\tFAutoConsoleVariableRef CVarDebugRepresentationLODMaxSignificance(TEXT(\"mass.debug.RepresentationLOD.MaxSignificance\"), DebugRepresentationLODMaxSignificance, TEXT(\"Max LODSignificance for entities to draw / vislog with mass.debug.RepresentationLOD enabled\"), ECVF_Cheat);\n\n\tvoid DebugDisplayRepresentation(FMassExecutionContext& Context, TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList, TConstArrayView<FMassRepresentationFragment> RepresentationList, TConstArrayView<FTransformFragment> LocationList, UWorld* World)\n\t{\n#if UE_ENABLE_DEBUG_DRAWING\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tfor (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t\t{\n\t\t\tconst FMassRepresentationLODFragment& RepresentationLOD = RepresentationLODList[EntityIdx];\n\t\t\tif (RepresentationLOD.LODSignificance <= UE::Mass::Representation::Debug::DebugRepresentationMaxSignificance)\n\t\t\t{\n\t\t\t\tconst FMassRepresentationFragment& Representation = RepresentationList[EntityIdx];\n\t\t\t\tconst FTransformFragment& EntityLocation = LocationList[EntityIdx];\n\t\t\t\tint32 CurrentRepresentationIdx = (int32)Representation.CurrentRepresentation;\n\t\t\t\tDrawDebugSolidBox(World, EntityLocation.GetTransform().GetLocation() + FVector(0.0f, 0.0f, 150.0f), FVector(25.0f), UE::Mass::Representation::Debug::RepresentationColors[CurrentRepresentationIdx]);\n\t\t\t}\n\t\t}\n#endif // UE_ENABLE_DEBUG_DRAWING\n\t}\n\n\tvoid VisLogRepresentation(FMassExecutionContext& Context, TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList, TConstArrayView<FMassRepresentationFragment> RepresentationList, TConstArrayView<FTransformFragment> LocationList, UObject* LogOwner)\n\t{\n#if ENABLE_VISUAL_LOG\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tfor (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t\t{\n\t\t\tconst FMassRepresentationLODFragment& RepresentationLOD = RepresentationLODList[EntityIdx];\n\t\t\tif (RepresentationLOD.LODSignificance <= UE::Mass::Representation::Debug::DebugRepresentationMaxSignificance)\n\t\t\t{\n\t\t\t\tconst FTransformFragment& EntityLocation = LocationList[EntityIdx];\n\t\t\t\tconst FMassRepresentationFragment& Representation = RepresentationList[EntityIdx];\n\t\t\t\tint32 CurrentRepresentationIdx = (int32)Representation.CurrentRepresentation;\n\t\t\t\tint32 PrevRepresentationIdx = (int32)Representation.PrevRepresentation;\n\t\t\t\t// Add 20cm +Z offset to draw above mass.debug.RepresentationLOD so they can be viewed together\n\t\t\t\tUE_CVLOG_LOCATION(Representation.CurrentRepresentation == Representation.PrevRepresentation, LogOwner, LogMassRepresentation, Verbose, EntityLocation.GetTransform().GetLocation() + FVector(0.0f, 0.0f, 20.0f), 20, UE::Mass::Representation::Debug::RepresentationColors[CurrentRepresentationIdx], TEXT(\"%s %d\"), *Context.GetEntity(EntityIdx).DebugGetDescription(), CurrentRepresentationIdx);\n\t\t\t\tUE_CVLOG_LOCATION(Representation.CurrentRepresentation != Representation.PrevRepresentation, LogOwner, LogMassRepresentation, Verbose, EntityLocation.GetTransform().GetLocation() + FVector(0.0f, 0.0f, 20.0f), 20, UE::Mass::Representation::Debug::RepresentationColors[CurrentRepresentationIdx], TEXT(\"%s %d -> %d\"), *Context.GetEntity(EntityIdx).DebugGetDescription(), PrevRepresentationIdx, CurrentRepresentationIdx);\n\t\t\t}\n\t\t}\n#endif // ENABLE_VISUAL_LOG\n\t}\n}\n\n#endif // WITH_MASSGAMEPLAY_DEBUG\n",
      "lines": 76
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassRepresentationFragments.cpp",
      "extension": ".cpp",
      "size_bytes": 821,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassRepresentationFragments.h\"\n\nFMassVisualizationLODSharedFragment::FMassVisualizationLODSharedFragment(const FMassVisualizationLODParameters& LODParams)\n{\n\tLODCalculator.Initialize(LODParams.BaseLODDistance, LODParams.BufferHysteresisOnDistancePercentage / 100.f, LODParams.LODMaxCount\n\t\t, /*InLODMaxCountPerViewer=*/nullptr, LODParams.DistanceToFrustum, LODParams.DistanceToFrustumHysteresis, LODParams.VisibleLODDistance);\n\tFilterTag = LODParams.FilterTag;\n}\n\nFMassDistanceLODSharedFragment::FMassDistanceLODSharedFragment(const FMassDistanceLODParameters& LODParams)\n{\n\tLODCalculator.Initialize(LODParams.LODDistance, LODParams.BufferHysteresisOnDistancePercentage / 100.f, /*InLODMaxCount=*/nullptr);\n\tFilterTag = LODParams.FilterTag;\n}\n",
      "lines": 16
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassRepresentationModule.cpp",
      "extension": ".cpp",
      "size_bytes": 726,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CoreMinimal.h\"\n#include \"IMassRepresentationModule.h\"\n#include \"UObject/CoreRedirects.h\"\n\nclass FMassRepresentationModule : public IMassRepresentationModule\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nIMPLEMENT_MODULE(FMassRepresentationModule, MassRepresentation)\n\n\n\nvoid FMassRepresentationModule::StartupModule()\n{\n}\n\n\nvoid FMassRepresentationModule::ShutdownModule()\n{\n\t// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n\t// we call this function before unloading the module.\n}\n\n\n\n",
      "lines": 30
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassRepresentationProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 25257,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassRepresentationProcessor.h\"\n#include \"MassRepresentationDebug.h\"\n#include \"MassRepresentationSubsystem.h\"\n#include \"MassRepresentationUtils.h\"\n#include \"MassActorSubsystem.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassCommandBuffer.h\"\n#include \"MassEntityManager.h\"\n#include \"MassEntityView.h\"\n#include \"Engine/World.h\"\n#include \"MassRepresentationActorManagement.h\"\n#include \"MassCommonUtils.h\"\n#include \"MassEntityUtils.h\"\n#include \"MassExecutionContext.h\"\n\n\nDECLARE_CYCLE_STAT(TEXT(\"Mass Visualization Execute\"), STAT_Mass_VisProcessor_Execute, STATGROUP_Mass);\n\nnamespace UE::Mass::Representation\n{\n\tint32 bAllowKeepActorExtraFrame = 1;\n\tFAutoConsoleVariableRef CVarAllowKeepActorExtraFrame(TEXT(\"ai.massrepresentation.AllowKeepActorExtraFrame\"), bAllowKeepActorExtraFrame, TEXT(\"Allow the mass representation to keep actor an extra frame when switching to ISM\"), ECVF_Default);\n}\n\n//----------------------------------------------------------------------//\n// UMassRepresentationProcessor(); \n//----------------------------------------------------------------------//\nUMassRepresentationProcessor::UMassRepresentationProcessor()\n\t: EntityQuery(*this)\n{\n\tbAutoRegisterWithProcessingPhases = false;\n\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Representation;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LOD);\n}\n\nvoid UMassRepresentationProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassRepresentationFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassRepresentationLODFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassActorFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddConstSharedRequirement<FMassRepresentationParameters>();\n\tEntityQuery.AddSharedRequirement<FMassRepresentationSubsystemSharedFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddSubsystemRequirement<UMassActorSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassRepresentationProcessor::UpdateRepresentation(FMassExecutionContext& Context, const FMassRepresentationUpdateParams& Params)\n{\n\tUMassRepresentationSubsystem* RepresentationSubsystem = Context.GetMutableSharedFragment<FMassRepresentationSubsystemSharedFragment>().RepresentationSubsystem;\n\tcheck(RepresentationSubsystem);\n\n\tconst FMassRepresentationParameters& RepresentationParams = Context.GetConstSharedFragment<FMassRepresentationParameters>();\n\tUMassRepresentationActorManagement* RepresentationActorManagement = RepresentationParams.CachedRepresentationActorManagement;\n\tcheck(RepresentationActorManagement);\n\n\tUMassActorSubsystem* MassActorSubsystem = Context.GetMutableSubsystem<UMassActorSubsystem>();\n\n\tFMassEntityManager& CachedEntityManager = Context.GetEntityManagerChecked();\n\t\n\t// Get Transform, Representation, RepresentationLOD and Actor fragments from Context\n\tconst TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();\n\tconst TArrayView<FMassRepresentationFragment> RepresentationList = Context.GetMutableFragmentView<FMassRepresentationFragment>();\n\tconst TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();\n\tconst TArrayView<FMassActorFragment> ActorList = Context.GetMutableFragmentView<FMassActorFragment>();\n\n\tconst bool bDoKeepActorExtraFrame = UE::Mass::Representation::bAllowKeepActorExtraFrame ? RepresentationParams.bKeepLowResActors : false;\n\n\t// Iterate over all entities, and:\n\t// 1. Find their current EMassRepresentationType value based on their current RepresentationLOD;\n\t// 2. Change EMassRepresentationType value based on some configs (not all flows will care about this);\n\t// 3. Switch the in-game instance representation depending on the EMassRepresentationType;\n\t// \t\ta. If EMassRepresentationType == HighResSpawnedActor or LowResSpawnedActor, sends an Actor SpawnRequest to MassRepresentationActorManagement;\n\t// \t\tb. If EMassRepresentationType == StaticMeshInstance, sends an Actor disable request to MassRepresentationActorManagement;\n\t//\t\tc. If EMassRepresentationType == StaticMeshInstance, sends an Actor disable request to MassRepresentationActorManagement.\n\t// \t\tNOTE: I guess this system assumes all instances are already represented by ISMs, which is why we're only dealing with Actor spawn/deactivation\n\tconst int32 NumEntities = Context.GetNumEntities();\n\tfor (int32 EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t{\n\t\tconst FMassEntityHandle MassAgentEntityHandle = Context.GetEntity(EntityIdx);\n\t\tconst FTransformFragment& TransformFragment = TransformList[EntityIdx];\n\t\tconst FMassRepresentationLODFragment& RepresentationLOD = RepresentationLODList[EntityIdx];\n\t\tFMassRepresentationFragment& Representation = RepresentationList[EntityIdx];\n\t\tFMassActorFragment& ActorInfo = ActorList[EntityIdx];\n\t\tAActor* Actor = ActorInfo.GetMutable();\n\n\t\t// Keeping a copy of the that last calculated previous representation\n\t\tconst EMassRepresentationType PrevRepresentationCopy = Representation.PrevRepresentation;\n\t\tRepresentation.PrevRepresentation = Representation.CurrentRepresentation;\n\n\t\t// === 1. Find the current EMassRepresentationType value based on their current RepresentationLOD\t\t\n\t\tEMassRepresentationType WantedRepresentationType = RepresentationParams.LODRepresentation[FMath::Min((int32)RepresentationLOD.LOD, (int32)EMassLOD::Off)];\n\t\t// === 1 end\n\n\t\t// === 2. Change EMassRepresentationType value based on some configs (not all flows will care about this)\n\t\t// Make sure we do not have actor spawned in areas not fully loaded\n\t\tif (Params.bTestCollisionAvailibilityForActorVisualization\n\t\t\t&& (WantedRepresentationType == EMassRepresentationType::HighResSpawnedActor || WantedRepresentationType == EMassRepresentationType::LowResSpawnedActor)\n\t\t\t&& !RepresentationSubsystem->IsCollisionLoaded(RepresentationParams.WorldPartitionGridNameContainingCollision, TransformFragment.GetTransform()))\n\t\t{\n\t\t\tWantedRepresentationType = RepresentationParams.CachedDefaultRepresentationType;\n\t\t}\n\n\t\t// If bForceActorRepresentationForExternalActors is enabled and we have an Actor reference for this entity, forcibly use it\n\t\t// by enforcing an actor representation as the WantedRepresentation. If we're coming from ISMC, we'll remove the instance\n\t\t// and switch to this actor, commiting either LowResSpawnedActor or HighResSpawnedActor as the new CurrentRepresentation.\n\t\t// Once the Actor is destroyed however, this override stops, allowing the natural WantedRepresentationType to return.\n\t\t//\n\t\t// Useful for server-authoritative Actor spawning, with replicated Actors inserting themselves into Mass whilst they're\n\t\t// replicated, enforcing actor representation on clients whilst they're present.\n\t\t//\n\t\t// NOTE:\n\t\t// IsOwnedByMass = Hydrated by mass\n\t\t// !IsOwnedByMass = Hydrated by some external system\n\t\tif (IsValid(Actor))\n\t\t{\n\t\t\tif (RepresentationParams.bForceActorRepresentationForExternalActors && !ActorInfo.IsOwnedByMass())\n\t\t\t{\n\t\t\t\tWantedRepresentationType = (Representation.CurrentRepresentation == EMassRepresentationType::LowResSpawnedActor)\n\t\t\t\t\t? EMassRepresentationType::LowResSpawnedActor\n\t\t\t\t\t: EMassRepresentationType::HighResSpawnedActor;\n\t\t\t}\n\t\t}\n\t\t// Has Actor unexpectedly been unset / destroyed since we last ran? \n\t\telse if (Representation.CurrentRepresentation == EMassRepresentationType::LowResSpawnedActor \n\t\t\t|| Representation.CurrentRepresentation == EMassRepresentationType::HighResSpawnedActor)\n\t\t{\n\t\t\t// Set CurrentRepresentation = None so we get a chance to see CurrentRepresentation != WantedRepresentationType and spawn \n\t\t\t// another actor.\n\t\t\tRepresentation.CurrentRepresentation = EMassRepresentationType::None;\n\t\t}\n\t\t// === 2 end\n\n\t\tauto DisableActorForISM = [&](AActor*& Actor)\n\t\t{\n\t\t\tif (!Actor || ActorInfo.IsOwnedByMass())\n\t\t\t{\n\t\t\t\t// Execute only if the high res is different than the low res Actor \n\t\t\t\t// Or if we do not wish to keep the low res actor while in TransformList\n\t\t\t\tif (Representation.HighResTemplateActorIndex != Representation.LowResTemplateActorIndex || !RepresentationParams.bKeepLowResActors)\n\t\t\t\t{\n\t\t\t\t\t// Try releasing the high actor or any high res spawning request\n\t\t\t\t\tif (ReleaseActorOrCancelSpawning(*RepresentationSubsystem, MassActorSubsystem, MassAgentEntityHandle, ActorInfo, Representation.HighResTemplateActorIndex, Representation.ActorSpawnRequestHandle, Context.Defer()))\n\t\t\t\t\t{\n\t\t\t\t\t\tActor = ActorInfo.GetOwnedByMassMutable();\n\t\t\t\t\t}\n\t\t\t\t\t// Do not do the same with low res if indicated so\n\t\t\t\t\tif (!RepresentationParams.bKeepLowResActors && ReleaseActorOrCancelSpawning(*RepresentationSubsystem, MassActorSubsystem, MassAgentEntityHandle, ActorInfo, Representation.LowResTemplateActorIndex, Representation.ActorSpawnRequestHandle, Context.Defer()))\n\t\t\t\t\t{\n\t\t\t\t\t\tActor = ActorInfo.GetOwnedByMassMutable();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If we already queued spawn request but have changed our mind, continue with it but once we get the actor back, disable it immediately\n\t\t\t\tif (Representation.ActorSpawnRequestHandle.IsValid())\n\t\t\t\t{\n\t\t\t\t\tActor = RepresentationActorManagement->GetOrSpawnActor(*RepresentationSubsystem, CachedEntityManager, MassAgentEntityHandle, TransformFragment.GetTransform(), Representation.LowResTemplateActorIndex, Representation.ActorSpawnRequestHandle, RepresentationActorManagement->GetSpawnPriority(RepresentationLOD));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Actor != nullptr)\n\t\t\t{\n\t\t\t\tRepresentationActorManagement->SetActorEnabled(EMassActorEnabledType::Disabled, *Actor, EntityIdx, Context.Defer());\n\t\t\t}\n\t\t};\n\n\t\t// === 3. Switch the in-game instance representation depending on the EMassRepresentationType;\n\t\t// Process switch between representation if there is a change in the representation or there is a pending spawning request\n\t\tif (WantedRepresentationType != Representation.CurrentRepresentation || Representation.ActorSpawnRequestHandle.IsValid())\n\t\t{\n\t\t\tif (Representation.CurrentRepresentation == EMassRepresentationType::None)\n\t\t\t{\n\t\t\t\tRepresentation.PrevTransform = TransformFragment.GetTransform();\n\t\t\t\tRepresentation.PrevLODSignificance = RepresentationLOD.LODSignificance;\n\t\t\t}\n\n\t\t\tswitch (WantedRepresentationType)\n\t\t\t{\n\t\t\t\tcase EMassRepresentationType::HighResSpawnedActor:\n\t\t\t\tcase EMassRepresentationType::LowResSpawnedActor:\n\t\t\t\t{\n\t\t\t\t\tconst bool bHighResActor = WantedRepresentationType == EMassRepresentationType::HighResSpawnedActor;\n\n\t\t\t\t\t// Reuse actor, if it is valid and not owned by mass or same representation as low res without a valid spawning request\n\t\t\t\t\tAActor* NewActor = nullptr;\n\t\t\t\t\tif (!Actor || ActorInfo.IsOwnedByMass())\n\t\t\t\t\t{\n\t\t\t\t\t\tconst int16 WantedTemplateActorIndex = bHighResActor ? Representation.HighResTemplateActorIndex : Representation.LowResTemplateActorIndex;\n\n\t\t\t\t\t\t// If the low res is different than the high res, cancel any pending spawn request that is the opposite of what is needed.\n\t\t\t\t\t\tif (Representation.LowResTemplateActorIndex != Representation.HighResTemplateActorIndex)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tReleaseActorOrCancelSpawning(*RepresentationSubsystem, MassActorSubsystem, MassAgentEntityHandle, ActorInfo, bHighResActor ? Representation.LowResTemplateActorIndex : Representation.HighResTemplateActorIndex, Representation.ActorSpawnRequestHandle, Context.Defer(), /*bCancelSpawningOnly*/true);\n\t\t\t\t\t\t\tActor = ActorInfo.GetOwnedByMassMutable();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If there isn't any actor yet or\n\t\t\t\t\t\t// If the actor isn't matching the one needed or\n\t\t\t\t\t\t// If there is still a pending spawn request\n\t\t\t\t\t\t// Then try to retrieve/spawn the new actor\n\t\t\t\t\t\tif (!Actor ||\n\t\t\t\t\t\t\t!RepresentationSubsystem->DoesActorMatchTemplate(*Actor, WantedTemplateActorIndex) ||\n\t\t\t\t\t\t\tRepresentation.ActorSpawnRequestHandle.IsValid())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNewActor = RepresentationActorManagement->GetOrSpawnActor(*RepresentationSubsystem, CachedEntityManager, MassAgentEntityHandle, TransformFragment.GetTransform(), WantedTemplateActorIndex, Representation.ActorSpawnRequestHandle, RepresentationActorManagement->GetSpawnPriority(RepresentationLOD));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNewActor = Actor;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tNewActor = Actor;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (NewActor)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Make sure our (re)activated actor is at the simulated position\n\t\t\t\t\t\t// Needs to be done before enabling the actor so the animation initialization can use the new values\n\t\t\t\t\t\tif (Representation.CurrentRepresentation == EMassRepresentationType::StaticMeshInstance)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRepresentationActorManagement->TeleportActor(Representation.PrevTransform, *NewActor, Context.Defer());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tRepresentationActorManagement->SetActorEnabled(bHighResActor ? EMassActorEnabledType::HighRes : EMassActorEnabledType::LowRes, *NewActor, EntityIdx, Context.Defer());\n\t\t\t\t\t\tRepresentation.CurrentRepresentation = WantedRepresentationType;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!Actor)\n\t\t\t\t\t{\n\t\t\t\t\t\tRepresentation.CurrentRepresentation = RepresentationParams.CachedDefaultRepresentationType;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase EMassRepresentationType::StaticMeshInstance:\n\t\t\t\t\tif (!bDoKeepActorExtraFrame || \n\t\t\t\t\t   (Representation.PrevRepresentation != EMassRepresentationType::HighResSpawnedActor && Representation.PrevRepresentation != EMassRepresentationType::LowResSpawnedActor))\n\t\t\t\t\t{\n\t\t\t\t\t\tDisableActorForISM(Actor);\n\t\t\t\t\t}\n \n\t\t\t\t\tRepresentation.CurrentRepresentation = EMassRepresentationType::StaticMeshInstance;\n\t\t\t\t\tbreak;\n\t\t\t\tcase EMassRepresentationType::None:\n\t\t\t\t\tif (!Actor || ActorInfo.IsOwnedByMass())\n\t\t\t\t\t{\n\t\t\t\t\t\t// Try releasing both, could have an high res spawned actor and a spawning request for a low res one\n\t\t\t\t\t\tReleaseActorOrCancelSpawning(*RepresentationSubsystem, MassActorSubsystem, MassAgentEntityHandle, ActorInfo, Representation.LowResTemplateActorIndex, Representation.ActorSpawnRequestHandle, Context.Defer());\n\t\t\t\t\t\tReleaseActorOrCancelSpawning(*RepresentationSubsystem, MassActorSubsystem, MassAgentEntityHandle, ActorInfo, Representation.HighResTemplateActorIndex, Representation.ActorSpawnRequestHandle, Context.Defer());\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tRepresentationActorManagement->SetActorEnabled(EMassActorEnabledType::Disabled, *Actor, EntityIdx, Context.Defer());\n\t\t\t\t\t}\n\t\t\t\t\tRepresentation.CurrentRepresentation = EMassRepresentationType::None;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcheckf(false, TEXT(\"Unsupported LOD type\"));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (bDoKeepActorExtraFrame\n\t\t\t\t&& Representation.PrevRepresentation == EMassRepresentationType::StaticMeshInstance \n\t\t\t\t&& (PrevRepresentationCopy == EMassRepresentationType::HighResSpawnedActor \n\t\t\t\t\t|| PrevRepresentationCopy == EMassRepresentationType::LowResSpawnedActor))\n\t\t{\n\t\t\tDisableActorForISM(Actor);\n\t\t}\n\t\t// === 3 end\n\t}\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\t// Optional debug display\n\tif (UE::Mass::Representation::Debug::DebugRepresentation == 1 || UE::Mass::Representation::Debug::DebugRepresentation >= 3)\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(DebugDisplayRepresentation)\n\t\tUWorld* World = CachedEntityManager.GetWorld();\n\t\tUE::Mass::Representation::Debug::DebugDisplayRepresentation(Context, RepresentationLODList, RepresentationList, TransformList, World);\n\t}\n\t// Optional vislog\n\tif (UE::Mass::Representation::Debug::DebugRepresentation >= 2)\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(VisLogRepresentation)\n\t\tUE::Mass::Representation::Debug::VisLogRepresentation(Context, RepresentationLODList, RepresentationList, TransformList, RepresentationSubsystem);\n\t}\n#endif\n}\n\nvoid UMassRepresentationProcessor::Execute(FMassEntityManager& InEntityManager, FMassExecutionContext& Context)\n{\n\t// Update entities representation\n\tEntityQuery.ForEachEntityChunk(InEntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tUpdateRepresentation(Context, UpdateParams);\n\t});\n}\n\nbool UMassRepresentationProcessor::ReleaseActorOrCancelSpawning(UMassRepresentationSubsystem& RepresentationSubsystem, UMassActorSubsystem* MassActorSubsystem\n\t, const FMassEntityHandle MassAgent, FMassActorFragment& ActorInfo, const int16 TemplateActorIndex, FMassActorSpawnRequestHandle& SpawnRequestHandle\n\t, FMassCommandBuffer& CommandBuffer, bool bCancelSpawningOnly /*= false*/)\n{\n\tif (TemplateActorIndex == INDEX_NONE)\n\t{\n\t\t// Nothing to release\n\t\treturn false;\n\t}\n\tcheck(!ActorInfo.IsValid() || ActorInfo.IsOwnedByMass());\n\n\tAActor* Actor = ActorInfo.GetOwnedByMassMutable();\n\t// note that it's fine for Actor to be null. That means the RepresentationSubsystem will try to stop \n\t// the spawning of whatever SpawnRequestHandle reference to\n\tconst bool bSuccess = bCancelSpawningOnly ? RepresentationSubsystem.CancelSpawning(MassAgent, TemplateActorIndex, SpawnRequestHandle) :\n\t\t\tRepresentationSubsystem.ReleaseTemplateActorOrCancelSpawning(MassAgent, TemplateActorIndex, Actor, SpawnRequestHandle);\n\tif (bSuccess)\n\t{\n\t\tActor = ActorInfo.GetOwnedByMassMutable();\n\t\tif (Actor && RepresentationSubsystem.DoesActorMatchTemplate(*Actor, TemplateActorIndex))\n\t\t{\n\t\t\tActorInfo.ResetNoHandleMapUpdate();\n\t\t\t\n\t\t\tTObjectKey<const AActor> ActorKey(Actor); \n\t\t\tif (MassActorSubsystem)\n\t\t\t{\n\t\t\t\tCommandBuffer.PushCommand<FMassDeferredSetCommand>([MassActorSubsystem, ActorKey](FMassEntityManager&)\n\t\t\t\t{\n\t\t\t\t\tMassActorSubsystem->RemoveHandleForActor(ActorKey);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//----------------------------------------------------------------------//\n// UMassVisualizationProcessor \n//----------------------------------------------------------------------//\nvoid UMassVisualizationProcessor::UpdateVisualization(FMassExecutionContext& Context)\n{\n\tFMassVisualizationChunkFragment& ChunkData = UpdateChunkVisibility(Context);\n\tif (!ChunkData.ShouldUpdateVisualization())\n\t{\n\t\treturn;\n\t}\n\n\tUpdateRepresentation(Context, UpdateParams);\n\n\t// Update entity visibility\n\tconst TArrayView<FMassRepresentationFragment> RepresentationList = Context.GetMutableFragmentView<FMassRepresentationFragment>();\n\tconst TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();\n\n\tconst int32 NumEntities = Context.GetNumEntities();\n\tfor (int32 EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t{\n\t\tconst FMassEntityHandle Entity = Context.GetEntity(EntityIdx);\n\t\tFMassRepresentationFragment& Representation = RepresentationList[EntityIdx];\n\t\tconst FMassRepresentationLODFragment& RepresentationLOD = RepresentationLODList[EntityIdx];\n\t\tUpdateEntityVisibility(Entity, Representation, RepresentationLOD, ChunkData, Context.Defer());\n\t}\n}\n\nvoid UMassVisualizationProcessor::ConfigureQueries()\n{\n\tSuper::ConfigureQueries();\n\tEntityQuery.AddChunkRequirement<FMassVisualizationChunkFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddTagRequirement<FMassVisualizationProcessorTag>(EMassFragmentPresence::All);\n}\n\nFMassVisualizationChunkFragment& UMassVisualizationProcessor::UpdateChunkVisibility(FMassExecutionContext& Context) const\n{\n\tconst FMassRepresentationParameters& RepresentationParams = Context.GetConstSharedFragment<FMassRepresentationParameters>();\n\tbool bFirstUpdate = false;\n\n\t// Setup chunk fragment data about visibility\n\tFMassVisualizationChunkFragment& ChunkData = Context.GetMutableChunkFragment<FMassVisualizationChunkFragment>();\n\tEMassVisibility ChunkVisibility = ChunkData.GetVisibility();\n\tif (ChunkVisibility == EMassVisibility::Max)\n\t{\n\t\t// The visibility on the chunk fragment data isn't set yet, let see if the Archetype has an visibility tag and set it on the ChunkData\n\t\tChunkVisibility = UE::Mass::Representation::GetVisibilityFromArchetype(Context);\n\t\tChunkData.SetVisibility(ChunkVisibility);\n\t\tbFirstUpdate = RepresentationParams.bSpreadFirstVisualizationUpdate;\n\t}\n\telse\n\t{\n\t\tcheckfSlow(UE::Mass::Representation::IsVisibilityTagSet(Context, ChunkVisibility), TEXT(\"Expecting the same Visibility as what we saved in the chunk data, maybe external code is modifying the tags\"))\n\t}\n\n\tif (ChunkVisibility == EMassVisibility::CulledByDistance)\n\t{\n\t\tfloat DeltaTime = ChunkData.GetDeltaTime();\n\t\tif (bFirstUpdate)\n\t\t{\n\t\t\t// A DeltaTime of 0.0f means it will tick this frame.\n\t\t\t// @todo: Add some randomization for deterministic runs too. The randomization is used to distribute the infrequent ticks evenly on different frames.\n\t\t\tDeltaTime = UE::Mass::Utils::IsDeterministic() ? RepresentationParams.NotVisibleUpdateRate * 0.5f : FMath::RandRange(0.0f, RepresentationParams.NotVisibleUpdateRate);\n\t\t}\n\t\telse \n\t\t{\n\t\t\tif (DeltaTime < 0.0f)\n\t\t\t{\n\t\t\t\t// @todo: Add some randomization for deterministic runs too. The randomization is used to distribute the infrequent ticks evenly on different frames.\n\t\t\t\tDeltaTime += UE::Mass::Utils::IsDeterministic() ? RepresentationParams.NotVisibleUpdateRate : (RepresentationParams.NotVisibleUpdateRate * (1.0f + FMath::RandRange(-0.1f, 0.1f)));\n\t\t\t}\n\t\t\tDeltaTime -= Context.GetDeltaTimeSeconds();\n\t\t}\n\n\t\tChunkData.Update(DeltaTime);\n\t}\n\n\treturn ChunkData;\n}\n\nvoid UMassVisualizationProcessor::UpdateEntityVisibility(const FMassEntityHandle Entity, const FMassRepresentationFragment& Representation, const FMassRepresentationLODFragment& RepresentationLOD, FMassVisualizationChunkFragment& ChunkData, FMassCommandBuffer& CommandBuffer)\n{\n\t// Move the visible entities together into same chunks so we can skip entire chunk when not visible as an optimization\n\tconst EMassVisibility Visibility = Representation.CurrentRepresentation != EMassRepresentationType::None ? \n\t\tEMassVisibility::CanBeSeen : RepresentationLOD.Visibility;\n\tconst EMassVisibility ChunkVisibility = ChunkData.GetVisibility();\n\tif (ChunkVisibility != Visibility)\n\t{\n\t\tUE::Mass::Representation::PushSwapTagsCommand(CommandBuffer, Entity, ChunkVisibility, Visibility);\n\t\tChunkData.SetContainsNewlyVisibleEntity(Visibility == EMassVisibility::CanBeSeen);\n\t}\n}\n\nvoid UMassVisualizationProcessor::Execute(FMassEntityManager& InEntityManager, FMassExecutionContext& Context)\n{\n\tSCOPE_CYCLE_COUNTER(STAT_Mass_VisProcessor_Execute);\n\n\tint32 TotalEntitiesProcessed = 0;\n\t// Update entities visualization\n\tEntityQuery.ForEachEntityChunk(InEntityManager, Context, [this, &TotalEntitiesProcessed](FMassExecutionContext& Context)\n\t{\n\t\tTotalEntitiesProcessed += Context.GetNumEntities();\n\t\tUpdateVisualization(Context);\n\t});\n\n\tUE_VLOG(this, LogMassRepresentation, Verbose, TEXT(\"UMassVisualizationProcessor::Execute processed %d entities\"), TotalEntitiesProcessed);\n}\n\n//----------------------------------------------------------------------//\n// UMassRepresentationFragmentDestructor \n//----------------------------------------------------------------------//\nUMassRepresentationFragmentDestructor::UMassRepresentationFragmentDestructor()\n\t: EntityQuery(*this)\n{\n\tObservedType = FMassRepresentationFragment::StaticStruct();\n\tOperation = EMassObservedOperation::Remove;\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n\tbRequiresGameThreadExecution = true; // due to FMassRepresentationSubsystemSharedFragment.RepresentationSubsystem use\n}\n\nvoid UMassRepresentationFragmentDestructor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassRepresentationFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassActorFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddConstSharedRequirement<FMassRepresentationParameters>();\n\tEntityQuery.AddSharedRequirement<FMassRepresentationSubsystemSharedFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddSubsystemRequirement<UMassActorSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassRepresentationFragmentDestructor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tUMassRepresentationSubsystem* RepresentationSubsystem = Context.GetMutableSharedFragment<FMassRepresentationSubsystemSharedFragment>().RepresentationSubsystem;\n\t\tcheck(RepresentationSubsystem);\n\t\tUMassActorSubsystem* ActorSubsystem = Context.GetMutableSubsystem<UMassActorSubsystem>();\n\n\t\tconst TArrayView<FMassRepresentationFragment> RepresentationList = Context.GetMutableFragmentView<FMassRepresentationFragment>();\n\t\tconst TArrayView<FMassActorFragment> ActorList = Context.GetMutableFragmentView<FMassActorFragment>();\n\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tfor (int32 i = 0; i < NumEntities; ++i)\n\t\t{\n\t\t\tFMassRepresentationFragment& Representation = RepresentationList[i];\n\t\t\tFMassActorFragment& ActorInfo = ActorList[i];\n\n\t\t\tconst FMassEntityHandle MassAgentEntityHandle = Context.GetEntity(i);\n\n\t\t\tUMassRepresentationActorManagement::ReleaseAnyActorOrCancelAnySpawning(*RepresentationSubsystem, MassAgentEntityHandle, ActorInfo, Representation, ActorSubsystem);\n\t\t}\n\t});\n}\n",
      "lines": 485
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassRepresentationSubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 19383,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassRepresentationSubsystem.h\"\n#include \"Engine/World.h\"\n#include \"MassActorSpawnerSubsystem.h\"\n#include \"MassActorSubsystem.h\"\n#include \"MassSimulationSubsystem.h\"\n#include \"MassVisualizationComponent.h\"\n#include \"MassVisualizer.h\"\n#include \"MassRepresentationTypes.h\"\n#include \"MassSimulationSettings.h\"\n#include \"MassAgentComponent.h\"\n#include \"MassAgentSubsystem.h\"\n#include \"MassEntityManager.h\"\n#include \"MassRepresentationFragments.h\"\n#include \"MassRepresentationActorManagement.h\"\n#include \"MassEntityView.h\"\n#include \"WorldPartition/WorldPartitionSubsystem.h\"\n#include \"WorldPartition/WorldPartitionRuntimeCell.h\"\n#include \"MassEntityUtils.h\"\n\n\nFStaticMeshInstanceVisualizationDescHandle UMassRepresentationSubsystem::FindOrAddStaticMeshDesc(const FStaticMeshInstanceVisualizationDesc& Desc)\n{\n\tcheck(VisualizationComponent);\n\treturn VisualizationComponent->FindOrAddVisualDesc(Desc);\n}\n\nFStaticMeshInstanceVisualizationDescHandle UMassRepresentationSubsystem::AddVisualDescWithISMComponent(const FStaticMeshInstanceVisualizationDesc& Desc, UInstancedStaticMeshComponent& ISMComponent)\n{\n\tcheck(VisualizationComponent);\n\treturn VisualizationComponent->AddVisualDescWithISMComponent(Desc, ISMComponent);\n}\n\nFStaticMeshInstanceVisualizationDescHandle UMassRepresentationSubsystem::AddVisualDescWithISMComponents(const FStaticMeshInstanceVisualizationDesc& Desc, TArrayView<TObjectPtr<UInstancedStaticMeshComponent>> ISMComponents)\n{\n\tcheck(VisualizationComponent);\n\treturn VisualizationComponent->AddVisualDescWithISMComponents(Desc, ISMComponents);\n}\n\nconst FMassISMCSharedData* UMassRepresentationSubsystem::GetISMCSharedDataForDescriptionIndex(const int32 DescriptionIndex) const\n{\n\tcheck(VisualizationComponent);\n\treturn VisualizationComponent->GetISMCSharedDataForDescriptionIndex(DescriptionIndex);\n}\n\nconst FMassISMCSharedData* UMassRepresentationSubsystem::GetISMCSharedDataForInstancedStaticMesh(const UInstancedStaticMeshComponent* ISMC) const\n{\n\tcheck(VisualizationComponent);\n\treturn VisualizationComponent->GetISMCSharedDataForInstancedStaticMesh(ISMC);\n}\n\nvoid UMassRepresentationSubsystem::RemoveISMComponent(UInstancedStaticMeshComponent& ISMComponent)\n{\nPRAGMA_DISABLE_DEPRECATION_WARNINGS\n\tcheck(VisualizationComponent);\n\treturn VisualizationComponent->RemoveISMComponent(ISMComponent);\nPRAGMA_ENABLE_DEPRECATION_WARNINGS\n}\n\nvoid UMassRepresentationSubsystem::RemoveVisualDesc(const FStaticMeshInstanceVisualizationDescHandle VisualizationHandle)\n{\n\tcheck(VisualizationComponent);\n\treturn VisualizationComponent->RemoveVisualDesc(VisualizationHandle);\n}\n\nFMassInstancedStaticMeshInfoArrayView UMassRepresentationSubsystem::GetMutableInstancedStaticMeshInfos()\n{\n\tcheck(VisualizationComponent);\n\tFMassInstancedStaticMeshInfoArrayView View = VisualizationComponent->GetMutableVisualInfos();\n\treturn MoveTemp(View);\n}\n\nvoid UMassRepresentationSubsystem::DirtyStaticMeshInstances()\n{\n\tcheck(VisualizationComponent);\n\treturn VisualizationComponent->DirtyVisuals();\n}\n\nint16 UMassRepresentationSubsystem::FindOrAddTemplateActor(const TSubclassOf<AActor>& ActorClass)\n{\n\tUE_MT_SCOPED_WRITE_ACCESS(TemplateActorsMTAccessDetector);\n\n\tint32 VisualIndex = TemplateActors.IndexOfByPredicate(FTemplateActorEqualsPredicate{ActorClass});\n\n\tif (VisualIndex == INDEX_NONE)\n\t{\n\t\tVisualIndex = TemplateActors.Add({ActorClass, 1u});\n\t}\n\telse\n\t{\n\t\t++TemplateActors[VisualIndex].RefCount;\n\t}\n\n\tcheck(VisualIndex < INT16_MAX);\n\treturn (int16)VisualIndex;\n}\n\nAActor* UMassRepresentationSubsystem::GetOrSpawnActorFromTemplate(const FMassEntityHandle MassAgent, const FTransform& Transform\n\t, const int16 TemplateActorIndex, FMassActorSpawnRequestHandle& InOutSpawnRequestHandle, float Priority\n\t, FMassActorPreSpawnDelegate ActorPreSpawnDelegate, FMassActorPostSpawnDelegate ActorPostSpawnDelegate)\n{\n\tUE_MT_SCOPED_READ_ACCESS(TemplateActorsMTAccessDetector);\n\tif (!TemplateActors.IsValidIndex(TemplateActorIndex))\n\t{\n\t\tUE_LOG(LogMassRepresentation, Error, TEXT(\"Template actor type %i is not referring to a valid type\"), TemplateActorIndex);\n\t\treturn nullptr;\n\t}\n\n\t//@todo: this would be a good place to do pooling of actors instead of spawning them every time\n\tcheck(ActorSpawnerSubsystem);\n\tconst TSubclassOf<AActor> TemplateToSpawn = TemplateActors[TemplateActorIndex].Actor;\n\n\tif (InOutSpawnRequestHandle.IsValid())\n\t{\n\t\tFMassActorSpawnRequest& SpawnRequest = ActorSpawnerSubsystem->GetMutableSpawnRequest<FMassActorSpawnRequest>(InOutSpawnRequestHandle);\n\t\t// Check if this existing spawn request is matching the template actor\n\t\tif (SpawnRequest.Template != TemplateToSpawn)\n\t\t{\n\t\t\treturn nullptr;\n\t\t}\n\t\tswitch (SpawnRequest.SpawnStatus)\n\t\t{\n\t\t\tcase ESpawnRequestStatus::RetryPending:\n\t\t\tcase ESpawnRequestStatus::Pending:\n\t\t\t\t// Update spawn request with latest information\n\t\t\t\tSpawnRequest.Transform = Transform;\n\t\t\t\tSpawnRequest.Priority = Priority;\n\t\t\t\treturn nullptr;\n\t\t\tcase ESpawnRequestStatus::Failed:\n\t\t\t{\n\t\t\t\tcheck(!SpawnRequest.SpawnedActor);\n\t\t\t\t// The most common case for failure is that collision was preventing the spawning, the agent might have moved or the thing preventing it from spawning might have moved too.\n\t\t\t\tUWorld* World = GetWorld();\n\t\t\t\tcheck(World);\n\n\t\t\t\t// Limits the retry as they are bad for rendering performance\n\t\t\t\tif ((World->GetTimeSeconds() - SpawnRequest.RequestedTime) > RetryTimeInterval ||\n\t\t\t\t\t(SpawnRequest.Transform.GetLocation() - Transform.GetLocation()).SizeSquared() > RetryMovedDistanceSq)\n\t\t\t\t{\n\t\t\t\t\t// Update spawn request with latest information and retry\n\t\t\t\t\tSpawnRequest.Transform = Transform;\n\t\t\t\t\tSpawnRequest.Priority = Priority;\n\t\t\t\t\tActorSpawnerSubsystem->RetryActorSpawnRequest(InOutSpawnRequestHandle);\n\t\t\t\t}\n\t\t\t\treturn nullptr;\n\t\t\t}\n\t\t\tcase ESpawnRequestStatus::Succeeded:\n\t\t\t{\n\t\t\t\tAActor* SpawnedActor = SpawnRequest.SpawnedActor;\n\t\t\t\tcheck(SpawnedActor);\n\t\t\t\tensureMsgf(ActorSpawnerSubsystem->RemoveActorSpawnRequest(InOutSpawnRequestHandle), TEXT(\"Unable to remove a valid spawn request\"));\n\t\t\t\treturn SpawnedActor;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tcheckf(false, TEXT(\"Unexpected spawn request status!\"));\n\t\t\t\tInOutSpawnRequestHandle.Invalidate();\n\t\t\t\treturn nullptr;\n\t\t}\n\t}\n\n\t// If we reach here, means we need to create a spawn request\n\tFMassActorSpawnRequest SpawnRequest;\n\tSpawnRequest.MassAgent = MassAgent;\n\tif (FMassGuidFragment* GuidFragment = EntityManager->GetFragmentDataPtr<FMassGuidFragment>(MassAgent))\n\t{\n\t\tSpawnRequest.Guid = GuidFragment->Guid;\n\t}\n\tSpawnRequest.Template = TemplateToSpawn;\n\tSpawnRequest.Transform = Transform;\n\tSpawnRequest.Priority = Priority;\n\tSpawnRequest.ActorPreSpawnDelegate = ActorPreSpawnDelegate;\n\tSpawnRequest.ActorPostSpawnDelegate = ActorPostSpawnDelegate;\n\tInOutSpawnRequestHandle = ActorSpawnerSubsystem->RequestActorSpawn(SpawnRequest);\n\n\t++(HandledMassAgents.FindOrAdd(MassAgent));\n\n\treturn nullptr;\n}\n\nTSubclassOf<AActor> UMassRepresentationSubsystem::GetTemplateActorClass(const int16 TemplateActorIndex)\n{\n\tUE_MT_SCOPED_READ_ACCESS(TemplateActorsMTAccessDetector);\n\tif (!TemplateActors.IsValidIndex(TemplateActorIndex))\n\t{\n\t\tUE_LOG(LogMassRepresentation, Error, TEXT(\"Template actor type %i is not referring to a valid type\"), TemplateActorIndex);\n\t\treturn nullptr;\n\t}\n\n\treturn TemplateActors[TemplateActorIndex].Actor;\n}\n\nbool UMassRepresentationSubsystem::IsCollisionLoaded(const FName TargetGrid, const FTransform& Transform) const\n{\n\tif (!WorldPartitionSubsystem)\n\t{\n\t\t// Assuming that all collisions are loaded if not using WorldPartition.\n\t\treturn true;\n\t}\n\n\t// @todo optimize by doing one query per cell\n\t// Build a query source\n\tTArray<FWorldPartitionStreamingQuerySource> QuerySources;\n\tFWorldPartitionStreamingQuerySource& QuerySource = QuerySources.Emplace_GetRef();\n\tQuerySource.bSpatialQuery = true;\n\tQuerySource.Location = Transform.GetLocation();\n\tQuerySource.Rotation = Transform.Rotator();\n\tif (!TargetGrid.IsNone())\n\t{\n\t\tQuerySource.TargetGrids.Add(TargetGrid);\n\t}\n\tQuerySource.bUseGridLoadingRange = false;\n\tQuerySource.Radius = 1.f; // 1cm should be enough to know if grid is loaded at specific area\n\tQuerySource.bDataLayersOnly = false;\n\n\t// Execute query\n\treturn WorldPartitionSubsystem->IsStreamingCompleted(EWorldPartitionRuntimeCellState::Activated, QuerySources, /*bExactState*/ false);\n}\n\nvoid UMassRepresentationSubsystem::ReleaseTemplate(const TSubclassOf<AActor>& ActorClass)\n{\n\tif (ActorClass)\n\t{\n\t\tUE_MT_SCOPED_WRITE_ACCESS(TemplateActorsMTAccessDetector);\n\t\t\n\t\tconst int32 TemplateActorIndex = TemplateActors.IndexOfByPredicate(FTemplateActorEqualsPredicate{ActorClass});\n\t\tcheck(TemplateActors.IsValidIndex(TemplateActorIndex));\n\n\t\tFTemplateActorData& TemplateActorData = TemplateActors[TemplateActorIndex];\n\t\tcheck(TemplateActorData.RefCount > 0u);\n\t\t--TemplateActorData.RefCount;\n\n\t\tif (TemplateActorData.RefCount == 0u)\n\t\t{\n\t\t\tTemplateActors.RemoveAt(TemplateActorIndex);\n\t\t}\n\t}\n}\n\nvoid UMassRepresentationSubsystem::ReleaseAllResources()\n{\n\tensureMsgf(HandledMassAgents.Num() == 0, TEXT(\"All entities must be released before releasing resources\"));\n\n\t{\n\t\t// Release all template actors\n\t\tUE_MT_SCOPED_WRITE_ACCESS(TemplateActorsMTAccessDetector);\n\t\tTemplateActors.Reset();\n\t}\n\n\t// Release all static meshes resources\n\tVisualizationComponent->ClearAllVisualInstances();\n}\n\nbool UMassRepresentationSubsystem::ReleaseTemplateActorOrCancelSpawning(const FMassEntityHandle MassAgent, const int16 TemplateActorIndex, AActor* ActorToRelease, FMassActorSpawnRequestHandle& SpawnRequestHandle)\n{\n\t// First try to cancel the spawning request, then try to release the actor\n\tif( CancelSpawningInternal(TemplateActorIndex, SpawnRequestHandle) ||\n\t\tReleaseTemplateActorInternal(TemplateActorIndex, ActorToRelease, false))\n\t{ \n\t\tconst int32 RefCount = --(HandledMassAgents.FindChecked(MassAgent));\n\t\tcheckf(RefCount >= 0, TEXT(\"RefCount are expected to be greater than or equal to 0\"));\n\t\tif (RefCount == 0)\n\t\t{\n\t\t\tHandledMassAgents.Remove(MassAgent);\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool UMassRepresentationSubsystem::ReleaseTemplateActor(const FMassEntityHandle MassAgent, const int16 TemplateActorIndex, AActor* ActorToRelease, bool bImmediate)\n{\n\tif (ReleaseTemplateActorInternal(TemplateActorIndex, ActorToRelease, bImmediate))\n\t{\n\t\tconst int32 RefCount = --HandledMassAgents.FindChecked(MassAgent);\n\t\tcheckf(RefCount >= 0, TEXT(\"RefCount are expected to be greater than or equal to 0\"));\n\t\tif (RefCount == 0)\n\t\t{\n\t\t\tHandledMassAgents.Remove(MassAgent);\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool UMassRepresentationSubsystem::CancelSpawning(const FMassEntityHandle MassAgent, const int16 TemplateActorIndex, FMassActorSpawnRequestHandle& SpawnRequestHandle)\n{\n\tif (CancelSpawningInternal(TemplateActorIndex, SpawnRequestHandle))\n\t{\n\t\tconst int32 RefCount = --HandledMassAgents.FindChecked(MassAgent);\n\t\tcheckf(RefCount >= 0, TEXT(\"RefCount are expected to be greater than or equal to 0\"));\n\t\tif (RefCount == 0)\n\t\t{\n\t\t\tHandledMassAgents.Remove(MassAgent);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool UMassRepresentationSubsystem::ReleaseTemplateActorInternal(const int16 TemplateActorIndex, AActor* ActorToRelease, bool bImmediate)\n{\n\tUE_MT_SCOPED_READ_ACCESS(TemplateActorsMTAccessDetector);\n\tif (!TemplateActors.IsValidIndex(TemplateActorIndex))\n\t{\n\t\tUE_LOG(LogMassRepresentation, Error, TEXT(\"Template actor type %i is not referring a valid type\"), TemplateActorIndex);\n\t\treturn false;\n\t}\n\tconst TSubclassOf<AActor> TemplateToRelease = TemplateActors[TemplateActorIndex].Actor;\n\n\t// We can only release existing and matching template actors\n\tif (!ActorToRelease || ActorToRelease->GetClass() != TemplateToRelease)\n\t{\n\t\treturn false;\n\t}\n\tActorSpawnerSubsystem->DestroyActor(ActorToRelease, bImmediate);\n\treturn true;\n}\n\nbool UMassRepresentationSubsystem::CancelSpawningInternal(const int16 TemplateActorIndex, FMassActorSpawnRequestHandle& SpawnRequestHandle)\n{\n\tUE_MT_SCOPED_READ_ACCESS(TemplateActorsMTAccessDetector);\n\tif (!TemplateActors.IsValidIndex(TemplateActorIndex))\n\t{\n\t\tUE_LOG(LogMassRepresentation, Error, TEXT(\"Template actor type %i is not referring a valid type\"), TemplateActorIndex);\n\t\treturn false;\n\t}\n\tconst TSubclassOf<AActor> TemplateToRelease = TemplateActors[TemplateActorIndex].Actor;\n\n\tcheck(ActorSpawnerSubsystem);\n\t// Check if there is something to cancel\n\tif (!SpawnRequestHandle.IsValid())\n\t{\n\t\treturn false;\n\t}\n\n\tconst FMassActorSpawnRequest& SpawnRequest = ActorSpawnerSubsystem->GetMutableSpawnRequest<FMassActorSpawnRequest>(SpawnRequestHandle);\n\t// Check if the spawning request matches the template actor\n\tif (SpawnRequest.Template != TemplateToRelease)\n\t{\n\t\treturn false;\n\t}\n\n\tif (SpawnRequest.SpawnStatus == ESpawnRequestStatus::Succeeded)\n\t{\n\t\tcheck(SpawnRequest.SpawnedActor);\n\t\tReleaseTemplateActorInternal(TemplateActorIndex, SpawnRequest.SpawnedActor, false);\n\t}\n\n\t// Remove the spawn request\n\tensureMsgf(ActorSpawnerSubsystem->RemoveActorSpawnRequest(SpawnRequestHandle), TEXT(\"Unable to remove a valid spawn request\"));\n\n\treturn true;\n}\n\nbool UMassRepresentationSubsystem::DoesActorMatchTemplate(const AActor& Actor, const int16 TemplateActorIndex) const\n{\n\tUE_MT_SCOPED_READ_ACCESS(TemplateActorsMTAccessDetector);\n\tif (!TemplateActors.IsValidIndex(TemplateActorIndex))\n\t{\n\t\tUE_LOG(LogMassRepresentation, Error, TEXT(\"Template actor type %i is not referring to a valid type\"), TemplateActorIndex);\n\t\treturn false;\n\t}\n\n\tconst TSubclassOf<AActor> Template = TemplateActors[TemplateActorIndex].Actor;\n\treturn Actor.GetClass() == Template;\n}\n\nvoid UMassRepresentationSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tCollection.InitializeDependency(UMassSimulationSubsystem::StaticClass());\n\tCollection.InitializeDependency(UMassActorSpawnerSubsystem::StaticClass());\n\tCollection.InitializeDependency(UMassAgentSubsystem::StaticClass());\n\tSuper::Initialize(Collection);\n\n\tif (UWorld* World = GetWorld())\n\t{\n\t\tEntityManager = UE::Mass::Utils::GetEntityManagerChecked(*World).AsShared();\n\n\t\tActorSpawnerSubsystem = World->GetSubsystem<UMassActorSpawnerSubsystem>();\n\t\tWorldPartitionSubsystem = World->GetSubsystem<UWorldPartitionSubsystem>();\n\n\t\tif (Visualizer == nullptr)\n\t\t{\n\t\t\tFActorSpawnParameters SpawnInfo;\n\t\t\tSpawnInfo.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;\n\t\t\t// The helper actor is only once per world so we can allow it to spawn during construction script.\n\t\t\tSpawnInfo.bAllowDuringConstructionScript = true;\n\t\t\tVisualizer = World->SpawnActor<AMassVisualizer>(SpawnInfo);\n\t\t\tcheck(Visualizer);\n\t\t\tVisualizationComponent = &Visualizer->GetVisualizationComponent();\n\n#if WITH_EDITOR\n\t\t\tVisualizer->SetActorLabel(FString::Printf(TEXT(\"%sVisualizer\"), *GetClass()->GetName()), /*bMarkDirty*/false);\n#endif\n\t\t}\n\n\t\tUMassSimulationSubsystem* SimSystem = World->GetSubsystem<UMassSimulationSubsystem>();\n\t\tcheck(SimSystem);\n\t\tSimSystem->GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).AddUObject(this, &UMassRepresentationSubsystem::OnProcessingPhaseStarted, EMassProcessingPhase::PrePhysics);\n\t\tSimSystem->GetOnProcessingPhaseFinished(EMassProcessingPhase::PostPhysics).AddUObject(this, &UMassRepresentationSubsystem::OnProcessingPhaseStarted, EMassProcessingPhase::PostPhysics);\n\n\t\tUMassAgentSubsystem* AgentSystem = World->GetSubsystem<UMassAgentSubsystem>();\n\t\tcheck(AgentSystem);\n\t\tAgentSystem->GetOnMassAgentComponentEntityAssociated().AddUObject(this, &UMassRepresentationSubsystem::OnMassAgentComponentEntityAssociated);\n\t\tAgentSystem->GetOnMassAgentComponentEntityDetaching().AddUObject(this, &UMassRepresentationSubsystem::OnMassAgentComponentEntityDetaching);\n\t}\n\n\tRetryMovedDistanceSq = FMath::Square(GET_MASSSIMULATION_CONFIG_VALUE(DesiredActorFailedSpawningRetryMoveDistance));\n\tRetryTimeInterval = GET_MASSSIMULATION_CONFIG_VALUE(DesiredActorFailedSpawningRetryTimeInterval);\n}\n\nvoid UMassRepresentationSubsystem::Deinitialize()\n{\n\tif (const UWorld* World = GetWorld())\n\t{\n\t\tif (UMassSimulationSubsystem* SimSystem = World->GetSubsystem<UMassSimulationSubsystem>())\n\t\t{\n\t\t\tSimSystem->GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).RemoveAll(this);\n\t\t\tSimSystem->GetOnProcessingPhaseFinished(EMassProcessingPhase::PostPhysics).RemoveAll(this);\n\t\t}\n\n\t\tif (UMassAgentSubsystem* AgentSystem = World->GetSubsystem<UMassAgentSubsystem>())\n\t\t{\n\t\t\tAgentSystem->GetOnMassAgentComponentEntityAssociated().RemoveAll(this);\n\t\t\tAgentSystem->GetOnMassAgentComponentEntityDetaching().RemoveAll(this);\n\t\t}\n\t}\n\tEntityManager.Reset();\n\n\tSuper::Deinitialize();\n}\n\nvoid UMassRepresentationSubsystem::OnProcessingPhaseStarted(const float DeltaSeconds, const EMassProcessingPhase Phase) const\n{\n\tcheck(VisualizationComponent);\n\tswitch (Phase)\n\t{\n\t\tcase EMassProcessingPhase::PrePhysics:\n\t\t\tVisualizationComponent->BeginVisualChanges();\n\t\t\tbreak;\n\t\tcase EMassProcessingPhase::PostPhysics:/* Currently this is the end of phases signal */\n\t\t\tVisualizationComponent->EndVisualChanges();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcheck(false); // Need to handle this case\n\t\t\tbreak;\n\t}\n}\n\nvoid UMassRepresentationSubsystem::OnMassAgentComponentEntityAssociated(const UMassAgentComponent& AgentComponent)\n{\n\tcheck(EntityManager);\n\n\tconst FMassEntityHandle MassAgent = AgentComponent.GetEntityHandle();\n\tcheckf(EntityManager->IsEntityValid(MassAgent), TEXT(\"Expecting a valid mass entity\"));\n\tif (EntityManager->IsEntityValid(MassAgent) && AgentComponent.IsNetSimulating())\n\t{\n\t\t// Check if this mass agent already handled by this sub system, if yes than release any local spawned actor or cancel any spawn requests\n\t\tif (HandledMassAgents.Find(MassAgent))\n\t\t{\n\t\t\tUMassRepresentationActorManagement::ReleaseAnyActorOrCancelAnySpawning(*EntityManager.Get(), MassAgent);\n\t\t}\n\t}\n}\n\nvoid UMassRepresentationSubsystem::OnMassAgentComponentEntityDetaching(const UMassAgentComponent& AgentComponent)\n{\n\tcheck(EntityManager);\n\n\tAActor* ComponentOwner = AgentComponent.GetOwner();\n\tcheck(ComponentOwner);\n\n\tconst FMassEntityHandle MassAgent = AgentComponent.GetEntityHandle();\n\tcheckf(EntityManager->IsEntityValid(MassAgent), TEXT(\"Expecting a valid mass entity\"));\n\tif (EntityManager->IsEntityValid(MassAgent) && AgentComponent.IsNetSimulating())\n\t{\n\t\tconst FMassEntityView EntityView(*EntityManager.Get(), MassAgent);\n\t\tif (FMassRepresentationFragment* Representation = EntityView.GetFragmentDataPtr<FMassRepresentationFragment>())\n\t\t{\n\t\t\t// Force a reevaluate of the current representation\n\t\t\tRepresentation->CurrentRepresentation = EMassRepresentationType::None;\n\t\t}\n\t}\n}\n\nvoid UMassRepresentationSubsystem::AddReferencedObjects(UObject* InThis, FReferenceCollector& Collector)\n{\n\tSuper::AddReferencedObjects(InThis, Collector);\n\n\tUMassRepresentationSubsystem& TypedThis = *CastChecked<UMassRepresentationSubsystem>(InThis);\n\tfor (FTemplateActorData& TemplateActorData : TypedThis.TemplateActors)\n\t{\n\t\tCollector.AddStableReference(&TemplateActorData.Actor.GetGCPtr());\n\t}\n}\n",
      "lines": 498
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassRepresentationTypes.cpp",
      "extension": ".cpp",
      "size_bytes": 4666,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassRepresentationTypes.h\"\n#include \"MassRepresentationUtils.h\"\n#include \"MassCommandBuffer.h\"\n#include \"Components/InstancedStaticMeshComponent.h\"\n\nDEFINE_LOG_CATEGORY(LogMassRepresentation);\n\nnamespace UE::Mass::Representation\n{\nvoid PushSwapTagsCommand(FMassCommandBuffer& CommandBuffer, const FMassEntityHandle Entity, const EMassVisibility PrevVisibility, const EMassVisibility NewVisibility)\n{\n#define CASE_SWAP_TAGS(OldVisibility, NewVisibility) \\\n\tcase NewVisibility: \\\n\t\tCommandBuffer.SwapTags<TMassVisibilityTagForLevel<OldVisibility>::FTag, TMassVisibilityTagForLevel<NewVisibility>::FTag>(Entity); \\\n\t\tbreak\n\n#define CASE_ADD_TAG(NewVisibility) \\\ncase NewVisibility: \\\n\tCommandBuffer.AddTag<TMassVisibilityTagForLevel<NewVisibility>::FTag>(Entity); \\\n\tbreak\n\n#define DEFAULT_REMOVE_TAG(OldVisibility) \\\ncase EMassVisibility::Max: /* fall through on purpose */ \\\ndefault: \\\n\tCommandBuffer.RemoveTag<TMassVisibilityTagForLevel<OldVisibility>::FTag>(Entity); \\\n\tbreak\n\n\tcheck(PrevVisibility != NewVisibility);\n\n\tswitch (PrevVisibility)\n\t{\n\tcase EMassVisibility::CanBeSeen:\n\t\tswitch (NewVisibility)\n\t\t{\n\t\tCASE_SWAP_TAGS(EMassVisibility::CanBeSeen, EMassVisibility::CulledByFrustum);\n\t\tCASE_SWAP_TAGS(EMassVisibility::CanBeSeen, EMassVisibility::CulledByDistance);\n\t\tDEFAULT_REMOVE_TAG(EMassVisibility::CanBeSeen);\n\t\t}\n\t\tbreak;\n\tcase EMassVisibility::CulledByFrustum:\n\t\tswitch (NewVisibility)\n\t\t{\n\t\tCASE_SWAP_TAGS(EMassVisibility::CulledByFrustum, EMassVisibility::CanBeSeen);\n\t\tCASE_SWAP_TAGS(EMassVisibility::CulledByFrustum, EMassVisibility::CulledByDistance);\n\t\tDEFAULT_REMOVE_TAG(EMassVisibility::CulledByFrustum);\n\t\t}\n\t\tbreak;\n\tcase EMassVisibility::CulledByDistance:\n\t\tswitch (NewVisibility)\n\t\t{\n\t\tCASE_SWAP_TAGS(EMassVisibility::CulledByDistance, EMassVisibility::CanBeSeen);\n\t\tCASE_SWAP_TAGS(EMassVisibility::CulledByDistance, EMassVisibility::CulledByFrustum);\n\t\tDEFAULT_REMOVE_TAG(EMassVisibility::CulledByDistance);\n\t\t}\n\t\tbreak;\n\tcase EMassVisibility::Max:\n\t\tswitch (NewVisibility)\n\t\t{\n\t\tCASE_ADD_TAG(EMassVisibility::CanBeSeen);\n\t\tCASE_ADD_TAG(EMassVisibility::CulledByFrustum);\n\t\tCASE_ADD_TAG(EMassVisibility::CulledByDistance);\n\t\tdefault:\n\t\t\tcheckf(false, TEXT(\"Unsupported Visibility types!\"));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tcheckf(false, TEXT(\"Unsupported Visibility type!\"));\n\t\tbreak;\n\t}\n\n#undef CASE_SWAP_TAGS\n}\n} // UE::Mass::Representation\n\n//-----------------------------------------------------------------------------\n// FMassInstancedStaticMeshInfo\n//-----------------------------------------------------------------------------\nvoid FMassInstancedStaticMeshInfo::ClearVisualInstance(UInstancedStaticMeshComponent& ISMComponent)\n{\n\tif (InstancedStaticMeshComponents.RemoveSingleSwap(&ISMComponent, EAllowShrinking::No))\n\t{\n\t\tISMComponent.ClearInstances();\n\t\tISMComponent.DestroyComponent();\n\t}\n\telse\n\t{\n\t\tInstancedStaticMeshComponents.Reset();\n\t\tLODSignificanceRanges.Reset();\n\t}\n}\n\nvoid FMassInstancedStaticMeshInfo::Reset()\n{\n\tDesc.Reset();\n\tInstancedStaticMeshComponents.Reset();\n\tLODSignificanceRanges.Reset();\n}\n\n//-----------------------------------------------------------------------------\n// FMassStaticMeshInstanceVisualizationMeshDesc\n//-----------------------------------------------------------------------------\nFMassStaticMeshInstanceVisualizationMeshDesc::FMassStaticMeshInstanceVisualizationMeshDesc()\n{\n\tISMComponentClass = UInstancedStaticMeshComponent::StaticClass();\n}\n\n//-----------------------------------------------------------------------------\n// FStaticMeshInstanceVisualizationDesc\n//-----------------------------------------------------------------------------\nbool FStaticMeshInstanceVisualizationDesc::IsValid() const\n{\n\tfor (const FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : Meshes)\n\t{\n\t\tif (MeshDesc.Mesh && MeshDesc.ISMComponentClass)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//-----------------------------------------------------------------------------\n// FMassISMCSharedDataMap - DEPRECATED\n//-----------------------------------------------------------------------------\nFMassISMCSharedData& FMassISMCSharedDataMap::GetAndMarkDirtyChecked(const uint32 Hash)\n{\n\tstatic FMassISMCSharedData Dummy;\n\treturn Dummy;\n}\n\nFMassISMCSharedData* FMassISMCSharedDataMap::GetAndMarkDirty(const uint32 Hash)\n{\n\treturn nullptr;\n}\n\nFMassISMCSharedData* FMassISMCSharedDataMap::Find(const uint32 Hash)\n{\n\treturn nullptr;\n}\n\nvoid FMassISMCSharedDataMap::Remove(const uint32 Hash)\n{\n}\n",
      "lines": 146
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassStationaryDistanceVisualizationTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 1734,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassStationaryDistanceVisualizationTrait.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"VisualLogger/VisualLogger.h\"\n\n\nUMassStationaryDistanceVisualizationTrait::UMassStationaryDistanceVisualizationTrait(const FObjectInitializer& ObjectInitializer)\n{\n\tbAllowServerSideVisualization = true;\n}\n\nvoid UMassStationaryDistanceVisualizationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tbool bIssuesFound = false;\n\tfor (FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : StaticMeshInstanceDesc.Meshes)\n\t{\n\t\tbIssuesFound = bIssuesFound || (MeshDesc.Mobility != EComponentMobility::Stationary);\n\t\tMeshDesc.Mobility = EComponentMobility::Stationary;\n\t}\n\tUE_CVLOG_UELOG(bIssuesFound, this, LogMass, Log, TEXT(\"%s some Meshes' mobility has been set to non-Stationary. Theese settings will be overridden. \"), *GetPathName());\n\n\tSuper::BuildTemplate(BuildContext, World);\n\n\tBuildContext.AddTag<FMassStaticRepresentationTag>();\n}\n\n#if WITH_EDITOR\nvoid UMassStationaryDistanceVisualizationTrait::PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent)\n{\n\tstatic const FName StaticMeshInstanceDescName = GET_MEMBER_NAME_CHECKED(UMassStationaryDistanceVisualizationTrait, StaticMeshInstanceDesc);\n\n\tSuper::PostEditChangeProperty(PropertyChangedEvent);\n\n\tif (PropertyChangedEvent.MemberProperty && PropertyChangedEvent.MemberProperty->GetFName() == StaticMeshInstanceDescName)\n\t{\n\t\tfor (FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : StaticMeshInstanceDesc.Meshes)\n\t\t{\n\t\t\tMeshDesc.Mobility = EComponentMobility::Stationary;\n\t\t}\n\t}\n}\n#endif // WITH_EDITOR\n",
      "lines": 43
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassStationaryISMRepresentationFragmentDestructor.cpp",
      "extension": ".cpp",
      "size_bytes": 2768,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassStationaryISMRepresentationFragmentDestructor.h\"\n#include \"MassRepresentationSubsystem.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassRepresentationProcessor.h\"\n\n//-----------------------------------------------------------------------------\n// UMassStationaryISMRepresentationFragmentDestructor\n//-----------------------------------------------------------------------------\nUMassStationaryISMRepresentationFragmentDestructor::UMassStationaryISMRepresentationFragmentDestructor()\n\t: EntityQuery(*this)\n{\n\tObservedType = FMassRepresentationFragment::StaticStruct();\n\tOperation = EMassObservedOperation::Remove;\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllWorldModes;\n\tbRequiresGameThreadExecution = true; // not sure about this\n}\n\nvoid UMassStationaryISMRepresentationFragmentDestructor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassRepresentationFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddConstSharedRequirement<FMassRepresentationParameters>();\n\tEntityQuery.AddSharedRequirement<FMassRepresentationSubsystemSharedFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddTagRequirement<FMassStaticRepresentationTag>(EMassFragmentPresence::All);\n}\n\nvoid UMassStationaryISMRepresentationFragmentDestructor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tUMassRepresentationSubsystem* RepresentationSubsystem = Context.GetMutableSharedFragment<FMassRepresentationSubsystemSharedFragment>().RepresentationSubsystem;\n\t\tcheck(RepresentationSubsystem);\n\t\tFMassInstancedStaticMeshInfoArrayView ISMInfosView = RepresentationSubsystem->GetMutableInstancedStaticMeshInfos();\n\n\t\tconst TArrayView<FMassRepresentationFragment> RepresentationList = Context.GetMutableFragmentView<FMassRepresentationFragment>();\n\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tfor (int32 EntityIdx = 0; EntityIdx < NumEntities; ++EntityIdx)\n\t\t{\n\t\t\tFMassRepresentationFragment& Representation = RepresentationList[EntityIdx];\n\t\t\tif (Representation.CurrentRepresentation == EMassRepresentationType::StaticMeshInstance)\n\t\t\t{\n\t\t\t\tFMassInstancedStaticMeshInfo& ISMInfo = ISMInfosView[Representation.StaticMeshDescHandle.ToIndex()];\n\t\t\t\tif (FMassLODSignificanceRange* OldRange = ISMInfo.GetLODSignificanceRange(Representation.PrevLODSignificance))\n\t\t\t\t{\n\t\t\t\t\tconst FMassEntityHandle EntityHandle = Context.GetEntity(EntityIdx);\n\t\t\t\t\tif (OldRange)\n\t\t\t\t\t{\n\t\t\t\t\t\tOldRange->RemoveInstance(EntityHandle);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRepresentation.CurrentRepresentation = EMassRepresentationType::None;\n\t\t\t}\n\t\t}\n\t});\n}\n",
      "lines": 57
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassStationaryISMSwitcherProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 7156,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassStationaryISMSwitcherProcessor.h\"\n#include \"MassRepresentationSubsystem.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassRepresentationProcessor.h\"\n\n#include \"MassSignalSubsystem.h\"\n\n\nUMassStationaryISMSwitcherProcessor::UMassStationaryISMSwitcherProcessor(const FObjectInitializer& ObjectInitializer)\n\t: EntityQuery(*this)\n{\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Representation;\n\tExecutionOrder.ExecuteAfter.Add(UMassVisualizationProcessor::StaticClass()->GetFName());\n\tbAutoRegisterWithProcessingPhases = true;\n\tExecutionFlags = static_cast<int32>(EProcessorExecutionFlags::AllNetModes);\n}\n\nvoid UMassStationaryISMSwitcherProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassRepresentationLODFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassRepresentationFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddConstSharedRequirement<FMassRepresentationParameters>();\n\tEntityQuery.AddSharedRequirement<FMassRepresentationSubsystemSharedFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddTagRequirement<FMassStaticRepresentationTag>(EMassFragmentPresence::All);\n\tEntityQuery.AddTagRequirement<FMassStationaryISMSwitcherProcessorTag>(EMassFragmentPresence::All);\n\tEntityQuery.AddSubsystemRequirement<UMassSignalSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassStationaryISMSwitcherProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, &UMassStationaryISMSwitcherProcessor::ProcessContext);\n}\n\t\nvoid UMassStationaryISMSwitcherProcessor::ProcessContext(FMassExecutionContext& Context)\n{\n\tUMassSignalSubsystem& SignalSubsystem = Context.GetMutableSubsystemChecked<UMassSignalSubsystem>();\n\n\tUMassRepresentationSubsystem* RepresentationSubsystem = Context.GetMutableSharedFragment<FMassRepresentationSubsystemSharedFragment>().RepresentationSubsystem;\n\tcheck(RepresentationSubsystem);\n\tFMassInstancedStaticMeshInfoArrayView ISMInfosView = RepresentationSubsystem->GetMutableInstancedStaticMeshInfos();\n\n\tconst TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();\n\tconst TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();\n\tconst TArrayView<FMassRepresentationFragment> RepresentationList = Context.GetMutableFragmentView<FMassRepresentationFragment>();\n\n\tconst FMassRepresentationParameters& RepresentationParams = Context.GetConstSharedFragment<FMassRepresentationParameters>();\n\tconst bool bDoKeepActorExtraFrame = UE::Mass::Representation::bAllowKeepActorExtraFrame ? RepresentationParams.bKeepLowResActors : false;\n\n\tconst int32 NumEntities = Context.GetNumEntities();\n\tfor (int32 EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t{\n\t\tconst FMassEntityHandle EntityHandle = Context.GetEntity(EntityIdx);\n\t\tconst FMassRepresentationLODFragment& RepresentationLOD = RepresentationLODList[EntityIdx];\n\t\tconst FTransformFragment& TransformFragment = TransformList[EntityIdx];\n\t\tFMassRepresentationFragment& Representation = RepresentationList[EntityIdx];\n\n\t\tif (Representation.PrevRepresentation != EMassRepresentationType::StaticMeshInstance\n\t\t\t&& Representation.CurrentRepresentation != EMassRepresentationType::StaticMeshInstance)\n\t\t{\n\t\t\t// nothing to do here\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ensureMsgf(Representation.StaticMeshDescHandle.IsValid() && ISMInfosView.IsValidIndex(Representation.StaticMeshDescHandle.ToIndex())\n\t\t\t\t\t\t, TEXT(\"Invalid handle index %u for ISMInfosView\"), Representation.StaticMeshDescHandle.ToIndex()))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tFMassInstancedStaticMeshInfo& ISMInfo = ISMInfosView[Representation.StaticMeshDescHandle.ToIndex()];\n\t\tif (const bool bSwitchedAwayFromStaticMesh = (Representation.PrevRepresentation == EMassRepresentationType::StaticMeshInstance\n\t\t\t&& Representation.CurrentRepresentation != EMassRepresentationType::StaticMeshInstance))\n\t\t{\n\t\t\t// note that we're using the PrevLODSignificance here, and the reason for it is that the Prev value matches the \n\t\t\t// PrevRepresentation - thus we need to remove from the \"previously\" used LODSignificance range.\n\t\t\tISMInfo.RemoveInstance(EntityHandle, Representation.PrevLODSignificance);\n\n\t\t\t// consume \"prev\" data\n\t\t\tRepresentation.PrevRepresentation = Representation.CurrentRepresentation;\n\n\t\t\tif (Representation.PrevRepresentation != EMassRepresentationType::None)\n\t\t\t{\n\t\t\t\tSignalSubsystem.SignalEntity(UE::Mass::Signals::SwitchedToActor, EntityHandle);\n\t\t\t}\n\t\t}\n\t\telse if (const bool bSwitchedToStaticMesh = (Representation.PrevRepresentation != EMassRepresentationType::StaticMeshInstance\n\t\t\t&& Representation.CurrentRepresentation == EMassRepresentationType::StaticMeshInstance))\n\t\t{\n\t\t\tconst FTransform& Transform = TransformFragment.GetTransform();\n\t\t\tconst FTransform& PrevTransform = Representation.PrevTransform;\n\t\t\tconst float LODSignificance = RepresentationLOD.LODSignificance;\n\t\t\tconst float PrevLODSignificance = Representation.PrevLODSignificance;\n\t\t\t\t\n\t\t\tif (FMassLODSignificanceRange* NewRange = ISMInfo.GetLODSignificanceRange(RepresentationLOD.LODSignificance))\n\t\t\t{\n\t\t\t\tif (ISMInfo.ShouldUseTransformOffset())\n\t\t\t\t{\n\t\t\t\t\tconst FTransform& TransformOffset = ISMInfo.GetTransformOffset();\n\t\t\t\t\tconst FTransform SMTransform = TransformOffset * Transform;\n\t\t\t\t\tNewRange->AddInstance(EntityHandle, SMTransform);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tNewRange->AddInstance(EntityHandle, Transform);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// consume \"prev\" data\n\t\t\t// @note crazy hacky, but we don't want to consume if bDoKeepActorExtraFrame is true. In that case \n\t\t\t// UMassRepresentationProcessor::UpdateRepresentation expects the \"prev\" state not to be consumed \n\t\t\t// a frame longer so that it can do the consuming (and call \"disable actor\").\n\t\t\tif (bDoKeepActorExtraFrame == false)\n\t\t\t{\n\t\t\t\tRepresentation.PrevRepresentation = Representation.CurrentRepresentation;\n\t\t\t}\n\n\t\t\tSignalSubsystem.SignalEntity(UE::Mass::Signals::SwitchedToISM, EntityHandle);\n\t\t}\n\t\telse if (ISMInfo.GetLODSignificanceRangesNum() > 1 && Representation.PrevLODSignificance != RepresentationLOD.LODSignificance)\n\t\t{\n\t\t\t// we remain in ISM land, but LODSignificance changed and we have multiple LODSignificance ranges for this entity\n\t\t\tFMassLODSignificanceRange* OldRange = ISMInfo.GetLODSignificanceRange(Representation.PrevLODSignificance);\n\t\t\tFMassLODSignificanceRange* NewRange = ISMInfo.GetLODSignificanceRange(RepresentationLOD.LODSignificance);\n\t\t\tif (OldRange != NewRange)\n\t\t\t{\n\t\t\t\tif (OldRange)\n\t\t\t\t{\n\t\t\t\t\tOldRange->RemoveInstance(EntityHandle);\n\t\t\t\t}\n\t\t\t\tif (NewRange)\n\t\t\t\t{\n\t\t\t\t\tconst FTransform& Transform = TransformFragment.GetTransform();\n\t\t\t\t\tNewRange->AddInstance(EntityHandle, Transform);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// consume \"prev\" data\n\t\tRepresentation.PrevLODSignificance = RepresentationLOD.LODSignificance;\n\t}\n}\n",
      "lines": 144
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassStationaryVisualizationTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 1686,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassStationaryVisualizationTrait.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"VisualLogger/VisualLogger.h\"\n\n\nUMassStationaryVisualizationTrait::UMassStationaryVisualizationTrait(const FObjectInitializer& ObjectInitializer)\n{\n\tbAllowServerSideVisualization = true;\n}\n\nvoid UMassStationaryVisualizationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tbool bIssuesFound = false;\n\tfor (FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : StaticMeshInstanceDesc.Meshes)\n\t{\n\t\tbIssuesFound = bIssuesFound || (MeshDesc.Mobility != EComponentMobility::Stationary);\n\t\tMeshDesc.Mobility = EComponentMobility::Stationary;\n\t}\n\tUE_CVLOG_UELOG(bIssuesFound, this, LogMass, Log, TEXT(\"%s some Meshes' mobility has been set to non-Stationary. Theese settings will be overridden. \"), *GetPathName());\n\n\tSuper::BuildTemplate(BuildContext, World);\n\n\tBuildContext.AddTag<FMassStaticRepresentationTag>();\n}\n\n#if WITH_EDITOR\nvoid UMassStationaryVisualizationTrait::PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent)\n{\n\tstatic const FName StaticMeshInstanceDescName = GET_MEMBER_NAME_CHECKED(UMassStationaryVisualizationTrait, StaticMeshInstanceDesc);\n\n\tSuper::PostEditChangeProperty(PropertyChangedEvent);\n\n\tif (PropertyChangedEvent.MemberProperty && PropertyChangedEvent.MemberProperty->GetFName() == StaticMeshInstanceDescName)\n\t{\n\t\tfor (FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : StaticMeshInstanceDesc.Meshes)\n\t\t{\n\t\t\tMeshDesc.Mobility = EComponentMobility::Stationary;\n\t\t}\n\t}\n}\n#endif // WITH_EDITOR\n",
      "lines": 43
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassUpdateISMProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 4080,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassUpdateISMProcessor.h\"\n#include \"MassVisualizationComponent.h\"\n#include \"MassRepresentationSubsystem.h\"\n#include \"MassEntityManager.h\"\n#include \"MassRepresentationFragments.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassLODFragments.h\"\n#include \"Engine/World.h\"\n\nUMassUpdateISMProcessor::UMassUpdateISMProcessor()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)(EProcessorExecutionFlags::Client | EProcessorExecutionFlags::Standalone);\n\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Representation);\n\tbRequiresGameThreadExecution = true;\n}\n\nvoid UMassUpdateISMProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FMassRepresentationFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassRepresentationLODFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddChunkRequirement<FMassVisualizationChunkFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.SetChunkFilter(&FMassVisualizationChunkFragment::AreAnyEntitiesVisibleInChunk);\n\tEntityQuery.AddSharedRequirement<FMassRepresentationSubsystemSharedFragment>(EMassFragmentAccess::ReadWrite);\n\n\t// ignore entities configured to have their representation static (@todo maybe just check if there's not movement fragment?)\n\tEntityQuery.AddTagRequirement<FMassStaticRepresentationTag>(EMassFragmentPresence::None);\n}\n\nvoid UMassUpdateISMProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)\n\t{\n\t\tUMassRepresentationSubsystem* RepresentationSubsystem = Context.GetSharedFragment<FMassRepresentationSubsystemSharedFragment>().RepresentationSubsystem;\n\t\tcheck(RepresentationSubsystem);\n\t\tFMassInstancedStaticMeshInfoArrayView ISMInfo = RepresentationSubsystem->GetMutableInstancedStaticMeshInfos();\n\n\t\tconst TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();\n\t\tconst TArrayView<FMassRepresentationFragment> RepresentationList = Context.GetMutableFragmentView<FMassRepresentationFragment>();\n\t\tconst TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();\n\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tfor (int32 EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)\n\t\t{\n\t\t\tconst FTransformFragment& TransformFragment = TransformList[EntityIdx];\n\t\t\tconst FMassRepresentationLODFragment& RepresentationLOD = RepresentationLODList[EntityIdx];\n\t\t\tFMassRepresentationFragment& Representation = RepresentationList[EntityIdx];\n\n\t\t\tif (Representation.CurrentRepresentation == EMassRepresentationType::StaticMeshInstance)\n\t\t\t{\n\t\t\t\tUpdateISMTransform(Context.GetEntity(EntityIdx), ISMInfo[Representation.StaticMeshDescHandle.ToIndex()], TransformFragment.GetTransform(), Representation.PrevTransform, RepresentationLOD.LODSignificance, Representation.PrevLODSignificance);\n\t\t\t}\n\t\t\tRepresentation.PrevTransform = TransformFragment.GetTransform();\n\t\t\tRepresentation.PrevLODSignificance = RepresentationLOD.LODSignificance;\n\t\t}\n\t});\n}\n\nvoid UMassUpdateISMProcessor::UpdateISMTransform(FMassEntityHandle EntityHandle, FMassInstancedStaticMeshInfo& ISMInfo, const FTransform& Transform, const FTransform& PrevTransform, const float LODSignificance, const float PrevLODSignificance/* = -1.0f*/)\n{\n\tif (ISMInfo.ShouldUseTransformOffset())\n\t{\n\t\tconst FTransform& TransformOffset = ISMInfo.GetTransformOffset();\n\t\tconst FTransform SMTransform = TransformOffset * Transform;\n\t\tconst FTransform SMPrevTransform = TransformOffset * PrevTransform;\n\n\t\tISMInfo.AddBatchedTransform(EntityHandle, SMTransform, SMPrevTransform, LODSignificance, PrevLODSignificance);\n\t}\n\telse\n\t{\n\t\tISMInfo.AddBatchedTransform(EntityHandle, Transform, PrevTransform, LODSignificance, PrevLODSignificance);\n\t}\n}\n",
      "lines": 78
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassVisualizationComponent.cpp",
      "extension": ".cpp",
      "size_bytes": 31520,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassVisualizationComponent.h\"\n#include \"CoreGlobals.h\"\n#include \"Logging/LogMacros.h\"\n#include \"MassVisualizer.h\"\n#include \"MassRepresentationTypes.h\"\n#include \"Components/InstancedStaticMeshComponent.h\"\n#include \"Engine/InstancedStaticMesh.h\"\n#include \"Engine/CollisionProfile.h\"\n#include \"RenderUtils.h\"\n#include \"SceneInterface.h\"\n#include \"Components/HierarchicalInstancedStaticMeshComponent.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"Rendering/NaniteResources.h\"\n#include \"AI/NavigationSystemBase.h\"\n\n\nDECLARE_CYCLE_STAT(TEXT(\"Mass Visualization EndVisualChanges\"), STAT_Mass_VisualizationComponent_EndVisualChanges, STATGROUP_Mass);\nDECLARE_CYCLE_STAT(TEXT(\"Mass Visualization HandleIDs\"), STAT_Mass_VisualizationComponent_HandleChangesWithExternalIDTracking, STATGROUP_Mass);\n\nDECLARE_DWORD_COUNTER_STAT(TEXT(\"VisualizationComp Instances Removed\"), STAT_Mass_VisualizationComponent_InstancesRemovedNum, STATGROUP_Mass);\nDECLARE_DWORD_COUNTER_STAT(TEXT(\"VisualizationComp Instances Added\"), STAT_Mass_VisualizationComponent_InstancesAddedNum, STATGROUP_Mass);\n\n//---------------------------------------------------------------\n// UMassVisualizationComponent\n//---------------------------------------------------------------\n\nnamespace UE::Mass::Representation\n{\n\tint32 GCallUpdateInstances = 1;\n\tFAutoConsoleVariableRef  CVarCallUpdateInstances(TEXT(\"Mass.CallUpdateInstances\"), GCallUpdateInstances, TEXT(\"Toggle between UpdateInstances and BatchUpdateTransform.\"));\n\n#if STATS\n\tuint32 LastStatsResetFrame = 0;\n#endif // STATS\n}  // UE::Mass::Representation\n\nvoid UMassVisualizationComponent::PostInitProperties()\n{\n\tSuper::PostInitProperties();\n\tif (HasAnyFlags(RF_ClassDefaultObject) == false && GetOuter())\n\t{\n\t\tensureMsgf(GetOuter()->GetClass()->IsChildOf(AMassVisualizer::StaticClass()), TEXT(\"UMassVisualizationComponent should only be added to AMassVisualizer-like instances\"));\n\t}\n}\n\nFStaticMeshInstanceVisualizationDescHandle UMassVisualizationComponent::AddInstancedStaticMeshInfo(const FStaticMeshInstanceVisualizationDesc& Desc)\n{\n\tFStaticMeshInstanceVisualizationDescHandle Handle;\n\tif (InstancedStaticMeshInfosFreeIndices.Num() > 0)\n\t{\n\t\tHandle = InstancedStaticMeshInfosFreeIndices.Pop(EAllowShrinking::No);\n\t\tnew(&InstancedStaticMeshInfos[Handle.ToIndex()]) FMassInstancedStaticMeshInfo(Desc);\n\t}\n\telse\n\t{\n\t\tint32 AddedInfoIndex = InstancedStaticMeshInfos.Emplace(Desc);\n\t\tHandle = FStaticMeshInstanceVisualizationDescHandle(AddedInfoIndex);\n\t}\n\n\treturn Handle;\n}\n\nFStaticMeshInstanceVisualizationDescHandle UMassVisualizationComponent::FindOrAddVisualDesc(const FStaticMeshInstanceVisualizationDesc& Desc)\n{\n\tUE_MT_SCOPED_WRITE_ACCESS(InstancedStaticMeshInfosDetector);\n\t// First check to see if we already have a matching Desc already and reuse / return that\n\t// Note: FStaticMeshInstanceVisualizationDescHandle(int32) handles the INDEX_NONE case here, generating an invalid handle in this case\n\tFStaticMeshInstanceVisualizationDescHandle VisualDescHandle(InstancedStaticMeshInfos.IndexOfByPredicate([&Desc](const FMassInstancedStaticMeshInfo& Info) { return Info.GetDesc() == Desc; }));\n\tif (!VisualDescHandle.IsValid())\n\t{\n\t\tif (Desc.IsValid())\n\t\t{\n\t\t\tfor (const FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : Desc.Meshes)\n\t\t\t{\n\t\t\t\tif (MeshDesc.Mesh && MeshDesc.ISMComponentClass)\n\t\t\t\t{\n\t\t\t\t\t// if we've already encountered MeshDesc in the past MeshDescToISMCMap already contains information\n\t\t\t\t\t// about actual ISMC used to represent it, and at the same time indicates the ISMCSharedData data\n\t\t\t\t\t// tied to it. Regardless we need to process all MeshDesc instances here so that we have all the \n\t\t\t\t\t// data ready when InstancedSMComponentsRequiringConstructing gets processed next time\n\t\t\t\t\t// UMassVisualizationComponent::ConstructStaticMeshComponents gets called.\n\t\t\t\t\tMeshDescToISMCMap.FindOrAdd(GetTypeHash(MeshDesc), FISMCSharedDataKey());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tVisualDescHandle = AddInstancedStaticMeshInfo(Desc);\n\t\t\tcheck(VisualDescHandle.IsValid());\n\n\t\t\t// VisualDescHandle is a valid handle now, but there's initialization pending, performed in ConstructStaticMeshComponents\n\t\t\tInstancedSMComponentsRequiringConstructing.Add(VisualDescHandle);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUE_LOG(LogMassRepresentation, Warning, TEXT(\"%hs: invalid FStaticMeshInstanceVisualizationDesc passed in. Check the contained meshes.\"), __FUNCTION__);\n\t\t}\n\t}\n\n\treturn VisualDescHandle;\n}\n\nFStaticMeshInstanceVisualizationDescHandle UMassVisualizationComponent::AddVisualDescWithISMComponent(const FStaticMeshInstanceVisualizationDesc& Desc, UInstancedStaticMeshComponent& ISMComponent)\n{\n\tTObjectPtr<UInstancedStaticMeshComponent> AsObjectPtr = ISMComponent;\n\treturn AddVisualDescWithISMComponents(Desc, MakeArrayView(&AsObjectPtr, 1));\n}\n\nFStaticMeshInstanceVisualizationDescHandle UMassVisualizationComponent::AddVisualDescWithISMComponents(const FStaticMeshInstanceVisualizationDesc& Desc, TArrayView<TObjectPtr<UInstancedStaticMeshComponent>> ISMComponents)\n{\n\tcheck(Desc.Meshes.Num() == ISMComponents.Num());\n\t\n\tUE_MT_SCOPED_WRITE_ACCESS(InstancedStaticMeshInfosDetector);\n\n\n\t// 0. Iterate over all meshes in the visualization desc. Each mesh is a descriptor.\n\tFStaticMeshInstanceVisualizationDescHandle VisualHandle;\n\tTArray<UInstancedStaticMeshComponent*> ISMComponentsUsed;\n\tfor (int32 EntryIndex = 0; EntryIndex < Desc.Meshes.Num(); ++EntryIndex)\n\t{\n\t\tconst FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc = Desc.Meshes[EntryIndex];\n\t\tif (MeshDesc.Mesh == nullptr || ISMComponents[EntryIndex] == nullptr)\n\t\t{\n\t\t\t// invalid description, log an continue.\n\t\t\tUE_VLOG_UELOG(this, LogMassRepresentation, Error, TEXT(\"Empty mesh at index %d while registering FStaticMeshInstanceVisualizationDesc instance\"), EntryIndex);\n\t\t\tcontinue;\n\t\t}\n\t\n\t\t// 1. Creates a VisualHandle that will be used for all ISMCs\n\t\tif (!VisualHandle.IsValid())\n\t\t{\n\t\t\tVisualHandle = AddInstancedStaticMeshInfo(Desc);\n\t\t\tcheck(VisualHandle.IsValid());\n\t\t}\n\n\t\t// 2. Stores one FMassISMCSharedData for each ISMC in ISMCSharedData\n\t\t// NOTE: FMassISMCSharedData stores a reference to an ISMC and instance transform updates performed in the current frame.\n\t\tFMassISMCSharedData& NewData = ISMCSharedData.FindOrAdd(ISMComponents[EntryIndex], FMassISMCSharedData(ISMComponents[EntryIndex], /*bInRequiresExternalInstanceIDTracking=*/true));\n\t\t// 3. Stores the newly created FMassISMCSharedData in a VisualHandle -> FMassISMCSharedData array\n\t\t// NOTE: This means that one VisualHandle may reference multiple FMassISMCSharedData\n\t\tInstancedStaticMeshInfos[VisualHandle.ToIndex()].AddISMComponent(NewData);\n\t\t// 4. Stores an ISMC -> VisualHandle map, which allows us to later on use an ISMC to query for its FMassISMCSharedData\n\t\tISMComponentMap.Add(ISMComponents[EntryIndex], VisualHandle);\n\n\t\tISMComponentsUsed.Add(ISMComponents[EntryIndex]);\n\t}\n\n\tif (VisualHandle.IsValid())\n\t{\n\t\tBuildLODSignificanceForInfo(InstancedStaticMeshInfos[VisualHandle.ToIndex()], ISMComponentsUsed);\n\t}\n\n\treturn VisualHandle;\n}\n\nconst FMassISMCSharedData* UMassVisualizationComponent::GetISMCSharedDataForDescriptionIndex(const int32 DescriptionIndex) const\n{\n\treturn ISMCSharedData.GetDataForIndex(DescriptionIndex);\n}\n\nconst FMassISMCSharedData* UMassVisualizationComponent::GetISMCSharedDataForInstancedStaticMesh(const UInstancedStaticMeshComponent* ISMC) const\n{\n\treturn ISMCSharedData.GetDataForKey(ISMC);\n}\n\nvoid UMassVisualizationComponent::RemoveVisualDesc(const FStaticMeshInstanceVisualizationDescHandle VisualizationHandle)\n{\n\tUE_MT_SCOPED_WRITE_ACCESS(InstancedStaticMeshInfosDetector);\n\t\n\tif (ensure(InstancedStaticMeshInfos.IsValidIndex(VisualizationHandle.ToIndex()))\n\t\t&& ensureMsgf(InstancedStaticMeshInfos[VisualizationHandle.ToIndex()].IsValid(), TEXT(\"Trying to remove visualization data that has already been cleaned\")))\n\t{\n\t\tfor (TObjectPtr<UInstancedStaticMeshComponent>& ISMComponent : InstancedStaticMeshInfos[VisualizationHandle.ToIndex()].InstancedStaticMeshComponents)\n\t\t{\n\t\t\tconst bool bValidKey = ISMComponentMap.Contains(ISMComponent);\n\t\t\tcheckf(bValidKey, TEXT(\"Failed to find ISMC in ISMComponentMap, path: %s\"), *ISMComponent.GetPathName());\n\t\t\tif (bValidKey)\n\t\t\t{\n\t\t\t\tconst FStaticMeshInstanceVisualizationDescHandle StoredVisualizationDescHandle = ISMComponentMap.FindAndRemoveChecked(ISMComponent);\n\t\t\t\tensure(StoredVisualizationDescHandle == VisualizationHandle);\n\t\t\t}\n\t\t\n\t\t\tISMCSharedData.Remove(ISMComponent);\n\t\t}\n\t\t\n\t\tInstancedStaticMeshInfos[VisualizationHandle.ToIndex()].Reset();\n\t\tInstancedStaticMeshInfosFreeIndices.Add(VisualizationHandle);\n\t}\n}\n\nvoid UMassVisualizationComponent::ConstructStaticMeshComponents()\n{\n\tAActor* ActorOwner = GetOwner();\n\tcheck(ActorOwner);\n\t\n\tTArray<UInstancedStaticMeshComponent*> TransientISMCs;\n\n\tUE_MT_SCOPED_WRITE_ACCESS(InstancedStaticMeshInfosDetector);\n\tfor (const FStaticMeshInstanceVisualizationDescHandle VisualDescHandle : InstancedSMComponentsRequiringConstructing)\n\t{\n\t\tif (!ensureMsgf(InstancedStaticMeshInfos.IsValidIndex(VisualDescHandle.ToIndex())\n\t\t\t, TEXT(\"InstancedStaticMeshInfos (size: %d) is never expected to shrink, so VisualDescHandle (value: %u) being invalid indicates it was wrong from the start.\")\n\t\t\t, InstancedStaticMeshInfos.Num(), VisualDescHandle.ToIndex()))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tFMassInstancedStaticMeshInfo& Info = InstancedStaticMeshInfos[VisualDescHandle.ToIndex()];\n\n\t\t// Check if it is already created\n\t\tif (!Info.InstancedStaticMeshComponents.IsEmpty())\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check if there are any specified meshes for this visual type\n\t\tif(Info.Desc.Meshes.Num() == 0)\n\t\t{\n\t\t\tUE_LOG(LogMassRepresentation, Error, TEXT(\"No associated meshes for this instanced static mesh type\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\tTransientISMCs.Reset();\n\t\tfor (const FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : Info.Desc.Meshes)\n\t\t{\n\t\t\t// MeshDescToISMCMap here lets us figure out whether for the given MeshDesc we need to create a new ISM component\n\t\t\t// or a one has already been created in the past. Note that we only need this intermediate map for \n\t\t\t// FMassStaticMeshInstanceVisualizationMeshDesc that has been added to the system without specifying an\n\t\t\t// ISM component to handle the instances (i.e. added via FindOrAddVisualDesc rather than AddVisualDescWithISMComponents).\n\t\t\t// This is the only kind of FMassStaticMeshInstanceVisualizationMeshDesc were processing here. \n\t\t\tFISMCSharedDataKey& ISMCKey = MeshDescToISMCMap.FindChecked(GetTypeHash(MeshDesc));\n\t\t\tFMassISMCSharedData* SharedData = ISMCSharedData.Find(ISMCKey);\n\t\t\tUInstancedStaticMeshComponent* ISMC = SharedData ? SharedData->GetMutableISMComponent() : nullptr;\n\n\t\t\tif (ISMC == nullptr)\n\t\t\t{\n\t\t\t\tISMC = NewObject<UInstancedStaticMeshComponent>(ActorOwner, MeshDesc.ISMComponentClass);\t\n\t\t\t\tCA_ASSUME(ISMC);\n\t\t\t\tREDIRECT_OBJECT_TO_VLOG(ISMC, this);\n\n\t\t\t\t// note that ISMCKey is a reference, so the assignment below actually sets a value in MeshDescToISMCMap\n\t\t\t\t// and all subsequent handling of a given MeshDesc configuration (i.e. containing same values) will \n\t\t\t\t// result in referring to the ISMC we just created.\n\t\t\t\tISMCKey = ISMC;\n\n\t\t\t\tISMC->SetStaticMesh(MeshDesc.Mesh);\n\t\t\t\tfor (int32 ElementIndex = 0; ElementIndex < MeshDesc.MaterialOverrides.Num(); ++ElementIndex)\n\t\t\t\t{\n\t\t\t\t\tif (UMaterialInterface* MaterialOverride = MeshDesc.MaterialOverrides[ElementIndex])\n\t\t\t\t\t{\n\t\t\t\t\t\tISMC->SetMaterial(ElementIndex, MaterialOverride);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tISMC->SetCullDistances(0, 1000000); // @todo: Need to figure out what to do here, either LOD or cull distances.\n\t\t\t\tISMC->SetupAttachment(ActorOwner->GetRootComponent());\n\t\t\t\tISMC->SetCanEverAffectNavigation(false);\n\t\t\t\tISMC->SetCollisionProfileName(UCollisionProfile::NoCollision_ProfileName);\n\t\t\t\tISMC->SetCastShadow(MeshDesc.bCastShadows);\n\t\t\t\tISMC->Mobility = MeshDesc.Mobility;\n\t\t\t\tISMC->SetReceivesDecals(false);\n\t\t\t\tISMC->RegisterComponent();\n\n\t\t\t\tif (SharedData == nullptr)\n\t\t\t\t{\n\t\t\t\t\tSharedData = &ISMCSharedData.Add(ISMC, FMassISMCSharedData(ISMC));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSharedData->SetISMComponent(*ISMC);\n\t\t\t\t}\n\n\t\t\t\tensureMsgf(ISMComponentMap.Find(ISMC) == nullptr, TEXT(\"We've just created the ISMC that's being used here, so this check failing indicates hash-clash.\"));\n\t\t\t\tISMComponentMap.Add(ISMC, VisualDescHandle); \n\t\t\t}\n\n\t\t\tTransientISMCs.Add(ISMC);\n\n\t\t\tcheck(SharedData);\n\t\t\tInfo.AddISMComponent(*SharedData);\n\t\t}\n\n\t\t// Build the LOD significance ranges\n\t\tif (TransientISMCs.Num())\n\t\t{\n\t\t\tcheck(Info.LODSignificanceRanges.Num() == 0);\n\t\t\tBuildLODSignificanceForInfo(Info, TransientISMCs);\n\t\t}\n\t}\n}\n\nvoid UMassVisualizationComponent::BuildLODSignificanceForInfo(FMassInstancedStaticMeshInfo& Info, TConstArrayView<UInstancedStaticMeshComponent*> StaticMeshRefKeys)\n{\n\tTArray<float> AllLODSignificances;\n\tauto UniqueInsertOrdered = [&AllLODSignificances](const float Significance)\n\t{\n\t\tint i = 0;\n\t\tfor (; i < AllLODSignificances.Num(); ++i)\n\t\t{\n\t\t\t// I did not use epsilon check here on purpose, because it will make it hard later meshes inside.\n\t\t\tif (Significance == AllLODSignificances[i])\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (AllLODSignificances[i] > Significance)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tAllLODSignificances.Insert(Significance, i);\n\t};\n\tfor (const FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : Info.Desc.Meshes)\n\t{\n\t\tUniqueInsertOrdered(MeshDesc.MinLODSignificance);\n\t\tUniqueInsertOrdered(MeshDesc.MaxLODSignificance);\n\t}\n\n\tif (AllLODSignificances.Num() > 1)\n\t{\n\t\tInfo.LODSignificanceRanges.SetNum(AllLODSignificances.Num() - 1);\n\t\tfor (int RangeIndex = 0; RangeIndex < Info.LODSignificanceRanges.Num(); ++RangeIndex)\n\t\t{\n\t\t\tFMassLODSignificanceRange& Range = Info.LODSignificanceRanges[RangeIndex];\n\t\t\tRange.MinSignificance = AllLODSignificances[RangeIndex];\n\t\t\tRange.MaxSignificance = AllLODSignificances[RangeIndex + 1];\n\t\t\tRange.ISMCSharedDataPtr = &ISMCSharedData;\n\n\t\t\tfor (int MeshIndex = 0; MeshIndex < Info.Desc.Meshes.Num(); ++MeshIndex)\n\t\t\t{\n\t\t\t\tconst FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc = Info.Desc.Meshes[MeshIndex];\n\t\t\t\tconst bool bAddMeshInRange = (Range.MinSignificance >= MeshDesc.MinLODSignificance && Range.MinSignificance < MeshDesc.MaxLODSignificance);\n\t\t\t\tif (bAddMeshInRange)\n\t\t\t\t{\n\t\t\t\t\tcheckf(StaticMeshRefKeys.IsValidIndex(MeshIndex) && StaticMeshRefKeys[MeshIndex]\n\t\t\t\t\t\t, TEXT(\"We don't expect receiving null ISMCs at this point\"));\n\t\t\t\t\tRange.StaticMeshRefs.Add(StaticMeshRefKeys[MeshIndex]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid UMassVisualizationComponent::ClearAllVisualInstances()\n{\n\tUE_MT_SCOPED_WRITE_ACCESS(InstancedStaticMeshInfosDetector);\n\t\n\tfor (int32 SharedDataIndex = 0; SharedDataIndex < ISMCSharedData.Num(); ++SharedDataIndex)\n\t{\n\t\tif (UInstancedStaticMeshComponent* InstancedStaticMeshComponent = ISMCSharedData.GetAtIndex(SharedDataIndex).GetMutableISMComponent())\n\t\t{\n\t\t\tInstancedStaticMeshComponent->ClearInstances();\n\t\t\tInstancedStaticMeshComponent->DestroyComponent();\n\t\t}\n\t}\n\n\tMeshDescToISMCMap.Reset();\n\tISMCSharedData.Reset();\n\tInstancedSMComponentsRequiringConstructing.Reset();\n\tInstancedStaticMeshInfos.Reset();\n}\n\nvoid UMassVisualizationComponent::DirtyVisuals()\n{\n\tUE_MT_SCOPED_WRITE_ACCESS(InstancedStaticMeshInfosDetector);\n\tfor (FMassInstancedStaticMeshInfo& Info : InstancedStaticMeshInfos)\n\t{\n\t\tfor (UInstancedStaticMeshComponent* InstancedStaticMeshComponent : Info.InstancedStaticMeshComponents)\n\t\t{\n\t\t\tInstancedStaticMeshComponent->MarkRenderStateDirty();\n\t\t}\n\t}\n}\n\nvoid UMassVisualizationComponent::BeginVisualChanges()\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"MassVisualizationComponent BeginVisualChanges\")\n\n\t// Conditionally construct static mesh components\n\tif (InstancedSMComponentsRequiringConstructing.Num())\n\t{\n\t\tConstructStaticMeshComponents();\n\t\tInstancedSMComponentsRequiringConstructing.Reset();\n\t}\n}\n\nvoid UMassVisualizationComponent::HandleChangesWithExternalIDTracking(UInstancedStaticMeshComponent& ISMComponent, FMassISMCSharedData& SharedData)\n{\n\tif (SharedData.HasUpdatesToApply() == false)\n\t{\n\t\t// nothing to do here. We most probably were called as the part of the very first tick of this given SharedData\n\t\t// since all the SharedData starts off as `dirty`.\n\t\treturn;\n\t}\n\n\tSCOPE_CYCLE_COUNTER(STAT_Mass_VisualizationComponent_HandleChangesWithExternalIDTracking);\n\n\t// removing instances first, since this operation is more resilient to duplicates. Plus we make an arbitrary decision \n\t// that it's better to have redundant things visible than not seeing required things\n\tProcessRemoves(ISMComponent, SharedData, /*bUpdateNavigation=*/false);\n\n\t// NOTE: This code path is designed to only perform Adds, never updates so updates are filtered out along with duplicates.\n\tTArray<FMassEntityHandle>& EntityHandles = SharedData.UpdateInstanceIds;\n\tif (EntityHandles.Num())\n\t{\n\t\tINC_DWORD_STAT_BY(STAT_Mass_VisualizationComponent_InstancesAddedNum, EntityHandles.Num());\n\n\t\tFMassISMCSharedData::FEntityToPrimitiveIdMap& SharedIdMap = SharedData.GetMutableEntityPrimitiveToIdMap();\n\t\tTArray<Experimental::FHashElementId> ElementIds;\n\t\tElementIds.SetNumUninitialized(EntityHandles.Num());\n\t\t// Filter out all updates & duplicate adds\n\t\tfor (int32 IDIndex = EntityHandles.Num() - 1; IDIndex >= 0; --IDIndex)\n\t\t{\n\t\t\tbool bWasAlreadyInMap = false;\n\t\t\tExperimental::FHashElementId ElementId = SharedIdMap.FindOrAddId(EntityHandles[IDIndex], FPrimitiveInstanceId{INDEX_NONE}, bWasAlreadyInMap);\n\n\t\t\tif (bWasAlreadyInMap)\n\t\t\t{\n\t\t\t\tSharedData.RemoveUpdatedInstanceIdsAtSwap(IDIndex);\n\t\t\t\tElementIds.RemoveAtSwap(IDIndex);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tElementIds[IDIndex] = ElementId;\n\t\t\t}\n\t\t}\n\n\t\t// it's possible the loop above removed all the data, so we do one last check\n\t\tif (!EntityHandles.IsEmpty())\n\t\t{\n\t\t\tcheck(ElementIds.Num() == EntityHandles.Num());\n\n\t\t\tconst TConstArrayView<FMassEntityHandle> InstanceIds = SharedData.UpdateInstanceIds;\n\n\t\t\tconst TArray<FTransform>& InstanceTransforms = SharedData.GetStaticMeshInstanceTransformsArray();\n\t\t\tconst int32 InNumCustomDataFloats = SharedData.GetStaticMeshInstanceCustomFloats().Num();\n\t\t\tTConstArrayView<float> CustomFloatData = SharedData.GetStaticMeshInstanceCustomFloats();\n\n\t\t\t// if these are the first entities we're adding we need to set NumCustomDataFloats so that the PerInstanceSMCustomData\n\t\t\t// gets populated properly by the AddInstancesInternal call below\n\t\t\tconst int32 StartingCount = ISMComponent.GetNumInstances();\n\t\t\tconst bool bInitiallyEmpty = (StartingCount == 0); \n\t\t\tif (StartingCount == 0 && CustomFloatData.Num() && ISMComponent.Mobility != EComponentMobility::Static)\n\t\t\t{\n\t\t\t\tISMComponent.SetNumCustomDataFloats(InNumCustomDataFloats);\n\t\t\t}\n\n\t\t\tcheck(EntityHandles.Num() == InstanceTransforms.Num());\n\t\t\tTArray<FPrimitiveInstanceId> NewIds = ISMComponent.AddInstancesById(InstanceTransforms, /*bWorldSpace=*/true, /*bUpdateNavigation =*/bInitiallyEmpty);\n\t\t\tcheck(EntityHandles.Num() == NewIds.Num());\n\t\t\tfor (int32 i = 0; i < EntityHandles.Num(); ++i)\n\t\t\t{\n\t\t\t\tSharedIdMap.GetByElementId(ElementIds[i]).Value = NewIds[i];\n\t\t\t}\n\t\t\tensureMsgf(CustomFloatData.Num() == 0, TEXT(\"Custom floats not supported with this set up just yet.\"));\n\t\t}\n\t}\n\n\tif (bNavigationRelevant && ISMComponent.GetInstanceCount() == 0)\n\t{\n\t\tFNavigationSystem::UnregisterComponent(ISMComponent);\n\t}\n}\n\n\nvoid UMassVisualizationComponent::ProcessRemoves(UInstancedStaticMeshComponent& ISMComponent, FMassISMCSharedData& SharedData, const bool bUpdateNavigation /*= true*/)\n{\n\tif (!SharedData.GetRemoveInstanceIds().IsEmpty())\n\t{\n\t\tFMassISMCSharedData::FEntityToPrimitiveIdMap& SharedIdMap = SharedData.GetMutableEntityPrimitiveToIdMap();\n\t\tINC_DWORD_STAT_BY(STAT_Mass_VisualizationComponent_InstancesRemovedNum, SharedData.GetRemoveInstanceIds().Num());\n\n\t\tTConstArrayView<FMassEntityHandle> EntityHandles = SharedData.GetRemoveInstanceIds();\n\n\t\tTArray<FPrimitiveInstanceId> ISMInstanceIds;\n\t\tISMInstanceIds.Reserve(EntityHandles.Num());\n\t\t\n\t\t// Translate Mass IDs to ISMC IDs\n\t\tfor (const FMassEntityHandle MassInstanceId : EntityHandles)\n\t\t{\n\t\t\tExperimental::FHashElementId ElementId = SharedIdMap.FindId(MassInstanceId);\n\t\t\tif (ElementId.IsValid())\n\t\t\t{\n\t\t\t\tFPrimitiveInstanceId InstanceId = SharedIdMap.GetByElementId(ElementId).Value;\n\t\t\t\tcheck(InstanceId.IsValid());\n\t\t\t\tSharedIdMap.RemoveByElementId(ElementId);\n\t\t\t\tISMInstanceIds.Add(InstanceId);\n\t\t\t}\n\t\t}\n\n\t\tISMComponent.RemoveInstancesById(ISMInstanceIds, bUpdateNavigation);\n\t}\n}\n\nvoid UMassVisualizationComponent::EndVisualChanges()\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"MassVisualizationComponent EndVisualChanges\")\n\tSCOPE_CYCLE_COUNTER(STAT_Mass_VisualizationComponent_EndVisualChanges);\n\n#if STATS\n\tif (UE::Mass::Representation::LastStatsResetFrame != GFrameNumber)\n\t{\n\t\tSET_DWORD_STAT(STAT_Mass_VisualizationComponent_InstancesRemovedNum, 0);\n\t\tSET_DWORD_STAT(STAT_Mass_VisualizationComponent_InstancesAddedNum, 0);\n\t\tUE::Mass::Representation::LastStatsResetFrame = GFrameNumber;\n\t}\n#endif // STATS\n\n\t// Batch update gathered instance transforms\n\tfor (FMassISMCSharedDataMap::FDirtyIterator It(ISMCSharedData); It; ++It)\n\t{\n\t\tFMassISMCSharedData& SharedData = *It;\n\n\t\tUInstancedStaticMeshComponent* ISMComponent = SharedData.GetMutableISMComponent();\n\t\t// @todo need to check validity this way since Mass used to rely on the assumption that all the ISM components used were\n\t\t// under its control. That's no longer the case, but the system has not been updated to take that into consideration.\n\t\t// This is a temporary fix. \n\t\tif (IsValid(ISMComponent))\n\t\t{\n\t\t\tensureMsgf(!Cast<UHierarchicalInstancedStaticMeshComponent>(ISMComponent), TEXT(\"The UMassVisualizationComponent does not support driving a HISM, since it is not suitable for rapid updates, replace `%s`.\"), *ISMComponent->GetFullName());\n\n\t\t\tif (SharedData.RequiresExternalInstanceIDTracking())\n\t\t\t{\n\t\t\t\tHandleChangesWithExternalIDTracking(*ISMComponent, SharedData);\n\t\t\t\tIt.ClearDirtyFlag();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Process all removes.\n\t\t\t\tProcessRemoves(*ISMComponent, SharedData);\n\n\t\t\t\tconst int32 NumCustomDataFloats = SharedData.StaticMeshInstanceCustomFloats.Num() / (FMath::Max(1, SharedData.UpdateInstanceIds.Num()));\n\n\t\t\t\t// Ensure InstanceCustomData is passed if NumCustomDataFloats > 0. If it is, also make sure\n\t\t\t\t// its length is NumCustomDataFloats * InstanceTransforms.Num()\n\t\t\t\tensure(NumCustomDataFloats == 0 || (SharedData.StaticMeshInstanceCustomFloats.Num() == NumCustomDataFloats * SharedData.UpdateInstanceIds.Num()));\n\t\t\t\tISMComponent->SetNumCustomDataFloats(NumCustomDataFloats);\n\t\t\t\tTArray<FMassEntityHandle>& EntityHandles = SharedData.UpdateInstanceIds;\n\t\t\t\t{\n\t\t\t\t\t// Loop over all the instances in the update and \n\t\t\t\t\t// 1. Sort the data such that all Adds are last\n\t\t\t\t\t// 2. Remove any duplicates (unsure if they may exist)\n\t\t\t\t\tFMassISMCSharedData::FEntityToPrimitiveIdMap& SharedIdMap = SharedData.GetMutableEntityPrimitiveToIdMap();\n\t\t\t\t\t// Filter out all updates & duplicate adds\n\t\t\t\t\tTBitArray<> Unprocessed;\n\t\t\t\t\tUnprocessed.SetNum(SharedIdMap.GetMaxIndex(), true);\n\t\t\t\t\t// Process interval\n\n\t\t\t\t\tTConstArrayView<FTransform> PrevInstanceTransforms = SharedData.GetStaticMeshInstancePrevTransforms();\n\t\t\t\t\tTConstArrayView<FTransform> InstanceTransforms = SharedData.GetStaticMeshInstanceTransformsArray();\n\t\t\t\t\tTConstArrayView<float> CustomDataFloats = SharedData.GetStaticMeshInstanceCustomFloats();\n\n\t\t\t\t\t// Enable support for per-instance prev transforms, if it was not already enabled it will copy the current transforms.\n\t\t\t\t\tISMComponent->SetHasPerInstancePrevTransforms(!PrevInstanceTransforms.IsEmpty());\n\n\t\t\t\t\tstruct FAddItem\n\t\t\t\t\t{\n\t\t\t\t\t\tExperimental::FHashElementId ElementId;\n\t\t\t\t\t\tint32 IDIndex;\n\t\t\t\t\t};\n\t\t\t\t\tTArray<FAddItem> ToAdd;\n\t\t\t\t\tToAdd.Reserve(EntityHandles.Num());\n\t\t\t\t\tfor (int32 IDIndex = 0; IDIndex < EntityHandles.Num(); ++IDIndex)\n\t\t\t\t\t{\n\t\t\t\t\t\tbool bWasAlreadyInMap = false;\n\t\t\t\t\t\tExperimental::FHashElementId ElementId = SharedIdMap.FindOrAddId(EntityHandles[IDIndex], FPrimitiveInstanceId{INDEX_NONE}, bWasAlreadyInMap);\n\n\t\t\t\t\t\t// if it was already in the map, it may be a duplicate if we have processed it already\n\t\t\t\t\t\tbool bIsDuplicate = bWasAlreadyInMap && !Unprocessed[ElementId.GetIndex()];\n\t\t\t\t\t\tif (bIsDuplicate)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tFPrimitiveInstanceId Id = SharedIdMap.GetByElementId(ElementId).Value;\n\t\t\t\t\t\tif (!Id.IsValid())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcheck(!bWasAlreadyInMap);\n\t\t\t\t\t\t\tToAdd.Emplace(FAddItem{ElementId, IDIndex});\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tISMComponent->UpdateInstanceTransformById(Id, InstanceTransforms[IDIndex]);\n\t\t\t\t\t\t\tif (!PrevInstanceTransforms.IsEmpty())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tISMComponent->SetPreviousTransformById(Id, PrevInstanceTransforms[IDIndex]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!CustomDataFloats.IsEmpty())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tISMComponent->SetCustomDataById(Id, MakeArrayView(CustomDataFloats.GetData() + IDIndex * NumCustomDataFloats, NumCustomDataFloats));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Make sure we have enough space to track the already processed IDs\n\t\t\t\t\t\tUnprocessed.SetNum(SharedIdMap.GetMaxIndex(), true);\n\t\t\t\t\t\tUnprocessed[ElementId.GetIndex()] = false;\n\t\t\t\t\t}\n\t\t\t\t\t// Collect unwanted items & remove\n\t\t\t\t\tTArray<FPrimitiveInstanceId> RemovedISMInstanceIds;\n\t\t\t\t\tRemovedISMInstanceIds.Reserve(Unprocessed.Num());\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(TConstSetBitIterator<> BitIt(Unprocessed); BitIt; ++BitIt)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tExperimental::FHashElementId ElementId(BitIt.GetIndex());\n\t\t\t\t\t\t\tif (SharedIdMap.ContainsElementId(ElementId))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tFPrimitiveInstanceId InstanceId = SharedIdMap.GetByElementId(ElementId).Value;\n\t\t\t\t\t\t\t\tcheck(InstanceId.IsValid());\n\t\t\t\t\t\t\t\tSharedIdMap.RemoveByElementId(ElementId);\n\t\t\t\t\t\t\t\tRemovedISMInstanceIds.Add(InstanceId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t\t\n\t\t\t\t\t\tISMComponent->RemoveInstancesById(RemovedISMInstanceIds);\n\t\t\t\t\t}\n\t\t\t\t\t// Process deferred adds.\n\t\t\t\t\tfor (FAddItem AddItem : ToAdd)\n\t\t\t\t\t{\n\t\t\t\t\t\tFPrimitiveInstanceId Id = ISMComponent->AddInstanceById(InstanceTransforms[AddItem.IDIndex]);\n\t\t\t\t\t\tcheck(!SharedIdMap.GetByElementId(AddItem.ElementId).Value.IsValid());\n\t\t\t\t\t\tSharedIdMap.GetByElementId(AddItem.ElementId).Value = Id;\n\n\t\t\t\t\t\tif (!PrevInstanceTransforms.IsEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tISMComponent->SetPreviousTransformById(Id, PrevInstanceTransforms[AddItem.IDIndex]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!CustomDataFloats.IsEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tISMComponent->SetCustomDataById(Id, MakeArrayView(CustomDataFloats.GetData() + AddItem.IDIndex * NumCustomDataFloats, NumCustomDataFloats));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\t// note that we're not clearing the dirty flag on purpose - these components require constant updates\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// bump the touch counter so that anyone caching data based on contents of this SharedData can detect the change\n\t\t\t++SharedData.ComponentInstanceIdTouchCounter;\n\t\t}\n\t\t\n\t\tSharedData.ResetAccumulatedData();\n\t}\n}\n\n//---------------------------------------------------------------\n// FMassLODSignificanceRange\n//---------------------------------------------------------------\n\nvoid FMassLODSignificanceRange::AddBatchedTransform(const FMassEntityHandle EntityHandle, const FTransform& Transform, const FTransform& PrevTransform, TConstArrayView<FISMCSharedDataKey> ExcludeStaticMeshRefs)\n{\n\tcheck(ISMCSharedDataPtr);\n\tfor (int32 StaticMeshIndex = 0; StaticMeshIndex < StaticMeshRefs.Num(); ++StaticMeshIndex)\n\t{\n\t\tif (ExcludeStaticMeshRefs.Contains(StaticMeshRefs[StaticMeshIndex]))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (FMassISMCSharedData* SharedData = ISMCSharedDataPtr->GetAndMarkDirty(StaticMeshRefs[StaticMeshIndex]))\n\t\t{\n\t\t\tSharedData->UpdateInstanceIds.Add(EntityHandle);\n\t\t\tSharedData->StaticMeshInstanceTransforms.Add(Transform);\n\t\t\tSharedData->StaticMeshInstancePrevTransforms.Add(PrevTransform);\n\t\t}\n\t}\n}\n\nvoid FMassLODSignificanceRange::AddBatchedCustomDataFloats(const TArray<float>& CustomFloats, const TArray<FISMCSharedDataKey>& ExcludeStaticMeshRefs)\n{\n\tcheck(ISMCSharedDataPtr);\n\tfor (int32 StaticMeshIndex = 0; StaticMeshIndex < StaticMeshRefs.Num(); ++StaticMeshIndex)\n\t{\n\t\tif (ExcludeStaticMeshRefs.Contains(StaticMeshRefs[StaticMeshIndex]))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (FMassISMCSharedData* SharedData = ISMCSharedDataPtr->GetAndMarkDirty(StaticMeshRefs[StaticMeshIndex]))\n\t\t{\n\t\t\tSharedData->StaticMeshInstanceCustomFloats.Append(CustomFloats);\n\t\t}\n\t}\n}\n\nvoid FMassLODSignificanceRange::AddInstance(const FMassEntityHandle EntityHandle, const FTransform& Transform)\n{\n\tcheck(ISMCSharedDataPtr);\n\tfor (int32 StaticMeshIndex = 0; StaticMeshIndex < StaticMeshRefs.Num(); ++StaticMeshIndex)\n\t{\n\t\tif (FMassISMCSharedData* SharedData = ISMCSharedDataPtr->GetAndMarkDirty(StaticMeshRefs[StaticMeshIndex]))\n\t\t{\n\t\t\tSharedData->UpdateInstanceIds.Add(EntityHandle);\n\t\t\tSharedData->StaticMeshInstanceTransforms.Add(Transform);\n\t\t\tSharedData->StaticMeshInstancePrevTransforms.Add(Transform);\n\t\t}\n\t}\n}\n\nvoid FMassLODSignificanceRange::RemoveInstance(const FMassEntityHandle EntityHandle)\n{\n\tcheck(ISMCSharedDataPtr);\n\tfor (int32 StaticMeshIndex = 0; StaticMeshIndex < StaticMeshRefs.Num(); ++StaticMeshIndex)\n\t{\n\t\tif (FMassISMCSharedData* SharedData = ISMCSharedDataPtr->GetAndMarkDirty(StaticMeshRefs[StaticMeshIndex]))\n\t\t{\n\t\t\tSharedData->RemoveInstanceIds.Add(EntityHandle);\n\t\t}\n\t}\n}\n\nvoid FMassLODSignificanceRange::WriteCustomDataFloatsAtStartIndex(int32 StaticMeshIndex, const TArrayView<float>& CustomFloats, const int32 FloatsPerInstance, const int32 StartFloatIndex, const TArray<FISMCSharedDataKey>& ExcludeStaticMeshRefs)\n{\n\tcheck(ISMCSharedDataPtr);\n\tif (StaticMeshRefs.IsValidIndex(StaticMeshIndex))\n\t{\n\t\tif (ExcludeStaticMeshRefs.Contains(StaticMeshRefs[StaticMeshIndex]))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (FMassISMCSharedData* SharedData = ISMCSharedDataPtr->GetAndMarkDirty(StaticMeshRefs[StaticMeshIndex]))\n\t\t{\n\t\t\tconst int32 StartIndex = FloatsPerInstance * SharedData->WriteIterator + StartFloatIndex;\n\n\t\t\tensure(SharedData->StaticMeshInstanceCustomFloats.Num() >= StartIndex + CustomFloats.Num());\n\n\t\t\tfor (int CustomFloatIdx = 0; CustomFloatIdx < CustomFloats.Num(); CustomFloatIdx++)\n\t\t\t{\n\t\t\t\tSharedData->StaticMeshInstanceCustomFloats[StartIndex + CustomFloatIdx] = CustomFloats[CustomFloatIdx];\n\t\t\t}\n\t\t\tSharedData->WriteIterator++;\n\t\t}\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// DEPRECATED\n//-----------------------------------------------------------------------------\nvoid UMassVisualizationComponent::RemoveISMComponent(UInstancedStaticMeshComponent& ISMComponent)\n{\n\tUE_MT_SCOPED_WRITE_ACCESS(InstancedStaticMeshInfosDetector);\n\n\tconst FStaticMeshInstanceVisualizationDescHandle* VisualDescHandlePtr = ISMComponentMap.Find(&ISMComponent);\n\tif (VisualDescHandlePtr)\n\t{\n\t\tRemoveVisualDesc(*VisualDescHandlePtr);\n\t}\n}\n\nvoid UMassVisualizationComponent::RemoveVisualDescByIndex(const int32 VisualizationIndex)\n{\n\tRemoveVisualDesc(FStaticMeshInstanceVisualizationDescHandle(VisualizationIndex));\n}\n",
      "lines": 750
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassVisualizationLODProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 7045,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassVisualizationLODProcessor.h\"\n#include \"MassRepresentationDebug.h\"\n#include \"MassExecutionContext.h\"\n\nUMassVisualizationLODProcessor::UMassVisualizationLODProcessor()\n{\n\tbAutoRegisterWithProcessingPhases = false;\n\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::LOD;\n\tExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LODCollector);\n}\n\nvoid UMassVisualizationLODProcessor::ConfigureQueries()\n{\n\tFMassEntityQuery BaseQuery;\n\tBaseQuery.AddTagRequirement<FMassVisualizationLODProcessorTag>(EMassFragmentPresence::All);\n\tBaseQuery.AddRequirement<FMassViewerInfoFragment>(EMassFragmentAccess::ReadOnly);\n\tBaseQuery.AddRequirement<FMassRepresentationLODFragment>(EMassFragmentAccess::ReadWrite);\n\tBaseQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tBaseQuery.AddConstSharedRequirement<FMassVisualizationLODParameters>();\n\tBaseQuery.AddSharedRequirement<FMassVisualizationLODSharedFragment>(EMassFragmentAccess::ReadWrite);\n\n\tCloseEntityQuery = BaseQuery;\n\tCloseEntityQuery.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::None);\n\tCloseEntityQuery.RegisterWithProcessor(*this);\n\n\tCloseEntityAdjustDistanceQuery = CloseEntityQuery;\n\tCloseEntityAdjustDistanceQuery.SetChunkFilter([](const FMassExecutionContext& Context)\n\t{\n\t\tconst FMassVisualizationLODSharedFragment& LODSharedFragment = Context.GetSharedFragment<FMassVisualizationLODSharedFragment>();\n\t\treturn LODSharedFragment.bHasAdjustedDistancesFromCount;\n\t});\n\tCloseEntityAdjustDistanceQuery.RegisterWithProcessor(*this);\n\n\tFarEntityQuery = BaseQuery;\n\tFarEntityQuery.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::All);\n\tFarEntityQuery.AddChunkRequirement<FMassVisualizationChunkFragment>(EMassFragmentAccess::ReadOnly);\n\tFarEntityQuery.SetChunkFilter(&FMassVisualizationChunkFragment::ShouldUpdateVisualizationForChunk);\n\tFarEntityQuery.RegisterWithProcessor(*this);\n\n\tDebugEntityQuery = BaseQuery;\n\tDebugEntityQuery.RegisterWithProcessor(*this);\n\n\tProcessorRequirements.AddSubsystemRequirement<UMassLODSubsystem>(EMassFragmentAccess::ReadOnly);\n}\n\nvoid UMassVisualizationLODProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tif (bForceOFFLOD)\n\t{\n\t\tCloseEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t\t{\n\t\t\tFMassVisualizationLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassVisualizationLODSharedFragment>();\n\t\t\tTArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetMutableFragmentView<FMassRepresentationLODFragment>();\n\t\t\tLODSharedFragment.LODCalculator.ForceOffLOD(Context, RepresentationLODList);\n\t\t});\n\t\treturn;\n\t}\n\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(PrepareExecution)\n\t\tconst UMassLODSubsystem& LODSubsystem = Context.GetSubsystemChecked<UMassLODSubsystem>();\n\t\tconst TArray<FViewerInfo>& Viewers = LODSubsystem.GetViewers();\n\t\tEntityManager.ForEachSharedFragment<FMassVisualizationLODSharedFragment>([this, &Viewers](FMassVisualizationLODSharedFragment& LODSharedFragment)\n\t\t{\n\t\t\tif (FilterTag == LODSharedFragment.FilterTag)\n\t\t\t{\n\t\t\t\tLODSharedFragment.LODCalculator.PrepareExecution(Viewers);\n\t\t\t}\n\t\t});\n\t}\n\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(CalculateLOD)\n\n\t\tauto CalculateLOD = [this](FMassExecutionContext& Context)\n\t\t{\n\t\t\tFMassVisualizationLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassVisualizationLODSharedFragment>();\n\t\t\tTArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetMutableFragmentView<FMassRepresentationLODFragment>();\n\t\t\tTConstArrayView<FMassViewerInfoFragment> ViewerInfoList = Context.GetFragmentView<FMassViewerInfoFragment>();\n\t\t\tLODSharedFragment.LODCalculator.CalculateLOD(Context, ViewerInfoList, RepresentationLODList);\n\t\t};\n\t\tCloseEntityQuery.ForEachEntityChunk(EntityManager, Context, CalculateLOD);\n\t\tFarEntityQuery.ForEachEntityChunk(EntityManager, Context, CalculateLOD);\n\t}\n\n\tif (bDoAdjustmentFromCount)\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(AdjustDistanceAndLODFromCount)\n\t\tEntityManager.ForEachSharedFragment<FMassVisualizationLODSharedFragment>([this](FMassVisualizationLODSharedFragment& LODSharedFragment)\n\t\t{\n\t\t\tif (FilterTag == LODSharedFragment.FilterTag)\n\t\t\t{\n\t\t\t\tLODSharedFragment.bHasAdjustedDistancesFromCount = LODSharedFragment.LODCalculator.AdjustDistancesFromCount();\n\t\t\t}\n\t\t});\n\n\t\tCloseEntityAdjustDistanceQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t\t{\n\t\t\tFMassVisualizationLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassVisualizationLODSharedFragment>();\n\t\t\tTConstArrayView<FMassViewerInfoFragment> ViewerInfoList = Context.GetFragmentView<FMassViewerInfoFragment>();\n\t\t\tTArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetMutableFragmentView<FMassRepresentationLODFragment>();\n\t\t\tLODSharedFragment.LODCalculator.AdjustLODFromCount(Context, ViewerInfoList, RepresentationLODList);\n\t\t});\n\t\t// Far entities do not need to maximize count\n\t}\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\t// Optional debug display\n\tif (UE::Mass::Representation::Debug::DebugRepresentationLOD == 1 || UE::Mass::Representation::Debug::DebugRepresentationLOD >= 3)\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(DebugDisplayLOD)\n\t\tUWorld* World = EntityManager.GetWorld();\n\t\tDebugEntityQuery.ForEachEntityChunk(EntityManager, Context, [World](FMassExecutionContext& Context)\n\t\t{\n\t\t\tFMassVisualizationLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassVisualizationLODSharedFragment>();\n\t\t\tTConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();\n\t\t\tTConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();\n\t\t\tLODSharedFragment.LODCalculator.DebugDisplaySignificantLOD(Context, RepresentationLODList, TransformList, World, UE::Mass::Representation::Debug::DebugRepresentationLODMaxSignificance);\n\t\t});\n\t}\n\t// Optional vislog\n\tif (UE::Mass::Representation::Debug::DebugRepresentationLOD >= 2)\n\t{\n\t\tTRACE_CPUPROFILER_EVENT_SCOPE(VisLogLOD)\n\t\tDebugEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t\t{\n\t\t\tFMassVisualizationLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassVisualizationLODSharedFragment>();\n\t\t\tTConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();\n\t\t\tTConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();\n\t\t\tLODSharedFragment.LODCalculator.VisLogSignificantLOD(Context, RepresentationLODList, TransformList, this, UE::Mass::Representation::Debug::DebugRepresentationLODMaxSignificance);\n\t\t});\n\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n}\n",
      "lines": 137
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassVisualizationTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 9011,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassVisualizationTrait.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"MassRepresentationSubsystem.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassRepresentationFragments.h\"\n#include \"MassRepresentationActorManagement.h\"\n#include \"Engine/World.h\"\n#include \"MassLODFragments.h\"\n#include \"MassActorSubsystem.h\"\n#include \"MassEntityUtils.h\"\n#include \"MassVisualizationLODProcessor.h\"\n#include \"MassRepresentationProcessor.h\"\n#if WITH_EDITOR\n#include \"Logging/MessageLog.h\"\n#include \"Editor.h\"\n#include \"UObject/UnrealType.h\"\n#endif\n\n#define LOCTEXT_NAMESPACE \"Mass\"\n\n\nUMassVisualizationTrait::UMassVisualizationTrait()\n{\n\tRepresentationSubsystemClass = UMassRepresentationSubsystem::StaticClass();\n\n\tParams.RepresentationActorManagementClass = UMassRepresentationActorManagement::StaticClass();\n\tParams.LODRepresentation[EMassLOD::High] = EMassRepresentationType::HighResSpawnedActor;\n\tParams.LODRepresentation[EMassLOD::Medium] = EMassRepresentationType::LowResSpawnedActor;\n\tParams.LODRepresentation[EMassLOD::Low] = EMassRepresentationType::StaticMeshInstance;\n\tParams.LODRepresentation[EMassLOD::Off] = EMassRepresentationType::None;\n\n\tLODParams.BaseLODDistance[EMassLOD::High] = 0.f;\n\tLODParams.BaseLODDistance[EMassLOD::Medium] = 1000.f;\n\tLODParams.BaseLODDistance[EMassLOD::Low] = 2500.f;\n\tLODParams.BaseLODDistance[EMassLOD::Off] = 10000.f;\n\n\tLODParams.VisibleLODDistance[EMassLOD::High] = 0.f;\n\tLODParams.VisibleLODDistance[EMassLOD::Medium] = 2000.f;\n\tLODParams.VisibleLODDistance[EMassLOD::Low] = 4000.f;\n\tLODParams.VisibleLODDistance[EMassLOD::Off] = 10000.f;\n\n\tLODParams.LODMaxCount[EMassLOD::High] = 50;\n\tLODParams.LODMaxCount[EMassLOD::Medium] = 100;\n\tLODParams.LODMaxCount[EMassLOD::Low] = 500;\n\tLODParams.LODMaxCount[EMassLOD::Off] = 0;\n\n\tLODParams.BufferHysteresisOnDistancePercentage = 10.0f;\n\tLODParams.DistanceToFrustum = 0.0f;\n\tLODParams.DistanceToFrustumHysteresis = 0.0f;\n\n\tbAllowServerSideVisualization = false;\n}\n\nvoid UMassVisualizationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\t// This should not be ran on NM_Server network mode\n\tif (World.IsNetMode(NM_DedicatedServer) && !bAllowServerSideVisualization \n\t\t&& !BuildContext.IsInspectingData())\n\t{\n\t\treturn;\n\t}\n\n\tBuildContext.RequireFragment<FMassViewerInfoFragment>();\n\tBuildContext.RequireFragment<FTransformFragment>();\n\tBuildContext.RequireFragment<FMassActorFragment>();\n\n\tFMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(World);\n\n\tUMassRepresentationSubsystem* RepresentationSubsystem = Cast<UMassRepresentationSubsystem>(World.GetSubsystemBase(RepresentationSubsystemClass));\n\tif (RepresentationSubsystem == nullptr && !BuildContext.IsInspectingData())\n\t{\n\t\tUE_LOG(LogMassRepresentation, Error, TEXT(\"Expecting a valid class for the representation subsystem\"));\n\t\tRepresentationSubsystem = UWorld::GetSubsystem<UMassRepresentationSubsystem>(&World);\n\t\tcheck(RepresentationSubsystem);\n\t}\n\n\tFMassRepresentationSubsystemSharedFragment SubsystemSharedFragment;\n\tSubsystemSharedFragment.RepresentationSubsystem = RepresentationSubsystem;\n\tFSharedStruct SubsystemFragment = EntityManager.GetOrCreateSharedFragment<FMassRepresentationSubsystemSharedFragment>(SubsystemSharedFragment);\n\tBuildContext.AddSharedFragment(SubsystemFragment);\n\n\tif (!Params.RepresentationActorManagementClass)\n\t{\n\t\tUE_LOG(LogMassRepresentation, Error, TEXT(\"Expecting a valid class for the representation actor management\"));\n\t}\n\n\tFMassRepresentationFragment& RepresentationFragment = BuildContext.AddFragment_GetRef<FMassRepresentationFragment>();\n\tif (LIKELY(BuildContext.IsInspectingData() == false))\n\t{\n\t\tRepresentationFragment.HighResTemplateActorIndex = HighResTemplateActor.Get() ? RepresentationSubsystem->FindOrAddTemplateActor(HighResTemplateActor.Get()) : INDEX_NONE;\n\t\tRepresentationFragment.LowResTemplateActorIndex = LowResTemplateActor.Get() ? RepresentationSubsystem->FindOrAddTemplateActor(LowResTemplateActor.Get()) : INDEX_NONE;\n\t}\n\n\tbool bStaticMeshDescriptionValid = StaticMeshInstanceDesc.IsValid();\n\tif (bStaticMeshDescriptionValid)\n\t{\n\t\tif (bRegisterStaticMeshDesc && !BuildContext.IsInspectingData())\n\t\t{\n\t\t\tRepresentationFragment.StaticMeshDescHandle = RepresentationSubsystem->FindOrAddStaticMeshDesc(StaticMeshInstanceDesc);\n\t\t\tensureMsgf(RepresentationFragment.StaticMeshDescHandle.IsValid()\n\t\t\t\t, TEXT(\"Expected to get a valid StaticMeshDescHandle since we already checked that StaticMeshInstanceDesc is valid\"));\n\t\t\t// if the unexpected happens and StaticMeshDescHandle is not valid we're going to treat it as if StaticMeshInstanceDesc\n\t\t\t// was not valid in the first place and handle it accordingly in a moment\n\t\t\tbStaticMeshDescriptionValid = RepresentationFragment.StaticMeshDescHandle.IsValid();\n\t\t}\n\t}\n\n\tFConstSharedStruct ParamsFragment;\n\tif (bStaticMeshDescriptionValid)\n\t{\n\t\tParamsFragment = EntityManager.GetOrCreateConstSharedFragment(Params);\n\t}\n\telse\n\t{\n\t\tFMassRepresentationParameters ParamsCopy = Params;\n\t\tSanitizeParams(ParamsCopy, bStaticMeshDescriptionValid);\n\t\tParamsFragment = EntityManager.GetOrCreateConstSharedFragment(ParamsCopy);\n\t}\n\tParamsFragment.Get<const FMassRepresentationParameters>().ComputeCachedValues();\n\tBuildContext.AddConstSharedFragment(ParamsFragment);\n\n\tFConstSharedStruct LODParamsFragment = EntityManager.GetOrCreateConstSharedFragment(LODParams);\n\tBuildContext.AddConstSharedFragment(LODParamsFragment);\n\n\tFSharedStruct LODSharedFragment = EntityManager.GetOrCreateSharedFragment<FMassVisualizationLODSharedFragment>(FConstStructView::Make(LODParams), LODParams);\n\tBuildContext.AddSharedFragment(LODSharedFragment);\n\n\tBuildContext.AddFragment<FMassRepresentationLODFragment>();\n\tBuildContext.AddTag<FMassVisibilityCulledByDistanceTag>();\n\tBuildContext.AddChunkFragment<FMassVisualizationChunkFragment>();\n\n\tBuildContext.AddTag<FMassVisualizationLODProcessorTag>();\n\tBuildContext.AddTag<FMassVisualizationProcessorTag>();\n}\n\nvoid UMassVisualizationTrait::SanitizeParams(FMassRepresentationParameters& InOutParams, const bool bStaticMeshDeterminedInvalid) const\n{\n\tif (bStaticMeshDeterminedInvalid || (StaticMeshInstanceDesc.IsValid() == false))\n\t{\n\t\tfor (int32 LODIndex = 0; LODIndex < EMassLOD::Max; ++LODIndex)\n\t\t{\n\t\t\tif (InOutParams.LODRepresentation[LODIndex] == EMassRepresentationType::StaticMeshInstance)\n\t\t\t{\n\t\t\t\tInOutParams.LODRepresentation[LODIndex] = EMassRepresentationType::None;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid UMassVisualizationTrait::Serialize(FArchive& Ar)\n{\n\tSuper::Serialize(Ar);\n\n#if WITH_EDITOR\n\tif (GEditor && (Ar.IsLoading() || Ar.IsSaving()))\n\t{\n\t\tValidateParams();\n\t}\n#endif // WITH_EDITOR\n}\n\nbool UMassVisualizationTrait::ValidateTemplate(const FMassEntityTemplateBuildContext& BuildContext, const UWorld& World, FAdditionalTraitRequirements& OutTraitRequirements) const\n{\n\tSuper::ValidateTemplate(BuildContext, World, OutTraitRequirements);\n\n#if WITH_EDITOR\n\treturn ValidateParams();\n#else\n\treturn true;\n#endif // WITH_EDITOR\n}\n\n#if WITH_EDITOR\nbool UMassVisualizationTrait::ValidateParams() const\n{\n\tbool bIssuesFound = false;\n\n\t// if this test is called on any of the CDOs we don't care, we're never going to utilize those in practice.\n\tif (HasAnyFlags(RF_ClassDefaultObject) == false)\n\t{\n\t\t// the SM config provided is not valid. We need to check if EMassRepresentationType::StaticMeshInstance\n\t\t// is being used as any of the LODRepresentations. If so then we need to clear those out and report an error\n\t\tif (StaticMeshInstanceDesc.IsValid() == false)\n\t\t{\n\t\t\tfor (int32 LODIndex = 0; LODIndex < EMassLOD::Max; ++LODIndex)\n\t\t\t{\n\t\t\t\tif (Params.LODRepresentation[LODIndex] == EMassRepresentationType::StaticMeshInstance)\n\t\t\t\t{\n\t\t\t\t\tbIssuesFound = true;\n\n\t\t\t\t\tUE_LOG(LogMassRepresentation, Error, TEXT(\"Trait %s is using StaticMeshInstance representation type for \"\n\t\t\t\t\t\t\"LODRepresentation[%s] while the trait's StaticMeshInstanceDesc is not valid (has no Meshes). Entities \"\n\t\t\t\t\t\t\"won't be visible at this LOD level.\")\n\t\t\t\t\t\t, *GetPathName(), *UEnum::GetValueAsString(EMassLOD::Type(LODIndex)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn !bIssuesFound;\n}\n\nvoid UMassVisualizationTrait::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)\n{\n\tstatic const FName ParamsName = GET_MEMBER_NAME_CHECKED(UMassVisualizationTrait, Params);\n\tstatic const FName StaticMeshDescriptionName = GET_MEMBER_NAME_CHECKED(UMassVisualizationTrait, StaticMeshInstanceDesc);\n\n\tSuper::PostEditChangeProperty(PropertyChangedEvent);\n\n\tif (PropertyChangedEvent.MemberProperty)\n\t{\n\t\tconst FName PropName = PropertyChangedEvent.MemberProperty->GetFName();\n\t\tif (PropName == ParamsName || PropName == StaticMeshDescriptionName)\n\t\t{\n\t\t\tValidateParams();\n\t\t}\n\t}\n}\n\n#endif // WITH_EDITOR\n\n#undef LOCTEXT_NAMESPACE \n",
      "lines": 224
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\Private\\MassVisualizer.cpp",
      "extension": ".cpp",
      "size_bytes": 587,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassVisualizer.h\"\n#include \"MassVisualizationComponent.h\"\n\nAMassVisualizer::AMassVisualizer()\n{\n\tRootComponent = CreateDefaultSubobject<USceneComponent>(TEXT(\"SceneComp\"));\n\tRootComponent->SetMobility(EComponentMobility::Static);\n\tVisComponent = CreateDefaultSubobject<UMassVisualizationComponent>(TEXT(\"VisualizerComponent\"));\n\n\t// MassVisualizers are created by the subsystems and should not be exposed to users or allowed to be deleted.\n#if WITH_EDITORONLY_DATA\n\tbListedInSceneOutliner = false;\n#endif\n}\n\n",
      "lines": 17
    },
    {
      "file_path": "MassGameplay\\MassSignals\\Private\\MassSignalProcessorBase.cpp",
      "extension": ".cpp",
      "size_bytes": 5365,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSignalProcessorBase.h\"\n#include \"MassSignalSubsystem.h\"\n#include \"MassArchetypeTypes.h\"\n#include \"MassExecutionContext.h\"\n#include \"Engine/World.h\"\n#include \"Misc/ScopeLock.h\"\n\n\nUMassSignalProcessorBase::UMassSignalProcessorBase(const FObjectInitializer& ObjectInitializer)\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n}\n\nvoid UMassSignalProcessorBase::BeginDestroy()\n{\n\tif (UMassSignalSubsystem* SignalSubsystem = UWorld::GetSubsystem<UMassSignalSubsystem>(GetWorld()))\n\t{\n\t\tfor (const FName& SignalName : RegisteredSignals)\n\t\t{\n\t\t\tSignalSubsystem->GetSignalDelegateByName(SignalName).RemoveAll(this);\n\t\t}\n\t}\n\n\tSuper::BeginDestroy();\n}\n\nvoid UMassSignalProcessorBase::SubscribeToSignal(UMassSignalSubsystem& SignalSubsystem, const FName SignalName)\n{\n\tcheck(!RegisteredSignals.Contains(SignalName));\n\tRegisteredSignals.Add(SignalName);\n\tSignalSubsystem.GetSignalDelegateByName(SignalName).AddUObject(this, &UMassSignalProcessorBase::OnSignalReceived);\n}\n\nvoid UMassSignalProcessorBase::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tQUICK_SCOPE_CYCLE_COUNTER(SignalEntities);\n\n\tconst int32 ProcessingFrameBufferIndex = CurrentFrameBufferIndex;\n\t{\n\t\t// we only need to lock the part where we change the current buffer index. Once that's done the incoming signals will end up \n\t\t// in the other buffer\n\t\tUE::TScopeLock<UE::FSpinLock> ScopeLock(ReceivedSignalLock);\n\t\tCurrentFrameBufferIndex = (CurrentFrameBufferIndex + 1) % BuffersCount;\n\t}\n\t\n\tFFrameReceivedSignals& ProcessingFrameBuffer = FrameReceivedSignals[ProcessingFrameBufferIndex];\n\tTArray<FEntitySignalRange>& ReceivedSignalRanges = ProcessingFrameBuffer.ReceivedSignalRanges;\n\tTArray<FMassEntityHandle>& SignaledEntities = ProcessingFrameBuffer.SignaledEntities;\n\n\tif (ReceivedSignalRanges.IsEmpty())\n\t{\n\t\treturn;\n\t}\n\n\tTArray<FMassArchetypeHandle> ValidArchetypes;\n\tGetArchetypesMatchingOwnedQueries(EntityManager, ValidArchetypes);\n\n\tif (ValidArchetypes.Num() > 0)\n\t{\n\t\t// EntitySet stores unique array of entities per specified archetype.\n\t\t// FMassArchetypeEntityCollection expects an array of entities, a set is used to detect unique ones.\n\t\tstruct FEntitySet\n\t\t{\n\t\t\tvoid Reset()\n\t\t\t{\n\t\t\t\tEntities.Reset();\n\t\t\t}\n\n\t\t\tFMassArchetypeHandle Archetype;\n\t\t\tTArray<FMassEntityHandle> Entities;\n\t\t};\n\t\tTArray<FEntitySet> EntitySets;\n\n\t\tfor (const FMassArchetypeHandle& Archetype : ValidArchetypes)\n\t\t{\n\t\t\tFEntitySet& Set = EntitySets.AddDefaulted_GetRef();\n\t\t\tSet.Archetype = Archetype;\n\t\t}\n\n\t\t// SignalNameLookup has limit of how many signals it can handle at once, we'll do passes until all signals are processed.\n\t\tint32 SignalsToProcess = ReceivedSignalRanges.Num();\n\t\twhile(SignalsToProcess > 0)\n\t\t{\n\t\t\tSignalNameLookup.Reset();\n\n\t\t\t// Convert signals with entity ids into arrays of entities per archetype.\n\t\t\tfor (FEntitySignalRange& Range : ReceivedSignalRanges)\n\t\t\t{\n\t\t\t\tif (Range.bProcessed)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Get bitflag for the signal name\n\t\t\t\tconst uint64 SignalFlag = SignalNameLookup.GetOrAddSignalName(Range.SignalName);\n\t\t\t\tif (SignalFlag == 0)\n\t\t\t\t{\n\t\t\t\t\t// Will process that signal in a second iteration\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Entities for this signal\n\t\t\t\tTArrayView<FMassEntityHandle> Entities(&SignaledEntities[Range.Begin], Range.End - Range.Begin);\n\t\t\t\tFEntitySet* PrevSet = &EntitySets[0];\n\t\t\t\tfor (const FMassEntityHandle Entity : Entities)\n\t\t\t\t{\n\t\t\t\t\t// Add to set of supported archetypes. Dont process if we don't care about the type.\n\t\t\t\t\tFMassArchetypeHandle Archetype = EntityManager.GetArchetypeForEntity(Entity);\n\t\t\t\t\tFEntitySet* Set = PrevSet->Archetype == Archetype ? PrevSet : EntitySets.FindByPredicate([&Archetype](const FEntitySet& Set) { return Archetype == Set.Archetype; });\n\t\t\t\t\tif (Set != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\t// We don't care about duplicates here, the FMassArchetypeEntityCollection creation below will handle it\n\t\t\t\t\t\tSet->Entities.Add(Entity);\n\t\t\t\t\t\tSignalNameLookup.AddSignalToEntity(Entity, SignalFlag);\n\t\t\t\t\t\tPrevSet = Set;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tRange.bProcessed = true;\n\t\t\t\tSignalsToProcess--;\n\t\t\t}\n\n\t\t\t// Execute per archetype.\n\t\t\tfor (FEntitySet& Set : EntitySets)\n\t\t\t{\n\t\t\t\tif (Set.Entities.Num() > 0)\n\t\t\t\t{\n\t\t\t\t\tContext.SetEntityCollection(FMassArchetypeEntityCollection(Set.Archetype, Set.Entities, FMassArchetypeEntityCollection::FoldDuplicates));\n\t\t\t\t\tSignalEntities(EntityManager, Context, SignalNameLookup);\n\t\t\t\t\tContext.ClearEntityCollection();\n\t\t\t\t}\n\t\t\t\tSet.Reset();\n\t\t\t}\n\t\t}\n\t}\n\n\tReceivedSignalRanges.Reset();\n\tSignaledEntities.Reset();\n}\n\nvoid UMassSignalProcessorBase::OnSignalReceived(FName SignalName, TConstArrayView<FMassEntityHandle> Entities)\n{\n\tFEntitySignalRange Range;\n\tRange.SignalName = SignalName;\n\n\tUE::TScopeLock<UE::FSpinLock> ScopeLock(ReceivedSignalLock);\n\n\tFFrameReceivedSignals& CurrentFrameBuffer = FrameReceivedSignals[CurrentFrameBufferIndex];\n\n\tRange.Begin = CurrentFrameBuffer.SignaledEntities.Num();\n\tCurrentFrameBuffer.SignaledEntities.Append(Entities.GetData(), Entities.Num());\n\tRange.End = CurrentFrameBuffer.SignaledEntities.Num();\n\tCurrentFrameBuffer.ReceivedSignalRanges.Add(MoveTemp(Range));\n}\n",
      "lines": 156
    },
    {
      "file_path": "MassGameplay\\MassSignals\\Private\\MassSignalsModule.cpp",
      "extension": ".cpp",
      "size_bytes": 837,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CoreMinimal.h\"\n#include \"MassSignalTypes.h\"\n#include \"IMassSignalsModule.h\"\n\nDEFINE_LOG_CATEGORY(LogMassSignals)\n\n\nclass FMassSignalsModule : public IMassSignalsModule\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nIMPLEMENT_MODULE(FMassSignalsModule, MassSignals)\n\n\n\nvoid FMassSignalsModule::StartupModule()\n{\n\t// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)\n}\n\n\nvoid FMassSignalsModule::ShutdownModule()\n{\n\t// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n\t// we call this function before unloading the module.\n}\n\n\n\n",
      "lines": 34
    },
    {
      "file_path": "MassGameplay\\MassSignals\\Private\\MassSignalSubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 5898,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSignalSubsystem.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassCommandBuffer.h\"\n#include \"MassSignalTypes.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"ProfilingDebugging/CsvProfiler.h\"\n#include \"Engine/World.h\"\n\nCSV_DEFINE_CATEGORY(MassSignalsCounters, true);\n\nvoid UMassSignalSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tSuper::Initialize(Collection);\n\tCachedWorld = &GetWorldRef();\n\tcheckf(CachedWorld, TEXT(\"UMassSignalSubsystem instances are expected to always be tied to a valid UWorld instance\"));\n}\n\nvoid UMassSignalSubsystem::Deinitialize()\n{\n\tCachedWorld = nullptr;\n\tSuper::Deinitialize();\n}\n\nvoid UMassSignalSubsystem::Tick(float DeltaTime)\n{\n\tCA_ASSUME(CachedWorld);\n\tconst double CurrentTime = CachedWorld->GetTimeSeconds();\n\n\tfor (int i = 0; i < DelayedSignals.Num();)\n\t{\n\t\tFDelayedSignal& DelayedSignal = DelayedSignals[i];\n\t\tif (DelayedSignal.TargetTimestamp <= CurrentTime)\n\t\t{\n\t\t\tSignalEntities(DelayedSignal.SignalName, MakeArrayView(DelayedSignal.Entities));\n\t\t\tDelayedSignals.RemoveAtSwap(i, EAllowShrinking::No);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n}\n\nTStatId UMassSignalSubsystem::GetStatId() const\n{\n\tRETURN_QUICK_DECLARE_CYCLE_STAT(UMassSignalSubsystem, STATGROUP_Tickables);\n}\n\nvoid UMassSignalSubsystem::SignalEntity(FName SignalName, const FMassEntityHandle Entity)\n{\n\tcheckf(Entity.IsSet(), TEXT(\"Expecting a valid entity to signal\"));\n\tSignalEntities(SignalName, MakeArrayView(&Entity, 1));\n}\n\nvoid UMassSignalSubsystem::SignalEntities(FName SignalName, TConstArrayView<FMassEntityHandle> Entities)\n{\n\tcheckf(Entities.Num() > 0, TEXT(\"Expecting entities to signal\"));\n\tconst UE::MassSignal::FSignalDelegate& SignalDelegate = GetSignalDelegateByName(SignalName);\n\tSignalDelegate.Broadcast(SignalName, Entities);\n\n#if CSV_PROFILER_STATS\n\tFCsvProfiler::RecordCustomStat(*SignalName.ToString(), CSV_CATEGORY_INDEX(MassSignalsCounters), Entities.Num(), ECsvCustomStatOp::Accumulate);\n#endif\n\n\tUE_CVLOG(Entities.Num() == 1, this, LogMassSignals, Log, TEXT(\"Raising signal [%s] to entity [%s]\"), *SignalName.ToString(), *Entities[0].DebugGetDescription());\n\tUE_CVLOG(Entities.Num() > 1, this, LogMassSignals, Log, TEXT(\"Raising signal [%s] to %d entities\"), *SignalName.ToString(), Entities.Num());\n}\n\nvoid UMassSignalSubsystem::DelaySignalEntity(FName SignalName, const FMassEntityHandle Entity, const float DelayInSeconds)\n{\n\tcheckf(Entity.IsSet(), TEXT(\"Expecting a valid entity to signal\"));\n\tDelaySignalEntities(SignalName, MakeArrayView(&Entity, 1), DelayInSeconds);\n}\n\nvoid UMassSignalSubsystem::DelaySignalEntities(FName SignalName, TConstArrayView<FMassEntityHandle> Entities, const float DelayInSeconds)\n{\n\tFDelayedSignal& DelayedSignal = DelayedSignals.Emplace_GetRef();\n\tDelayedSignal.SignalName = SignalName;\n\tDelayedSignal.Entities = Entities;\n\n\tcheck(CachedWorld);\n\tDelayedSignal.TargetTimestamp = CachedWorld->GetTimeSeconds() + DelayInSeconds;\n\n\tUE_CVLOG(Entities.Num() == 1, this, LogMassSignals, Log, TEXT(\"Delay signal [%s] to entity [%s] in %.2f\"), *SignalName.ToString(), *Entities[0].DebugGetDescription(), DelayInSeconds);\n\tUE_CVLOG(Entities.Num() > 1,this, LogMassSignals, Log, TEXT(\"Delay signal [%s] to %d entities in %.2f\"), *SignalName.ToString(), Entities.Num(), DelayInSeconds);\n}\n\nvoid UMassSignalSubsystem::SignalEntityDeferred(FMassExecutionContext& Context, FName SignalName, const FMassEntityHandle Entity)\n{\n\tcheckf(Entity.IsSet(), TEXT(\"Expecting a valid entity to signal\"));\n\tSignalEntitiesDeferred(Context, SignalName, MakeArrayView(&Entity, 1));\n}\n\nvoid UMassSignalSubsystem::SignalEntitiesDeferred(FMassExecutionContext& Context, FName SignalName, TConstArrayView<FMassEntityHandle> Entities)\n{\n\tcheckf(Entities.Num() > 0, TEXT(\"Expecting entities to signal\"));\n\tContext.Defer().PushCommand<FMassDeferredSetCommand>([SignalName, InEntities = TArray<FMassEntityHandle>(Entities)](const FMassEntityManager& System)\n\t{\n\t\tUMassSignalSubsystem* SignalSubsystem = UWorld::GetSubsystem<UMassSignalSubsystem>(System.GetWorld());\n\t\tSignalSubsystem->SignalEntities(SignalName, InEntities);\n\t});\n\n\tUE_CVLOG(Entities.Num() == 1, this, LogMassSignals, Log, TEXT(\"Raising deferred signal [%s] to entity [%s]\"), *SignalName.ToString(), *Entities[0].DebugGetDescription());\n\tUE_CVLOG(Entities.Num() > 1, this, LogMassSignals, Log, TEXT(\"Raising deferred signal [%s] to %d entities\"), *SignalName.ToString(), Entities.Num());\n}\n\nvoid UMassSignalSubsystem::DelaySignalEntityDeferred(FMassExecutionContext& Context, FName SignalName, const FMassEntityHandle Entity, const float DelayInSeconds)\n{\n\tcheckf(Entity.IsSet(), TEXT(\"Expecting a valid entity to signal\"));\n\tDelaySignalEntitiesDeferred(Context, SignalName, MakeArrayView(&Entity, 1), DelayInSeconds);\n}\n\nvoid UMassSignalSubsystem::DelaySignalEntitiesDeferred(FMassExecutionContext& Context, FName SignalName, TConstArrayView<FMassEntityHandle> Entities, const float DelayInSeconds)\n{\n\tcheckf(Entities.Num() > 0, TEXT(\"Expecting entities to signal\"));\n\tContext.Defer().PushCommand<FMassDeferredSetCommand>([SignalName, InEntities = TArray<FMassEntityHandle>(Entities), DelayInSeconds](const FMassEntityManager& System)\n\t{\n\t\tUMassSignalSubsystem* SignalSubsystem = UWorld::GetSubsystem<UMassSignalSubsystem>(System.GetWorld());\n\t\tSignalSubsystem->DelaySignalEntities(SignalName, InEntities, DelayInSeconds);\n\t});\n\n\tUE_CVLOG(Entities.Num() == 1, this, LogMassSignals, Log, TEXT(\"Delay deferred signal [%s] to entity [%s] in %.2f\"), *SignalName.ToString(), *Entities[0].DebugGetDescription(), DelayInSeconds);\n\tUE_CVLOG(Entities.Num() > 1,this, LogMassSignals, Log, TEXT(\"Delay deferred signal [%s] to %d entities in %.2f\"), *SignalName.ToString(), Entities.Num(), DelayInSeconds);\n}\n",
      "lines": 126
    },
    {
      "file_path": "MassGameplay\\MassSignals\\Private\\MassSignalTypes.cpp",
      "extension": ".cpp",
      "size_bytes": 1214,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSignalTypes.h\"\n#include \"MassEntityManager.h\"\n\nuint64 FMassSignalNameLookup::GetOrAddSignalName(const FName SignalName)\n{\n\tint32 Index = SignalNames.Find(SignalName);\n\tif (Index == INDEX_NONE)\n\t{\n\t\tif (SignalNames.Num() >= MaxSignalNames)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tIndex = SignalNames.Add(SignalName);\n\t}\n\treturn 1ULL << Index;\n}\n\nvoid FMassSignalNameLookup::AddSignalToEntity(const FMassEntityHandle Entity, const uint64 SignalFlag)\n{\n\tuint64& Signals = EntitySignals.FindOrAdd(Entity, 0);\n\tSignals |= SignalFlag;\n}\n\nvoid FMassSignalNameLookup::GetSignalsForEntity(const FMassEntityHandle Entity, TArray<FName>& OutSignals) const\n{\n\tOutSignals.Reset();\n\tif (const uint64* Signals = EntitySignals.Find(Entity))\n\t{\n\t\tconst uint64 Start = FMath::CountTrailingZeros64(*Signals);\n\t\tconst uint64 End = FMath::CountLeadingZeros64(*Signals);\n\t\tfor (uint64 i = Start; i < 64 - End; i++)\n\t\t{\n\t\t\tconst uint64 SignalFlag = 1ULL << i;\n\t\t\tif ((*Signals) & SignalFlag)\n\t\t\t{\n\t\t\t\tOutSignals.Add(SignalNames[(uint32)i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid FMassSignalNameLookup::Reset()\n{\n\tSignalNames.Reset();\n\tEntitySignals.Reset();\n}",
      "lines": 48
    },
    {
      "file_path": "MassGameplay\\MassSimulation\\Private\\MassSimulationModule.cpp",
      "extension": ".cpp",
      "size_bytes": 789,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CoreMinimal.h\"\n#include \"IMassSimulationModule.h\"\n\n\nclass FMassSimulationModule : public IMassSimulationModule\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nIMPLEMENT_MODULE(FMassSimulationModule, MassSimulation)\n\n\n\nvoid FMassSimulationModule::StartupModule()\n{\n\t// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)\n}\n\n\nvoid FMassSimulationModule::ShutdownModule()\n{\n\t// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n\t// we call this function before unloading the module.\n}\n\n\n\n",
      "lines": 31
    },
    {
      "file_path": "MassGameplay\\MassSimulation\\Private\\MassSimulationSubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 8632,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSimulationSubsystem.h\"\n#include \"MassEntityManager.h\"\n#include \"MassEntitySubsystem.h\"\n#include \"MassExecutor.h\"\n#include \"MassSimulationSettings.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassEntitySettings.h\"\n#include \"Engine/Engine.h\"\n#if WITH_EDITOR\n#include \"Editor.h\"\n#endif // WITH_EDITOR\n\nDEFINE_LOG_CATEGORY(LogMassSim);\n\nnamespace UE::Mass::Simulation\n{\n\tbool bDoEntityCompaction = true;\n\tbool bSimulationTickingEnabled = true;\n\n\tnamespace Private\n\t{\n\tFAutoConsoleVariableRef CVars[] = {\n\t\t{TEXT(\"mass.EntityCompaction\"), bDoEntityCompaction, TEXT(\"Maximize the number of entities per chunk\"), ECVF_Cheat}\n\t\t, {TEXT(\"mass.SimulationTickingEnabled\"), bSimulationTickingEnabled, TEXT(\"Controls whether Mass simulation ticking is allowed in game worlds. Upon changing the value it also stops/starts Mass simulation ticking, if needed\"), \n\t\t\tFConsoleVariableDelegate::CreateStatic(UMassSimulationSubsystem::HandleSimulationTickingEnabledCVarChange)}\n\t\t};\n\t}\n}\n\n//----------------------------------------------------------------------//\n// UMassSimulationSubsystem\n//----------------------------------------------------------------------//\nUMassSimulationSubsystem::UMassSimulationSubsystem(const FObjectInitializer& ObjectInitializer)\n\t: Super()\n{\n}\n\nvoid UMassSimulationSubsystem::BeginDestroy()\n{\n#if WITH_EDITOR\n\tif (PieBeginEventHandle.IsValid())\n\t{\n\t\tFEditorDelegates::BeginPIE.Remove(PieBeginEventHandle);\n\t}\n\tif (PieEndedEventHandle.IsValid())\n\t{\n\t\tFEditorDelegates::PrePIEEnded.Remove(PieEndedEventHandle);\n\t}\n\tif (MassEntitySettingsChangeHandle.IsValid())\n\t{\n\t\tif (UMassEntitySettings* Settings = GetMutableDefault<UMassEntitySettings>())\n\t\t{\n\t\t\tSettings->GetOnSettingsChange().Remove(MassEntitySettingsChangeHandle);\n\t\t}\n\t}\n#endif //  WITH_EDITOR\n\n\tif (bSimulationStarted)\n\t{\n\t\tcheck(EntityManager);\n\t\tStopSimulation();\n\t}\n\n\tSuper::BeginDestroy();\n}\n\nFMassProcessingPhase::FOnPhaseEvent& UMassSimulationSubsystem::GetOnProcessingPhaseStarted(const EMassProcessingPhase Phase)\n{\n\treturn PhaseManager.GetOnPhaseStart(Phase);\n}\n\nFMassProcessingPhase::FOnPhaseEvent& UMassSimulationSubsystem::GetOnProcessingPhaseFinished(const EMassProcessingPhase Phase)\n{\n\treturn PhaseManager.GetOnPhaseEnd(Phase);\n}\n\nbool UMassSimulationSubsystem::IsDuringMassProcessing() const \n{\n\treturn EntityManager.IsValid() && EntityManager->IsProcessing();\n}\n\nvoid UMassSimulationSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tSuper::Initialize(Collection);\n\n\tUMassEntitySubsystem* EntitySubsystem = Collection.InitializeDependency<UMassEntitySubsystem>();\n\tcheck(EntitySubsystem);\n\tEntityManager = EntitySubsystem->GetMutableEntityManager().AsShared();\n\t\n\tGetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).AddUObject(this, &UMassSimulationSubsystem::OnProcessingPhaseStarted, EMassProcessingPhase::PrePhysics);\n\n\tHandleLateCreation();\n}\n\nvoid UMassSimulationSubsystem::Deinitialize()\n{\n\tGetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).RemoveAll(this);\n\tStopSimulation();\n\n\tPhaseManager.Deinitialize();\n\tEntityManager.Reset();\n\n\tSuper::Deinitialize();\n}\n\nvoid UMassSimulationSubsystem::PostInitialize()\n{\n\tSuper::PostInitialize();\n\n#if WITH_EDITOR\n\tUWorld* World = GetWorld();\n\tif (GEditor && World != nullptr && !World->IsGameWorld())\n\t{\n\t\t// in editor worlds we need to rebuild the pipeline at this point since OnWorldBeginPlay won't be called\n\t\tRebuildTickPipeline();\n\n\t\tPieBeginEventHandle = FEditorDelegates::BeginPIE.AddUObject(this, &UMassSimulationSubsystem::OnPieBegin);\n\t\tPieEndedEventHandle = FEditorDelegates::PrePIEEnded.AddUObject(this, &UMassSimulationSubsystem::OnPieEnded);\n\n\t\tUMassEntitySettings* Settings = GetMutableDefault<UMassEntitySettings>();\n\t\tcheck(Settings);\n\t\tMassEntitySettingsChangeHandle = Settings->GetOnSettingsChange().AddUObject(this, &UMassSimulationSubsystem::OnMassEntitySettingsChange);\n\n\t\t// note that this starts ticking for the editor world\n\t\tStartSimulation(*World);\n\t}\n#endif // WITH_EDITOR\n}\n\nvoid UMassSimulationSubsystem::OnWorldBeginPlay(UWorld& InWorld)\n{\n\tSuper::OnWorldBeginPlay(InWorld);\n\n\t// To evaluate the effective processors execution mode, we need to wait on OnWorldBeginPlay before calling\n\t// RebuildTickPipeline as we are sure by this time the network is setup correctly.\n\tRebuildTickPipeline();\n\t// note that since we're in this function we're tied to a game world. This means the StartSimulation in \n\t// PostInitialize haven't been called.\n\tStartSimulation(InWorld);\n}\n\nvoid UMassSimulationSubsystem::RegisterDynamicProcessor(UMassProcessor& Processor)\n{\n\tcheckf(!IsDuringMassProcessing(), TEXT(\"Unable to add dynamic processors to Mass during processing.\"));\n\tPhaseManager.RegisterDynamicProcessor(Processor);\n}\n\nvoid UMassSimulationSubsystem::UnregisterDynamicProcessor(UMassProcessor& Processor)\n{\n\tcheckf(!IsDuringMassProcessing(), TEXT(\"Unable to remove dynamic processors to Mass during processing.\"));\n\tPhaseManager.UnregisterDynamicProcessor(Processor);\n}\n\nvoid UMassSimulationSubsystem::HandleSimulationTickingEnabledCVarChange(IConsoleVariable*)\n{\n\tif (GEngine == nullptr)\n\t{\n\t\treturn;\n\t}\n\n\tfor (const FWorldContext& Context : GEngine->GetWorldContexts())\n\t{\n\t\tif (Context.WorldType != EWorldType::Inactive)\n\t\t{\n\t\t\tUWorld* World = Context.World();\n\t\t\t\n\t\t\t// we only want to affect game worlds\n\t\t\tif (World == nullptr || World->IsGameWorld() == false)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (UMassSimulationSubsystem* MassSimulationSubsystem = UWorld::GetSubsystem<UMassSimulationSubsystem>(World))\n\t\t\t{\n\t\t\t\tif (UE::Mass::Simulation::bSimulationTickingEnabled)\n\t\t\t\t{\n\t\t\t\t\t// if enabling call StartSimulation ony if the world has already begun play. Otherwise the \n\t\t\t\t\t// simulation ticking will be started at the right time automatically\n\t\t\t\t\tif (World->HasBegunPlay())\n\t\t\t\t\t{\n\t\t\t\t\t\tMassSimulationSubsystem->StartSimulation(*World);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tMassSimulationSubsystem->StopSimulation();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid UMassSimulationSubsystem::RebuildTickPipeline()\n{\n\tTConstArrayView<FMassProcessingPhaseConfig> ProcessingPhasesConfig = GET_MASS_CONFIG_VALUE(GetProcessingPhasesConfig());\n\tFString DependencyGraphFileName;\n\n#if WITH_EDITOR\n\tconst UWorld* World = GetWorld();\n\tconst UMassEntitySettings* Settings = GetMutableDefault<UMassEntitySettings>();\n\tif (World != nullptr && Settings != nullptr && !Settings->DumpDependencyGraphFileName.IsEmpty())\n\t{\n\t\tDependencyGraphFileName = FString::Printf(TEXT(\"%s_%s\"), *Settings->DumpDependencyGraphFileName, *ToString(World->GetNetMode()));\n\t}\n#endif // WITH_EDITOR\n\n\tPhaseManager.Initialize(*this, ProcessingPhasesConfig, DependencyGraphFileName);\n}\n\nvoid UMassSimulationSubsystem::StartSimulation(UWorld& InWorld)\n{\n\tif (bSimulationStarted)\n\t{\n\t\treturn;\n\t}\n\n\tif (UE::Mass::Simulation::bSimulationTickingEnabled)\n\t{\n\t\tPhaseManager.Start(InWorld);\n\n\t\tbSimulationStarted = true;\n\n\t\tOnSimulationStarted.Broadcast(&InWorld);\n\t}\n}\n\nvoid UMassSimulationSubsystem::StopSimulation()\n{\n\tif (bSimulationStarted == false)\n\t{\n\t\treturn;\n\t}\n\n\tPhaseManager.Stop();\n\n\tbSimulationStarted = false;\n}\n\nvoid UMassSimulationSubsystem::OnProcessingPhaseStarted(const float DeltaSeconds, const EMassProcessingPhase Phase) const\n{\n\tswitch (Phase)\n\t{\n\t\tcase EMassProcessingPhase::PrePhysics:\n\t\t\t{\n\t\t\t\tif (UE::Mass::Simulation::bDoEntityCompaction && GET_MASSSIMULATION_CONFIG_VALUE(bEntityCompactionEnabled))\n\t\t\t\t{\n\t\t\t\t\tTRACE_CPUPROFILER_EVENT_SCOPE(DoEntityCompaction);\n\t\t\t\t\tcheck(EntityManager);\n\t\t\t\t\tEntityManager->DoEntityCompaction(GET_MASSSIMULATION_CONFIG_VALUE(DesiredEntityCompactionTimeSlicePerTick));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// unhandled phases, by design, not every phase needs to be handled by the Actor subsystem\n\t\t\tbreak;\n\t}\n}\n\n\n#if WITH_EDITOR\nvoid UMassSimulationSubsystem::OnPieBegin(const bool bIsSimulation)\n{\n\t// called so that we're not processing phases for the editor world while PIE/SIE is running\n\tStopSimulation();\n}\n\nvoid UMassSimulationSubsystem::OnPieEnded(const bool bIsSimulation)\n{\n\tUWorld* World = GetWorld();\n\tif (World && !bSimulationStarted)\n\t{\n\t\t// Resume processing phases in the editor world.\n\t\tStartSimulation(*World);\n\t}\n}\n\nvoid UMassSimulationSubsystem::OnMassEntitySettingsChange(const FPropertyChangedEvent& PropertyChangedEvent)\n{\n\tRebuildTickPipeline();\n}\n#endif // WITH_EDITOR",
      "lines": 283
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Private\\MassSmartObjectBehaviorDefinition.cpp",
      "extension": ".cpp",
      "size_bytes": 814,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSmartObjectBehaviorDefinition.h\"\n\n#include \"MassCommandBuffer.h\"\n#include \"MassSmartObjectFragments.h\"\n\nvoid USmartObjectMassBehaviorDefinition::Activate(FMassCommandBuffer& CommandBuffer, const FMassBehaviorEntityContext& EntityContext) const\n{\n\tFMassSmartObjectTimedBehaviorFragment TimedBehaviorFragment;\n\tTimedBehaviorFragment.UseTime = UseTime;\n\tCommandBuffer.PushCommand<FMassCommandAddFragmentInstances>(EntityContext.EntityView.GetEntity(), TimedBehaviorFragment);\n}\n\nvoid USmartObjectMassBehaviorDefinition::Deactivate(FMassCommandBuffer& CommandBuffer, const FMassBehaviorEntityContext& EntityContext) const\n{\n\tCommandBuffer.RemoveFragment<FMassSmartObjectTimedBehaviorFragment>(EntityContext.EntityView.GetEntity());\n}\n",
      "lines": 18
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Private\\MassSmartObjectHandler.cpp",
      "extension": ".cpp",
      "size_bytes": 12200,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSmartObjectHandler.h\"\n#include \"MassSmartObjectBehaviorDefinition.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassExecutionContext.h\"\n#include \"SmartObjectSubsystem.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassCommandBuffer.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassSignalSubsystem.h\"\n#include \"MassSmartObjectFragments.h\"\n#include \"Engine/World.h\"\n#include \"MassDebugger.h\"\n\n\nnamespace UE::Mass::SmartObject\n{\n\tvoid StopInteraction(FMassCommandBuffer& CommandBuffer, const FMassBehaviorEntityContext& Context, const FSmartObjectClaimHandle& ClaimHandle, const EMassSmartObjectInteractionStatus NewStatus)\n\t{\n\t\tFMassSmartObjectUserFragment& User = Context.EntityView.GetFragmentData<FMassSmartObjectUserFragment>();\n\t\tif ( User.InteractionHandle == ClaimHandle)\n\t\t{\n\t\t\tif (User.InteractionStatus == EMassSmartObjectInteractionStatus::InProgress ||\n\t\t\t\tUser.InteractionStatus == EMassSmartObjectInteractionStatus::BehaviorCompleted)\n\t\t\t{\n\t\t\t\tif (const USmartObjectMassBehaviorDefinition* BehaviorDefinition = Context.SmartObjectSubsystem.GetBehaviorDefinition<USmartObjectMassBehaviorDefinition>(User.InteractionHandle))\n\t\t\t\t{\n\t\t\t\t\tBehaviorDefinition->Deactivate(CommandBuffer, Context);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUser.InteractionStatus = NewStatus;\n\t\t\tUser.InteractionHandle.Invalidate();\n\t\t}\n\t}\n\n\tstruct FPayload\n\t{\n\t\tFMassEntityHandle Entity;\n\t\tTSharedPtr<FMassEntityManager> EntityManager;\n\t\tTWeakObjectPtr<USmartObjectSubsystem> SmartObjectSubsystem;\n\t\tTWeakObjectPtr<UMassSignalSubsystem> SignalSubsystem;\n\t};\n\n\tvoid OnSlotInvalidated(const FSmartObjectClaimHandle& ClaimHandle, const ESmartObjectSlotState State, FPayload Payload)\n\t{\n\t\tUSmartObjectSubsystem* SmartObjectSubsystem = Payload.SmartObjectSubsystem.Get();\n\t\tFMassEntityManager* EntityManager = Payload.EntityManager.Get();\n\t\tUMassSignalSubsystem* SignalSubsystem = Payload.SignalSubsystem.Get();\n\t\tif (SmartObjectSubsystem != nullptr && EntityManager != nullptr && SignalSubsystem != nullptr && EntityManager->IsEntityActive(Payload.Entity))\n\t\t{\n\t\t\tconst FMassEntityView EntityView(*EntityManager, Payload.Entity);\n\t\t\tconst FMassBehaviorEntityContext Context(EntityView, *SmartObjectSubsystem);\n\n\t\t\tStopInteraction(EntityManager->Defer(), Context, ClaimHandle, EMassSmartObjectInteractionStatus::Aborted);\n\t\t\tif (EntityManager->IsProcessing() == false)\n\t\t\t{\n\t\t\t\tEntityManager->FlushCommands();\n\t\t\t}\n\n\t\t\tSignalSubsystem->SignalEntity(UE::Mass::Signals::SmartObjectInteractionAborted, Payload.Entity);\n\t\t}\n\t}\n} // UE::Mass::SmartObject;\n\n//----------------------------------------------------------------------//\n// FMassSmartObjectHandler\n//----------------------------------------------------------------------//\nFMassSmartObjectRequestID FMassSmartObjectHandler::FindCandidatesAsync(const FMassEntityHandle RequestingEntity, const FGameplayTagContainer& UserTags, const FGameplayTagQuery& ActivityRequirements, const FVector& Location) const\n{\n\tconst FMassEntityHandle ReservedEntity = EntityManager.ReserveEntity();\n\n\tFMassSmartObjectWorldLocationRequestFragment RequestFragment;\n\tRequestFragment.SearchOrigin = Location;\n\tRequestFragment.RequestingEntity = RequestingEntity;\n\tRequestFragment.UserTags = UserTags;\n\tRequestFragment.ActivityRequirements = ActivityRequirements;\n\n\tFMassSmartObjectRequestResultFragment ResultFragment;\n\n\tExecutionContext.Defer().PushCommand<FMassCommandAddFragmentInstances>(ReservedEntity, RequestFragment, ResultFragment);\n\n\treturn FMassSmartObjectRequestID(ReservedEntity);\n}\n\nFMassSmartObjectRequestID FMassSmartObjectHandler::FindCandidatesAsync(const FMassEntityHandle RequestingEntity, const FGameplayTagContainer& UserTags, const FGameplayTagQuery& ActivityRequirements, const FZoneGraphCompactLaneLocation& LaneLocation) const\n{\n\tconst FMassEntityHandle ReservedEntity = EntityManager.ReserveEntity();\n\n\tFMassSmartObjectLaneLocationRequestFragment RequestFragment;\n\tRequestFragment.CompactLaneLocation = LaneLocation;\n\tRequestFragment.RequestingEntity = RequestingEntity;\n\tRequestFragment.UserTags = UserTags;\n\tRequestFragment.ActivityRequirements = ActivityRequirements;\n\n\tFMassSmartObjectRequestResultFragment ResultFragment;\n\n\tExecutionContext.Defer().PushCommand<FMassCommandAddFragmentInstances>(ReservedEntity, RequestFragment, ResultFragment);\n\n\treturn FMassSmartObjectRequestID(ReservedEntity);\n}\n\nconst FMassSmartObjectCandidateSlots* FMassSmartObjectHandler::GetRequestCandidates(const FMassSmartObjectRequestID& RequestID) const\n{\n\tconst FMassEntityHandle RequestEntity = static_cast<FMassEntityHandle>(RequestID);\n\tif (!ensureMsgf(EntityManager.IsEntityValid(RequestEntity), TEXT(\"Invalid request.\")))\n\t{\n\t\treturn nullptr;\n\t}\n\n\t// Check if entity is built by now.\n\tif (!EntityManager.IsEntityBuilt(RequestEntity))\n\t{\n\t\treturn nullptr;\n\t}\n\n\tconst FMassSmartObjectRequestResultFragment& RequestFragment = EntityManager.GetFragmentDataChecked<FMassSmartObjectRequestResultFragment>(RequestEntity);\n\n\treturn RequestFragment.bProcessed ? &RequestFragment.Candidates : nullptr;\n}\n\nvoid FMassSmartObjectHandler::RemoveRequest(const FMassSmartObjectRequestID& RequestID) const\n{\n\tconst FMassEntityHandle RequestEntity = static_cast<FMassEntityHandle>(RequestID);\n\tExecutionContext.Defer().DestroyEntity(RequestEntity);\n}\n\nFSmartObjectClaimHandle FMassSmartObjectHandler::ClaimCandidate(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const FMassSmartObjectCandidateSlots& Candidates, ESmartObjectClaimPriority ClaimPriority) const\n{\n\tcheckf(!User.InteractionHandle.IsValid(), TEXT(\"User should not already have an interaction.\"));\n\t\n\tconst TConstArrayView<FSmartObjectCandidateSlot> View = MakeArrayView(Candidates.Slots.GetData(), Candidates.NumSlots);\n\n\tFSmartObjectClaimHandle ClaimedSlot;\n\t\n\tfor (const FSmartObjectCandidateSlot& CandidateSlot : View)\n\t{\n\t\tClaimedSlot = ClaimSmartObject(Entity, User, CandidateSlot.Result, ClaimPriority);  \n\t\tif (ClaimedSlot.IsValid())\n\t\t{\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\t\tUE_CVLOG(UE::Mass::Debug::IsDebuggingEntity(Entity),\n\t\t\t\t&SmartObjectSubsystem,\n\t\t\t\tLogSmartObject,\n\t\t\t\tLog,\n\t\t\t\tTEXT(\"[%s] claimed [%s]\"),\n\t\t\t\t*Entity.DebugGetDescription(),\n\t\t\t\t*LexToString(CandidateSlot.Result));\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ClaimedSlot;\n}\n\nFSmartObjectClaimHandle FMassSmartObjectHandler::ClaimSmartObject(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const FSmartObjectRequestResult& RequestResult, ESmartObjectClaimPriority ClaimPriority) const\n{\n\tconst FSmartObjectClaimHandle ClaimHandle = SmartObjectSubsystem.MarkSlotAsClaimed(RequestResult.SlotHandle, ClaimPriority, FConstStructView::Make(FSmartObjectMassEntityUserData(Entity)));\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\tUE_CVLOG(UE::Mass::Debug::IsDebuggingEntity(Entity),\n\t\t&SmartObjectSubsystem,\n\t\tLogSmartObject,\n\t\tLog,\n\t\tTEXT(\"[%s] claim for [%s] %s\"),\n\t\t*Entity.DebugGetDescription(),\n\t\t*LexToString(RequestResult),\n\t\tClaimHandle.IsValid() ? TEXT(\"Succeeded\") : TEXT(\"Failed\"));\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t// Register callback to abort interaction if slot gets invalidated.\n\t// Callback will be unregistered by UMassSmartObjectUserFragmentDeinitializer\n\tUE::Mass::SmartObject::FPayload Payload;\n\tPayload.Entity = Entity;\n\tPayload.EntityManager = EntityManager.AsShared();\n\tPayload.SmartObjectSubsystem = &SmartObjectSubsystem;\n\tPayload.SignalSubsystem = &SignalSubsystem;\n\tSmartObjectSubsystem.RegisterSlotInvalidationCallback(ClaimHandle, FOnSlotInvalidated::CreateStatic(&UE::Mass::SmartObject::OnSlotInvalidated, Payload));\n\t\n\treturn ClaimHandle;\n}\n\nbool FMassSmartObjectHandler::StartUsingSmartObject(\n\tconst FMassEntityHandle Entity,\n\tFMassSmartObjectUserFragment& User,\n\tconst FSmartObjectClaimHandle ClaimHandle) const\n{\n#if WITH_MASSGAMEPLAY_DEBUG\n\tUE_CVLOG(UE::Mass::Debug::IsDebuggingEntity(Entity),\n\t\t&SmartObjectSubsystem,\n\t\tLogSmartObject,\n\t\tLog,\n\t\tTEXT(\"[%s] starts using [%s]\"),\n\t\t*Entity.DebugGetDescription(),\n\t\t*LexToString(User.InteractionHandle));\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\tconst USmartObjectMassBehaviorDefinition* BehaviorDefinition = SmartObjectSubsystem.MarkSlotAsOccupied<USmartObjectMassBehaviorDefinition>(ClaimHandle);\n\tif (BehaviorDefinition == nullptr)\n\t{\n\t\treturn false;\n\t}\n\n\tUser.InteractionStatus = EMassSmartObjectInteractionStatus::InProgress;\n\tUser.InteractionHandle = ClaimHandle;\n\n\t// Activate behavior\n\tconst FMassEntityView EntityView(EntityManager, Entity);\n\tconst FMassBehaviorEntityContext Context(EntityView, SmartObjectSubsystem);\n\tBehaviorDefinition->Activate(ExecutionContext.Defer(), Context);\n\n\treturn true;\n}\n\n\nvoid FMassSmartObjectHandler::StopUsingSmartObject(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const EMassSmartObjectInteractionStatus NewStatus) const\n{\n#if WITH_MASSGAMEPLAY_DEBUG\n\tUE_CVLOG(UE::Mass::Debug::IsDebuggingEntity(Entity),\n\t\t&SmartObjectSubsystem,\n\t\tLogSmartObject,\n\t\tLog,\n\t\tTEXT(\"[%s] releases handle [%s]\"),\n\t\t*Entity.DebugGetDescription(),\n\t\t*LexToString(User.InteractionHandle));\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n#if DO_ENSURE\n\tconst EMassSmartObjectInteractionStatus CurrentStatus = User.InteractionStatus;\n\n\tswitch (CurrentStatus)\n\t{\n\tcase EMassSmartObjectInteractionStatus::Unset:\n\t\tensureMsgf(NewStatus == EMassSmartObjectInteractionStatus::Unset,\n\t\t\tTEXT(\"Not expecting new status for inactive interaction. Received %s\"),\n\t\t\t*UEnum::GetValueAsString(NewStatus));\n\t\tbreak;\n\n\tcase EMassSmartObjectInteractionStatus::InProgress:\n\t\tensureMsgf(NewStatus == EMassSmartObjectInteractionStatus::BehaviorCompleted\n\t\t\t|| NewStatus == EMassSmartObjectInteractionStatus::TaskCompleted\n\t\t\t|| NewStatus == EMassSmartObjectInteractionStatus::Aborted,\n\t\t\tTEXT(\"Expecting status 'BehaviorCompleted', 'TaskCompleted' or 'Aborted' for in progress interaction. Received %s\"),\n\t\t\t*UEnum::GetValueAsString(NewStatus));\n\t\tbreak;\n\n\tcase EMassSmartObjectInteractionStatus::BehaviorCompleted:\n\t\tensureMsgf(NewStatus == EMassSmartObjectInteractionStatus::TaskCompleted || NewStatus == EMassSmartObjectInteractionStatus::Aborted,\n\t\t\tTEXT(\"Expecting status 'TaskCompleted' or 'Aborted' for 'BehaviorCompleted' interaction. Received %s\"),\n\t\t\t*UEnum::GetValueAsString(NewStatus));\n\t\tbreak;\n\n\tcase EMassSmartObjectInteractionStatus::TaskCompleted:\n\tcase EMassSmartObjectInteractionStatus::Aborted:\n\t\tensureMsgf(false, TEXT(\"Not expecting status changes for'Completed' or 'Aborted' interaction. Current %s - Received %s\"),\n\t\t\t*UEnum::GetValueAsString(CurrentStatus),\n\t\t\t*UEnum::GetValueAsString(NewStatus));\n\t\tbreak;\n\n\tdefault:\n\t\tensureMsgf(false, TEXT(\"Unhandled state: %s\"), *UEnum::GetValueAsString(NewStatus));\n\t}\n#endif\n\n\tconst FMassEntityView EntityView(EntityManager, Entity);\n\tconst FMassBehaviorEntityContext Context(EntityView, SmartObjectSubsystem);\n\tUE::Mass::SmartObject::StopInteraction(ExecutionContext.Defer(), Context, User.InteractionHandle, NewStatus);\n}\n\n\nvoid FMassSmartObjectHandler::ReleaseSmartObject(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const FSmartObjectClaimHandle ClaimHandle) const\n{\n#if WITH_MASSGAMEPLAY_DEBUG\n\tUE_CVLOG(UE::Mass::Debug::IsDebuggingEntity(Entity),\n\t\t&SmartObjectSubsystem,\n\t\tLogSmartObject,\n\t\tLog,\n\t\tTEXT(\"[%s] releases handle [%s]\"),\n\t\t*Entity.DebugGetDescription(),\n\t\t*LexToString(User.InteractionHandle));\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n#if DO_ENSURE\n\tif (User.InteractionStatus == EMassSmartObjectInteractionStatus::InProgress)\n\t{\n\t\tensureMsgf(false, TEXT(\"Expecting interaction to be compled before releasing the SmartObject. Current state %s\"), *UEnum::GetValueAsString(User.InteractionStatus));\n\t}\n#endif\n\n\tconst FMassEntityView EntityView(EntityManager, Entity);\n\tconst FMassBehaviorEntityContext Context(EntityView, SmartObjectSubsystem);\n\n\tSmartObjectSubsystem.UnregisterSlotInvalidationCallback(ClaimHandle);\n\n\tContext.SmartObjectSubsystem.MarkSlotAsFree(ClaimHandle);\n}\n",
      "lines": 298
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Private\\MassSmartObjectProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 20013,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSmartObjectProcessor.h\"\n#include \"MassCommandBuffer.h\"\n#include \"MassCommonTypes.h\"\n#include \"MassDebugger.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassGameplayExternalTraits.h\"\n#include \"MassSignalSubsystem.h\"\n#include \"MassSmartObjectBehaviorDefinition.h\"\n#include \"MassSmartObjectFragments.h\"\n#include \"MassSmartObjectRequest.h\"\n#include \"MassSmartObjectSettings.h\"\n#include \"MassSmartObjectTypes.h\"\n#include \"Misc/ScopeExit.h\"\n#include \"SmartObjectOctree.h\"\n#include \"SmartObjectSubsystem.h\"\n#include \"SmartObjectZoneAnnotations.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"ZoneGraphAnnotationSubsystem.h\"\n#include \"ZoneGraphSubsystem.h\"\n\n\n//----------------------------------------------------------------------//\n// UMassSmartObjectCandidatesFinderProcessor\n//----------------------------------------------------------------------//\nvoid UMassSmartObjectCandidatesFinderProcessor::ConfigureQueries()\n{\n\tWorldRequestQuery.AddRequirement<FMassSmartObjectWorldLocationRequestFragment>(EMassFragmentAccess::ReadOnly);\n\tWorldRequestQuery.AddRequirement<FMassSmartObjectRequestResultFragment>(EMassFragmentAccess::ReadWrite);\n\tWorldRequestQuery.AddTagRequirement<FMassSmartObjectCompletedRequestTag>(EMassFragmentPresence::None);\n\tWorldRequestQuery.AddSubsystemRequirement<USmartObjectSubsystem>(EMassFragmentAccess::ReadOnly);\n\tWorldRequestQuery.RegisterWithProcessor(*this);\n\n\tLaneRequestQuery.AddRequirement<FMassSmartObjectLaneLocationRequestFragment>(EMassFragmentAccess::ReadOnly);\n\tLaneRequestQuery.AddRequirement<FMassSmartObjectRequestResultFragment>(EMassFragmentAccess::ReadWrite);\n\tLaneRequestQuery.AddTagRequirement<FMassSmartObjectCompletedRequestTag>(EMassFragmentPresence::None);\n\tLaneRequestQuery.AddSubsystemRequirement<UZoneGraphSubsystem>(EMassFragmentAccess::ReadOnly);\n\tLaneRequestQuery.AddSubsystemRequirement<USmartObjectSubsystem>(EMassFragmentAccess::ReadOnly);\n\tLaneRequestQuery.RegisterWithProcessor(*this);\n\n\tProcessorRequirements.AddSubsystemRequirement<UMassSignalSubsystem>(EMassFragmentAccess::ReadWrite);\n\tProcessorRequirements.AddSubsystemRequirement<UZoneGraphAnnotationSubsystem>(EMassFragmentAccess::ReadOnly);\n}\n\nUMassSmartObjectCandidatesFinderProcessor::UMassSmartObjectCandidatesFinderProcessor()\n\t: WorldRequestQuery(*this)\n\t, LaneRequestQuery(*this)\n{\n\t// 1. Frame T Behavior create a request(deferred entity creation)\n\t// 2. Frame T+1: Processor execute the request might mark it as done(deferred add tag flushed at the end of the frame)\n\t// 3. Frame T+1: Behavior could cancel request(deferred destroy entity)\n\t// If the processor does not run before the behaviors, step 2 and 3 are flipped and it will crash while flushing the deferred commands\n\tExecutionOrder.ExecuteBefore.Add(UE::Mass::ProcessorGroupNames::Behavior);\n}\n\nvoid UMassSmartObjectCandidatesFinderProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tUMassSignalSubsystem& SignalSubsystem = Context.GetMutableSubsystemChecked<UMassSignalSubsystem>();\n\tconst UZoneGraphAnnotationSubsystem& AnnotationSubsystem = Context.GetSubsystemChecked<UZoneGraphAnnotationSubsystem>();\n\t\n\t// Create filter\n\tFSmartObjectRequestFilter Filter;\n\tFilter.BehaviorDefinitionClasses = { USmartObjectMassBehaviorDefinition::StaticClass() };\n\n\t// Build list of request owner entities to send a completion signal\n\tTArray<FMassEntityHandle> EntitiesToSignal;\n\n\tauto BeginRequestProcessing = [](const FMassEntityHandle Entity, FMassExecutionContext& Context, FMassSmartObjectRequestResultFragment& Result)\n\t{\n\t\tContext.Defer().AddTag<FMassSmartObjectCompletedRequestTag>(Entity);\n\t\tResult.Candidates.NumSlots = 0;\n\t};\n\n\tauto EndRequestProcessing = [](const UObject* LogOwner, const FMassEntityHandle Entity, FMassSmartObjectRequestResultFragment& Result)\n\t{\n\t\tif (Result.Candidates.NumSlots > 0)\n\t\t{\n\t\t\tTArrayView<FSmartObjectCandidateSlot> View = MakeArrayView(Result.Candidates.Slots.GetData(), Result.Candidates.NumSlots);\n\t\t\tAlgo::Sort(View, [](const FSmartObjectCandidateSlot& LHS, const FSmartObjectCandidateSlot& RHS) { return LHS.Cost < RHS.Cost; });\n\t\t}\n\t\tResult.bProcessed = true;\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\tUE_VLOG(LogOwner, LogSmartObject, Verbose, TEXT(\"[%s] search completed: found %d\"), *Entity.DebugGetDescription(), Result.Candidates.NumSlots);\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t};\n\n\t// Process world location based requests\n\tWorldRequestQuery.ForEachEntityChunk(EntityManager, Context, [this, &Filter, &EntitiesToSignal, &BeginRequestProcessing, &EndRequestProcessing](FMassExecutionContext& Context)\n\t{\n\t\tconst USmartObjectSubsystem& SmartObjectSubsystem = Context.GetSubsystemChecked<USmartObjectSubsystem>();\n\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tEntitiesToSignal.Reserve(EntitiesToSignal.Num() + NumEntities);\n\n\t\tconst TConstArrayView<FMassSmartObjectWorldLocationRequestFragment> RequestList = Context.GetFragmentView<FMassSmartObjectWorldLocationRequestFragment>();\n\t\tconst TArrayView<FMassSmartObjectRequestResultFragment> ResultList = Context.GetMutableFragmentView<FMassSmartObjectRequestResultFragment>();\n\n\t\tTArray<FSmartObjectRequestResult> QueryResults;\n\t\tTArray<FSmartObjectCandidateSlot> SortedCandidateSlots;\n\n\t\tfor (int32 i = 0; i < NumEntities; ++i)\n\t\t{\n\t\t\tconst FMassSmartObjectWorldLocationRequestFragment& RequestFragment = RequestList[i];\n\t\t\tFMassSmartObjectRequestResultFragment& Result = ResultList[i];\n\t\t\t\n\t\t\tEntitiesToSignal.Add(RequestFragment.RequestingEntity);\n\n\t\t\tconst FVector& SearchOrigin = RequestFragment.SearchOrigin;\n\t\t\tconst FBox& SearchBounds = FBox::BuildAABB(SearchOrigin, FVector(SearchExtents));\n\n\t\t\tconst FMassEntityHandle Entity = Context.GetEntity(i);\n\t\t\tbool bDisplayDebug = false;\n\t\t\tFColor DebugColor(FColor::White);\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\t\tbDisplayDebug = UE::Mass::Debug::IsDebuggingEntity(Entity, &DebugColor);\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t\t\tBeginRequestProcessing(Entity, Context, Result);\n\t\t\tON_SCOPE_EXIT{ EndRequestProcessing(&SmartObjectSubsystem, Entity, Result);\t};\n\n\t\t\tFilter.UserTags = RequestFragment.UserTags;\n\t\t\tFilter.ActivityRequirements = RequestFragment.ActivityRequirements;\n\t\t\t\n\t\t\tQueryResults.Reset();\n\t\t\tSmartObjectSubsystem.FindSmartObjects(FSmartObjectRequest(SearchBounds, Filter), QueryResults);\n\n\t\t\tSortedCandidateSlots.Reset(QueryResults.Num());\n\t\t\tfor (const FSmartObjectRequestResult& QueryResult : QueryResults)\n\t\t\t{\n\t\t\t\tconst FVector SlotLocation = SmartObjectSubsystem.GetSlotLocation(QueryResult.SlotHandle).GetValue();\n\t\t\t\tSortedCandidateSlots.Emplace(QueryResult, UE_REAL_TO_FLOAT_CLAMPED_MAX(FVector::DistSquared(SearchOrigin, SlotLocation)));\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\t\t\tif (bDisplayDebug)\n\t\t\t\t{\n\t\t\t\t\tconstexpr uint16 DebugRadius = 10;\n\t\t\t\t\tUE_VLOG_LOCATION(&SmartObjectSubsystem, LogSmartObject, Display, SlotLocation, DebugRadius, DebugColor, TEXT(\"%s\"), *LexToString(QueryResult.SmartObjectHandle));\n\t\t\t\t\tUE_VLOG_SEGMENT(&SmartObjectSubsystem, LogSmartObject, Display, SearchOrigin, SlotLocation, DebugColor, TEXT(\"\"));\n\t\t\t\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t\t\t}\n\t\t\tSortedCandidateSlots.Sort([](const FSmartObjectCandidateSlot& First, const FSmartObjectCandidateSlot& Second){ return First.Cost < Second.Cost; });\n\n\t\t\tResult.Candidates.NumSlots = IntCastChecked<uint8>(FMath::Min(FMassSmartObjectCandidateSlots::MaxNumCandidates, (uint32)SortedCandidateSlots.Num()));\n\t\t\tfor (int ResultIndex = 0; ResultIndex < Result.Candidates.NumSlots; ResultIndex++)\n\t\t\t{\n\t\t\t\tResult.Candidates.Slots[ResultIndex] = SortedCandidateSlots[ResultIndex];\n\t\t\t}\n\t\t}\n\t});\n\n\t// Process lane based requests\n\tconst FZoneGraphTag SmartObjectTag = GetDefault<UMassSmartObjectSettings>()->SmartObjectTag;\n\tUSmartObjectZoneAnnotations* Annotations = Cast<USmartObjectZoneAnnotations>(AnnotationSubsystem.GetFirstAnnotationForTag(SmartObjectTag));\n\n\tLaneRequestQuery.ForEachEntityChunk(EntityManager, Context,\n\t\t[&AnnotationSubsystem, Annotations, &Filter, SmartObjectTag, &EntitiesToSignal, &BeginRequestProcessing, &EndRequestProcessing](FMassExecutionContext& Context)\n\t\t{\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\t\tconst UZoneGraphSubsystem& ZoneGraphSubsystem = Context.GetSubsystemChecked<UZoneGraphSubsystem>();\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t\t\tconst USmartObjectSubsystem& SmartObjectSubsystem = Context.GetSubsystemChecked<USmartObjectSubsystem>();\n\n\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\tEntitiesToSignal.Reserve(EntitiesToSignal.Num() + NumEntities);\n\n\t\t\tTConstArrayView<FMassSmartObjectLaneLocationRequestFragment> RequestList = Context.GetFragmentView<FMassSmartObjectLaneLocationRequestFragment>();\n\t\t\tTArrayView<FMassSmartObjectRequestResultFragment> ResultList = Context.GetMutableFragmentView<FMassSmartObjectRequestResultFragment>();\n\n\t\t\t// Cache latest used data since request are most of the time on the same zone graph\n\t\t\tFZoneGraphDataHandle LastUsedDataHandle;\n\t\t\tconst FSmartObjectAnnotationData* GraphData = nullptr;\n\n\t\t\tfor (int32 i = 0; i < NumEntities; ++i)\n\t\t\t{\n\t\t\t\tconst FMassSmartObjectLaneLocationRequestFragment& RequestFragment = RequestList[i];\n\t\t\t\tFMassSmartObjectRequestResultFragment& Result = ResultList[i];\n\t\t\t\t\n\t\t\t\tEntitiesToSignal.Add(RequestFragment.RequestingEntity);\n\n\t\t\t\tconst FZoneGraphCompactLaneLocation RequestLocation = RequestFragment.CompactLaneLocation;\n\t\t\t\tconst FZoneGraphLaneHandle RequestLaneHandle = RequestLocation.LaneHandle;\n\n\t\t\t\tconst FMassEntityHandle Entity = Context.GetEntity(i);\n\t\t\t\tbool bDisplayDebug = false;\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\t\t\tFColor DebugColor(FColor::White);\n\t\t\t\tbDisplayDebug = UE::Mass::Debug::IsDebuggingEntity(Entity, &DebugColor);\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t\t\t\tBeginRequestProcessing(Entity, Context, Result);\n\t\t\t\tON_SCOPE_EXIT{ EndRequestProcessing(&SmartObjectSubsystem, Entity, Result); };\n\n\t\t\t\tif (!ensureMsgf(RequestLaneHandle.IsValid(), TEXT(\"Requesting smart objects using an invalid handle\")))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (Annotations == nullptr)\n\t\t\t\t{\n\t\t\t\t\tUE_VLOG(&SmartObjectSubsystem, LogSmartObject, Warning, TEXT(\"%d lane location based requests failed since SmartObject annotations are not available\"), NumEntities);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Fetch smart object data associated to the current graph if different than last used one\n\t\t\t\tif (LastUsedDataHandle != RequestLaneHandle.DataHandle)\n\t\t\t\t{\n\t\t\t\t\tLastUsedDataHandle = RequestLaneHandle.DataHandle;\n\t\t\t\t\tGraphData = Annotations->GetAnnotationData(RequestLaneHandle.DataHandle);\n\t\t\t\t}\n\n\t\t\t\tif (GraphData == nullptr)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Fetch current annotations for the specified lane and look for the smart object tag\n\t\t\t\tconst FZoneGraphTagMask LaneMask = AnnotationSubsystem.GetAnnotationTags(RequestLaneHandle);\n\t\t\t\tif (!LaneMask.Contains(SmartObjectTag))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst FSmartObjectLaneLocationIndices* SmartObjectList = GraphData->LaneToLaneLocationIndicesLookup.Find(RequestLaneHandle.Index);\n\t\t\t\tif (SmartObjectList == nullptr || !ensureMsgf(SmartObjectList->SmartObjectLaneLocationIndices.Num() > 0, TEXT(\"Lookup table should only contains lanes with one or more associated object(s).\")))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tFilter.UserTags = RequestFragment.UserTags;\n\t\t\t\tFilter.ActivityRequirements = RequestFragment.ActivityRequirements;\n\n\t\t\t\tfor (const int32 Index : SmartObjectList->SmartObjectLaneLocationIndices)\n\t\t\t\t{\n\t\t\t\t\t// Find entry point using FindChecked since all smart objects added to LaneToSmartObjects lookup table\n\t\t\t\t\t// were also added to the entry point lookup table\n\t\t\t\t\tcheck(GraphData->SmartObjectLaneLocations.IsValidIndex(Index));\n\t\t\t\t\tconst FSmartObjectLaneLocation& EntryPoint = GraphData->SmartObjectLaneLocations[Index];\n\t\t\t\t\tconst FSmartObjectHandle Handle = EntryPoint.ObjectHandle;\n\n\t\t\t\t\tfloat Cost = 0.f;\n\t\t\t\t\tif (ensureMsgf(EntryPoint.LaneIndex == RequestLocation.LaneHandle.Index, TEXT(\"Must be on same lane to be able to use distance along lane.\")))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Only consider object ahead\n\t\t\t\t\t\tconst float DistAhead = EntryPoint.DistanceAlongLane - RequestLocation.DistanceAlongLane;\n\t\t\t\t\t\tif (DistAhead < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCost = DistAhead;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Make sure that we can use a slot in that object (availability with supported definitions, etc.)\n\t\t\t\t\tTArray<FSmartObjectSlotHandle> SlotHandles;\n\t\t\t\t\tSmartObjectSubsystem.FindSlots(Handle, Filter, SlotHandles, FConstStructView::Make(FSmartObjectMassEntityUserData(Entity)));\n\n\t\t\t\t\tif (SlotHandles.IsEmpty())\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (FSmartObjectSlotHandle SlotHandle : SlotHandles)\n\t\t\t\t\t{\n\t\t\t\t\t\tResult.Candidates.Slots[Result.Candidates.NumSlots++] = FSmartObjectCandidateSlot(FSmartObjectRequestResult(Handle, SlotHandle), Cost);\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\t\t\t\t\tif (bDisplayDebug)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFZoneGraphLaneLocation RequestLaneLocation, EntryPointLaneLocation;\n\t\t\t\t\t\t\tZoneGraphSubsystem.CalculateLocationAlongLane(RequestLaneHandle, RequestLocation.DistanceAlongLane, RequestLaneLocation);\n\t\t\t\t\t\t\tZoneGraphSubsystem.CalculateLocationAlongLane(RequestLaneHandle, EntryPoint.DistanceAlongLane, EntryPointLaneLocation);\n\n\t\t\t\t\t\t\tconstexpr uint16 DebugRadius = 10;\n\t\t\t\t\t\t\tFVector SlotLocation = SmartObjectSubsystem.GetSlotLocation(SlotHandle).Get(EntryPointLaneLocation.Position);\n\t\t\t\t\t\t\tUE_VLOG_LOCATION(&SmartObjectSubsystem, LogSmartObject, Display, SlotLocation, DebugRadius, DebugColor, TEXT(\"%s\"), *LexToString(SlotHandle));\n\t\t\t\t\t\t\tUE_VLOG_SEGMENT(&SmartObjectSubsystem, LogSmartObject, Display, SlotLocation, EntryPointLaneLocation.Position, DebugColor, TEXT(\"\"));\n\t\t\t\t\t\t\tUE_VLOG_SEGMENT(&SmartObjectSubsystem, LogSmartObject, Display, RequestLaneLocation.Position, EntryPointLaneLocation.Position, DebugColor, TEXT(\"\"));\n\t\t\t\t\t\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\t\t\t\t\t\tif (Result.Candidates.NumSlots == FMassSmartObjectCandidateSlots::MaxNumCandidates)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Result.Candidates.NumSlots == FMassSmartObjectCandidateSlots::MaxNumCandidates)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t// Signal entities that their search results are ready\n\tif (EntitiesToSignal.Num())\n\t{\n\t\tSignalSubsystem.SignalEntities(UE::Mass::Signals::SmartObjectCandidatesReady, EntitiesToSignal);\n\t}\n}\n\n//----------------------------------------------------------------------//\n// UMassSmartObjectTimedBehaviorProcessor\n//----------------------------------------------------------------------//\nvoid UMassSmartObjectTimedBehaviorProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassSmartObjectUserFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddRequirement<FMassSmartObjectTimedBehaviorFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddSubsystemRequirement<USmartObjectSubsystem>(EMassFragmentAccess::ReadOnly);\n\n\tProcessorRequirements.AddSubsystemRequirement<UMassSignalSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nUMassSmartObjectTimedBehaviorProcessor::UMassSmartObjectTimedBehaviorProcessor()\n\t: EntityQuery(*this)\n{\n\tExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::SyncWorldToMass;\n}\n\nvoid UMassSmartObjectTimedBehaviorProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tTArray<FMassEntityHandle> ToRelease;\n\n\tQUICK_SCOPE_CYCLE_COUNTER(UMassProcessor_SmartObjectTestBehavior_Run);\n\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this, &ToRelease](FMassExecutionContext& Context)\n\t{\n\t\tconst USmartObjectSubsystem& SmartObjectSubsystem = Context.GetSubsystemChecked<USmartObjectSubsystem>();\n\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tconst TArrayView<FMassSmartObjectUserFragment> UserList = Context.GetMutableFragmentView<FMassSmartObjectUserFragment>();\n\t\tconst TArrayView<FMassSmartObjectTimedBehaviorFragment> TimedBehaviorFragments = Context.GetMutableFragmentView<FMassSmartObjectTimedBehaviorFragment>();\n\n\t\tfor (int32 i = 0; i < NumEntities; ++i)\n\t\t{\n\t\t\tFMassSmartObjectUserFragment& SOUser = UserList[i];\n\t\t\tFMassSmartObjectTimedBehaviorFragment& TimedBehaviorFragment = TimedBehaviorFragments[i];\n\t\t\tensureMsgf(SOUser.InteractionStatus == EMassSmartObjectInteractionStatus::InProgress, TEXT(\"TimedBehavior fragment should only be present for in-progress interactions: %s\"), *Context.GetEntity(i).DebugGetDescription());\n\n\t\t\tconst float DT = Context.GetDeltaTimeSeconds();\n\t\t\tfloat& UseTime = TimedBehaviorFragment.UseTime;\n\t\t\tUseTime = FMath::Max(UseTime - DT, 0.0f);\n\t\t\tconst bool bMustRelease = UseTime <= 0.f;\n\n#if WITH_MASSGAMEPLAY_DEBUG\n\t\t\tconst FMassEntityHandle Entity = Context.GetEntity(i);\n\t\t\tFColor DebugColor(FColor::White);\n\t\t\tconst bool bIsDebuggingEntity = UE::Mass::Debug::IsDebuggingEntity(Entity, &DebugColor);\n\t\t\tif (bIsDebuggingEntity)\n\t\t\t{\n\t\t\t\tUE_CVLOG(bMustRelease, &SmartObjectSubsystem, LogSmartObject, Log, TEXT(\"[%s] stops using [%s]\"), *Entity.DebugGetDescription(), *LexToString(SOUser.InteractionHandle));\n\t\t\t\tUE_CVLOG(!bMustRelease, &SmartObjectSubsystem, LogSmartObject, Verbose, TEXT(\"[%s] using [%s]. Time left: %.1f\"), *Entity.DebugGetDescription(), *LexToString(SOUser.InteractionHandle), UseTime);\n\n\t\t\t\tconst TOptional<FTransform> Transform = SmartObjectSubsystem.GetSlotTransform(SOUser.InteractionHandle);\n\t\t\t\tif (Transform.IsSet())\n\t\t\t\t{\n\t\t\t\t\tconstexpr float Radius = 40.f;\n\t\t\t\t\tconst FVector HalfHeightOffset(0.f, 0.f, 100.f);\n\t\t\t\t\tconst FVector Pos = Transform.GetValue().GetLocation();\n\t\t\t\t\tconst FVector Dir = Transform.GetValue().GetRotation().GetForwardVector();\n\t\t\t\t\tUE_VLOG_CYLINDER(&SmartObjectSubsystem, LogSmartObject, Display, Pos - HalfHeightOffset, Pos + HalfHeightOffset, Radius, DebugColor, TEXT(\"\"));\n\t\t\t\t\tUE_VLOG_ARROW(&SmartObjectSubsystem, LogSmartObject, Display, Pos, Pos + Dir * 2.0f * Radius, DebugColor, TEXT(\"\"));\n\t\t\t\t}\n\t\t\t}\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\n\t\t\tif (bMustRelease)\n\t\t\t{\n\t\t\t\tSOUser.InteractionStatus = EMassSmartObjectInteractionStatus::BehaviorCompleted;\n\t\t\t\tToRelease.Add(Context.GetEntity(i));\n\t\t\t}\n\t\t}\n\t});\n\n\tif (ToRelease.Num())\n\t{\n\t\tUMassSignalSubsystem& SignalSubsystem = Context.GetMutableSubsystemChecked<UMassSignalSubsystem>();\n\t\tSignalSubsystem.SignalEntities(UE::Mass::Signals::SmartObjectInteractionDone, ToRelease);\n\t}\n}\n\n//----------------------------------------------------------------------//\n//  UMassSmartObjectUserFragmentDeinitializer\n//----------------------------------------------------------------------//\nUMassSmartObjectUserFragmentDeinitializer::UMassSmartObjectUserFragmentDeinitializer()\n\t: EntityQuery(*this)\n{\n\tObservedType = FMassSmartObjectUserFragment::StaticStruct();\n\tOperation = EMassObservedOperation::Remove;\n\tExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;\n}\n\nvoid UMassSmartObjectUserFragmentDeinitializer::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FMassSmartObjectUserFragment>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddSubsystemRequirement<USmartObjectSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassSmartObjectUserFragmentDeinitializer::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t\t{\n\t\t\tUSmartObjectSubsystem& SmartObjectSubsystem = Context.GetMutableSubsystemChecked<USmartObjectSubsystem>();\n\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\tconst TArrayView<FMassSmartObjectUserFragment> SmartObjectUserFragments = Context.GetMutableFragmentView<FMassSmartObjectUserFragment>();\n\n\t\t\tfor (int32 i = 0; i < NumEntities; ++i)\n\t\t\t{\n\t\t\t\tSmartObjectSubsystem.UnregisterSlotInvalidationCallback(SmartObjectUserFragments[i].InteractionHandle);\n\t\t\t}\n\t\t});\n}",
      "lines": 414
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Private\\MassSmartObjectRegistration.cpp",
      "extension": ".cpp",
      "size_bytes": 10751,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSmartObjectRegistration.h\"\n\n#include \"MassActorSubsystem.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassGameplayExternalTraits.h\" // required for USmartObjectSubsystem trait (i.e. TMassExternalSubsystemTraits<USmartObjectSubsystem>)\n#include \"MassExecutionContext.h\"\n#include \"MassSignalSubsystem.h\"\n#include \"SmartObjectSubsystem.h\"\n\nnamespace UE::Mass::Signals\n{\n\tconst FName SmartObjectActivationChanged = FName(TEXT(\"SmartObjectActivated\"));\n}\n\n//----------------------------------------------------------------------//\n// UMassSmartObjectInitializerBase\n//----------------------------------------------------------------------//\nUMassSmartObjectInitializerBase::UMassSmartObjectInitializerBase()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = static_cast<int32>(EProcessorExecutionFlags::Standalone | EProcessorExecutionFlags::Server);\n\tOperation = EMassObservedOperation::Add;\n}\n\nvoid UMassSmartObjectInitializerBase::ConfigureQueries()\n{\n\tProcessorRequirements.AddSubsystemRequirement<UMassSignalSubsystem>(EMassFragmentAccess::ReadWrite);\n\tEntityQuery.AddTagRequirement<FMassInActiveSmartObjectsRangeTag>(EMassFragmentPresence::All);\n\tEntityQuery.AddRequirement<FMassActorInstanceFragment>(EMassFragmentAccess::ReadOnly);\n\tEntityQuery.AddRequirement<FSmartObjectRegistrationFragment>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassSmartObjectInitializerBase::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tUMassSignalSubsystem& SignalSubsystem = Context.GetMutableSubsystemChecked<UMassSignalSubsystem>();\n\tTArray<FMassEntityHandle> EntitiesToSignal;\n\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context,[&EntitiesToSignal](FMassExecutionContext& Context)\n\t{\n\t\tconst TConstArrayView<FMassActorInstanceFragment> InstancedActorFragments = Context.GetFragmentView<FMassActorInstanceFragment>();\n\t\tconst TArrayView<FSmartObjectRegistrationFragment> RegistrationFragments = Context.GetMutableFragmentView<FSmartObjectRegistrationFragment>();\n\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tEntitiesToSignal.Reserve(EntitiesToSignal.Num() + NumEntities);\n\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tFSmartObjectRegistrationFragment& RegistrationFragment = RegistrationFragments[EntityIndex];\n\t\t\tconst FMassActorInstanceFragment& InstancedActorFragment = InstancedActorFragments[EntityIndex];\n\n\t\t\tcheckf(!RegistrationFragment.Handle.IsValid(), TEXT(\"Should create smartobject only once.\"))\n\t\t\tif (RegistrationFragment.Asset.Get() == nullptr)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!InstancedActorFragment.Handle.IsValid())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tEntitiesToSignal.Add(Context.GetEntity(EntityIndex));\n\t\t}\n\t});\n\n\t// Signal all entities inside the consolidated list\n\tif (EntitiesToSignal.Num())\n\t{\n\t\tSignalSubsystem.SignalEntities(Signal, EntitiesToSignal);\n\t}\n}\n\n//----------------------------------------------------------------------//\n// UMassSmartObjectDeinitializerBase\n//----------------------------------------------------------------------//\nUMassSmartObjectDeinitializerBase::UMassSmartObjectDeinitializerBase()\n\t: EntityQuery(*this)\n{\n\tExecutionFlags = static_cast<int32>(EProcessorExecutionFlags::Standalone | EProcessorExecutionFlags::Server);\n\tOperation = EMassObservedOperation::Remove;\n}\n\nvoid UMassSmartObjectDeinitializerBase::ConfigureQueries()\n{\n\tProcessorRequirements.AddSubsystemRequirement<UMassSignalSubsystem>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassSmartObjectDeinitializerBase::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tUMassSignalSubsystem& SignalSubsystem = Context.GetMutableSubsystemChecked<UMassSignalSubsystem>();\n\tTArray<FMassEntityHandle> EntitiesToSignal;\n\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [&EntitiesToSignal](FMassExecutionContext& Context)\n\t{\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tEntitiesToSignal.Reserve(EntitiesToSignal.Num() + NumEntities);\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tEntitiesToSignal.Add(Context.GetEntity(EntityIndex));\n\t\t}\n\t});\n\t\n\t// Signal all entities inside the consolidated list\n\tif (EntitiesToSignal.Num())\n\t{\n\t\tSignalSubsystem.SignalEntities(Signal, EntitiesToSignal);\n\t}\n}\n\n//----------------------------------------------------------------------//\n// UMassActiveSmartObjectInitializer\n//----------------------------------------------------------------------//\nUMassActiveSmartObjectInitializer::UMassActiveSmartObjectInitializer()\n{\n\tObservedType = FMassInActiveSmartObjectsRangeTag::StaticStruct();\n\tSignal = UE::Mass::Signals::SmartObjectActivationChanged;\n}\n\n//----------------------------------------------------------------------//\n// UMassActiveSmartObjectDeinitializer\n//----------------------------------------------------------------------//\nUMassActiveSmartObjectDeinitializer::UMassActiveSmartObjectDeinitializer()\n{\n\tObservedType = FMassInActiveSmartObjectsRangeTag::StaticStruct();\n\tSignal = UE::Mass::Signals::SmartObjectActivationChanged;\n}\n\n//----------------------------------------------------------------------//\n// UMassActorInstanceHandleInitializer\n//----------------------------------------------------------------------//\nUMassActorInstanceHandleInitializer::UMassActorInstanceHandleInitializer()\n{\n\tObservedType = FMassActorInstanceFragment::StaticStruct();\n\tSignal = UE::Mass::Signals::ActorInstanceHandleChanged;\n}\n\n//----------------------------------------------------------------------//\n// UMassActorInstanceHandleDeinitializer\n//----------------------------------------------------------------------//\nUMassActorInstanceHandleDeinitializer::UMassActorInstanceHandleDeinitializer()\n{\n\tObservedType = FMassActorInstanceFragment::StaticStruct();\n\tSignal = UE::Mass::Signals::ActorInstanceHandleChanged;\n}\n\n//-----------------------------------------------------------------------------\n// UMassActiveSmartObjectSignalProcessor\n//-----------------------------------------------------------------------------\nUMassActiveSmartObjectSignalProcessor::UMassActiveSmartObjectSignalProcessor()\n\t: InsideSmartObjectActiveRangeQuery(*this)\n\t, OutsideSmartObjectActiveRangeQuery(*this)\n{\n\t// USmartObjectSubsystem CreateSmartObject/DestroySmartObject methods called\n\t// from this process are not safe to call from other threads.\n\tbRequiresGameThreadExecution = true;\n}\n\nvoid UMassActiveSmartObjectSignalProcessor::ConfigureQueries()\n{\n\tInsideSmartObjectActiveRangeQuery.AddSubsystemRequirement<USmartObjectSubsystem>(EMassFragmentAccess::ReadWrite);\n\tInsideSmartObjectActiveRangeQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);\n\tInsideSmartObjectActiveRangeQuery.AddRequirement<FMassActorInstanceFragment>(EMassFragmentAccess::ReadOnly);\n\tInsideSmartObjectActiveRangeQuery.AddRequirement<FSmartObjectRegistrationFragment>(EMassFragmentAccess::ReadWrite);\n\tInsideSmartObjectActiveRangeQuery.AddTagRequirement<FMassInActiveSmartObjectsRangeTag>(EMassFragmentPresence::All);\n\n\tOutsideSmartObjectActiveRangeQuery.AddSubsystemRequirement<USmartObjectSubsystem>(EMassFragmentAccess::ReadWrite);\n\tOutsideSmartObjectActiveRangeQuery.AddRequirement<FSmartObjectRegistrationFragment>(EMassFragmentAccess::ReadWrite);\n\tOutsideSmartObjectActiveRangeQuery.AddTagRequirement<FMassInActiveSmartObjectsRangeTag>(EMassFragmentPresence::None);\n}\n\nvoid UMassActiveSmartObjectSignalProcessor::Initialize(UObject& Owner)\n{\n\tSuper::Initialize(Owner);\n\n\tUMassSignalSubsystem* SignalSubsystem = UWorld::GetSubsystem<UMassSignalSubsystem>(Owner.GetWorld());\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::ActorInstanceHandleChanged);\n\tSubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::SmartObjectActivationChanged);\n}\n\nvoid UMassActiveSmartObjectSignalProcessor::SignalEntities(FMassEntityManager& EntityManager, FMassExecutionContext& Context, FMassSignalNameLookup&)\n{\n\t// Process entities in active range\n\tInsideSmartObjectActiveRangeQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tUSmartObjectSubsystem& Subsystem = Context.GetMutableSubsystemChecked<USmartObjectSubsystem>();\n\t\tconst TConstArrayView<FTransformFragment> TransformFragments = Context.GetFragmentView<FTransformFragment>();\n\t\tconst TConstArrayView<FMassActorInstanceFragment> InstancedActorFragments = Context.GetFragmentView<FMassActorInstanceFragment>();\n\t\tconst TArrayView<FSmartObjectRegistrationFragment> RegistrationFragments = Context.GetMutableFragmentView<FSmartObjectRegistrationFragment>();\n\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tFSmartObjectRegistrationFragment& RegistrationFragment = RegistrationFragments[EntityIndex];\n\t\t\tconst FMassActorInstanceFragment& InstancedActorFragment = InstancedActorFragments[EntityIndex];\n\t\t\tconst FTransformFragment& TransformFragment = TransformFragments[EntityIndex];\n\n\t\t\t// Creation\n\t\t\tif (!RegistrationFragment.Handle.IsValid() && InstancedActorFragment.Handle.IsValid())\n\t\t\t{\n\t\t\t\tif (const USmartObjectDefinition* Definition = RegistrationFragment.Asset.Get())\n\t\t\t\t{\n\t\t\t\t\tFSmartObjectActorOwnerData InstancedActorOwnerData(InstancedActorFragment.Handle);\n\t\t\t\t\tRegistrationFragment.Handle = Subsystem.CreateSmartObject(\n\t\t\t\t\t\t*Definition,\n\t\t\t\t\t\tTransformFragment.GetTransform(),\n\t\t\t\t\t\tFConstStructView::Make(InstancedActorOwnerData));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Destruction\n\t\t\telse if (RegistrationFragment.Handle.IsValid() && !InstancedActorFragment.Handle.IsValid())\n\t\t\t{\n\t\t\t\tSubsystem.DestroySmartObject(RegistrationFragment.Handle);\n\t\t\t\tRegistrationFragment.Handle.Invalidate();\n\t\t\t}\n\t\t}\n\t});\n\n\t// Process out of active range entities\n\tOutsideSmartObjectActiveRangeQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)\n\t{\n\t\tUSmartObjectSubsystem& Subsystem = Context.GetMutableSubsystemChecked<USmartObjectSubsystem>();\n\t\tconst TArrayView<FSmartObjectRegistrationFragment> RegistrationFragments = Context.GetMutableFragmentView<FSmartObjectRegistrationFragment>();\n\n\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\tfor (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)\n\t\t{\n\t\t\tFSmartObjectRegistrationFragment& RegistrationFragment = RegistrationFragments[EntityIndex];\n\n\t\t\tif (RegistrationFragment.Handle.IsValid())\n\t\t\t{\n\t\t\t\tSubsystem.DestroySmartObject(RegistrationFragment.Handle);\n\t\t\t\tRegistrationFragment.Handle.Invalidate();\n\t\t\t}\n\t\t}\n\t});\n}\n",
      "lines": 238
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Private\\MassSmartObjectSettings.cpp",
      "extension": ".cpp",
      "size_bytes": 791,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSmartObjectSettings.h\"\n\n#if WITH_EDITOR\nvoid UMassSmartObjectSettings::PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent)\n{\n\tSuper::PostEditChangeChainProperty(PropertyChangedEvent);\n\n\tFProperty* Property = PropertyChangedEvent.Property;\n\tFProperty* MemberProperty = nullptr;\n\tif (PropertyChangedEvent.PropertyChain.GetActiveMemberNode())\n\t{\n\t\tMemberProperty = PropertyChangedEvent.PropertyChain.GetActiveMemberNode()->GetValue();\n\t}\n\n\tif (MemberProperty != nullptr && Property != nullptr)\n\t{\n\t\tif (MemberProperty->GetFName() == GET_MEMBER_NAME_CHECKED(UMassSmartObjectSettings, SmartObjectTag))\n\t\t{\n\t\t\tOnAnnotationSettingsChanged.Broadcast();\n\t\t}\n\t}\n}\n#endif // WITH_EDITOR",
      "lines": 25
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Private\\MassSmartObjectsModule.cpp",
      "extension": ".cpp",
      "size_bytes": 837,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CoreMinimal.h\"\n#include \"IMassSmartObjectsModule.h\"\n#include \"UObject/CoreRedirects.h\"\n\nclass FMassSmartObjectsModule : public IMassSmartObjectsModule\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nIMPLEMENT_MODULE(FMassSmartObjectsModule, MassSmartObjects)\n\n\n\nvoid FMassSmartObjectsModule::StartupModule()\n{\n\t// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)\n}\n\n\nvoid FMassSmartObjectsModule::ShutdownModule()\n{\n\t// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n\t// we call this function before unloading the module.\n}\n\n\n\n",
      "lines": 31
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Private\\MassSmartObjectTypes.cpp",
      "extension": ".cpp",
      "size_bytes": 89,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSmartObjectTypes.h\"\n",
      "lines": 3
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Private\\MassSmartObjectUserTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 466,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSmartObjectUserTrait.h\"\n\n#include \"MassSmartObjectFragments.h\"\n#include \"MassEntityTemplateRegistry.h\"\n\nvoid UMassSmartObjectUserTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tFMassSmartObjectUserFragment SmartObjectUser;\n\tSmartObjectUser.UserTags = UserTags;\n\t\n\tBuildContext.AddFragment(FConstStructView::Make(SmartObjectUser));\n}\n",
      "lines": 14
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\Private\\SmartObjectZoneAnnotations.cpp",
      "extension": ".cpp",
      "size_bytes": 13589,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"SmartObjectZoneAnnotations.h\"\n#include \"MassSmartObjectSettings.h\"\n#include \"SmartObjectComponent.h\"\n#include \"SmartObjectSubsystem.h\"\n#include \"ZoneGraphAnnotationSubsystem.h\"\n#include \"ZoneGraphAnnotationTypes.h\"\n#include \"ZoneGraphDelegates.h\"\n#include \"ZoneGraphQuery.h\"\n#include \"ZoneGraphSubsystem.h\"\n#include \"GameFramework/Character.h\"\n#include \"VisualLogger/VisualLogger.h\"\n\nvoid USmartObjectZoneAnnotations::PostSubsystemsInitialized()\n{\n\tSmartObjectSubsystem = UWorld::GetSubsystem<USmartObjectSubsystem>(GetWorld());\n\n#if WITH_EDITOR\n\t// Monitor collection changes to rebuild our lookup data\n\tif (SmartObjectSubsystem != nullptr)\n\t{\n\t\tOnMainCollectionChangedHandle = SmartObjectSubsystem->OnMainCollectionChanged.AddLambda([this]()\n\t\t{\n\t\t\tconst UWorld* World = GetWorld();\n\t\t\tif (World != nullptr && !World->IsGameWorld())\n\t\t\t{\n\t\t\t\tRebuildForAllGraphs();\n\t\t\t}\n\t\t});\n\n\t\tOnMainCollectionDirtiedHandle = SmartObjectSubsystem->OnMainCollectionDirtied.AddLambda([this]()\n\t\t{\n\t\t\tconst UWorld* World = GetWorld();\n\t\t\tif (World != nullptr && !World->IsGameWorld())\n\t\t\t{\n\t\t\t\t// Simply queue a rebuild request until we serialize the annotations.\n\t\t\t\t// This is to avoid large amount of rebuild triggered from SmartObjectComponents being constantly\n\t\t\t\t// unregistered/registered when modifying their properties (e.g. dragging the actor(s) in the level)\n\t\t\t\tbRebuildAllGraphsRequested = true;\n\t\t\t\tMarkPackageDirty();\n\t\t\t}\n\t\t});\n\t}\n\n\tconst UMassSmartObjectSettings* MassSmartObjectSettings = GetDefault<UMassSmartObjectSettings>();\n\tBehaviorTag = MassSmartObjectSettings->SmartObjectTag;\n\n\t// Track density settings changes\n\tOnAnnotationSettingsChangedHandle = MassSmartObjectSettings->OnAnnotationSettingsChanged.AddLambda([this]()\n\t{\n\t\tBehaviorTag = GetDefault<UMassSmartObjectSettings>()->SmartObjectTag;\n\t});\n\n\t// Monitor zone graph changes to rebuild our lookup data\n\tOnGraphDataChangedHandle = UE::ZoneGraphDelegates::OnZoneGraphDataBuildDone.AddLambda([this](const FZoneGraphBuildData& BuildData)\n\t{\n\t\tRebuildForAllGraphs();\n\t});\n#endif // WITH_EDITOR\n\n\t// Update our cached members before calling base class since it might call\n\t// PostZoneGraphDataAdded and we need to be all set.\n\tSuper::PostSubsystemsInitialized();\n}\n\nvoid USmartObjectZoneAnnotations::PostZoneGraphDataAdded(const AZoneGraphData& ZoneGraphData)\n{\n\tconst FZoneGraphStorage& Storage = ZoneGraphData.GetStorage();\n\tconst int32 Index = Storage.DataHandle.Index;\n\n#if WITH_EDITOR\n\tif (Index >= SmartObjectAnnotationDataArray.Num())\n\t{\n\t\tSmartObjectAnnotationDataArray.SetNum(Index + 1);\n\t}\n#endif\n\n\tcheckf(SmartObjectAnnotationDataArray.IsValidIndex(Index), TEXT(\"In Editor should always resize when necessary and runtime should always have valid precomputed data.\"));\n\tFSmartObjectAnnotationData& Data = SmartObjectAnnotationDataArray[Index];\n\tif (!Data.IsValid())\n\t{\n\t\tData.DataHandle = Storage.DataHandle;\n\t}\n\n#if WITH_EDITOR\n\t// We don't rebuild for runtime world, we use precomputed data\n\tif (!ZoneGraphData.GetWorld()->IsGameWorld())\n\t{\n\t\tRebuildForSingleGraph(Data, Storage);\n\t}\n#endif // WITH_EDITOR\n\n\tData.bInitialTaggingCompleted = false;\n}\n\nvoid USmartObjectZoneAnnotations::PreZoneGraphDataRemoved(const AZoneGraphData& ZoneGraphData)\n{\n\tconst FZoneGraphStorage& Storage = ZoneGraphData.GetStorage();\n\tconst int32 Index = Storage.DataHandle.Index;\n\n\tif (!SmartObjectAnnotationDataArray.IsValidIndex(Index))\n\t{\n\t\treturn;\n\t}\n\n\tFSmartObjectAnnotationData& Data = SmartObjectAnnotationDataArray[Index];\n\n\t// We use precomputed data for runtime so we only mark it as not longer used\n\tif (ZoneGraphData.GetWorld()->IsGameWorld())\n\t{\n\t\tData.DataHandle = {};\n\t}\n\telse\n\t{\n\t\tData.Reset();\n\t}\n}\n\nFZoneGraphTagMask USmartObjectZoneAnnotations::GetAnnotationTags() const\n{\n\treturn FZoneGraphTagMask(BehaviorTag);\n}\n\nconst FSmartObjectAnnotationData* USmartObjectZoneAnnotations::GetAnnotationData(const FZoneGraphDataHandle DataHandle) const\n{\n\tconst int32 Index = DataHandle.Index;\n\tif (!SmartObjectAnnotationDataArray.IsValidIndex(Index))\n\t{\n\t\treturn nullptr;\n\t}\n\n\treturn &SmartObjectAnnotationDataArray[Index];\n}\n\nTOptional<FSmartObjectLaneLocation> USmartObjectZoneAnnotations::GetSmartObjectLaneLocation(const FZoneGraphDataHandle DataHandle, const FSmartObjectHandle SmartObjectHandle) const\n{\n\tTOptional<FSmartObjectLaneLocation> SmartObjectLaneLocation;\n\tif (const FSmartObjectAnnotationData* AnnotationData = GetAnnotationData(DataHandle))\n\t{\n\t\tconst int32 Index = AnnotationData->SmartObjectToLaneLocationIndexLookup.FindChecked(SmartObjectHandle);\n\t\tif (AnnotationData->SmartObjectLaneLocations.IsValidIndex(Index))\n\t\t{\n\t\t\tSmartObjectLaneLocation = AnnotationData->SmartObjectLaneLocations[Index];\n\t\t}\n\t}\n\treturn SmartObjectLaneLocation;\n}\n\nvoid USmartObjectZoneAnnotations::TickAnnotation(const float DeltaTime, FZoneGraphAnnotationTagContainer& BehaviorTagContainer)\n{\n\tif (!BehaviorTag.IsValid())\n\t{\n\t\treturn;\n\t}\n\n\tfor (FSmartObjectAnnotationData& Data : SmartObjectAnnotationDataArray)\n\t{\n\t\tif (Data.bInitialTaggingCompleted || !Data.IsValid() || Data.SmartObjectToLaneLocationIndexLookup.IsEmpty())\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Apply tags\n\t\tTArrayView<FZoneGraphTagMask> LaneTags = BehaviorTagContainer.GetMutableAnnotationTagsForData(Data.DataHandle);\n\t\tfor (const int32 LaneIndex : Data.AffectedLanes)\n\t\t{\n\t\t\tLaneTags[LaneIndex].Add(BehaviorTag);\n\t\t}\n\n\t\tData.bInitialTaggingCompleted = true;\n\t}\n\n#if UE_ENABLE_DEBUG_DRAWING\n\tMarkRenderStateDirty();\n#endif // UE_ENABLE_DEBUG_DRAWING\n}\n\n#if UE_ENABLE_DEBUG_DRAWING\nvoid USmartObjectZoneAnnotations::DebugDraw(FZoneGraphAnnotationSceneProxy* DebugProxy)\n{\n\tUZoneGraphSubsystem* ZoneGraph = UWorld::GetSubsystem<UZoneGraphSubsystem>(GetWorld());\n\tif (ZoneGraph == nullptr)\n\t{\n\t\treturn;\n\t}\n\n\tconst FSmartObjectContainer& SmartObjectContainer = SmartObjectSubsystem->GetSmartObjectContainer();\n\n\tfor (FSmartObjectAnnotationData& AnnotationData : SmartObjectAnnotationDataArray)\n\t{\n\t\tconst FZoneGraphStorage* ZoneStorage = AnnotationData.DataHandle.IsValid() ? ZoneGraph->GetZoneGraphStorage(AnnotationData.DataHandle) : nullptr;\n\t\tif (ZoneStorage == nullptr)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (const FSmartObjectCollectionEntry& Entry : SmartObjectContainer.GetEntries())\n\t\t{\n\t\t\tint32* Index = AnnotationData.SmartObjectToLaneLocationIndexLookup.Find(Entry.GetHandle());\n\t\t\tif (Index == nullptr)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst FSmartObjectLaneLocation& SOLaneLocation = AnnotationData.SmartObjectLaneLocations[*Index];\n\n\t\t\tconst FVector& ObjectLocation = Entry.GetTransform().GetLocation();\n\t\t\tFZoneGraphLaneLocation EntryPointLocation;\n\t\t\tUE::ZoneGraph::Query::CalculateLocationAlongLane(*ZoneStorage, SOLaneLocation.LaneIndex, SOLaneLocation.DistanceAlongLane, EntryPointLocation);\n\t\t\tconst FColor Color = FColor::Silver;\n\t\t\tconstexpr float SphereRadius = 25.f;\n\t\t\tDebugProxy->Spheres.Emplace(SphereRadius, EntryPointLocation.Position, Color);\n\t\t\tDebugProxy->Spheres.Emplace(SphereRadius, ObjectLocation, Color);\n\t\t\tDebugProxy->DashedLines.Emplace(ObjectLocation, EntryPointLocation.Position, Color, /*dash size*/10.f);\n\t\t}\n\t}\n}\n#endif // UE_ENABLE_DEBUG_DRAWING\n\n#if WITH_EDITORONLY_DATA\nvoid USmartObjectZoneAnnotations::Serialize(FArchive& Ar)\n{\n\tif (bRebuildAllGraphsRequested\n\t\t&& Ar.IsSaving()\n\t\t&& Ar.IsPersistent()\t// saving archive for persistent storage (package)\n\t\t&& !Ar.IsTransacting()\t// do not rebuild for transactions (i.e. undo/redo)\n\t\t)\n\t{\n\t\tRebuildForAllGraphs();\n\t}\n\n\tSuper::Serialize(Ar);\n}\n#endif // WITH_EDITORONLY_DATA\n\n#if WITH_EDITOR\nvoid USmartObjectZoneAnnotations::OnUnregister()\n{\n\tif (SmartObjectSubsystem != nullptr)\n\t{\n\t\tSmartObjectSubsystem->OnMainCollectionChanged.Remove(OnMainCollectionChangedHandle);\n\t\tOnMainCollectionChangedHandle.Reset();\n\n\t\tSmartObjectSubsystem->OnMainCollectionDirtied.Remove(OnMainCollectionDirtiedHandle);\n\t\tOnMainCollectionDirtiedHandle.Reset();\n\t}\n\n\tGetDefault<UMassSmartObjectSettings>()->OnAnnotationSettingsChanged.Remove(OnAnnotationSettingsChangedHandle);\n\tOnAnnotationSettingsChangedHandle.Reset();\n\n\tUE::ZoneGraphDelegates::OnZoneGraphDataBuildDone.Remove(OnGraphDataChangedHandle);\n\tOnGraphDataChangedHandle.Reset();\n\n\tSuper::OnUnregister();\n}\n\nvoid USmartObjectZoneAnnotations::PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent)\n{\n\tSuper::PostEditChangeChainProperty(PropertyChangedEvent);\n\n\tFProperty* Property = PropertyChangedEvent.Property;\n\tFProperty* MemberProperty = nullptr;\n\tif (PropertyChangedEvent.PropertyChain.GetActiveMemberNode())\n\t{\n\t\tMemberProperty = PropertyChangedEvent.PropertyChain.GetActiveMemberNode()->GetValue();\n\t}\n\n\tif (MemberProperty && Property)\n\t{\n\t\tif (MemberProperty->GetFName() == GET_MEMBER_NAME_CHECKED(USmartObjectZoneAnnotations, AffectedLaneTags))\n\t\t{\n\t\t\tRebuildForAllGraphs();\n\t\t}\n\t}\n}\n\nvoid USmartObjectZoneAnnotations::RebuildForSingleGraph(FSmartObjectAnnotationData& Data, const FZoneGraphStorage& Storage)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"ZoneGraphSmartObjectBehavior RebuildData\")\n\n\tif (SmartObjectSubsystem == nullptr)\n\t{\n\t\tUE_VLOG_UELOG(this, LogSmartObject, Error, TEXT(\"Attempting to rebuild data while SmartObjectSubsystem is not set. This indicates a problem in the initialization flow.\"));\n\t\treturn;\n\t}\n\n\tif (!BehaviorTag.IsValid())\n\t{\n\t\tUE_VLOG_UELOG(this, LogSmartObject, Warning, TEXT(\"Attempting to rebuild data while BehaviorTag is invalid (e.g. not set in MassSmartObjectSettings)\"));\n\t\treturn;\n\t}\n\t\n\tconst FSmartObjectContainer& SmartObjectContainer = SmartObjectSubsystem->GetSmartObjectContainer();\n\n\tconst FVector SearchExtent(GetDefault<UMassSmartObjectSettings>()->SearchExtents);\n\tint32 NumAdded = 0;\n\tint32 NumDiscarded = 0;\n\n\tconst int32 NumSO = SmartObjectContainer.GetEntries().Num();\n\tconst int32 NumLanes = Storage.Lanes.Num();\n\tData.SmartObjectLaneLocations.Empty(NumSO);\n\tData.SmartObjectToLaneLocationIndexLookup.Empty(NumSO);\n\tData.LaneToLaneLocationIndicesLookup.Empty(NumLanes);\n\tData.AffectedLanes.Empty(NumLanes);\n\n\tfor (const FSmartObjectCollectionEntry& Entry : SmartObjectContainer.GetEntries())\n\t{\n\t\tFSmartObjectHandle Handle = Entry.GetHandle();\n\t\tconst FVector& ObjectLocation = Entry.GetTransform().GetLocation();\n\t\tconst FBox QueryBounds(ObjectLocation - SearchExtent, ObjectLocation + SearchExtent);\n\n\t\tFZoneGraphLaneLocation LaneLocation;\n\t\tfloat DistanceSqr = 0.f;\n\t\tconst bool bFound = UE::ZoneGraph::Query::FindNearestLane(Storage, QueryBounds, AffectedLaneTags, LaneLocation, DistanceSqr);\n\t\tif (bFound)\n\t\t{\n\t\t\tNumAdded++;\n\n\t\t\tconst int32 LaneIndex = LaneLocation.LaneHandle.Index;\n\n\t\t\tconst int32 SOLaneLocationIndex = Data.SmartObjectLaneLocations.Add(FSmartObjectLaneLocation(Handle, LaneIndex, LaneLocation.DistanceAlongLane));\n\t\t\tData.SmartObjectToLaneLocationIndexLookup.Add(Handle, SOLaneLocationIndex);\n\t\t\tData.AffectedLanes.AddUnique(LaneIndex);\n\t\t\tData.LaneToLaneLocationIndicesLookup.FindOrAdd(LaneIndex).SmartObjectLaneLocationIndices.Add(SOLaneLocationIndex);\n\n\t\t\tUE_VLOG_UELOG(this, LogSmartObject, Verbose, TEXT(\"Adding ZG annotation for SmartObject '%s' on lane '%s'\"), *LexToString(Handle), *LaneLocation.LaneHandle.ToString());\n\t\t\tUE_VLOG_SEGMENT(this, LogSmartObject, Display, ObjectLocation, LaneLocation.Position, FColor::Green, TEXT(\"\"));\n\t\t\tUE_VLOG_LOCATION(this, LogSmartObject, Display, ObjectLocation, 50 /*radius*/, FColor::Green, TEXT(\"%s\"), *LexToString(Handle));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNumDiscarded++;\n\t\t\tUE_VLOG_LOCATION(this, LogSmartObject, Display, ObjectLocation, 75 /*radius*/, FColor::Red, TEXT(\"%s\"), *LexToString(Handle));\n\t\t}\n\t}\n\n\t// Sort all entry points per distance on lane\n\tfor (auto It(Data.LaneToLaneLocationIndicesLookup.CreateIterator()); It; ++It)\n\t{\n\t\tIt.Value().SmartObjectLaneLocationIndices.Sort([Locations = Data.SmartObjectLaneLocations](const int32 FirstIndex, const int32 SecondIndex)\n\t\t{\n\t\t\treturn Locations[FirstIndex].DistanceAlongLane < Locations[SecondIndex].DistanceAlongLane;\n\t\t});\n\t}\n\n\tData.SmartObjectLaneLocations.Shrink();\n\tData.SmartObjectToLaneLocationIndexLookup.Shrink();\n\tData.AffectedLanes.Shrink();\n\tData.LaneToLaneLocationIndicesLookup.Shrink();\n\tData.bInitialTaggingCompleted = false;\n\n\tUE_VLOG_UELOG(this, LogSmartObject, Log, TEXT(\"Summary: %d entry points added, %d discarded%s.\"), NumAdded, NumDiscarded, NumDiscarded == 0 ? TEXT(\"\") : TEXT(\" (too far from any lane)\"));\n}\n\nvoid USmartObjectZoneAnnotations::RebuildForAllGraphs()\n{\n\tbRebuildAllGraphsRequested = false;\n\n\tUZoneGraphSubsystem* ZoneGraphSubsystem = UWorld::GetSubsystem<UZoneGraphSubsystem>(GetWorld());\n\tif (!ZoneGraphSubsystem)\n\t{\n\t\treturn;\n\t}\n\n\tfor (const FRegisteredZoneGraphData& RegisteredZoneGraphData : ZoneGraphSubsystem->GetRegisteredZoneGraphData())\n\t{\n\t\tif (!RegisteredZoneGraphData.bInUse || RegisteredZoneGraphData.ZoneGraphData == nullptr)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst FZoneGraphStorage& Storage = RegisteredZoneGraphData.ZoneGraphData->GetStorage();\n\t\tconst int32 Index = Storage.DataHandle.Index;\n\n\t\tif (SmartObjectAnnotationDataArray.IsValidIndex(Index))\n\t\t{\n\t\t\tFSmartObjectAnnotationData& AnnotationData = SmartObjectAnnotationDataArray[Index];\n\t\t\tAnnotationData.Reset();\n\t\t\tRebuildForSingleGraph(AnnotationData, Storage);\n\t\t}\n\t}\n}\n#endif // WITH_EDITOR\n",
      "lines": 383
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Private\\MassAssortedFragmentsTrait.cpp",
      "extension": ".cpp",
      "size_bytes": 1070,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassAssortedFragmentsTrait.h\"\n#include \"MassEntityTemplateRegistry.h\"\n\n\nvoid UMassAssortedFragmentsTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tfor (const FInstancedStruct& Fragment : Fragments)\n\t{\n\t\tif (Fragment.IsValid())\n\t\t{\n\t\t\tconst UScriptStruct* Type = Fragment.GetScriptStruct();\n\t\t\tCA_ASSUME(Type);\n\t\t\tif (Type->IsChildOf(FMassFragment::StaticStruct()))\n\t\t\t{\n\t\t\t\tBuildContext.AddFragment(Fragment);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tUE_LOG(LogMass, Error, TEXT(\"Struct type %s is not a child of FMassFragment\"), *GetPathNameSafe(Type));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (const FInstancedStruct& Tag : Tags)\n\t{\n\t\tif (Tag.IsValid())\n\t\t{\n\t\t\tconst UScriptStruct* Type = Tag.GetScriptStruct();\n\t\t\tCA_ASSUME(Type);\n\t\t\tif (Type->IsChildOf(FMassTag::StaticStruct()))\n\t\t\t{\n\t\t\t\tBuildContext.AddTag(*Type);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tUE_LOG(LogMass, Error, TEXT(\"Struct type %s is not a child of FMassTag\"), *GetPathNameSafe(Type));\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "lines": 42
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Private\\MassEntityConfigAsset.cpp",
      "extension": ".cpp",
      "size_bytes": 9253,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEntityConfigAsset.h\"\n#include \"Logging/MessageLog.h\"\n#include \"MassEntityTraitBase.h\"\n#include \"MassSpawnerTypes.h\"\n#include \"MassSpawnerSubsystem.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"Serialization/ArchiveObjectCrc32.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"Engine/World.h\"\n#if WITH_EDITOR\n#include \"Editor.h\"\n#include \"MassEntityEditor.h\"\n#include \"ScopedTransaction.h\"\n#endif // WITH_EDITOR\n\n#define LOCTEXT_NAMESPACE \"Mass\"\n\n\n//-----------------------------------------------------------------------------\n// FMassEntityConfig\n//-----------------------------------------------------------------------------\nFMassEntityConfig::FMassEntityConfig()\n{\n\tConfigGuid = FGuid::NewGuid();\n}\n\nFMassEntityConfig::FMassEntityConfig(UObject& InOwner)\n\t: ConfigOwner(&InOwner)\n{\n\tConfigGuid = FGuid::NewGuid();\n}\n\nUMassEntityTraitBase* FMassEntityConfig::FindTraitInternal(TSubclassOf<UMassEntityTraitBase> TraitClass, const bool bExactMatch) const\n{\n\tfor (const TObjectPtr<UMassEntityTraitBase>& Trait : Traits)\n\t{\n\t\tif (Trait && (bExactMatch ? Trait->GetClass() == TraitClass : Trait->IsA(TraitClass)))\n\t\t{\n\t\t\treturn Trait;\n\t\t}\n\t}\n\n\treturn Parent ? Parent->GetConfig().FindTraitInternal(TraitClass, bExactMatch) : nullptr;\n}\n\nconst FMassEntityTemplate& FMassEntityConfig::GetOrCreateEntityTemplate(const UWorld& World) const\n{\n\tFMassEntityTemplateID TemplateID;\n\tif (const FMassEntityTemplate* ExistingTemplate = GetEntityTemplateInternal(World, TemplateID))\n\t{\n\t\treturn *ExistingTemplate;\n\t}\n\n\tUMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(&World);\n\tcheck(SpawnerSystem);\n\tFMassEntityTemplateRegistry& TemplateRegistry = SpawnerSystem->GetMutableTemplateRegistryInstance();\n\n\t// Build new template\n\t// TODO: Add methods to FMassEntityTemplateBuildContext to indicate dependency vs setup.\n\t// Dependency should add a fragment with default values (which later can be overridden),\n\t// while setup would override values and should be run just once.\n\n\tFMassEntityTemplateData TemplateData;\n\tFMassEntityTemplateBuildContext BuildContext(TemplateData, TemplateID);\n\n\tTArray<UMassEntityTraitBase*> CombinedTraits;\n\tGetCombinedTraits(CombinedTraits);\n\n\tBuildContext.BuildFromTraits(CombinedTraits, World);\n\tBuildContext.SetTemplateName(GetNameSafe(ConfigOwner));\n\n\treturn TemplateRegistry.FindOrAddTemplate(TemplateID, MoveTemp(TemplateData)).Get();\n}\n\nvoid FMassEntityConfig::DestroyEntityTemplate(const UWorld& World) const\n{\n\tFMassEntityTemplateID TemplateID;\n\tconst FMassEntityTemplate* Template = GetEntityTemplateInternal(World, TemplateID);\n\tif (Template == nullptr)\n\t{\n\t\treturn;\n\t}\n\n\tUMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(&World);\n\tcheck(SpawnerSystem);\n\tFMassEntityTemplateRegistry& TemplateRegistry = SpawnerSystem->GetMutableTemplateRegistryInstance();\n\n\tTArray<UMassEntityTraitBase*> CombinedTraits;\n\tGetCombinedTraits(CombinedTraits);\n\n\tfor (const UMassEntityTraitBase* Trait : CombinedTraits)\n\t{\n\t\tcheck(Trait);\n\t\tTrait->DestroyTemplate(World);\n\t}\n\n\t// TODO - The templates are not being torn down completely, resulting in traits that leave data in various subsystems. (Representation system)\n\t\n\tTemplateRegistry.DestroyTemplate(TemplateID);\n}\n\nconst FMassEntityTemplate& FMassEntityConfig::GetEntityTemplateChecked(const UWorld& World) const\n{\n\tFMassEntityTemplateID TemplateID;\n\tconst FMassEntityTemplate* ExistingTemplate = GetEntityTemplateInternal(World, TemplateID);\n\tcheck(ExistingTemplate);\n\treturn *ExistingTemplate;\n}\n\nconst FMassEntityTemplate* FMassEntityConfig::GetEntityTemplateInternal(const UWorld& World, FMassEntityTemplateID& OutTemplateID) const\n{\n\tUMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(&World);\n\tcheck(SpawnerSystem);\n\tconst FMassEntityTemplateRegistry& TemplateRegistry = SpawnerSystem->GetTemplateRegistryInstance();\n\n\t// Return existing template if found.\n\tOutTemplateID = FMassEntityTemplateIDFactory::Make(ConfigGuid);\n\tconst TSharedRef<FMassEntityTemplate>* TemplateFound = TemplateRegistry.FindTemplateFromTemplateID(OutTemplateID);\n\treturn TemplateFound ? &TemplateFound->Get() : nullptr;\n}\n\nvoid FMassEntityConfig::GetCombinedTraits(TArray<UMassEntityTraitBase*>& OutTraits) const\n{\n\tTArray<const UObject*> Visited;\n\tOutTraits.Reset();\n\tVisited.Add(ConfigOwner);\n\tGetCombinedTraitsInternal(OutTraits, Visited);\n}\n\nvoid FMassEntityConfig::GetCombinedTraitsInternal(TArray<UMassEntityTraitBase*>& OutTraits, TArray<const UObject*>& Visited) const\n{\n\tif (Parent)\n\t{\n\t\tif (Visited.IndexOfByKey(Parent) != INDEX_NONE)\n\t\t{\n\t\t\t// Infinite loop detected.\n\t\t\tFString Path;\n\t\t\tfor (const UObject* Object : Visited)\n\t\t\t{\n\t\t\t\tPath += Object->GetName();\n\t\t\t\tPath += TEXT(\"/\");\n\t\t\t}\n\t\t\tUE_VLOG(ConfigOwner, LogMassSpawner, Error, TEXT(\"%s: Encountered %s as parent second time (Infinite loop). %s\"), *GetNameSafe(ConfigOwner), *GetNameSafe(Parent), *Path);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tVisited.Add(Parent);\n\t\t\tParent->GetConfig().GetCombinedTraitsInternal(OutTraits, Visited);\n\t\t}\n\t}\n\n\tfor (UMassEntityTraitBase* Trait : Traits)\n\t{\n\t\tif (!Trait)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t// Allow only one feature per type. This is also used to allow child configs override parent features.\n\t\tconst int32 Index = OutTraits.IndexOfByPredicate([Trait](const UMassEntityTraitBase* ExistingFeature) -> bool { return Trait->GetClass() == ExistingFeature->GetClass(); });\n\t\tif (Index != INDEX_NONE)\n\t\t{\n\t\t\tOutTraits[Index] = Trait;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOutTraits.Add(Trait);\n\t\t}\n\t}\n}\n\nvoid FMassEntityConfig::AddTrait(UMassEntityTraitBase& Trait)\n{\n\tTraits.Add(&Trait);\n}\n\nbool FMassEntityConfig::ValidateEntityTemplate(const UWorld& World)\n{\n\tTArray<UMassEntityTraitBase*> CombinedTraits;\n\tGetCombinedTraits(CombinedTraits);\n\n\tFMassEntityTemplateData Template;\n\tFMassEntityTemplateBuildContext BuildContext(Template);\n\n\treturn BuildContext.BuildFromTraits(CombinedTraits, World);\n}\n\n//-----------------------------------------------------------------------------\n// DEPRECATED\n//-----------------------------------------------------------------------------\nconst FMassEntityTemplate& FMassEntityConfig::GetOrCreateEntityTemplate(const UWorld& World, const UObject& InConfigOwner) const\n{\n\treturn GetOrCreateEntityTemplate(World);\n}\n\nvoid FMassEntityConfig::DestroyEntityTemplate(const UWorld& World, const UObject& InConfigOwner) const\n{\n\tDestroyEntityTemplate(World);\n}\n\nconst FMassEntityTemplate& FMassEntityConfig::GetEntityTemplateChecked(const UWorld& World, const UObject& InConfigOwner) const\n{\n\treturn GetEntityTemplateChecked(World);\n}\n\nbool FMassEntityConfig::ValidateEntityTemplate(const UWorld& World, const UObject& InConfigOwner)\n{\n\treturn ValidateEntityTemplate(World);\n}\n\nvoid FMassEntityConfig::GetCombinedTraits(TArray<UMassEntityTraitBase*>& OutTraits, TArray<const UObject*>& Visited, const UObject& InConfigOwner) const\n{\n\treturn GetCombinedTraitsInternal(OutTraits, Visited);\n}\n\n#if WITH_EDITOR\nvoid FMassEntityConfig::PostDuplicate(const bool bDuplicateForPIE)\n{\n\tif (bDuplicateForPIE == false)\n\t{\n\t\tConfigGuid = FGuid::NewGuid();\n\t}\n}\n\nUMassEntityTraitBase* FMassEntityConfig::FindMutableTrait(TSubclassOf<UMassEntityTraitBase> TraitClass, const bool bExactMatch)\n{\n\treturn FindTraitInternal(TraitClass, bExactMatch);\n}\n#endif // WITH_EDITOR\n\n//-----------------------------------------------------------------------------\n// UMassEntityConfigAsset\n//-----------------------------------------------------------------------------\n#if WITH_EDITOR\nvoid UMassEntityConfigAsset::PostDuplicate(const bool bDuplicateForPIE)\n{\n\tSuper::PostDuplicate(bDuplicateForPIE);\n\t\n\tConfig.PostDuplicate(bDuplicateForPIE);\n}\n\nvoid UMassEntityConfigAsset::ValidateEntityConfig()\n{\n\tif (UWorld* EditorWorld = GEditor->GetEditorWorldContext().World())\n\t{\n\t\tFMessageLog MessageLog(UE::Mass::Editor::MessageLogPageName);\n\t\tMessageLog.NewPage(FText::FromName(UE::Mass::Editor::MessageLogPageName));\n\n\t\tif (Config.ValidateEntityTemplate(*EditorWorld))\n\t\t{\n\t\t\tFMassEditorNotification Notification;\n\t\t\tNotification.Message = FText::FormatOrdered(LOCTEXT(\"MassEntityConfigAssetNoErrorsDetected\", \"There were no errors detected during validation of {0}\")\n\t\t\t\t, FText::FromName(GetFName()));\n\t\t\tNotification.Severity = EMessageSeverity::Info;\n\t\t\tNotification.Show();\n\t\t}\n\t}\n}\n\nUMassEntityTraitBase* UMassEntityConfigAsset::AddTrait(TSubclassOf<UMassEntityTraitBase> TraitClass)\n{\n\tcheck(TraitClass);\n\n\tUMassEntityTraitBase* TraitInstance = Config.FindMutableTrait(TraitClass, /*bExactMatch=*/true);\n\tif (TraitInstance == nullptr)\n\t{\n\t\tconst FScopedTransaction Transaction(LOCTEXT(\"ProcedurallyAddingTrait\", \"Adding a trait procedurally\"));\n\n\t\tModify();\n\n\t\tTraitInstance = NewObject<UMassEntityTraitBase>(this, TraitClass, FName(), RF_Transactional);\n\t\tcheck(TraitInstance);\n\t\tConfig.AddTrait(*TraitInstance);\n\t}\n\treturn TraitInstance;\n}\n#endif // WITH_EDITOR\n\n#undef LOCTEXT_NAMESPACE \n",
      "lines": 280
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Private\\MassEntityEQSSpawnPointsGenerator.cpp",
      "extension": ".cpp",
      "size_bytes": 4917,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEntityEQSSpawnPointsGenerator.h\"\n#include \"MassSpawnerTypes.h\"\n#include \"MassSpawnLocationProcessor.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassGameplaySettings.h\"\n#include \"MassCommonUtils.h\"\n\n\nUMassEntityEQSSpawnPointsGenerator::UMassEntityEQSSpawnPointsGenerator()\n{\n\tEQSRequest.RunMode = EEnvQueryRunMode::AllMatching; \n}\n\nvoid UMassEntityEQSSpawnPointsGenerator::Generate(UObject& QueryOwner, TConstArrayView<FMassSpawnedEntityType> EntityTypes, const int32 Count, FFinishedGeneratingSpawnDataSignature& FinishedGeneratingSpawnPointsDelegate) const\n{\n\tif (Count <= 0)\n\t{\n\t\tFinishedGeneratingSpawnPointsDelegate.Execute(TArray<FMassEntitySpawnDataGeneratorResult>());\n\t\treturn;\n\t}\n\t\n\t// Need to copy the request as it is called inside a CDO and CDO states cannot be changed.\n\tFEQSParametrizedQueryExecutionRequest EQSRequestInstanced = EQSRequest;\n\tif (EQSRequestInstanced.IsValid() == false)\n\t{\n\t\tEQSRequestInstanced.InitForOwnerAndBlackboard(QueryOwner, /*BBAsset=*/nullptr);\n\t\tif (!ensureMsgf(EQSRequestInstanced.IsValid(), TEXT(\"Query request initialization can fail due to missing parameters. See the runtime log for details\")))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Build array of entity types to spawn.\n\t// @todo: I dont like that this get's passed by value to OnEQSQueryFinished, but seemed like the cleanest solution.\n\tTArray<FMassEntitySpawnDataGeneratorResult> Results;\n\tBuildResultsFromEntityTypes(Count, EntityTypes, Results);\n\n\tFQueryFinishedSignature Delegate = FQueryFinishedSignature::CreateUObject(this, &UMassEntityEQSSpawnPointsGenerator::OnEQSQueryFinished, Results, FinishedGeneratingSpawnPointsDelegate);\n\tEQSRequestInstanced.Execute(QueryOwner, /*BlackboardComponent=*/nullptr, Delegate);\n}\n\nvoid UMassEntityEQSSpawnPointsGenerator::OnEQSQueryFinished(TSharedPtr<FEnvQueryResult> EQSResult, TArray<FMassEntitySpawnDataGeneratorResult> Results,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFFinishedGeneratingSpawnDataSignature FinishedGeneratingSpawnPointsDelegate) const\n{\n\tif (EQSResult.IsValid() == false || EQSResult->IsSuccessful() == false)\n\t{\n\t\tUE_VLOG_UELOG(this, LogMassSpawner, Error, TEXT(\"EQS query failed or result is invalid\"));\n\t\t// Return empty result.\n\t\tResults.Reset();\n\t\tFinishedGeneratingSpawnPointsDelegate.Execute(Results);\n\t\treturn;\n\t}\n\n\tTArray<FVector> Locations;\n\tEQSResult->GetAllAsLocations(Locations);\n\n\t// Randomize them\n\tFRandomStream RandomStream(UE::Mass::Utils::OverrideRandomSeedForTesting(GetRandomSelectionSeed()));\n\tfor (int32 I = 0; I < Locations.Num(); ++I)\n\t{\n\t\tconst int32 J = RandomStream.RandHelper(Locations.Num());\n\t\tLocations.Swap(I, J);\n\t}\n\n\tconst int32 LocationCount = Locations.Num();\n\tint32 LocationIndex = 0;\n\n\t// Distribute points amongst the entities to spawn.\n\tfor (FMassEntitySpawnDataGeneratorResult& Result : Results)\n\t{\n\t\tResult.SpawnDataProcessor = UMassSpawnLocationProcessor::StaticClass();\n\t\tResult.SpawnData.InitializeAs<FMassTransformsSpawnData>();\n\t\tFMassTransformsSpawnData& Transforms = Result.SpawnData.GetMutable<FMassTransformsSpawnData>();\n\n\t\tTransforms.Transforms.Reserve(Result.NumEntities);\n\t\tfor (int i = 0; i < Result.NumEntities; i++)\n\t\t{\n\t\t\tFTransform& Transform = Transforms.Transforms.AddDefaulted_GetRef();\n\t\t\tTransform.SetLocation(Locations[LocationIndex % LocationCount]);\n\t\t\tLocationIndex++;\n\t\t}\n\t}\n\n#if ENABLE_VISUAL_LOG\n\tUE_VLOG(this, LogMassSpawner, Log, TEXT(\"Spawning at %d locations\"), LocationIndex);\n\tif (GetDefault<UMassGameplaySettings>()->bLogSpawnLocations)\n\t{\n\t\tif (FVisualLogEntry* LogEntry = FVisualLogger::Get().GetLastEntryForObject(this))\n\t\t{\n\t\t\tFVisualLogShapeElement Element(TEXT(\"\"), FColor::Orange, /*Thickness*/20, LogMassSpawner.GetCategoryName());\n\n\t\t\tElement.Points.Reserve(LocationIndex);\n\t\t\tfor (const FMassEntitySpawnDataGeneratorResult& Result : Results)\n\t\t\t{\n\t\t\t\tconst FMassTransformsSpawnData& Transforms = Result.SpawnData.Get<FMassTransformsSpawnData>();\n\t\t\t\tfor (int i = 0; i < Result.NumEntities; i++)\n\t\t\t\t{\n\t\t\t\t\tElement.Points.Add(Transforms.Transforms[i].GetLocation());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tElement.Type = EVisualLoggerShapeElement::SinglePoint;\n\t\t\tElement.Verbosity = ELogVerbosity::Display;\n\t\t\tLogEntry->AddElement(Element);\n\t\t}\n\t}\n#endif // ENABLE_VISUAL_LOG\n\n\tFinishedGeneratingSpawnPointsDelegate.Execute(Results);\n}\n\n#if WITH_EDITOR\nvoid UMassEntityEQSSpawnPointsGenerator::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)\n{\n\tstatic const FName EQSRequestName = GET_MEMBER_NAME_CHECKED(UMassEntityEQSSpawnPointsGenerator, EQSRequest);\n\n\tSuper::PostEditChangeProperty(PropertyChangedEvent);\n\n\tif (PropertyChangedEvent.MemberProperty && PropertyChangedEvent.MemberProperty->GetFName() == EQSRequestName)\n\t{\n\t\tEQSRequest.PostEditChangeProperty(*this, PropertyChangedEvent);\n\t}\n}\n#endif",
      "lines": 126
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Private\\MassEntitySpawnDataGeneratorBase.cpp",
      "extension": ".cpp",
      "size_bytes": 1192,
      "content": "ï»¿// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEntitySpawnDataGeneratorBase.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassSpawnerTypes.h\"\n\nvoid UMassEntitySpawnDataGeneratorBase::BuildResultsFromEntityTypes(const int32 SpawnCount, TConstArrayView<FMassSpawnedEntityType> EntityTypes, TArray<FMassEntitySpawnDataGeneratorResult>& OutResults) const\n{\n\tfloat TotalProportion = 0.0f;\n\tfor (const FMassSpawnedEntityType& EntityType : EntityTypes)\n\t{\n\t\tTotalProportion += EntityType.Proportion;\n\t}\n\n\tif (TotalProportion <= 0)\n\t{\n\t\tUE_VLOG_UELOG(this, LogMassSpawner, Error, TEXT(\"The total combined proportion of all the entity types needs to be greater than 0.\"));\n\t\treturn;\n\t}\n\n\tfor (int32 i = 0; i < EntityTypes.Num(); i++)\n\t{\n\t\tconst FMassSpawnedEntityType& EntityType = EntityTypes[i];\n\t\tconst int32 EntityCount = static_cast<int32>(static_cast<float>(SpawnCount) * EntityType.Proportion / TotalProportion);\n\t\tif (EntityCount > 0 && EntityType.GetEntityConfig() != nullptr)\n\t\t{\n\t\t\tFMassEntitySpawnDataGeneratorResult& Res = OutResults.AddDefaulted_GetRef();\n\t\t\tRes.NumEntities = EntityCount;\n\t\t\tRes.EntityConfigIndex = i;\n\t\t}\n\t}\n}",
      "lines": 32
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Private\\MassEntityTemplate.cpp",
      "extension": ".cpp",
      "size_bytes": 6629,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEntityTemplate.h\"\n#include \"VisualLogger/VisualLoggerTypes.h\"\n#include \"MassDebugger.h\"\n#include \"Algo/Find.h\"\n\n//----------------------------------------------------------------------//\n//  FMassEntityTemplateID\n//----------------------------------------------------------------------//\nFString FMassEntityTemplateID::ToString() const\n{\n\treturn IsValid() ? FString::Printf(TEXT(\"[%s:%d]\"), *ConfigGuid.ToString(EGuidFormats::DigitsLower), FlavorHash) \n\t\t\t: FString::Printf(TEXT(\"[Invalid]\"));\n}\n\n//----------------------------------------------------------------------//\n//  FMassEntityTemplateData\n//----------------------------------------------------------------------//\nFMassEntityTemplateData::FMassEntityTemplateData(const FMassEntityTemplate& InFinalizedTemplate)\n\t: FMassEntityTemplateData(InFinalizedTemplate.GetTemplateData())\n{\n\n}\n\nbool FMassEntityTemplateData::SlowIsEquivalent(const FMassEntityTemplateData& Other) const\n{\n\tif (Composition.IsEquivalent(Other.GetCompositionDescriptor()) == false)\n\t{\n\t\treturn false;\n\t}\n\telse if (SharedFragmentValues.IsEquivalent(Other.GetSharedFragmentValues()) == false)\n\t{\n\t\treturn false;\n\t}\n\t\n\tTConstArrayView<FInstancedStruct> OtherInitialFragmentValues = Other.GetInitialFragmentValues();\n\t\n\tif (OtherInitialFragmentValues.Num() != InitialFragmentValues.Num())\n\t{\n\t\treturn false;\n\t}\n\n\tfor (const FInstancedStruct& InitialValue : InitialFragmentValues)\n\t{\n\t\tconst FInstancedStruct* FoundElement = Algo::FindByPredicate(OtherInitialFragmentValues, [&InitialValue](const FInstancedStruct& Element)\n\t\t{\n\t\t\treturn InitialValue == Element;\n\t\t});\n\n\t\tif (FoundElement == nullptr)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nuint32 GetTypeHash(const FMassEntityTemplateData& Template)\n{\n\t// @todo: using the template name is temporary solution to allow to tell two templates apart based on something \n\t// else than composition. Ideally we would hash the fragment values instead.\n\tconst int32 NameHash = GetTypeHash(Template.GetTemplateName());\n\tconst uint32 CompositionHash = Template.GetCompositionDescriptor().CalculateHash();\n\t// @todo shared fragments hash is based on pointers - this needs to be changed as well\n\tconst uint32 SharedFragmentValuesHash = GetTypeHash(Template.GetSharedFragmentValues());\n\t\n\tuint32 InitialValuesHash = 0;\n\t// Initial fragment values, this is not part of the archetype as it is the spawner job to set them.\n\tfor (const FInstancedStruct& Struct : Template.GetInitialFragmentValues())\n\t{\n\t\tInitialValuesHash = UE::StructUtils::GetStructCrc32(Struct, InitialValuesHash);\n\t}\n\n\t// These functions will be called to initialize entity's UObject-based fragments\n\t// @todo this is very bad for hash creation - no way to make this consistent between client server. Might need some \"initializer index\"\n\tuint32 InitializersHash = 0;\n\t/* left here on purpose, will address in following CLs\n\tfor (const FMassEntityTemplateData::FObjectFragmentInitializerFunction& Initializer : Template.ObjectInitializers)\n\t{\n\t\tInitializersHash = HashCombine(InitializersHash, GetTypeHash(Initializer));\n\t}*/\n\n\t// @todo maybe better to have two separate hashes - one for composition and maybe shared fragments, and then the other one for the rest, and use multimap for look up\n\treturn HashCombine(NameHash, HashCombine(HashCombine(CompositionHash, SharedFragmentValuesHash), HashCombine(InitialValuesHash, InitializersHash)));\n}\n\n//-----------------------------------------------------------------------------\n// FMassEntityTemplate\n//-----------------------------------------------------------------------------\nTSharedRef<FMassEntityTemplate> FMassEntityTemplate::MakeFinalTemplate(FMassEntityManager& EntityManager, FMassEntityTemplateData&& TempTemplateData, FMassEntityTemplateID InTemplateID)\n{\n\treturn MakeShared<FMassEntityTemplate>(MoveTemp(TempTemplateData), EntityManager, InTemplateID);\n}\n\nFMassEntityTemplate::FMassEntityTemplate(const FMassEntityTemplateData& InData, FMassEntityManager& EntityManager, FMassEntityTemplateID InTemplateID)\n\t: TemplateData(InData)\n\t, TemplateID(InTemplateID)\n{\n\t// Sort anything there is to sort for later comparison purposes\n\tTemplateData.Sort();\n\n\tTemplateData.GetArchetypeCreationParams().DebugName = FName(GetTemplateName());\n\tconst FMassArchetypeHandle ArchetypeHandle = EntityManager.CreateArchetype(GetCompositionDescriptor(), TemplateData.GetArchetypeCreationParams());\n\tSetArchetype(ArchetypeHandle);\n}\n\nFMassEntityTemplate::FMassEntityTemplate(FMassEntityTemplateData&& InData, FMassEntityManager& EntityManager, FMassEntityTemplateID InTemplateID)\n\t: TemplateData(InData)\n\t, TemplateID(InTemplateID)\n{\n\t// Sort anything there is to sort for later comparison purposes\n\tTemplateData.Sort();\n\n\tTemplateData.GetArchetypeCreationParams().DebugName = FName(GetTemplateName());\n\tconst FMassArchetypeHandle ArchetypeHandle = EntityManager.CreateArchetype(GetCompositionDescriptor(), TemplateData.GetArchetypeCreationParams());\n\tSetArchetype(ArchetypeHandle);\n}\n\nvoid FMassEntityTemplate::SetArchetype(const FMassArchetypeHandle& InArchetype)\n{\n\tcheck(InArchetype.IsValid());\n\tArchetype = InArchetype;\n}\n\nFString FMassEntityTemplate::DebugGetArchetypeDescription(FMassEntityManager& EntityManager) const\n{\n\tFStringOutputDevice OutDescription;\n#if WITH_MASSGAMEPLAY_DEBUG\n\tFMassDebugger::OutputArchetypeDescription(OutDescription, Archetype);\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\treturn MoveTemp(OutDescription);\n}\n\nFString FMassEntityTemplate::DebugGetDescription(FMassEntityManager* EntityManager) const\n{\n\tFStringOutputDevice Ar;\n#if WITH_MASSGAMEPLAY_DEBUG\n\tAr.SetAutoEmitLineTerminator(true);\n\n\tif (EntityManager)\n\t{\n\t\tAr += TEXT(\"Archetype details:\\n\");\n\t\tAr += DebugGetArchetypeDescription(*EntityManager);\n\t}\n\telse\n\t{\n\t\tAr += TEXT(\"Composition:\\n\");\n\t\tGetCompositionDescriptor().DebugOutputDescription(Ar);\n\t}\n\n#endif // WITH_MASSGAMEPLAY_DEBUG\n\treturn MoveTemp(Ar);\n}\n\n//-----------------------------------------------------------------------------\n// FMassEntityTemplateIDFactory\n//-----------------------------------------------------------------------------\nFMassEntityTemplateID FMassEntityTemplateIDFactory::Make(const FGuid& ConfigGuid)\n{\n\treturn FMassEntityTemplateID(ConfigGuid);\n}\n\nFMassEntityTemplateID FMassEntityTemplateIDFactory::MakeFlavor(const FMassEntityTemplateID& SourceTemplateID, const int32 Flavor)\n{\n\treturn FMassEntityTemplateID(SourceTemplateID.ConfigGuid, Flavor);\n}\n",
      "lines": 167
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Private\\MassEntityTemplateRegistry.cpp",
      "extension": ".cpp",
      "size_bytes": 10680,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEntityTemplateRegistry.h\"\n#include \"MassSpawnerTypes.h\"\n#include \"MassEntityManager.h\"\n#include \"Engine/World.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassSpawnerSubsystem.h\"\n#include \"MassEntityTypes.h\"\n#include \"MassEntityTraitBase.h\"\n\n#if WITH_EDITOR\n#include \"Editor.h\"\n#include \"MassDebugger.h\"\n#include \"MassEntityEditor.h\"\n#endif\n\n#define LOCTEXT_NAMESPACE \"Mass\"\n\nnamespace UE::Mass::Debug\n{\n\tconst FName TraitFailedValidation(TEXT(\"TraitFailedValidation\"));\n\tconst FName TraitIgnored(TEXT(\"TraitIgnored\"));\n\n\tstatic bool bReportDuplicatedFragmentsAsWarnings = false;\n\t// anonymous namespace to force CVars's uniqueness - we use the same name in many places, sometimes withing same namespaces\n\tnamespace \n\t{\n\t\tFAutoConsoleVariableRef CVars[] =\n\t\t{\n\t\t\t{ TEXT(\"mass.template.DuplicateElementsAsWarnings\")\n\t\t\t\t, bReportDuplicatedFragmentsAsWarnings\n\t\t\t\t, TEXT(\"Whether to report a detection of a given element type being added by multiple traits as a Warning. Otherise we print the information out as `Info`\")\n\t\t\t\t, ECVF_Cheat}\n\t\t};\n\t}\n}\n\n//----------------------------------------------------------------------//\n// FMassEntityTemplateRegistry \n//----------------------------------------------------------------------//\nTMap<const UScriptStruct*, FMassEntityTemplateRegistry::FStructToTemplateBuilderDelegate> FMassEntityTemplateRegistry::StructBasedBuilders;\n\nFMassEntityTemplateRegistry::FMassEntityTemplateRegistry(UObject* InOwner)\n\t: Owner(InOwner)\n{\n}\n\nvoid FMassEntityTemplateRegistry::ShutDown()\n{\n\tTemplateIDToTemplateMap.Reset();\n\tEntityManager = nullptr;\n}\n\nUWorld* FMassEntityTemplateRegistry::GetWorld() const \n{\n\treturn Owner.IsValid() ? Owner->GetWorld() : nullptr;\n}\n\nFMassEntityTemplateRegistry::FStructToTemplateBuilderDelegate& FMassEntityTemplateRegistry::FindOrAdd(const UScriptStruct& DataType)\n{\n\treturn StructBasedBuilders.FindOrAdd(&DataType);\n}\n\nvoid FMassEntityTemplateRegistry::Initialize(const TSharedPtr<FMassEntityManager>& InEntityManager)\n{\n\tif (EntityManager)\n\t{\n\t\tensureMsgf(EntityManager == InEntityManager, TEXT(\"Attempting to store a different EntityManager then the previously stored one - this indicated a set up issue, attempting to use multiple EntityManager instances\"));\n\t\treturn;\n\t}\n\n\tEntityManager = InEntityManager;\n}\n\nvoid FMassEntityTemplateRegistry::DebugReset()\n{\n#if WITH_MASSGAMEPLAY_DEBUG\n\tTemplateIDToTemplateMap.Reset();\n#endif // WITH_MASSGAMEPLAY_DEBUG\n}\n\nconst TSharedRef<FMassEntityTemplate>* FMassEntityTemplateRegistry::FindTemplateFromTemplateID(FMassEntityTemplateID TemplateID) const\n{\n\treturn TemplateIDToTemplateMap.Find(TemplateID);\n}\n\nconst TSharedRef<FMassEntityTemplate>& FMassEntityTemplateRegistry::FindOrAddTemplate(FMassEntityTemplateID TemplateID, FMassEntityTemplateData&& TemplateData)\n{\n\tcheck(EntityManager);\n\tconst TSharedRef<FMassEntityTemplate>* ExistingTemplate = FindTemplateFromTemplateID(TemplateID);\n\tif (ExistingTemplate != nullptr)\n\t{\n\t\treturn *ExistingTemplate;\n\t}\n\n\treturn TemplateIDToTemplateMap.Add(TemplateID, FMassEntityTemplate::MakeFinalTemplate(*EntityManager, MoveTemp(TemplateData), TemplateID));\n}\n\nvoid FMassEntityTemplateRegistry::DestroyTemplate(FMassEntityTemplateID TemplateID)\n{\n\tTemplateIDToTemplateMap.Remove(TemplateID);\n}\n\n//----------------------------------------------------------------------//\n// FMassEntityTemplateBuildContext \n//----------------------------------------------------------------------//\nbool FMassEntityTemplateBuildContext::BuildFromTraits(TConstArrayView<UMassEntityTraitBase*> Traits, const UWorld& World)\n{\n\tensureMsgf(bBuildInProgress == false, TEXT(\"Unexpected occurrence - it suggests FMassEntityTemplateBuildContext::BuildFromTraits \"\n\t\t\"has been called as a consequence of some UMassEntityTraitBase::BuildTemplate call. Check the callstack.\"));\n\n\tbBuildInProgress = true;\n\tfor (const UMassEntityTraitBase* Trait : Traits)\n\t{\n\t\tcheck(Trait);\n\t\tif (SetTraitBeingProcessed(Trait))\n\t\t{\n\t\t\tTrait->BuildTemplate(*this, World);\n\t\t}\n\t}\n\t// now remove all that has been requested to be removed\n\t// those are only tags for now, thus the shortcut of going directly for tags\n\tfor (FRemovedType& Removed : RemovedTypes)\n\t{\n\t\tcheck(Removed.TypeRemoved);\n\t\tTemplateData.RemoveTag(*CastChecked<UScriptStruct>(Removed.TypeRemoved));\n\t}\n\n\tbBuildInProgress = false;\n\n\tconst bool bTemplateValid = ValidateBuildContext(World);\n\t\n\tResetBuildTimeData();\n\n\treturn bTemplateValid;\n}\n\nbool FMassEntityTemplateBuildContext::SetTraitBeingProcessed(const UMassEntityTraitBase* Trait)\n{\n\tif (Trait == nullptr || TraitsProcessed.Contains(Trait) == false)\n\t{\n\t\tTraitsData.Add({Trait});\n\t\treturn true;\n\t}\n\n\tUE_LOG(LogMass, Warning, TEXT(\"Attempting to add %s to FMassEntityTemplateBuildContext while this or another instance of the trait class has already been added.\")\n\t\t, *GetNameSafe(Trait));\n\n\tIgnoredTraits.Add(Trait);\n\treturn false;\n}\n\nbool FMassEntityTemplateBuildContext::ValidateBuildContext(const UWorld& World)\n{\n#if WITH_UNREAL_DEVELOPER_TOOLS && WITH_EDITOR && WITH_EDITORONLY_DATA && WITH_MASSENTITY_DEBUG\n#define IF_MESSAGES(Message) if (GEditor) { Message }\n#else\n#define IF_MESSAGES(_)\n#endif\n\n\tint32 ErrorCount = 0;\n\tint32 WarningCount = 0;\n\n\t// Doing the trait-specific validation first since it can add required elements to the build context\n\tfor (FTraitData& TraitData : TraitsData)\n\t{\n\t\tUMassEntityTraitBase::FAdditionalTraitRequirements TraitRequirementsWrapper(TraitData.TypesRequired);\n\t\tif (LIKELY(TraitData.Trait) && TraitData.Trait->ValidateTemplate(*this, World, TraitRequirementsWrapper) == false)\n\t\t{\n\t\t\t++ErrorCount;\n\t\t\tIF_MESSAGES(\n\t\t\t\tFMassDebugger::DebugEvent(UE::Mass::Debug::TraitFailedValidation, FConstStructView::Make(FMassGenericDebugEvent{TraitData.Trait}));\n\t\t\t);\n\t\t}\n\t}\n\n\tTMap<const UStruct*, const UMassEntityTraitBase*> TypesAlreadyAdded;\n\n\t// these are non-critical warnings, we want to report these to the users as a potential configuration issue,\n\t// but it won't affect the final entity template composition (for example adding the same fragment is fine since \n\t// the entity template handles that gracefully).\n\tfor (const FTraitData& TraitData : TraitsData)\n\t{\n\t\tfor (const UStruct* TypeAdded : TraitData.TypesAdded)\n\t\t{\n\t\t\tconst UMassEntityTraitBase*& SourceTrait = TypesAlreadyAdded.FindOrAdd(TypeAdded);\n\t\t\tif (SourceTrait != nullptr)\n\t\t\t{\n\t\t\t\tif (UE::Mass::Debug::bReportDuplicatedFragmentsAsWarnings)\n\t\t\t\t{\n\t\t\t\t\t// we report this only if it wasn't added twice by the same trait, the one we're processing right now\n\t\t\t\t\tUE_CLOG(SourceTrait != TraitData.Trait\n\t\t\t\t\t\t, LogMass, Warning, TEXT(\"%s: Fragment %s already added by %s. Check the entity config for conflicting traits\")\n\t\t\t\t\t\t, *GetNameSafe(TraitData.Trait), *GetNameSafe(TypeAdded), *SourceTrait->GetName());\n\t\t\t\t\t++WarningCount;\n\t\t\t\t}\n\t\t\t\tIF_MESSAGES(\n\t\t\t\t\tFMassDebugger::DebugEvent(FMassDuplicateElementsMessage::StaticStruct()->GetFName()\n\t\t\t\t\t\t, FConstStructView::Make(FMassDuplicateElementsMessage{TraitData.Trait, SourceTrait, TypeAdded})\n\t\t\t\t\t\t, UE::Mass::Debug::bReportDuplicatedFragmentsAsWarnings ? EMassDebugMessageSeverity::Warning : EMassDebugMessageSeverity::Info);\n\t\t\t\t);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSourceTrait = TraitData.Trait;\n\t\t\t}\n\t\t}\n\t}\n\n\t// now to properly test if something required was removed we need to filter TypesAlreadyAdded first\n\tfor (const FRemovedType& RemovedElement : RemovedTypes)\n\t{\n\t\tif (RemovedElement.TypeRemoved)\n\t\t{\n\t\t\tTypesAlreadyAdded.Remove(RemovedElement.TypeRemoved);\n\t\t}\n\t}\n\n\t// these are critical, we're going to fail the validation if anything here fails\n\tfor (const FTraitData& TraitData : TraitsData)\n\t{\n\t\tfor (const UStruct* TypeRequired : TraitData.TypesRequired)\n\t\t{\n\t\t\tif (TypesAlreadyAdded.Contains(TypeRequired) == false)\n\t\t\t{\n\t\t\t\tUE_LOG(LogMass, Error, TEXT(\"%s: Missing required element of type %s\")\n\t\t\t\t\t, *GetNameSafe(TraitData.Trait), *GetNameSafe(TypeRequired));\n\t\t\t\t++ErrorCount;\n\t\t\t\tIF_MESSAGES(\n\t\t\t\t{\n\t\t\t\t\t// check if it was removed\n\t\t\t\t\tconst UMassEntityTraitBase* RemovedByTrait = nullptr;\n\t\t\t\t\tconst int32 RemoverIndex = RemovedTypes.Find(FRemovedType({TypeRequired}));\n\t\t\t\t\tif (RemoverIndex != INDEX_NONE)\n\t\t\t\t\t{\n\t\t\t\t\t\tRemovedByTrait = RemovedTypes[RemoverIndex].Remover;\n\t\t\t\t\t}\n\n\t\t\t\t\tFMassDebugger::DebugEvent<FMassMissingTraitMessage>(TraitData.Trait, TypeRequired, RemovedByTrait);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const UMassEntityTraitBase* IgnoredTrait : IgnoredTraits)\n\t{\n\t\tIF_MESSAGES(\n\t\t\tFMassDebugger::DebugEvent(UE::Mass::Debug::TraitIgnored, FConstStructView::Make(FMassGenericDebugEvent{IgnoredTrait}));\n\t\t);\n\t\t++WarningCount;\n\t}\n\t\n\t// @todo add dependencies on trait classes? might be hard if traits are unrelated, like requiring UMassLODCollectorTrait \n\t// or UMassDistanceLODCollectorTrait - both supply alternative implementations of a given functionality, but are unrelated.\n\t// Could be done with a complex requirements system (similar to entity queries - \"all of X\", \"any of Y\", etc) - probably \n\t// not worth it since we don't even have a use case for it right now.\n\n#if WITH_UNREAL_DEVELOPER_TOOLS && WITH_EDITOR\n\tif (GEditor && (ErrorCount || WarningCount))\n\t{\n\t\tFMassEditorNotification Notification;\n\t\tNotification.Message = FText::FormatOrdered(LOCTEXT(\"TraitResult\", \"Mass Entity Template validation:\\n{0} errors and {1} warnings found\"), ErrorCount, WarningCount);\n\t\tNotification.Severity = ErrorCount ? EMessageSeverity::Error : EMessageSeverity::Warning;\n\t\tNotification.bIncludeSeeOutputLogForDetails = true;\n\t\tNotification.Show();\n\t}\n#endif // WITH_UNREAL_DEVELOPER_TOOLS && WITH_EDITOR\n\n#undef IF_MESSAGES\n\n\t// only the Errors render the template invalid, Warnings just warn about stuff not being set up quite right, but we can recover.\n\treturn (ErrorCount == 0);\n}\n\n//-----------------------------------------------------------------------------\n// DEPRECATED\n//-----------------------------------------------------------------------------\nFMassEntityTemplate* FMassEntityTemplateRegistry::FindMutableTemplateFromTemplateID(FMassEntityTemplateID TemplateID)\n{\n\treturn nullptr;\n}\n\nFMassEntityTemplate& FMassEntityTemplateRegistry::CreateTemplate(const uint32 HashLookup, FMassEntityTemplateID TemplateID)\n{\n\tstatic FMassEntityTemplate Dummy;\n\treturn Dummy;\n}\n\nvoid FMassEntityTemplateRegistry::InitializeEntityTemplate(FMassEntityTemplate& InOutTemplate) const\n{}\n\n#undef LOCTEXT_NAMESPACE \n",
      "lines": 293
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Private\\MassEntityTraitBase.cpp",
      "extension": ".cpp",
      "size_bytes": 1362,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEntityTraitBase.h\"\n\n//----------------------------------------------------------------------//\n//  UMassEntityTraitBase\n//----------------------------------------------------------------------//\nvoid UMassEntityTraitBase::DestroyTemplate() const \n{\n\n}\n\nbool UMassEntityTraitBase::ValidateTemplate(const FMassEntityTemplateBuildContext& BuildContext, const UWorld& World, FAdditionalTraitRequirements& OutTraitRequirements) const\n{\n\treturn true;\n}\n\n#if WITH_EDITOR\nUMassEntityTraitBase::FOnNewTraitType UMassEntityTraitBase::OnNewTraitTypeEvent;\n\nvoid UMassEntityTraitBase::PostInitProperties()\n{\n\tSuper::PostInitProperties();\n\n\tif (HasAnyFlags(RF_ClassDefaultObject))\n\t{\n\t\tOnNewTraitTypeEvent.Broadcast(*this);\n\t}\n}\n\n#endif // WITH_EDITOR\n\n//-----------------------------------------------------------------------------\n// DEPRECATED\n//-----------------------------------------------------------------------------\nbool UMassEntityTraitBase::ValidateTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const\n{\n\tTArray<const UStruct*> AdditionalRequirements;\n\tFAdditionalTraitRequirements AdditionalTraitRequirementsWrapper(AdditionalRequirements);\n\treturn ValidateTemplate(BuildContext, World, AdditionalTraitRequirementsWrapper);\n}",
      "lines": 41
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Private\\MassEntityZoneGraphSpawnPointsGenerator.cpp",
      "extension": ".cpp",
      "size_bytes": 5559,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassEntityZoneGraphSpawnPointsGenerator.h\"\n#include \"ZoneGraphSubsystem.h\"\n#include \"ZoneGraphQuery.h\"\n#include \"MassSpawnerTypes.h\"\n#include \"Engine/World.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassGameplaySettings.h\"\n#include \"MassSpawnLocationProcessor.h\"\n#include \"Engine/World.h\"\n#include \"MassCommonUtils.h\"\n\nvoid UMassEntityZoneGraphSpawnPointsGenerator::Generate(UObject& QueryOwner, TConstArrayView<FMassSpawnedEntityType> EntityTypes, int32 Count, FFinishedGeneratingSpawnDataSignature& FinishedGeneratingSpawnPointsDelegate) const\n{\n\tif (Count <= 0)\n\t{\n\t\tFinishedGeneratingSpawnPointsDelegate.Execute(TArray<FMassEntitySpawnDataGeneratorResult>());\n\t\treturn;\n\t}\n\t\n\tconst UZoneGraphSubsystem* ZoneGraph = UWorld::GetSubsystem<UZoneGraphSubsystem>(QueryOwner.GetWorld());\n\tif (ZoneGraph == nullptr)\n\t{\n\t\tUE_VLOG_UELOG(&QueryOwner, LogMassSpawner, Error, TEXT(\"No zone graph subsystem found in world\"));\n\t\treturn;\n\t}\n\n\tTArray<FVector> Locations;\n\t\n\tconst FRandomStream RandomStream(UE::Mass::Utils::OverrideRandomSeedForTesting(GetRandomSelectionSeed()));\n\tconst TConstArrayView<FRegisteredZoneGraphData> RegisteredZoneGraphs = ZoneGraph->GetRegisteredZoneGraphData();\n\tif (RegisteredZoneGraphs.IsEmpty())\n\t{\n\t\tUE_VLOG_UELOG(&QueryOwner, LogMassSpawner, Error, TEXT(\"No zone graphs found\"));\n\t\treturn;\n\t}\n\n\tfor (const FRegisteredZoneGraphData& Registered : RegisteredZoneGraphs)\n\t{\n\t\tif (Registered.bInUse && Registered.ZoneGraphData)\n\t\t{\n\t\t\tGeneratePointsForZoneGraphData(*Registered.ZoneGraphData, Locations, RandomStream);\n\t\t}\n\t}\n\n\tif (Locations.IsEmpty())\n\t{\n\t\tUE_VLOG_UELOG(&QueryOwner, LogMassSpawner, Error, TEXT(\"No locations found on zone graphs\"));\n\t\treturn;\n\t}\n\n\t// Randomize them\n\tfor (int32 I = 0; I < Locations.Num(); ++I)\n\t{\n\t\tconst int32 J = RandomStream.RandHelper(Locations.Num());\n\t\tLocations.Swap(I, J);\n\t}\n\n\t// If we generated too many, shrink it.\n\tif (Locations.Num() > Count)\n\t{\n\t\tLocations.SetNum(Count);\n\t}\n\n\t// Build array of entity types to spawn.\n\tTArray<FMassEntitySpawnDataGeneratorResult> Results;\n\tBuildResultsFromEntityTypes(Count, EntityTypes, Results);\n\n\tconst int32 LocationCount = Locations.Num();\n\tint32 LocationIndex = 0;\n\n\t// Distribute points amongst the entities to spawn.\n\tfor (FMassEntitySpawnDataGeneratorResult& Result : Results)\n\t{\n\t\t// @todo: Make separate processors and pass the ZoneGraph locations directly.\n\t\tResult.SpawnDataProcessor = UMassSpawnLocationProcessor::StaticClass();\n\t\tResult.SpawnData.InitializeAs<FMassTransformsSpawnData>();\n\t\tFMassTransformsSpawnData& Transforms = Result.SpawnData.GetMutable<FMassTransformsSpawnData>();\n\n\t\tTransforms.Transforms.Reserve(Result.NumEntities);\n\t\tfor (int i = 0; i < Result.NumEntities; i++)\n\t\t{\n\t\t\tFTransform& Transform = Transforms.Transforms.AddDefaulted_GetRef();\n\t\t\tTransform.SetLocation(Locations[LocationIndex % LocationCount]);\n\t\t\tLocationIndex++;\n\t\t}\n\t}\n\n#if ENABLE_VISUAL_LOG\n\tUE_VLOG(this, LogMassSpawner, Log, TEXT(\"Spawning at %d locations\"), LocationIndex);\n\tif (GetDefault<UMassGameplaySettings>()->bLogSpawnLocations)\n\t{\n\t\tif (FVisualLogEntry* LogEntry = FVisualLogger::Get().GetLastEntryForObject(this))\n\t\t{\n\t\t\tFVisualLogShapeElement Element(TEXT(\"\"), FColor::Orange, /*Thickness*/20, LogMassSpawner.GetCategoryName());\n\n\t\t\tElement.Points.Reserve(LocationIndex);\n\t\t\tfor (const FMassEntitySpawnDataGeneratorResult& Result : Results)\n\t\t\t{\n\t\t\t\tconst FMassTransformsSpawnData& Transforms = Result.SpawnData.Get<FMassTransformsSpawnData>();\n\t\t\t\tfor (int i = 0; i < Result.NumEntities; i++)\n\t\t\t\t{\n\t\t\t\t\tElement.Points.Add(Transforms.Transforms[i].GetLocation());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tElement.Type = EVisualLoggerShapeElement::SinglePoint;\n\t\t\tElement.Verbosity = ELogVerbosity::Display;\n\t\t\tLogEntry->AddElement(Element);\n\t\t}\n\t}\n#endif // ENABLE_VISUAL_LOG\n\n\tFinishedGeneratingSpawnPointsDelegate.Execute(Results);\n}\n\nvoid UMassEntityZoneGraphSpawnPointsGenerator::GeneratePointsForZoneGraphData(const ::AZoneGraphData& ZoneGraphData, TArray<FVector>& Locations, const FRandomStream& RandomStream) const\n{\n\t// Avoid an infinite loop.\n\tif (MinGap == 0.0f && MaxGap == 0.0f)\n\t{\n\t\tUE_VLOG_UELOG(this, LogMassSpawner, Error, TEXT(\"You cannot set both Min Gap and Max Gap to 0.0f\"));\n\t\treturn;\t\t\t\t\t\t\n\t}\n\n\tconst FZoneGraphStorage &ZoneGraphStorage = ZoneGraphData.GetStorage();\n\t\n\t// Loop through all lanes\n\tfor (int32 LaneIndex = 0; LaneIndex < ZoneGraphStorage.Lanes.Num(); ++LaneIndex)\n\t{\n\t\tconst FZoneLaneData& Lane = ZoneGraphStorage.Lanes[LaneIndex];\n\t\tconst float LaneHalfWidth = Lane.Width / 2.0f;\n\t\tif (TagFilter.Pass(Lane.Tags))\n\t\t{\n\t\t\tfloat LaneLength = 0.0f;\n\t\t\tUE::ZoneGraph::Query::GetLaneLength(ZoneGraphStorage, LaneIndex, LaneLength);\n\n\t\t\tfloat Distance = static_cast<float>(RandomStream.FRandRange(MinGap, MaxGap)); // ..initially\n\t\t\twhile (Distance <= LaneLength)\n\t\t\t{\n\t\t\t\t// Add location at the center of this space.\n\t\t\t\tFZoneGraphLaneLocation LaneLocation;\n\t\t\t\tUE::ZoneGraph::Query::CalculateLocationAlongLane(ZoneGraphStorage, LaneIndex, Distance, LaneLocation);\n\t\t\t\tconst FVector Perp = LaneLocation.Direction ^ LaneLocation.Up;\n\t\t\t\tLocations.Add(LaneLocation.Position + Perp * RandomStream.FRandRange(-LaneHalfWidth, LaneHalfWidth));\n\n\t\t\t\t// Advance ahead past the space we just consumed, plus a random gap.\n\t\t\t\tDistance += static_cast<float>(RandomStream.FRandRange(MinGap, MaxGap));\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "lines": 153
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Private\\MassSpawner.cpp",
      "extension": ".cpp",
      "size_bytes": 18707,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSpawner.h\"\n#include \"Engine/Engine.h\"\n#include \"Engine/World.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Components/SceneComponent.h\"\n#include \"Components/BillboardComponent.h\"\n#include \"MassSpawnerTypes.h\"\n#include \"MassSpawnerSubsystem.h\"\n#include \"MassSimulationSubsystem.h\"\n#include \"EnvironmentQuery/EnvQuery.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassEntityConfigAsset.h\"\n#include \"MassEntityManager.h\"\n#include \"EngineUtils.h\"\n#include \"Engine/StreamableManager.h\"\n#include \"Engine/AssetManager.h\"\n#include \"MassSpawnLocationProcessor.h\"\n#include \"MassExecutor.h\"\n#include \"MassEntityUtils.h\"\n#if WITH_EDITOR\n#include \"Engine/Texture2D.h\"\n#endif\n\n\nnamespace UE::MassSpawner\n{\n\tfloat ScalabilitySpawnDensityMultiplier = 1.f;\n\tFAutoConsoleVariableRef CVarScalabilitySpawnDensityMultiplier(TEXT(\"ai.mass.scalability.SpawnDensityMultiplier\"), ScalabilitySpawnDensityMultiplier, TEXT(\"Spawn Density Multiplier, must be set before Mass Spawn Init\"), ECVF_Scalability);\n\n#if WITH_EDITOR\n\tstatic FAutoConsoleCommandWithWorld ForceSpawningCommand(\n\tTEXT(\"ai.mass.ForceSpawn\"),\n\tTEXT(\"Command to Force Spawn all mass entities generated by MassSpawners\"),\n\tFConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* World)\n\t{\n\t\tfor (TActorIterator<AActor> It(World, AMassSpawner::StaticClass()); It; ++It)\n\t\t{\n\t\t\tif (AMassSpawner* Spawner = Cast<AMassSpawner>(*It))\n\t\t\t{\n\t\t\t\tSpawner->DoSpawning();\n\t\t\t}\n\t\t}\n\t}));\n\n\tstatic FAutoConsoleCommandWithWorld ForceDespawningCommand(\n\tTEXT(\"ai.mass.ForceDespawn\"),\n\tTEXT(\"Command to Force Despawn all mass entities generated by MassSpawners\"),\n\tFConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* World)\n\t{\n\t\tfor (TActorIterator<AActor> It(World, AMassSpawner::StaticClass()); It; ++It)\n\t\t{\n\t\t\tif (AMassSpawner* Spawner = Cast<AMassSpawner>(*It))\n\t\t\t{\n\t\t\t\tSpawner->DoDespawning();\n\t\t\t}\n\t\t}\n\t}));\n\n\tstatic FAutoConsoleCommandWithWorld ResetSpawningCommand(\n\tTEXT(\"ai.mass.ResetSpawning\"),\n\tTEXT(\"Command to Force Despawn and Respawn all mass entities generated by MassSpawners\"),\n\tFConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* World)\n\t{\n\t\tfor (TActorIterator<AActor> It(World, AMassSpawner::StaticClass()); It; ++It)\n\t\t{\n\t\t\tif (AMassSpawner* Spawner = Cast<AMassSpawner>(*It))\n\t\t\t{\n\t\t\t\tSpawner->DoDespawning();\n\t\t\t\tSpawner->DoSpawning();\n\t\t\t}\n\t\t}\n\t}));\n#endif // WITH_EDITOR\n}\n\nAMassSpawner::AMassSpawner()\n{\n\tRootComponent = CreateDefaultSubobject<USceneComponent>(TEXT(\"SceneComp\"));\n\tRootComponent->Mobility = EComponentMobility::Static;\n\n#if WITH_EDITOR\n\tSpriteComponent = CreateEditorOnlyDefaultSubobject<UBillboardComponent>(TEXT(\"Sprite\"));\n\n\t// SpriteComponent can be null for editor builds running \"-game|server\"\n\tif (!IsRunningCommandlet() && SpriteComponent != nullptr)\n\t{\n\t\t// Structure to hold one-time initialization\n\t\tstruct FConstructorStatics\n\t\t{\n\t\t\tConstructorHelpers::FObjectFinderOptional<UTexture2D> IconTextureObject;\n\t\t\tFName MassSpawnerID;\n\t\t\tFText MassSpawnerName;\n\t\t\tFConstructorStatics()\n\t\t\t\t: IconTextureObject(TEXT(\"/MassGameplay/S_MassCrowd\"))\n\t\t\t\t, MassSpawnerID(TEXT(\"MassSpawner\"))\n\t\t\t\t, MassSpawnerName(NSLOCTEXT(\"SpriteCategory\", \"MassSpawner\", \"MassSpawner\"))\n\t\t\t{\n\t\t\t}\n\t\t};\n\t\tstatic FConstructorStatics ConstructorStatics;\n\t\t\n\t\tSpriteComponent->Sprite = ConstructorStatics.IconTextureObject.Get();\n\t\tSpriteComponent->SetRelativeScale3D(FVector(0.5f, 0.5f, 0.5f));\n\t\tSpriteComponent->SpriteInfo.Category = ConstructorStatics.MassSpawnerID;\n\t\tSpriteComponent->SpriteInfo.DisplayName = ConstructorStatics.MassSpawnerName;\n\t\tSpriteComponent->SetupAttachment(RootComponent);\n\t\tSpriteComponent->Mobility = EComponentMobility::Static;\n\t}\n#endif // WITH_EDITOR\n\n\tSetCanBeDamaged(false);\n\n#if UE_BUILD_SHIPPING || UE_BUILD_TEST\n\tSetActorHiddenInGame(true);\n#endif\n\n\tbAutoSpawnOnBeginPlay = true;\n\tbOverrideSchematics = false;\n}\n\nvoid AMassSpawner::PostLoad()\n{\n\tSuper::PostLoad();\n\n\tfor (FMassSpawnDataGenerator& SpawnPointsGenerator : SpawnDataGenerators)\n\t{\n\t\tif (SpawnPointsGenerator.GeneratorClass)\n\t\t{\n\t\t\tSpawnPointsGenerator.GeneratorInstance = NewObject<UMassEntitySpawnDataGeneratorBase>(this, SpawnPointsGenerator.GeneratorClass);\n\t\t\tSpawnPointsGenerator.GeneratorClass = nullptr;\n\t\t\tMarkPackageDirty();\n\t\t}\n\t}\n}\n\nvoid AMassSpawner::PostRegisterAllComponents()\n{\n\tSuper::PostRegisterAllComponents();\n\n\tif (HasAnyFlags(RF_ClassDefaultObject) == false)\n\t{\n\t\tUWorld* World = GetWorld();\n\t\tcheck(World);\n\n\n\t\t// This is a temp fix for streaming levels async loading MassSpawners after UMassSpawnerSubsystem::OnPostWorldInit, \n\t\t// in the long run we are going to need a better system for making sure all the entity templates are registered\n\t\t// on the clients before replication of Agents occurs. This is only required to be done for clients.\n\t\tif (GEngine->GetNetMode(GetWorld()) == NM_Client)\n\t\t{\n\t\t\tUMassSpawnerSubsystem* MassSpawnerSubsystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(World);\n\t\t\tif (MassSpawnerSubsystem)\n\t\t\t{\n\t\t\t\tRegisterEntityTemplates();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFWorldDelegates::OnPostWorldInitialization.AddUObject(this, &AMassSpawner::OnPostWorldInit);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid AMassSpawner::OnPostWorldInit(UWorld* World, const UWorld::InitializationValues)\n{\n\tif (World == GetWorld())\n\t{\n\t\tUMassSpawnerSubsystem* MassSpawnerSubsystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(World);\n\t\tcheck(MassSpawnerSubsystem);\n\n\t\tRegisterEntityTemplates();\n\n\t\tFWorldDelegates::OnPostWorldInitialization.Remove(OnPostWorldInitDelegateHandle);\n\t}\n}\n\nvoid AMassSpawner::BeginDestroy()\n{\n\tFWorldDelegates::OnPostWorldInitialization.Remove(OnPostWorldInitDelegateHandle);\n\n\tDoDespawning();\n\t\n\tif (StreamingHandle.IsValid() && StreamingHandle->IsActive())\n\t{\n\t\tStreamingHandle->CancelHandle();\n\t}\n\n\tSuper::BeginDestroy();\n}\n\nvoid AMassSpawner::BeginPlay()\n{\n\tcheck(GEngine);\n\n\tSuper::BeginPlay();\n\n\tconst ENetMode NetMode = GEngine->GetNetMode(GetWorld());\n\n\tif (bAutoSpawnOnBeginPlay && NetMode != NM_Client)\n\t{\n\t\tconst UMassSimulationSubsystem* MassSimulationSubsystem = UWorld::GetSubsystem<UMassSimulationSubsystem>(GetWorld());\n\t\tif (MassSimulationSubsystem == nullptr || MassSimulationSubsystem->IsSimulationStarted())\n\t\t{\n\t\t\tDoSpawning();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\n\t\t\tSimulationStartedHandle = UMassSimulationSubsystem::GetOnSimulationStarted().AddLambda([this](UWorld* InWorld)\n\t\t\t\t{\n\t\t\t\t\tUWorld* World = GetWorld();\n\n\t\t\t\t\tif (World == InWorld)\n\t\t\t\t\t{\n\t\t\t\t\t\tDoSpawning();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t}\n}\n\nvoid AMassSpawner::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tUMassSimulationSubsystem::GetOnSimulationStarted().Remove(SimulationStartedHandle);\n\n\tDoDespawning();\n\n\tSuper::EndPlay(EndPlayReason);\n}\n\n#if WITH_EDITOR\nvoid AMassSpawner::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)\n{\n\tstatic const FName EntityTypesName = GET_MEMBER_NAME_CHECKED(AMassSpawner, EntityTypes);\n\n\tSuper::PostEditChangeProperty(PropertyChangedEvent);\n\n\tif (PropertyChangedEvent.Property)\n\t{\n\t\tconst FName PropName = PropertyChangedEvent.Property->GetFName();\n\t\tif (PropName == EntityTypesName)\n\t\t{\n\t\t\t// TODO: Should optimize this, i.e. set a dirty flag and update only when needed.\n\t\t\tUMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(GetWorld());\n\t\t\tif (SpawnerSystem)\n\t\t\t{\n\t\t\t\tRegisterEntityTemplates();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid AMassSpawner::DEBUG_Spawn()\n{\n\tDoSpawning();\n}\n\nvoid AMassSpawner::DEBUG_Clear()\n{\n\tDoDespawning();\n}\n\n#endif // WITH_EDITOR\n\nvoid AMassSpawner::RegisterEntityTemplates()\n{\n\tUWorld* World = GetWorld();\n\tcheck(World);\n\tfor (FMassSpawnedEntityType& EntityType : EntityTypes)\n\t{\n\t\tif (const UMassEntityConfigAsset* EntityConfig = EntityType.GetEntityConfig())\n\t\t{\n\t\t\tEntityConfig->GetOrCreateEntityTemplate(*World);\n\t\t}\n\t}\n}\n\nvoid AMassSpawner::DoSpawning()\n{\n\t// no spawn point generators configured. Let user know and fall back to the spawner's location\n\tif (SpawnDataGenerators.Num() == 0)\n\t{\n\t\tUE_VLOG_UELOG(this, LogMassSpawner, Warning, TEXT(\"No Spawn Data Generators configured.\"));\n\t\treturn;\n\t}\n\t\n\tif (EntityTypes.Num() == 0)\n\t{\n\t\tUE_VLOG_UELOG(this, LogMassSpawner, Warning, TEXT(\"No EntityTypes configured.\"));\n\t\treturn;\n\t}\n\n\tAllGeneratedResults.Reset();\n\t\n\tfloat TotalProportion = 0.0f;\n\tfor (FMassSpawnDataGenerator& Generator : SpawnDataGenerators)\n\t{\n\t\tif (Generator.GeneratorInstance)\n\t\t{\n\t\t\tGenerator.bDataGenerated = false;\n\t\t\tTotalProportion += Generator.Proportion;\n\t\t}\n\t}\n\n\tif (TotalProportion <= 0.0f)\n\t{\n\t\tUE_VLOG_UELOG(this, LogMassSpawner, Error, TEXT(\"The total combined proportion of all the generator needs to be greater than 0.\"));\n\t\treturn;\n\t}\n\t\n\t// Check if it needs loading\n\tif (StreamingHandle.IsValid() && StreamingHandle->IsActive())\n\t{\n\t\t// @todo, instead of blindly canceling, we should remember what was asked to load with that handle and compare if more is needed?\n\t\tStreamingHandle->CancelHandle();\n\t}\n\tTArray<FSoftObjectPath> AssetsToLoad;\n\tfor (const FMassSpawnedEntityType& EntityType : EntityTypes)\n\t{\n\t\tif (!EntityType.IsLoaded())\n\t\t{\n\t\t\tAssetsToLoad.Add(EntityType.EntityConfig.ToSoftObjectPath());\n\t\t}\n\t}\n\t\n\tconst int32 TotalSpawnCount = GetSpawnCount();\n\t\n\tauto GenerateSpawningPoints = [this, TotalSpawnCount, TotalProportion]()\n\t{\n\t\tint32 SpawnCountRemaining = TotalSpawnCount;\n\t\tfloat ProportionRemaining = TotalProportion;\n\t\tfor (FMassSpawnDataGenerator& Generator : SpawnDataGenerators)\n\t\t{\n\t\t\tif (Generator.Proportion == 0.0f || ProportionRemaining <= 0.0f)\n\t\t\t{\n\t\t\t\t// If there's nothing to spawn, mark the generator done as OnSpawnDataGenerationFinished() will wait for all generators to complete before the actual spawning.\n\t\t\t\tGenerator.bDataGenerated = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (Generator.GeneratorInstance)\n\t\t\t{\n\t\t\t\tconst float ProportionRatio = FMath::Min(Generator.Proportion / ProportionRemaining, 1.0f);\n\t\t\t\tconst int32 SpawnCount = FMath::CeilToInt(static_cast<float>(SpawnCountRemaining) * ProportionRatio);\n\t\t\t\t\n\t\t\t\tFFinishedGeneratingSpawnDataSignature Delegate = FFinishedGeneratingSpawnDataSignature::CreateUObject(this, &AMassSpawner::OnSpawnDataGenerationFinished, &Generator);\n\t\t\t\tGenerator.GeneratorInstance->Generate(*this, EntityTypes, SpawnCount, Delegate);\n\t\t\t\tSpawnCountRemaining -= SpawnCount;\n\t\t\t\tProportionRemaining -= Generator.Proportion;\n\t\t\t}\n\t\t}\n\t};\n\t\n\tif (AssetsToLoad.Num())\n\t{\n\t\tFStreamableManager& StreamableManager = UAssetManager::GetStreamableManager();\n\t\tStreamingHandle = StreamableManager.RequestAsyncLoad(AssetsToLoad, GenerateSpawningPoints);\n\t}\n\telse\n\t{\n\t\tGenerateSpawningPoints();\n\t}\n}\n\nvoid AMassSpawner::OnSpawnDataGenerationFinished(TConstArrayView<FMassEntitySpawnDataGeneratorResult> Results, FMassSpawnDataGenerator* FinishedGenerator)\n{\n\t// @todo: this can be potentially expensive copy for the instanced structs, could there be a way to use move gere instead?\n\tAllGeneratedResults.Append(Results.GetData(), Results.Num());\n\n\tbool bAllSpawnPointsGenerated = true;\n\tbool bFoundFinishedGenerator = false;\n\tfor (FMassSpawnDataGenerator& Generator : SpawnDataGenerators)\n\t{\n\t\tif (&Generator == FinishedGenerator)\n\t\t{\n\t\t\tGenerator.bDataGenerated = true;\n\t\t\tbFoundFinishedGenerator = true;\n\t\t}\n\n\t\tbAllSpawnPointsGenerated &= Generator.bDataGenerated;\n\t}\n\n\tcheckf(bFoundFinishedGenerator, TEXT(\"Something went wrong, we are receiving a callback on an unknow spawn point generator\"));\n\t\n\tif (bAllSpawnPointsGenerated)\n\t{\n\t\tSpawnGeneratedEntities(AllGeneratedResults);\n\t\tAllGeneratedResults.Reset();\n\t}\n}\n\nint32 AMassSpawner::GetSpawnCount() const\n{\n\tconst float FinalSpawningCountScale = SpawningCountScale * UE::MassSpawner::ScalabilitySpawnDensityMultiplier;\n\treturn static_cast<int32>(FinalSpawningCountScale * static_cast<float>(Count));\n}\n\nUMassProcessor* AMassSpawner::GetPostSpawnProcessor(TSubclassOf<UMassProcessor> ProcessorClass)\n{\n\tif (!ProcessorClass)\n\t{\n\t\treturn nullptr;\n\t}\n\n\tTObjectPtr<UMassProcessor>* const Initializer = PostSpawnProcessors.FindByPredicate([ProcessorClass](const UMassProcessor* Processor)\n\t\t{\n\t\t\treturn Processor && Processor->GetClass() == ProcessorClass;\n\t\t}\n\t);\n\n\tif (Initializer == nullptr)\n\t{\n\t\tUMassProcessor* NewInitializer = NewObject<UMassProcessor>(this, ProcessorClass);\n\t\tNewInitializer->Initialize(*this);\n\t\tPostSpawnProcessors.Add(NewInitializer);\n\t\treturn NewInitializer;\n\t}\n\n\treturn *Initializer;\n}\n\nvoid AMassSpawner::SpawnGeneratedEntities(TConstArrayView<FMassEntitySpawnDataGeneratorResult> Results)\n{\n\tUMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(GetWorld());\n\tif (SpawnerSystem == nullptr)\n\t{\n\t\tUE_VLOG_UELOG(this, LogMassSpawner, Error, TEXT(\"UMassSpawnerSubsystem missing while trying to spawn entities\"));\n\t\treturn;\n\t}\n\n\tUWorld* World = GetWorld();\n\tcheck(World);\n\n\tint32 TotalNum = 0;\n\tconst int32 StartIndex = AllSpawnedEntities.Num();\n\n\tfor (const FMassEntitySpawnDataGeneratorResult& Result : Results)\n\t{\n\t\tif (Result.NumEntities <= 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tcheck(EntityTypes.IsValidIndex(Result.EntityConfigIndex));\n\t\tcheck(Result.SpawnDataProcessor != nullptr);\n\t\t\n\t\tconst FMassSpawnedEntityType& EntityType = EntityTypes[Result.EntityConfigIndex];\n\n\t\tif (const UMassEntityConfigAsset* EntityConfig = EntityType.GetEntityConfig())\n\t\t{\n\t\t\tconst FMassEntityTemplate& EntityTemplate = EntityConfig->GetOrCreateEntityTemplate(*World);\n\t\t\tif (EntityTemplate.IsValid())\n\t\t\t{\n\t\t\t\tFSpawnedEntities& SpawnedEntities = AllSpawnedEntities.AddDefaulted_GetRef();\n\t\t\t\tSpawnedEntities.TemplateID = EntityTemplate.GetTemplateID();\n\t\t\t\tSpawnerSystem->SpawnEntities(EntityTemplate.GetTemplateID(), Result.NumEntities, Result.SpawnData, Result.SpawnDataProcessor, SpawnedEntities.Entities);\n\t\t\t\tTotalNum += SpawnedEntities.Entities.Num();\n\t\t\t}\n\t\t}\n\t}\n\n\t// Run post spawn processors only on the freshly spawned entities.\n\tif (TotalNum)\n\t{\n\t\tTArray<UMassProcessor*> Processors;\n\t\tTSet<TSubclassOf<UMassProcessor>> AddedProcessorClasses;\n\n\t\tfor (const FMassEntitySpawnDataGeneratorResult& Result : Results)\n\t\t{\n\t\t\tfor (const TSubclassOf<UMassProcessor>& ProcessorClass : Result.PostSpawnProcessors)\n\t\t\t{\n\t\t\t\tif (AddedProcessorClasses.Contains(ProcessorClass) == false)\n\t\t\t\t{\n\t\t\t\t\tif (UMassProcessor* Processor = GetPostSpawnProcessor(ProcessorClass))\n\t\t\t\t\t{\n\t\t\t\t\t\tProcessors.Add(Processor);\n\t\t\t\t\t}\n\t\t\t\t\tAddedProcessorClasses.Add(ProcessorClass);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Processors.Num() > 0)\n\t\t{\n\t\t\tFMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(*World);\n\t\t\tFMassProcessingContext ProcessingContext(EntityManager, /*TimeDelta=*/0.0f);\n\n\t\t\t// gather freshly spawned entities\n\t\t\tTArray<FMassEntityHandle> AllEntities;\n\t\t\tAllEntities.Reserve(TotalNum);\n\t\t\t\n\t\t\tfor (int32 Index = StartIndex; Index < AllSpawnedEntities.Num(); ++Index)\n\t\t\t{\n\t\t\t\tAllEntities.Append(AllSpawnedEntities[Index].Entities);\n\t\t\t}\n\n\t\t\t// create entity collections and run Processors on them. \n\t\t\tTArray<FMassArchetypeEntityCollection> EntityCollections;\n\t\t\tUE::Mass::Utils::CreateEntityCollections(EntityManager, AllEntities, FMassArchetypeEntityCollection::NoDuplicates, EntityCollections);\n\t\t\tUE::Mass::Executor::RunProcessorsView(Processors, ProcessingContext, EntityCollections);\n\t\t}\n\t}\n\n\tOnSpawningFinishedEvent.Broadcast();\n}\n\nvoid AMassSpawner::DoDespawning()\n{\n\tif (AllSpawnedEntities.IsEmpty())\n\t{\n\t\treturn;\n\t}\n\t\n\tUMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(GetWorld());\n\tif (SpawnerSystem == nullptr)\n\t{\n\t\tUE_LOG(LogMassSpawner, Error, TEXT(\"UMassSpawnerSubsystem missing while trying to despawn entities\"));\n\t\treturn;\n\t}\n\n\tfor (const FSpawnedEntities& SpawnedEntities : AllSpawnedEntities)\n\t{\n\t\tSpawnerSystem->DestroyEntities(SpawnedEntities.Entities);\n\t}\n\tAllSpawnedEntities.Reset();\n\n\tOnDespawningFinishedEvent.Broadcast();\n}\n\nvoid AMassSpawner::DoDespawning(TConstArrayView<FMassEntityHandle> EntitiesToIgnore)\n{\n\t// Remove EntitiesToIgnore from SpawnedEntities so they get skipped by DoDespawning() and add to AllEntitiesToKeep\n\t// to restore after.\n\tTArray<FSpawnedEntities> AllEntitiesToKeep;\n\tfor (FSpawnedEntities& SpawnedEntities : AllSpawnedEntities)\n\t{\n\t\tFSpawnedEntities* EntitiesToKeep = nullptr;\n\t\tfor (const FMassEntityHandle& EntityToIgnore : EntitiesToIgnore)\n\t\t{\n\t\t\tif (SpawnedEntities.Entities.RemoveSingleSwap(EntityToIgnore, EAllowShrinking::No))\n\t\t\t{\n\t\t\t\tif (!EntitiesToKeep)\n\t\t\t\t{\n\t\t\t\t\tEntitiesToKeep = &AllEntitiesToKeep.AddDefaulted_GetRef();\n\t\t\t\t\tEntitiesToKeep->TemplateID = SpawnedEntities.TemplateID;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tEntitiesToKeep->Entities.Add(EntityToIgnore);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Despawn the remaining entities in AllSpawnedEntities\n\tDoDespawning();\n\n\t// Restore AllEntitiesToKeep to AllSpawnedEntities so they remain tracked\n\tAllSpawnedEntities = AllEntitiesToKeep;\n}\n\nbool AMassSpawner::DespawnEntity(const FMassEntityHandle Entity)\n{\n\tUMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(GetWorld());\n\tif (SpawnerSystem == nullptr)\n\t{\n\t\tUE_LOG(LogMassSpawner, Error, TEXT(\"UMassSpawnerSubsystem missing while trying to despawn a single entity\"));\n\t\treturn false;\n\t}\n\n\tfor (FSpawnedEntities& SpawnedEntities : AllSpawnedEntities)\n\t{\n\t\tconst int32 Index = SpawnedEntities.Entities.Find(Entity);\n\t\tif (Index != INDEX_NONE)\n\t\t{\n\t\t\tSpawnerSystem->DestroyEntities(MakeArrayView(&Entity, 1));\n\t\t\tSpawnedEntities.Entities.RemoveAtSwap(Index, EAllowShrinking::No);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint32 AMassSpawner::GetCount() const\n{\n\treturn Count;\n}\n\nfloat AMassSpawner::GetSpawningCountScale() const\n{\n\treturn SpawningCountScale;\n}\n\nvoid AMassSpawner::ClearTemplates()\n{\n\tUWorld* World = GetWorld();\n\tcheck(World);\n\n\tfor (FMassSpawnedEntityType& EntityType : EntityTypes)\n\t{\n\t\tif (const UMassEntityConfigAsset* EntityConfig = EntityType.GetEntityConfig())\n\t\t{\n\t\t\tEntityConfig->DestroyEntityTemplate(*World);\n\t\t}\n\t}\n}\n\nvoid AMassSpawner::UnloadConfig()\n{\n\t// Clear all templates that were created by the config\n\tClearTemplates();\n\tfor (FMassSpawnedEntityType& EntityType : EntityTypes)\n\t{\n\t\tEntityType.UnloadEntityConfig();\n\t}\n\n\tif (StreamingHandle.IsValid() && StreamingHandle->IsActive())\n\t{\n\t\tStreamingHandle->CancelHandle();\n\t}\n}\n",
      "lines": 621
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Private\\MassSpawnerModule.cpp",
      "extension": ".cpp",
      "size_bytes": 839,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"CoreMinimal.h\"\n#include \"MassSpawnerTypes.h\"\n#include \"IMassSpawnerModule.h\"\n\n\nDEFINE_LOG_CATEGORY(LogMassSpawner);\n\nclass FMassSpawnerModule : public IMassSpawnerModule\n{\n\t/** IModuleInterface implementation */\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nIMPLEMENT_MODULE(FMassSpawnerModule, MassSpawner)\n\n\n\nvoid FMassSpawnerModule::StartupModule()\n{\n\t// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)\n}\n\n\nvoid FMassSpawnerModule::ShutdownModule()\n{\n\t// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n\t// we call this function before unloading the module.\n}\n\n\n\n",
      "lines": 34
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Private\\MassSpawnerSubsystem.cpp",
      "extension": ".cpp",
      "size_bytes": 6509,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSpawnerSubsystem.h\"\n#include \"MassSpawnerTypes.h\"\n#include \"MassEntityTemplate.h\"\n#include \"MassEntityManager.h\"\n#include \"MassEntityTemplateRegistry.h\"\n#include \"Engine/World.h\"\n#include \"MassExecutor.h\"\n#include \"StructUtils/InstancedStruct.h\"\n#include \"VisualLogger/VisualLogger.h\"\n#include \"MassSpawner.h\"\n#include \"MassObserverProcessor.h\"\n#include \"ProfilingDebugging/CpuProfilerTrace.h\"\n#include \"MassSimulationSubsystem.h\"\n#include \"MassProcessor.h\"\n#include \"MassEntityUtils.h\"\n\n//----------------------------------------------------------------------//\n//  UMassSpawnerSubsystem\n//----------------------------------------------------------------------//\nUMassSpawnerSubsystem::UMassSpawnerSubsystem()\n\t: TemplateRegistryInstance(this)\n{\n\n}\n\nvoid UMassSpawnerSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\t\n\tSuper::Initialize(Collection);\n\n\t// making sure UMassSimulationSubsystem gets created before the MassSpawnerSubsystem, since UMassSimulationSubsystem\n\t// is where the EntityManager gets created for the runtime MassGameplay simulation\n\tCollection.InitializeDependency<UMassSimulationSubsystem>();\n\n\tUWorld* World = GetWorld();\n\tcheck(World);\n\tEntityManager = UE::Mass::Utils::GetEntityManagerChecked(*World).AsShared();\n\tTemplateRegistryInstance.Initialize(EntityManager);\n}\n\nvoid UMassSpawnerSubsystem::Deinitialize() \n{\n\tEntityManager.Reset();\n\tTemplateRegistryInstance.ShutDown();\n\n\tSuper::Deinitialize();\n}\n\nvoid UMassSpawnerSubsystem::SpawnEntities(const FMassEntityTemplate& EntityTemplate, const uint32 NumberToSpawn, TArray<FMassEntityHandle>& OutEntities)\n{\n\tcheck(EntityManager);\n\tcheck(EntityTemplate.IsValid());\n\n\tif (NumberToSpawn == 0)\n\t{\n\t\tUE_VLOG(this, LogMassSpawner, Warning, TEXT(\"Trying to spawn 0 entities. This would cause inefficiency. Bailing out with result FALSE.\"));\n\t\treturn;\n\t}\n\n\tDoSpawning(EntityTemplate, NumberToSpawn, FStructView(), TSubclassOf<UMassProcessor>(), OutEntities);\n}\n\nvoid UMassSpawnerSubsystem::SpawnEntities(FMassEntityTemplateID TemplateID, const uint32 NumberToSpawn, FConstStructView SpawnData, TSubclassOf<UMassProcessor> InitializerClass, TArray<FMassEntityHandle>& OutEntities)\n{\n\tcheck(TemplateID.IsValid());\n\n\tconst TSharedRef<FMassEntityTemplate>* EntityTemplate = TemplateRegistryInstance.FindTemplateFromTemplateID(TemplateID);\n\tcheckf(EntityTemplate, TEXT(\"SpawnEntities: TemplateID must have been registered!\"));\n\n\tDoSpawning(EntityTemplate->Get(), NumberToSpawn, SpawnData, InitializerClass, OutEntities);\n}\n\nvoid UMassSpawnerSubsystem::DestroyEntities(TConstArrayView<FMassEntityHandle> Entities)\n{\n\tTRACE_CPUPROFILER_EVENT_SCOPE_STR(\"MassSpawnerSubsystem_DestroyEntities\")\n\n\tcheck(EntityManager);\n\tcheckf(!EntityManager->IsProcessing()\n\t\t, TEXT(\"%s called while MassEntity processing in progress. This is unsupported and dangerous!\"), ANSI_TO_TCHAR(__FUNCTION__));\n\n\tUWorld* World = GetWorld();\n\tcheck(World);\n\n\n\tTArray<FMassArchetypeEntityCollection> EntityCollections;\n\tUE::Mass::Utils::CreateEntityCollections(*EntityManager.Get(), Entities, FMassArchetypeEntityCollection::NoDuplicates, EntityCollections);\n\tEntityManager->BatchDestroyEntityChunks(EntityCollections);\n}\n\nUMassProcessor* UMassSpawnerSubsystem::GetSpawnDataInitializer(TSubclassOf<UMassProcessor> InitializerClass)\n{\t\n\tif (!InitializerClass)\n\t{\n\t\treturn nullptr;\n\t}\n\n\tTObjectPtr<UMassProcessor>* const Initializer = SpawnDataInitializers.FindByPredicate([InitializerClass](const UMassProcessor* Processor)\n\t\t{\n\t\t\treturn Processor && Processor->GetClass() == InitializerClass;\n\t\t}\n\t);\n\n\tif (Initializer == nullptr)\n\t{\n\t\tUMassProcessor* NewInitializer = NewObject<UMassProcessor>(this, InitializerClass);\n\t\tNewInitializer->Initialize(*this);\n\t\tSpawnDataInitializers.Add(NewInitializer);\n\t\treturn NewInitializer;\n\t}\n\n\treturn *Initializer;\n}\n\nvoid UMassSpawnerSubsystem::DoSpawning(const FMassEntityTemplate& EntityTemplate, const int32 NumToSpawn, FConstStructView SpawnData, TSubclassOf<UMassProcessor> InitializerClass, TArray<FMassEntityHandle>& OutEntities)\n{\n\tcheck(EntityManager);\n\tcheck(EntityTemplate.GetArchetype().IsValid());\n\tUE_VLOG(this, LogMassSpawner, Log, TEXT(\"Spawning with EntityTemplate:\\n%s\"), *EntityTemplate.DebugGetDescription(EntityManager.Get()));\n\n\tif (NumToSpawn <= 0)\n\t{\n\t\tUE_VLOG(this, LogMassSpawner, Warning, TEXT(\"%s: Trying to spawn %d entities. Ignoring.\"), ANSI_TO_TCHAR(__FUNCTION__), NumToSpawn);\n\t\treturn;\n\t}\n\n\tLLM_SCOPE_BYNAME(TEXT(\"Mass/Spawner\"))\n\t//TRACE_CPUPROFILER_EVENT_SCOPE_STR(\"MassSpawnerSubsystem DoSpawning\");\n\n\t// 1. Create required number of entities with EntityTemplate.Archetype\n\tTArray<FMassEntityHandle> SpawnedEntities;\n\tTSharedRef<FMassEntityManager::FEntityCreationContext> CreationContext\n\t\t= EntityManager->BatchCreateEntities(EntityTemplate.GetArchetype(), EntityTemplate.GetSharedFragmentValues(), NumToSpawn, SpawnedEntities);\n\n\t// 2. Copy data from FMassEntityTemplate.Fragments.\n\t//\t\ta. @todo, could be done as part of creation?\n\tTConstArrayView<FInstancedStruct> FragmentInstances = EntityTemplate.GetInitialFragmentValues();\n\tEntityManager->BatchSetEntityFragmentsValues(CreationContext->GetEntityCollections(), FragmentInstances);\n\t\n\t// 3. Run SpawnDataInitializer, if set. This is a special type of processor that operates on the entities to initialize them.\n\t// e.g., will run UInstancedActorsInitializerProcessor for Mass InstancedActors\n\tUMassProcessor* SpawnDataInitializer = SpawnData.IsValid() \n\t\t? GetSpawnDataInitializer(InitializerClass) \n\t\t: nullptr;\n\n\tif (SpawnDataInitializer)\n\t{\n\t\tFMassProcessingContext ProcessingContext(EntityManager, /*TimeDelta=*/0.0f);\n\t\tProcessingContext.AuxData = SpawnData;\n\t\tUE::Mass::Executor::RunProcessorsView(MakeArrayView(&SpawnDataInitializer, 1), ProcessingContext, CreationContext->GetEntityCollections());\n\t}\n\n\tOutEntities.Append(MoveTemp(SpawnedEntities));\n\t// 4. \"OnEntitiesCreated\" notifies will be sent out once the CreationContext gets destroyed (via its destructor).\n}\n\nconst FMassEntityTemplate* UMassSpawnerSubsystem::GetMassEntityTemplate(FMassEntityTemplateID TemplateID) const\n{\n\tcheck(TemplateID.IsValid());\n\tconst TSharedRef<FMassEntityTemplate>* TemplateFound = TemplateRegistryInstance.FindTemplateFromTemplateID(TemplateID);\n\treturn TemplateFound ? &TemplateFound->Get() : nullptr;\n}\n",
      "lines": 162
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Private\\MassSpawnerTypes.cpp",
      "extension": ".cpp",
      "size_bytes": 1704,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSpawnerTypes.h\"\n#include \"MassEntityConfigAsset.h\"\n#include \"Serialization/ArchiveObjectCrc32.h\"\n#include \"MassEntityTraitBase.h\"\n\nnamespace UE::MassSpawner\n{\n\tuint32 HashTraits(TConstArrayView<UMassEntityTraitBase*> CombinedTraits)\n\t{\n\t\tclass FArchiveObjectCRC32AgentConfig : public FArchiveObjectCrc32\n\t\t{\n\t\tpublic:\n\t\t\tvirtual bool ShouldSkipProperty(const FProperty* InProperty) const override\n\t\t\t{\n\t\t\t\tcheck(InProperty);\n\t\t\t\treturn FArchiveObjectCrc32::ShouldSkipProperty(InProperty) || InProperty->HasAllPropertyFlags(CPF_Transient);\n\t\t\t}\n\t\t};\n\n\t\tuint32 CRC = 0;\n\t\tfor (UMassEntityTraitBase* Trait : CombinedTraits)\n\t\t{\n\t\t\tFArchiveObjectCRC32AgentConfig Archive;\n\t\t\tCRC = Archive.Crc32(Trait, CRC);\n\t\t\t// @todo this piece is here to avoid an easy to repro hash class - all one needs to do is to add a \n\t\t\t// trait subclass that sets different default values\n\t\t\tcheck(Trait && Trait->GetClass());\n\t\t\tCRC = HashCombine(CRC, GetTypeHash(Trait->GetClass()->GetName()));\n\t\t}\n\t\treturn CRC;\n\t}\n} // UE::MassSpawner\n\n//-----------------------------------------------------------------------------\n// FMassSpawnedEntityType\n//-----------------------------------------------------------------------------\nconst UMassEntityConfigAsset* FMassSpawnedEntityType::GetEntityConfig() const\n{\n\tif (EntityConfigPtr == nullptr)\n\t{\n\t\tEntityConfigPtr = EntityConfig.LoadSynchronous();\n\t}\n\treturn EntityConfigPtr;\n}\n\nUMassEntityConfigAsset* FMassSpawnedEntityType::GetEntityConfig()\n{\n\tif (EntityConfigPtr == nullptr)\n\t{\n\t\tEntityConfigPtr = EntityConfig.LoadSynchronous();\n\t}\n\treturn EntityConfigPtr;\n}",
      "lines": 55
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Private\\MassSpawnLocationProcessor.cpp",
      "extension": ".cpp",
      "size_bytes": 3741,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassSpawnLocationProcessor.h\"\n#include \"MassCommonFragments.h\"\n#include \"MassEntityManager.h\"\n#include \"MassExecutionContext.h\"\n#include \"MassSpawnerTypes.h\"\n#include \"MassCommonUtils.h\"\n#include \"Engine/World.h\"\n#include \"VisualLogger/VisualLogger.h\"\n\n//----------------------------------------------------------------------//\n// UMassSpawnLocationProcessor \n//----------------------------------------------------------------------//\nUMassSpawnLocationProcessor::UMassSpawnLocationProcessor()\n\t: EntityQuery(*this)\n{\n\tbAutoRegisterWithProcessingPhases = false;\n\tRandomStream.Initialize(UE::Mass::Utils::GenerateRandomSeed());\n}\n\nvoid UMassSpawnLocationProcessor::ConfigureQueries()\n{\n\tEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);\n}\n\nvoid UMassSpawnLocationProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)\n{\n\tif (!ensure(Context.ValidateAuxDataType<FMassTransformsSpawnData>()))\n\t{\n\t\tUE_VLOG_UELOG(this, LogMass, Log, TEXT(\"Execution context has invalid AuxData or it's not FMassSpawnAuxData. Entity transforms won't be initialized.\"));\n\t\treturn;\n\t}\n\n\tconst UWorld* World = EntityManager.GetWorld();\n\tcheck(World);\n\n\tconst ENetMode NetMode = World->GetNetMode();\n\n\tFMassTransformsSpawnData& AuxData = Context.GetMutableAuxData().GetMutable<FMassTransformsSpawnData>();\n\tTArray<FTransform>& Transforms = AuxData.Transforms;\n\n\tconst int32 NumSpawnTransforms = Transforms.Num();\n\tif (NumSpawnTransforms == 0)\n\t{\n\t\tUE_VLOG_UELOG(this, LogMass, Error, TEXT(\"No spawn transforms provided. Entity transforms won't be initialized.\"));\n\t\treturn;\n\t}\n\n\tint32 NumRequiredSpawnTransforms = 0;\n\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [&NumRequiredSpawnTransforms](const FMassExecutionContext& Context)\n\t\t{\n\t\t\tNumRequiredSpawnTransforms += Context.GetNumEntities();\n\t\t});\n\n\tconst int32 NumToAdd = NumRequiredSpawnTransforms - NumSpawnTransforms;\n\tif (NumToAdd > 0)\n\t{\n\t\tUE_VLOG_UELOG(this, LogMass, Warning,\n\t\t\tTEXT(\"Not enough spawn locations provided (%d) for all entities (%d). Existing locations will be reused randomly to fill the %d missing positions.\"),\n\t\t\tNumSpawnTransforms, NumRequiredSpawnTransforms, NumToAdd);\n\n\t\tTransforms.AddUninitialized(NumToAdd);\n\t\tfor (int i = 0; i < NumToAdd; ++i)\n\t\t{\n\t\t\tTransforms[NumSpawnTransforms + i] = Transforms[RandomStream.RandRange(0, NumSpawnTransforms - 1)];\n\t\t}\n\t}\n\n\tif (AuxData.bRandomize && !UE::Mass::Utils::IsDeterministic())\n\t{\n\t\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [&Transforms, this](FMassExecutionContext& Context)\n\t\t\t{\n\t\t\t\tconst TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();\n\t\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\t\tfor (int32 i = 0; i < NumEntities; ++i)\n\t\t\t\t{\n\t\t\t\t\tconst int32 AuxIndex = RandomStream.RandRange(0, Transforms.Num() - 1);\n\t\t\t\t\tLocationList[i].GetMutableTransform() = Transforms[AuxIndex];\n\t\t\t\t\tTransforms.RemoveAtSwap(AuxIndex, EAllowShrinking::No);\n\t\t\t\t}\n\t\t\t});\n\t}\n\telse\n\t{\n\t\tint32 NextTransformIndex = 0;\n\t\tEntityQuery.ForEachEntityChunk(EntityManager, Context, [&Transforms, &NextTransformIndex, this](FMassExecutionContext& Context)\n\t\t\t{\n\t\t\t\tconst int32 NumEntities = Context.GetNumEntities();\n\t\t\t\tTArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();\n\t\t\t\tcheck(NextTransformIndex + NumEntities <= Transforms.Num());\n\t\n\t\t\t\tFMemory::Memcpy(LocationList.GetData(), &Transforms[NextTransformIndex], NumEntities * LocationList.GetTypeSize());\n\t\t\t\tNextTransformIndex += NumEntities;\n\t\t\t});\n\t}\n}\n",
      "lines": 97
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\Private\\MassTranslator.cpp",
      "extension": ".cpp",
      "size_bytes": 592,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"MassTranslator.h\"\n#include \"MassCommonTypes.h\"\n\n//----------------------------------------------------------------------//\n//  UMassTranslator\n//----------------------------------------------------------------------//\nUMassTranslator::UMassTranslator()\n{\n\tbAutoRegisterWithProcessingPhases = true;\n\tExecutionFlags = (int32)EProcessorExecutionFlags::All;\n}\n\nvoid UMassTranslator::AddRequiredTagsToQuery(FMassEntityQuery& EntityQuery)\n{\n\tEntityQuery.AddTagRequirements<EMassFragmentPresence::All>(RequiredTags);\n}\n",
      "lines": 18
    },
    {
      "file_path": "MassCrowd\\MassCrowd.Build.cs",
      "extension": ".cs",
      "size_bytes": 894,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassCrowd: ModuleRules\n\t{\n\t\tpublic MassCrowd(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"AIModule\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"MassActors\",\n\t\t\t\t\t\"MassCommon\",\n\t\t\t\t\t\"MassLOD\",\n\t\t\t\t\t\"MassMovement\",\n\t\t\t\t\t\"MassNavigation\",\n\t\t\t\t\t\"MassZoneGraphNavigation\",\n\t\t\t\t\t\"MassReplication\",\n\t\t\t\t\t\"MassAIReplication\",\n\t\t\t\t\t\"MassSignals\",\n\t\t\t\t\t\"MassSimulation\",\n\t\t\t\t\t\"MassSpawner\",\n\t\t\t\t\t\"MassRepresentation\",\n\t\t\t\t\t\"MassAIBehavior\",\n\t\t\t\t\t\"NetCore\",\n\t\t\t\t\t\"StateTreeModule\",\n\t\t\t\t\t\"ZoneGraph\",\n\t\t\t\t\t\"ZoneGraphAnnotations\",\n\t\t\t\t\t\"ZoneGraphDebug\"\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tSetupIrisSupport(Target);\n\t\t}\n\t}\n}",
      "lines": 42
    },
    {
      "file_path": "MassEntity\\MassEntity.Build.cs",
      "extension": ".cs",
      "size_bytes": 1000,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nusing UnrealBuildTool;\n\npublic class MassEntity : ModuleRules\n{\n\tpublic MassEntity(ReadOnlyTargetRules Target) : base(Target)\n\t{\n\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\tUnsafeTypeCastWarningLevel = WarningLevel.Warning;\n\n\t\tPublicDependencyModuleNames.AddRange(\n\t\t\tnew string[] {\n\t\t\t\t\"Core\",\n\t\t\t\t\"CoreUObject\",\n\t\t\t\t\"Engine\",\n\t\t\t\t\"DeveloperSettings\",\n\t\t\t}\n\t\t);\n\n\t\tif (Target.bBuildEditor || Target.bCompileAgainstEditor)\n\t\t{\n\t\t\tPrivateDependencyModuleNames.Add(\"UnrealEd\");\n\t\t\tPrivateDependencyModuleNames.Add(\"EditorSubsystem\");\n\t\t}\n\n\t\tif (Target.Configuration != UnrealTargetConfiguration.Shipping\n\t\t\t&& Target.Configuration != UnrealTargetConfiguration.Test)\n\t\t{\n\t\t\t// pulling this one in for the testableEnsureMsgf\n\t\t\tPrivateDependencyModuleNames.Add(\"AITestSuite\");\n\t\t}\n\n\t\tif (Target.bBuildDeveloperTools)\n\t\t{\n\t\t\tDynamicallyLoadedModuleNames.Add(\"MassEntityTestSuite\");\n\t\t}\n\t}\n}\n",
      "lines": 40
    },
    {
      "file_path": "MassAI\\MassAIBehavior\\MassAIBehavior.Build.cs",
      "extension": ".cs",
      "size_bytes": 1125,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassAIBehavior : ModuleRules\n\t{\n\t\tpublic MassAIBehavior(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tUnsafeTypeCastWarningLevel = WarningLevel.Warning;\n\n\t\t\tPrivateIncludePathModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"AIModule\"\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"GameplayTags\",\n\t\t\t\t\t\"MassActors\",\n\t\t\t\t\t\"MassCommon\",\n\t\t\t\t\t\"MassLOD\",\n\t\t\t\t\t\"MassMovement\",\n\t\t\t\t\t\"MassNavigation\",\n\t\t\t\t\t\"MassZoneGraphNavigation\",\n\t\t\t\t\t\"MassRepresentation\",\n\t\t\t\t\t\"MassSignals\",\n\t\t\t\t\t\"MassSmartObjects\",\n\t\t\t\t\t\"MassSpawner\",\n\t\t\t\t\t\"MassSimulation\",\n\t\t\t\t\t\"NavigationSystem\",\n\t\t\t\t\t\"SmartObjectsModule\",\n\t\t\t\t\t\"StateTreeModule\",\n\t\t\t\t\t\"ZoneGraph\",\n\t\t\t\t\t\"ZoneGraphAnnotations\",\n\t\t\t\t\t\"MassGameplayExternalTraits\"\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (Target.bBuildEditor == true)\n\t\t\t{\n\t\t\t\tPrivateDependencyModuleNames.Add(\"EditorFramework\");\n\t\t\t\tPrivateDependencyModuleNames.Add(\"UnrealEd\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "lines": 51
    },
    {
      "file_path": "MassAI\\MassAIDebug\\MassAIDebug.Build.cs",
      "extension": ".cs",
      "size_bytes": 1150,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassAIDebug : ModuleRules\n\t{\n\t\tpublic MassAIDebug(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tUnsafeTypeCastWarningLevel = WarningLevel.Warning;\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"InputCore\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t\t\"NavigationSystem\",\n\t\t\t\t\t\"StateTreeModule\",\n\t\t\t\t\t\"MassGameplayDebug\",\n\t\t\t\t\t\"MassActors\",\n\t\t\t\t\t\"MassAIBehavior\",\n\t\t\t\t\t\"MassCommon\",\n\t\t\t\t\t\"MassMovement\",\n\t\t\t\t\t\"MassNavigation\",\n\t\t\t\t\t\"MassZoneGraphNavigation\",\n\t\t\t\t\t\"MassAIReplication\",\n\t\t\t\t\t\"MassSmartObjects\",\n\t\t\t\t\t\"MassSpawner\",\n\t\t\t\t\t\"MassSimulation\",\n\t\t\t\t\t\"MassRepresentation\",\n\t\t\t\t\t\"MassSignals\",\n\t\t\t\t\t\"MassLOD\",\n\t\t\t\t\t\"MassSmartObjects\",\n\t\t\t\t\t\"SmartObjectsModule\",\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (Target.bBuildEditor == true)\n\t\t\t{\n\t\t\t\tPrivateDependencyModuleNames.Add(\"UnrealEd\");\n\t\t\t\tPublicDependencyModuleNames.Add(\"MassEntityEditor\");\n\t\t\t}\n\n\t\t\tSetupGameplayDebuggerSupport(Target);\n\t\t}\n\t}\n}\n",
      "lines": 50
    },
    {
      "file_path": "MassAI\\MassAIReplication\\MassAIReplication.Build.cs",
      "extension": ".cs",
      "size_bytes": 877,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassAIReplication : ModuleRules\n\t{\n\t\tpublic MassAIReplication(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tUnsafeTypeCastWarningLevel = WarningLevel.Warning;\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"AIModule\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t\t\"MassCommon\",\n\t\t\t\t\t\"MassSpawner\",\n\t\t\t\t\t\"MassSimulation\",\n\t\t\t\t\t\"MassLOD\",\n\t\t\t\t\t\"NetCore\",\n\t\t\t\t\t\"MassNavigation\",\n\t\t\t\t\t\"MassZoneGraphNavigation\",\n\t\t\t\t\t\"MassReplication\",\n\t\t\t\t\t\"ZoneGraph\"\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (Target.bBuildEditor == true)\n\t\t\t{\n\t\t\t\tPrivateDependencyModuleNames.Add(\"EditorFramework\");\n\t\t\t\tPrivateDependencyModuleNames.Add(\"UnrealEd\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "lines": 39
    },
    {
      "file_path": "MassAI\\MassAITestSuite\\MassAITestSuite.Build.cs",
      "extension": ".cs",
      "size_bytes": 1078,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nusing UnrealBuildTool;\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassAITestSuite : ModuleRules\n\t{\n\t\tpublic MassAITestSuite(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tUnsafeTypeCastWarningLevel = WarningLevel.Warning;\n\n\t\t\tPublicIncludePaths.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"AIModule\",\n\t\t\t\t\t\"AITestSuite\",\n\t\t\t\t\t\"MassActors\",\n\t\t\t\t\t\"MassAIBehavior\",\n\t\t\t\t\t\"MassCommon\",\n\t\t\t\t\t\"MassNavigation\",\n\t\t\t\t\t\"MassAIReplication\",\n\t\t\t\t\t\"MassSmartObjects\",\n\t\t\t\t\t\"MassSpawner\",\n\t\t\t\t\t\"MassRepresentation\"\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tDynamicallyLoadedModuleNames.AddRange(\n\t\t\t\tnew string[] {\n                    // ... add any modules that your module loads dynamically here ...\n                }\n\t\t\t);\n\n\t\t\tif (Target.bBuildEditor == true)\n\t\t\t{\n\t\t\t\tPrivateDependencyModuleNames.Add(\"UnrealEd\");\n\t\t\t}\n\t\t}\n\t}\n}",
      "lines": 50
    },
    {
      "file_path": "MassAI\\MassNavigation\\MassNavigation.Build.cs",
      "extension": ".cs",
      "size_bytes": 767,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassNavigation : ModuleRules\n\t{\n\t\tpublic MassNavigation(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"AIModule\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"MassCommon\",\n\t\t\t\t\t\"MassLOD\",\n\t\t\t\t\t\"MassSignals\",\n\t\t\t\t\t\"MassSimulation\",\n\t\t\t\t\t\"MassSpawner\",\n\t\t\t\t\t\"MassMovement\",\n\t\t\t\t\t\"DeveloperSettings\"\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (Target.bCompileAgainstEditor)\n\t\t\t{\n\t\t\t\tPrivateDependencyModuleNames.Add(\"EditorFramework\");\n\t\t\t\tPrivateDependencyModuleNames.Add(\"UnrealEd\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "lines": 35
    },
    {
      "file_path": "MassAI\\MassNavigationEditor\\MassNavigationEditor.Build.cs",
      "extension": ".cs",
      "size_bytes": 885,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassNavigationEditor : ModuleRules\n\t{\n\t\tpublic MassNavigationEditor(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPublicIncludePaths.AddRange(\n\t\t\tnew string[] {\n\t\t\t}\n\t\t\t);\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\tnew string[] {\n\t\t\t\t\"Core\",\n\t\t\t\t\"CoreUObject\",\n\t\t\t\t\"Engine\",\n\t\t\t\t\"InputCore\",\n\t\t\t\t\"AssetTools\",\n\t\t\t\t\"EditorFramework\",\n\t\t\t\t\"UnrealEd\",\n\t\t\t\t\"RHI\",\n\t\t\t\t\"Slate\",\n\t\t\t\t\"SlateCore\",\n\t\t\t\t\"PropertyEditor\",\n\t\t\t\t\"MassEntity\",\n\t\t\t\t\"DetailCustomizations\",\n\t\t\t\t\"MassCommon\",\n\t\t\t\t\"MassNavigation\",\n\t\t\t\t\"MassZoneGraphNavigation\",\n\t\t\t\t\"ZoneGraph\",\n\t\t\t}\n\t\t\t);\n\n\t\t\tPrivateDependencyModuleNames.AddRange(\n\t\t\tnew string[] {\n\t\t\t\t\"RenderCore\",\n\t\t\t\t\"KismetWidgets\",\n\t\t\t\t\"ToolMenus\",\n\t\t\t\t\"AppFramework\",\n\t\t\t\t\"Projects\",\n\t\t\t}\n\t\t\t);\n\t\t}\n\n\t}\n}\n",
      "lines": 48
    },
    {
      "file_path": "MassAI\\MassZoneGraphNavigation\\MassZoneGraphNavigation.Build.cs",
      "extension": ".cs",
      "size_bytes": 891,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassZoneGraphNavigation : ModuleRules\n\t{\n\t\tpublic MassZoneGraphNavigation(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"AIModule\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"MassCommon\",\n\t\t\t\t\t\"MassLOD\",\n\t\t\t\t\t\"MassSignals\",\n\t\t\t\t\t\"MassSimulation\",\n\t\t\t\t\t\"MassSpawner\",\n\t\t\t\t\t\"MassMovement\",\n\t\t\t\t\t\"MassNavigation\",\n\t\t\t\t\t\"ZoneGraph\",\n\t\t\t\t\t\"ZoneGraphAnnotations\",\n\t\t\t\t\t\"DeveloperSettings\",\n\t\t\t\t\t\"MassGameplayExternalTraits\"\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (Target.bBuildEditor == true)\n\t\t\t{\n\t\t\t\tPrivateDependencyModuleNames.Add(\"EditorFramework\");\n\t\t\t\tPrivateDependencyModuleNames.Add(\"UnrealEd\");\n\t\t\t}\n\t\t}\n\t}\n}",
      "lines": 39
    },
    {
      "file_path": "MassGameplay\\MassActors\\MassActors.Build.cs",
      "extension": ".cs",
      "size_bytes": 814,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassActors : ModuleRules\n\t{\n\t\tpublic MassActors(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tUnsafeTypeCastWarningLevel = WarningLevel.Warning;\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t\t\"AIModule\",\n\t\t\t\t\t\"MassCommon\",\n\t\t\t\t\t\"MassMovement\",\n\t\t\t\t\t\"MassSpawner\",\n\t\t\t\t\t\"MassSimulation\",\n\t\t\t\t\t\"MassReplication\",\n\t\t\t\t\t\"MassSignals\",\n\t\t\t\t\t\"NetCore\",\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (Target.bBuildEditor == true)\n\t\t\t{\n\t\t\t\tPrivateDependencyModuleNames.Add(\"EditorFramework\");\n\t\t\t\tPrivateDependencyModuleNames.Add(\"UnrealEd\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "lines": 37
    },
    {
      "file_path": "MassGameplay\\MassCommon\\MassCommon.Build.cs",
      "extension": ".cs",
      "size_bytes": 606,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassCommon : ModuleRules\n\t{\n\t\tpublic MassCommon(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tUnsafeTypeCastWarningLevel = WarningLevel.Warning;\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"AIModule\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (Target.bBuildEditor == true)\n\t\t\t{\n\t\t\t\tPrivateDependencyModuleNames.Add(\"UnrealEd\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "lines": 29
    },
    {
      "file_path": "MassGameplay\\MassEQS\\MassEQS.Build.cs",
      "extension": ".cs",
      "size_bytes": 575,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nusing UnrealBuildTool;\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassEQS : ModuleRules\n\t{\n\t\tpublic MassEQS(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tPublicIncludePaths.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"AIModule\",\n\t\t\t\t\t\"MassCommon\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t\t\"MassSignals\",\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n}",
      "lines": 31
    },
    {
      "file_path": "MassGameplay\\MassGameplayDebug\\MassGameplayDebug.Build.cs",
      "extension": ".cs",
      "size_bytes": 952,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassGameplayDebug : ModuleRules\n\t{\n\t\tpublic MassGameplayDebug(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tUnsafeTypeCastWarningLevel = WarningLevel.Warning;\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"InputCore\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t\t\"NavigationSystem\",\n\t\t\t\t\t\"StateTreeModule\",\n\t\t\t\t\t\"MassActors\",\n\t\t\t\t\t\"MassCommon\",\n\t\t\t\t\t\"MassMovement\",\n\t\t\t\t\t\"MassSmartObjects\",\n\t\t\t\t\t\"MassSpawner\",\n\t\t\t\t\t\"MassSimulation\",\n\t\t\t\t\t\"MassRepresentation\",\n\t\t\t\t\t\"MassLOD\",\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (Target.bBuildEditor == true)\n\t\t\t{\n\t\t\t\tPrivateDependencyModuleNames.Add(\"UnrealEd\");\n\t\t\t\tPublicDependencyModuleNames.Add(\"MassEntityEditor\");\n\t\t\t}\n\n\t\t\tSetupGameplayDebuggerSupport(Target);\n\t\t}\n\t}\n}\n",
      "lines": 42
    },
    {
      "file_path": "MassGameplay\\MassGameplayEditor\\MassGameplayEditor.Build.cs",
      "extension": ".cs",
      "size_bytes": 1061,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassGameplayEditor : ModuleRules\n\t{\n\t\tpublic MassGameplayEditor(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tUnsafeTypeCastWarningLevel = WarningLevel.Warning;\n\n\t\t\tPublicIncludePaths.AddRange(\n\t\t\tnew string[] {\n\t\t\t}\n\t\t\t);\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\tnew string[] {\n\t\t\t\t\"Core\",\n\t\t\t\t\"CoreUObject\",\n\t\t\t\t\"Engine\",\n\t\t\t\t\"InputCore\",\n\t\t\t\t\"AssetTools\",\n\t\t\t\t\"UnrealEd\",\n\t\t\t\t\"Slate\",\n\t\t\t\t\"SlateCore\",\n\t\t\t\t\n\t\t\t\t\"PropertyEditor\",\n\t\t\t\t\"MassSpawner\",\n\t\t\t\t\"MassEntity\",\n\t\t\t\t\"MassEntityEditor\",\n\t\t\t\t\"MassActors\",\n\t\t\t\t\"DetailCustomizations\",\n\t\t\t\t\"ComponentVisualizers\",\n\t\t\t\t\"Projects\",\n\t\t\t\t\"EditorSubsystem\",\n\t\t\t}\n\t\t\t);\n\n\t\t\tPrivateDependencyModuleNames.AddRange(\n\t\t\tnew string[] {\n\t\t\t\t\"RenderCore\",\n\t\t\t\t\"GraphEditor\",\n\t\t\t\t\"KismetWidgets\",\n\t\t\t\t\"PropertyEditor\",\n\t\t\t\t\"AIGraph\",\n\t\t\t\t\"ToolMenus\",\n\t\t\t\t\"DataValidation\",\n\t\t\t}\n\t\t\t);\n\t\t}\n\n\t}\n}\n",
      "lines": 55
    },
    {
      "file_path": "MassGameplay\\MassGameplayExternalTraits\\MassGameplayExternalTraits.Build.cs",
      "extension": ".cs",
      "size_bytes": 424,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassGameplayExternalTraits : ModuleRules\n\t{\n\t\tpublic MassGameplayExternalTraits(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n}\n",
      "lines": 19
    },
    {
      "file_path": "MassGameplay\\MassGameplayTestSuite\\MassGameplayTestSuite.Build.cs",
      "extension": ".cs",
      "size_bytes": 615,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nusing UnrealBuildTool;\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassGameplayTestSuite : ModuleRules\n\t{\n\t\tpublic MassGameplayTestSuite(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tPublicIncludePaths.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"AITestSuite\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t\t\"MassEntityTestSuite\",\n\t\t\t\t\t\"MassSpawner\",\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n}",
      "lines": 31
    },
    {
      "file_path": "MassGameplay\\MassLOD\\MassLOD.Build.cs",
      "extension": ".cs",
      "size_bytes": 664,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassLOD : ModuleRules\n\t{\n\t\tpublic MassLOD(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tUnsafeTypeCastWarningLevel = WarningLevel.Warning;\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"AIModule\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t\t\"MassCommon\",\n\t\t\t\t\t\"MassSimulation\",\n\t\t\t\t\t\"MassSpawner\"\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (Target.bBuildEditor == true)\n\t\t\t{\n\t\t\t\tPrivateDependencyModuleNames.Add(\"UnrealEd\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "lines": 32
    },
    {
      "file_path": "MassGameplay\\MassMovement\\MassMovement.Build.cs",
      "extension": ".cs",
      "size_bytes": 822,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassMovement : ModuleRules\n\t{\n\t\tpublic MassMovement(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tUnsafeTypeCastWarningLevel = WarningLevel.Warning;\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"AIModule\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"MassCommon\",\n\t\t\t\t\t\"MassLOD\",\n\t\t\t\t\t\"MassSignals\",\n\t\t\t\t\t\"MassSpawner\",\n\t\t\t\t\t\"NavigationSystem\",\n\t\t\t\t\t\"ZoneGraph\",\n\t\t\t\t\t\"ZoneGraphAnnotations\",\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (Target.bBuildEditor == true)\n\t\t\t{\n\t\t\t\tPrivateDependencyModuleNames.Add(\"EditorFramework\");\n\t\t\t\tPrivateDependencyModuleNames.Add(\"UnrealEd\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "lines": 37
    },
    {
      "file_path": "MassGameplay\\MassMovementEditor\\MassMovementEditor.Build.cs",
      "extension": ".cs",
      "size_bytes": 835,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassMovementEditor : ModuleRules\n\t{\n\t\tpublic MassMovementEditor(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPublicIncludePaths.AddRange(\n\t\t\tnew string[] {\n\t\t\t}\n\t\t\t);\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\tnew string[] {\n\t\t\t\t\"Core\",\n\t\t\t\t\"CoreUObject\",\n\t\t\t\t\"Engine\",\n\t\t\t\t\"InputCore\",\n\t\t\t\t\"AssetTools\",\n\t\t\t\t\"EditorFramework\",\n\t\t\t\t\"UnrealEd\",\n\t\t\t\t\"RHI\",\n\t\t\t\t\"Slate\",\n\t\t\t\t\"SlateCore\",\n\t\t\t\t\n\t\t\t\t\"PropertyEditor\",\n\t\t\t\t\"DetailCustomizations\",\n\t\t\t\t\"MassEntity\",\n\t\t\t\t\"MassCommon\",\n\t\t\t\t\"MassMovement\",\n\t\t\t}\n\t\t\t);\n\n\t\t\tPrivateDependencyModuleNames.AddRange(\n\t\t\tnew string[] {\n\t\t\t\t\"RenderCore\",\n\t\t\t\t\"KismetWidgets\",\n\t\t\t\t\"ToolMenus\",\n\t\t\t\t\"AppFramework\",\n\t\t\t\t\"Projects\",\n\t\t\t}\n\t\t\t);\n\t\t}\n\n\t}\n}\n",
      "lines": 47
    },
    {
      "file_path": "MassGameplay\\MassReplication\\MassReplication.Build.cs",
      "extension": ".cs",
      "size_bytes": 813,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassReplication : ModuleRules\n\t{\n\t\tpublic MassReplication(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tUnsafeTypeCastWarningLevel = WarningLevel.Warning;\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"AIModule\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t\t\"MassCommon\",\n\t\t\t\t\t\"MassSimulation\",\n\t\t\t\t\t\"MassSpawner\",\n\t\t\t\t\t\"MassLOD\",\n\t\t\t\t\t\"NetCore\",\n\t\t\t\t\t\"MassMovement\",\n\t\t\t\t\t\"ZoneGraph\"\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (Target.bBuildEditor == true)\n\t\t\t{\n\t\t\t\tPrivateDependencyModuleNames.Add(\"EditorFramework\");\n\t\t\t\tPrivateDependencyModuleNames.Add(\"UnrealEd\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "lines": 37
    },
    {
      "file_path": "MassGameplay\\MassRepresentation\\MassRepresentation.Build.cs",
      "extension": ".cs",
      "size_bytes": 883,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassRepresentation : ModuleRules\n\t{\n\t\tpublic MassRepresentation(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tUnsafeTypeCastWarningLevel = WarningLevel.Warning;\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"AIModule\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t\t\"MassCommon\",\n\t\t\t\t\t\"MassActors\",\n\t\t\t\t\t\"MassSpawner\",\n\t\t\t\t\t\"MassReplication\",\n\t\t\t\t\t\"MassLOD\",\n\t\t\t\t\t\"MassSimulation\",\n\t\t\t\t\t\"RenderCore\",\n\t\t\t\t\t\"RHI\",\n\t\t\t\t\t\"MassMovement\",\n\t\t\t\t\t\"MassSignals\",\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (Target.bBuildEditor == true)\n\t\t\t{\n\t\t\t\tPrivateDependencyModuleNames.Add(\"EditorFramework\");\n\t\t\t\tPrivateDependencyModuleNames.Add(\"UnrealEd\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "lines": 40
    },
    {
      "file_path": "MassGameplay\\MassSignals\\MassSignals.Build.cs",
      "extension": ".cs",
      "size_bytes": 648,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassSignals : ModuleRules\n\t{\n\t\tpublic MassSignals(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tUnsafeTypeCastWarningLevel = WarningLevel.Warning;\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (Target.bBuildEditor == true)\n\t\t\t{\n\t\t\t\tPrivateDependencyModuleNames.Add(\"EditorFramework\");\n\t\t\t\tPrivateDependencyModuleNames.Add(\"UnrealEd\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "lines": 29
    },
    {
      "file_path": "MassGameplay\\MassSimulation\\MassSimulation.Build.cs",
      "extension": ".cs",
      "size_bytes": 701,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassSimulation : ModuleRules\n\t{\n\t\tpublic MassSimulation(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tUnsafeTypeCastWarningLevel = WarningLevel.Warning;\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"MassCommon\",\n\t\t\t\t\t\"NavigationSystem\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (Target.bBuildEditor == true)\n\t\t\t{\n\t\t\t\tPrivateDependencyModuleNames.Add(\"UnrealEd\");\n\t\t\t\tPrivateDependencyModuleNames.Add(\"MassEntityEditor\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "lines": 31
    },
    {
      "file_path": "MassGameplay\\MassSmartObjects\\MassSmartObjects.Build.cs",
      "extension": ".cs",
      "size_bytes": 843,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassSmartObjects : ModuleRules\n\t{\n\t\tpublic MassSmartObjects(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tUnsafeTypeCastWarningLevel = WarningLevel.Warning;\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"GameplayTags\",\n\t\t\t\t\t\"MassCommon\",\n\t\t\t\t\t\"MassLOD\",\n\t\t\t\t\t\"MassMovement\",\n\t\t\t\t\t\"MassSignals\",\n\t\t\t\t\t\"MassSimulation\",\n\t\t\t\t\t\"MassSpawner\",\n\t\t\t\t\t\"SmartObjectsModule\",\n\t\t\t\t\t\"ZoneGraph\",\n\t\t\t\t\t\"ZoneGraphAnnotations\",\n\t\t\t\t\t\"MassGameplayExternalTraits\"\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tPrivateDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"MassActors\"\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n}\n",
      "lines": 40
    },
    {
      "file_path": "MassGameplay\\MassSpawner\\MassSpawner.Build.cs",
      "extension": ".cs",
      "size_bytes": 974,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\nnamespace UnrealBuildTool.Rules\n{\n\tpublic class MassSpawner : ModuleRules\n\t{\n\t\tpublic MassSpawner(ReadOnlyTargetRules Target) : base(Target)\n\t\t{\n\t\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\t\tUnsafeTypeCastWarningLevel = WarningLevel.Warning;\n\n\t\t\tPublicDependencyModuleNames.AddRange(\n\t\t\t\tnew string[] {\n\t\t\t\t\t\"Core\",\n\t\t\t\t\t\"CoreUObject\",\n\t\t\t\t\t\"Engine\",\n\t\t\t\t\t\"AIModule\",\n\t\t\t\t\t\"MassEntity\",\n\t\t\t\t\t\"MassCommon\",\n\t\t\t\t\t\"MassSimulation\",\n\t\t\t\t\t\"ZoneGraph\",\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (Target.bBuildEditor == true)\n\t\t\t{\n\t\t\t\tPrivateDependencyModuleNames.AddRange(\n\t\t\t\t\tnew string[] {\n\t\t\t\t\t\t\"UnrealEd\",\n\t\t\t\t\t\t\"Slate\"\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tPublicDependencyModuleNames.Add(\"MassEntityEditor\");\n\t\t\t\t// here for communication with MassTraitRepository\n\t\t\t\tPrivateIncludePathModuleNames.Add(\"MassGameplayEditor\");\n\t\t\t\tDynamicallyLoadedModuleNames.Add(\"MassGameplayEditor\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "lines": 42
    }
  ]
}