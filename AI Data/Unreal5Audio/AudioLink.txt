=== CODEBASE STRUCTURE ===

ðŸ“„ AudioLinkCore.Build.cs
ðŸ“„ AudioLinkEngine.Build.cs
ðŸ“„ AudioLinkLog.h
ðŸ“„ AudioLinkModule.cpp
ðŸ“„ AudioLinkSettingsAbstract.h
ðŸ“„ AudioMixerPlatformAudioLink.Build.cs
ðŸ“„ AudioMixerPlatformAudioLink.cpp
ðŸ“„ AudioMixerPlatformAudioLink.h
ðŸ“„ AudioMixerPlatformAudioLinkModule.cpp
ðŸ“„ BufferedListenerBase.cpp
ðŸ“„ BufferedListenerBase.h
ðŸ“„ BufferedSourceListener.cpp
ðŸ“„ BufferedSourceListener.h
ðŸ“„ BufferedSubmixListener.cpp
ðŸ“„ BufferedSubmixListener.h
ðŸ“„ IAudioLink.cpp
ðŸ“„ IAudioLink.h
ðŸ“„ IAudioLinkBlueprintInterface.cpp
ðŸ“„ IAudioLinkBlueprintInterface.h
ðŸ“„ IAudioLinkFactory.cpp
ðŸ“„ IAudioLinkFactory.h
ðŸ“„ IBufferedAudioOutput.h


=== FILE CONTENTS ===


=== AudioLinkCore.Build.cs ===
==============================

// Copyright Epic Games, Inc. All Rights Reserved.

namespace UnrealBuildTool.Rules
{
	public class AudioLinkCore : ModuleRules
	{
		public AudioLinkCore (ReadOnlyTargetRules Target) : base(Target)
		{
			PublicDependencyModuleNames.AddRange(
				new string[]
				{
					"Core",
					"CoreUObject",
				}
			);
		}
	}
}

==============================


=== AudioLinkEngine.Build.cs ===
================================

// Copyright Epic Games, Inc. All Rights Reserved.

namespace UnrealBuildTool.Rules
{
	public class AudioLinkEngine : ModuleRules
	{
		public AudioLinkEngine(ReadOnlyTargetRules Target) : base(Target)
		{
			PrivateDependencyModuleNames.AddRange(
				new string[]
				{
					// We depend on USoundSubmix/AudioDevice which is in Engine.
					"Core",
					"CoreUObject",
					"Engine",
				}
			);
		}
	}
}

================================


=== AudioLinkLog.h ===
======================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"

AUDIOLINKENGINE_API DECLARE_LOG_CATEGORY_EXTERN(LogAudioLink, Log, All);

======================


=== AudioLinkModule.cpp ===
===========================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "CoreMinimal.h"
#include "AudioLinkLog.h"
#include "Modules/ModuleManager.h"

DEFINE_LOG_CATEGORY(LogAudioLink);

class FAudioLinkModule : public IModuleInterface
{
public:
	// Begin IModuleInterface
	virtual void StartupModule() override
	{
	}
	virtual void ShutdownModule() override
	{
	}
};

IMPLEMENT_MODULE(FAudioLinkModule, AudioLinkEngine);

===========================


=== AudioLinkSettingsAbstract.h ===
===================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Templates/SharedPointer.h"
#include "AudioLinkSettingsAbstract.generated.h"

class UAudioLinkSettingsAbstract;

/**
  * This interface should be used to provide a non-uclass version of the data described in
  * your implementation of UAudioLinkSettingsAbstract
  */
class IAudioLinkSettingsProxy
{
public:
	virtual ~IAudioLinkSettingsProxy() = default;
protected:
#if WITH_EDITOR
	friend class UAudioLinkSettingsAbstract;
	virtual void RefreshFromSettings(UAudioLinkSettingsAbstract* InSettings, FPropertyChangedEvent& InPropertyChangedEvent) = 0;
#endif //WITH_EDITOR
};

/**
  * This opaque class should be used for specifying settings for how audio should be
  * send to an external audio link.
  */
UCLASS(config = Engine, abstract, editinlinenew, BlueprintType, MinimalAPI)
class UAudioLinkSettingsAbstract : public UObject
{
	GENERATED_BODY()

public:
	using FSharedSettingsProxyPtr = TSharedPtr<IAudioLinkSettingsProxy, ESPMode::ThreadSafe>;

	AUDIOLINKCORE_API virtual FName GetFactoryName() const PURE_VIRTUAL(UAudioLinkSettingsAbstract::GetFactoryName, return {};);
	
	virtual const FSharedSettingsProxyPtr& GetProxy() const
	{
		if (!ProxyInstance.IsValid())
		{
			ProxyInstance = MakeProxy();
		}
		return ProxyInstance;
	}

	template<typename T> 
	auto GetCastProxy() const
	{
		return StaticCastSharedPtr<T>(GetProxy());
	}

protected:
#if WITH_EDITOR	
	void PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent)
	{
		GetProxy()->RefreshFromSettings(this, PropertyChangedEvent);
	}
#endif //WITH_EDITOR

	AUDIOLINKCORE_API virtual FSharedSettingsProxyPtr MakeProxy() const PURE_VIRTUAL(UAudioLinkSettingsAbstract::MakeProxy, return {};);
	mutable FSharedSettingsProxyPtr ProxyInstance;
};


===================================


=== AudioMixerPlatformAudioLink.Build.cs ===
============================================

// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class AudioMixerPlatformAudioLink: ModuleRules
{
	public AudioMixerPlatformAudioLink(ReadOnlyTargetRules Target) : base(Target)
	{
        PrivateIncludePathModuleNames.Add("TargetPlatform");
		PublicIncludePathModuleNames.Add("AudioMixer");

		PrivateDependencyModuleNames.AddRange(
			new string[] {
				"AudioMixer",
				"AudioMixerCore",
				"AudioLinkEngine",
				"Core",
				"CoreUObject",
				"Engine",
		});
					
	}
}

============================================


=== AudioMixerPlatformAudioLink.cpp ===
=======================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "AudioMixerPlatformAudioLink.h"
#include "Modules/ModuleManager.h"
#include "AudioMixer.h"
#include "AudioMixerDevice.h"
#include "CoreGlobals.h"
#include "Misc/ConfigCacheIni.h"

#include "Misc/CoreMisc.h"
#include "Interfaces/ITargetPlatform.h"
#include "Interfaces/ITargetPlatformManagerModule.h"
#include "AudioLinkLog.h"

namespace Audio
{
	// We can't easily access AudioMixer instance from here, so find the factory in the registry.
	static IAudioLinkFactory* GetAudioLinkFactory()
	{
		TArray<FName> Names = IAudioLinkFactory::GetAllRegisteredFactoryNames();
		if (Names.Num())
		{
			return IAudioLinkFactory::FindFactory(Names[0]);
		}
		return nullptr;
	}

	FAudioMixerPlatformAudioLink::FAudioMixerPlatformAudioLink()
		: Factory(GetAudioLinkFactory())
	{
		MakeDeviceInfo(
			8,
			48000,
			TEXT("AudioLink AudioMixer")
		);
	}

	bool FAudioMixerPlatformAudioLink::InitializeHardware()
	{
		if (IAudioMixer::ShouldRecycleThreads())
		{
			// Pre-create the null render device thread, so we can simple wake it up when we need it.
			// Give it nothing to do, with a slow tick as the default, but ask it to wait for a signal to wake up.
			CreateNullDeviceThread([] {}, 1.0f, true);
		}

		SynchronizeLink = Factory->CreateSynchronizerAudioLink();
		if (SynchronizeLink.IsValid())
		{
			using FThisType = FAudioMixerPlatformAudioLink;
			using FSync = IAudioLinkSynchronizer;
		
			// Register callbacks.
			SynchronizeLink->RegisterBeginRenderDelegate(FSync::FOnBeginRender::FDelegate::CreateRaw(this, &FThisType::OnLinkRenderBegin));
			SynchronizeLink->RegisterEndRenderDelegate(FSync::FOnEndRender::FDelegate::CreateRaw(this, &FThisType::OnLinkRenderEnd));
			SynchronizeLink->RegisterOpenStreamDelegate(FSync::FOnOpenStream::FDelegate::CreateRaw(this, &FThisType::OnLinkOpenStream));
		}

		bInitialized = true;
		return true;
	}

	bool FAudioMixerPlatformAudioLink::TeardownHardware()
	{		
		StopAudioStream();
		CloseAudioStream();

		// Kill synchronizer, and unregister callbacks.
		SynchronizeLink.Reset();
		return true;
	}

	bool FAudioMixerPlatformAudioLink::IsInitialized() const
	{
		return bInitialized;
	}

	bool FAudioMixerPlatformAudioLink::GetNumOutputDevices(uint32& OutNumOutputDevices)
	{
		OutNumOutputDevices = 1;
		return true;
	}
	
	bool FAudioMixerPlatformAudioLink::GetOutputDeviceInfo(const uint32 InDeviceIndex, FAudioPlatformDeviceInfo& OutInfo)
	{	
		OutInfo = DeviceInfo;
		return true;
	}

	bool FAudioMixerPlatformAudioLink::GetDefaultOutputDeviceIndex(uint32& OutDefaultDeviceIndex) const
	{
		// It's not possible to know what index the default audio device is.
		OutDefaultDeviceIndex = AUDIO_MIXER_DEFAULT_DEVICE_INDEX;
		return true;
	}

	bool FAudioMixerPlatformAudioLink::OpenAudioStream(const FAudioMixerOpenStreamParams& Params)
	{
		if (!bInitialized || AudioStreamInfo.StreamState != EAudioOutputStreamState::Closed)
		{
			return false;
		}
			
		AudioStreamInfo.Reset();
		if(!GetOutputDeviceInfo(Params.OutputDeviceIndex, AudioStreamInfo.DeviceInfo))
		{
			return false;
		}

		OpenStreamParams = Params;

		AudioStreamInfo.AudioMixer = Params.AudioMixer;
		AudioStreamInfo.NumBuffers = Params.NumBuffers;
		AudioStreamInfo.NumOutputFrames = Params.NumFrames;
		AudioStreamInfo.StreamState = EAudioOutputStreamState::Open;

		return true;
	}

	bool FAudioMixerPlatformAudioLink::CloseAudioStream()
	{
		if (AudioStreamInfo.StreamState == EAudioOutputStreamState::Closed)
		{
			return false;
		}

		if (!StopAudioStream())
		{
			return false;
		}

		AudioStreamInfo.StreamState = EAudioOutputStreamState::Closed;
		return true;
	}

	bool FAudioMixerPlatformAudioLink::StartAudioStream()
	{
		if (!bInitialized || (AudioStreamInfo.StreamState != EAudioOutputStreamState::Open && AudioStreamInfo.StreamState != EAudioOutputStreamState::Stopped))
		{
			return false;
		}

		// Start generating audio
		BeginGeneratingAudio();

		if (!SynchronizeLink.IsValid())
		{
			StartRunningNullDevice();
		}

		AudioStreamInfo.StreamState = EAudioOutputStreamState::Running;

		return true;
	}

	bool FAudioMixerPlatformAudioLink::StopAudioStream()
	{
		if (AudioStreamInfo.StreamState != EAudioOutputStreamState::Stopped && AudioStreamInfo.StreamState != EAudioOutputStreamState::Closed)
		{
			if(bIsUsingNullDevice)
			{
				StopRunningNullDevice();
			}
			
			if (AudioStreamInfo.StreamState == EAudioOutputStreamState::Running)
			{
				StopGeneratingAudio();
			}

			check(AudioStreamInfo.StreamState == EAudioOutputStreamState::Stopped);
		}

		return true;
	}

	FAudioPlatformDeviceInfo FAudioMixerPlatformAudioLink::GetPlatformDeviceInfo() const
	{
		return AudioStreamInfo.DeviceInfo;
	}

	FString FAudioMixerPlatformAudioLink::GetDefaultDeviceName()
	{
		return DeviceInfo.Name;
	}
	
	FAudioPlatformSettings FAudioMixerPlatformAudioLink::GetPlatformSettings() const
	{
#if WITH_ENGINE
		return FAudioPlatformSettings::GetPlatformSettings(FPlatformProperties::GetRuntimeSettingsClassName());
#else
		return FAudioPlatformSettings();
#endif // WITH_ENGINE
	}

	void FAudioMixerPlatformAudioLink::MakeDeviceInfo(int32 InNumChannels, int32 InSampleRate, const FString& InName)
	{
		DeviceInfo.Reset();
		DeviceInfo.Name = InName;
		DeviceInfo.DeviceId = InName;
		DeviceInfo.SampleRate = InSampleRate;
		DeviceInfo.NumChannels = InNumChannels;
		DeviceInfo.bIsSystemDefault = true;
		DeviceInfo.Format = EAudioMixerStreamDataFormat::Float;
		
		DeviceInfo.OutputChannelArray.SetNum(InNumChannels);
		for (int32 i = 0; i < InNumChannels; ++i)
		{
			DeviceInfo.OutputChannelArray.Add(EAudioMixerChannel::Type(i));
		}
	}

	void FAudioMixerPlatformAudioLink::OnLinkOpenStream(const IAudioLinkSynchronizer::FOnOpenStreamParams& InParams)
	{
		DeviceInfo.Name = InParams.Name;
		DeviceInfo.NumChannels = InParams.NumChannels;
		DeviceInfo.SampleRate = InParams.SampleRate;
	}

	void FAudioMixerPlatformAudioLink::OnLinkRenderBegin(const IAudioLinkSynchronizer::FOnRenderParams& InParams)
	{		
	}
	void FAudioMixerPlatformAudioLink::OnLinkRenderEnd(const IAudioLinkSynchronizer::FOnRenderParams& InParams)
	{
		UE_LOG(LogAudioLink, VeryVerbose, TEXT(
			"FAudioMixerPlatformAudioLink::OnLinkRenderEnd, TickID=%d, FramesMade=%d, LastBufferTickID=%d, FrameRemainder=%d, AudioMixer.NumFrames=%d, AudioMixer.NumBuffers=%dm This=0x%p"), 
				InParams.BufferTickID, InParams.NumFrames, LastBufferTickID, FrameRemainder, AudioStreamInfo.NumOutputFrames, AudioStreamInfo.NumBuffers, this);

		if (LastBufferTickID < InParams.BufferTickID)
		{
			LastBufferTickID = InParams.BufferTickID;

			FrameRemainder += InParams.NumFrames;

			if (FrameRemainder >= AudioStreamInfo.NumOutputFrames)
			{
				FrameRemainder = 0;
				ReadNextBuffer();
			}
		}
	}
}

=======================================


=== AudioMixerPlatformAudioLink.h ===
=====================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "AudioMixer.h"
#include "IAudioLinkFactory.h"

namespace Audio
{
	class FAudioMixerPlatformAudioLink : public IAudioMixerPlatformInterface
	{
	public:

		FAudioMixerPlatformAudioLink();
		virtual ~FAudioMixerPlatformAudioLink() = default;
	protected:

		//~ Begin IAudioMixerPlatformInterface Interface
		FString GetPlatformApi() const override { return TEXT("AudioLink"); }
		bool InitializeHardware() override;
		bool TeardownHardware() override;
		bool IsInitialized() const override;
		bool GetNumOutputDevices(uint32& OutNumOutputDevices) override;
		bool GetOutputDeviceInfo(const uint32 InDeviceIndex, FAudioPlatformDeviceInfo& OutInfo) override;
		bool GetDefaultOutputDeviceIndex(uint32& OutDefaultDeviceIndex) const override;
		virtual bool OpenAudioStream(const FAudioMixerOpenStreamParams& Params) override;
		bool CloseAudioStream() override;
		bool StartAudioStream() override;
		bool StopAudioStream() override;
		FAudioPlatformDeviceInfo GetPlatformDeviceInfo() const override;
		FString GetDefaultDeviceName() override;
		FAudioPlatformSettings GetPlatformSettings() const override;
		//~ End IAudioMixerPlatformInterface Interface

	private:
		void MakeDeviceInfo(int32 InNumChannels, int32 InSampleRate, const FString& InName);

		void OnLinkSuspend();
		void OnLinkResume();
		void OnLinkCloseStream();
		void OnLinkOpenStream(const IAudioLinkSynchronizer::FOnOpenStreamParams&);
		void OnLinkRenderBegin(const IAudioLinkSynchronizer::FOnRenderParams&);
		void OnLinkRenderEnd(const IAudioLinkSynchronizer::FOnRenderParams&);

		bool bSuspended = false;
		bool bInitialized = false;
		IAudioLinkFactory* Factory = nullptr;
		IAudioLinkFactory::FAudioLinkSynchronizerSharedPtr SynchronizeLink;
		FAudioPlatformDeviceInfo DeviceInfo;
		uint32 LastBufferTickID = 0;
		int32 FrameRemainder = 0;
	};
}


=====================================


=== AudioMixerPlatformAudioLinkModule.cpp ===
=============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "CoreMinimal.h"
#include "AudioMixer.h"
#include "AudioMixerDevice.h"
#include "AudioMixerPlatformAudioLink.h"

class FAudioMixerPlatformAudioLinkModule : public IAudioDeviceModule
{
public:
	virtual bool IsAudioMixerModule() const override { return true; }

	virtual void StartupModule() override
	{
		IAudioDeviceModule::StartupModule();

		FModuleManager::Get().LoadModuleChecked(TEXT("AudioMixerCore"));
	}

	virtual FAudioDevice* CreateAudioDevice() override
	{
		return new Audio::FMixerDevice(CreateAudioMixerPlatformInterface());
	}

	virtual Audio::IAudioMixerPlatformInterface* CreateAudioMixerPlatformInterface() override
	{
		return new Audio::FAudioMixerPlatformAudioLink();
	}
};

IMPLEMENT_MODULE(FAudioMixerPlatformAudioLinkModule, AudioMixerPlatformAudioLink);

=============================================


=== BufferedListenerBase.cpp ===
================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "BufferedListenerBase.h"
#include "AudioLinkLog.h"

FBufferedListenerBase::FBufferedListenerBase(int32 InDefaultCircularBufferSize)
	: CircularBuffer(InDefaultCircularBufferSize)
{
	CircularBuffer.SetCapacity(InDefaultCircularBufferSize);
}

/** CONSUMER Thread. This will be called by the consuming data of the buffers. */
bool FBufferedListenerBase::PopBuffer(float* InBuffer, int32 InBufferSizeInSamples, int32& OutSamplesWritten)
{
	FScopeLock Lock(&CircularBuffer.GetCriticialSection());
	OutSamplesWritten = CircularBuffer.Pop(InBuffer, InBufferSizeInSamples);
	int32 NumSamplesRemaining = CircularBuffer.Num();
	
	// Return true if any data remaining, which signals the consumer to shutdown if false.
	// However if we're still running, we could be starving, so only signal stopped if we've exhausted.
	return (bStopping && NumSamplesRemaining > 0) || bStarted;
}

/** CONSUMER Thread. This will be called by the consuming data of the buffers. */
bool FBufferedListenerBase::GetFormat(IBufferedAudioOutput::FBufferFormat& OutFormat) const
{
	FReadScopeLock ReadLock(FormatKnownRwLock);
	if (KnownFormat)
	{
		OutFormat = *KnownFormat;
		return true; // success.
	}
	return false;
}

void FBufferedListenerBase::SetFormatKnownDelegate(FOnFormatKnown InFormatKnownDelegate)
{
	OnFormatKnown = InFormatKnownDelegate;
}

/** AUDIO MIXER THREAD. */
void FBufferedListenerBase::OnBufferReceived(const FBufferFormat& InFormat, TArrayView<const float> InBuffer)
{
	// Keep track of if we need to fire the delegate, so we can do it outside of a lock.
	bool bFireFormatKnownDelegate = false;

	// Do we know the format yet? (do this under a read-only lock, unless we need to change it).
	{
		// Read lock to check if we know the state.
		FRWScopeLock Lock(FormatKnownRwLock, SLT_ReadOnly);

		// Format known?
		if (!KnownFormat)
		{
			{
				// Upgrade lock to Write lock. (Safe here as we are the only writer, and only readers can race between.).
				Lock.ReleaseReadOnlyLockAndAcquireWriteLock_USE_WITH_CAUTION();

				// Write this format as our known format.
				KnownFormat = InFormat;

				// Remember to fire the delegate.
				bFireFormatKnownDelegate = true;
			}
		}
		else
		{
			// Sanity check they haven't changed on the source since it started.
			ensure(InFormat == *KnownFormat);
		}
	}

	// Fire format known delegate. (important this is done outside of the read/write lock above as it calls GetFormat, which needs a read lock).
	if (bFireFormatKnownDelegate)
	{
		// Broadcast to consumer that we know our format and block rate.
		OnFormatKnown.ExecuteIfBound(InFormat);
	}

	int32 SamplesPushed = 0;
	{
		// Lock outside for the sake of atomic logging
		FScopeLock Lock(&CircularBuffer.GetCriticialSection());
		
		// Push the data into the circular buffer.
		SamplesPushed = CircularBuffer.Push(InBuffer.GetData(), InBuffer.Num());

		UE_LOG(LogAudioLink, VeryVerbose, 
			TEXT("FBufferedListenerBase::OnBufferReceived()(post-push), SamplesPushed=%d, InBuffer.Num()=%d, LocklessCircularBuffer.Num()=%d, LocklessCircularBuffer.Remainder()=%d, LocklessCircularBuffer.Capacity()=%d, This=0x%p"),
				SamplesPushed, InBuffer.Num(), CircularBuffer.Num(), CircularBuffer.Remainder(), CircularBuffer.GetCapacity(), this );
	}

	// Warn of not enough space in circular buffer, unless we're overwriting silence.
	if (SamplesPushed < InBuffer.Num())
	{
		// Prevent log spam by limiting to 1:100 logs.
		static const int32 NumLogMessagesToSkip = 100;
		static int32 LogPacifier = 0;
		UE_CLOG(LogPacifier++ % NumLogMessagesToSkip == 0, LogAudioLink, 
			Verbose, TEXT("FBufferedListenerBase: Overflow by '%d' Samples in Buffer Listener"), InBuffer.Num() - SamplesPushed);
	}
}

void FBufferedListenerBase::ResetFormat()
{
	FWriteScopeLock WriteLock(FormatKnownRwLock);
	KnownFormat.Reset();
}

void FBufferedListenerBase::SetFormat(const FBufferFormat& InFormat)
{
	FWriteScopeLock WriteLock(FormatKnownRwLock);
	KnownFormat = InFormat;
}

bool FBufferedListenerBase::IsStartedNonAtomic() const
{
	return bStarted;
}

bool FBufferedListenerBase::TrySetStartedFlag()
{
	// We expect not to be started.
	bool bExpected = false;
	bool bDesired = true;
	return bStarted.compare_exchange_strong(bExpected, bDesired);
}

bool FBufferedListenerBase::TryUnsetStartedFlag()
{
	// We expect be started.
	bool bExpected = true;
	bool bDesired = false;
	return bStarted.compare_exchange_strong(bExpected, bDesired);
}

bool FBufferedListenerBase::TrySetStoppingFlag()
{
	bool bExpected = false;
	bool bDesired = true;
	return bStopping.compare_exchange_strong(bExpected, bDesired);
}

void FBufferedListenerBase::PushSilence(int32 InNumSamplesOfSilence)
{
	CircularBuffer.PushZeros(InNumSamplesOfSilence);
}

void FBufferedListenerBase::Reserve(int32 InNumSamplesToReserve, int32 InNumSamplesOfSilence)
{
	// This Zeros the buffer also so should only be done at the start.
	CircularBuffer.SetCapacity(InNumSamplesToReserve);	
	
	// Optionally add silence into the buffer, this will cause latency.
	if (InNumSamplesOfSilence > 0)
	{
		PushSilence(InNumSamplesOfSilence);
	}
}

================================


=== BufferedListenerBase.h ===
==============================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "AudioDevice.h"
#include "DSP/Dsp.h"

#include "IBufferedAudioOutput.h"
#include "Misc/Optional.h"
#include "Math/UnrealMathUtility.h"

// Simple locking circular buffer
// Uses 32bit wrap around logic explained here: 
// https://www.snellman.net/blog/archive/2016-12-13-ring-buffers/
class FLockingCircularSampleBuffer
{	
public:
	FLockingCircularSampleBuffer(int32 InInitialCapacity)
	{
		SetCapacity(InInitialCapacity);
	}

	// Allow the caller to lock the CS ahead of calling (if necessary)
	FCriticalSection& GetCriticialSection() { return CS; }
	const FCriticalSection& GetCriticialSection() const { return CS; }

	// This doesn't preserve contents.
	void SetCapacity(int32 InCapacity)
	{
		check(InCapacity > 0);

		if(!FMath::IsPowerOfTwo(InCapacity))
		{
			InCapacity = FMath::RoundUpToPowerOfTwo(InCapacity);
		}

		FScopeLock Lock(&CS);
		Buffer.SetNumZeroed(InCapacity, EAllowShrinking::Yes);
		Mask = InCapacity-1;
		Read = 0; // Empty.
		Write = 0;

		check(Mask != 0);
	}
	int32 GetCapacity() const
	{
		FScopeLock Lock(&CS);
		return Buffer.Num();
	}
	int32 Num() const
	{
		FScopeLock Lock(&CS);
		return Write-Read;
	}
	
	// Get number of samples that can be pushed onto the buffer before it is full.
	int32 Remainder() const
	{
		FScopeLock Lock(&CS);
		return Buffer.Num() - Num();
	}

	int32 Push(const float* InBuffer, int32 InSize)
	{
		FScopeLock Lock(&CS);

		int32 CanPush = FMath::Min(Remainder(), InSize);
		for (int32 i = 0; i < CanPush ; ++i)
		{
			Enqueue(InBuffer[i]);
		}
		return CanPush;		
	}
	int32 Pop(float* OutBuffer, int32 InNumSamples)
	{
		FScopeLock Lock(&CS);
		int32 CanPop = FMath::Min(Num(),InNumSamples);
		for(int32 i=0; i < CanPop; ++i)
		{
			OutBuffer[i] = Dequeue();
		}
		return CanPop;
	}

	int32 PushZeros(int32 InNumSamplesOfSilence)
	{
		FScopeLock Lock(&CS);
		int32 CanPush = FMath::Min(GetCapacity(), InNumSamplesOfSilence);
		for(int32 i = 0; i < CanPush; ++i)
		{
			Enqueue(0.f);
		}
		return CanPush;
	}
private:
	uint32 Read = 0;		// These grow indefinitely until wrap at 2^32,
	uint32 Write = 0;		// this allows us to use full capacity as write >= read.
	uint32 Mask = 0;
	TArray<float> Buffer;
	mutable FCriticalSection CS;

	// NOTE: Not forceinline as compiler does better job without.
	void Enqueue(const float InFloat)
	{
		Buffer[Write++ & Mask] = InFloat;
	}
	float Dequeue()
	{
		return Buffer[Read++ & Mask];
	}
};

/** Common base class of Buffered Listener objects.
*/
class FBufferedListenerBase : public IBufferedAudioOutput
{
protected:
	AUDIOLINKENGINE_API FBufferedListenerBase(int32 InDefaultCircularBufferSize);
	virtual ~FBufferedListenerBase() = default;

	//~ Begin IBufferedAudioOutput
	AUDIOLINKENGINE_API bool PopBuffer(float* InBuffer, int32 InBufferSizeInSamples, int32& OutSamplesWritten) override;
	AUDIOLINKENGINE_API bool GetFormat(IBufferedAudioOutput::FBufferFormat& OutFormat) const override;
	AUDIOLINKENGINE_API void Reserve(int32 InNumSamplesToReserve, int32 InNumSamplesOfSilence) override;
	AUDIOLINKENGINE_API void SetFormatKnownDelegate(FOnFormatKnown InFormatKnownDelegate) override;
	void SetBufferStreamEndDelegate(FOnBufferStreamEnd) override {}
	//~ End IBufferedAudioOutput

	//* Common path to receive a new buffer, call from derived classes */
	AUDIOLINKENGINE_API void OnBufferReceived(const FBufferFormat& InFormat, TArrayView<const float> InBuffer);

	//* Reset the format of the buffer */
	AUDIOLINKENGINE_API void ResetFormat();

	//* Set the format of the buffer */
	AUDIOLINKENGINE_API void SetFormat(const FBufferFormat& InFormat);
	
	//* Ask if the started flag has been set. Note this is non-atomic, as it could change during the call */	
	AUDIOLINKENGINE_API bool IsStartedNonAtomic() const;
		
	//* Attempt to set our state to started. Not this can fail if we're already started. */	
	AUDIOLINKENGINE_API bool TrySetStartedFlag(); 
	
	//* Attempt to set started to false. This can fail if we're already stopped. */	
	AUDIOLINKENGINE_API bool TryUnsetStartedFlag();

	AUDIOLINKENGINE_API bool TrySetStoppingFlag();

private:	
	AUDIOLINKENGINE_API void PushSilence(int32 InNumSamplesOfSilence);

	/** Buffer to hold the data for the single source we're listening to, interleaved. */
	FLockingCircularSampleBuffer CircularBuffer;

	/** Read/Write slim lock protects format known optional */
	mutable FRWLock FormatKnownRwLock;

	/** Optional that holds the buffer format, if (and when) it's known. Protected by r/w Slim-lock */
	TOptional<FBufferFormat> KnownFormat;

	/** Delegate that fires when the format it known. Normally on the first buffer received. */
	FOnFormatKnown OnFormatKnown;

	/** Atomic flag we've been started */
	std::atomic<bool> bStarted;

	/** Atomic flag we've been told to stop */
	std::atomic<bool> bStopping;
};

==============================


=== BufferedSourceListener.cpp ===
==================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "BufferedSourceListener.h"

/** Buffered Source Listener. */
FBufferedSourceListener::FBufferedSourceListener(int32 InDefaultCircularBufferSize)
	: FBufferedListenerBase{ InDefaultCircularBufferSize }
{
}

FBufferedSourceListener::~FBufferedSourceListener()
{
	// No need to stop as its only record keeping and nothing to unregister.
}

bool FBufferedSourceListener::Start(FAudioDevice*)
{
	return TrySetStartedFlag();
}

void FBufferedSourceListener::Stop(FAudioDevice*)
{
	TrySetStoppingFlag();
	TryUnsetStartedFlag();
}

/** AUDIO MIXER THREAD. When a source is finished and returned to the pool, this call will be called. */
void FBufferedSourceListener::OnSourceReleased(const int32 InSourceId)
{	
	if (InSourceId == CurrentSourceId)
	{
		// Fire delegate to any interested parties.
		IBufferedAudioOutput::FBufferStreamEnd Params;
		Params.Id = CurrentSourceId;
		OnBufferStreamEndDelegate.ExecuteIfBound(Params);

		// Reset our source id.
		CurrentSourceId = INDEX_NONE;

		// Mark us stopping.
		Stop(nullptr);

	}
}

void FBufferedSourceListener::SetBufferStreamEndDelegate(FOnBufferStreamEnd InBufferStreamEndDelegate)
{
	OnBufferStreamEndDelegate = InBufferStreamEndDelegate;
}

/** AUDIO MIXER THREAD. New Audio buffers from the active sources enter here. */
void FBufferedSourceListener::OnNewBuffer(const ISourceBufferListener::FOnNewBufferParams& InParams)
{
	if (IsStartedNonAtomic()) 
	{
		// Make sure caller is sane.
		check(InParams.AudioData);
		check(InParams.NumChannels > 0);
		check(InParams.NumSamples > 0);
		check(InParams.SampleRate > 0);
		check(InParams.SourceId >= 0);
		
		// Multiple sources can call this same instance, so make sure we're only listening to one.
		int32 OriginalCurrentSourceId = CurrentSourceId.load(std::memory_order_relaxed);	
		if (OriginalCurrentSourceId == INDEX_NONE)
		{
			// Exchange CurrentSourceId, which is INDEX_NONE with InSourceId  (unless another thread beats us to it). 
			int32 NotSetSourceId = INDEX_NONE;
			if (!CurrentSourceId.compare_exchange_strong(/* expected */ NotSetSourceId, /* desired */ InParams.SourceId, std::memory_order_relaxed))
			{
				return;
			}
		}

		// Call to base class to handle.
		FBufferFormat NewFormat;
		NewFormat.NumChannels = InParams.NumChannels;
		NewFormat.NumSamplesPerBlock = InParams.NumSamples;
		NewFormat.NumSamplesPerSec = InParams.SampleRate;
		OnBufferReceived(NewFormat, MakeArrayView(InParams.AudioData, InParams.NumSamples));
	}
}

==================================


=== BufferedSourceListener.h ===
================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "AudioDevice.h"
#include "BufferedListenerBase.h"

/**
	FBufferedSourceListener: Concrete implementation of both a buffer listener and buffered output.
	Contains a circular buffer.
*/
class FBufferedSourceListener : public ISourceBufferListener, public FBufferedListenerBase
{
public:
	AUDIOLINKENGINE_API FBufferedSourceListener(int32 InDefaultCircularBufferSize);
	AUDIOLINKENGINE_API virtual ~FBufferedSourceListener();

	/**
	 * @param  InDevice Audio Device to register this listener with.
	 * @param  InOnFirstBufferCallback Delegate to fire when the format of the buffer is known.
	 *
	 * @return  success true, false otherwise.
	 */
	AUDIOLINKENGINE_API bool Start(FAudioDevice* InDevice) override;

	/** Stop the buffer by unregistering the buffer listener */
	AUDIOLINKENGINE_API void Stop(FAudioDevice* InDevice) override;
	
private:
	//~ Begin ISourceBufferListener
	AUDIOLINKENGINE_API void OnNewBuffer(const ISourceBufferListener::FOnNewBufferParams& InParams) override;
	AUDIOLINKENGINE_API void OnSourceReleased(const int32 SourceId) override;
	//~ End ISourceBufferListener

	//~ Begin IBufferedAudioOutput
	AUDIOLINKENGINE_API void SetBufferStreamEndDelegate(FOnBufferStreamEnd InBufferStreamEndDelegate) override;
	//~ End IBufferedAudioOutput

	std::atomic<int32> CurrentSourceId	= INDEX_NONE;		// r/w AudioMixer thread.	
	FOnBufferStreamEnd OnBufferStreamEndDelegate;
};

================================


=== BufferedSubmixListener.cpp ===
==================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "BufferedSubmixListener.h"
#include "AudioMixerDevice.h"

namespace BufferedSubmixListenerPrivate
{
	static Audio::FDeviceId InvalidAudioDeviceId = static_cast<Audio::FDeviceId>(INDEX_NONE);
}

/** Buffered Submix Listener. */
FBufferedSubmixListener::FBufferedSubmixListener(int32 InDefaultCircularBufferSize, bool bInZeroInputBuffer, const FString* InName)
	: FBufferedListenerBase{ InDefaultCircularBufferSize }
	, DeviceId{ BufferedSubmixListenerPrivate::InvalidAudioDeviceId }
	, bZeroInputBuffer{ bInZeroInputBuffer }
{
	if (InName)
	{
		Name = *InName;
	}
}

FBufferedSubmixListener::~FBufferedSubmixListener()
{
	// We should have been unregistered.
	check(DeviceId == BufferedSubmixListenerPrivate::InvalidAudioDeviceId);
	check(!IsStartedNonAtomic());
}

const FString& FBufferedSubmixListener::GetListenerName() const
{
	return Name;
}

void FBufferedSubmixListener::RegisterWithAudioDevice(FAudioDevice* InDevice)
{
	check(InDevice);

	DeviceId = InDevice->DeviceID;
	InDevice->RegisterSubmixBufferListener(AsShared(), InDevice->GetMainSubmixObject());
}

void FBufferedSubmixListener::UnregsiterWithAudioDevice(FAudioDevice* InDevice)
{
	check(InDevice);

	if (ensure(DeviceId != BufferedSubmixListenerPrivate::InvalidAudioDeviceId))
	{
		DeviceId = BufferedSubmixListenerPrivate::InvalidAudioDeviceId;
		InDevice->UnregisterSubmixBufferListener(AsShared(), InDevice->GetMainSubmixObject());
	}
}

bool FBufferedSubmixListener::Start(FAudioDevice* InAudioDevice)
{
	if (ensure(InAudioDevice))
	{
		if (TrySetStartedFlag())
		{
			RegisterWithAudioDevice(InAudioDevice);
		}
	}
	return false;
}

void FBufferedSubmixListener::Stop(FAudioDevice* InAudioDevice)
{
	if (ensure(InAudioDevice))
	{
		if (ensure(InAudioDevice->DeviceID == DeviceId))
		{
			if (TryUnsetStartedFlag())
			{
				UnregsiterWithAudioDevice(InAudioDevice);
			}
		}
	}
}

void FBufferedSubmixListener::OnNewSubmixBuffer(const USoundSubmix* OwningSubmix, float* AudioData, int32 InNumSamples, int32 InNumChannels, const int32 InSampleRate, double)
{
	if (IsStartedNonAtomic())
	{
		// Call to base class to handle.
		FBufferFormat NewFormat;
		NewFormat.NumChannels = InNumChannels;
		NewFormat.NumSamplesPerBlock = InNumSamples;
		NewFormat.NumSamplesPerSec = InSampleRate;
		OnBufferReceived(NewFormat, MakeArrayView(AudioData, InNumSamples));

		// Optionally, zero the buffer if we're asked to. This in the case where we're running both Unreal+Consumer renderers at once.
		// NOTE: this is dangerous as there's a chance we're not the only listener registered on this Submix. And will cause
		// listeners after us to have a silent buffer. Use with caution. 

		if (bZeroInputBuffer)
		{
			FMemory::Memzero(AudioData, sizeof(float) * InNumSamples);
		}	
	}
}

==================================


=== BufferedSubmixListener.h ===
================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BufferedListenerBase.h"
#include "ISubmixBufferListener.h"

/** Concrete Submix Buffer Listener  
*/
class FBufferedSubmixListener : public ISubmixBufferListener, public FBufferedListenerBase
{
public:
	/** Constructor
	 * @param  InDefaultCircularBufferSize: Size of the circular buffer in samples by default.
	 * @param  bInZeroInputBuffer: The passed in buffer will be set zeroed after we've buffered it.
	 * @param InName(Optional): Optional name to track listener lifetime with. 
	 */
	AUDIOLINKENGINE_API FBufferedSubmixListener(int32 InDefaultCircularBufferSize, bool bInZeroInputBuffer, const FString* InName);

	AUDIOLINKENGINE_API virtual ~FBufferedSubmixListener();

	/**
	 * Starts the Submix buffer listener by registering it with the passed in Audio Device.
	 * @param  InDevice Audio Device to register this submix listener with.
	 * @param  InOnFirstBufferCallback Delegate to fire when the format of the buffer is known.
	 *
	 * @return  success true, false otherwise.
	 */
	AUDIOLINKENGINE_API bool Start(FAudioDevice* InDevice) override;
	AUDIOLINKENGINE_API void Stop(FAudioDevice* InDevice) override;

private:
	void RegisterWithAudioDevice(FAudioDevice* InDevice);
	void UnregsiterWithAudioDevice(FAudioDevice* InDevice);
	
	//~ Begin ISubmixBufferListener
	AUDIOLINKENGINE_API void OnNewSubmixBuffer(const USoundSubmix* OwningSubmix, float* AudioData, int32 InNumSamples, int32 InNumChannels, const int32 InSampleRate, double) override;
	AUDIOLINKENGINE_API const FString& GetListenerName() const override;
	//~ End ISubmixBufferListener

	Audio::FDeviceId DeviceId;
	bool bZeroInputBuffer = false;
	FString Name;
};

================================


=== IAudioLink.cpp ===
======================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "IAudioLink.h"

#include "AudioAnalytics.h"

IAudioLink::IAudioLink()
{
	Audio::Analytics::RecordEvent_Usage(TEXT("AudioLink.InstanceCreated"));
}

======================


=== IAudioLink.h ===
====================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "HAL/Platform.h"
#include "Math/Transform.h"
#include "Delegates/DelegateCombinations.h"

/** IAudioLink
  *	Abstract interface for AudioLink instances. 
  *	Purely opaque.
  */
class IAudioLink
{
protected:
	AUDIOLINKENGINE_API IAudioLink();
public:
	virtual ~IAudioLink() = default;
};

/** IAudioLinkSourcePushed
  *	Where the owning object needs to push it's state
  */
class IAudioLinkSourcePushed : public IAudioLink
{
protected:
	IAudioLinkSourcePushed() = default;
public:
	virtual ~IAudioLinkSourcePushed() = default;

	struct FOnUpdateWorldStateParams
	{
		FTransform	WorldTransform;
	};
	virtual void OnUpdateWorldState(const FOnUpdateWorldStateParams&) = 0;

	struct FOnNewBufferParams
	{
		TArrayView<float> Buffer;
		int32 SourceId = INDEX_NONE;
	};
	virtual void OnNewBuffer(const FOnNewBufferParams&) = 0;

	virtual void OnSourceDone(const int32 SourceId) = 0;

	virtual void OnSourceReleased(const int32 SourceId) = 0;


};

/** IAudioLinkSynchronizer
  *	Provides delegates for hooking and external AudioLinks synchronization callbacks.
  */
class IAudioLinkSynchronizer
{
protected:
	IAudioLinkSynchronizer() = default;
public:
	virtual ~IAudioLinkSynchronizer() = default;	
	
	DECLARE_MULTICAST_DELEGATE(FOnSuspend);
	virtual FDelegateHandle RegisterSuspendDelegate(const FOnSuspend::FDelegate&) = 0;
	virtual bool RemoveSuspendDelegate(const FDelegateHandle&) = 0;

	DECLARE_MULTICAST_DELEGATE(FOnResume);
	virtual FDelegateHandle RegisterResumeDelegate(const FOnResume::FDelegate&) = 0;
	virtual bool RemoveResumeDelegate(const FDelegateHandle&) = 0;

	struct FOnOpenStreamParams
	{
		FString Name;
		int32 NumFrames = INDEX_NONE; 
		int32 NumChannels = INDEX_NONE;
		int32 SampleRate = INDEX_NONE;
	};

	DECLARE_MULTICAST_DELEGATE_OneParam(FOnOpenStream, const FOnOpenStreamParams&);
	virtual FDelegateHandle RegisterOpenStreamDelegate(const FOnOpenStream::FDelegate&) = 0;
	virtual bool RemoveOpenStreamDelegate(const FDelegateHandle&) = 0;

	DECLARE_MULTICAST_DELEGATE(FOnCloseStream);
	virtual FDelegateHandle RegisterCloseStreamDelegate(const FOnCloseStream::FDelegate&) = 0;
	virtual bool RemoveCloseStreamDelegate(const FDelegateHandle&) = 0;

	struct FOnRenderParams 
	{
		uint64 BufferTickID = 0;
		int32 NumFrames = INDEX_NONE;
	};
	
	DECLARE_MULTICAST_DELEGATE_OneParam(FOnBeginRender, const FOnRenderParams&);
	virtual FDelegateHandle RegisterBeginRenderDelegate(const FOnBeginRender::FDelegate&) = 0;
	virtual bool RemoveBeginRenderDelegate(const FDelegateHandle&) = 0;

	DECLARE_MULTICAST_DELEGATE_OneParam(FOnEndRender, const FOnRenderParams&);
	virtual FDelegateHandle RegisterEndRenderDelegate(const FOnEndRender::FDelegate&) = 0;
	virtual bool RemoveEndRenderDelegate(const FDelegateHandle&) = 0;
};

====================


=== IAudioLinkBlueprintInterface.cpp ===
========================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "IAudioLinkBlueprintInterface.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(IAudioLinkBlueprintInterface)

UAudioLinkBlueprintInterface::UAudioLinkBlueprintInterface(FObjectInitializer const& InObjectInitializer)
	: UInterface(InObjectInitializer)
{
}


========================================


=== IAudioLinkBlueprintInterface.h ===
======================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "UObject/Interface.h"
#include "UObject/ObjectMacros.h"
#include "UObject/UObjectGlobals.h"

#include "IAudioLinkBlueprintInterface.generated.h"

class UObject;
class USoundBase;
struct FFrame;

UINTERFACE(BlueprintType, meta = (CannotImplementInterfaceInBlueprint), MinimalAPI)
class UAudioLinkBlueprintInterface : public UInterface
{
	GENERATED_UINTERFACE_BODY()
};

class IAudioLinkBlueprintInterface : public IInterface
{
	GENERATED_IINTERFACE_BODY()

public:	
	UFUNCTION(BlueprintCallable, Category = "AudioLink")
	virtual void SetLinkSound(USoundBase* NewSound) = 0;

	UFUNCTION(BlueprintCallable, Category = "AudioLink")
	virtual void PlayLink(float StartTime = 0.0f) = 0;

	/** Stop an audio component's sound, issue any delegates if needed */
	UFUNCTION(BlueprintCallable, Category = "AudioLink")
	virtual void StopLink() = 0;
		
	UFUNCTION(BlueprintCallable, Category = "AudioLink")
	virtual bool IsLinkPlaying() const = 0;
};


======================================


=== IAudioLinkFactory.cpp ===
=============================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "IAudioLinkFactory.h"
#include "Algo/Transform.h"
#include "AudioLinkLog.h"

// Concrete Buffer Listeners.
#include "BufferedSubmixListener.h" 
#include "BufferedSourceListener.h" 

namespace AudioLinkFactory_Private
{
	bool IsEnabled()
	{
		static bool bAudioLinkEnabled = true;
		static FAutoConsoleVariableRef CVarAudioLinkEnabled(TEXT("au.audiolink.enabled"), bAudioLinkEnabled, TEXT("Enable AudioLink"), ECVF_Default);
		return bAudioLinkEnabled;
	}
}

IAudioLinkFactory::IAudioLinkFactory()
{
	if (AudioLinkFactory_Private::IsEnabled())
	{
		IModularFeatures::Get().RegisterModularFeature(GetModularFeatureName(), this);
	}
	else
	{
		UE_LOG(LogAudioLink, Warning, TEXT("AudioLink is disabled, au.audiolink.enabled=0. Not registering factory."));
	}
}

IAudioLinkFactory::~IAudioLinkFactory()
{
	IModularFeatures::Get().UnregisterModularFeature(GetModularFeatureName(), this);
}

FSharedBufferedOutputPtr IAudioLinkFactory::CreateSourceBufferListener(const FSourceBufferListenerCreateParams& InSourceCreateParams)
{	
	auto SourceBufferListenerSP = MakeShared<FBufferedSourceListener, ESPMode::ThreadSafe>(InSourceCreateParams.SizeOfBufferInFrames);
	if (!InSourceCreateParams.AudioComponent.IsExplicitlyNull())
	{
		check(IsInGameThread());
		InSourceCreateParams.AudioComponent->SetSourceBufferListener(SourceBufferListenerSP, InSourceCreateParams.bShouldZeroBuffer);
	}
	return SourceBufferListenerSP;
}

FSharedBufferedOutputPtr IAudioLinkFactory::CreatePushableBufferListener(const FPushedBufferListenerCreateParams& InPushableCreateParams)
{
	// Add push functionality to the source buffer listener with simple wrapper
	struct FPushableSourceBufferListener : FBufferedSourceListener, IPushableAudioOutput
	{
		using FBufferedSourceListener::FBufferedSourceListener;

		IPushableAudioOutput* GetPushableInterface() override { return this; }
		const IPushableAudioOutput* GetPushableInterface() const { return this; }

		void PushNewBuffer(const IPushableAudioOutput::FOnNewBufferParams& InNewBuffer) override
		{
			ISourceBufferListener::FOnNewBufferParams Params;
			Params.AudioData = InNewBuffer.AudioData;
			Params.NumChannels = InNewBuffer.NumChannels;
			Params.NumSamples = InNewBuffer.NumSamples;
			Params.SourceId = InNewBuffer.Id;
			Params.SampleRate = InNewBuffer.SampleRate;
			static_cast<ISourceBufferListener*>(this)->OnNewBuffer(Params);
		}

		void LastBuffer(int32 InId) override
		{
			static_cast<ISourceBufferListener*>(this)->OnSourceReleased(InId);
		}
	};

	auto SourceBufferListenerSP = MakeShared<FPushableSourceBufferListener, ESPMode::ThreadSafe>(InPushableCreateParams.SizeOfBufferInFrames);
	
	return SourceBufferListenerSP;
}

FSharedBufferedOutputPtr IAudioLinkFactory::CreateSubmixBufferListener(const FSubmixBufferListenerCreateParams& InSubmixCreateParams)
{
	const FString ListenerName = FString::Format(TEXT("IAudioLinkFactory:{0}"), { *GetFactoryName().ToString() });
	return MakeShared<FBufferedSubmixListener, ESPMode::ThreadSafe>(InSubmixCreateParams.SizeOfBufferInFrames, InSubmixCreateParams.bShouldZeroBuffer, &ListenerName);
}

TArray<IAudioLinkFactory*> IAudioLinkFactory::GetAllRegisteredFactories()
{
	IModularFeatures::FScopedLockModularFeatureList ScopedLockModularFeatureList;
	return IModularFeatures::Get().GetModularFeatureImplementations<IAudioLinkFactory>(GetModularFeatureName());
}

TArray<FName> IAudioLinkFactory::GetAllRegisteredFactoryNames()
{
	TArray<FName> Names;
	Algo::Transform(GetAllRegisteredFactories(), Names, [](IAudioLinkFactory* Factory) { return Factory->GetFactoryName(); });
	return Names;
}

IAudioLinkFactory* IAudioLinkFactory::FindFactory(const FName InFactoryImplName)
{
	TArray<IAudioLinkFactory*> Factories = GetAllRegisteredFactories();
	if (IAudioLinkFactory** Found = Factories.FindByPredicate([InFactoryImplName](IAudioLinkFactory* Factory) { return Factory->GetFactoryName() == InFactoryImplName; }))
	{
		return *Found;
	}
	return nullptr;
}

=============================


=== IAudioLinkFactory.h ===
===========================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "IAudioLink.h"
#include "Features/IModularFeatures.h"
#include "AudioDeviceManager.h"
#include "AudioLinkSettingsAbstract.h"
#include "Templates/SubclassOf.h"
#include "IBufferedAudioOutput.h"

// Forward declarations.
class USoundSubmix;
class UAudioLinkComponent;

/**
	IAudioLinkFactory
	Abstract interface for AudioLink factory objects. 
*/
class IAudioLinkFactory : public IModularFeature
{
protected:
	/** Constructor will auto register this instance. */
	AUDIOLINKENGINE_API IAudioLinkFactory();
public:
	/** Destructor will auto unregister this instance. */
	AUDIOLINKENGINE_API virtual ~IAudioLinkFactory();

	/** 
	 * Gets the name of this factory type. This will uniquely identity itself, so it can be found by the FindFactory call below
	 * @return Name of factory
	 */
	virtual FName GetFactoryName() const = 0;

	/**
	 * Gets the type of of the settings object that this factory uses to define its specific settings. All settings for each
	 * AudioLink factory will derive from UAudioLinkSettingsAbstract
	 * @return Class of the Settings Object
	 */
	virtual TSubclassOf<UAudioLinkSettingsAbstract> GetSettingsClass() const = 0;
	
	struct FSourceBufferListenerCreateParams
	{
		int32 SizeOfBufferInFrames = 0;
		bool bShouldZeroBuffer = false;
		TWeakObjectPtr<UAudioComponent> AudioComponent;
		TWeakObjectPtr<USceneComponent> OwningComponent;
	};
	AUDIOLINKENGINE_API virtual FSharedBufferedOutputPtr CreateSourceBufferListener(const FSourceBufferListenerCreateParams&);

	struct FPushedBufferListenerCreateParams
	{
		int32 SizeOfBufferInFrames = INDEX_NONE;
		bool bShouldZeroBuffer = false;
	};
	AUDIOLINKENGINE_API virtual FSharedBufferedOutputPtr CreatePushableBufferListener(const FPushedBufferListenerCreateParams&);

	struct FSubmixBufferListenerCreateParams
	{
		int32 SizeOfBufferInFrames = 0;
		bool bShouldZeroBuffer = false;
	};
	AUDIOLINKENGINE_API virtual FSharedBufferedOutputPtr CreateSubmixBufferListener(const FSubmixBufferListenerCreateParams&);
			
	/**
	 * Parameters use when creating a Submix Audio Link 
	 */
	struct FAudioLinkSubmixCreateArgs
	{
		TWeakObjectPtr<const USoundSubmix> Submix;
		FAudioDevice* Device = nullptr;
		TWeakObjectPtr<const UAudioLinkSettingsAbstract> Settings;
	};

	/**
	 * Create a Submix Audio Link.
	 * @param InCreateArgs Arguments used to create the AudioLink instance
	 * @return The newly created Link instance (if successful).
	 */
	virtual TUniquePtr<IAudioLink> CreateSubmixAudioLink(const FAudioLinkSubmixCreateArgs& InCreateArgs) = 0;

	/**
	 * Parameters use when creating a Source Audio Link 
	 */
	struct FAudioLinkSourceCreateArgs
	{
		TWeakObjectPtr<UAudioComponent> AudioComponent;
		TWeakObjectPtr<USceneComponent> OwningComponent;
		TWeakObjectPtr<UAudioLinkSettingsAbstract> Settings;
	};

	/**
	 * Create a Source Audio Link.
	 * @param InCreateArgs Arguments used to create the AudioLink instance
	 * @return The newly created Link instance (if successful).
	 */
	virtual TUniquePtr<IAudioLink> CreateSourceAudioLink(const FAudioLinkSourceCreateArgs&) = 0;
	
	struct FAudioLinkSourcePushedCreateArgs
	{
		FName OwnerName;
		int32 NumChannels = INDEX_NONE;
		int32 SampleRate = INDEX_NONE;
		int32 NumFramesPerBuffer = INDEX_NONE;
		int32 TotalNumFramesInSource = INDEX_NONE;
		UAudioLinkSettingsAbstract::FSharedSettingsProxyPtr Settings;
	};	
	using FAudioLinkSourcePushedSharedPtr = TSharedPtr<IAudioLinkSourcePushed, ESPMode::ThreadSafe>;
	virtual FAudioLinkSourcePushedSharedPtr CreateSourcePushedAudioLink(const FAudioLinkSourcePushedCreateArgs&) = 0;

	/**
	 * Create a AudioLinkSynchronizer callback
	 * @return The newly created Link instance (if successful).
	 */
	using FAudioLinkSynchronizerSharedPtr = TSharedPtr<IAudioLinkSynchronizer, ESPMode::ThreadSafe>;
	virtual FAudioLinkSynchronizerSharedPtr CreateSynchronizerAudioLink() = 0;
		
	/**	
	 * Get the name of all AudioLink factories in the Modular Features registry.
	 * @return "AudioLink Factory"
	 */

	inline static FName GetModularFeatureName()
	{
		static FName FeatureName = FName(TEXT("AudioLink Factory"));
		return FeatureName;
	}

	/**
	 * Gets all registered factory instances.
	 * @return Array of all factories.
	 */
	static AUDIOLINKENGINE_API TArray<IAudioLinkFactory*> GetAllRegisteredFactories();

	/**
	 * Gets all registered factory names
	 * @return Array of all factory names
	 */
	static AUDIOLINKENGINE_API TArray<FName> GetAllRegisteredFactoryNames();
	
	/**
	 * Gets all registered factory names
	 * @return Array of all factory names
	 */
	static AUDIOLINKENGINE_API IAudioLinkFactory* FindFactory(const FName InFactoryName);

protected:	
};


===========================


=== IBufferedAudioOutput.h ===
==============================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreTypes.h"
#include "Delegates/Delegate.h"

class FAudioDevice;

class IPushableAudioOutput
{
public:
	struct FOnNewBufferParams
	{
		const float* AudioData = nullptr;
		int32 Id = INDEX_NONE;
		int32 NumSamples = INDEX_NONE;
		int32 NumChannels = INDEX_NONE;
		int32 SampleRate = INDEX_NONE;
	};
	virtual void PushNewBuffer(const FOnNewBufferParams&) = 0;	
	virtual void LastBuffer(int32 InId) = 0;
};

/**
	Abstract interface for communication with outputting audio objects
	Examples concrete implementation of these are (source, submix etc).
*/

class IBufferedAudioOutput 
{
protected:
	IBufferedAudioOutput() = default;

public:
	virtual ~IBufferedAudioOutput() = default;

	/**
	 * The format of a buffer.
	 */
	struct FBufferFormat
	{
		int32 NumSamplesPerBlock = 0;
		int32 NumChannels = 0;
		int32 NumSamplesPerSec = 0;

		bool operator==(const FBufferFormat& InRhs) const
		{
			return InRhs.NumChannels == NumChannels && 
				InRhs.NumSamplesPerBlock == NumSamplesPerBlock && 
				InRhs.NumSamplesPerSec == NumSamplesPerSec;
		}
	};

	// Delegates.
	DECLARE_DELEGATE_OneParam(FOnFormatKnown, FBufferFormat);
	virtual void SetFormatKnownDelegate(FOnFormatKnown InFormatKnownDelegate) = 0;

	/**
	 * Stream of buffers ended.
	 */
	struct FBufferStreamEnd
	{
		int32 Id = INDEX_NONE;
	};

	// Delegates.
	DECLARE_DELEGATE_OneParam(FOnBufferStreamEnd, FBufferStreamEnd);
	virtual void SetBufferStreamEndDelegate(FOnBufferStreamEnd InBufferStreamEndDelegate) = 0;

	virtual bool Start(FAudioDevice* InAudioDevice) = 0;
	virtual void Stop(FAudioDevice* InAudioDevice) = 0;

	/**
	 * Attempts to Atomically copy a buffer sized amount of Buffered Sample data from the interface.
	 * 
	 * @param InBuffer Sample Buffer to Write to
	 * @param InBufferSizeInSamples Buffer Size in total samples. 
	 * @param OutSamplesWritten Number of Samples Written to the buffer
	 * 
	 * @return false no more data, true more data to come
	 */
	virtual bool PopBuffer(float* InBuffer, int32 InBufferSizeInSamples, int32& OutSamplesWritten) = 0;

	/**
	 * Gets the format of the buffer, if its known.
	 *
	 * @return  success true, false otherwise. 
	 */
	virtual bool GetFormat(FBufferFormat& OutFormat) const = 0;

	/**
	 * Reserve at least this many samples in buffer.
	 *
	 * @param InNumSamplesToReserve Reserve this number of samples.
	 */
	virtual void Reserve(int32 InNumSamplesToReserve, int32 InNumSamplesOfSilence = 0) = 0;

	virtual IPushableAudioOutput* GetPushableInterface() { return nullptr; }
	virtual const IPushableAudioOutput* GetPushableInterface() const { return nullptr; }
};

using FWeakBufferedOutputPtr = TWeakPtr<IBufferedAudioOutput, ESPMode::ThreadSafe>;
using FSharedBufferedOutputPtr = TSharedPtr<IBufferedAudioOutput, ESPMode::ThreadSafe>;


==============================

