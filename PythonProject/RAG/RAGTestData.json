{
  "metadata": {
    "total_files": 3,
    "extensions": [
      ".h",
      ".cpp",
      ".cs"
    ],
    "root_path": "C:\\Users\\jjh\\Desktop\\RAG",
    "total_lines": 968,
    "created_at": "2024-11-29T23:13:08.696831"
  },
  "files": [
    {
      "file_path": "Public\\AIConfig.h",
      "extension": ".h",
      "size_bytes": 329,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n\n// various parameters will be exposed to config at some point\nnamespace FAIConfig\n{\n\tnamespace Navigation\n\t{\n\t\t// distance to focal point along current velocity vector\n\t\tAIMODULE_API extern float FocalPointDistance;\n\t}\n};\n",
      "lines": 15
    },
    {
      "file_path": "Private\\Actions\\PawnAction.cpp",
      "extension": ".cpp",
      "size_bytes": 13008,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Actions/PawnAction.h\"\n#include \"UObject/Package.h\"\n#include \"EngineGlobals.h\"\n#include \"Engine/Engine.h\"\n#include \"Actions/PawnActionsComponent.h\"\n#include \"AIController.h\"\n#include \"VisualLogger/VisualLogger.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(PawnAction)\n\nPRAGMA_DISABLE_DEPRECATION_WARNINGS\n\nDEFINE_LOG_CATEGORY(LogPawnAction);\n\nnamespace\n{\n\tFString GetActionResultName(int64 Value)\n\t{\n\t\tstatic const UEnum* Enum = StaticEnum<EPawnActionResult::Type>();\n\t\tcheck(Enum);\n\t\treturn Enum->GetNameStringByValue(Value);\n\t}\n}\n\nUDEPRECATED_PawnAction::UDEPRECATED_PawnAction(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n\t, RequiredResources(FAIResourcesSet::AllResources)\n\t, AbortState(EPawnActionAbortState::NeverStarted)\n\t, FinishResult(EPawnActionResult::NotStarted)\n{\n\t// actions start their lives paused\n\tbPaused = true;\n\tbFailedToStart = false;\n\tIndexOnStack = INDEX_NONE;\n}\n\nUWorld* UDEPRECATED_PawnAction::GetWorld() const\n{\n\treturn OwnerComponent_DEPRECATED ? OwnerComponent_DEPRECATED->GetWorld() : Cast<UWorld>(GetOuter());\n}\n\nvoid UDEPRECATED_PawnAction::Tick(float DeltaTime)\n{\n}\n\nEPawnActionAbortState::Type UDEPRECATED_PawnAction::Abort(EAIForceParam::Type ShouldForce)\n{\n\t// if already aborting, and this request is not Forced, just skip it\n\tif (AbortState != EPawnActionAbortState::NotBeingAborted && ShouldForce != EAIForceParam::Force)\n\t{\n\t\tif (AbortState == EPawnActionAbortState::NeverStarted)\n\t\t{\n\t\t\tUE_VLOG(GetPawn(), LogPawnAction, Log, TEXT(\"%s> Discarding Abort request since the action has never been started yet\"), *GetName());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUE_VLOG(GetPawn(), LogPawnAction, Log, TEXT(\"%s> Discarding Abort request due to action being already in abort state\"), *GetName());\n\t\t}\n\t\t\n\t\treturn AbortState;\n\t}\n\n\tconst bool bForce = ShouldForce == EAIForceParam::Force;\n\tEPawnActionAbortState::Type Result = EPawnActionAbortState::NotBeingAborted;\n\tEPawnActionAbortState::Type ChildResult = EPawnActionAbortState::AbortDone;\n\n\tSetAbortState(EPawnActionAbortState::MarkPendingAbort);\n\n\tif (ChildAction_DEPRECATED != NULL)\n\t{\n\t\tChildResult = ChildAction_DEPRECATED->Abort(ShouldForce);\n\n\t\tif (ChildResult == EPawnActionAbortState::NotBeingAborted)\n\t\t{\n\t\t\tUE_VLOG(GetPawn(), LogPawnAction, Error, TEXT(\"%s> ChildAction_DEPRECATED %s failed to carry out proper abortion! Things might get ugly..\")\n\t\t\t\t, *GetName(), *ChildAction_DEPRECATED->GetName());\n\n\t\t\t// fake proper result and hope for the best!\n\t\t\tChildResult = EPawnActionAbortState::AbortDone;\n\t\t}\n\t}\n\n\tif (bForce)\n\t{\n\t\tResult = PerformAbort(ShouldForce);\n\t\tif (Result != EPawnActionAbortState::AbortDone)\n\t\t{\n\t\t\tUE_VLOG(GetPawn(), LogPawnAction, Error, TEXT(\"%s> failed to force-abort! Things might get ugly..\")\n\t\t\t\t, *GetName());\n\n\t\t\t// fake proper result and hope for the best!\n\t\t\tResult = EPawnActionAbortState::AbortDone;\n\t\t}\n\t}\n\telse\n\t{\n\t\tswitch (ChildResult)\n\t\t{\n\t\tcase EPawnActionAbortState::MarkPendingAbort:\n\t\t\t// this means child is awaiting its abort, so should parent\n\t\tcase EPawnActionAbortState::LatentAbortInProgress:\n\t\t\t// this means child is performing time-consuming abort. Parent should wait\n\t\t\tResult = EPawnActionAbortState::MarkPendingAbort;\n\t\t\tbreak;\n\n\t\tcase EPawnActionAbortState::AbortDone:\n\t\t\tResult = IsPaused() ? EPawnActionAbortState::MarkPendingAbort : PerformAbort(ShouldForce);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tUE_VLOG(GetPawn(), LogPawnAction, Error, TEXT(\"%s> Unhandled Abort State!\")\n\t\t\t\t, *GetName());\n\t\t\tResult = EPawnActionAbortState::AbortDone;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tSetAbortState(Result);\n\n\treturn Result;\n}\n\nAPawn* UDEPRECATED_PawnAction::GetPawn() const\n{\n\treturn OwnerComponent_DEPRECATED ? OwnerComponent_DEPRECATED->GetControlledPawn() : NULL;\n}\n\nAController* UDEPRECATED_PawnAction::GetController() const\n{\n\treturn OwnerComponent_DEPRECATED ? OwnerComponent_DEPRECATED->GetController() : NULL;\n}\n\nvoid UDEPRECATED_PawnAction::SetAbortState(EPawnActionAbortState::Type NewAbortState)\n{\n\t// allowing only progression\n\tif (NewAbortState <= AbortState)\n\t{\n\t\treturn;\n\t}\n\n\tAbortState = NewAbortState;\n\tif (AbortState == EPawnActionAbortState::AbortDone)\n\t{\n\t\tSendEvent(EPawnActionEventType::FinishedAborting);\n\t}\n}\n\nvoid UDEPRECATED_PawnAction::SendEvent(EPawnActionEventType::Type Event)\n{\n\tif (IsValid(OwnerComponent_DEPRECATED))\n\t{\n\t\t// this will get communicated to parent action if needed, latently \n\t\tOwnerComponent_DEPRECATED->OnEvent(*this, Event);\n\t}\n\n\tActionObserver.ExecuteIfBound(*this, Event);\n}\n\nvoid UDEPRECATED_PawnAction::StopWaitingForMessages()\n{\n\tMessageHandlers.Reset();\n}\n\nvoid UDEPRECATED_PawnAction::SetFinishResult(EPawnActionResult::Type Result)\n{\n\t// once return value had been set it's no longer possible to back to InProgress\n\tif (Result <= EPawnActionResult::InProgress)\n\t{\n\t\tUE_VLOG(GetPawn(), LogPawnAction, Warning, TEXT(\"%s> UDEPRECATED_PawnAction::SetFinishResult setting FinishResult as EPawnActionResult::InProgress or EPawnActionResult::NotStarted - should not be happening\"), *GetName());\n\t\treturn;\n\t}\n\n\tif (FinishResult != Result)\n\t{\n\t\tFinishResult = Result;\n\t}\n}\n\nvoid UDEPRECATED_PawnAction::SetOwnerComponent(UDEPRECATED_PawnActionsComponent* Component)\n{\n\tif (OwnerComponent_DEPRECATED != NULL && OwnerComponent_DEPRECATED != Component)\n\t{\n\t\tUE_VLOG(GetPawn(), LogPawnAction, Warning, TEXT(\"%s> UDEPRECATED_PawnAction::SetOwnerComponent called to change already set valid owner component\"), *GetName());\n\t}\n\n\tOwnerComponent_DEPRECATED = Component;\n\tif (Component != NULL)\n\t{\n\t\tAAIController* AIController = Cast<AAIController>(Component->GetController());\n\t\tif (AIController != NULL)\n\t\t{\n\t\t\tBrainComp = AIController->FindComponentByClass<UBrainComponent>();\n\t\t}\n\t}\n}\n\nvoid UDEPRECATED_PawnAction::SetInstigator(UObject* const InInstigator)\n{ \n\tif (Instigator && Instigator != InInstigator)\n\t{\n\t\tUE_VLOG(GetPawn(), LogPawnAction, Warning, TEXT(\"%s> setting Instigator to %s when already has instigator set to %s\")\n\t\t\t, *GetName(), *Instigator->GetName(), InInstigator ? *InInstigator->GetName() : TEXT(\"<null>\"));\n\t}\n\tInstigator = InInstigator; \n}\n\nvoid UDEPRECATED_PawnAction::Finish(TEnumAsByte<EPawnActionResult::Type> WithResult)\n{\n\tUE_VLOG(GetPawn(), LogPawnAction, Log, TEXT(\"%s> finishing with result %s\")\n\t\t, *GetName(), *GetActionResultName(WithResult));\n\n\tSetFinishResult(WithResult);\n\n\tStopWaitingForMessages();\n\n\tSendEvent(EPawnActionEventType::FinishedExecution);\n}\n\nbool UDEPRECATED_PawnAction::Activate()\n{\n\tbool bResult = false; \n\n\tUE_VLOG(GetPawn(), LogPawnAction, Log, TEXT(\"%s> Activating at priority %s! First start? %s Paused? %s\")\n\t\t, *GetName()\n\t\t, *GetPriorityName()\n\t\t, HasBeenStarted() ? TEXT(\"NO\") : TEXT(\"YES\")\n\t\t, IsPaused() ? TEXT(\"YES\") : TEXT(\"NO\"));\n\n\tif (HasBeenStarted() && IsPaused())\n\t{\n\t\tbResult = Resume();\n\t\tif (bResult == false)\n\t\t{\n\t\t\tUE_VLOG(GetPawn(), LogPawnAction, Log, TEXT(\"%s> Failed to RESUME.\")\n\t\t\t\t, *GetName());\n\t\t\tbFailedToStart = true;\n\t\t\tSetFinishResult(EPawnActionResult::Failed);\n\t\t\tSendEvent(EPawnActionEventType::FailedToStart);\n\t\t}\n\t}\n\telse \n\t{\n\t\tbResult = Start();\n\t\tif (bResult == false)\n\t\t{\n\t\t\tUE_VLOG(GetPawn(), LogPawnAction, Log, TEXT(\"%s> Failed to START.\")\n\t\t\t\t, *GetName());\n\t\t\tbFailedToStart = true;\n\t\t\tSetFinishResult(EPawnActionResult::Failed);\n\t\t\tSendEvent(EPawnActionEventType::FailedToStart);\n\t\t}\n\t}\n\n\treturn bResult;\n}\n\nvoid UDEPRECATED_PawnAction::OnPopped()\n{\n\t// not calling OnFinish if action haven't actually started\n\tif (!bFailedToStart || bAlwaysNotifyOnFinished)\n\t{\n\t\tOnFinished(FinishResult);\n\t}\n}\n\nbool UDEPRECATED_PawnAction::Start()\n{\n\tAbortState = EPawnActionAbortState::NotBeingAborted;\n\tFinishResult = EPawnActionResult::InProgress;\n\tbPaused = false;\n\treturn true;\n}\n\n\nbool UDEPRECATED_PawnAction::Pause(const UDEPRECATED_PawnAction* PausedBy)\n{\n\t// parent should be paused anyway\n\tensure(ParentAction_DEPRECATED == NULL || ParentAction_DEPRECATED->IsPaused() == true);\n\n\t// don't pause twice, this should be guaranteed by the PawnActionsComponent\n\tensure(bPaused == false);\n\t\n\tif (AbortState == EPawnActionAbortState::LatentAbortInProgress || AbortState == EPawnActionAbortState::AbortDone)\n\t{\n\t\tUE_VLOG(GetPawn(), LogPawnAction, Warning, TEXT(\"%s> Not pausing due to being in unpausable aborting state\"), *GetName());\n\t\treturn false;\n\t}\n\n\tUE_VLOG(GetPawn(), LogPawnAction, Log, TEXT(\"%s> Pausing...\"), *GetName());\n\t\n\tbPaused = true;\n\n\tif (ChildAction_DEPRECATED)\n\t{\n\t\tChildAction_DEPRECATED->Pause(PausedBy);\n\t}\n\n\treturn bPaused;\n}\n\nbool UDEPRECATED_PawnAction::Resume()\n{\n\t// parent should be paused anyway\n\tensure(ParentAction_DEPRECATED == NULL || ParentAction_DEPRECATED->IsPaused() == true);\n\n\t// do not unpause twice\n\tif (bPaused == false)\n\t{\n\t\treturn false;\n\t}\n\t\n\tensure(ChildAction_DEPRECATED == NULL);\n\n\tif (ChildAction_DEPRECATED)\n\t{\n\t\tUE_VLOG(GetPawn(), LogPawnAction, Log, TEXT(\"%s> Resuming child, %s\"), *GetName(), *ChildAction_DEPRECATED->GetName());\n\t\tChildAction_DEPRECATED->Resume();\n\t}\n\telse\n\t{\n\t\tUE_VLOG(GetPawn(), LogPawnAction, Log, TEXT(\"%s> Resuming.\"), *GetName());\n\t\tbPaused = false;\n\t}\n\n\treturn !bPaused;\n}\n\nvoid UDEPRECATED_PawnAction::OnFinished(EPawnActionResult::Type WithResult)\n{\n}\n\nvoid UDEPRECATED_PawnAction::OnChildFinished(UDEPRECATED_PawnAction& Action, EPawnActionResult::Type WithResult)\n{\n\tUE_VLOG(GetPawn(), LogPawnAction, Log, TEXT(\"%s> Child \\'%s\\' finished with result %s\")\n\t\t, *GetName(), *Action.GetName(), *GetActionResultName(WithResult));\n\n\tensure(Action.ParentAction_DEPRECATED == this);\n\tensure(ChildAction_DEPRECATED == &Action);\n\tAction.ParentAction_DEPRECATED = NULL;\n\tChildAction_DEPRECATED = NULL;\n}\n\nvoid UDEPRECATED_PawnAction::OnPushed()\n{\n\tIndexOnStack = 0;\n\tUDEPRECATED_PawnAction* PrevAction = ParentAction_DEPRECATED;\n\twhile (PrevAction)\n\t{\n\t\t++IndexOnStack;\n\t\tPrevAction = PrevAction->ParentAction_DEPRECATED;\n\t}\n\n\tUE_VLOG(GetPawn(), LogPawnAction, Log, TEXT(\"%s> Pushed with priority %s, IndexOnStack: %d, instigator %s\")\n\t\t, *GetName(), *GetPriorityName(), IndexOnStack, *GetNameSafe(Instigator));\n}\n\nbool UDEPRECATED_PawnAction::PushChildAction(UDEPRECATED_PawnAction& Action)\n{\n\tbool bResult = false;\n\t\n\tif (OwnerComponent_DEPRECATED != NULL)\n\t{\n\t\tUE_CVLOG( ChildAction_DEPRECATED != NULL\n\t\t\t, GetPawn(), LogPawnAction, Log, TEXT(\"%s> Pushing child action %s while already having ChildAction_DEPRECATED set to %s\")\n\t\t\t, *GetName(), *Action.GetName(), *ChildAction_DEPRECATED->GetName());\n\t\t\n\t\t// copy runtime data\n\t\t// note that priority and instigator will get assigned as part of PushAction.\n\n\t\tbResult = OwnerComponent_DEPRECATED->PushAction(Action, GetPriority(), Instigator);\n\n\t\t// adding a check to make sure important data has been set \n\t\tensure(Action.GetPriority() == GetPriority() && Action.GetInstigator() == GetInstigator());\n\t}\n\n\treturn bResult;\n}\n\n//----------------------------------------------------------------------//\n// messaging\n//----------------------------------------------------------------------//\n\nvoid UDEPRECATED_PawnAction::WaitForMessage(FName MessageType, FAIRequestID InRequestID)\n{\n\tMessageHandlers.Add(FAIMessageObserver::Create(BrainComp, MessageType, InRequestID.GetID(), FOnAIMessage::CreateUObject(this, &UDEPRECATED_PawnAction::HandleAIMessage)));\n}\n\n//----------------------------------------------------------------------//\n// blueprint interface\n//----------------------------------------------------------------------//\n\nUDEPRECATED_PawnAction* UDEPRECATED_PawnAction::CreateActionInstance(UObject* WorldContextObject, TSubclassOf<UDEPRECATED_PawnAction> ActionClass)\n{\n\tUWorld* World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull);\n\tif (World && ActionClass)\n\t{\n\t\treturn NewObject<UDEPRECATED_PawnAction>(World, ActionClass);\n\t}\n\treturn NULL;\n}\n\n//----------------------------------------------------------------------//\n// debug\n//----------------------------------------------------------------------//\n\nFString UDEPRECATED_PawnAction::GetStateDescription() const\n{\n\tstatic const UEnum* AbortStateEnum = StaticEnum<EPawnActionAbortState::Type>(); \n\t\t\n\tif (AbortState != EPawnActionAbortState::NotBeingAborted)\n\t{\n\t\treturn *AbortStateEnum->GetDisplayNameTextByValue(AbortState).ToString();\n\t}\n\treturn IsPaused() ? TEXT(\"Paused\") : TEXT(\"Active\");\n}\n\nFString UDEPRECATED_PawnAction::GetPriorityName() const\n{\n\tstatic const UEnum* Enum = StaticEnum<EAIRequestPriority::Type>();\n\tcheck(Enum);\n\treturn Enum->GetNameStringByValue(GetPriority());\n}\n\nFString UDEPRECATED_PawnAction::GetDisplayName() const\n{\n\treturn GetClass()->GetName();\n}\n\nPRAGMA_ENABLE_DEPRECATION_WARNINGS\n",
      "lines": 431
    },
    {
      "file_path": "Program.cs",
      "extension": ".cs",
      "size_bytes": 20613,
      "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n// This software is provided \"as-is,\" without any express or implied warranty. \n// In no event shall the author, nor Epic Games, Inc. be held liable for any damages arising from the use of this software.\n// This software will not be supported.\n// Use at your own risk.\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Diagnostics;\nusing System.Reflection;\nusing EpicGames.Core;\nusing System.IO;\nusing System.Collections.Generic;\nusing UnrealBuildBase;\nusing Microsoft.Extensions.Logging;\n\nnamespace AutomationToolDriver\n{\n\t/// <summary>\n\t/// Main entry point\n\t/// </summary>\n\tpublic partial class Program\n\t{\n\t\t/// <summary>\n\t\t/// Parses command line parameter.\n\t\t/// </summary>\n\t\t/// <param name=\"CurrentParam\">Parameter</param>\n\t\t/// <param name=\"CurrentCommand\">Recently parsed command</param>\n\t\t/// <param name=\"Logger\">Logger for output</param>\n\t\t/// <returns>True if the parameter has been successfully parsed.</returns>\n\t\tprivate static void ParseParam(string CurrentParam, CommandInfo CurrentCommand, ILogger Logger)\n\t\t{\n\t\t\tif (AutomationToolCommandLine.IsParameterIgnored(CurrentParam))\n            {\n\t\t\t\treturn;\n            }\n\n\t\t\tbool bGlobalParam = AutomationToolCommandLine.TrySetGlobal(CurrentParam);\n\n\t\t\t// Global value parameters, handled explicitly\n\t\t\tstring Option_ScriptsForProject = \"-ScriptsForProject\";\n\t\t\tstring Option_ScriptDir = \"-ScriptDir\";\n\t\t\tstring Option_Telemetry = \"-Telemetry\";\n\t\t\tstring Option_WaitForStdStreams = \"-WaitForStdStreams\";\n\n\t\t\t// The parameter was not found in the list of global parameters, continue looking...\n\t\t\tif (CurrentParam.StartsWith(Option_ScriptsForProject + \"=\", StringComparison.InvariantCultureIgnoreCase))\n\t\t\t{\n\t\t\t\tif (AutomationToolCommandLine.IsSetUnchecked(Option_ScriptsForProject))\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(\"The -ScriptsForProject argument may only be specified once\");\n\t\t\t\t}\n\n\t\t\t\tstring ProjectFileName = CurrentParam.Substring(CurrentParam.IndexOf('=') + 1).Replace(\"\\\"\", \"\");\n\t\t\t\tFileReference ProjectReference = NativeProjectsBase.FindProjectFile(ProjectFileName, Logger);\n\n\t\t\t\tif (ProjectReference != null)\n\t\t\t\t{\n\t\t\t\t\tAutomationToolCommandLine.SetUnchecked(Option_ScriptsForProject, ProjectReference.FullName);\n\t\t\t\t\tLogger.LogDebug(\"Found project file: {0}\", ProjectReference.FullName);\n\t\t\t\t}\n\t\t\t\telse if (Path.IsPathFullyQualified(ProjectFileName))\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception($\"Project '{ProjectFileName}' does not exist\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception($\"Project '{ProjectFileName}' does not exist relative to any entries in *.uprojectdirs\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (CurrentParam.StartsWith(Option_ScriptDir + \"=\", StringComparison.InvariantCultureIgnoreCase))\n\t\t\t{\n\t\t\t\tstring ScriptDir = CurrentParam.Substring(CurrentParam.IndexOf('=') + 1);\n\t\t\t\tif (Directory.Exists(ScriptDir))\n\t\t\t\t{\n\t\t\t\t\tList<string> OutAdditionalScriptDirectories = (List<string>)AutomationToolCommandLine.GetValueUnchecked(Option_ScriptDir) ?? new List<string>();\n\t\t\t\t\tOutAdditionalScriptDirectories.Add(Path.GetFullPath(ScriptDir));\n\t\t\t\t\tAutomationToolCommandLine.SetUnchecked(Option_ScriptDir, OutAdditionalScriptDirectories);\n\t\t\t\t\tLogger.LogDebug(\"Found additional script dir: {0}\", Path.GetFullPath(ScriptDir));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDirectoryReference ScriptDirReference = NativeProjectsBase.FindRelativeDirectoryReference(ScriptDir, Logger);\n\n\t\t\t\t\tif (ScriptDirReference != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tList<string> OutAdditionalScriptDirectories = (List<string>)AutomationToolCommandLine.GetValueUnchecked(Option_ScriptDir) ?? new List<string>();\n\t\t\t\t\t\tOutAdditionalScriptDirectories.Add(ScriptDirReference.FullName);\n\t\t\t\t\t\tAutomationToolCommandLine.SetUnchecked(Option_ScriptDir, OutAdditionalScriptDirectories);\n\t\t\t\t\t\tLogger.LogDebug(\"Found additional script dir: {0}\", ScriptDirReference.FullName);\n\t\t\t\t\t}\n\t\t\t\t\telse if (Path.IsPathFullyQualified(ScriptDir))\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new Exception($\"Specified ScriptDir doesn't exist: {ScriptDir}\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new Exception($\"Specified ScriptDir doesn't exist relative to any entries in *.uprojectdirs: {ScriptDir}\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (CurrentParam.StartsWith(Option_Telemetry + \"=\", StringComparison.InvariantCultureIgnoreCase))\n            {\n\t\t\t\tstring TelemetryPath = CurrentParam.Substring(CurrentParam.IndexOf('=') + 1);\n\t\t\t\tAutomationToolCommandLine.SetUnchecked(Option_Telemetry, TelemetryPath);\n\t\t\t}\n\t\t\telse if (CurrentParam.StartsWith(Option_WaitForStdStreams + \"=\", StringComparison.InvariantCultureIgnoreCase))\n\t\t\t{\n\t\t\t\tstring WaitTime = CurrentParam.Substring(CurrentParam.IndexOf('=') + 1);\n\t\t\t\tAutomationToolCommandLine.SetUnchecked(Option_WaitForStdStreams, WaitTime);\n\t\t\t}\n\t\t\telse if (CurrentParam.StartsWith(\"-\"))\n\t\t\t{\n\t\t\t\tif (CurrentCommand != null)\n\t\t\t\t{\n\t\t\t\t\tCurrentCommand.Arguments.Add(CurrentParam.Substring(1));\n\t\t\t\t}\n\t\t\t\telse if (!bGlobalParam)\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception($\"Unknown parameter {CurrentParam} in the command line that does not belong to any command.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (CurrentParam.Contains(\"=\"))\n\t\t\t{\n\t\t\t\t// Environment variable\n\t\t\t\tint ValueStartIndex = CurrentParam.IndexOf('=') + 1;\n\t\t\t\tstring EnvVarName = CurrentParam.Substring(0, ValueStartIndex - 1);\n\t\t\t\tif (String.IsNullOrEmpty(EnvVarName))\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception($\"Unable to parse environment variable that has no name. Error when parsing command line param {CurrentParam}\");\n\t\t\t\t}\n\t\t\t\tstring EnvVarValue = CurrentParam.Substring(ValueStartIndex);\n\n\t\t\t\tLogger.LogDebug($\"SetEnvVar {EnvVarName}={EnvVarValue}\");\n\t\t\t\tEnvironment.SetEnvironmentVariable(EnvVarName, EnvVarValue);\n\t\t\t}\n\t\t}\n\n\t\tprivate static string ParseString(string Key, string Value)\n\t\t{\n\t\t\tif (!String.IsNullOrEmpty(Key))\n\t\t\t{\n\t\t\t\tif (Value == \"true\" || Value == \"false\")\n\t\t\t\t{\n\t\t\t\t\treturn \"-\" + Key;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstring param = \"-\" + Key + \"=\";\n\t\t\t\t\tif (Value.Contains(\" \"))\n\t\t\t\t\t{\n\t\t\t\t\t\tparam += \"\\\"\" + Value + \"\\\"\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tparam += Value;\n\t\t\t\t\t}\n\t\t\t\t\treturn param;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn Value;\n\t\t\t}\n\t\t}\n\n\t\tprivate static string ParseList(string Key, List<object> Value)\n\t\t{\n\t\t\tstring param = \"-\" + Key + \"=\";\n\t\t\tbool bStart = true;\n\t\t\tforeach (var Val in Value)\n\t\t\t{\n\t\t\t\tif (!bStart)\n\t\t\t\t{\n\t\t\t\t\tparam += \"+\";\n\t\t\t\t}\n\t\t\t\tparam += Val as string;\n\t\t\t\tbStart = false;\n\t\t\t}\n\t\t\treturn param;\n\t\t}\n\n\t\tprivate static void ParseDictionary(Dictionary<string, object> Value, List<string> Arguments)\n\t\t{\n\t\t\tforeach (var Pair in Value)\n\t\t\t{\n\t\t\t\tif ((Pair.Value as string) != null && !string.IsNullOrEmpty(Pair.Value as string))\n\t\t\t\t{\n\t\t\t\t\tArguments.Add(ParseString(Pair.Key, Pair.Value as string));\n\t\t\t\t}\n\t\t\t\telse if (Pair.Value.GetType() == typeof(bool))\n\t\t\t\t{\n\t\t\t\t\tif ((bool)Pair.Value)\n\t\t\t\t\t{\n\t\t\t\t\t\tArguments.Add(\"-\" + Pair.Key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ((Pair.Value as List<object>) != null)\n\t\t\t\t{\n\t\t\t\t\tArguments.Add(ParseList(Pair.Key, Pair.Value as List<object>));\n\t\t\t\t}\n\t\t\t\telse if ((Pair.Value as Dictionary<string, object>) != null)\n\t\t\t\t{\n\t\t\t\t\tstring param = \"-\" + Pair.Key + \"=\\\"\";\n\t\t\t\t\tList<string> Args = new List<string>();\n\t\t\t\t\tParseDictionary(Pair.Value as Dictionary<string, object>, Args);\n\t\t\t\t\tbool bStart = true;\n\t\t\t\t\tforeach (var Arg in Args)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!bStart)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam += \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparam += Arg.Replace(\"\\\"\", \"\\'\");\n\t\t\t\t\t\tbStart = false;\n\t\t\t\t\t}\n\t\t\t\t\tparam += \"\\\"\";\n\t\t\t\t\tArguments.Add(param);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate static void ParseProfile(ref string[] CommandLine)\n\t\t{\n\t\t\t// find if there is a profile file to read\n\t\t\tstring Profile = \"\";\n\t\t\tList<string> Arguments = new List<string>();\n\t\t\tfor (int Index = 0; Index < CommandLine.Length; ++Index)\n\t\t\t{\n\t\t\t\tif (CommandLine[Index].StartsWith(\"-profile=\"))\n\t\t\t\t{\n\t\t\t\t\tProfile = CommandLine[Index].Substring(CommandLine[Index].IndexOf('=') + 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tArguments.Add(CommandLine[Index]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!string.IsNullOrEmpty(Profile))\n\t\t\t{\n\t\t\t\tif (File.Exists(Profile))\n\t\t\t\t{\n\t\t\t\t\t// find if the command has been specified\n\t\t\t\t\tvar text = File.ReadAllText(Profile);\n\t\t\t\t\tvar RawObject = fastJSON.JSON.Instance.Parse(text) as Dictionary<string, object>;\n\t\t\t\t\tvar Params = RawObject[\"scripts\"] as List<object>;\n\t\t\t\t\tforeach (var Script in Params)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring ScriptName = (Script as Dictionary<string, object>)[\"script\"] as string;\n\t\t\t\t\t\tif (!string.IsNullOrEmpty(ScriptName) && !Arguments.Contains(ScriptName))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tArguments.Add(ScriptName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(Script as Dictionary<string, object>).Remove(\"script\");\n\t\t\t\t\t\tParseDictionary((Script as Dictionary<string, object>), Arguments);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCommandLine = Arguments.ToArray();\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Parse the command line and create a list of commands to execute.\n\t\t/// </summary>\n\t\t/// <param name=\"Arguments\">Command line</param>\n\t\t/// <param name=\"Logger\">Logger for output</param>\n\t\tpublic static void ParseCommandLine(string[] Arguments, ILogger Logger)\n\t\t{\n\t\t\tAutomationToolCommandLine = new ParsedCommandLine(\n\t\t\t\tnew Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase)\n\t\t\t\t{\n\t\t\t\t\t{\"-Verbose\", \"Enables verbose logging\"},\n\t\t\t\t\t{\"-VeryVerbose\", \"Enables very verbose logging\"},\n\t\t\t\t\t{\"-TimeStamps\", \"\"},\n\t\t\t\t\t{\"-Submit\", \"Allows UAT command to submit changes\"},\n\t\t\t\t\t{\"-NoSubmit\", \"Prevents any submit attempts\"},\n\t\t\t\t\t{\"-NoP4\", \"Disables Perforce functionality {default if not run on a build machine}\"},\n\t\t\t\t\t{\"-P4\", \"Enables Perforce functionality {default if run on a build machine}\"},\n\t\t\t\t\t{\"-IgnoreDependencies\", \"\"},\n\t\t\t\t\t{\"-Help\", \"Displays help\"},\n\t\t\t\t\t{\"-List\", \"Lists all available commands\"},\n\t\t\t\t\t{\"-NoKill\", \"Does not kill any spawned processes on exit\"},\n\t\t\t\t\t{\"-UTF8Output\", \"\"},\n\t\t\t\t\t{\"-AllowStdOutLogVerbosity\", \"\"},\n\t\t\t\t\t{\"-NoAutoSDK\", \"\"},\n\t\t\t\t\t{\"-Compile\", \"Force all script modules to be compiled\"},\n\t\t\t\t\t{\"-NoCompile\", \"Do not attempt to compile any script modules - attempts to run with whatever is up to date\" },\n\t\t\t\t\t{\"-IgnoreBuildRecords\", \"Ignore build records (Intermediate/ScriptModule/ProjectName.json) files when determining if script modules are up to date\" },\n\t\t\t\t\t{\"-UseLocalBuildStorage\", @\"Allows you to use local storage for your root build storage dir {default of P:\\Builds {on PC} is changed to Engine\\Saved\\LocalBuilds}. Used for local testing.\"},\n\t\t\t\t\t{\"-WaitForDebugger\", \"Waits for a debugger to be attached, and breaks once debugger successfully attached.\"},\n\t\t\t\t\t{\"-BuildMachine\", \"\" },\n\t\t\t\t\t{\"-WaitForUATMutex\", \"\" },\n\t\t\t\t\t{\"-WaitForStdStreams\", \"Time in milliseconds to wait for std streams to close in child processes.\" }\n\t\t\t\t},\n\t\t\t\tnew HashSet<string>(StringComparer.InvariantCultureIgnoreCase) { \"-msbuild-verbose\", \"-NoCompileUAT\" }\n\t\t\t);\n\n\t\t\tParseProfile(ref Arguments);\n\n\t\t\tLogger.LogInformation(\"Parsing command line: {CommandLine}\", CommandLine.FormatCommandLine(Arguments));\n\n\t\t\tCommandInfo CurrentCommand = null;\n\t\t\tfor (int Index = 0; Index < Arguments.Length; ++Index)\n\t\t\t{\n\t\t\t\t// Guard against empty arguments passed as \"\" on the command line\n\t\t\t\tstring Param = Arguments[Index];\n\t\t\t\tif(Param.Length > 0) \n\t\t\t\t{\n\t\t\t\t\tif (Param.StartsWith(\"-\") || Param.Contains(\"=\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tParseParam(Arguments[Index], CurrentCommand, Logger);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tCurrentCommand = new CommandInfo(Arguments[Index]);\n\t\t\t\t\t\tAutomationToolCommandLine.CommandsToExecute.Add(CurrentCommand);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Validate\n\t\t\tvar Result = AutomationToolCommandLine.CommandsToExecute.Count > 0 || AutomationToolCommandLine.IsSetGlobal(\"-Help\") || AutomationToolCommandLine.IsSetGlobal(\"-List\");\n\t\t\tif (AutomationToolCommandLine.CommandsToExecute.Count > 0)\n\t\t\t{\n\t\t\t\tLogger.LogDebug(\"Found {NumScripts} scripts to execute:\", AutomationToolCommandLine.CommandsToExecute.Count);\n\t\t\t\tforeach (CommandInfo Command in AutomationToolCommandLine.CommandsToExecute)\n\t\t\t\t{\n\t\t\t\t\tLogger.LogDebug(\"  {Command}\", Command.ToString());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!Result)\n\t\t\t{\n\t\t\t\tthrow new Exception(\"Failed to find scripts to execute in the command line params.\");\n\t\t\t}\n\t\t\tif (AutomationToolCommandLine.IsSetGlobal(\"-NoP4\") && AutomationToolCommandLine.IsSetGlobal(\"-P4\"))\n\t\t\t{\n\t\t\t\tthrow new Exception(\"'-NoP4' and '-P4' can't be set simultaneously.\");\n\t\t\t}\n\t\t\tif (AutomationToolCommandLine.IsSetGlobal(\"-NoSubmit\") && AutomationToolCommandLine.IsSetGlobal(\"-Submit\"))\n\t\t\t{\n\t\t\t\tthrow new Exception(\"'-NoSubmit' and '-Submit' can't be set simultaneously.\");\n\t\t\t}\n\t\t}\n\n\n\t\tstatic ParsedCommandLine AutomationToolCommandLine;\n\t\tstatic StartupTraceListener StartupListener = new StartupTraceListener();\n\n\n\t\t/// <summary>\n\t\t/// Main entry point\n\t\t/// </summary>\n\t\t/// <remarks>Do not add [STAThread] here. It will cause deadlocks in platform automation code.</remarks>\n\t\tpublic static async Task<int> Main(string[] Arguments)\n\t\t{\n\t\t\tILogger Logger = Log.Logger;\n\n\t\t\t// Initialize the log system, buffering the output until we can create the log file\n\t\t\tLog.AddTraceListener(StartupListener);\n\t\t\tLogger.LogInformation(\"Starting AutomationTool...\");\n\n\t\t\t// Populate AutomationToolCommandLine and CommandsToExecute\n\t\t\ttry\n\t\t\t{\n\t\t\t\tParseCommandLine(Arguments, Logger);\n\t\t\t}\n\t\t\tcatch (Exception Ex)\n\t\t\t{\n\t\t\t\tLogger.LogError(Ex, \"ERROR: \" + Ex.Message);\n\t\t\t\treturn (int)ExitCode.Error_Arguments;\n\t\t\t}\n\n\t\t\t// Wait for a debugger to be attached\n\t\t\tif (AutomationToolCommandLine.IsSetGlobal(\"-WaitForDebugger\"))\t\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"Waiting for debugger to be attached...\");\n\t\t\t\twhile (Debugger.IsAttached == false)\n\t\t\t\t{\n\t\t\t\t\tThread.Sleep(100);\n\t\t\t\t}\n\t\t\t\tDebugger.Break();\n\t\t\t}\n\n\t\t\tStopwatch Timer = Stopwatch.StartNew();\n\t\t\t\n\t\t\t// Ensure UTF8Output flag is respected, since we are initializing logging early in the program.\n\t\t\tif (AutomationToolCommandLine.IsSetGlobal(\"-UTF8Output\"))\n            {\n                Console.OutputEncoding = new System.Text.UTF8Encoding(false, false);\n            }\n\n\t\t\t// Parse the log level argument\n\t\t\tif (AutomationToolCommandLine.IsSetGlobal(\"-Verbose\"))\n\t\t\t{\n\t\t\t\tLog.OutputLevel = LogEventType.Verbose;\n\t\t\t}\n\t\t\tif (AutomationToolCommandLine.IsSetGlobal(\"-VeryVerbose\"))\n\t\t\t{\n\t\t\t\tLog.OutputLevel = LogEventType.VeryVerbose;\n\t\t\t}\n\n\t\t\t// Configure log timestamps\n\t\t\tLog.IncludeTimestamps = AutomationToolCommandLine.IsSetGlobal(\"-Timestamps\");\n\n\t\t\t// Configure the structured logging event parser with matchers from UBT\n\t\t\tAssembly UnrealBuildToolAssembly = typeof(UnrealBuildTool.BuildVersion).Assembly;\n\t\t\tLog.EventParser.AddMatchersFromAssembly(UnrealBuildToolAssembly);\n\n\t\t\t// when running frmo RunUAT.sh (Mac/Linux) we need to install a Ctrl-C handler, or hitting Ctrl-C from a terminal\n\t\t\t// can leave dotnet process in a zombie state (some order of process destruction is failing)\n\t\t\t// by putting this in, the Ctrl-C may not be handled immediately, but it shouldn't leave a zombie process\n\t\t\tif (OperatingSystem.IsMacOS() || OperatingSystem.IsLinux())\n\t\t\t{\n\t\t\t\tConsole.CancelKeyPress += delegate\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine(\"AutomationTool: Ctrl-C pressed. Exiting...\");\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Enter the main program section\n\t\t\tExitCode ReturnCode = ExitCode.Error_Unknown;\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Set the working directory to the Unreal root directory\n\t\t\t\tEnvironment.CurrentDirectory = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().GetOriginalLocation()), \"..\", \"..\", \"..\", \"..\"));\n\n\t\t\t\t// Ensure we can resolve any external assemblies as necessary.\n\t\t\t\tstring PathToBinariesDotNET = Path.GetDirectoryName(Assembly.GetEntryAssembly().GetOriginalLocation());\n\t\t\t\tAssemblyUtils.InstallAssemblyResolver(PathToBinariesDotNET);\n\t\t\t\tAssemblyUtils.InstallRecursiveAssemblyResolver(PathToBinariesDotNET);\n\n\t\t\t\t// Log the operating environment. Since we usually compile to AnyCPU, we may be executed using different system paths under WOW64.\n\t\t\t\tLogger.LogDebug(\"Running on {Platform} as a {Bitness}-bit process.\", RuntimePlatform.Current.ToString(), Environment.Is64BitProcess ? 64 : 32);\n\n\t\t\t\t// Log if we're running from the launcher\n\t\t\t\tstring ExecutingAssemblyLocation = Assembly.GetExecutingAssembly().Location;\n\t\t\t\tif (string.Compare(ExecutingAssemblyLocation, Assembly.GetEntryAssembly().GetOriginalLocation(), StringComparison.OrdinalIgnoreCase) != 0)\n\t\t\t\t{\n\t\t\t\t\tLogger.LogDebug(\"Executed from AutomationToolLauncher ({Location})\", ExecutingAssemblyLocation);\n\t\t\t\t}\n\t\t\t\tLogger.LogDebug(\"CWD={Cwd}\", Environment.CurrentDirectory);\n\n\t\t\t\t// Log the application version\n\t\t\t\tFileVersionInfo Version = AssemblyUtils.ExecutableVersion;\n\t\t\t\tLogger.LogDebug(\"{ProductName} ver. {ProductVersion}\", Version.ProductName, Version.ProductVersion);\n\n\t\t\t\tbool bWaitForUATMutex = AutomationToolCommandLine.IsSetGlobal(\"-WaitForUATMutex\");\n\n\t\t\t\t// Don't allow simultaneous execution of AT (in the same branch)\n\t\t\t\tReturnCode = await ProcessSingleton.RunSingleInstanceAsync(MainProc, bWaitForUATMutex, Log.Logger);\n\t\t\t}\n\t\t\tcatch (Exception Ex)\n            {\n\t\t\t\tLogger.LogError(Ex, \"Unhandled exception: {Message}\", ExceptionUtils.FormatException(Ex));\n            }\n            finally\n            {\n\t\t\t\t// Write the exit code\n                Logger.LogInformation(\"AutomationTool executed for {Time}\", Timer.Elapsed.ToString(\"h'h 'm'm 's's'\"));\n                Logger.LogInformation(\"AutomationTool exiting with ExitCode={ExitCode} ({ExitReason})\", (int)ReturnCode, ReturnCode);\n\n                // Can't use NoThrow here because the code logs exceptions. We're shutting down logging!\n                Trace.Close();\n            }\n            return (int)ReturnCode;\n        }\n\n\t\tstatic async Task<ExitCode> MainProc()\n\t\t{\n\t\t\tILogger Logger = Log.Logger;\n\t\t\tLogger.LogInformation(\"Initializing script modules...\");\n\t\t\tvar StartTime = DateTime.UtcNow;\n\t\t\tstring ScriptsForProject = (string)AutomationToolCommandLine.GetValueUnchecked(\"-ScriptsForProject\");\n\t\t\tList<string> AdditionalScriptDirs = (List<string>) AutomationToolCommandLine.GetValueUnchecked(\"-ScriptDir\");\n\t\t\tbool bForceCompile = AutomationToolCommandLine.IsSetGlobal(\"-Compile\");\n\t\t\tbool bNoCompile = AutomationToolCommandLine.IsSetGlobal(\"-NoCompile\");\n\t\t\tbool bUseBuildRecords = !AutomationToolCommandLine.IsSetGlobal(\"-IgnoreBuildRecords\");\n\t\t\tList<CommandInfo> Commands = AutomationToolCommandLine.IsSetGlobal(\"-List\")\n\t\t\t\t? null\n\t\t\t\t: AutomationToolCommandLine.CommandsToExecute;\n\t\t\tbool bBuildSuccess;\n\t\t\tHashSet<FileReference> ScriptModuleAssemblyPaths = CompileScriptModule.InitializeScriptModules(\n\t\t\t\t\tRules.RulesFileType.AutomationModule, ScriptsForProject, AdditionalScriptDirs, bForceCompile, bNoCompile, bUseBuildRecords, \n\t\t\t\t\tout bBuildSuccess, (int Count) =>\n                    {\n\t\t\t\t\t\tLogger.LogInformation(\"Building {Count} projects (see Log 'Engine/Programs/AutomationTool/Saved/Logs/Log.txt' for more details)\", Count);\n\t\t\t\t\t},\n\t\t\t\t\tLog.Logger);\n\n\t\t\tif (!bBuildSuccess)\n            {\n\t\t\t\treturn ExitCode.Error_Unknown;\n            }\n\n\t\t\t// when the engine is installed, or UAT is invoked with -NoCompile, we expect to find at least one script module (AutomationUtils is a necessity)\n\t\t\tif (ScriptModuleAssemblyPaths.Count == 0)\n\t\t\t{\n\t\t\t\tthrow new Exception(\"Found no script module records.\");\n\t\t\t}\n\n\t\t\t// Load AutomationUtils.Automation.dll\n\t\t\tFileReference AssemblyPath = ScriptModuleAssemblyPaths.FirstOrDefault(x => x.GetFileNameWithoutExtension().Contains(\"AutomationUtils.Automation\"));\n\t\t\tAssembly AutomationUtilsAssembly = AssemblyPath != null ? Assembly.LoadFrom(AssemblyPath.FullName) : null;\n\n\t\t\tif (AutomationUtilsAssembly == null)\n            {\n\t\t\t\tthrow new Exception(\"Did not find an AutomationUtils.Automation.dll\");\n            }\n\n\t\t\t// Call into AutomationTool.Automation.Process()\n\n\t\t\tType AutomationTools_Automation = AutomationUtilsAssembly.GetType(\"AutomationTool.Automation\");\n\t\t\tMethodInfo Automation_Process = AutomationTools_Automation.GetMethod(\"ProcessAsync\");\n\t\t\tLogger.LogInformation(\"Total script module initialization time: {InitTime:0.00} s.\", (DateTime.UtcNow - StartTime).TotalMilliseconds / 1000);\n\t\t\treturn await (Task<ExitCode>) Automation_Process.Invoke(null,\n\t\t\t\tnew object[] {AutomationToolCommandLine, StartupListener, ScriptModuleAssemblyPaths});\n\t\t}\n\t}\n}\n",
      "lines": 522
    }
  ]
}