=== CODEBASE STRUCTURE ===

ğŸ“ MassEntity/
    â””â”€â”€ ğŸ“ Internal/
        â””â”€â”€ ğŸ“„ MassArchetypeData.h
    â””â”€â”€ ğŸ“ Private/
        â””â”€â”€ ğŸ“„ MassArchetypeData.cpp
        â””â”€â”€ ğŸ“„ MassArchetypeTypes.cpp
        â””â”€â”€ ğŸ“„ MassCommandBuffer.cpp
        â””â”€â”€ ğŸ“„ MassDebugger.cpp
        â””â”€â”€ ğŸ“„ MassEntityManager.cpp
        â””â”€â”€ ğŸ“„ MassEntityManagerConstants.h
        â””â”€â”€ ğŸ“„ MassEntityManagerStorage.cpp
        â””â”€â”€ ğŸ“„ MassEntityModule.cpp
        â””â”€â”€ ğŸ“„ MassEntityQuery.cpp
        â””â”€â”€ ğŸ“„ MassEntitySettings.cpp
        â””â”€â”€ ğŸ“„ MassEntitySubsystem.cpp
        â””â”€â”€ ğŸ“„ MassEntityTypes.cpp
        â””â”€â”€ ğŸ“„ MassEntityUtils.cpp
        â””â”€â”€ ğŸ“„ MassEntityView.cpp
        â””â”€â”€ ğŸ“„ MassExecutionContext.cpp
        â””â”€â”€ ğŸ“„ MassExecutor.cpp
        â””â”€â”€ ğŸ“„ MassObserverManager.cpp
        â””â”€â”€ ğŸ“„ MassObserverProcessor.cpp
        â””â”€â”€ ğŸ“„ MassObserverRegistry.cpp
        â””â”€â”€ ğŸ“„ MassProcessingPhaseManager.cpp
        â””â”€â”€ ğŸ“„ MassProcessingTypes.cpp
        â””â”€â”€ ğŸ“„ MassProcessor.cpp
        â””â”€â”€ ğŸ“„ MassProcessorDependencySolver.cpp
        â””â”€â”€ ğŸ“„ MassRequirementAccessDetector.cpp
        â””â”€â”€ ğŸ“„ MassRequirements.cpp
        â””â”€â”€ ğŸ“„ MassSettings.cpp
        â””â”€â”€ ğŸ“„ MassSubsystemAccess.cpp
        â””â”€â”€ ğŸ“„ MassSubsystemBase.cpp
    â””â”€â”€ ğŸ“ Public/
        â””â”€â”€ ğŸ“„ MassArchetypeTypes.h
        â””â”€â”€ ğŸ“„ MassCommandBuffer.h
        â””â”€â”€ ğŸ“„ MassCommands.h
        â””â”€â”€ ğŸ“„ MassDebugger.h
        â””â”€â”€ ğŸ“„ MassEntityManager.h
        â””â”€â”€ ğŸ“„ MassEntityManagerStorage.h
        â””â”€â”€ ğŸ“„ MassEntityQuery.h
        â””â”€â”€ ğŸ“„ MassEntitySettings.h
        â””â”€â”€ ğŸ“„ MassEntitySubsystem.h
        â””â”€â”€ ğŸ“„ MassEntityTypes.h
        â””â”€â”€ ğŸ“„ MassEntityUtils.h
        â””â”€â”€ ğŸ“„ MassEntityView.h
        â””â”€â”€ ğŸ“„ MassExecutionContext.h
        â””â”€â”€ ğŸ“„ MassExecutor.h
        â””â”€â”€ ğŸ“„ MassExternalSubsystemTraits.h
        â””â”€â”€ ğŸ“„ MassObserverManager.h
        â””â”€â”€ ğŸ“„ MassObserverProcessor.h
        â””â”€â”€ ğŸ“„ MassObserverRegistry.h
        â””â”€â”€ ğŸ“„ MassProcessingPhaseManager.h
        â””â”€â”€ ğŸ“„ MassProcessingTypes.h
        â””â”€â”€ ğŸ“„ MassProcessor.h
        â””â”€â”€ ğŸ“„ MassProcessorDependencySolver.h
        â””â”€â”€ ğŸ“„ MassRequirementAccessDetector.h
        â””â”€â”€ ğŸ“„ MassRequirements.h
        â””â”€â”€ ğŸ“„ MassSettings.h
        â””â”€â”€ ğŸ“„ MassSubsystemAccess.h
        â””â”€â”€ ğŸ“„ MassSubsystemBase.h
    â””â”€â”€ ğŸ“„ MassEntity.Build.cs


=== FILE CONTENTS ===


=== MassEntity/Internal/MassArchetypeData.h ===
===============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityManager.h"
#include "MassArchetypeTypes.h"


struct FMassEntityQuery;
struct FMassExecutionContext;
class FOutputDevice;
struct FMassArchetypeEntityCollection;

namespace UE::Mass
{
	int32 SanitizeChunkMemorySize(const int32 InChunkMemorySize, const bool bLogMismatch = true);
}

// This is one chunk within an archetype
struct FMassArchetypeChunk
{
private:
	uint8* RawMemory = nullptr;
	SIZE_T AllocSize = 0;
	int32 NumInstances = 0;
	int32 SerialModificationNumber = 0;
	TArray<FInstancedStruct> ChunkFragmentData;
	FMassArchetypeSharedFragmentValues SharedFragmentValues;

public:
	explicit FMassArchetypeChunk(const SIZE_T InAllocSize, TConstArrayView<FInstancedStruct> InChunkFragmentTemplates, FMassArchetypeSharedFragmentValues InSharedFragmentValues)
		: AllocSize(InAllocSize)
		, ChunkFragmentData(InChunkFragmentTemplates)
		, SharedFragmentValues(InSharedFragmentValues)
	{
		RawMemory = (uint8*)FMemory::Malloc(AllocSize);
	}

	~FMassArchetypeChunk()
	{
		// Only release memory if it was not done already.
		if (RawMemory != nullptr)
		{
			FMemory::Free(RawMemory);
			RawMemory = nullptr;
		}
	}

	// Returns the Entity array element at the specified index
	FMassEntityHandle& GetEntityArrayElementRef(int32 ChunkBase, int32 IndexWithinChunk)
	{
		return ((FMassEntityHandle*)(RawMemory + ChunkBase))[IndexWithinChunk];
	}

	uint8* GetRawMemory() const
	{
		return RawMemory;
	}

	int32 GetNumInstances() const
	{
		return NumInstances;
	}

	void AddMultipleInstances(uint32 Count)
	{
		NumInstances += Count;
		SerialModificationNumber++;
	}

	void RemoveMultipleInstances(uint32 Count)
	{
		NumInstances -= Count;
		check(NumInstances >= 0);
		SerialModificationNumber++;

		// Because we only remove trailing chunks to avoid messing up the absolute indices in the entities map,
		// We are freeing the memory here to save memory
		if (NumInstances == 0)
		{
			FMemory::Free(RawMemory);
			RawMemory = nullptr;
		}
	}

	void AddInstance()
	{
		AddMultipleInstances(1);
	}

	void RemoveInstance()
	{
		RemoveMultipleInstances(1);
	}

	int32 GetSerialModificationNumber() const
	{
		return SerialModificationNumber;
	}

	FStructView GetMutableChunkFragmentViewChecked(const int32 Index) { return FStructView(ChunkFragmentData[Index]); }

	FInstancedStruct* FindMutableChunkFragment(const UScriptStruct* Type)
	{
		return ChunkFragmentData.FindByPredicate([Type](const FInstancedStruct& Element)
			{
				return Element.GetScriptStruct()->IsChildOf(Type);
			});
	}

	void Recycle(TConstArrayView<FInstancedStruct> InChunkFragmentsTemplate, const FMassArchetypeSharedFragmentValues& InSharedFragmentValues)
	{
		checkf(NumInstances == 0, TEXT("Recycling a chunk that is not empty."));
		SerialModificationNumber++;
		ChunkFragmentData = InChunkFragmentsTemplate;
		SharedFragmentValues = InSharedFragmentValues;
		
		// If this chunk previously had entity and it does not anymore, we might have to reallocate the memory as it was freed to save memory
		if (RawMemory == nullptr)
		{
			RawMemory = (uint8*)FMemory::Malloc(AllocSize);
		}
	}

	bool IsValidSubChunk(const int32 StartIndex, const int32 Length) const
	{
		return StartIndex >= 0 && StartIndex < NumInstances && (StartIndex + Length) <= NumInstances;
	}

#if WITH_MASSENTITY_DEBUG
	int32 DebugGetChunkFragmentCount() const { return ChunkFragmentData.Num(); }
#endif // WITH_MASSENTITY_DEBUG

	FMassArchetypeSharedFragmentValues& GetMutableSharedFragmentValues() { return SharedFragmentValues; }
	const FMassArchetypeSharedFragmentValues& GetSharedFragmentValues() const { return SharedFragmentValues; }
};

// Information for a single fragment type in an archetype
struct FMassArchetypeFragmentConfig
{
	const UScriptStruct* FragmentType = nullptr;
	int32 ArrayOffsetWithinChunk = 0;

	void* GetFragmentData(uint8* ChunkBase, int32 IndexWithinChunk) const
	{
		return ChunkBase + ArrayOffsetWithinChunk + (IndexWithinChunk * FragmentType->GetStructureSize());
	}
};

// An archetype is defined by a collection of unique fragment types (no duplicates).
// Order doesn't matter, there will only ever be one FMassArchetypeData per unique set of fragment types per entity manager subsystem
struct FMassArchetypeData
{
private:
	// One-stop-shop variable describing the archetype's fragment and tag composition 
	FMassArchetypeCompositionDescriptor CompositionDescriptor;

	// Pre-created default chunk fragment templates
	TArray<FInstancedStruct> ChunkFragmentsTemplate;

	TArray<FMassArchetypeFragmentConfig, TInlineAllocator<16>> FragmentConfigs;
	
	TArray<FMassArchetypeChunk> Chunks;

	// Entity ID to index within archetype
	//@TODO: Could be folded into FEntityData in the entity manager at the expense of a bit
	// of loss of encapsulation and extra complexity during archetype changes
	TMap<int32, int32> EntityMap;
	
	TMap<const UScriptStruct*, int32> FragmentIndexMap;

	int32 NumEntitiesPerChunk;
	SIZE_T TotalBytesPerEntity = 0;
	int32 EntityListOffsetWithinChunk;

	// Archetype version at which this archetype was created, useful for query to do incremental archetype matching
	uint32 CreatedArchetypeDataVersion = 0;

#if WITH_MASSENTITY_DEBUG
	// Arrays of names the archetype is referred as.
	TArray<FName> DebugNames;
#endif // WITH_MASSENTITY_DEBUG

	// Defaults to UMassEntitySettings.ChunkMemorySize. In near future will support being set via constructor.
	const SIZE_T ChunkMemorySize = 0;
	
	friend FMassEntityQuery;
	friend FMassArchetypeEntityCollection;
	friend FMassDebugger;

public:
	explicit FMassArchetypeData(const FMassArchetypeCreationParams& CreationParams = FMassArchetypeCreationParams());

	TConstArrayView<FMassArchetypeFragmentConfig> GetFragmentConfigs() const { return FragmentConfigs; }
	const FMassFragmentBitSet& GetFragmentBitSet() const { return CompositionDescriptor.Fragments; }
	const FMassTagBitSet& GetTagBitSet() const { return CompositionDescriptor.Tags; }
	const FMassChunkFragmentBitSet& GetChunkFragmentBitSet() const { return CompositionDescriptor.ChunkFragments; }
	const FMassSharedFragmentBitSet& GetSharedFragmentBitSet() const { return CompositionDescriptor.SharedFragments; }
	const FMassConstSharedFragmentBitSet& GetConstSharedFragmentBitSet() const { return CompositionDescriptor.ConstSharedFragments; }

	const FMassArchetypeCompositionDescriptor& GetCompositionDescriptor() const { return CompositionDescriptor; }
	FORCEINLINE const FMassArchetypeSharedFragmentValues& GetSharedFragmentValues(int32 EntityIndex) const
	{ 
		const int32 AbsoluteIndex = EntityMap.FindChecked(EntityIndex);
		const int32 ChunkIndex = AbsoluteIndex / NumEntitiesPerChunk;

		return Chunks[ChunkIndex].GetSharedFragmentValues();
	}
	FORCEINLINE const FMassArchetypeSharedFragmentValues& GetSharedFragmentValues(FMassEntityHandle Entity) const
	{
		return GetSharedFragmentValues(Entity.Index);
	}

	/** Method to iterate on all the fragment types */
	void ForEachFragmentType(TFunction< void(const UScriptStruct* /*FragmentType*/)> Function) const;
	bool HasFragmentType(const UScriptStruct* FragmentType) const;
	bool HasTagType(const UScriptStruct* FragmentType) const { check(FragmentType); return CompositionDescriptor.Tags.Contains(*FragmentType); }

	bool IsEquivalent(const FMassArchetypeCompositionDescriptor& OtherCompositionDescriptor) const
	{
		return CompositionDescriptor.IsEquivalent(OtherCompositionDescriptor);
	}

	void Initialize(const FMassArchetypeCompositionDescriptor& InCompositionDescriptor, const uint32 ArchetypeDataVersion);

	/** 
	 * A special way of initializing an archetype resulting in a copy of BaseArchetype's setup with OverrideTags
	 * replacing original tags of BaseArchetype
	 */
	void InitializeWithSimilar(const FMassArchetypeData& BaseArchetype, FMassArchetypeCompositionDescriptor&& NewComposition, const uint32 ArchetypeDataVersion);

	void AddEntity(FMassEntityHandle Entity, const FMassArchetypeSharedFragmentValues& InSharedFragmentValues);
	void RemoveEntity(FMassEntityHandle Entity);

	bool HasFragmentDataForEntity(const UScriptStruct* FragmentType, int32 EntityIndex) const;
	void* GetFragmentDataForEntityChecked(const UScriptStruct* FragmentType, int32 EntityIndex) const;
	void* GetFragmentDataForEntity(const UScriptStruct* FragmentType, int32 EntityIndex) const;

	FORCEINLINE const int32* GetInternalIndexForEntity(const int32 EntityIndex) const { return EntityMap.Find(EntityIndex); }
	FORCEINLINE int32 GetInternalIndexForEntityChecked(const int32 EntityIndex) const { return EntityMap.FindChecked(EntityIndex); }
	int32 GetNumEntitiesPerChunk() const { return NumEntitiesPerChunk; }
	SIZE_T GetBytesPerEntity() const { return TotalBytesPerEntity; }

	int32 GetNumEntities() const { return EntityMap.Num(); }

	SIZE_T GetChunkAllocSize() const { return ChunkMemorySize; }

	int32 GetChunkCount() const { return Chunks.Num(); }
	int32 GetNonEmptyChunkCount() const;

	uint32 GetCreatedArchetypeDataVersion() const { return CreatedArchetypeDataVersion; }

	void ExecuteFunction(FMassExecutionContext& RunContext, const FMassExecuteFunction& Function, const FMassQueryRequirementIndicesMapping& RequirementMapping
		, FMassArchetypeEntityCollection::FConstEntityRangeArrayView EntityRangeContainer, const FMassChunkConditionFunction& ChunkCondition);
	void ExecuteFunction(FMassExecutionContext& RunContext, const FMassExecuteFunction& Function, const FMassQueryRequirementIndicesMapping& RequirementMapping
		, const FMassChunkConditionFunction& ChunkCondition);

	void ExecutionFunctionForChunk(FMassExecutionContext& RunContext, const FMassExecuteFunction& Function, const FMassQueryRequirementIndicesMapping& RequirementMapping
		, const FMassArchetypeEntityCollection::FArchetypeEntityRange& EntityRange, const FMassChunkConditionFunction& ChunkCondition = FMassChunkConditionFunction());

	/**
	 * Compacts entities to fill up chunks as much as possible
	 * @return number of entities moved around
	 */
	int32 CompactEntities(const double TimeAllowed);

	/**
	 * Moves the entity from this archetype to another, will only copy all matching fragment types
	 * @param Entity is the entity to move
	 * @param NewArchetype the archetype to move to
	 * @param SharedFragmentValuesOverride if provided will override all given Entity's shared fragment values
	 */
	void MoveEntityToAnotherArchetype(const FMassEntityHandle Entity, FMassArchetypeData& NewArchetype, const FMassArchetypeSharedFragmentValues* SharedFragmentValuesOverride = nullptr);

	/**
	 * Set all fragment sources data on specified entity, will check if there are fragment sources type that does not exist in the archetype
	 * @param Entity is the entity to set the data of all fragments
	 * @param FragmentSources are the fragments to copy the data from
	 */
	void SetFragmentsData(const FMassEntityHandle Entity, TArrayView<const FInstancedStruct> FragmentSources);

	/** For all entities indicated by EntityCollection the function sets the value of fragment of type
	 *  FragmentSource.GetScriptStruct to the value represented by FragmentSource.GetMemory */
	void SetFragmentData(FMassArchetypeEntityCollection::FConstEntityRangeArrayView EntityRangeContainer, const FInstancedStruct& FragmentSource);

	/** Returns conversion from given Requirements to archetype's fragment indices */
	void GetRequirementsFragmentMapping(TConstArrayView<FMassFragmentRequirementDescription> Requirements, FMassFragmentIndicesMapping& OutFragmentIndices) const;

	/** Returns conversion from given ChunkRequirements to archetype's chunk fragment indices */
	void GetRequirementsChunkFragmentMapping(TConstArrayView<FMassFragmentRequirementDescription> ChunkRequirements, FMassFragmentIndicesMapping& OutFragmentIndices) const;

	/** Returns conversion from given const shared requirements to archetype's const shared fragment indices */
	void GetRequirementsConstSharedFragmentMapping(TConstArrayView<FMassFragmentRequirementDescription> Requirements, FMassFragmentIndicesMapping& OutFragmentIndices) const;

	/** Returns conversion from given shared requirements to archetype's shared fragment indices */
	void GetRequirementsSharedFragmentMapping(TConstArrayView<FMassFragmentRequirementDescription> Requirements, FMassFragmentIndicesMapping& OutFragmentIndices) const;

	SIZE_T GetAllocatedSize() const;

	// Converts the list of fragments into a user-readable debug string
	FString DebugGetDescription() const;

	/** Copies debug names from another archetype data. */
	void CopyDebugNamesFrom(const FMassArchetypeData& Other)
	{ 
#if WITH_MASSENTITY_DEBUG
		DebugNames = Other.DebugNames; 
#endif // WITH_MASSENTITY_DEBUG
	}

#if WITH_MASSENTITY_DEBUG
	/** Fetches how much memory is allocated for active chunks, and how much of that memory is actually occupied */
	void DebugGetEntityMemoryNumbers(SIZE_T& OutActiveChunksMemorySize, SIZE_T& OutActiveEntitiesMemorySize) const;

	/** Adds new debug name associated with the archetype. */
	void AddUniqueDebugName(const FName& Name) { DebugNames.AddUnique(Name); }
	
	/** @return array of debug names associated with this archetype. */
	const TConstArrayView<FName> GetDebugNames() const { return DebugNames; }
	
	/** @return string of all debug names combined */
	FString GetCombinedDebugNamesAsString() const;

	/**
	 * Prints out debug information about the archetype
	 */
	void DebugPrintArchetype(FOutputDevice& Ar);

	/**
	 * Prints out fragment's values for the specified entity. 
	 * @param Entity The entity for which we want to print fragment values
	 * @param Ar The output device
	 * @param InPrefix Optional prefix to remove from fragment names
	 */
	void DebugPrintEntity(FMassEntityHandle Entity, FOutputDevice& Ar, const TCHAR* InPrefix = TEXT("")) const;
#endif // WITH_MASSENTITY_DEBUG

	void REMOVEME_GetArrayViewForFragmentInChunk(int32 ChunkIndex, const UScriptStruct* FragmentType, void*& OutChunkBase, int32& OutNumEntities);

	//////////////////////////////////////////////////////////////////////
	// low level api
	FORCEINLINE const int32* GetFragmentIndex(const UScriptStruct* FragmentType) const { return FragmentIndexMap.Find(FragmentType); }
	FORCEINLINE int32 GetFragmentIndexChecked(const UScriptStruct* FragmentType) const { return FragmentIndexMap.FindChecked(FragmentType); }

	FORCEINLINE void* GetFragmentData(const int32 FragmentIndex, const FMassRawEntityInChunkData EntityIndex) const
	{
		return FragmentConfigs[FragmentIndex].GetFragmentData(EntityIndex.ChunkRawMemory, EntityIndex.IndexWithinChunk);
	}

	FORCEINLINE FMassRawEntityInChunkData MakeEntityHandle(int32 EntityIndex) const
	{
		const int32 AbsoluteIndex = EntityMap.FindChecked(EntityIndex);
		const int32 ChunkIndex = AbsoluteIndex / NumEntitiesPerChunk;
	
		return FMassRawEntityInChunkData(Chunks[ChunkIndex].GetRawMemory(), AbsoluteIndex % NumEntitiesPerChunk); 
	}

	FORCEINLINE FMassRawEntityInChunkData MakeEntityHandle(FMassEntityHandle Entity) const
	{
		return MakeEntityHandle(Entity.Index); 
	}

	bool IsInitialized() const { return TotalBytesPerEntity > 0 && FragmentConfigs.IsEmpty() == false; }

	//////////////////////////////////////////////////////////////////////
	// batched api
	void BatchDestroyEntityChunks(FMassArchetypeEntityCollection::FConstEntityRangeArrayView EntityRangeContainer, TArray<FMassEntityHandle>& OutEntitiesRemoved);
	void BatchAddEntities(TConstArrayView<FMassEntityHandle> Entities, const FMassArchetypeSharedFragmentValues& SharedFragmentValues
		, TArray<FMassArchetypeEntityCollection::FArchetypeEntityRange>& OutNewRanges);
	/** 
	 * @param SharedFragmentValuesOverride if provided will override shared fragment values for the entities being moved
	 */
	void BatchMoveEntitiesToAnotherArchetype(const FMassArchetypeEntityCollection& EntityCollection, FMassArchetypeData& NewArchetype
		, TArray<FMassEntityHandle>& OutEntitiesBeingMoved, TArray<FMassArchetypeEntityCollection::FArchetypeEntityRange>* OutNewChunks = nullptr
		, const FMassArchetypeSharedFragmentValues* SharedFragmentValuesToAdd = nullptr
		, const FMassSharedFragmentBitSet* SharedFragmentToRemoveBitSet = nullptr
		, const FMassConstSharedFragmentBitSet* ConstSharedFragmentToRemoveBitSet = nullptr);
	void BatchSetFragmentValues(TConstArrayView<FMassArchetypeEntityCollection::FArchetypeEntityRange> EntityCollection, const FMassGenericPayloadViewSlice& Payload);

protected:
	FMassArchetypeEntityCollection::FArchetypeEntityRange PrepareNextEntitiesSpanInternal(TConstArrayView<FMassEntityHandle> Entities, const FMassArchetypeSharedFragmentValues& InSharedFragmentValues, const int32 StartingChunk = 0);
	void BatchRemoveEntitiesInternal(const int32 ChunkIndex, const int32 StartIndexWithinChunk, const int32 NumberToRemove);

	struct FTransientChunkLocation
	{
		uint8* RawChunkMemory;
		int32 IndexWithinChunk;
	};
	void MoveFragmentsToAnotherArchetypeInternal(FMassArchetypeData& TargetArchetype, FTransientChunkLocation Target, const FTransientChunkLocation Source, const int32 ElementsNum);
	void MoveFragmentsToNewLocationInternal(FTransientChunkLocation Target, const FTransientChunkLocation Source, const int32 NumberToMove);
	void ConfigureFragments();

	FORCEINLINE void* GetFragmentData(const int32 FragmentIndex, uint8* ChunkRawMemory, const int32 IndexWithinChunk) const
	{
		return FragmentConfigs[FragmentIndex].GetFragmentData(ChunkRawMemory, IndexWithinChunk);
	}

	void BindEntityRequirements(FMassExecutionContext& RunContext, const FMassFragmentIndicesMapping& EntityFragmentsMapping, FMassArchetypeChunk& Chunk, const int32 SubchunkStart, const int32 SubchunkLength);
	void BindChunkFragmentRequirements(FMassExecutionContext& RunContext, const FMassFragmentIndicesMapping& ChunkFragmentsMapping, FMassArchetypeChunk& Chunk);
	void BindConstSharedFragmentRequirements(FMassExecutionContext& RunContext, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, const FMassFragmentIndicesMapping& ChunkFragmentsMapping);
	void BindSharedFragmentRequirements(FMassExecutionContext& RunContext, FMassArchetypeSharedFragmentValues& SharedFragmentValues, const FMassFragmentIndicesMapping& ChunkFragmentsMapping);

	/**
	 * The function first creates new FMassArchetypeSharedFragmentValues instance combining existing values
	 * and the contents of SharedFragmentValueOverrides. Then that is used to find the target chunk for Entity,
	 * and if one cannot be found a new one will be created. 
	 * @param SharedFragmentValueOverrides is expected to contain only instance of types already
	 *    present in given archetypes FMassArchetypeSharedFragmentValues
	 */
	void SetSharedFragmentsData(const FMassEntityHandle Entity, TConstArrayView<FSharedStruct> SharedFragmentValueOverrides);

	FMassArchetypeChunk& GetOrAddChunk(const FMassArchetypeSharedFragmentValues& SharedFragmentValues, int32& OutAbsoluteIndex, int32& OutIndexWithinChunk);
	
private:
	int32 AddEntityInternal(FMassEntityHandle Entity, const FMassArchetypeSharedFragmentValues& InSharedFragmentValues);
	void RemoveEntityInternal(const int32 AbsoluteIndex);
};


struct FMassArchetypeHelper
{
	FORCEINLINE static FMassArchetypeData* ArchetypeDataFromHandle(const FMassArchetypeHandle& ArchetypeHandle) { return ArchetypeHandle.DataPtr.Get(); }
	FORCEINLINE static FMassArchetypeData& ArchetypeDataFromHandleChecked(const FMassArchetypeHandle& ArchetypeHandle)
	{
		check(ArchetypeHandle.IsValid());
		return *ArchetypeHandle.DataPtr.Get();
	}
	FORCEINLINE static FMassArchetypeHandle ArchetypeHandleFromData(const TSharedPtr<FMassArchetypeData>& Archetype)
	{
		return FMassArchetypeHandle(Archetype);
	}

	/**
	 * Determines whether given Archetype matches given Requirements. In case of failure to match and if WITH_MASSENTITY_DEBUG
	 * the function will also log the reasons for said failure (at VeryVerbose level).
	 * @param bBailOutOnFirstFail if true will skip the remaining tests as soon as a single mismatch is detected. This option
	 *	is used when looking for matching archetypes. For debugging purposes use `false` to list all the mismatching elements.
	 */
#if WITH_MASSENTITY_DEBUG
	MASSENTITY_API static bool DoesArchetypeMatchRequirements(const FMassArchetypeData& Archetype, const FMassFragmentRequirements& Requirements
		, const bool bBailOutOnFirstFail = true, FOutputDevice* OutputDevice = nullptr);
#endif // WITH_MASSENTITY_DEBUG

	MASSENTITY_API static bool DoesArchetypeMatchRequirements(const FMassArchetypeData& Archetype, const FMassFragmentRequirements& Requirements);
	MASSENTITY_API static bool DoesArchetypeMatchRequirements(const FMassArchetypeCompositionDescriptor& ArchetypeComposition, const FMassFragmentRequirements& Requirements);
};

===============================================


=== MassEntity/Private/MassArchetypeData.cpp ===
================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassArchetypeData.h"
#include "MassEntityTypes.h"
#include "MassExecutionContext.h"
#include "MassEntitySettings.h"
#include "MassDebugger.h"
#include "Misc/StringBuilder.h"


DECLARE_CYCLE_STAT(TEXT("Mass Archetype BatchAdd"), STAT_Mass_ArchetypeBatchAdd, STATGROUP_Mass);

namespace UE::Mass
{
	namespace Private
	{
		constexpr int32 UninitializedInt32 = -1;
		constexpr int32 MinChunkMemorySize = 1024;
		constexpr int32 MaxChunkMemorySize = 512 * 1024;
	}

	int32 SanitizeChunkMemorySize(const int32 InChunkMemorySize, const bool bLogMismatch)
	{
		const int32 SanitizedSize = FMath::Clamp(InChunkMemorySize, Private::MinChunkMemorySize, Private::MaxChunkMemorySize);
		UE_CLOG(bLogMismatch && SanitizedSize != InChunkMemorySize, LogMass, Warning
			, TEXT("ChunkMemorySize sanitization resulted in changing value. Old: %d, modified: %d")
			, InChunkMemorySize, SanitizedSize);
		return SanitizedSize;
	}
}

//////////////////////////////////////////////////////////////////////
// FMassArchetypeData

FMassArchetypeData::FMassArchetypeData(const FMassArchetypeCreationParams& CreationParams)
	: NumEntitiesPerChunk(UE::Mass::Private::UninitializedInt32)
	, EntityListOffsetWithinChunk(UE::Mass::Private::UninitializedInt32)
	, ChunkMemorySize(UE::Mass::SanitizeChunkMemorySize(CreationParams.ChunkMemorySize ? CreationParams.ChunkMemorySize : GET_MASS_CONFIG_VALUE(ChunkMemorySize)))
{
#if WITH_MASSENTITY_DEBUG
	DebugNames.Add(CreationParams.DebugName);
#endif // WITH_MASSENTITY_DEBUG
}

void FMassArchetypeData::ForEachFragmentType(TFunction< void(const UScriptStruct* /*Fragment*/)> Function) const
{
	for (const FMassArchetypeFragmentConfig& FragmentData : FragmentConfigs)
	{
		Function(FragmentData.FragmentType);
	}
}

bool FMassArchetypeData::HasFragmentType(const UScriptStruct* FragmentType) const
{
	return (FragmentType && CompositionDescriptor.Fragments.Contains(*FragmentType));
}

void FMassArchetypeData::Initialize(const FMassArchetypeCompositionDescriptor& InCompositionDescriptor, const uint32 ArchetypeDataVersion)
{
	if (!ensureMsgf(Chunks.Num() == 0, TEXT("Trying to re-initialize non-empty Mass Archetype is not supported")))
	{
		return;
	}
	if (!ensureMsgf(CreatedArchetypeDataVersion == 0, TEXT("MassArchetype has already been initialized")))
	{
		return;
	}

	CreatedArchetypeDataVersion = ArchetypeDataVersion;
	CompositionDescriptor.Fragments = InCompositionDescriptor.Fragments;
	ConfigureFragments();

	// Tags
	CompositionDescriptor.Tags = InCompositionDescriptor.Tags;

	// Chunk fragments
	CompositionDescriptor.ChunkFragments = InCompositionDescriptor.ChunkFragments;
	TArray<const UScriptStruct*, TInlineAllocator<16>> ChunkFragmentList;
	CompositionDescriptor.ChunkFragments.ExportTypes(ChunkFragmentList);
	ChunkFragmentList.Sort(FScriptStructSortOperator());
	for (const UScriptStruct* ChunkFragmentType : ChunkFragmentList)
	{
		check(ChunkFragmentType);
		ChunkFragmentsTemplate.Emplace(ChunkFragmentType);
	}

	// Share fragments
	CompositionDescriptor.SharedFragments = InCompositionDescriptor.SharedFragments;
	CompositionDescriptor.ConstSharedFragments = InCompositionDescriptor.ConstSharedFragments;

	EntityListOffsetWithinChunk = 0;
}

void FMassArchetypeData::InitializeWithSimilar(const FMassArchetypeData& BaseArchetype, FMassArchetypeCompositionDescriptor&& NewComposition, const uint32 ArchetypeDataVersion)
{
	checkf(IsInitialized() == false, TEXT("Trying to InitializeWithSimilar but this archetype has already been initialized"));

	CreatedArchetypeDataVersion = ArchetypeDataVersion;

	// note that we're calling this function rarely, so we can be a little bit inefficient here.
	CompositionDescriptor = MoveTemp(NewComposition);
	if (CompositionDescriptor.Fragments != NewComposition.Fragments)
	{
		ConfigureFragments();
	}
	else
	{
		FragmentConfigs = BaseArchetype.FragmentConfigs;
		FragmentIndexMap = BaseArchetype.FragmentIndexMap;
		TotalBytesPerEntity = BaseArchetype.TotalBytesPerEntity;
		NumEntitiesPerChunk = BaseArchetype.NumEntitiesPerChunk;
	}
	ChunkFragmentsTemplate = BaseArchetype.ChunkFragmentsTemplate;

	EntityListOffsetWithinChunk = 0;
}

void FMassArchetypeData::ConfigureFragments()
{
	TArray<const UScriptStruct*, TInlineAllocator<16>> SortedFragmentList;
	CompositionDescriptor.Fragments.ExportTypes(SortedFragmentList);

	SortedFragmentList.Sort(FScriptStructSortOperator());

	// Figure out how many bytes all of the individual fragments (and metadata) will cost per entity
	SIZE_T FragmentSizeTallyBytes = 0;

	// Alignment padding computation is currently very conservative and over-estimated.
	SIZE_T AlignmentPadding = 0;
	
	// Save room for the 'metadata' (entity array)
	FragmentSizeTallyBytes += sizeof(FMassEntityHandle);

	// Tally up the fragment sizes and place them in the index map
	FragmentConfigs.AddDefaulted(SortedFragmentList.Num());
	FragmentIndexMap.Reserve(SortedFragmentList.Num());

	for (int32 FragmentIndex = 0; FragmentIndex < SortedFragmentList.Num(); ++FragmentIndex)
	{
		const UScriptStruct* FragmentType = SortedFragmentList[FragmentIndex];
		check(FragmentType);
		FragmentConfigs[FragmentIndex].FragmentType = FragmentType;

		AlignmentPadding += SIZE_T(FragmentType->GetMinAlignment());
		FragmentSizeTallyBytes += SIZE_T(FragmentType->GetStructureSize());

		FragmentIndexMap.Add(FragmentType, FragmentIndex);
	}

	TotalBytesPerEntity = FragmentSizeTallyBytes;
	const SIZE_T ChunkAvailableSize = GetChunkAllocSize() - AlignmentPadding;
	check(TotalBytesPerEntity <= ChunkAvailableSize);

	NumEntitiesPerChunk = static_cast<int32>(ChunkAvailableSize / TotalBytesPerEntity);

	// Set up the offsets for each fragment into the chunk data
	int32 CurrentOffset = NumEntitiesPerChunk * sizeof(FMassEntityHandle);
	for (FMassArchetypeFragmentConfig& FragmentData : FragmentConfigs)
	{
		CurrentOffset = Align(CurrentOffset, FragmentData.FragmentType->GetMinAlignment());
		FragmentData.ArrayOffsetWithinChunk = CurrentOffset;
		const int32 SizeOfThisFragmentArray = NumEntitiesPerChunk * FragmentData.FragmentType->GetStructureSize();
		CurrentOffset += SizeOfThisFragmentArray;
	}
}

void FMassArchetypeData::AddEntity(FMassEntityHandle Entity, const FMassArchetypeSharedFragmentValues& SharedFragmentValues)
{
	const int32 AbsoluteIndex = AddEntityInternal(Entity, SharedFragmentValues);

	// Initialize fragments
	const int32 ChunkIndex = AbsoluteIndex / NumEntitiesPerChunk;
	const int32 IndexWithinChunk = AbsoluteIndex % NumEntitiesPerChunk;
	FMassArchetypeChunk& Chunk = Chunks[ChunkIndex];
	for (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)
	{
		void* FragmentPtr = FragmentConfig.GetFragmentData(Chunk.GetRawMemory(), IndexWithinChunk);
		FragmentConfig.FragmentType->InitializeStruct(FragmentPtr);
	}
}

int32 FMassArchetypeData::AddEntityInternal(FMassEntityHandle Entity, const FMassArchetypeSharedFragmentValues& SharedFragmentValues)
{
	checkf(SharedFragmentValues.IsSorted(), TEXT("Expecting shared fragment values to be previously sorted"));
	checkf(SharedFragmentValues.HasExactFragmentTypesMatch(CompositionDescriptor.SharedFragments, CompositionDescriptor.ConstSharedFragments)
		, TEXT("Expecting values for every specified shared fragment in the archetype and only those"))

	int32 IndexWithinChunk = 0;
	int32 AbsoluteIndex = 0;

	FMassArchetypeChunk& DestinationChunk = GetOrAddChunk(SharedFragmentValues, AbsoluteIndex, IndexWithinChunk);
	DestinationChunk.AddInstance();

	// Add to the table and map
	EntityMap.Add(Entity.Index, AbsoluteIndex);
	DestinationChunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, IndexWithinChunk) = Entity;

	return AbsoluteIndex;
}

FMassArchetypeChunk& FMassArchetypeData::GetOrAddChunk(const FMassArchetypeSharedFragmentValues& SharedFragmentValues, int32& OutAbsoluteIndex, int32& OutIndexWithinChunk)
{
	OutAbsoluteIndex = 0;
	OutIndexWithinChunk = 0;

	int32 ChunkIndex = 0;
	int32 EmptyChunkIndex = INDEX_NONE;
	int32 EmptyAbsoluteIndex = INDEX_NONE;

	FMassArchetypeChunk* DestinationChunk = nullptr;
	// Check chunks for a free spot (trying to reuse the earlier ones first so later ones might get freed up) 
	//@TODO: This could be accelerated to include a cached index to the first chunk with free spots or similar
	for (FMassArchetypeChunk& Chunk : Chunks)
	{
		if (Chunk.GetNumInstances() == 0)
		{
			// Remember first empty chunk but continue looking for a chunk that has space and same group tag
			if (EmptyChunkIndex == INDEX_NONE)
			{
				EmptyChunkIndex = ChunkIndex;
				EmptyAbsoluteIndex = OutAbsoluteIndex;
			}
		}
		else if (Chunk.GetNumInstances() < NumEntitiesPerChunk && Chunk.GetSharedFragmentValues().IsEquivalent(SharedFragmentValues))
		{
			OutIndexWithinChunk = Chunk.GetNumInstances();
			OutAbsoluteIndex += OutIndexWithinChunk;

			DestinationChunk = &Chunk;
			break;
		}
		OutAbsoluteIndex += NumEntitiesPerChunk;
		++ChunkIndex;
	}

	if (DestinationChunk == nullptr)
	{
		// Check if it is a recycled chunk
		if (EmptyChunkIndex != INDEX_NONE)
		{
			DestinationChunk = &Chunks[EmptyChunkIndex];
			DestinationChunk->Recycle(ChunkFragmentsTemplate, SharedFragmentValues);
			OutAbsoluteIndex = EmptyAbsoluteIndex;
		}
		else
		{
			DestinationChunk = &Chunks.Emplace_GetRef(GetChunkAllocSize(), ChunkFragmentsTemplate, SharedFragmentValues);
		}
	}

	check(DestinationChunk);
	return *DestinationChunk;
}

void FMassArchetypeData::RemoveEntity(FMassEntityHandle Entity)
{
	const int32 AbsoluteIndex = EntityMap.FindAndRemoveChecked(Entity.Index);

	// Destroy fragments
	const int32 ChunkIndex = AbsoluteIndex / NumEntitiesPerChunk;
	const int32 IndexWithinChunk = AbsoluteIndex % NumEntitiesPerChunk;
	FMassArchetypeChunk& Chunk = Chunks[ChunkIndex];

	for (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)
	{
		// Destroy the fragment data
		void* DyingFragmentPtr = FragmentConfig.GetFragmentData(Chunk.GetRawMemory(), IndexWithinChunk);
		FragmentConfig.FragmentType->DestroyStruct(DyingFragmentPtr);
	}

	RemoveEntityInternal(AbsoluteIndex);
}

void FMassArchetypeData::RemoveEntityInternal(const int32 AbsoluteIndex)
{
	const int32 ChunkIndex = AbsoluteIndex / NumEntitiesPerChunk;
	const int32 IndexWithinChunk = AbsoluteIndex % NumEntitiesPerChunk;

	FMassArchetypeChunk& Chunk = Chunks[ChunkIndex];

	const int32 IndexToSwapFrom = Chunk.GetNumInstances() - 1;

	// Remove and swap the last entry in the chunk to the location of the removed item (if it's not the same as the dying entry)
	if (IndexToSwapFrom != IndexWithinChunk)
	{
		for (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)
		{
			void* DyingFragmentPtr = FragmentConfig.GetFragmentData(Chunk.GetRawMemory(), IndexWithinChunk);
			void* MovingFragmentPtr = FragmentConfig.GetFragmentData(Chunk.GetRawMemory(), IndexToSwapFrom);

			// Move last entry
			FMemory::Memcpy(DyingFragmentPtr, MovingFragmentPtr, FragmentConfig.FragmentType->GetStructureSize());
		}

		// Update the entity table and map
		const FMassEntityHandle EntityBeingSwapped = Chunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, IndexToSwapFrom);
		Chunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, IndexWithinChunk) = EntityBeingSwapped;
		EntityMap.FindChecked(EntityBeingSwapped.Index) = AbsoluteIndex;
	}
	
	Chunk.RemoveInstance();

	// If the chunk itself is empty now, see if we can remove it entirely
	// Note: This is only possible for trailing chunks, to avoid messing up the absolute indices in the entities map
	while ((Chunks.Num() > 0) && (Chunks.Last().GetNumInstances() == 0))
	{
		Chunks.RemoveAt(Chunks.Num() - 1, EAllowShrinking::No);
	}
}

void FMassArchetypeData::BatchDestroyEntityChunks(FMassArchetypeEntityCollection::FConstEntityRangeArrayView EntityRangeContainer, TArray<FMassEntityHandle>& OutEntitiesRemoved)
{
	const int32 InitialOutEntitiesCount = OutEntitiesRemoved.Num();

	// Sorting the subchunks info so that subchunks of a given chunk are processed "from the back". Otherwise removing 
	// a subchunk from the front of the chunk would inevitably invalidate following subchunks' information.
	FMassArchetypeEntityCollection::FEntityRangeArray SortedRangeCollection(EntityRangeContainer);
	SortedRangeCollection.Sort([](const FMassArchetypeEntityCollection::FArchetypeEntityRange& A, const FMassArchetypeEntityCollection::FArchetypeEntityRange& B) 
		{ 
			return A.ChunkIndex < B.ChunkIndex || (A.ChunkIndex == B.ChunkIndex && A.SubchunkStart > B.SubchunkStart);
		});

	for (const FMassArchetypeEntityCollection::FArchetypeEntityRange EntityRange : SortedRangeCollection)
	{ 
		FMassArchetypeChunk& Chunk = Chunks[EntityRange.ChunkIndex];

		// gather entities we're about to remove
		FMassEntityHandle* DyingEntityPtr = &Chunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, EntityRange.SubchunkStart);
		OutEntitiesRemoved.Append(DyingEntityPtr, EntityRange.Length);

		for (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)
		{
			// Destroy the fragment data
			void* DyingFragmentPtr = FragmentConfig.GetFragmentData(Chunk.GetRawMemory(), EntityRange.SubchunkStart);
			FragmentConfig.FragmentType->DestroyStruct(DyingFragmentPtr, EntityRange.Length);
		}

		BatchRemoveEntitiesInternal(EntityRange.ChunkIndex, EntityRange.SubchunkStart, EntityRange.Length);
	}

	for (int i = InitialOutEntitiesCount; i < OutEntitiesRemoved.Num(); ++i)
	{
		EntityMap.FindAndRemoveChecked(OutEntitiesRemoved[i].Index);
	}

	// If the chunk itself is empty now, see if we can remove it entirely
	// Note: This is only possible for trailing chunks, to avoid messing up the absolute indices in the entities map
	while ((Chunks.Num() > 0) && (Chunks.Last().GetNumInstances() == 0))
	{
		Chunks.RemoveAt(Chunks.Num() - 1, EAllowShrinking::No);
	}
}

bool FMassArchetypeData::HasFragmentDataForEntity(const UScriptStruct* FragmentType, int32 EntityIndex) const
{
	return (FragmentType && CompositionDescriptor.Fragments.Contains(*FragmentType));
}

void* FMassArchetypeData::GetFragmentDataForEntityChecked(const UScriptStruct* FragmentType, int32 EntityIndex) const
{
	const FMassRawEntityInChunkData InternalIndex = MakeEntityHandle(EntityIndex);
	
	// failing the below Find means given entity's archetype is missing given FragmentType
	const int32 FragmentIndex = FragmentIndexMap.FindChecked(FragmentType);
	return GetFragmentData(FragmentIndex, InternalIndex);
}

void* FMassArchetypeData::GetFragmentDataForEntity(const UScriptStruct* FragmentType, int32 EntityIndex) const
{
	if (const int32* FragmentIndex = FragmentIndexMap.Find(FragmentType))
	{
		FMassRawEntityInChunkData InternalIndex = MakeEntityHandle(EntityIndex);
		// failing the below Find means given entity's archetype is missing given FragmentType
		return GetFragmentData(*FragmentIndex, InternalIndex);
	}
	return nullptr;
}

void FMassArchetypeData::SetSharedFragmentsData(const FMassEntityHandle Entity, TConstArrayView<FSharedStruct> SharedFragmentValueOverrides)
{
	// Gets the current chunk where the entity is located
	const int32 OldAbsoluteIndex = EntityMap.FindChecked(Entity.Index);
	const int32 OldChunkIndex = OldAbsoluteIndex / NumEntitiesPerChunk;
	const int32 OldIndexWithinChunk = OldAbsoluteIndex % NumEntitiesPerChunk;
	const FMassArchetypeChunk& OldChunk = Chunks[OldChunkIndex];

	// Gets or adds a new chunk that will hold the new entity with the new shared values
	FMassArchetypeSharedFragmentValues NewSharedFragmentValues(OldChunk.GetSharedFragmentValues());
	NewSharedFragmentValues.ReplaceSharedFragments(SharedFragmentValueOverrides);
	NewSharedFragmentValues.Sort();

	int32 NewAbsoluteIndex = 0;
	int32 NewIndexWithinChunk = 0;
	FMassArchetypeChunk& NewChunk = GetOrAddChunk(NewSharedFragmentValues, NewAbsoluteIndex, NewIndexWithinChunk);

	if (ensureMsgf(&NewChunk != &OldChunk, TEXT("Found target chunk is the same as the source chunk. Probably "
		"caused by setting shared fragment values resulted in no change, meaning the target values equal the source values")))
	{
		NewChunk.AddInstance();

		// Update the new entity in the table and map
		EntityMap[Entity.Index] = NewAbsoluteIndex;
		NewChunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, NewIndexWithinChunk) = Entity;
		
		// Move the current entity fragments into the new chunk
		MoveFragmentsToNewLocationInternal({ OldChunk.GetRawMemory(), OldIndexWithinChunk }, { NewChunk.GetRawMemory(), NewIndexWithinChunk }, 1);

		// Clean up the old chunk
		RemoveEntityInternal(OldAbsoluteIndex);
	}
}

void FMassArchetypeData::SetFragmentsData(const FMassEntityHandle Entity, TArrayView<const FInstancedStruct> FragmentInstances)
{
	FMassRawEntityInChunkData InternalIndex = MakeEntityHandle(Entity);

	for (const FInstancedStruct& Instance : FragmentInstances)
	{
		const UScriptStruct* FragmentType = Instance.GetScriptStruct();
		check(FragmentType);
		const int32 FragmentIndex = FragmentIndexMap.FindChecked(FragmentType);
		void* FragmentMemory = GetFragmentData(FragmentIndex, InternalIndex);
		FragmentType->CopyScriptStruct(FragmentMemory, Instance.GetMemory());
	}
}

void FMassArchetypeData::SetFragmentData(FMassArchetypeEntityCollection::FConstEntityRangeArrayView EntityRangeContainer, const FInstancedStruct& FragmentSource)
{
	check(FragmentSource.IsValid());
	const UScriptStruct* FragmentType = FragmentSource.GetScriptStruct();
	check(FragmentType);
	const int32 FragmentIndex = FragmentIndexMap.FindChecked(FragmentType);
	const int32 FragmentTypeSize = FragmentType->GetStructureSize();
	const uint8* FragmentSourceMemory = FragmentSource.GetMemory();
	check(FragmentSourceMemory);
	
	for (FMassArchetypeChunkIterator ChunkIterator(EntityRangeContainer); ChunkIterator; ++ChunkIterator)
	{
		uint8* FragmentMemory = (uint8*)FragmentConfigs[FragmentIndex].GetFragmentData(Chunks[ChunkIterator->ChunkIndex].GetRawMemory(), ChunkIterator->SubchunkStart);
		for (int i = ChunkIterator->Length; i; --i, FragmentMemory += FragmentTypeSize)
		{
			FragmentType->CopyScriptStruct(FragmentMemory, FragmentSourceMemory);
		}
	}
}

void FMassArchetypeData::MoveEntityToAnotherArchetype(const FMassEntityHandle Entity, FMassArchetypeData& NewArchetype, const FMassArchetypeSharedFragmentValues* SharedFragmentValuesOverride)
{
	check(&NewArchetype != this);

	const int32 AbsoluteIndex = EntityMap.FindAndRemoveChecked(Entity.Index);
	const int32 ChunkIndex = AbsoluteIndex / NumEntitiesPerChunk;
	const int32 IndexWithinChunk = AbsoluteIndex % NumEntitiesPerChunk;
	FMassArchetypeChunk& Chunk = Chunks[ChunkIndex];

	const int32 NewAbsoluteIndex = NewArchetype.AddEntityInternal(Entity, SharedFragmentValuesOverride ? *SharedFragmentValuesOverride : Chunk.GetSharedFragmentValues());
	const int32 NewChunkIndex = NewAbsoluteIndex / NewArchetype.NumEntitiesPerChunk;
	const int32 NewIndexWithinChunk = NewAbsoluteIndex % NewArchetype.NumEntitiesPerChunk;
	FMassArchetypeChunk& NewChunk = NewArchetype.Chunks[NewChunkIndex];

	MoveFragmentsToAnotherArchetypeInternal(NewArchetype, { NewChunk.GetRawMemory(), NewIndexWithinChunk }, { Chunk.GetRawMemory(), IndexWithinChunk }, /*Count=*/1);

	RemoveEntityInternal(AbsoluteIndex);
}

void FMassArchetypeData::ExecuteFunction(FMassExecutionContext& RunContext, const FMassExecuteFunction& Function, const FMassQueryRequirementIndicesMapping& RequirementMapping, FMassArchetypeEntityCollection::FConstEntityRangeArrayView EntityRangeContainer, const FMassChunkConditionFunction& ChunkCondition)
{
	if (GetNumEntities() == 0)
	{
		return;
	}

	// @todo do we really want users to check composition of the archetype being processed at the moment?
	RunContext.SetCurrentArchetypeCompositionDescriptor(GetCompositionDescriptor());

	uint32 PrevSharedFragmentValuesHash = UINT32_MAX;
	for (FMassArchetypeChunkIterator ChunkIterator(EntityRangeContainer); ChunkIterator; ++ChunkIterator)
	{
		FMassArchetypeChunk& Chunk = Chunks[ChunkIterator->ChunkIndex];

		const int32 ChunkLength = ChunkIterator->Length > 0 ? ChunkIterator->Length : (Chunk.GetNumInstances() - ChunkIterator->SubchunkStart);
		if (ChunkLength)
		{
			const uint32 SharedFragmentValuesHash = GetTypeHash(Chunk.GetSharedFragmentValues());
			if (PrevSharedFragmentValuesHash != SharedFragmentValuesHash)
			{
				PrevSharedFragmentValuesHash = SharedFragmentValuesHash;
				BindConstSharedFragmentRequirements(RunContext, Chunk.GetSharedFragmentValues(), RequirementMapping.ConstSharedFragments);
				BindSharedFragmentRequirements(RunContext, Chunk.GetMutableSharedFragmentValues(), RequirementMapping.SharedFragments);
			}

			checkf((ChunkIterator->SubchunkStart + ChunkLength) <= Chunk.GetNumInstances() && ChunkLength > 0, TEXT("Invalid subchunk, it is going over the number of instances in the chunk or it is empty."));

			RunContext.SetCurrentChunkSerialModificationNumber(Chunk.GetSerialModificationNumber());
			BindChunkFragmentRequirements(RunContext, RequirementMapping.ChunkFragments, Chunk);

			if (!ChunkCondition || ChunkCondition(RunContext))
			{
				BindEntityRequirements(RunContext, RequirementMapping.EntityFragments, Chunk, ChunkIterator->SubchunkStart, ChunkLength);
				Function(RunContext);
			}
		}
	}
}

void FMassArchetypeData::ExecuteFunction(FMassExecutionContext& RunContext, const FMassExecuteFunction& Function, const FMassQueryRequirementIndicesMapping& RequirementMapping, const FMassChunkConditionFunction& ChunkCondition)
{
	if (GetNumEntities() == 0)
	{
		return;
	}

	RunContext.SetCurrentArchetypeCompositionDescriptor(GetCompositionDescriptor());

	uint32 PrevSharedFragmentValuesHash = UINT32_MAX;
	for (FMassArchetypeChunk& Chunk : Chunks)
	{
		if (Chunk.GetNumInstances())
		{
			const uint32 SharedFragmentValuesHash = GetTypeHash(Chunk.GetSharedFragmentValues());
			if (PrevSharedFragmentValuesHash != SharedFragmentValuesHash)
			{
				PrevSharedFragmentValuesHash = SharedFragmentValuesHash;
				BindConstSharedFragmentRequirements(RunContext, Chunk.GetSharedFragmentValues(), RequirementMapping.ConstSharedFragments);
				BindSharedFragmentRequirements(RunContext, Chunk.GetMutableSharedFragmentValues(), RequirementMapping.SharedFragments);
			}

			RunContext.SetCurrentChunkSerialModificationNumber(Chunk.GetSerialModificationNumber());
			BindChunkFragmentRequirements(RunContext, RequirementMapping.ChunkFragments, Chunk);

			if (!ChunkCondition || ChunkCondition(RunContext))
			{
				BindEntityRequirements(RunContext, RequirementMapping.EntityFragments, Chunk, 0, Chunk.GetNumInstances());
				Function(RunContext);
			}
		}
	}
}

void FMassArchetypeData::ExecutionFunctionForChunk(FMassExecutionContext& RunContext, const FMassExecuteFunction& Function, const FMassQueryRequirementIndicesMapping& RequirementMapping, const FMassArchetypeEntityCollection::FArchetypeEntityRange& EntityRange, const FMassChunkConditionFunction& ChunkCondition)
{
	FMassArchetypeChunk& Chunk = Chunks[EntityRange.ChunkIndex];
	const int32 ChunkLength = EntityRange.Length > 0 ? EntityRange.Length : (Chunk.GetNumInstances() - EntityRange.SubchunkStart);

	if (ChunkLength)
	{
		BindConstSharedFragmentRequirements(RunContext, Chunk.GetSharedFragmentValues(), RequirementMapping.ConstSharedFragments);
		BindSharedFragmentRequirements(RunContext, Chunk.GetMutableSharedFragmentValues(), RequirementMapping.SharedFragments);

		RunContext.SetCurrentArchetypeCompositionDescriptor(GetCompositionDescriptor());
		RunContext.SetCurrentChunkSerialModificationNumber(Chunk.GetSerialModificationNumber());
		BindChunkFragmentRequirements(RunContext, RequirementMapping.ChunkFragments, Chunk);

		if (!ChunkCondition || ChunkCondition(RunContext))
		{
			BindEntityRequirements(RunContext, RequirementMapping.EntityFragments, Chunk, EntityRange.SubchunkStart, ChunkLength);
			Function(RunContext);
		}
	}
}

int32 FMassArchetypeData::CompactEntities(const double TimeAllowed)
{
	int32 TotalEntitiesMoved = 0;
	const double TimeAllowedEnd = FPlatformTime::Seconds() + TimeAllowed;

	TMap<uint32, TArray<FMassArchetypeChunk*>> SortedChunksBySharedValues;
	for (FMassArchetypeChunk& Chunk : Chunks)
	{
		// Skip already full chunks
		const int32 NumInstances = Chunk.GetNumInstances();
		if (NumInstances > 0 && NumInstances < NumEntitiesPerChunk)
		{
			const uint32 SharedFragmentHash = GetTypeHash(Chunk.GetSharedFragmentValues());
			TArray<FMassArchetypeChunk*>& SortedChunks = SortedChunksBySharedValues.FindOrAddByHash(SharedFragmentHash, SharedFragmentHash, TArray<FMassArchetypeChunk*>());
			SortedChunks.Add(&Chunk);
		}
	}

	for (TPair<uint32, TArray<FMassArchetypeChunk*>>& Pair : SortedChunksBySharedValues)
	{
		TArray<FMassArchetypeChunk*>& SortedChunks = Pair.Value;

		// Check if there is anything to compact at all
		if (SortedChunks.Num() <= 1)
		{
			continue;
		}

		SortedChunks.Sort([](const FMassArchetypeChunk& LHS, const FMassArchetypeChunk& RHS)
		{
			return LHS.GetNumInstances() < RHS.GetNumInstances();
		});

		int32 ChunkToFillSortedIdx = 0;
		int32 ChunkToEmptySortedIdx = SortedChunks.Num() - 1;
		while (ChunkToFillSortedIdx < ChunkToEmptySortedIdx && FPlatformTime::Seconds() < TimeAllowedEnd)
		{
			while (ChunkToFillSortedIdx < SortedChunks.Num() && SortedChunks[ChunkToFillSortedIdx]->GetNumInstances() == NumEntitiesPerChunk)
			{
				ChunkToFillSortedIdx++;
			}
			while (ChunkToEmptySortedIdx >= 0 && SortedChunks[ChunkToEmptySortedIdx]->GetNumInstances() == 0)
			{
				ChunkToEmptySortedIdx--;
			}
			if (ChunkToFillSortedIdx >= ChunkToEmptySortedIdx)
			{
				break;
			}

			FMassArchetypeChunk* ChunkToFill = SortedChunks[ChunkToFillSortedIdx];
			FMassArchetypeChunk* ChunkToEmpty = SortedChunks[ChunkToEmptySortedIdx];
			const int32 NumberOfEntitiesToMove = FMath::Min(NumEntitiesPerChunk - ChunkToFill->GetNumInstances(), ChunkToEmpty->GetNumInstances());
			const int32 FromIndex = ChunkToEmpty->GetNumInstances() - NumberOfEntitiesToMove;
			const int32 ToIndex = ChunkToFill->GetNumInstances();
			check(NumberOfEntitiesToMove > 0);

			MoveFragmentsToNewLocationInternal({ChunkToFill->GetRawMemory(), ToIndex}, {ChunkToEmpty->GetRawMemory(), FromIndex}
				, NumberOfEntitiesToMove);

			FMassEntityHandle* FromEntity = &ChunkToEmpty->GetEntityArrayElementRef(EntityListOffsetWithinChunk, FromIndex);
			FMassEntityHandle* ToEntity = &ChunkToFill->GetEntityArrayElementRef(EntityListOffsetWithinChunk, ToIndex);
			FMemory::Memcpy(ToEntity, FromEntity, NumberOfEntitiesToMove * sizeof(FMassEntityHandle));
			ChunkToFill->AddMultipleInstances(NumberOfEntitiesToMove);
			ChunkToEmpty->RemoveMultipleInstances(NumberOfEntitiesToMove);

			const int32 ChunkToFillIdx = UE_PTRDIFF_TO_INT32(ChunkToFill - &Chunks[0]);
			check(ChunkToFillIdx >= 0 && ChunkToFillIdx < Chunks.Num());
			const int32 AbsoluteIndex = ChunkToFillIdx * NumEntitiesPerChunk + ToIndex;

			for (int32 i = 0; i < NumberOfEntitiesToMove; i++, ++ToEntity)
			{
				EntityMap.FindChecked(ToEntity->Index) = AbsoluteIndex + i;
			}

			TotalEntitiesMoved += NumberOfEntitiesToMove;
		}
	}

	return TotalEntitiesMoved;
}

void FMassArchetypeData::GetRequirementsFragmentMapping(TConstArrayView<FMassFragmentRequirementDescription> Requirements, FMassFragmentIndicesMapping& OutFragmentIndices) const
{
	OutFragmentIndices.Reset(Requirements.Num());
	for (const FMassFragmentRequirementDescription& Requirement : Requirements)
	{
		if (Requirement.RequiresBinding())
		{
			const int32* FragmentIndex = FragmentIndexMap.Find(Requirement.StructType);
			check(FragmentIndex != nullptr || Requirement.IsOptional());
			OutFragmentIndices.Add(FragmentIndex ? *FragmentIndex : INDEX_NONE);
		}
	}
}

// @todo make ChunkRequirements a dedicated type, so that we can ensure that the contents are sorted as expected by the for loop below
void FMassArchetypeData::GetRequirementsChunkFragmentMapping(TConstArrayView<FMassFragmentRequirementDescription> ChunkRequirements, FMassFragmentIndicesMapping& OutFragmentIndices) const
{
	int32 LastFoundFragmentIndex = -1;
	OutFragmentIndices.Reset(ChunkRequirements.Num());
	for (const FMassFragmentRequirementDescription& Requirement : ChunkRequirements)
	{
		if (Requirement.RequiresBinding())
		{
			int32 FragmentIndex = INDEX_NONE;
			for (int32 i = LastFoundFragmentIndex + 1; i < ChunkFragmentsTemplate.Num(); ++i)
			{
				if (ChunkFragmentsTemplate[i].GetScriptStruct()->IsChildOf(Requirement.StructType))
				{
					FragmentIndex = i;
					break;
				}
			}

			check(FragmentIndex != INDEX_NONE || Requirement.IsOptional());
			OutFragmentIndices.Add(FragmentIndex);
			LastFoundFragmentIndex = FragmentIndex;
		}
	}
}

void FMassArchetypeData::GetRequirementsConstSharedFragmentMapping(TConstArrayView<FMassFragmentRequirementDescription> Requirements, FMassFragmentIndicesMapping& OutFragmentIndices) const
{
	if (Chunks.Num() == 0)
	{
		return;
	}
	// All shared fragment values for this archetype should have deterministic indices, so anyone will work to calculate them
	const FMassArchetypeSharedFragmentValues& SharedFragmentValues = Chunks[0].GetSharedFragmentValues();

	OutFragmentIndices.Reset(Requirements.Num());
	for (const FMassFragmentRequirementDescription& Requirement : Requirements)
	{
		if (Requirement.RequiresBinding())
		{
			const int32 FragmentIndex = SharedFragmentValues.GetConstSharedFragments().IndexOfByPredicate(FStructTypeEqualOperator(Requirement.StructType));
			check(FragmentIndex != INDEX_NONE || Requirement.IsOptional());
			OutFragmentIndices.Add(FragmentIndex);
		}
	}
}

void FMassArchetypeData::GetRequirementsSharedFragmentMapping(TConstArrayView<FMassFragmentRequirementDescription> Requirements, FMassFragmentIndicesMapping& OutFragmentIndices) const
{
	if (Chunks.Num() == 0)
	{
		return;
	}

	// All shared fragment values for this archetype should have deterministic indices, so anyone will work to calculate them
	const FMassArchetypeSharedFragmentValues& SharedFragmentValues = Chunks[0].GetSharedFragmentValues();

	OutFragmentIndices.Reset(Requirements.Num());
	for (const FMassFragmentRequirementDescription& Requirement : Requirements)
	{
		if (Requirement.RequiresBinding())
		{
			const int32 FragmentIndex = SharedFragmentValues.GetSharedFragments().IndexOfByPredicate(FStructTypeEqualOperator(Requirement.StructType));
			check(FragmentIndex != INDEX_NONE || Requirement.IsOptional());
			OutFragmentIndices.Add(FragmentIndex);
		}
	}
}

void FMassArchetypeData::BindEntityRequirements(FMassExecutionContext& RunContext, const FMassFragmentIndicesMapping& EntityFragmentsMapping, FMassArchetypeChunk& Chunk, const int32 SubchunkStart, const int32 SubchunkLength)
{
	// auto-correcting number of entities to process in case SubchunkStart +  SubchunkLength > Chunk.GetNumInstances()
	const int32 NumEntities = SubchunkLength >= 0 ? FMath::Min(SubchunkLength, Chunk.GetNumInstances() - SubchunkStart) : Chunk.GetNumInstances();
	check(SubchunkStart >= 0 && SubchunkStart < Chunk.GetNumInstances());

	if (EntityFragmentsMapping.Num() > 0)
	{
		check(RunContext.GetMutableRequirements().Num() == EntityFragmentsMapping.Num());

		for (int i = 0; i < EntityFragmentsMapping.Num(); ++i)
		{
			FMassExecutionContext::FFragmentView& Requirement = RunContext.FragmentViews[i];
			const int32 FragmentIndex = EntityFragmentsMapping[i];

			check(FragmentIndex != INDEX_NONE || Requirement.Requirement.IsOptional());
			if (FragmentIndex != INDEX_NONE)
			{
				Requirement.FragmentView = TArrayView<FMassFragment>((FMassFragment*)GetFragmentData(FragmentIndex, Chunk.GetRawMemory(), SubchunkStart), NumEntities);
			}
			else
			{
				// @todo this might not be needed
				Requirement.FragmentView = TArrayView<FMassFragment>();
			}
		}
	}
	else
	{
		// Map in the required data arrays from the current chunk to the array views
		for (FMassExecutionContext::FFragmentView& Requirement : RunContext.GetMutableRequirements())
		{
			const int32* FragmentIndex = FragmentIndexMap.Find(Requirement.Requirement.StructType);
			check(FragmentIndex != nullptr || Requirement.Requirement.IsOptional());
			if (FragmentIndex)
			{
				Requirement.FragmentView = TArrayView<FMassFragment>((FMassFragment*)GetFragmentData(*FragmentIndex, Chunk.GetRawMemory(), SubchunkStart), NumEntities);
			}
			else
			{
				Requirement.FragmentView = TArrayView<FMassFragment>();
			}
		}
	}

	RunContext.EntityListView = TArrayView<FMassEntityHandle>(&Chunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, SubchunkStart), NumEntities);
}

void FMassArchetypeData::BindChunkFragmentRequirements(FMassExecutionContext& RunContext, const FMassFragmentIndicesMapping& ChunkFragmentsMapping, FMassArchetypeChunk& Chunk)
{
	if (ChunkFragmentsMapping.Num() > 0)
	{
		check(RunContext.GetMutableChunkRequirements().Num() == ChunkFragmentsMapping.Num());

		for (int i = 0; i < ChunkFragmentsMapping.Num(); ++i)
		{
			FMassExecutionContext::FChunkFragmentView& ChunkRequirement = RunContext.ChunkFragmentViews[i];
			const int32 ChunkFragmentIndex = ChunkFragmentsMapping[i];

			check(ChunkFragmentIndex != INDEX_NONE || ChunkRequirement.Requirement.IsOptional());
			ChunkRequirement.FragmentView = ChunkFragmentIndex != INDEX_NONE ? Chunk.GetMutableChunkFragmentViewChecked(ChunkFragmentIndex) : FStructView();
		}
	}
	else
	{
		for (FMassExecutionContext::FChunkFragmentView& ChunkRequirement : RunContext.GetMutableChunkRequirements())
		{
			FInstancedStruct* ChunkFragmentInstance = Chunk.FindMutableChunkFragment(ChunkRequirement.Requirement.StructType);
			check(ChunkFragmentInstance != nullptr || ChunkRequirement.Requirement.IsOptional());
			ChunkRequirement.FragmentView = ChunkFragmentInstance ? FStructView(*ChunkFragmentInstance) : FStructView();
		}
	}
}

void FMassArchetypeData::BindConstSharedFragmentRequirements(FMassExecutionContext& RunContext, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, const FMassFragmentIndicesMapping& FragmentsMapping)
{
	if (FragmentsMapping.Num() > 0)
	{
		check(RunContext.GetMutableConstSharedRequirements().Num() == FragmentsMapping.Num());

		for (int i = 0; i < FragmentsMapping.Num(); ++i)
		{
			FMassExecutionContext::FConstSharedFragmentView& Requirement = RunContext.ConstSharedFragmentViews[i];
			const int32 FragmentIndex = FragmentsMapping[i];

			check(FragmentIndex != INDEX_NONE || Requirement.Requirement.IsOptional());
			Requirement.FragmentView = FragmentIndex != INDEX_NONE ? FConstStructView(SharedFragmentValues.GetConstSharedFragments()[FragmentIndex]) : FConstStructView();
		}
	}
	else
	{
		for (FMassExecutionContext::FConstSharedFragmentView& Requirement : RunContext.GetMutableConstSharedRequirements())
		{
			const FConstSharedStruct* SharedFragment = SharedFragmentValues.GetConstSharedFragments().FindByPredicate(FStructTypeEqualOperator(Requirement.Requirement.StructType) );
			check(SharedFragment != nullptr || Requirement.Requirement.IsOptional());
			Requirement.FragmentView = SharedFragment ? FConstStructView(*SharedFragment) : FConstStructView();
		}
	}
}

void FMassArchetypeData::BindSharedFragmentRequirements(FMassExecutionContext& RunContext, FMassArchetypeSharedFragmentValues& SharedFragmentValues, const FMassFragmentIndicesMapping& FragmentsMapping)
{
	if (FragmentsMapping.Num() > 0)
	{
		check(RunContext.GetMutableSharedRequirements().Num() == FragmentsMapping.Num());

		for (int i = 0; i < FragmentsMapping.Num(); ++i)
		{
			FMassExecutionContext::FSharedFragmentView& Requirement = RunContext.SharedFragmentViews[i];
			const int32 FragmentIndex = FragmentsMapping[i];

			check(FragmentIndex != INDEX_NONE || Requirement.Requirement.IsOptional());
			Requirement.FragmentView = FragmentIndex != INDEX_NONE ? FStructView(SharedFragmentValues.GetMutableSharedFragments()[FragmentIndex]) : FStructView();
		}
	}
	else
	{
		for (FMassExecutionContext::FSharedFragmentView& Requirement : RunContext.GetMutableSharedRequirements())
		{
			FSharedStruct* SharedFragment = SharedFragmentValues.GetMutableSharedFragments().FindByPredicate(FStructTypeEqualOperator(Requirement.Requirement.StructType));
			check(SharedFragment != nullptr || Requirement.Requirement.IsOptional());
			Requirement.FragmentView = SharedFragment ? FStructView(*SharedFragment) : FStructView();
		}
	}
}

int32 FMassArchetypeData::GetNonEmptyChunkCount() const
{
	int32 NumAllocatedChunks = 0;
	for (const FMassArchetypeChunk& Chunk : Chunks)
	{
		if (Chunk.GetRawMemory() != nullptr)
		{
			++NumAllocatedChunks;
		}
	}
	return NumAllocatedChunks;
}

SIZE_T FMassArchetypeData::GetAllocatedSize() const
{
	const int32 NumAllocatedChunkBuffers = GetNonEmptyChunkCount();

	return sizeof(FMassArchetypeData) +
		ChunkFragmentsTemplate.GetAllocatedSize() +
		FragmentConfigs.GetAllocatedSize() +
		Chunks.GetAllocatedSize() +
		(NumAllocatedChunkBuffers * GetChunkAllocSize()) +
		EntityMap.GetAllocatedSize() +
		FragmentIndexMap.GetAllocatedSize();
}

FString FMassArchetypeData::DebugGetDescription() const
{
#if WITH_MASSENTITY_DEBUG
	FStringOutputDevice OutDescription;

	if (!DebugNames.IsEmpty())
	{
		OutDescription += TEXT("Name: ");
		OutDescription += GetCombinedDebugNamesAsString();
		OutDescription += TEXT("\n");
	}
	OutDescription += TEXT("Chunk fragments: ");
	CompositionDescriptor.ChunkFragments.DebugGetStringDesc(OutDescription);
	OutDescription += TEXT("\nTags: ");
	CompositionDescriptor.Tags.DebugGetStringDesc(OutDescription);
	OutDescription += TEXT("\nFragments: ");
	CompositionDescriptor.Fragments.DebugGetStringDesc(OutDescription);
	
	return static_cast<FString>(OutDescription);
#else
	return {};
#endif
}

#if WITH_MASSENTITY_DEBUG
void FMassArchetypeData::DebugGetEntityMemoryNumbers(SIZE_T& OutActiveChunksMemorySize, SIZE_T& OutActiveEntitiesMemorySize) const
{
	OutActiveChunksMemorySize = GetChunkAllocSize() * GetNonEmptyChunkCount();
	OutActiveEntitiesMemorySize = TotalBytesPerEntity * EntityMap.Num();
}

FString FMassArchetypeData::GetCombinedDebugNamesAsString() const
{
	TStringBuilder<256> StringBuilder;
	for (int i = 0; i < DebugNames.Num(); i++)
	{
		if (i > 0)
		{
			StringBuilder.Append(TEXT(", "));;
		}
		StringBuilder.Append(DebugNames[i].ToString());
	}
	return StringBuilder.ToString();
}

void FMassArchetypeData::DebugPrintArchetype(FOutputDevice& Ar)
{
	Ar.Logf(ELogVerbosity::Log, TEXT("Name: %s"), *GetCombinedDebugNamesAsString());

	FStringOutputDevice TagsDecription;
	CompositionDescriptor.Tags.DebugGetStringDesc(TagsDecription);
	Ar.Logf(ELogVerbosity::Log, TEXT("Tags: %s"), *TagsDecription);
	Ar.Logf(ELogVerbosity::Log, TEXT("Fragments: %s"), *DebugGetDescription());
	Ar.Logf(ELogVerbosity::Log, TEXT("\tChunks: %d x %d KB = %d KB total"), Chunks.Num(), GetChunkAllocSize() / 1024, (GetChunkAllocSize()*Chunks.Num()) / 1024);
	
	int ChunkWithFragmentsCount = 0;
	for (FMassArchetypeChunk& Chunk : Chunks)
	{
		ChunkWithFragmentsCount += Chunk.DebugGetChunkFragmentCount() > 0 ? 1 : 0;
	}
	if (ChunkWithFragmentsCount)
	{
		Ar.Logf(ELogVerbosity::Log, TEXT("\tChunks with fragments: %d"), ChunkWithFragmentsCount);
	}

	const int32 CurrentEntityCapacity = Chunks.Num() * NumEntitiesPerChunk;
	Ar.Logf(ELogVerbosity::Log, TEXT("\tEntity Count    : %d"), EntityMap.Num());
	Ar.Logf(ELogVerbosity::Log, TEXT("\tEntity Capacity : %d"), CurrentEntityCapacity);
	if (Chunks.Num() > 1)
	{
		const float Scaler = 100.0f / static_cast<float>(CurrentEntityCapacity);
		// count non-last chunks to see how occupied they are
		int EntitiesPerChunkMin = CurrentEntityCapacity;
		int EntitiesPerChunkMax = 0;
		for (int ChunkIndex = 0; ChunkIndex < Chunks.Num() - 1; ++ChunkIndex)
		{
			const int Population = Chunks[ChunkIndex].GetNumInstances();
			EntitiesPerChunkMin = FMath::Min(Population, EntitiesPerChunkMin);
			EntitiesPerChunkMax = FMath::Max(Population, EntitiesPerChunkMax);
		}
		Ar.Logf(ELogVerbosity::Log, TEXT("\tEntity Occupancy: %.1f%% (min: %.1f%%, max: %.1f%%)"),
			Scaler * static_cast<float>(EntityMap.Num()),
			Scaler * static_cast<float>(EntitiesPerChunkMin),
			Scaler * static_cast<float>(EntitiesPerChunkMax));
	}
	else 
	{
		Ar.Logf(ELogVerbosity::Log, TEXT("\tEntity Occupancy: %.1f%%"),
			CurrentEntityCapacity > 0 ? ((static_cast<float>(EntityMap.Num()) * 100.0f) / static_cast<float>(CurrentEntityCapacity)) : 0.f);
	}
	Ar.Logf(ELogVerbosity::Log, TEXT("\tBytes / Entity  : %zu"), TotalBytesPerEntity);
	Ar.Logf(ELogVerbosity::Log, TEXT("\tEntities / Chunk: %d"), NumEntitiesPerChunk);

	Ar.Logf(ELogVerbosity::Log, TEXT("\tOffset 0x%04X: Entity[] (%llu bytes each)"), EntityListOffsetWithinChunk, sizeof(FMassEntityHandle));
	int32 TotalBytesOfValidData = sizeof(FMassEntityHandle) * NumEntitiesPerChunk;
	for (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)
	{
		TotalBytesOfValidData += FragmentConfig.FragmentType->GetStructureSize() * NumEntitiesPerChunk;
		Ar.Logf(ELogVerbosity::Log, TEXT("\tOffset 0x%04X: %s[] (%d bytes each)"), FragmentConfig.ArrayOffsetWithinChunk, *FragmentConfig.FragmentType->GetName(), FragmentConfig.FragmentType->GetStructureSize());
	}

	//@TODO: Print out padding in between things?

	const SIZE_T UnusuablePaddingOffset = TotalBytesPerEntity * NumEntitiesPerChunk;
	const SIZE_T UnusuablePaddingAmount = GetChunkAllocSize() - UnusuablePaddingOffset;
	if (UnusuablePaddingAmount > 0)
	{
		Ar.Logf(ELogVerbosity::Log, TEXT("\tOffset 0x%04X: WastePadding[] (%d bytes total)"), UnusuablePaddingOffset, UnusuablePaddingAmount);
	}

	if (GetChunkAllocSize() != TotalBytesOfValidData + UnusuablePaddingAmount)
	{
		Ar.Logf(ELogVerbosity::Log, TEXT("\t@TODO: EXTRA PADDING HERE:  TotalBytesOfValidData: %d (%d missing)"), TotalBytesOfValidData, GetChunkAllocSize() - TotalBytesOfValidData);
	}
}

void FMassArchetypeData::DebugPrintEntity(FMassEntityHandle Entity, FOutputDevice& Ar, const TCHAR* InPrefix) const
{
	for (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)
	{
		void* Data = GetFragmentDataForEntityChecked(FragmentConfig.FragmentType, Entity.Index);
		
		FString FragmentName = FragmentConfig.FragmentType->GetName();
		FragmentName.RemoveFromStart(InPrefix);

		FString ValueStr;
		FragmentConfig.FragmentType->ExportText(ValueStr, Data, /*Default*/nullptr, /*OwnerObject*/nullptr, EPropertyPortFlags::PPF_IncludeTransient, /*ExportRootScope*/nullptr);

		Ar.Logf(TEXT("%s: %s"), *FragmentName, *ValueStr);
	}
}

#endif // WITH_MASSENTITY_DEBUG

void FMassArchetypeData::REMOVEME_GetArrayViewForFragmentInChunk(int32 ChunkIndex, const UScriptStruct* FragmentType, void*& OutChunkBase, int32& OutNumEntities)
{
	const FMassArchetypeChunk& Chunk = Chunks[ChunkIndex];
	const int32 FragmentIndex = FragmentIndexMap.FindChecked(FragmentType);

	OutChunkBase = FragmentConfigs[FragmentIndex].GetFragmentData(Chunk.GetRawMemory(), 0);
	OutNumEntities = Chunk.GetNumInstances();
}

//////////////////////////////////////////////////////////////////////
// FMassArchetypeData batched api

void FMassArchetypeData::BatchAddEntities(TConstArrayView<FMassEntityHandle> Entities, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, TArray<FMassArchetypeEntityCollection::FArchetypeEntityRange>& OutNewRanges)
{
	SCOPE_CYCLE_COUNTER(STAT_Mass_ArchetypeBatchAdd);

	testableCheckfReturn(SharedFragmentValues.HasExactSharedFragmentTypesMatch(GetCompositionDescriptor().SharedFragments), return, TEXT("%hs parameter SharedFragmentValues doesn't match archetype's composition"), __FUNCTION__);
	testableCheckfReturn(SharedFragmentValues.HasExactConstSharedFragmentTypesMatch(GetCompositionDescriptor().ConstSharedFragments), return, TEXT("%hs parameter ConstSharedFragmentValues doesn't match archetype's composition"), __FUNCTION__);

	FMassArchetypeEntityCollection::FArchetypeEntityRange ResultSubchunk;
	ResultSubchunk.ChunkIndex = 0;
	int32 NumberMoved = 0;
	do 
	{
		ResultSubchunk = PrepareNextEntitiesSpanInternal(MakeArrayView(Entities.GetData() + NumberMoved, Entities.Num() - NumberMoved), SharedFragmentValues, ResultSubchunk.ChunkIndex);
		check(Chunks.IsValidIndex(ResultSubchunk.ChunkIndex) && Chunks[ResultSubchunk.ChunkIndex].IsValidSubChunk(ResultSubchunk.SubchunkStart, ResultSubchunk.Length));
		
		for (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)
		{
			void* FragmentPtr = FragmentConfig.GetFragmentData(Chunks[ResultSubchunk.ChunkIndex].GetRawMemory(), ResultSubchunk.SubchunkStart);
			FragmentConfig.FragmentType->InitializeStruct(FragmentPtr, ResultSubchunk.Length);
		}

		NumberMoved += ResultSubchunk.Length;

		OutNewRanges.Add(ResultSubchunk);

	} while (NumberMoved < Entities.Num());
}

void FMassArchetypeData::BatchMoveEntitiesToAnotherArchetype(const FMassArchetypeEntityCollection& EntityCollection
	, FMassArchetypeData& NewArchetype, TArray<FMassEntityHandle>& OutEntitiesBeingMoved
	, TArray<FMassArchetypeEntityCollection::FArchetypeEntityRange>* OutNewRanges, const FMassArchetypeSharedFragmentValues* SharedFragmentValuesToAdd
	, const FMassSharedFragmentBitSet* SharedFragmentToRemoveBitSet, const FMassConstSharedFragmentBitSet* ConstSharedFragmentToRemoveBitSet)
{
	check(&NewArchetype != this);

	// verify the new archetype's shared fragment composition matches current archetype's composition modified as requested
	if (SharedFragmentValuesToAdd)
	{
		bool bIsValidArchetype = true;
		if (SharedFragmentToRemoveBitSet)
		{
			FMassSharedFragmentBitSet NewSharedFragmentsBitset = GetSharedFragmentBitSet();
			NewSharedFragmentsBitset -= *SharedFragmentToRemoveBitSet;
			NewSharedFragmentsBitset += SharedFragmentValuesToAdd->GetSharedFragmentBitSet();
			bIsValidArchetype = NewArchetype.GetCompositionDescriptor().SharedFragments == NewSharedFragmentsBitset;
		}

		if (bIsValidArchetype && ConstSharedFragmentToRemoveBitSet)
		{
			FMassConstSharedFragmentBitSet NewConstSharedFragmentsBitset = GetConstSharedFragmentBitSet();
			NewConstSharedFragmentsBitset -= *ConstSharedFragmentToRemoveBitSet;
			NewConstSharedFragmentsBitset += SharedFragmentValuesToAdd->GetConstSharedFragmentBitSet();
			bIsValidArchetype = NewArchetype.GetCompositionDescriptor().ConstSharedFragments == NewConstSharedFragmentsBitset;
		}

		testableCheckfReturn(bIsValidArchetype, return, TEXT("%hs parameter SharedFragmentValues doesn't match archetype's composition"), __FUNCTION__);
	}

	TArray<FMassArchetypeEntityCollection::FArchetypeEntityRange> Subchunks(EntityCollection.GetRanges());

	const int32 InitialOutEntitiesCount = OutEntitiesBeingMoved.Num();

	for (const FMassArchetypeEntityCollection::FArchetypeEntityRange EntityRange : Subchunks)
	{
		if (!ensureMsgf(EntityRange.IsSet() && EntityRange.Length > 0, TEXT("We only expect to get valid EntityRanges at this point.")))
		{
			continue;
		}

		FMassArchetypeChunk& Chunk = Chunks[EntityRange.ChunkIndex];

		// 0 - consider compacting new archetype to ensure larger empty spaces
		// 1. find next free spot in the destination archetype
		// 2. min(amount of elements) to move

		// gather entities we're about to remove
		FMassEntityHandle* DyingEntityPtr = &Chunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, EntityRange.SubchunkStart);
		OutEntitiesBeingMoved.Append(DyingEntityPtr, EntityRange.Length);

		FMassArchetypeEntityCollection::FArchetypeEntityRange ResultSubChunk;
		ResultSubChunk.ChunkIndex = 0;
		ResultSubChunk.Length = 0;
		int32 NumberMoved = 0;
		const bool ChangeSharedFragments = SharedFragmentValuesToAdd || SharedFragmentToRemoveBitSet;

		do
		{
			const int32 IndexWithinChunk = EntityRange.SubchunkStart + NumberMoved;

			if (ChangeSharedFragments == false)
			{
				ResultSubChunk = NewArchetype.PrepareNextEntitiesSpanInternal(MakeArrayView(DyingEntityPtr + NumberMoved, EntityRange.Length - NumberMoved)
					, Chunk.GetSharedFragmentValues(), ResultSubChunk.ChunkIndex);
			}
			else
			{
				// create new shared values
				FMassArchetypeSharedFragmentValues NewSharedValues = Chunk.GetSharedFragmentValues();
				if (SharedFragmentToRemoveBitSet)
				{
					NewSharedValues.Remove(*SharedFragmentToRemoveBitSet);
				}
				if (ConstSharedFragmentToRemoveBitSet)
				{
					NewSharedValues.Remove(*ConstSharedFragmentToRemoveBitSet);
				}
				if (SharedFragmentValuesToAdd)
				{
					NewSharedValues.Append(*SharedFragmentValuesToAdd);
				}
				NewSharedValues.Sort();

				ResultSubChunk = NewArchetype.PrepareNextEntitiesSpanInternal(MakeArrayView(DyingEntityPtr + NumberMoved, EntityRange.Length - NumberMoved)
					, NewSharedValues, ResultSubChunk.ChunkIndex);
			}

			FMassArchetypeChunk& NewChunk = NewArchetype.Chunks[ResultSubChunk.ChunkIndex];
			MoveFragmentsToAnotherArchetypeInternal(NewArchetype, {NewChunk.GetRawMemory(), ResultSubChunk.SubchunkStart}, {Chunk.GetRawMemory(), IndexWithinChunk}, ResultSubChunk.Length);

			NumberMoved += ResultSubChunk.Length;

			if (OutNewRanges)
			{
				// if the new ResultSubChunk is right next to the last stored one then merge them both
				if (OutNewRanges->Num() && OutNewRanges->Last().IsAdjacentAfter(ResultSubChunk))
				{
					OutNewRanges->Last().Length += ResultSubChunk.Length;
				}
				else // just add
				{
					OutNewRanges->Add(ResultSubChunk);
				}
			}

		} while (NumberMoved < EntityRange.Length);

	}

	// Sorting the subchunks info so that subchunks of a given chunk are processed "from the back". Otherwise removing 
	// a subchunk from the front of the chunk would inevitably invalidate following subchunks' information.
	// Note that we do this after already having added the entities to the new archetype to preserve the order of entities 
	// as given by the input data.
	Subchunks.Sort([](const FMassArchetypeEntityCollection::FArchetypeEntityRange& A, const FMassArchetypeEntityCollection::FArchetypeEntityRange& B)
	{
		return A.ChunkIndex < B.ChunkIndex || (A.ChunkIndex == B.ChunkIndex && A.SubchunkStart > B.SubchunkStart);
	});

	for (const FMassArchetypeEntityCollection::FArchetypeEntityRange& Subchunk : Subchunks)
	{
		BatchRemoveEntitiesInternal(Subchunk.ChunkIndex, Subchunk.SubchunkStart, Subchunk.Length);
	}

	for (int i = InitialOutEntitiesCount; i < OutEntitiesBeingMoved.Num(); ++i)
	{
		EntityMap.FindAndRemoveChecked(OutEntitiesBeingMoved[i].Index);
	}
}

FMassArchetypeEntityCollection::FArchetypeEntityRange FMassArchetypeData::PrepareNextEntitiesSpanInternal(TConstArrayView<FMassEntityHandle> Entities, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, int32 StartingChunk)
{
	checkf(SharedFragmentValues.IsSorted(), TEXT("Expecting shared fragment values to be previously sorted"));
	checkf(SharedFragmentValues.HasExactFragmentTypesMatch(CompositionDescriptor.SharedFragments, CompositionDescriptor.ConstSharedFragments)
		, TEXT("Expecting values for every specified shared fragment in the archetype and only those"))

	int32 StartIndexWithinChunk = INDEX_NONE;
	int32 AbsoluteStartIndex = 0;

	FMassArchetypeChunk* DestinationChunk = nullptr;
	
	int32 ChunkIndex = StartingChunk;
	// find a chunk with any room left
	for (; ChunkIndex < Chunks.Num(); ++ChunkIndex)
	{
		FMassArchetypeChunk& Chunk = Chunks[ChunkIndex];
		if (Chunk.GetNumInstances() < NumEntitiesPerChunk && Chunk.GetSharedFragmentValues().IsEquivalent(SharedFragmentValues))
		{
			StartIndexWithinChunk = Chunk.GetNumInstances();
			AbsoluteStartIndex = ChunkIndex * NumEntitiesPerChunk + StartIndexWithinChunk;

			DestinationChunk = &Chunk;

			if (StartIndexWithinChunk == 0)
			{
				Chunk.Recycle(ChunkFragmentsTemplate, SharedFragmentValues);
			}
			break;
		}
	}

	// if no chunk found create one
	if (DestinationChunk == nullptr)
	{
		ChunkIndex = Chunks.Num();
		AbsoluteStartIndex = Chunks.Num() * NumEntitiesPerChunk;
		StartIndexWithinChunk = 0;

		DestinationChunk = &Chunks.Emplace_GetRef(GetChunkAllocSize(), ChunkFragmentsTemplate, SharedFragmentValues);
	}

	check(DestinationChunk);

	// we might be able to fit in less entitites than requested
	const int32 NumToAdd = FMath::Min(NumEntitiesPerChunk - StartIndexWithinChunk, Entities.Num());
	check(NumToAdd);
	DestinationChunk->AddMultipleInstances(NumToAdd);

	// Add to the table and map
	int32 AbsoluteIndex = AbsoluteStartIndex;
	for (int32 i = 0; i < NumToAdd; ++i)
	{
		EntityMap.Add(Entities[i].Index, AbsoluteIndex++);
	}

	FMassEntityHandle* FirstAddedEntity = &DestinationChunk->GetEntityArrayElementRef(EntityListOffsetWithinChunk, StartIndexWithinChunk);
	FMemory::Memcpy(FirstAddedEntity, Entities.GetData(), sizeof(FMassEntityHandle) * NumToAdd);

	return FMassArchetypeEntityCollection::FArchetypeEntityRange(ChunkIndex, StartIndexWithinChunk, NumToAdd);
}

void FMassArchetypeData::BatchRemoveEntitiesInternal(const int32 ChunkIndex, const int32 StartIndexWithinChunk, const int32 NumberToRemove)
{
	FMassArchetypeChunk& Chunk = Chunks[ChunkIndex];
	
	const int32 NumberToMove = FMath::Min(Chunk.GetNumInstances() - (StartIndexWithinChunk + NumberToRemove), NumberToRemove);
	checkf(NumberToMove >= 0, TEXT("Trying to move a negative number of elements indicates a problem with sub-chunk indicators, it's possibly out of date."));
	const int32 NumberToCut = FMath::Max(NumberToRemove - NumberToMove, 0);

	if (NumberToMove > 0)
	{
		FMassEntityHandle* DyingEntityPtr = &Chunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, StartIndexWithinChunk);

		const int32 SwapStartIndex = Chunk.GetNumInstances() - NumberToMove;
		checkf((StartIndexWithinChunk + NumberToMove - 1) < SwapStartIndex, TEXT("Remove and Move ranges overlap"));

		MoveFragmentsToNewLocationInternal({ Chunk.GetRawMemory(), StartIndexWithinChunk }, { Chunk.GetRawMemory(), SwapStartIndex }, NumberToMove);
		
		// Update the entity table and map
		const FMassEntityHandle* MovingEntityPtr = &Chunk.GetEntityArrayElementRef(EntityListOffsetWithinChunk, SwapStartIndex);
		int32 AbsoluteIndex = ChunkIndex * NumEntitiesPerChunk + StartIndexWithinChunk;

		for (int i = 0; i < NumberToMove; ++i)
		{
			DyingEntityPtr[i] = MovingEntityPtr[i];
			EntityMap.FindChecked(MovingEntityPtr[i].Index) = AbsoluteIndex++;
		}
	}

	Chunk.RemoveMultipleInstances(NumberToRemove);

	// If the chunk itself is empty now, see if we can remove it entirely
	// Note: This is only possible for trailing chunks, to avoid messing up the absolute indices in the entities map
	while ((Chunks.Num() > 0) && (Chunks.Last().GetNumInstances() == 0))
	{
		Chunks.RemoveAt(Chunks.Num() - 1, EAllowShrinking::No);
	}
}

void FMassArchetypeData::MoveFragmentsToAnotherArchetypeInternal(FMassArchetypeData& TargetArchetype, FMassArchetypeData::FTransientChunkLocation Target
	, const FMassArchetypeData::FTransientChunkLocation Source, const int32 ElementsNum)
{
	// for every TargetArchetype's fragment see if it was in the old archetype as well and if so copy it's value. 
	// If not then initialize the fragment.
	for (const FMassArchetypeFragmentConfig& TargetFragmentConfig : TargetArchetype.FragmentConfigs)
	{
		const int32* OldFragmentIndex = FragmentIndexMap.Find(TargetFragmentConfig.FragmentType);
		void* Dst = TargetFragmentConfig.GetFragmentData(Target.RawChunkMemory, Target.IndexWithinChunk);

		// Only copy if the fragment type exists in both archetypes
		if (OldFragmentIndex)
		{
			const void* Src = FragmentConfigs[*OldFragmentIndex].GetFragmentData(Source.RawChunkMemory, Source.IndexWithinChunk);
			FMemory::Memcpy(Dst, Src, TargetFragmentConfig.FragmentType->GetStructureSize() * ElementsNum);
		}
		else
		{
			// the fragment's unique to the TargetArchetype need to be initialized
			// @todo we're doing it for tags here as well. A tiny bit of perf lost. Probably not worth adding a check
			// but something to keep in mind. Will go away once tags are more of an archetype fragment than entity's
			TargetFragmentConfig.FragmentType->InitializeStruct(Dst, ElementsNum);
		}
	}

	// Delete fragments that were left behind
	for (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)
	{
		// If the fragment is not in the new archetype, destroy it.
		const int32* NewFragmentIndex = TargetArchetype.FragmentIndexMap.Find(FragmentConfig.FragmentType);
		if (NewFragmentIndex == nullptr)
		{
			void* DyingFragmentPtr = FragmentConfig.GetFragmentData(Source.RawChunkMemory, Source.IndexWithinChunk);
			FragmentConfig.FragmentType->DestroyStruct(DyingFragmentPtr, ElementsNum);
		}
	}
}

FORCEINLINE void FMassArchetypeData::MoveFragmentsToNewLocationInternal(FMassArchetypeData::FTransientChunkLocation Target, const FMassArchetypeData::FTransientChunkLocation Source, const int32 NumberToMove)
{
	for (const FMassArchetypeFragmentConfig& FragmentConfig : FragmentConfigs)
	{
		void* DyingFragmentPtr = FragmentConfig.GetFragmentData(Target.RawChunkMemory, Target.IndexWithinChunk);
		void* MovingFragmentPtr = FragmentConfig.GetFragmentData(Source.RawChunkMemory, Source.IndexWithinChunk); 

		// Swap fragments to the empty space just created.
		FMemory::Memcpy(DyingFragmentPtr, MovingFragmentPtr, FragmentConfig.FragmentType->GetStructureSize() * NumberToMove);
	}
}

void FMassArchetypeData::BatchSetFragmentValues(TConstArrayView<FMassArchetypeEntityCollection::FArchetypeEntityRange> EntityCollection, const FMassGenericPayloadViewSlice& Payload)
{
	int32 EntitiesHandled = 0;

	for (const FMassArchetypeEntityCollection::FArchetypeEntityRange EntityRange : EntityCollection)
	{
		FMassArchetypeChunk& Chunk = Chunks[EntityRange.ChunkIndex];

		for (int i = 0; i < Payload.Num(); ++i)
		{
			FStructArrayView FragmentPayload = Payload[i];
			check(FragmentPayload.Num() - EntitiesHandled >= EntityRange.Length);

			const UScriptStruct* FragmentType = FragmentPayload.GetScriptStruct();
			check(FragmentType);

			const int32 FragmentIndex = FragmentIndexMap.FindChecked(FragmentType);
			void* Dst = FragmentConfigs[FragmentIndex].GetFragmentData(Chunk.GetRawMemory(), EntityRange.SubchunkStart);
			const void* Src = FragmentPayload.GetDataAt(EntitiesHandled);

			FragmentType->CopyScriptStruct(Dst, Src, EntityRange.Length);
		}

		EntitiesHandled += EntityRange.Length;
	}
}

//-----------------------------------------------------------------------------
// FMassArchetypeHelper
//-----------------------------------------------------------------------------
bool FMassArchetypeHelper::DoesArchetypeMatchRequirements(const FMassArchetypeData& Archetype, const FMassFragmentRequirements& Requirements)
{
	return DoesArchetypeMatchRequirements(Archetype.GetCompositionDescriptor(), Requirements);
}
bool FMassArchetypeHelper::DoesArchetypeMatchRequirements(const FMassArchetypeCompositionDescriptor& ArchetypeComposition, const FMassFragmentRequirements& Requirements)
{
	return Requirements.DoesArchetypeMatchRequirements(ArchetypeComposition);
}

#if WITH_MASSENTITY_DEBUG
bool FMassArchetypeHelper::DoesArchetypeMatchRequirements(const FMassArchetypeData& Archetype, const FMassFragmentRequirements& Requirements
	, const bool bBailOutOnFirstFail, FOutputDevice* OutputDevice)
{
	if (DoesArchetypeMatchRequirements(Archetype.GetCompositionDescriptor(), Requirements))
	{
		// nothing to log
		return true;
	}
	
	if (OutputDevice)
	{
		// do logging
		OutputDevice->Logf(TEXT("% s")
			, *FMassDebugger::GetArchetypeRequirementCompatibilityDescription(Requirements, Archetype.GetCompositionDescriptor()));
	}

	return false;

	//bool bResult = true;
	//if (Requirements.IsOptionalsOnly() == false)
	//{
	//	if (Archetype.GetTagBitSet().HasAll(Requirements.GetRequiredAllTags()) == false)
	//	{
	//		// missing some required tags, skip.
	//		const FMassTagBitSet UnsatisfiedTags = Requirements.GetRequiredAllTags() - Archetype.GetTagBitSet();
	//		FStringOutputDevice Description;
	//		UnsatisfiedTags.DebugGetStringDesc(Description);
	//		OutputDevice->Logf(TEXT("Archetype did not match due to missing tags: %s"), *Description);

	//		bResult = false;
	//		if (bBailOutOnFirstFail)
	//		{
	//			return false;
	//		}
	//	}

	//	if (Archetype.GetTagBitSet().HasNone(Requirements.GetRequiredNoneTags()) == false)
	//	{
	//		// has some tags required to be absent
	//		const FMassTagBitSet UnwantedTags = Requirements.GetRequiredNoneTags().GetOverlap(Archetype.GetTagBitSet());
	//		FStringOutputDevice Description;
	//		UnwantedTags.DebugGetStringDesc(Description);
	//		OutputDevice->Logf(TEXT("Archetype has tags required absent: %s"), *Description);

	//		bResult = false;
	//		if (bBailOutOnFirstFail)
	//		{
	//			return false;
	//		}
	//	}

	//	if (Requirements.GetRequiredAnyTags().IsEmpty() == false
	//		&& Archetype.GetTagBitSet().HasAny(Requirements.GetRequiredAnyTags()) == false)
	//	{
	//		FStringOutputDevice Description;
	//		Requirements.GetRequiredAnyTags().DebugGetStringDesc(Description);
	//		OutputDevice->Logf(TEXT("Archetype did not match due to missing \'any\' tags: %s"), *Description);

	//		bResult = false;
	//		if (bBailOutOnFirstFail)
	//		{
	//			return false;
	//		}
	//	}

	//	if (Archetype.GetFragmentBitSet().HasAll(Requirements.GetRequiredAllFragments()) == false)
	//	{
	//		// missing some required fragments, skip.
	//		const FMassFragmentBitSet UnsatisfiedFragments = Requirements.GetRequiredAllFragments() - Archetype.GetFragmentBitSet();
	//		FStringOutputDevice Description;
	//		UnsatisfiedFragments.DebugGetStringDesc(Description);
	//		OutputDevice->Logf(TEXT("Archetype did not match due to missing Fragments: %s"), *Description);

	//		bResult = false;
	//		if (bBailOutOnFirstFail)
	//		{
	//			return false;
	//		}
	//	}

	//	if (Archetype.GetFragmentBitSet().HasNone(Requirements.GetRequiredNoneFragments()) == false)
	//	{
	//		// has some Fragments required to be absent
	//		const FMassFragmentBitSet UnwantedFragments = Requirements.GetRequiredNoneFragments().GetOverlap(Archetype.GetFragmentBitSet());
	//		FStringOutputDevice Description;
	//		UnwantedFragments.DebugGetStringDesc(Description);
	//		OutputDevice->Logf(TEXT("Archetype has Fragments required absent: %s"), *Description);

	//		bResult = false;
	//		if (bBailOutOnFirstFail)
	//		{
	//			return false;
	//		}
	//	}

	//	if (Requirements.GetRequiredAnyFragments().IsEmpty() == false
	//		&& Archetype.GetFragmentBitSet().HasAny(Requirements.GetRequiredAnyFragments()) == false)
	//	{
	//		FStringOutputDevice Description;
	//		Requirements.GetRequiredAnyFragments().DebugGetStringDesc(Description);
	//		OutputDevice->Logf(TEXT("Archetype did not match due to missing \'any\' fragments: %s"), *Description);

	//		bResult = false;
	//		if (bBailOutOnFirstFail)
	//		{
	//			return false;
	//		}
	//	}

	//	if (Archetype.GetChunkFragmentBitSet().HasAll(Requirements.GetRequiredAllChunkFragments()) == false)
	//	{
	//		// missing some required fragments, skip.
	//		const FMassChunkFragmentBitSet UnsatisfiedFragments = Requirements.GetRequiredAllChunkFragments() - Archetype.GetChunkFragmentBitSet();
	//		FStringOutputDevice Description;
	//		UnsatisfiedFragments.DebugGetStringDesc(Description);
	//		OutputDevice->Logf(TEXT("Archetype did not match due to missing Chunk Fragments: %s"), *Description);

	//		bResult = false;
	//		if (bBailOutOnFirstFail)
	//		{
	//			return false;
	//		}
	//	}

	//	if (Archetype.GetChunkFragmentBitSet().HasNone(Requirements.GetRequiredNoneChunkFragments()) == false)
	//	{
	//		// has some Fragments required to be absent
	//		const FMassChunkFragmentBitSet UnwantedFragments = Requirements.GetRequiredNoneChunkFragments().GetOverlap(Archetype.GetChunkFragmentBitSet());
	//		FStringOutputDevice Description;
	//		UnwantedFragments.DebugGetStringDesc(Description);
	//		OutputDevice->Logf(TEXT("Archetype has Chunk Fragments required absent: %s"), *Description);

	//		bResult = false;
	//		if (bBailOutOnFirstFail)
	//		{
	//			return false;
	//		}
	//	}

	//	if (Archetype.GetSharedFragmentBitSet().HasAll(Requirements.GetRequiredAllSharedFragments()) == false)
	//	{
	//		// missing some required fragments, skip.
	//		const FMassSharedFragmentBitSet UnsatisfiedFragments = Requirements.GetRequiredAllSharedFragments() - Archetype.GetSharedFragmentBitSet();
	//		FStringOutputDevice Description;
	//		UnsatisfiedFragments.DebugGetStringDesc(Description);
	//		OutputDevice->Logf(TEXT("Archetype did not match due to missing Shared Fragments: %s"), *Description);

	//		bResult = false;
	//		if (bBailOutOnFirstFail)
	//		{
	//			return false;
	//		}
	//	}

	//	if (Archetype.GetSharedFragmentBitSet().HasNone(Requirements.GetRequiredNoneSharedFragments()) == false)
	//	{
	//		// has some Fragments required to be absent
	//		const FMassSharedFragmentBitSet UnwantedFragments = Requirements.GetRequiredNoneSharedFragments().GetOverlap(Archetype.GetSharedFragmentBitSet());
	//		FStringOutputDevice Description;
	//		UnwantedFragments.DebugGetStringDesc(Description);
	//		OutputDevice->Logf(TEXT("Archetype has Shared Fragments required absent: %s"), *Description);

	//		bResult = false;
	//		if (bBailOutOnFirstFail)
	//		{
	//			return false;
	//		}
	//	}

	//	if (Archetype.GetConstSharedFragmentBitSet().HasAll(Requirements.GetRequiredAllConstSharedFragments()) == false)
	//	{
	//		// missing some required fragments, skip.
	//		const FMassConstSharedFragmentBitSet UnsatisfiedFragments = Requirements.GetRequiredAllConstSharedFragments() - Archetype.GetConstSharedFragmentBitSet();
	//		FStringOutputDevice Description;
	//		UnsatisfiedFragments.DebugGetStringDesc(Description);
	//		OutputDevice->Logf(TEXT("Archetype did not match due to missing Const Shared Fragments: %s"), *Description);

	//		bResult = false;
	//		if (bBailOutOnFirstFail)
	//		{
	//			return false;
	//		}
	//	}

	//	if (Archetype.GetConstSharedFragmentBitSet().HasNone(Requirements.GetRequiredNoneConstSharedFragments()) == false)
	//	{
	//		// has some Fragments required to be absent
	//		const FMassConstSharedFragmentBitSet UnwantedFragments = Requirements.GetRequiredNoneConstSharedFragments().GetOverlap(Archetype.GetConstSharedFragmentBitSet());
	//		FStringOutputDevice Description;
	//		UnwantedFragments.DebugGetStringDesc(Description);
	//		OutputDevice->Logf(TEXT("Archetype has Const Shared Fragments required absent: %s"), *Description);

	//		// could skip the test as it's the final check we're performing, but leaving it in in case more cases are added
	//		// later without checking the existing code
	//		bResult = false;
	//		if (bBailOutOnFirstFail)
	//		{
	//			return false;
	//		}
	//	}
	//}
	//else
	//{
	//	// test if contains any of the optional elements
	//	if (Archetype.GetFragmentBitSet().HasNone(Requirements.GetRequiredOptionalFragments())
	//		&& Archetype.GetTagBitSet().HasNone(Requirements.GetRequiredOptionalTags())
	//		&& Archetype.GetChunkFragmentBitSet().HasNone(Requirements.GetRequiredOptionalChunkFragments())
	//		&& Archetype.GetSharedFragmentBitSet().HasNone(Requirements.GetRequiredOptionalSharedFragments())
	//		&& Archetype.GetConstSharedFragmentBitSet().HasNone(Requirements.GetRequiredOptionalConstSharedFragments()))
	//	{
	//		FStringOutputDevice Description;
	//		Requirements.GetRequiredOptionalFragments().DebugGetStringDesc(Description);
	//		Requirements.GetRequiredOptionalTags().DebugGetStringDesc(Description);
	//		Requirements.GetRequiredOptionalChunkFragments().DebugGetStringDesc(Description);
	//		Requirements.GetRequiredOptionalSharedFragments().DebugGetStringDesc(Description);
	//		Requirements.GetRequiredOptionalConstSharedFragments().DebugGetStringDesc(Description);
	//		
	//		OutputDevice->Logf(TEXT("Archetype has none of the optional elements: %s"), *Description);

	//		bResult = false;
	//	}
	//}

	//return bResult;
}
#endif // WITH_MASSENTITY_DEBUG
================================================


=== MassEntity/Private/MassArchetypeTypes.cpp ===
=================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassArchetypeTypes.h"
#include "MassEntityManager.h"
#include "MassArchetypeData.h"
#include "MassCommandBuffer.h"
#include "MassEntityUtils.h"

//////////////////////////////////////////////////////////////////////
// FMassArchetypeHandle

uint32 GetTypeHash(const FMassArchetypeHandle& Instance)
{
	return GetTypeHash(Instance.DataPtr.Get());
}

//////////////////////////////////////////////////////////////////////
// FMassArchetypeEntityCollection 

FMassArchetypeEntityCollection::FMassArchetypeEntityCollection(const FMassArchetypeHandle& InArchetype, TConstArrayView<FMassEntityHandle> InEntities, EDuplicatesHandling DuplicatesHandling)
	: Archetype(InArchetype)
{
	if (InEntities.Num() <= 0)
	{
		return;
	}

	const FMassArchetypeData* ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandle(InArchetype);
	const int32 NumEntitiesPerChunk = ArchetypeData ? ArchetypeData->GetNumEntitiesPerChunk() : MAX_int32;

	// InEntities has a real chance of not being sorted by AbsoluteIndex. We gotta fix that to optimize how we process the data 
	TArray<int32> TrueIndices;
	TrueIndices.AddUninitialized(InEntities.Num());
	int32 NumValidEntities = 0;
	if (ArchetypeData)
	{
		for (const FMassEntityHandle& Entity : InEntities)
		{
			if (Entity.IsValid())
			{
				if (const int32* TrueIndex = ArchetypeData->GetInternalIndexForEntity(Entity.Index))
				{
					TrueIndices[NumValidEntities++] = *TrueIndex;
				}
			}
		}
	}
	else
	{
		// special case, where we have a bunch of entities that have been built but not assigned an archetype yet.
		// we use their base index for the sake of sorting here. Will still get some perf benefits and we can keep using
		// FMassArchetypeEntityCollection as the generic batched API wrapper for entities
		for (const FMassEntityHandle& Entity : InEntities)
		{
			if (Entity.IsValid())
			{
				TrueIndices[NumValidEntities++] = Entity.Index;
			}
		}
	}

	TrueIndices.SetNum(NumValidEntities, EAllowShrinking::No);
	TrueIndices.Sort();

#if DO_GUARD_SLOW
	if (DuplicatesHandling == NoDuplicates)
	{
		// ensure there are no duplicates. 
		int32 PrevIndex = TrueIndices[0];
		for (int j = 1; j < TrueIndices.Num(); ++j)
		{
			checkf(TrueIndices[j] != PrevIndex, TEXT("InEntities contains duplicate while DuplicatesHandling is set to NoDuplicates"));
			if (TrueIndices[j] == PrevIndex)
			{
				// fix it, for development's sake
				DuplicatesHandling = FoldDuplicates;
				break;
			}
			PrevIndex = TrueIndices[j];
		}
	}
#endif // DO_GUARD_SLOW

	if (DuplicatesHandling == FoldDuplicates)
	{
		int32 PrevIndex = TrueIndices[0];
		for (int j = 1; j < TrueIndices.Num(); ++j)
		{
			if (TrueIndices[j] == PrevIndex)
			{
				const int32 Num = TrueIndices.Num();
				int Skip = 0;
				while ((j + ++Skip) < Num && TrueIndices[j + Skip] == PrevIndex);
				
				TrueIndices.RemoveAt(j, Skip, EAllowShrinking::No);
				--j;
				continue;
			}
			PrevIndex = TrueIndices[j];
		}
	}

	BuildEntityRanges(MakeStridedView<const int32>(TrueIndices));
}

void FMassArchetypeEntityCollection::BuildEntityRanges(TStridedView<const int32> TrueIndices)
{
	checkf(Ranges.Num() == 0, TEXT("Calling %s is valid only for initial configuration"), ANSI_TO_TCHAR(__FUNCTION__));

	const FMassArchetypeData* ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandle(Archetype);
	const int32 NumEntitiesPerChunk = ArchetypeData ? ArchetypeData->GetNumEntitiesPerChunk() : MAX_int32;

	// the following block of code is splitting up sorted AbsoluteIndices into 
	// continuous chunks
	int32 ChunkEnd = INDEX_NONE;
	FArchetypeEntityRange DummyChunk;
	FArchetypeEntityRange* SubChunkPtr = &DummyChunk;
	int32 SubchunkLen = 0;
	int32 PrevAbsoluteIndex = INDEX_NONE;
	for (const int32 Index : TrueIndices)
	{
		// if run across a chunk border or run into an index discontinuity 
		if (Index >= ChunkEnd || Index != (PrevAbsoluteIndex + 1))
		{
			SubChunkPtr->Length = SubchunkLen;
			// note that both ChunkIndex and ChunkEnd will change only if AbsoluteIndex >= ChunkEnd
			const int32 ChunkIndex = Index / NumEntitiesPerChunk;
			ChunkEnd = (ChunkIndex + 1) * NumEntitiesPerChunk;
			SubchunkLen = 0;
			// new subchunk
			const int32 SubchunkStart = Index % NumEntitiesPerChunk;
			SubChunkPtr = &Ranges.Add_GetRef(FArchetypeEntityRange(ChunkIndex, SubchunkStart));
		}
		++SubchunkLen;
		PrevAbsoluteIndex = Index;
	}

	SubChunkPtr->Length = SubchunkLen;
}

FMassArchetypeEntityCollection::FMassArchetypeEntityCollection(const FMassArchetypeHandle& InArchetypeHandle, const EInitializationType Initialization)
	: Archetype(InArchetypeHandle)
{
	if (Initialization == EInitializationType::GatherAll)
	{
		check(InArchetypeHandle.IsValid());
		GatherChunksFromArchetype();
	}
}

FMassArchetypeEntityCollection::FMassArchetypeEntityCollection(TSharedPtr<FMassArchetypeData>& InArchetype, const EInitializationType Initialization)
	: Archetype(FMassArchetypeHelper::ArchetypeHandleFromData(InArchetype))
{	
	if (Initialization == EInitializationType::GatherAll)
	{
		check(InArchetype.IsValid());
		GatherChunksFromArchetype();
	}
}

void FMassArchetypeEntityCollection::GatherChunksFromArchetype()
{
	if (const FMassArchetypeData* ArchetypePtr = FMassArchetypeHelper::ArchetypeDataFromHandle(Archetype))
	{
		const int32 ChunkCount = ArchetypePtr->GetChunkCount();
		Ranges.Reset(ChunkCount);
		for (int32 i = 0; i < ChunkCount; ++i)
		{
			Ranges.Add(FArchetypeEntityRange(i));
		}
	}
}

bool FMassArchetypeEntityCollection::IsSame(const FMassArchetypeEntityCollection& Other) const
{
	if (Archetype != Other.Archetype || Ranges.Num() != Other.Ranges.Num())
	{
		return false;
	}

	for (int i = 0; i < Ranges.Num(); ++i)
	{
		if (Ranges[i] != Other.Ranges[i])
		{
			return false;
		}
	}
	return true;
}

//////////////////////////////////////////////////////////////////////
// FMassArchetypeEntityCollectionWithPayload

void FMassArchetypeEntityCollectionWithPayload::CreateEntityRangesWithPayload(const FMassEntityManager& EntityManager, const TConstArrayView<FMassEntityHandle> Entities
	, const FMassArchetypeEntityCollection::EDuplicatesHandling DuplicatesHandling, FMassGenericPayloadView Payload
	, TArray<FMassArchetypeEntityCollectionWithPayload>& OutEntityCollections)
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("Mass_CreateEntityRangesWithPayload");

	check(Payload.Num() > 0);
	for (const FStructArrayView& Element : Payload.Content)
	{
		check(Entities.Num() == Element.Num());
	}

	struct FEntityInArchetype
	{
		int32 ArchetypeIndex = INDEX_NONE;
		int32 TrueIndex = INDEX_NONE;

		bool operator==(const FEntityInArchetype& Other) const
		{
			return ArchetypeIndex == Other.ArchetypeIndex && TrueIndex == Other.TrueIndex;
		}

		/** @return whether A should come before B in an ordered collection */
		static bool Compare(const FEntityInArchetype& A, const FEntityInArchetype& B)
		{
			// using "greater" to ensure INDEX_NONE archetypes end up at the end of the collection
			return A.ArchetypeIndex > B.ArchetypeIndex || (A.ArchetypeIndex == B.ArchetypeIndex && A.TrueIndex < B.TrueIndex);
		}
	};

	TArray<FEntityInArchetype> EntityData;
	EntityData.AddUninitialized(Entities.Num());

	struct FArchetypeInfo
	{
		// @todo using a handle here is temporary. Once ArchetypeHandle switches to using an index we'll use that instead
		FMassArchetypeHandle Archetype;
		int32 Count = 0;

		bool operator==(const FMassArchetypeHandle& InArchetype) const
		{
			return Archetype == InArchetype;
		}
		bool operator==(const FArchetypeInfo& Other) const
		{
			return Archetype == Other.Archetype;
		}
	};
	TArray<FArchetypeInfo> Archetypes;

	for (int32 i = 0; i < Entities.Num(); ++i)
	{
		const FMassEntityHandle& Entity = Entities[i];
		if (EntityManager.IsEntityValid(Entity))
		{
			// using Unsafe since we just checked that the entity is valid
			const FMassArchetypeHandle ArchetypeHandle = EntityManager.GetArchetypeForEntityUnsafe(Entity);
			const FMassArchetypeData* ArchetypePtr = FMassArchetypeHelper::ArchetypeDataFromHandle(ArchetypeHandle);
		
			// @todo if FMassArchetypeHandle used indices the look up would be a lot faster
			int32 ArchetypeIndex = INDEX_NONE;
		
			if (Archetypes.Find(FArchetypeInfo{ ArchetypeHandle, 0 }, ArchetypeIndex) == false)
			{
				ArchetypeIndex = Archetypes.Add({ ArchetypeHandle, 0 });
			}
			++Archetypes[ArchetypeIndex].Count;
			EntityData[i] = { ArchetypeIndex, ArchetypePtr ? ArchetypePtr->GetInternalIndexForEntityChecked(Entity.Index) : Entity.Index };
		}
		else
		{
			// for invalid entities we create an entry that will result in all of them batched together 
			// (due to having the same archetype index, INDEX_NONE). Since the main logic loop below relies on entries 
			// in Archetypes and the "invalid" EntityData doesn't correspond to any, all the invalid entities 
			// will be silently filtered out.
			EntityData[i] = FEntityInArchetype();
			UE_LOG(LogMass, Warning, TEXT("%hs: Invalid entity handle passed in. Ignoring it, but check your code to make sure you don't mix synchronous entity-mutating Mass API function calls with Mass commands")
				, __FUNCTION__);
		}
	}

	// A paranoid programmer might point out that there are no guarantees that a sorting algorithm will compare all elements.
	// While that's true we make an assumption here, that the elements next to each other will in fact all get compared
	// and since all we care about with `bDuplicatesFound` is whether same elements exist (that will be right next to each other
	// in the final lineup) we feel safe in the assumption.
	bool bDuplicatesFound = false;
	UE::Mass::Utils::AbstractSort(Entities.Num(), [&EntityData, &bDuplicatesFound](const int32 LHS, const int32 RHS)
		{
			bDuplicatesFound = bDuplicatesFound || (EntityData[LHS] == EntityData[RHS]);
			return FEntityInArchetype::Compare(EntityData[LHS], EntityData[RHS]);
		}
		, [&EntityData, &Payload](const int32 A, const int32 B)
		{
			::Swap(EntityData[A], EntityData[B]);
			Payload.Swap(A, B);
		});
	ensureMsgf(bDuplicatesFound == false || (DuplicatesHandling != FMassArchetypeEntityCollection::NoDuplicates)
		, TEXT("Caller declared lack of duplicates in the input data, but duplicates have been found"));

#if !UE_BUILD_SHIPPING
	// in non shipping builds we still want to verify that the assumption expressed in bDuplicatesFound comment above
	// is correct
	if (!bDuplicatesFound && (DuplicatesHandling == FMassArchetypeEntityCollection::FoldDuplicates))
	{
		for (int32 EntryIndex = 0; EntryIndex < EntityData.Num() - 1; ++EntryIndex)
		{
			checkf(EntityData[EntryIndex] != EntityData[EntryIndex + 1], TEXT("Assumption regarding comparison between identical elements while sorting is wrong!"));
		}
	}
#endif // !UE_BUILD_SHIPPING

	if (bDuplicatesFound && (DuplicatesHandling == FMassArchetypeEntityCollection::FoldDuplicates))
	{
		// we cannot remove elements from Payload, since it's a view to existing data, we need to sort the data in 
		// such a way that all the duplicates end up at the end of the view. We can then ignore the appropriate
		// number of elements.
		
		// processing Num - 1 elements since there's no point in checking the last one - there's nothing to compare it against
		for (int32 EntryIndex = 0; EntryIndex < EntityData.Num() - 1; ++EntryIndex)
		{	
			FEntityInArchetype& Entry = EntityData[EntryIndex];
			if (Entry.ArchetypeIndex == INDEX_NONE)
			{
				// we're reached INDEX_NONE archetypes, which are at the end of EntityData
				// breaking since there's nothing more to process. 
				break;
			}
			else if (Entry != EntityData[EntryIndex + 1])
			{
				continue;
			}

			int32 DuplicateIndex = EntryIndex + 1;
			while (DuplicateIndex + 1 < EntityData.Num() && Entry == EntityData[DuplicateIndex + 1])
			{
				++DuplicateIndex;
			};

			const int32 NumDuplicates = DuplicateIndex - EntryIndex;

			EntityData.RemoveAt(EntryIndex + 1, NumDuplicates, EAllowShrinking::No);
			Payload.SwapElementsToEnd(EntryIndex + 1, NumDuplicates);
			// even though we don't remove the elements from payload we later limit the number of elements used with
			// ArchetypeInfo.Count, so we need to update that
			Archetypes[Entry.ArchetypeIndex].Count -= NumDuplicates;
		}
	}

	int32 ProcessedEntitiesCount = 0;
	// processing from the back since that's how EntityData is sorted - higher-index archetypes come first
	for (int32 ArchetypeIndex = Archetypes.Num() - 1; ArchetypeIndex >= 0; --ArchetypeIndex)
	{
		FArchetypeInfo& ArchetypeInfo = Archetypes[ArchetypeIndex];
		TArrayView<FEntityInArchetype> EntityDataSubset = MakeArrayView(&EntityData[ProcessedEntitiesCount], ArchetypeInfo.Count);
		ensure(EntityDataSubset[0].ArchetypeIndex == ArchetypeIndex);
		ensure(EntityDataSubset.Last().ArchetypeIndex == ArchetypeIndex);
		TStridedView<int32> TrueIndices = MakeStridedView(EntityDataSubset, &FEntityInArchetype::TrueIndex);

		FMassGenericPayloadViewSlice PayloadSubView(Payload, ProcessedEntitiesCount, ArchetypeInfo.Count);

		OutEntityCollections.Add(FMassArchetypeEntityCollectionWithPayload(ArchetypeInfo.Archetype, TrueIndices, MoveTemp(PayloadSubView)));

		ProcessedEntitiesCount += ArchetypeInfo.Count;
	}
}

FMassArchetypeEntityCollectionWithPayload::FMassArchetypeEntityCollectionWithPayload(const FMassArchetypeHandle& InArchetype, TStridedView<const int32> TrueIndices, FMassGenericPayloadViewSlice&& InPayloadSlice)
	: Entities(InArchetype, FMassArchetypeEntityCollection::DoNothing)
	, PayloadSlice(InPayloadSlice)
{
	Entities.BuildEntityRanges(TrueIndices);
}

=================================================


=== MassEntity/Private/MassCommandBuffer.cpp ===
================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassCommandBuffer.h"
#include "Containers/AnsiString.h"
#include "MassObserverManager.h"
#include "MassEntityUtils.h"
#include "HAL/IConsoleManager.h"
#include "ProfilingDebugging/CsvProfiler.h"
#include "VisualLogger/VisualLogger.h"


CSV_DEFINE_CATEGORY(MassEntities, true);
CSV_DEFINE_CATEGORY(MassEntitiesCounters, true);
DECLARE_CYCLE_STAT(TEXT("Mass Flush Commands"), STAT_Mass_FlushCommands, STATGROUP_Mass);

namespace UE::Mass::Command {

#if CSV_PROFILER_STATS
bool bEnableDetailedStats = false;

FAutoConsoleVariableRef CVarEnableDetailedCommandStats(TEXT("massentities.EnableCommandDetailedStats"), bEnableDetailedStats,
	TEXT("Set to true create a dedicated stat per type of command."), ECVF_Default);

/** CSV stat names */
static FString DefaultBatchedName = TEXT("BatchedCommand");
static TMap<FName, TPair<FString, FAnsiString>> CommandBatchedFNames;

/** CSV custom stat names (ANSI) */
static FAnsiString DefaultANSIBatchedName = "BatchedCommand";

/**
 * Provides valid names for CSV profiling.
 * @param Command is the command instance
 * @param OutName is the name to use for csv custom stats
 * @param OutANSIName is the name to use for csv stats
 */
void GetCommandStatNames(FMassBatchedCommand& Command, FString*& OutName, FAnsiString*& OutANSIName)
{
	OutANSIName = &DefaultANSIBatchedName;
	OutName     = &DefaultBatchedName;
	if (!bEnableDetailedStats)
	{
		return;
	}

	const FName CommandFName = Command.GetFName();

	TPair<FString, FAnsiString>& Names = CommandBatchedFNames.FindOrAdd(CommandFName);
	OutName     = &Names.Get<FString>();
	OutANSIName = &Names.Get<FAnsiString>();
	if (OutName->IsEmpty())
	{
		*OutName     = CommandFName.ToString();
		*OutANSIName = **OutName;
	}
}

#endif
} // UE::Mass::Command

//////////////////////////////////////////////////////////////////////
// FMassBatchedCommand
std::atomic<uint32> FMassBatchedCommand::CommandsCounter;

//////////////////////////////////////////////////////////////////////
// FMassCommandBuffer

FMassCommandBuffer::FMassCommandBuffer()
	: OwnerThreadId(FPlatformTLS::GetCurrentThreadId())
{	
}

FMassCommandBuffer::~FMassCommandBuffer()
{
	ensureMsgf(HasPendingCommands() == false, TEXT("Destroying FMassCommandBuffer while there are still unprocessed commands. These operations will never be performed now."));

	CleanUp();
}

void FMassCommandBuffer::ForceUpdateCurrentThreadID()
{
	OwnerThreadId = FPlatformTLS::GetCurrentThreadId();
}

bool FMassCommandBuffer::Flush(FMassEntityManager& EntityManager)
{
	check(!bIsFlushing);
	TGuardValue FlushingGuard(bIsFlushing, true);

	// short-circuit exit
	if (HasPendingCommands() == false)
	{
		return false;
	}

	{
		UE_MT_SCOPED_WRITE_ACCESS(PendingBatchCommandsDetector);
		LLM_SCOPE_BYNAME(TEXT("Mass/FlushCommands"));
		SCOPE_CYCLE_COUNTER(STAT_Mass_FlushCommands);

		// array used to group commands depending on their operations. Based on EMassCommandOperationType
		constexpr int32 CommandTypeOrder[] =
		{
			MAX_int32 - 1, // None
			0, // Create
			3, // Add
			1, // Remove
			2, // ChangeComposition
			4, // Set
			5, // Destroy
		};
		static_assert(UE_ARRAY_COUNT(CommandTypeOrder) == (int)EMassCommandOperationType::MAX, "CommandTypeOrder needs to correspond to all EMassCommandOperationType\'s entries");

		struct FBatchedCommandsSortedIndex
		{
			FBatchedCommandsSortedIndex(const int32 InIndex, const int32 InGroupOrder)
				: Index(InIndex), GroupOrder(InGroupOrder)
			{}

			const int32 Index = -1;
			const int32 GroupOrder = MAX_int32;
			bool IsValid() const { return GroupOrder < MAX_int32; }
			bool operator<(const FBatchedCommandsSortedIndex& Other) const { return GroupOrder < Other.GroupOrder; }
		};
		
		TArray<FBatchedCommandsSortedIndex> CommandsOrder;
		const int32 OwnedCommandsCount = CommandInstances.Num();

		CommandsOrder.Reserve(OwnedCommandsCount);
		for (int32 i = 0; i < OwnedCommandsCount; ++i)
		{
			const TUniquePtr<FMassBatchedCommand>& Command = CommandInstances[i];
			CommandsOrder.Add(FBatchedCommandsSortedIndex(i, (Command && Command->HasWork())? CommandTypeOrder[(int)Command->GetOperationType()] : MAX_int32));
		}
		for (int32 i = 0; i < AppendedCommandInstances.Num(); ++i)
		{
			const TUniquePtr<FMassBatchedCommand>& Command = AppendedCommandInstances[i];
			CommandsOrder.Add(FBatchedCommandsSortedIndex(i + OwnedCommandsCount, (Command && Command->HasWork()) ? CommandTypeOrder[(int)Command->GetOperationType()] : MAX_int32));
		}
		CommandsOrder.StableSort();
				
		for (int32 k = 0; k < CommandsOrder.Num() && CommandsOrder[k].IsValid(); ++k)
		{
			const int32 CommandIndex = CommandsOrder[k].Index;
			TUniquePtr<FMassBatchedCommand>& Command = CommandIndex < OwnedCommandsCount
				? CommandInstances[CommandIndex]
				: AppendedCommandInstances[CommandIndex - OwnedCommandsCount];
			check(Command)

#if CSV_PROFILER_STATS
			using namespace UE::Mass::Command;

			// Extract name (default or detailed)
			FAnsiString* ANSIName = nullptr;
			FString*     Name     = nullptr;
			GetCommandStatNames(*Command, Name, ANSIName);

			// Push stats
			FScopedCsvStat ScopedCsvStat(**ANSIName, CSV_CATEGORY_INDEX(MassEntities));
			FCsvProfiler::RecordCustomStat(**Name, CSV_CATEGORY_INDEX(MassEntitiesCounters), Command->GetNumOperationsStat(), ECsvCustomStatOp::Accumulate);
#endif // CSV_PROFILER_STATS

			Command->Execute(EntityManager);
			Command->Reset();
		}

		AppendedCommandInstances.Reset();

		ActiveCommandsCounter = 0;
	}

	return true;
}
 
void FMassCommandBuffer::CleanUp()
{
	CommandInstances.Reset();
	AppendedCommandInstances.Reset();

	ActiveCommandsCounter = 0;
}

void FMassCommandBuffer::MoveAppend(FMassCommandBuffer& Other)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(MassCommandBuffer_MoveAppend);

	// @todo optimize, there surely a way to do faster then this.
	UE_MT_SCOPED_READ_ACCESS(Other.PendingBatchCommandsDetector);
	if (Other.HasPendingCommands())
	{
		FScopeLock Lock(&AppendingCommandsCS);
		UE_MT_SCOPED_WRITE_ACCESS(PendingBatchCommandsDetector);
		AppendedCommandInstances.Append(MoveTemp(Other.CommandInstances));
		AppendedCommandInstances.Append(MoveTemp(Other.AppendedCommandInstances));
		ActiveCommandsCounter += Other.ActiveCommandsCounter;
		Other.ActiveCommandsCounter = 0;
	}
}

SIZE_T FMassCommandBuffer::GetAllocatedSize() const
{
	SIZE_T TotalSize = 0;
	for (const TUniquePtr<FMassBatchedCommand>& Command : CommandInstances)
	{
		TotalSize += Command ? Command->GetAllocatedSize() : 0;
	}
	for (const TUniquePtr<FMassBatchedCommand>& Command : AppendedCommandInstances)
	{
		TotalSize += Command ? Command->GetAllocatedSize() : 0;
	}

	TotalSize += CommandInstances.GetAllocatedSize();
	
	return TotalSize;
}


================================================


=== MassEntity/Private/MassDebugger.cpp ===
===========================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassDebugger.h"
#if WITH_MASSENTITY_DEBUG
#include "MassProcessor.h"
#include "MassEntityManager.h"
#include "MassEntityManagerStorage.h"
#include "MassEntitySubsystem.h"
#include "MassArchetypeTypes.h"
#include "MassArchetypeData.h"
#include "MassRequirements.h"
#include "MassEntityQuery.h"
#include "Misc/OutputDevice.h"
#include "Engine/World.h"
#include "Engine/Engine.h"
#include "MassEntityUtils.h"
#include "MassCommandBuffer.h"


namespace UE::Mass::Debug
{
	bool bAllowProceduralDebuggedEntitySelection = false;
	bool bAllowBreakOnDebuggedEntity = false;
	bool bTestSelectedEntityAgainstProcessorQueries = true;

	FAutoConsoleVariableRef CVars[] =
	{
		{ TEXT("mass.debug.AllowProceduralDebuggedEntitySelection"), bAllowProceduralDebuggedEntitySelection
			, TEXT("Guards whether MASS_SET_ENTITY_DEBUGGED calls take effect."), ECVF_Cheat}
		, {TEXT("mass.debug.AllowBreakOnDebuggedEntity"), bAllowBreakOnDebuggedEntity
			, TEXT("Guards whether MASS_BREAK_IF_ENTITY_DEBUGGED calls take effect."), ECVF_Cheat}
		, {	TEXT("mass.debug.TestSelectedEntityAgainstProcessorQueries"), bTestSelectedEntityAgainstProcessorQueries
			, TEXT("Enabling will result in testing all processors' queries against SelectedEntity (as indicated by")
			TEXT("mass.debug.DebugEntity or the gameplay debugger) and storing potential failure results to be viewed in MassDebugger")
			, ECVF_Cheat }
	};
	

	FString DebugGetFragmentAccessString(EMassFragmentAccess Access)
	{
		switch (Access)
		{
		case EMassFragmentAccess::None:	return TEXT("--");
		case EMassFragmentAccess::ReadOnly:	return TEXT("RO");
		case EMassFragmentAccess::ReadWrite:	return TEXT("RW");
		default:
			ensureMsgf(false, TEXT("Missing string conversion for EMassFragmentAccess=%d"), Access);
			break;
		}
		return TEXT("Missing string conversion");
	}

	void DebugOutputDescription(TConstArrayView<UMassProcessor*> Processors, FOutputDevice& Ar)
	{
		const bool bAutoLineEnd = Ar.GetAutoEmitLineTerminator();
		Ar.SetAutoEmitLineTerminator(false);
		for (const UMassProcessor* Proc : Processors)
		{
			if (Proc)
			{
				Proc->DebugOutputDescription(Ar);
				Ar.Logf(TEXT("\n"));
			}
			else
			{
				Ar.Logf(TEXT("NULL\n"));
			}
		}
		Ar.SetAutoEmitLineTerminator(bAutoLineEnd);
	}

	// First Id of a range of lightweight entity for which we want to activate debug information
	int32 DebugEntityBegin = INDEX_NONE;

	// Last Id of a range of lightweight entity for which we want to activate debug information
	int32 DebugEntityEnd = INDEX_NONE;

	void SetDebugEntityRange(const int32 InDebugEntityBegin, const int32 InDebugEntityEnd)
	{
		DebugEntityBegin = InDebugEntityBegin;
		DebugEntityEnd = InDebugEntityEnd;
	}

	static FAutoConsoleCommand SetDebugEntityRangeCommand(
		TEXT("mass.debug.SetDebugEntityRange"),
		TEXT("Range of lightweight entity IDs that we want to debug.")
		TEXT("Usage: \"mass.debug.SetDebugEntityRange <FirstEntity> <LastEntity>\""),
		FConsoleCommandWithArgsDelegate::CreateLambda([](const TArray<FString>& Args)
			{
				if (Args.Num() != 2)
				{
					UE_LOG(LogConsoleResponse, Display, TEXT("Error: Expecting 2 parameters"));
					return;
				}

				int32 FirstID = INDEX_NONE;
				int32 LastID = INDEX_NONE;
				if (!LexTryParseString<int32>(FirstID, *Args[0]))
				{
					UE_LOG(LogConsoleResponse, Display, TEXT("Error: first parameter must be an integer"));
					return;
				}
			
				if (!LexTryParseString<int32>(LastID, *Args[1]))
				{
					UE_LOG(LogConsoleResponse, Display, TEXT("Error: second parameter must be an integer"));
					return;
				}

				SetDebugEntityRange(FirstID, LastID);
			}));

	static FAutoConsoleCommand ResetDebugEntity(
		TEXT("mass.debug.ResetDebugEntity"),
		TEXT("Disables lightweight entities debugging.")
		TEXT("Usage: \"mass.debug.ResetDebugEntity\""),
		FConsoleCommandWithArgsDelegate::CreateLambda([](const TArray<FString>& Args)
			{
				SetDebugEntityRange(INDEX_NONE, INDEX_NONE);
			}));

	bool HasDebugEntities()
	{
		return DebugEntityBegin != INDEX_NONE && DebugEntityEnd != INDEX_NONE;
	}

	bool IsDebuggingSingleEntity()
	{
		return DebugEntityBegin != INDEX_NONE && DebugEntityBegin == DebugEntityEnd;
	}

	bool GetDebugEntitiesRange(int32& OutBegin, int32& OutEnd)
	{
		OutBegin = DebugEntityBegin;
		OutEnd = DebugEntityEnd;
		return DebugEntityBegin != INDEX_NONE && DebugEntityEnd != INDEX_NONE && DebugEntityBegin <= DebugEntityEnd;
	}
	
	bool IsDebuggingEntity(FMassEntityHandle Entity, FColor* OutEntityColor)
	{
		const int32 EntityIdx = Entity.Index;
		const bool bIsDebuggingEntity = (DebugEntityBegin != INDEX_NONE && DebugEntityEnd != INDEX_NONE && DebugEntityBegin <= EntityIdx && EntityIdx <= DebugEntityEnd);
	
		if (bIsDebuggingEntity && OutEntityColor != nullptr)
		{
			*OutEntityColor = GetEntityDebugColor(Entity);
		}

		return bIsDebuggingEntity;
	}

	FColor GetEntityDebugColor(FMassEntityHandle Entity)
	{
		const int32 EntityIdx = Entity.Index;
		return EntityIdx != INDEX_NONE ? GColorList.GetFColorByIndex(EntityIdx % GColorList.GetColorsNum()) : FColor::Black;
	}

	FAutoConsoleCommandWithWorldArgsAndOutputDevice PrintEntityFragmentsCmd(
		TEXT("mass.PrintEntityFragments"),
		TEXT("Prints all fragment types and values (uproperties) for the specified Entity index"),
		FConsoleCommandWithWorldArgsAndOutputDeviceDelegate::CreateLambda(
			[](const TArray<FString>& Params, UWorld* World, FOutputDevice& Ar)
			{
				check(World);
				if (UMassEntitySubsystem* EntityManager = World->GetSubsystem<UMassEntitySubsystem>())
				{
					int32 Index = INDEX_NONE;
					if (LexTryParseString<int32>(Index, *Params[0]))
					{
						FMassDebugger::OutputEntityDescription(Ar, EntityManager->GetEntityManager(), Index);
					}
					else
					{
						Ar.Logf(ELogVerbosity::Error, TEXT("Entity index parameter must be an integer"));
					}
				}
				else
				{
					Ar.Logf(ELogVerbosity::Error, TEXT("Failed to find MassEntitySubsystem for world %s"), *GetPathNameSafe(World));
				}
			})
	);

	FAutoConsoleCommandWithWorldArgsAndOutputDevice LogArchetypesCmd(
		TEXT("mass.LogArchetypes"),
		TEXT("Dumps description of archetypes to log. Optional parameter controls whether to include or exclude non-occupied archetypes. Defaults to 'include'."),
		FConsoleCommandWithWorldArgsAndOutputDeviceDelegate::CreateLambda([](const TArray<FString>& Params, UWorld*, FOutputDevice& Ar)
			{
				const TIndirectArray<FWorldContext>& WorldContexts = GEngine->GetWorldContexts();
				for (const FWorldContext& Context : WorldContexts)
				{
					UWorld* World = Context.World();
					if (World == nullptr || World->IsPreviewWorld())
					{
						continue;
					}

					Ar.Logf(ELogVerbosity::Log, TEXT("Dumping description of archetypes for world: %s (%s - %s)"),
						*GetPathNameSafe(World),
						LexToString(World->WorldType),
						*ToString(World->GetNetMode()));

					if (UMassEntitySubsystem* EntityManager = World->GetSubsystem<UMassEntitySubsystem>())
					{
						bool bIncludeEmpty = true;
						if (Params.Num())
						{
							LexTryParseString(bIncludeEmpty, *Params[0]);
						}
						Ar.Logf(ELogVerbosity::Log, TEXT("Include empty archetypes: %s"), bIncludeEmpty ? TEXT("TRUE") : TEXT("FALSE"));
						EntityManager->GetEntityManager().DebugGetArchetypesStringDetails(Ar, bIncludeEmpty);
					}
					else
					{
						Ar.Logf(ELogVerbosity::Error, TEXT("Failed to find MassEntitySubsystem for world: %s (%s - %s)"),
							*GetPathNameSafe(World),
							LexToString(World->WorldType),
							*ToString(World->GetNetMode()));
					}
				}
			})
	);

	// @todo these console commands will be reparented to "massentities" domain once we rename and shuffle the modules around 
	FAutoConsoleCommandWithWorld RecacheQueries(
		TEXT("mass.RecacheQueries"),
		TEXT("Forces EntityQueries to recache their valid archetypes"),
		FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* InWorld)
			{
				check(InWorld);
				if (UMassEntitySubsystem* System = InWorld->GetSubsystem<UMassEntitySubsystem>())
				{
					System->GetMutableEntityManager().DebugForceArchetypeDataVersionBump();
				}
			}
	));

	FAutoConsoleCommandWithWorldArgsAndOutputDevice LogFragmentSizes(
		TEXT("mass.LogFragmentSizes"),
		TEXT("Logs all the fragment types being used along with their sizes."),
		FConsoleCommandWithWorldArgsAndOutputDeviceDelegate::CreateLambda([](const TArray<FString>& Params, UWorld* World, FOutputDevice& Ar)
			{
				for (const TWeakObjectPtr<const UScriptStruct>& WeakStruct : FMassFragmentBitSet::DebugGetAllStructTypes())
				{
					if (const UScriptStruct* StructType = WeakStruct.Get())
					{
						Ar.Logf(ELogVerbosity::Log, TEXT("%s, size: %d"), *StructType->GetName(), StructType->GetStructureSize());
					}
				}
			})
	);

	FAutoConsoleCommandWithWorldArgsAndOutputDevice LogMemoryUsage(
		TEXT("mass.LogMemoryUsage"),
		TEXT("Logs how much memory the mass entity system uses"),
		FConsoleCommandWithWorldArgsAndOutputDeviceDelegate::CreateLambda([](const TArray<FString>& Params, UWorld* World, FOutputDevice& Ar)
			{
				check(World);
				if (UMassEntitySubsystem* System = World->GetSubsystem<UMassEntitySubsystem>())
				{
					FResourceSizeEx CumulativeResourceSize;
					System->GetResourceSizeEx(CumulativeResourceSize);
					Ar.Logf(ELogVerbosity::Log, TEXT("MassEntity system uses: %d bytes"), CumulativeResourceSize.GetDedicatedSystemMemoryBytes());
				}
			}));

	FAutoConsoleCommandWithOutputDevice LogFragments(
		TEXT("mass.LogKnownFragments"),
		TEXT("Logs all the known tags and fragments along with their \"index\" as stored via bitsets."),
		FConsoleCommandWithOutputDeviceDelegate::CreateStatic([](FOutputDevice& OutputDevice)
			{
				auto PrintKnownTypes = [&OutputDevice](TConstArrayView<TWeakObjectPtr<const UScriptStruct>> AllStructs) {
					int i = 0;
					for (TWeakObjectPtr<const UScriptStruct> Struct : AllStructs)
					{
						if (Struct.IsValid())
						{
							OutputDevice.Logf(TEXT("\t%d. %s"), i++, *Struct->GetName());
						}
					}
				};

				OutputDevice.Logf(TEXT("Known tags:"));
				PrintKnownTypes(FMassTagBitSet::DebugGetAllStructTypes());

				OutputDevice.Logf(TEXT("Known Fragments:"));
				PrintKnownTypes(FMassFragmentBitSet::DebugGetAllStructTypes());

				OutputDevice.Logf(TEXT("Known Shared Fragments:"));
				PrintKnownTypes(FMassSharedFragmentBitSet::DebugGetAllStructTypes());

				OutputDevice.Logf(TEXT("Known Chunk Fragments:"));
				PrintKnownTypes(FMassChunkFragmentBitSet::DebugGetAllStructTypes());
			}));

	static FAutoConsoleCommandWithWorldAndArgs DestroyEntity(
		TEXT("mass.debug.DestroyEntity"),
		TEXT("ID of a Mass entity that we want to destroy.")
		TEXT("Usage: \"mass.debug.DestoryEntity <Entity>\""),
		FConsoleCommandWithWorldAndArgsDelegate::CreateLambda([](const TArray<FString>& Args, UWorld* World)
	{
		if (Args.Num() != 1)
		{
			UE_LOG(LogConsoleResponse, Display, TEXT("Error: Expecting 1 parameter"));
			return;
		}

		int32 ID = INDEX_NONE;
		if (!LexTryParseString<int32>(ID, *Args[0]))
		{
			UE_LOG(LogConsoleResponse, Display, TEXT("Error: parameter must be an integer"));
			return;
		}

		if (!World)
		{
			UE_LOG(LogConsoleResponse, Display, TEXT("Error: invalid world"));
			return;
		}

		FMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(*World);
		FMassEntityHandle EntityToDestroy = EntityManager.DebugGetEntityIndexHandle(ID);
		if (!EntityToDestroy.IsSet())
		{
			UE_LOG(LogConsoleResponse, Display, TEXT("Error: cannot find entity for this index"));
			return;
		}

		EntityManager.Defer().DestroyEntity(EntityToDestroy);
	}));

	static FAutoConsoleCommandWithWorldAndArgs SetDebugEntity(
		TEXT("mass.debug.DebugEntity"),
		TEXT("ID of a Mass entity that we want to debug.")
		TEXT("Usage: \"mass.debug.DebugEntity <Entity>\""),
		FConsoleCommandWithWorldAndArgsDelegate::CreateLambda([](const TArray<FString>& Args, UWorld* World)
		{
			if (Args.Num() != 1)
			{
				UE_LOG(LogConsoleResponse, Display, TEXT("Error: Expecting 1 parameter"));
				return;
			}

			int32 ID = INDEX_NONE;
			if (!LexTryParseString<int32>(ID, *Args[0]))
			{
				UE_LOG(LogConsoleResponse, Display, TEXT("Error: parameter must be an integer"));
				return;
			}

			if (!World)
			{
				UE_LOG(LogConsoleResponse, Display, TEXT("Error: invalid world"));
				return;
			}

			SetDebugEntityRange(ID, ID);

			FMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(*World);
			FMassEntityHandle EntityToDebug = EntityManager.DebugGetEntityIndexHandle(ID);
			if (!EntityToDebug.IsSet())
			{
				UE_LOG(LogConsoleResponse, Display, TEXT("Error: cannot find entity for this index"));
				return;
			}

			FMassDebugger::SelectEntity(EntityManager, EntityToDebug);
		}
	));

} // namespace UE::Mass::Debug

//----------------------------------------------------------------------//
// FMassDebugger
//----------------------------------------------------------------------//
FMassDebugger::FOnEntitySelected FMassDebugger::OnEntitySelectedDelegate;

FMassDebugger::FOnMassEntityManagerEvent FMassDebugger::OnEntityManagerInitialized;
FMassDebugger::FOnMassEntityManagerEvent FMassDebugger::OnEntityManagerDeinitialized;
FMassDebugger::FOnDebugEvent FMassDebugger::OnDebugEvent;
TArray<FMassDebugger::FEnvironment> FMassDebugger::ActiveEnvironments;
UE::FSpinLock FMassDebugger::EntityManagerRegistrationLock;

TConstArrayView<FMassEntityQuery*> FMassDebugger::GetProcessorQueries(const UMassProcessor& Processor)
{
	return Processor.OwnedQueries;
}

TConstArrayView<FMassEntityQuery*> FMassDebugger::GetUpToDateProcessorQueries(const FMassEntityManager& EntityManager, UMassProcessor& Processor)
{
	for (FMassEntityQuery* Query : Processor.OwnedQueries)
	{
		if (Query)
		{
			Query->CacheArchetypes(EntityManager);
		}
	}

	return Processor.OwnedQueries;
}

UE::Mass::Debug::FQueryRequirementsView FMassDebugger::GetQueryRequirements(const FMassEntityQuery& Query)
{
	UE::Mass::Debug::FQueryRequirementsView View = { Query.FragmentRequirements, Query.ChunkFragmentRequirements, Query.ConstSharedFragmentRequirements, Query.SharedFragmentRequirements
		, Query.RequiredAllTags, Query.RequiredAnyTags, Query.RequiredNoneTags, Query.RequiredOptionalTags
		, Query.RequiredConstSubsystems, Query.RequiredMutableSubsystems };

	return View;
}

void FMassDebugger::GetQueryExecutionRequirements(const FMassEntityQuery& Query, FMassExecutionRequirements& OutExecutionRequirements)
{
	Query.ExportRequirements(OutExecutionRequirements);
}

TArray<FMassArchetypeHandle> FMassDebugger::GetAllArchetypes(const FMassEntityManager& EntityManager)
{
	TArray<FMassArchetypeHandle> Archetypes;

	for (auto& KVP : EntityManager.FragmentHashToArchetypeMap)
	{
		for (const TSharedPtr<FMassArchetypeData>& Archetype : KVP.Value)
		{
			Archetypes.Add(FMassArchetypeHelper::ArchetypeHandleFromData(Archetype));
		}
	}

	return Archetypes;
}

const FMassArchetypeCompositionDescriptor& FMassDebugger::GetArchetypeComposition(const FMassArchetypeHandle& ArchetypeHandle)
{
	const FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);
	return ArchetypeData.CompositionDescriptor;
}

void FMassDebugger::GetArchetypeEntityStats(const FMassArchetypeHandle& ArchetypeHandle, UE::Mass::Debug::FArchetypeStats& OutStats)
{
	const FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);
	OutStats.EntitiesCount = ArchetypeData.GetNumEntities();
	OutStats.EntitiesCountPerChunk = ArchetypeData.GetNumEntitiesPerChunk();
	OutStats.ChunksCount = ArchetypeData.GetChunkCount();
	OutStats.AllocatedSize = ArchetypeData.GetAllocatedSize();
	OutStats.BytesPerEntity = ArchetypeData.GetBytesPerEntity();

	SIZE_T ActiveChunksMemorySize = 0;
	SIZE_T ActiveEntitiesMemorySize = 0;
	ArchetypeData.DebugGetEntityMemoryNumbers(ActiveChunksMemorySize, ActiveEntitiesMemorySize);
	OutStats.WastedEntityMemory = ActiveChunksMemorySize - ActiveEntitiesMemorySize;
}

const TConstArrayView<FName> FMassDebugger::GetArchetypeDebugNames(const FMassArchetypeHandle& ArchetypeHandle)
{
	const FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);
	return ArchetypeData.GetDebugNames();
}

TConstArrayView<struct UMassCompositeProcessor::FDependencyNode> FMassDebugger::GetProcessingGraph(const UMassCompositeProcessor& GraphOwner)
{
	return GraphOwner.FlatProcessingGraph;
}

TConstArrayView<TObjectPtr<UMassProcessor>> FMassDebugger::GetHostedProcessors(const UMassCompositeProcessor& GraphOwner)
{
	return GraphOwner.ChildPipeline.GetProcessors();
}

FString FMassDebugger::GetRequirementsDescription(const FMassFragmentRequirements& Requirements)
{
	TStringBuilder<256> StringBuilder;
	StringBuilder.Append(TEXT("<"));

	bool bNeedsComma = false;
	for (const FMassFragmentRequirementDescription& Requirement : Requirements.FragmentRequirements)
	{
		if (bNeedsComma)
		{
			StringBuilder.Append(TEXT(","));
		}
		StringBuilder.Append(*FMassDebugger::GetSingleRequirementDescription(Requirement));
		bNeedsComma = true;
	}

	StringBuilder.Append(TEXT(">"));
	return StringBuilder.ToString();
}

FString FMassDebugger::GetArchetypeRequirementCompatibilityDescription(const FMassFragmentRequirements& Requirements, const FMassArchetypeHandle& ArchetypeHandle)
{
	if (ArchetypeHandle.IsValid() == false)
	{
		return TEXT("Invalid");
	}

	const FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);
	return FMassDebugger::GetArchetypeRequirementCompatibilityDescription(Requirements, ArchetypeData.GetCompositionDescriptor());
}
	
FString FMassDebugger::GetArchetypeRequirementCompatibilityDescription(const FMassFragmentRequirements& Requirements, const FMassArchetypeCompositionDescriptor& ArchetypeComposition)
{
	FStringOutputDevice OutDescription;

	if (Requirements.HasNegativeRequirements())
	{
		if (ArchetypeComposition.Fragments.HasNone(Requirements.RequiredNoneFragments) == false)
		{
			// has some of the fragments required absent
			OutDescription += TEXT("\nHas fragments required absent: ");
			(Requirements.RequiredNoneFragments & ArchetypeComposition.Fragments).DebugGetStringDesc(OutDescription);
		}

		if (ArchetypeComposition.Tags.HasNone(Requirements.RequiredNoneTags) == false)
		{
			// has some of the tags required absent
			OutDescription += TEXT("\nHas tags required absent: ");
			(Requirements.RequiredNoneTags & ArchetypeComposition.Tags).DebugGetStringDesc(OutDescription);
		}

		if (ArchetypeComposition.ChunkFragments.HasNone(Requirements.RequiredNoneChunkFragments) == false)
		{
			// has some of the chunk fragments required absent
			OutDescription += TEXT("\nHas chunk fragments required absent: ");
			(Requirements.RequiredNoneChunkFragments & ArchetypeComposition.ChunkFragments).DebugGetStringDesc(OutDescription);
		}

		if (ArchetypeComposition.SharedFragments.HasNone(Requirements.RequiredNoneSharedFragments) == false)
		{
			// has some of the chunk fragments required absent
			OutDescription += TEXT("\nHas shared fragments required absent: ");
			(Requirements.RequiredNoneSharedFragments & ArchetypeComposition.SharedFragments).DebugGetStringDesc(OutDescription);
		}

		if (ArchetypeComposition.ConstSharedFragments.HasNone(Requirements.RequiredNoneConstSharedFragments) == false)
		{
			// has some of the chunk fragments required absent
			OutDescription += TEXT("\nHas shared fragments required absent: ");
			(Requirements.RequiredNoneConstSharedFragments & ArchetypeComposition.ConstSharedFragments).DebugGetStringDesc(OutDescription);
		}
	}

	// if we have regular (i.e. non-optional) positive requirements then these are the determining factor, we don't check optionals
	if (Requirements.HasPositiveRequirements())
	{
		if (ArchetypeComposition.Fragments.HasAll(Requirements.RequiredAllFragments) == false)
		{
			// missing one of the strictly required fragments
			OutDescription += TEXT("\nMissing required fragments: ");
			(Requirements.RequiredAllFragments - ArchetypeComposition.Fragments).DebugGetStringDesc(OutDescription);
		}

		if (Requirements.RequiredAnyFragments.IsEmpty() == false && ArchetypeComposition.Fragments.HasAny(Requirements.RequiredAnyFragments) == false)
		{
			// missing all of the "any" fragments
			OutDescription += TEXT("\nMissing all \'any\' fragments: ");
			Requirements.RequiredAnyFragments.DebugGetStringDesc(OutDescription);
		}

		if (ArchetypeComposition.Tags.HasAll(Requirements.RequiredAllTags) == false)
		{
			// missing one of the strictly required tags
			OutDescription += TEXT("\nMissing required tags: ");
			(Requirements.RequiredAllTags - ArchetypeComposition.Tags).DebugGetStringDesc(OutDescription);
		}

		if (Requirements.RequiredAnyTags.IsEmpty() == false && ArchetypeComposition.Tags.HasAny(Requirements.RequiredAnyTags) == false)
		{
			// missing all of the "any" tags
			OutDescription += TEXT("\nMissing all \'any\' tags: ");
			Requirements.RequiredAnyTags.DebugGetStringDesc(OutDescription);
		}

		if (ArchetypeComposition.ChunkFragments.HasAll(Requirements.RequiredAllChunkFragments) == false)
		{
			// missing one of the strictly required chunk fragments
			OutDescription += TEXT("\nMissing required chunk fragments: ");
			(Requirements.RequiredAllChunkFragments - ArchetypeComposition.ChunkFragments).DebugGetStringDesc(OutDescription);
		}

		if (ArchetypeComposition.SharedFragments.HasAll(Requirements.RequiredAllSharedFragments) == false)
		{
			// missing one of the strictly required Shared fragments
			OutDescription += TEXT("\nMissing required Shared fragments: ");
			(Requirements.RequiredAllSharedFragments - ArchetypeComposition.SharedFragments).DebugGetStringDesc(OutDescription);
		}

		if (ArchetypeComposition.ConstSharedFragments.HasAll(Requirements.RequiredAllConstSharedFragments) == false)
		{
			// missing one of the strictly required Shared fragments
			OutDescription += TEXT("\nMissing required Shared fragments: ");
			(Requirements.RequiredAllConstSharedFragments - ArchetypeComposition.ConstSharedFragments).DebugGetStringDesc(OutDescription);
		}
	}
	// else we check if there are any optionals and if so test them
	else if (Requirements.HasOptionalRequirements() && (Requirements.DoesMatchAnyOptionals(ArchetypeComposition) == false))
	{
		// we report that none of the optionals has been met
		OutDescription += TEXT("\nNone of the optionals were safisfied while not having other positive hard requirements: ");

		Requirements.RequiredOptionalTags.DebugGetStringDesc(OutDescription);
		Requirements.RequiredOptionalFragments.DebugGetStringDesc(OutDescription);
		Requirements.RequiredOptionalChunkFragments.DebugGetStringDesc(OutDescription);
		Requirements.RequiredOptionalSharedFragments.DebugGetStringDesc(OutDescription);
		Requirements.RequiredOptionalConstSharedFragments.DebugGetStringDesc(OutDescription);
	}

	return OutDescription.Len() > 0 ? static_cast<FString>(OutDescription) : TEXT("Match");
}

FString FMassDebugger::GetSingleRequirementDescription(const FMassFragmentRequirementDescription& Requirement)
{
	return FString::Printf(TEXT("%s%s[%s]"), Requirement.IsOptional() ? TEXT("?") : (Requirement.Presence == EMassFragmentPresence::None ? TEXT("-") : TEXT("+"))
		, *GetNameSafe(Requirement.StructType), *UE::Mass::Debug::DebugGetFragmentAccessString(Requirement.AccessMode));
}

void FMassDebugger::OutputArchetypeDescription(FOutputDevice& Ar, const FMassArchetypeHandle& ArchetypeHandle)
{
	Ar.Logf(TEXT("%s"), ArchetypeHandle.IsValid() ? *FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle).DebugGetDescription() : TEXT("INVALID"));
}

void FMassDebugger::OutputEntityDescription(FOutputDevice& Ar, const FMassEntityManager& EntityManager, const int32 EntityIndex, const TCHAR* InPrefix)
{
	if (EntityIndex >= EntityManager.DebugGetEntityStorageInterface().Num())
	{
		Ar.Logf(ELogVerbosity::Log, TEXT("Unable to list fragments values for out of range index in EntityManager owned by %s"), *GetPathNameSafe(EntityManager.GetOwner()));
		return;
	}
	
	if (!EntityManager.DebugGetEntityStorageInterface().IsValid(EntityIndex))
	{
		Ar.Logf(ELogVerbosity::Log, TEXT("Unable to list fragments values for invalid entity in EntityManager owned by %s"), *GetPathNameSafe(EntityManager.GetOwner()));
	}
	
	FMassEntityHandle Entity;
	Entity.Index = EntityIndex;
	Entity.SerialNumber = EntityManager.DebugGetEntityStorageInterface().GetSerialNumber(EntityIndex);
	OutputEntityDescription(Ar, EntityManager, Entity, InPrefix);
}

void FMassDebugger::OutputEntityDescription(FOutputDevice& Ar, const FMassEntityManager& EntityManager, const FMassEntityHandle Entity, const TCHAR* InPrefix)
{
	if (!EntityManager.IsEntityActive(Entity))
	{
		Ar.Logf(ELogVerbosity::Log, TEXT("Unable to list fragments values for invalid entity in EntityManager owned by %s"), *GetPathNameSafe(EntityManager.GetOwner()));
	}

	Ar.Logf(ELogVerbosity::Log, TEXT("Listing fragments values for Entity[%s] in EntityManager owned by %s"), *Entity.DebugGetDescription(), *GetPathNameSafe(EntityManager.GetOwner()));

	FMassArchetypeData* Archetype = EntityManager.DebugGetEntityStorageInterface().GetArchetypeAsShared(Entity.Index).Get();
	if (Archetype == nullptr)
	{
		Ar.Logf(ELogVerbosity::Log, TEXT("Unable to list fragments values for invalid entity in EntityManager owned by %s"), *GetPathNameSafe(EntityManager.GetOwner()));
	}
	else
	{
		Archetype->DebugPrintEntity(Entity, Ar, InPrefix);
	}
}

void FMassDebugger::SelectEntity(const FMassEntityManager& EntityManager, const FMassEntityHandle EntityHandle)
{
	UE::Mass::Debug::SetDebugEntityRange(EntityHandle.Index, EntityHandle.Index);

	const int32 Index = ActiveEnvironments.IndexOfByPredicate([WeakManager = EntityManager.AsWeak()](const FEnvironment& Element)
		{
			return Element.EntityManager == WeakManager;
		});
	if (ensure(Index != INDEX_NONE))
	{
		ActiveEnvironments[Index].SelectedEntity = EntityHandle;
	}

	OnEntitySelectedDelegate.Broadcast(EntityManager, EntityHandle);
}

FMassEntityHandle FMassDebugger::GetSelectedEntity(const FMassEntityManager& EntityManager)
{
	const int32 Index = ActiveEnvironments.IndexOfByPredicate([WeakManager = EntityManager.AsWeak()](const FEnvironment& Element)
		{
			return Element.EntityManager == WeakManager;
		});

	return Index != INDEX_NONE ? ActiveEnvironments[Index].SelectedEntity : FMassEntityHandle();
}

void FMassDebugger::RegisterEntityManager(FMassEntityManager& EntityManager)
{
	UE::TScopeLock<UE::FSpinLock> ScopeLock(EntityManagerRegistrationLock);

	ActiveEnvironments.Emplace(EntityManager);
	OnEntityManagerInitialized.Broadcast(EntityManager);
}

void FMassDebugger::UnregisterEntityManager(FMassEntityManager& EntityManager)
{
	UE::TScopeLock<UE::FSpinLock> ScopeLock(EntityManagerRegistrationLock);

	if (EntityManager.DoesSharedInstanceExist())
	{
		const int32 Index = ActiveEnvironments.IndexOfByPredicate([WeakManager = EntityManager.AsWeak()](const FEnvironment& Element) 
		{
			return Element.EntityManager == WeakManager;
		});
		if (Index != INDEX_NONE)
		{
			ActiveEnvironments.RemoveAt(Index, EAllowShrinking::No);
		}
	}
	else
	{
		ActiveEnvironments.RemoveAll([](const FEnvironment& Item)
			{
				return Item.IsValid() == false;
			});
	}
	OnEntityManagerDeinitialized.Broadcast(EntityManager);
}

bool FMassDebugger::DoesArchetypeMatchRequirements(const FMassArchetypeHandle& ArchetypeHandle, const FMassFragmentRequirements& Requirements, FOutputDevice& OutputDevice)
{
	if (const FMassArchetypeData* Archetype = FMassArchetypeHelper::ArchetypeDataFromHandle(ArchetypeHandle))
	{
		return FMassArchetypeHelper::DoesArchetypeMatchRequirements(*Archetype, Requirements, /*bBailOutOnFirstFail=*/false, &OutputDevice);
	}
	return false;
}

#endif // WITH_MASSENTITY_DEBUG
===========================================


=== MassEntity/Private/MassEntityManager.cpp ===
================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEntityManager.h"
#include "MassEntityManagerConstants.h"
#include "MassArchetypeData.h"
#include "MassCommandBuffer.h"
#include "MassEntityManagerStorage.h"
#include "Engine/World.h"
#include "UObject/UObjectIterator.h"
#include "VisualLogger/VisualLogger.h"
#include "MassExecutionContext.h"
#include "MassDebugger.h"
#include "Misc/Fork.h"
#include "Misc/CoreDelegates.h"
#include "Algo/Find.h"
#include "MassEntityUtils.h"

const FMassEntityHandle FMassEntityManager::InvalidEntity;

namespace UE::Mass::Private
{
	// note: this function doesn't set EntityHandle.SerialNumber
	void ConvertArchetypelessSubchunksIntoEntityHandles(FMassArchetypeEntityCollection::FConstEntityRangeArrayView Subchunks, TArray<FMassEntityHandle>& OutEntityHandles)
	{
		int32 TotalCount = 0;
		for (const FMassArchetypeEntityCollection::FArchetypeEntityRange& Subchunk : Subchunks)
		{
			TotalCount += Subchunk.Length;
		}

		int32 Index = OutEntityHandles.Num();
		OutEntityHandles.AddDefaulted(TotalCount);

		for (const FMassArchetypeEntityCollection::FArchetypeEntityRange& Subchunk : Subchunks)
		{
			for (int i = Subchunk.SubchunkStart; i < Subchunk.SubchunkStart + Subchunk.Length; ++i)
			{
				OutEntityHandles[Index++].Index = i;
			}
		}
	}
}

//-----------------------------------------------------------------------------
// FMassEntityManager::FEntityCreationContext
//-----------------------------------------------------------------------------
FMassEntityManager::FEntityCreationContext::FEntityCreationContext()
	: OwnerThreadId(FPlatformTLS::GetCurrentThreadId())
{	
}

FMassEntityManager::FEntityCreationContext::FEntityCreationContext(FMassEntityManager& InManager, const TConstArrayView<FMassEntityHandle> InCreatedEntities)
	: FEntityCreationContext()
{
	CreatedEntities = InCreatedEntities;
	Manager = InManager.AsShared();
}

FMassEntityManager::FEntityCreationContext::FEntityCreationContext(FMassEntityManager& InManager, const TConstArrayView<FMassEntityHandle> InCreatedEntities
	, FMassArchetypeEntityCollection&& InEntityCollection)
	: FEntityCreationContext(InManager, InCreatedEntities)
{
	checkf(InCreatedEntities.IsEmpty() || InEntityCollection.IsEmpty() == false, TEXT("Trying to create FEntityCreationContext instance with no entities but non-empty entity collection. This is not supported."))
	if (InCreatedEntities.IsEmpty() == false)
	{
		EntityCollections.Add(MoveTemp(InEntityCollection));
	}
}

FMassEntityManager::FEntityCreationContext::~FEntityCreationContext()
{
	if (((EntityCollections.IsEmpty() == false) || (CreatedEntities.IsEmpty() == false)) && ensure(Manager))
	{
		Manager->GetObserverManager().OnPostEntitiesCreated(GetEntityCollections());
	}
}

TConstArrayView<FMassArchetypeEntityCollection> FMassEntityManager::FEntityCreationContext::GetEntityCollections() const
{
	// the EntityCollection has been dirtied, we need to rebuild it
	if (IsDirty() && ensure(Manager))
	{
		UE::Mass::Utils::CreateEntityCollections(*Manager.Get(), CreatedEntities, CollectionCreationDuplicatesHandling, EntityCollections);
	}

	return EntityCollections;
}

void FMassEntityManager::FEntityCreationContext::MarkDirty()
{
	checkf(OwnerThreadId == FPlatformTLS::GetCurrentThreadId(), TEXT("%hs: all FEntityCreationContext operations ere expected to be run in a single thread"), __FUNCTION__);

	EntityCollections.Reset();
}

void FMassEntityManager::FEntityCreationContext::AppendEntities(const TConstArrayView<FMassEntityHandle> EntitiesToAppend)
{
	checkf(OwnerThreadId == FPlatformTLS::GetCurrentThreadId(), TEXT("%hs: all FEntityCreationContext operations ere expected to be run in a single thread"), __FUNCTION__);

	if (EntitiesToAppend.Num())
	{
		if (CreatedEntities.Num())
		{
			// since we already have entities in CreatedEntities (initially ensured to have no duplicates) we cannot 
			// guarantee anymore that we'll have no duplicates after adding EntitiesToAppend
			CollectionCreationDuplicatesHandling = FMassArchetypeEntityCollection::FoldDuplicates;
			MarkDirty();
		}
		// else, if there are no entities the resulting state will be "dirty" by design
		ensureMsgf(EntityCollections.IsEmpty(), TEXT("Having a non-empty array of entity collections is unexpected at this point!"));

		CreatedEntities.Append(EntitiesToAppend);
		ensure(IsDirty());
	}
}

void FMassEntityManager::FEntityCreationContext::AppendEntities(const TConstArrayView<FMassEntityHandle> EntitiesToAppend, FMassArchetypeEntityCollection&& InEntityCollection)
{
	checkf(OwnerThreadId == FPlatformTLS::GetCurrentThreadId(), TEXT("%hs: all FEntityCreationContext operations ere expected to be run in a single thread"), __FUNCTION__);

	if (EntitiesToAppend.Num() == 0)
	{
		return;
	}
	
	AppendEntities(EntitiesToAppend);

	// this condition boils down to checking if this FEntityCreationContext instance only connects the just added EntitiesToAppend
	if (CreatedEntities.Num() == EntitiesToAppend.Num())
	{
		checkf(EntityCollections.Num() == 0, TEXT("We never expect EntityCollections to be non-empty while there are no entities in CreatedEntities."));
		EntityCollections.Add(MoveTemp(InEntityCollection));
	}
}

void FMassEntityManager::FEntityCreationContext::ForceUpdateCurrentThreadID()
{
	OwnerThreadId = FPlatformTLS::GetCurrentThreadId();
}

//-----------------------------------------------------------------------------
// FMassEntityManager
//-----------------------------------------------------------------------------
#if MASS_CONCURRENT_RESERVE
UE::Mass::IEntityStorageInterface& FMassEntityManager::GetEntityStorageInterface()
{
	using namespace UE::Mass;
	struct StorageSelector
	{
		UE::Mass::IEntityStorageInterface* operator()(FEmptyVariantState&) const
		{
			checkf(false, TEXT("Attempt to use EntityStorageInterface without initialization"));
			return nullptr;
		}
		UE::Mass::IEntityStorageInterface* operator()(FSingleThreadedEntityStorage& Storage) const
		{
			return &Storage;
		}
		UE::Mass::IEntityStorageInterface* operator()(FConcurrentEntityStorage& Storage) const
		{
			return &Storage;
		}
	};

	UE::Mass::IEntityStorageInterface* Interface = Visit(StorageSelector{}, EntityStorage);

	return *Interface;
}

const UE::Mass::IEntityStorageInterface& FMassEntityManager::GetEntityStorageInterface() const
{
	using namespace UE::Mass;
	struct StorageSelector
	{
		const UE::Mass::IEntityStorageInterface* operator()(const FEmptyVariantState&) const
		{
			checkf(false, TEXT("Attempt to use EntityStorageInterface without initialization"));
			return nullptr;
		}
		const UE::Mass::IEntityStorageInterface* operator()(const FSingleThreadedEntityStorage& Storage) const
		{
			return &Storage;
		}
		const UE::Mass::IEntityStorageInterface* operator()(const FConcurrentEntityStorage& Storage) const
		{
			return &Storage;
		}
	};

	const UE::Mass::IEntityStorageInterface* Interface = Visit(StorageSelector{}, EntityStorage);

	return *Interface;
}
#else
UE::Mass::FSingleThreadedEntityStorage& FMassEntityManager::GetEntityStorageInterface()
{
	// Get will assert if not initialized
	return EntityStorage.Get<UE::Mass::FSingleThreadedEntityStorage>();
}

const UE::Mass::FSingleThreadedEntityStorage& FMassEntityManager::GetEntityStorageInterface() const
{
	// Get will assert if not initialized
	return EntityStorage.Get<UE::Mass::FSingleThreadedEntityStorage>();
}
#endif

#if WITH_MASSENTITY_DEBUG
UE::Mass::IEntityStorageInterface& FMassEntityManager::DebugGetEntityStorageInterface()
{
	return GetEntityStorageInterface();
}

const UE::Mass::IEntityStorageInterface& FMassEntityManager::DebugGetEntityStorageInterface() const
{
	return GetEntityStorageInterface();
}
#endif

//-----------------------------------------------------------------------------
// FMassEntityManager
//-----------------------------------------------------------------------------
FMassEntityManager::FMassEntityManager(UObject* InOwner)
	: ObserverManager(*this)
	, Owner(InOwner)
{
#if WITH_MASSENTITY_DEBUG
	DebugName = InOwner ? (InOwner->GetName() + TEXT("_EntityManager")) : TEXT("Unset");
#endif
}

FMassEntityManager::~FMassEntityManager()
{
	if (bInitialized)
	{
		Deinitialize();
	}
}

void FMassEntityManager::GetResourceSizeEx(FResourceSizeEx& CumulativeResourceSize)
{
	SIZE_T MyExtraSize = GetEntityStorageInterface().GetAllocatedSize()
		+ FragmentHashToArchetypeMap.GetAllocatedSize()
		+ FragmentTypeToArchetypeMap.GetAllocatedSize();

	for (const TSharedPtr<FMassCommandBuffer>& CommandBuffer : DeferredCommandBuffers)
	{
		MyExtraSize += (CommandBuffer ? CommandBuffer->GetAllocatedSize() : 0);
	}
	
	CumulativeResourceSize.AddDedicatedSystemMemoryBytes(MyExtraSize);

	for (const auto& KVP : FragmentHashToArchetypeMap)
	{
		for (const TSharedPtr<FMassArchetypeData>& ArchetypePtr : KVP.Value)
		{
			CumulativeResourceSize.AddDedicatedSystemMemoryBytes(ArchetypePtr->GetAllocatedSize());
		}
	}
}

void FMassEntityManager::AddReferencedObjects(FReferenceCollector& Collector)
{
	for (FConstSharedStruct& Struct : ConstSharedFragments)
	{
		Struct.AddStructReferencedObjects(Collector);
	}

	for (FSharedStruct& Struct : SharedFragments)
	{
		Struct.AddStructReferencedObjects(Collector);
	}
 
	const class UScriptStruct* ScriptStruct = FMassObserverManager::StaticStruct();
	TWeakObjectPtr<const UScriptStruct> ScriptStructPtr{ScriptStruct};
	Collector.AddReferencedObjects(ScriptStructPtr, &ObserverManager);
}

void FMassEntityManager::Initialize()
{
	FMassEntityManagerStorageInitParams InitializationParams;
	InitializationParams.Emplace<FMassEntityManager_InitParams_SingleThreaded>();
	Initialize(InitializationParams);
}

namespace UE::Mass::Private
{
	struct FEntityStorageInitializer
	{
		void operator()(const FMassEntityManager_InitParams_SingleThreaded& Params)
		{
			EntityStorage->Emplace<UE::Mass::FSingleThreadedEntityStorage>();
			EntityStorage->Get<FSingleThreadedEntityStorage>().Initialize(Params);
		}
		void operator()(const FMassEntityManager_InitParams_Concurrent& Params)
		{
#if MASS_CONCURRENT_RESERVE
			EntityStorage->Emplace<UE::Mass::FConcurrentEntityStorage>();
			EntityStorage->Get<UE::Mass::FConcurrentEntityStorage>().Initialize(Params);
#else
			checkf(false, TEXT("Mass does not support this storage backend"));
#endif
		}
		
		FMassEntityManager::FEntityStorageContainerType* EntityStorage = nullptr;
	};
}

void FMassEntityManager::Initialize(const FMassEntityManagerStorageInitParams& InitializationParams)
{
	if (bInitialized)
	{
		UE_LOG(LogMass, Log, TEXT("Calling %hs on already initialized entity manager owned by %s")
			, __FUNCTION__, *GetNameSafe(Owner.Get()));
		return;
	}

	Visit(UE::Mass::Private::FEntityStorageInitializer{&EntityStorage}, InitializationParams);

	for (TSharedPtr<FMassCommandBuffer>& CommandBuffer : DeferredCommandBuffers)
	{
		CommandBuffer = MakeShareable(new FMassCommandBuffer());
	}

	// if we get forked we need to update the command buffer's CurrentThreadID
	if (FForkProcessHelper::IsForkRequested())
	{
		OnPostForkHandle = FCoreDelegates::OnPostFork.AddSP(AsShared(), &FMassEntityManager::OnPostFork);
	}

	// creating these bitset instances to populate respective bitset types' StructTrackers
	FMassFragmentBitSet Fragments;
	FMassTagBitSet Tags;
	FMassChunkFragmentBitSet ChunkFragments;
	FMassSharedFragmentBitSet LocalSharedFragments;

	for (TObjectIterator<UScriptStruct> StructIt; StructIt; ++StructIt)
	{
		if (StructIt->IsChildOf(FMassFragment::StaticStruct()))
		{
			if (*StructIt != FMassFragment::StaticStruct())
			{
				Fragments.Add(**StructIt);
			}
		}
		else if (StructIt->IsChildOf(FMassTag::StaticStruct()))
		{
			if (*StructIt != FMassTag::StaticStruct())
			{
				Tags.Add(**StructIt);
			}
		}
		else if (StructIt->IsChildOf(FMassChunkFragment::StaticStruct()))
		{
			if (*StructIt != FMassChunkFragment::StaticStruct())
			{
				ChunkFragments.Add(**StructIt);
			}
		}
		else if (StructIt->IsChildOf(FMassSharedFragment::StaticStruct()))
		{
			if (*StructIt != FMassSharedFragment::StaticStruct())
			{
				LocalSharedFragments.Add(**StructIt);
			}
		}
	}
#if WITH_MASSENTITY_DEBUG
	RequirementAccessDetector.Initialize();
	FMassDebugger::RegisterEntityManager(*this);
#endif // WITH_MASSENTITY_DEBUG

	bInitialized = true;
	bFirstCommandFlush = true;
}

void FMassEntityManager::PostInitialize()
{
	ensure(bInitialized);
	// this needs to be done after all the subsystems have been initialized since some processors might want to access
	// them during processors' initialization
	ObserverManager.Initialize();
}

void FMassEntityManager::Deinitialize()
{
	if (bInitialized)
	{
		FCoreDelegates::OnPostFork.Remove(OnPostForkHandle);

		// closing down so no point in actually flushing commands, but need to clean them up to avoid warnings on destruction
		for (TSharedPtr<FMassCommandBuffer>& CommandBuffer : DeferredCommandBuffers)
		{
			if (CommandBuffer)
			{
				CommandBuffer->CleanUp();
			}
		}

#if WITH_MASSENTITY_DEBUG
		FMassDebugger::UnregisterEntityManager(*this);
#endif // WITH_MASSENTITY_DEBUG

		EntityStorage.Emplace<FEmptyVariantState>();

		ObserverManager.DeInitialize();
		
		bInitialized = false;
	}
	else
	{
		UE_LOG(LogMass, Log, TEXT("Calling %hs on already deinitialized entity manager owned by %s")
			, __FUNCTION__, *GetNameSafe(Owner.Get()));
	}
}

void FMassEntityManager::OnPostFork(EForkProcessRole Role)
{
	if (Role == EForkProcessRole::Child)
	{
		for (TSharedPtr<FMassCommandBuffer>& CommandBuffer : DeferredCommandBuffers)
		{
			if (CommandBuffer)
			{
				CommandBuffer->ForceUpdateCurrentThreadID();
			}
			else
			{
				CommandBuffer = MakeShareable(new FMassCommandBuffer());
			}
		}

		if (TSharedPtr<FEntityCreationContext> ActiveContext = ActiveCreationContext.Pin())
		{
			ActiveContext->ForceUpdateCurrentThreadID();
		}
	}
}

FMassArchetypeHandle FMassEntityManager::CreateArchetype(TConstArrayView<const UScriptStruct*> FragmentsAndTagsList, const FMassArchetypeCreationParams& CreationParams)
{
	FMassArchetypeCompositionDescriptor Composition;
	InternalAppendFragmentsAndTagsToArchetypeCompositionDescriptor(Composition, FragmentsAndTagsList);
	return CreateArchetype(Composition, CreationParams);
}

FMassArchetypeHandle FMassEntityManager::CreateArchetype(FMassArchetypeHandle SourceArchetype, TConstArrayView<const UScriptStruct*> FragmentsAndTagsList)
{
	const FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(SourceArchetype); 
	return CreateArchetype(SourceArchetype, FragmentsAndTagsList, FMassArchetypeCreationParams(ArchetypeData));
}

FMassArchetypeHandle FMassEntityManager::CreateArchetype(FMassArchetypeHandle SourceArchetype,
	TConstArrayView<const UScriptStruct*> FragmentsAndTagsList, const FMassArchetypeCreationParams& CreationParams)
{
	const FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(SourceArchetype);
	FMassArchetypeCompositionDescriptor Composition = ArchetypeData.GetCompositionDescriptor();
	InternalAppendFragmentsAndTagsToArchetypeCompositionDescriptor(Composition, FragmentsAndTagsList);
	return CreateArchetype(Composition, CreationParams);
}

FMassArchetypeHandle FMassEntityManager::CreateArchetype(const TSharedPtr<FMassArchetypeData>& SourceArchetype, const FMassFragmentBitSet& AddedFragments)
{
	return CreateArchetype(SourceArchetype, AddedFragments, FMassArchetypeCreationParams(*SourceArchetype));
}

FMassArchetypeHandle FMassEntityManager::CreateArchetype(const TSharedPtr<FMassArchetypeData>& SourceArchetype, const FMassFragmentBitSet& AddedFragments, const FMassArchetypeCreationParams& CreationParams)
{
	check(SourceArchetype.IsValid());
	checkf(AddedFragments.IsEmpty() == false, TEXT("%hs Adding an empty fragment list to an archetype is not supported."), __FUNCTION__);

	const FMassArchetypeCompositionDescriptor Composition(AddedFragments + SourceArchetype->GetFragmentBitSet()
		, SourceArchetype->GetTagBitSet()
		, SourceArchetype->GetChunkFragmentBitSet()
		, SourceArchetype->GetSharedFragmentBitSet()
		, SourceArchetype->GetConstSharedFragmentBitSet());
	return CreateArchetype(Composition, CreationParams);
}

FMassArchetypeHandle FMassEntityManager::GetOrCreateSuitableArchetype(const FMassArchetypeHandle& ArchetypeHandle
	, const FMassSharedFragmentBitSet& SharedFragmentBitSet
	, const FMassConstSharedFragmentBitSet& ConstSharedFragmentBitSet
	, const FMassArchetypeCreationParams& CreationParams)
{
	const FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);
	if (SharedFragmentBitSet != ArchetypeData.GetSharedFragmentBitSet()
		|| ConstSharedFragmentBitSet != ArchetypeData.GetConstSharedFragmentBitSet())
	{
		FMassArchetypeCompositionDescriptor NewDescriptor = ArchetypeData.GetCompositionDescriptor();
		NewDescriptor.SharedFragments = SharedFragmentBitSet;
		NewDescriptor.ConstSharedFragments = ConstSharedFragmentBitSet;
		return CreateArchetype(NewDescriptor);
	}
	return ArchetypeHandle;
}

FMassArchetypeHandle FMassEntityManager::CreateArchetype(const FMassArchetypeCompositionDescriptor& Composition, const FMassArchetypeCreationParams& CreationParams)
{
	const uint32 TypeHash = Composition.CalculateHash();

	TArray<TSharedPtr<FMassArchetypeData>>& HashRow = FragmentHashToArchetypeMap.FindOrAdd(TypeHash);

	TSharedPtr<FMassArchetypeData> ArchetypeDataPtr;
	for (const TSharedPtr<FMassArchetypeData>& Ptr : HashRow)
	{
		if (Ptr->IsEquivalent(Composition))
		{
#if WITH_MASSENTITY_DEBUG
			// Keep track of all names for this archetype.
			if (!CreationParams.DebugName.IsNone())
			{
				Ptr->AddUniqueDebugName(CreationParams.DebugName);
			}
#endif // WITH_MASSENTITY_DEBUG
			if (CreationParams.ChunkMemorySize > 0 && CreationParams.ChunkMemorySize != Ptr->GetChunkAllocSize())
			{
				UE_LOG(LogMass, Warning, TEXT("Reusing existing Archetype, but the requested ChunkMemorySize is different. Requested %d, existing: %llu")
					, CreationParams.ChunkMemorySize, Ptr->GetChunkAllocSize());
			}
			ArchetypeDataPtr = Ptr;
			break;
		}
	}

	if (!ArchetypeDataPtr.IsValid())
	{
		// Important to pre-increment the version as the queries will use this value to do incremental updates
		++ArchetypeDataVersion;

		// Create a new archetype
		FMassArchetypeData* NewArchetype = new FMassArchetypeData(CreationParams);
		NewArchetype->Initialize(Composition, ArchetypeDataVersion);
		ArchetypeDataPtr = HashRow.Add_GetRef(MakeShareable(NewArchetype));
		AllArchetypes.Add(ArchetypeDataPtr);
		ensure(AllArchetypes.Num() == ArchetypeDataVersion);

		for (const FMassArchetypeFragmentConfig& FragmentConfig : NewArchetype->GetFragmentConfigs())
		{
			checkSlow(FragmentConfig.FragmentType)
			FragmentTypeToArchetypeMap.FindOrAdd(FragmentConfig.FragmentType).Add(ArchetypeDataPtr);
		}

		OnNewArchetypeEvent.Broadcast(FMassArchetypeHandle(ArchetypeDataPtr));
	}

	return FMassArchetypeHelper::ArchetypeHandleFromData(ArchetypeDataPtr);
}

FMassArchetypeHandle FMassEntityManager::InternalCreateSimilarArchetype(const TSharedPtr<FMassArchetypeData>& SourceArchetype, const FMassTagBitSet& OverrideTags)
{
	checkSlow(SourceArchetype.IsValid());
	const FMassArchetypeData& SourceArchetypeRef = *SourceArchetype.Get();
	FMassArchetypeCompositionDescriptor NewComposition(SourceArchetypeRef.GetFragmentBitSet()
		, OverrideTags
		, SourceArchetypeRef.GetChunkFragmentBitSet()
		, SourceArchetypeRef.GetSharedFragmentBitSet()
		, SourceArchetypeRef.GetConstSharedFragmentBitSet());
	return InternalCreateSimilarArchetype(SourceArchetypeRef, MoveTemp(NewComposition));
}

FMassArchetypeHandle FMassEntityManager::InternalCreateSimilarArchetype(const TSharedPtr<FMassArchetypeData>& SourceArchetype, const FMassFragmentBitSet& OverrideFragments)
{
	checkSlow(SourceArchetype.IsValid());
	const FMassArchetypeData& SourceArchetypeRef = *SourceArchetype.Get();
	FMassArchetypeCompositionDescriptor NewComposition(OverrideFragments
		, SourceArchetypeRef.GetTagBitSet()
		, SourceArchetypeRef.GetChunkFragmentBitSet()
		, SourceArchetypeRef.GetSharedFragmentBitSet()
		, SourceArchetypeRef.GetConstSharedFragmentBitSet());
	return InternalCreateSimilarArchetype(SourceArchetypeRef, MoveTemp(NewComposition));
}

FMassArchetypeHandle FMassEntityManager::InternalCreateSimilarArchetype(const FMassArchetypeData& SourceArchetypeRef, FMassArchetypeCompositionDescriptor&& NewComposition)
{
	const uint32 TypeHash = NewComposition.CalculateHash();

	TArray<TSharedPtr<FMassArchetypeData>>& HashRow = FragmentHashToArchetypeMap.FindOrAdd(TypeHash);

	TSharedPtr<FMassArchetypeData> ArchetypeDataPtr;
	for (const TSharedPtr<FMassArchetypeData>& Ptr : HashRow)
	{
		if (Ptr->IsEquivalent(NewComposition))
		{
			ArchetypeDataPtr = Ptr;
			break;
		}
	}

	if (!ArchetypeDataPtr.IsValid())
	{
		// Important to pre-increment the version as the queries will use this value to do incremental updates
		++ArchetypeDataVersion;

		// Create a new archetype
		FMassArchetypeData* NewArchetype = new FMassArchetypeData(FMassArchetypeCreationParams(SourceArchetypeRef));
		NewArchetype->InitializeWithSimilar(SourceArchetypeRef, MoveTemp(NewComposition), ArchetypeDataVersion);
		NewArchetype->CopyDebugNamesFrom(SourceArchetypeRef);

		ArchetypeDataPtr = HashRow.Add_GetRef(MakeShareable(NewArchetype));
		AllArchetypes.Add(ArchetypeDataPtr);
		ensure(AllArchetypes.Num() == ArchetypeDataVersion);

		for (const FMassArchetypeFragmentConfig& FragmentConfig : NewArchetype->GetFragmentConfigs())
		{
			checkSlow(FragmentConfig.FragmentType)
			FragmentTypeToArchetypeMap.FindOrAdd(FragmentConfig.FragmentType).Add(ArchetypeDataPtr);
		}

		OnNewArchetypeEvent.Broadcast(FMassArchetypeHandle(ArchetypeDataPtr));
	}

	return FMassArchetypeHelper::ArchetypeHandleFromData(ArchetypeDataPtr);
}

void FMassEntityManager::InternalAppendFragmentsAndTagsToArchetypeCompositionDescriptor(
	FMassArchetypeCompositionDescriptor& InOutComposition, TConstArrayView<const UScriptStruct*> FragmentsAndTagsList) const
{
	for (const UScriptStruct* Type : FragmentsAndTagsList)
	{
		if (Type->IsChildOf(FMassFragment::StaticStruct()))
		{
			InOutComposition.Fragments.Add(*Type);
		}
		else if (Type->IsChildOf(FMassTag::StaticStruct()))
		{
			InOutComposition.Tags.Add(*Type);
		}
		else if (Type->IsChildOf(FMassChunkFragment::StaticStruct()))
		{
			InOutComposition.ChunkFragments.Add(*Type);
		}
		else
		{
			UE_LOG(LogMass, Warning, TEXT("%hs: %s is not a valid fragment nor tag type. Ignoring.")
				, __FUNCTION__, *GetNameSafe(Type));
		}
	}
}

FMassArchetypeHandle FMassEntityManager::GetArchetypeForEntity(FMassEntityHandle Entity) const
{
	if (IsEntityValid(Entity))
	{
		return FMassArchetypeHelper::ArchetypeHandleFromData(GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index));
	}
	return FMassArchetypeHandle();
}

FMassArchetypeHandle FMassEntityManager::GetArchetypeForEntityUnsafe(FMassEntityHandle Entity) const
{
	check(GetEntityStorageInterface().IsValidIndex(Entity.Index));
	return FMassArchetypeHelper::ArchetypeHandleFromData(GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index));
}

void FMassEntityManager::ForEachArchetypeFragmentType(const FMassArchetypeHandle& ArchetypeHandle, TFunction< void(const UScriptStruct* /*FragmentType*/)> Function)
{
	const FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);
	ArchetypeData.ForEachFragmentType(Function);
}

void FMassEntityManager::DoEntityCompaction(const double TimeAllowed)
{
	int32 TotalEntitiesMoved = 0;
	const double TimeAllowedEnd = FPlatformTime::Seconds() + TimeAllowed;

	bool bReachedTimeLimit = false;
	for (const auto& KVP : FragmentHashToArchetypeMap)
	{
		for (const TSharedPtr<FMassArchetypeData>& ArchetypePtr : KVP.Value)
		{
			const double TimeAllowedLeft = TimeAllowedEnd - FPlatformTime::Seconds();
			bReachedTimeLimit = TimeAllowedLeft <= 0.0;
			if (bReachedTimeLimit)
			{
 				break;
			}
			TotalEntitiesMoved += ArchetypePtr->CompactEntities(TimeAllowedLeft);
		}
		if (bReachedTimeLimit)
		{
			break;
		}
	}

	UE_CVLOG(TotalEntitiesMoved, GetOwner(), LogMass, Verbose, TEXT("Entity Compaction: moved %d entities"), TotalEntitiesMoved);
}

FMassEntityHandle FMassEntityManager::CreateEntity(const FMassArchetypeHandle& ArchetypeHandle, const FMassArchetypeSharedFragmentValues& SharedFragmentValues)
{
	checkf(IsProcessing() == false, TEXT("Synchronous API function %hs called during mass processing. Use asynchronous API instead."), __FUNCTION__);
	check(ArchetypeHandle.IsValid());

	const FMassEntityHandle Entity = ReserveEntity();
	InternalBuildEntity(Entity
		, GetOrCreateSuitableArchetype(ArchetypeHandle, SharedFragmentValues.GetSharedFragmentBitSet(), SharedFragmentValues.GetConstSharedFragmentBitSet())
		, SharedFragmentValues);

	return Entity;
}

FMassEntityHandle FMassEntityManager::CreateEntity(TConstArrayView<FInstancedStruct> FragmentInstanceList, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, const FMassArchetypeCreationParams& CreationParams)
{
	checkf(IsProcessing() == false, TEXT("Synchronous API function %hs called during mass processing. Use asynchronous API instead."), __FUNCTION__);
	check(FragmentInstanceList.Num() > 0);

	const FMassArchetypeHandle& ArchetypeHandle = CreateArchetype(FMassArchetypeCompositionDescriptor(FragmentInstanceList,
		FMassTagBitSet(), FMassChunkFragmentBitSet(), FMassSharedFragmentBitSet(), FMassConstSharedFragmentBitSet()), CreationParams);
	check(ArchetypeHandle.IsValid());

	const FMassEntityHandle Entity = ReserveEntity();

	// Using a creation context to prevent InternalBuildEntity from notifying observers before we set fragments data
	const TSharedRef<FEntityCreationContext> CreationContext = GetOrMakeCreationContext();
	CreationContext->AppendEntities({Entity});

	InternalBuildEntity(Entity, ArchetypeHandle, SharedFragmentValues);

	FMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);
	check(CurrentArchetype);
	CurrentArchetype->SetFragmentsData(Entity, FragmentInstanceList);

	return Entity;
}

FMassEntityHandle FMassEntityManager::ReserveEntity()
{
	FMassEntityHandle Result = GetEntityStorageInterface().AcquireOne();

	return Result;
}

void FMassEntityManager::ReleaseReservedEntity(FMassEntityHandle Entity)
{
	checkf(!IsEntityBuilt(Entity), TEXT("Entity is already built, use DestroyEntity() instead"));

	InternalReleaseEntity(Entity);
}

void FMassEntityManager::BuildEntity(FMassEntityHandle Entity, const FMassArchetypeHandle& ArchetypeHandle, const FMassArchetypeSharedFragmentValues& SharedFragmentValues)
{
	checkf(IsProcessing() == false, TEXT("Synchronous API function %hs called during mass processing. Use asynchronous API instead."), __FUNCTION__);
	checkf(!IsEntityBuilt(Entity), TEXT("Expecting an entity that is not already built"));
	check(ArchetypeHandle.IsValid());

	InternalBuildEntity(Entity, ArchetypeHandle, SharedFragmentValues);
}

void FMassEntityManager::BuildEntity(FMassEntityHandle Entity, TConstArrayView<FInstancedStruct> FragmentInstanceList, const FMassArchetypeSharedFragmentValues& SharedFragmentValues)
{
	checkf(IsProcessing() == false, TEXT("Synchronous API function %hs called during mass processing. Use asynchronous API instead."), __FUNCTION__);
	check(FragmentInstanceList.Num() > 0);
	checkf(!IsEntityBuilt(Entity), TEXT("Expecting an entity that is not already built"));

	checkf(SharedFragmentValues.IsSorted(), TEXT("Expecting shared fragment values to be previously sorted"));
	FMassArchetypeCompositionDescriptor Composition(FragmentInstanceList, FMassTagBitSet(), FMassChunkFragmentBitSet(), FMassSharedFragmentBitSet(), FMassConstSharedFragmentBitSet());
	for (const FConstSharedStruct& SharedFragment : SharedFragmentValues.GetConstSharedFragments())
	{
		Composition.ConstSharedFragments.Add(*SharedFragment.GetScriptStruct());
	}
	for (const FSharedStruct& SharedFragment : SharedFragmentValues.GetSharedFragments())
	{
		Composition.SharedFragments.Add(*SharedFragment.GetScriptStruct());
	}

	const FMassArchetypeHandle& ArchetypeHandle = CreateArchetype(Composition);
	check(ArchetypeHandle.IsValid());

	// Using a creation context to prevent InternalBuildEntity from notifying observers before we set fragments data
	const TSharedRef<FEntityCreationContext> CreationContext = GetOrMakeCreationContext();
	CreationContext->AppendEntities({Entity});

	InternalBuildEntity(Entity, ArchetypeHandle, SharedFragmentValues);

	FMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);
	check(CurrentArchetype);
	CurrentArchetype->SetFragmentsData(Entity, FragmentInstanceList);
}

TConstArrayView<FMassEntityHandle> FMassEntityManager::BatchReserveEntities(const int32 Count, TArray<FMassEntityHandle>& InOutEntities)
{
	const int32 Index = InOutEntities.Num();
	const int32 NumAdded = GetEntityStorageInterface().Acquire(Count, InOutEntities);
	ensureMsgf(NumAdded == Count, TEXT("Failed to reserve %d entities, was able to only reserve %d"), Count, NumAdded);

	return MakeArrayView(InOutEntities.GetData() + Index, NumAdded);
}

int32 FMassEntityManager::BatchReserveEntities(TArrayView<FMassEntityHandle> InOutEntities)
{
	return GetEntityStorageInterface().Acquire(InOutEntities);
}

TSharedRef<FMassEntityManager::FEntityCreationContext> FMassEntityManager::BatchBuildEntities(const FMassArchetypeEntityCollectionWithPayload& EncodedEntitiesWithPayload
	, const FMassFragmentBitSet& FragmentsAffected, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, const FMassArchetypeCreationParams& CreationParams)
{
	checkf(IsProcessing() == false, TEXT("Synchronous API function %hs called during mass processing. Use asynchronous API instead."), __FUNCTION__);
	check(SharedFragmentValues.IsSorted());

	FMassArchetypeCompositionDescriptor Composition(FragmentsAffected, FMassTagBitSet(), FMassChunkFragmentBitSet(), FMassSharedFragmentBitSet(), FMassConstSharedFragmentBitSet());
	for (const FConstSharedStruct& SharedFragment : SharedFragmentValues.GetConstSharedFragments())
	{
		Composition.SharedFragments.Add(*SharedFragment.GetScriptStruct());
	}
	for (const FSharedStruct& SharedFragment : SharedFragmentValues.GetSharedFragments())
	{
		Composition.SharedFragments.Add(*SharedFragment.GetScriptStruct());
	}

	return BatchBuildEntities(EncodedEntitiesWithPayload, MoveTemp(Composition), SharedFragmentValues, CreationParams);
}

TSharedRef<FMassEntityManager::FEntityCreationContext> FMassEntityManager::BatchBuildEntities(const FMassArchetypeEntityCollectionWithPayload& EncodedEntitiesWithPayload
	, FMassArchetypeCompositionDescriptor&& Composition
	, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, const FMassArchetypeCreationParams& CreationParams)
{
	checkf(IsProcessing() == false, TEXT("Synchronous API function %hs called during mass processing. Use asynchronous API instead."), __FUNCTION__);

	TRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchBuildEntities);

	FMassArchetypeEntityCollection::FEntityRangeArray TargetArchetypeEntityRanges;

	// "built" entities case, this is verified during FMassArchetypeEntityCollectionWithPayload construction
	FMassArchetypeHandle TargetArchetypeHandle = CreateArchetype(Composition, CreationParams);
	check(TargetArchetypeHandle.IsValid());

	// there are some extra steps in creating EncodedEntities from the original given entity handles and then back
	// to handles here, but this way we're consistent in how stuff is handled, and there are some slight benefits 
	// to having entities ordered by their index (like accessing the Entities data below).
	TArray<FMassEntityHandle> EntityHandles;
	UE::Mass::Private::ConvertArchetypelessSubchunksIntoEntityHandles(EncodedEntitiesWithPayload.GetEntityCollection().GetRanges(), EntityHandles);

	// since the handles encoded via FMassArchetypeEntityCollectionWithPayload miss the SerialNumber we need to update it
	// before passing over the new archetype. Thankfully we need to iterate over all the entity handles anyway
	// to update the manager's information on these entities (stored in FMassEntityManager::Entities)
	for (FMassEntityHandle& Entity : EntityHandles)
	{
		check(GetEntityStorageInterface().IsValidIndex(Entity.Index));

		const UE::Mass::IEntityStorageInterface::EEntityState EntityState = GetEntityStorageInterface().GetEntityState(Entity.Index);
		checkf(EntityState == UE::Mass::IEntityStorageInterface::EEntityState::Reserved, TEXT("Trying to build entities that are not reserved. Check all handles are reserved or consider using BatchCreateEntities"));

		const int32 SerialNumber = GetEntityStorageInterface().GetSerialNumber(Entity.Index);
		Entity.SerialNumber = SerialNumber;
		
		GetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, TargetArchetypeHandle.DataPtr);
	}

	TargetArchetypeHandle.DataPtr->BatchAddEntities(EntityHandles, SharedFragmentValues, TargetArchetypeEntityRanges);

	if (EncodedEntitiesWithPayload.GetPayload().IsEmpty() == false)
	{
		// at this point all the entities are in the target archetype, we can set the values
		// note that even though the "subchunk" information could have changed the order of entities is the same and 
		// corresponds to the order in FMassArchetypeEntityCollectionWithPayload's payload
		TargetArchetypeHandle.DataPtr->BatchSetFragmentValues(TargetArchetypeEntityRanges, EncodedEntitiesWithPayload.GetPayload());
	}

	// With this call we're either creating a fresh context populated with EntityHandles, or it will append 
	// EntityHandles to active context.
	// Not creating the context sooner since we want to reuse TargetArchetypeEntityRanges by moving it over to the context.
	// Note that we can afford to create this context so late since all previous operations were on the archetype level
	// and as such won't cause observers triggering (which usually is prevented by context's existence), and that we 
	// strongly assume the all entity creation/building (not to be mistaken with "reserving") takes place in a single thread
	// @todo add checks/ensures enforcing the assumption mentioned above.
	return GetOrMakeCreationContext(EntityHandles
		, FMassArchetypeEntityCollection(TargetArchetypeHandle, MoveTemp(TargetArchetypeEntityRanges)));
}

TSharedRef<FMassEntityManager::FEntityCreationContext> FMassEntityManager::BatchCreateReservedEntities(const FMassArchetypeHandle& ArchetypeHandle
	, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, TConstArrayView<FMassEntityHandle> ReservedEntities)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchCreateReservedEntities);

	checkf(IsProcessing() == false, TEXT("Synchronous API function %hs called during mass processing. Use asynchronous API instead."), __FUNCTION__);
	checkf(!ReservedEntities.IsEmpty(), TEXT("No reserved entities given to batch create."));

	return InternalBatchCreateReservedEntities(
		GetOrCreateSuitableArchetype(ArchetypeHandle, SharedFragmentValues.GetSharedFragmentBitSet(), SharedFragmentValues.GetConstSharedFragmentBitSet())
		, SharedFragmentValues, ReservedEntities);
}

TSharedRef<FMassEntityManager::FEntityCreationContext> FMassEntityManager::BatchCreateEntities(const FMassArchetypeHandle& ArchetypeHandle
	, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, const int32 Count, TArray<FMassEntityHandle>& InOutEntities)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchCreateEntities);

	checkf(IsProcessing() == false, TEXT("Synchronous API function %hs called during mass processing. Use asynchronous API instead."), __FUNCTION__);
	testableCheckfReturn(ArchetypeHandle.IsValid(), return GetOrMakeCreationContext()
		, TEXT("%hs expecting a valid ArchetypeHandle"), __FUNCTION__);

	TConstArrayView<FMassEntityHandle> ReservedEntities = BatchReserveEntities(Count, InOutEntities);
	
	return InternalBatchCreateReservedEntities(
		GetOrCreateSuitableArchetype(ArchetypeHandle, SharedFragmentValues.GetSharedFragmentBitSet(), SharedFragmentValues.GetConstSharedFragmentBitSet())
		, SharedFragmentValues, ReservedEntities);
}

TSharedRef<FMassEntityManager::FEntityCreationContext> FMassEntityManager::InternalBatchCreateReservedEntities(const FMassArchetypeHandle& ArchetypeHandle
	, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, TConstArrayView<FMassEntityHandle> ReservedEntities)
{
	// Functions calling into this one are required to verify that the archetype handle is valid
	FMassArchetypeData* ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandle(ArchetypeHandle);
	checkf(ArchetypeData, TEXT("Functions calling into this one are required to verify that the archetype handle is valid"));

	for (FMassEntityHandle Entity : ReservedEntities)
	{
		check(IsEntityValid(Entity));
		const UE::Mass::IEntityStorageInterface::EEntityState EntityState = GetEntityStorageInterface().GetEntityState(Entity.Index);
		checkf(EntityState == UE::Mass::IEntityStorageInterface::EEntityState::Reserved, TEXT("Trying to build entities that are not reserved. Check all handles are reserved or consider using BatchCreateEntities"));
		
		GetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, ArchetypeHandle.DataPtr);
	}

	FMassArchetypeEntityCollection::FEntityRangeArray TargetArchetypeEntityRanges;
	ArchetypeData->BatchAddEntities(ReservedEntities, SharedFragmentValues, TargetArchetypeEntityRanges);

	return GetOrMakeCreationContext(ReservedEntities, FMassArchetypeEntityCollection(ArchetypeHandle, MoveTemp(TargetArchetypeEntityRanges)));
}

void FMassEntityManager::DestroyEntity(FMassEntityHandle Entity)
{
	checkf(IsProcessing() == false, TEXT("Synchronous API function %hs called during mass processing. Use asynchronous API instead."), __FUNCTION__);
	
	CheckIfEntityIsActive(Entity);

	FMassArchetypeData* Archetype = GetEntityStorageInterface().GetArchetype(Entity.Index);

	if (Archetype)
	{
		ObserverManager.OnPreEntityDestroyed(Archetype->GetCompositionDescriptor(), Entity);
		Archetype->RemoveEntity(Entity);
	}

	InternalReleaseEntity(Entity);
}

void FMassEntityManager::BatchDestroyEntities(TConstArrayView<FMassEntityHandle> InEntities)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchDestroyEntities);

	checkf(IsProcessing() == false, TEXT("Synchronous API function %hs called during mass processing. Use asynchronous API instead."), __FUNCTION__);
	checkf(IsDuringEntityCreation() == false, TEXT("%hs: Trying to destroy entities while entity creation is under way. This operation is not supported."), __FUNCTION__);

	for (const FMassEntityHandle Entity : InEntities)
	{
		if (GetEntityStorageInterface().IsValidIndex(Entity.Index) == false)
		{
			continue;
		}

		const int32 SerialNumber = GetEntityStorageInterface().GetSerialNumber(Entity.Index);
		if (SerialNumber != Entity.SerialNumber)
		{
			continue;
		}

		if (FMassArchetypeData* Archetype = GetEntityStorageInterface().GetArchetype(Entity.Index))
		{
			ObserverManager.OnPreEntityDestroyed(Archetype->GetCompositionDescriptor(), Entity);
			Archetype->RemoveEntity(Entity);
		}
		// else it's a "reserved" entity so it has not been assigned to an archetype yet, no archetype nor observers to notify
	}

	GetEntityStorageInterface().Release(InEntities);
}

void FMassEntityManager::BatchDestroyEntityChunks(const FMassArchetypeEntityCollection& EntityCollection)
{
	BatchDestroyEntityChunks(MakeArrayView(&EntityCollection, 1));
}

void FMassEntityManager::BatchDestroyEntityChunks(TConstArrayView<FMassArchetypeEntityCollection> Collections)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchDestroyEntityChunks);

	checkf(IsProcessing() == false, TEXT("Synchronous API function %hs called during mass processing. Use asynchronous API instead."), __FUNCTION__);
	checkf(IsDuringEntityCreation() == false, TEXT("%hs: Trying to destroy entities while entity creation is under way. This operation is not supported."), __FUNCTION__);

	TArray<FMassEntityHandle> EntitiesRemoved;
	// note that it's important to place the context instance in the same scope as the loop below that updates 
	// FMassEntityManager.EntityData, otherwise, if there are commands flushed as part of FMassProcessingContext's 
	// destruction the commands will work on outdated information (which might result in crashes).
	FMassProcessingContext ProcessingContext(*this, /*TimeDelta=*/0.0f);
	ProcessingContext.bFlushCommandBuffer = false;
	ProcessingContext.CommandBuffer = MakeShareable(new FMassCommandBuffer());

	for (const FMassArchetypeEntityCollection& EntityCollection : Collections)
	{
		EntitiesRemoved.Reset();
		if (EntityCollection.GetArchetype().IsValid())
		{
			ObserverManager.OnPreEntitiesDestroyed(ProcessingContext, EntityCollection);

			FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(EntityCollection.GetArchetype());
			ArchetypeData.BatchDestroyEntityChunks(EntityCollection.GetRanges(), EntitiesRemoved);
		
			GetEntityStorageInterface().Release(EntitiesRemoved);
		}
		else
		{
			UE::Mass::Private::ConvertArchetypelessSubchunksIntoEntityHandles(EntityCollection.GetRanges(), EntitiesRemoved);
			GetEntityStorageInterface().ForceRelease(EntitiesRemoved);
		}
	}
}

void FMassEntityManager::AddFragmentToEntity(FMassEntityHandle Entity, const UScriptStruct* FragmentType)
{
	checkf(FragmentType, TEXT("Null fragment type passed in to %hs"), __FUNCTION__);
	checkf(IsProcessing() == false, TEXT("Synchronous API function %hs called during mass processing. Use asynchronous API instead."), __FUNCTION__);

	CheckIfEntityIsActive(Entity);

	const FMassArchetypeCompositionDescriptor Descriptor(InternalAddFragmentListToEntityChecked(Entity, FMassFragmentBitSet(*FragmentType)));

	if (IsAllowedToTriggerObservers())
	{
		ObserverManager.OnPostCompositionAdded(Entity, Descriptor);
	}
}

void FMassEntityManager::AddFragmentToEntity(FMassEntityHandle Entity, const UScriptStruct* FragmentType, const FStructInitializationCallback& Initializer)
{
	checkf(FragmentType, TEXT("Null fragment type passed in to %hs"), __FUNCTION__);
	checkf(IsProcessing() == false, TEXT("Synchronous API function %hs called during mass processing. Use asynchronous API instead."), __FUNCTION__);

	CheckIfEntityIsActive(Entity);

	FMassFragmentBitSet Fragments = InternalAddFragmentListToEntityChecked(Entity, FMassFragmentBitSet(*FragmentType));
	FMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);
	check(CurrentArchetype);
	void* FragmentData = CurrentArchetype->GetFragmentDataForEntity(FragmentType, Entity.Index);
	Initializer(FragmentData, *FragmentType);

	const FMassArchetypeCompositionDescriptor Descriptor(MoveTemp(Fragments));
	
	if (IsAllowedToTriggerObservers())
	{
		ObserverManager.OnPostCompositionAdded(Entity, Descriptor);
	}
}

void FMassEntityManager::AddFragmentListToEntity(FMassEntityHandle Entity, TConstArrayView<const UScriptStruct*> FragmentList)
{
	CheckIfEntityIsActive(Entity);

	const FMassArchetypeCompositionDescriptor Descriptor(InternalAddFragmentListToEntityChecked(Entity, FMassFragmentBitSet(FragmentList)));
	
	if (IsAllowedToTriggerObservers())
	{
		ObserverManager.OnPostCompositionAdded(Entity, Descriptor);
	}
}

void FMassEntityManager::AddCompositionToEntity_GetDelta(FMassEntityHandle Entity, FMassArchetypeCompositionDescriptor& InDescriptor)
{
	CheckIfEntityIsActive(Entity);

	FMassArchetypeData* OldArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);
	check(OldArchetype);

	InDescriptor.Fragments -= OldArchetype->GetCompositionDescriptor().Fragments;
	InDescriptor.Tags -= OldArchetype->GetCompositionDescriptor().Tags;

	ensureMsgf(InDescriptor.ChunkFragments.IsEmpty(), TEXT("Adding new chunk fragments is not supported"));

	if (InDescriptor.IsEmpty() == false)
	{
		FMassArchetypeCompositionDescriptor NewDescriptor = OldArchetype->GetCompositionDescriptor();
		NewDescriptor.Fragments += InDescriptor.Fragments;
		NewDescriptor.Tags += InDescriptor.Tags;

		const FMassArchetypeHandle NewArchetypeHandle = CreateArchetype(NewDescriptor, FMassArchetypeCreationParams(*OldArchetype));

		if (ensure(NewArchetypeHandle.DataPtr.Get() != OldArchetype))
		{
			// Move the entity over
			FMassArchetypeData& NewArchetype = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(NewArchetypeHandle);
			NewArchetype.CopyDebugNamesFrom(*OldArchetype);
			OldArchetype->MoveEntityToAnotherArchetype(Entity, NewArchetype);

			GetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);

			if (IsAllowedToTriggerObservers())
			{
				ObserverManager.OnPostCompositionAdded(Entity, InDescriptor);
			}
		}
	}
}

void FMassEntityManager::RemoveCompositionFromEntity(FMassEntityHandle Entity, const FMassArchetypeCompositionDescriptor& InDescriptor)
{
	CheckIfEntityIsActive(Entity);

	if(InDescriptor.IsEmpty() == false)
	{
		FMassArchetypeData* OldArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);
		check(OldArchetype);

		FMassArchetypeCompositionDescriptor NewDescriptor = OldArchetype->GetCompositionDescriptor();
		NewDescriptor.Fragments -= InDescriptor.Fragments;
		NewDescriptor.Tags -= InDescriptor.Tags;

		ensureMsgf(InDescriptor.ChunkFragments.IsEmpty(), TEXT("Removing chunk fragments is not supported"));
		ensureMsgf(InDescriptor.SharedFragments.IsEmpty(), TEXT("Removing shared fragments is not supported"));

		if (NewDescriptor.IsEquivalent(OldArchetype->GetCompositionDescriptor()) == false)
		{
			ensureMsgf(OldArchetype->GetCompositionDescriptor().HasAll(InDescriptor), TEXT("Some of the elements being removed are already missing from entity\'s composition."));
			
			if (IsAllowedToTriggerObservers())
			{
				ObserverManager.OnPreCompositionRemoved(Entity, InDescriptor);
			}

			const FMassArchetypeHandle NewArchetypeHandle = CreateArchetype(NewDescriptor, FMassArchetypeCreationParams(*OldArchetype));

			if (ensure(NewArchetypeHandle.DataPtr.Get() != OldArchetype))
			{
				// Move the entity over
				FMassArchetypeData& NewArchetype = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(NewArchetypeHandle);
				NewArchetype.CopyDebugNamesFrom(*OldArchetype);
				OldArchetype->MoveEntityToAnotherArchetype(Entity, NewArchetype);
				GetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);
			}
		}
	}
}

const FMassArchetypeCompositionDescriptor& FMassEntityManager::GetArchetypeComposition(const FMassArchetypeHandle& ArchetypeHandle) const
{
	const FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);
	return ArchetypeData.GetCompositionDescriptor();
}

void FMassEntityManager::InternalBuildEntity(FMassEntityHandle Entity, const FMassArchetypeHandle& ArchetypeHandle, const FMassArchetypeSharedFragmentValues& SharedFragmentValues)
{
	const TSharedPtr<FMassArchetypeData>& NewArchetype = ArchetypeHandle.DataPtr;
	GetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, ArchetypeHandle.DataPtr);
	NewArchetype->AddEntity(Entity, SharedFragmentValues);

	if (IsAllowedToTriggerObservers())
	{
		ObserverManager.OnPostCompositionAdded(Entity, NewArchetype->GetCompositionDescriptor());
	}
}

void FMassEntityManager::InternalReleaseEntity(FMassEntityHandle Entity)
{
	// Using force release by bypass serial number check since we have verified the validity of the handle earlier.
	GetEntityStorageInterface().ForceReleaseOne(Entity);
}

FMassFragmentBitSet FMassEntityManager::InternalAddFragmentListToEntityChecked(FMassEntityHandle Entity, const FMassFragmentBitSet& InFragments)
{
	TSharedPtr<FMassArchetypeData>& OldArchetype = GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index);
	check(OldArchetype);

	UE_CLOG(OldArchetype->GetFragmentBitSet().HasAny(InFragments), LogMass, Log
		, TEXT("Trying to add a new fragment type to an entity, but it already has some of them. (%s)")
		, *InFragments.GetOverlap(OldArchetype->GetFragmentBitSet()).DebugGetStringDesc());

	FMassFragmentBitSet NewFragments = InFragments - OldArchetype->GetFragmentBitSet();
	if (NewFragments.IsEmpty() == false)
	{
		InternalAddFragmentListToEntity(Entity, NewFragments);
	}
	return MoveTemp(NewFragments);
}

void FMassEntityManager::InternalAddFragmentListToEntity(FMassEntityHandle Entity, const FMassFragmentBitSet& InFragments)
{
	checkf(InFragments.IsEmpty() == false, TEXT("%hs is intended for internal calls with non empty NewFragments parameter"), __FUNCTION__);
	check(GetEntityStorageInterface().IsValidIndex(Entity.Index));
	TSharedPtr<FMassArchetypeData>& OldArchetype = GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index);
	check(OldArchetype.IsValid());

	// fetch or create the new archetype
	const FMassArchetypeHandle NewArchetypeHandle = CreateArchetype(OldArchetype, InFragments);
	checkf(NewArchetypeHandle.DataPtr != OldArchetype, TEXT("%hs is intended for internal calls with non overlapping fragment list."), __FUNCTION__);

	// Move the entity over
	FMassArchetypeData& NewArchetype = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(NewArchetypeHandle);
	NewArchetype.CopyDebugNamesFrom(*OldArchetype);
	OldArchetype->MoveEntityToAnotherArchetype(Entity, NewArchetype);

	GetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);
}

void FMassEntityManager::AddFragmentInstanceListToEntity(FMassEntityHandle Entity, TConstArrayView<FInstancedStruct> FragmentInstanceList)
{
	checkf(IsProcessing() == false, TEXT("Synchronous API function %hs called during mass processing. Use asynchronous API instead."), __FUNCTION__);

	CheckIfEntityIsActive(Entity);
	checkf(FragmentInstanceList.Num() > 0, TEXT("Need to specify at least one fragment instances for this operation"));

	const FMassArchetypeCompositionDescriptor Descriptor(InternalAddFragmentListToEntityChecked(Entity, FMassFragmentBitSet(FragmentInstanceList)));
	
	FMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);
	check(CurrentArchetype);
	CurrentArchetype->SetFragmentsData(Entity, FragmentInstanceList);

	if (IsAllowedToTriggerObservers())
	{
		ObserverManager.OnPostCompositionAdded(Entity, Descriptor);
	}
}

void FMassEntityManager::RemoveFragmentFromEntity(FMassEntityHandle Entity, const UScriptStruct* FragmentType)
{
	RemoveFragmentListFromEntity(Entity, MakeArrayView(&FragmentType, 1));
}

void FMassEntityManager::RemoveFragmentListFromEntity(FMassEntityHandle Entity, TConstArrayView<const UScriptStruct*> FragmentList)
{
	checkf(IsProcessing() == false, TEXT("Synchronous API function %hs called during mass processing. Use asynchronous API instead."), __FUNCTION__);

	CheckIfEntityIsActive(Entity);
	
	FMassArchetypeData* OldArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);
	check(OldArchetype);

	const FMassFragmentBitSet FragmentsToRemove(FragmentList);

	if (OldArchetype->GetFragmentBitSet().HasAny(FragmentsToRemove))
	{
		// If all the fragments got removed this will result in fetching of the empty archetype
		const FMassArchetypeCompositionDescriptor NewComposition(OldArchetype->GetFragmentBitSet() - FragmentsToRemove
			, OldArchetype->GetTagBitSet()
			, OldArchetype->GetChunkFragmentBitSet()
			, OldArchetype->GetSharedFragmentBitSet()
			, OldArchetype->GetConstSharedFragmentBitSet());
		const FMassArchetypeHandle NewArchetypeHandle = CreateArchetype(NewComposition, FMassArchetypeCreationParams(*OldArchetype));

		FMassArchetypeCompositionDescriptor CompositionDelta;
		// Find overlap.  It isn't guaranteed that the old archetype has all of the fragments being removed.
		CompositionDelta.Fragments = OldArchetype->GetFragmentBitSet().GetOverlap(FragmentsToRemove);

		if (IsAllowedToTriggerObservers())
		{
			ObserverManager.OnPreCompositionRemoved(Entity, CompositionDelta);
		}

		// Move the entity over
		FMassArchetypeData& NewArchetype = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(NewArchetypeHandle);
		NewArchetype.CopyDebugNamesFrom(*OldArchetype);
		OldArchetype->MoveEntityToAnotherArchetype(Entity, NewArchetype);
		
		GetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);
	}
}

void FMassEntityManager::SwapTagsForEntity(FMassEntityHandle Entity, const UScriptStruct* OldTagType, const UScriptStruct* NewTagType)
{
	checkf(IsProcessing() == false, TEXT("Synchronous API function %hs called during mass processing. Use asynchronous API instead."), __FUNCTION__);

	CheckIfEntityIsActive(Entity);

	checkf((OldTagType != nullptr) && OldTagType->IsChildOf(FMassTag::StaticStruct()), TEXT("%hs works only with tags while '%s' is not one."), __FUNCTION__, *GetPathNameSafe(OldTagType));
	checkf((NewTagType != nullptr) && NewTagType->IsChildOf(FMassTag::StaticStruct()), TEXT("%hs works only with tags while '%s' is not one."), __FUNCTION__, *GetPathNameSafe(NewTagType));
	
	TSharedPtr<FMassArchetypeData>& CurrentArchetype = GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index);
	check(CurrentArchetype);

	FMassTagBitSet NewTagBitSet = CurrentArchetype->GetTagBitSet();
	NewTagBitSet.Remove(*OldTagType);
	NewTagBitSet.Add(*NewTagType);
	
	if (NewTagBitSet != CurrentArchetype->GetTagBitSet())
	{
		const FMassArchetypeHandle NewArchetypeHandle = InternalCreateSimilarArchetype(CurrentArchetype, NewTagBitSet);
		checkSlow(NewArchetypeHandle.IsValid());

		// Move the entity over
		CurrentArchetype->MoveEntityToAnotherArchetype(Entity, *NewArchetypeHandle.DataPtr.Get());
		
		GetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);
	}
}

void FMassEntityManager::AddTagToEntity(FMassEntityHandle Entity, const UScriptStruct* TagType)
{
	checkf((TagType != nullptr) && TagType->IsChildOf(FMassTag::StaticStruct()), TEXT("%hs works only with tags while '%s' is not one."), __FUNCTION__, *GetPathNameSafe(TagType));

	CheckIfEntityIsActive(Entity);
	
	TSharedPtr<FMassArchetypeData>& CurrentArchetype = GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index);
	check(CurrentArchetype);

	if (CurrentArchetype->HasTagType(TagType) == false)
	{
		//FMassTagBitSet NewTags = CurrentArchetype->GetTagBitSet() - *TagType;
		FMassTagBitSet NewTags = CurrentArchetype->GetTagBitSet();
		NewTags.Add(*TagType);
		const FMassArchetypeHandle NewArchetypeHandle = InternalCreateSimilarArchetype(CurrentArchetype, NewTags);
		checkSlow(NewArchetypeHandle.IsValid());

		// Move the entity over
		CurrentArchetype->MoveEntityToAnotherArchetype(Entity, *NewArchetypeHandle.DataPtr.Get());
		GetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);

		FMassArchetypeCompositionDescriptor CompositionDelta;
		FMassTagBitSet TagDelta;
		TagDelta.Add(*TagType);
		CompositionDelta.Tags = TagDelta;
		
		if (IsAllowedToTriggerObservers())
		{
			ObserverManager.OnPostCompositionAdded(Entity, CompositionDelta);
		}
	}
}
	
void FMassEntityManager::RemoveTagFromEntity(FMassEntityHandle Entity, const UScriptStruct* TagType)
{
	checkf((TagType != nullptr) && TagType->IsChildOf(FMassTag::StaticStruct()), TEXT("%hs works only with tags while '%s' is not one."), __FUNCTION__, *GetPathNameSafe(TagType));

	CheckIfEntityIsActive(Entity);

	TSharedPtr<FMassArchetypeData>& CurrentArchetype = GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index);
	check(CurrentArchetype);

	if (CurrentArchetype->HasTagType(TagType))
	{
		FMassArchetypeCompositionDescriptor CompositionDelta;
		FMassTagBitSet TagDelta;
		TagDelta.Add(*TagType);
		CompositionDelta.Tags = TagDelta;
		
		if (IsAllowedToTriggerObservers())
		{
			ObserverManager.OnPreCompositionRemoved(Entity, CompositionDelta);
		}
		
		// CurrentArchetype->GetTagBitSet() -  *TagType
		const FMassTagBitSet NewTagComposition = CurrentArchetype->GetTagBitSet() - TagDelta;
		const FMassArchetypeHandle NewArchetypeHandle = InternalCreateSimilarArchetype(CurrentArchetype, NewTagComposition);
		checkSlow(NewArchetypeHandle.IsValid());

		// Move the entity over
		CurrentArchetype->MoveEntityToAnotherArchetype(Entity, *NewArchetypeHandle.DataPtr.Get());
		GetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);
	}
}

bool FMassEntityManager::AddConstSharedFragmentToEntity(const FMassEntityHandle Entity, const FConstSharedStruct& InConstSharedFragment)
{
	if (!ensureMsgf(InConstSharedFragment.IsValid(), TEXT("%hs parameter Fragment is expected to be valid"), __FUNCTION__))
	{
		return false;
	}

	CheckIfEntityIsActive(Entity);
	
	FMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index).Get();
	check(CurrentArchetype);

	const UScriptStruct* StructType = InConstSharedFragment.GetScriptStruct();
	CA_ASSUME(StructType);
	if (CurrentArchetype->GetCompositionDescriptor().ConstSharedFragments.Contains(*StructType))
	{
		const FMassArchetypeSharedFragmentValues& SharedFragmentValues = CurrentArchetype->GetSharedFragmentValues(Entity);
		FConstSharedStruct ExistingConstSharedStruct = SharedFragmentValues.GetConstSharedFragmentStruct(StructType);
		if (ExistingConstSharedStruct == InConstSharedFragment || ExistingConstSharedStruct.CompareStructValues(InConstSharedFragment))
		{
			// nothing to do
			return true;
		}
		UE_LOG(LogMass, Warning, TEXT("Changing shared fragment value of entities is not supported"));
		return false;
	}
	
	FMassArchetypeCompositionDescriptor NewComposition(CurrentArchetype->GetCompositionDescriptor());
	NewComposition.ConstSharedFragments.Add(*StructType);
	const FMassArchetypeHandle NewArchetypeHandle = CreateArchetype(NewComposition, FMassArchetypeCreationParams(*CurrentArchetype));
	check(NewArchetypeHandle.IsValid());
	FMassArchetypeData* NewArchetype = NewArchetypeHandle.DataPtr.Get();
	check(NewArchetype);

	const FMassArchetypeSharedFragmentValues& OldSharedFragmentValues = CurrentArchetype->GetSharedFragmentValues(Entity.Index);
	check(!OldSharedFragmentValues.ContainsType(StructType));
	FMassArchetypeSharedFragmentValues NewSharedFragmentValues(OldSharedFragmentValues);
	NewSharedFragmentValues.AddConstSharedFragment(InConstSharedFragment);
	NewSharedFragmentValues.Sort();

	CurrentArchetype->MoveEntityToAnotherArchetype(Entity, *NewArchetype, &NewSharedFragmentValues);

	// Change the entity archetype
	GetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);

	return true;
}

bool FMassEntityManager::RemoveConstSharedFragmentFromEntity(const FMassEntityHandle Entity, const UScriptStruct& ConstSharedFragmentType)
{
	if (!ensureMsgf(ConstSharedFragmentType.IsChildOf(FMassConstSharedFragment::StaticStruct()), TEXT("%hs parameter ConstSharedFragmentType is expected to be a FMassConstSharedFragment"), __FUNCTION__))
	{
		return false;
	}
	
	CheckIfEntityIsActive(Entity);
	
	FMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetypeAsShared(Entity.Index).Get();
	check(CurrentArchetype);
	
	if (!CurrentArchetype->GetCompositionDescriptor().ConstSharedFragments.Contains(ConstSharedFragmentType))
	{
		// Nothing to do. Returning false to indicate nothing has been removed, as per function's documentation 
		return false;
	}

	FMassArchetypeCompositionDescriptor NewComposition(CurrentArchetype->GetCompositionDescriptor());
	NewComposition.ConstSharedFragments.Remove(ConstSharedFragmentType);
	const FMassArchetypeHandle NewArchetypeHandle = CreateArchetype(NewComposition);
	check(NewArchetypeHandle.IsValid());
	FMassArchetypeData* NewArchetype = NewArchetypeHandle.DataPtr.Get();
	check(NewArchetype);
	
	const FMassArchetypeSharedFragmentValues& OldSharedFragmentValues = CurrentArchetype->GetSharedFragmentValues(Entity.Index);
	check(OldSharedFragmentValues.ContainsType(&ConstSharedFragmentType));
	FMassArchetypeSharedFragmentValues NewSharedFragmentValues(OldSharedFragmentValues);
	
	const FMassConstSharedFragmentBitSet ToRemove(ConstSharedFragmentType);
	NewSharedFragmentValues.Remove(ToRemove);
	NewSharedFragmentValues.Sort();
	
	CurrentArchetype->MoveEntityToAnotherArchetype(Entity, *NewArchetype, &NewSharedFragmentValues);

	// Change the entity archetype
	GetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);
	
	return true;
}

void FMassEntityManager::BatchChangeTagsForEntities(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, const FMassTagBitSet& TagsToAdd, const FMassTagBitSet& TagsToRemove)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchChangeTagsForEntities);

	const FScopedCreationContextOperations CreationContextOperations(*this);
	
	for (const FMassArchetypeEntityCollection& Collection : EntityCollections)
	{
		FMassArchetypeData* CurrentArchetype = Collection.GetArchetype().DataPtr.Get();
		const FMassTagBitSet NewTagComposition = CurrentArchetype
			? (CurrentArchetype->GetTagBitSet() + TagsToAdd - TagsToRemove)
			: (TagsToAdd - TagsToRemove);

		if (ensure(CurrentArchetype) && CurrentArchetype->GetTagBitSet() != NewTagComposition)
		{
			FMassTagBitSet TagsAdded = TagsToAdd - CurrentArchetype->GetTagBitSet();
			FMassTagBitSet TagsRemoved = TagsToRemove.GetOverlap(CurrentArchetype->GetTagBitSet());

			if (CreationContextOperations.IsAllowedToTriggerObservers()
				&& ObserverManager.HasObserversForBitSet(TagsRemoved, EMassObservedOperation::Remove))
			{
				// @todo should use OnPreCompositionRemoved here instead, but we're missing a FMassArchetypeEntityCollection version
				ObserverManager.OnCompositionChanged(Collection, FMassArchetypeCompositionDescriptor(MoveTemp(TagsRemoved)), EMassObservedOperation::Remove);
			}
			const bool bTagsAddedAreObserved = ObserverManager.HasObserversForBitSet(TagsAdded, EMassObservedOperation::Add);

			FMassArchetypeHandle NewArchetypeHandle = InternalCreateSimilarArchetype(Collection.GetArchetype().DataPtr, NewTagComposition);
			checkSlow(NewArchetypeHandle.IsValid());

			// Move the entity over
			FMassArchetypeEntityCollection::FEntityRangeArray NewArchetypeEntityRanges;
			TArray<FMassEntityHandle> EntitiesBeingMoved;
			CurrentArchetype->BatchMoveEntitiesToAnotherArchetype(Collection, *NewArchetypeHandle.DataPtr.Get(), EntitiesBeingMoved
				, bTagsAddedAreObserved ? &NewArchetypeEntityRanges : nullptr);

			for (const FMassEntityHandle& Entity : EntitiesBeingMoved)
			{
				check(GetEntityStorageInterface().IsValidIndex(Entity.Index));
				
				GetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);
			}

			if (bTagsAddedAreObserved && CreationContextOperations.IsAllowedToTriggerObservers())
			{
				// @todo should use OnPostCompositionAdded here instead, but we're missing a FMassArchetypeEntityCollection version
				ObserverManager.OnCompositionChanged(
					FMassArchetypeEntityCollection(NewArchetypeHandle, MoveTemp(NewArchetypeEntityRanges))
					, FMassArchetypeCompositionDescriptor(MoveTemp(TagsAdded))
					, EMassObservedOperation::Add);
			}
		}
	}
}

void FMassEntityManager::BatchChangeFragmentCompositionForEntities(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, const FMassFragmentBitSet& FragmentsToAdd, const FMassFragmentBitSet& FragmentsToRemove)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchChangeFragmentCompositionForEntities);

	FScopedCreationContextOperations CreationContextOperations(*this);

	for (const FMassArchetypeEntityCollection& Collection : EntityCollections)
	{
		FMassArchetypeData* CurrentArchetype = Collection.GetArchetype().DataPtr.Get();
		const FMassFragmentBitSet NewFragmentComposition = CurrentArchetype
			? (CurrentArchetype->GetFragmentBitSet() + FragmentsToAdd - FragmentsToRemove)
			: (FragmentsToAdd - FragmentsToRemove);

		if (CurrentArchetype)
		{
			if (CurrentArchetype->GetFragmentBitSet() != NewFragmentComposition)
			{
				FMassFragmentBitSet FragmentsAdded = FragmentsToAdd - CurrentArchetype->GetFragmentBitSet();
				const bool bFragmentsAddedAreObserved = ObserverManager.HasObserversForBitSet(FragmentsAdded, EMassObservedOperation::Add);
				FMassFragmentBitSet FragmentsRemoved = FragmentsToRemove.GetOverlap(CurrentArchetype->GetFragmentBitSet());
				
				if (CreationContextOperations.IsAllowedToTriggerObservers()
					&& ObserverManager.HasObserversForBitSet(FragmentsRemoved, EMassObservedOperation::Remove))
				{
					ObserverManager.OnCompositionChanged(Collection, FMassArchetypeCompositionDescriptor(MoveTemp(FragmentsRemoved)), EMassObservedOperation::Remove);
				}

				FMassArchetypeHandle NewArchetypeHandle = InternalCreateSimilarArchetype(Collection.GetArchetype().DataPtr, NewFragmentComposition);
				checkSlow(NewArchetypeHandle.IsValid());

				// Move the entity over
				FMassArchetypeEntityCollection::FEntityRangeArray NewArchetypeEntityRanges;
				TArray<FMassEntityHandle> EntitiesBeingMoved;
				CurrentArchetype->BatchMoveEntitiesToAnotherArchetype(Collection, *NewArchetypeHandle.DataPtr.Get(), EntitiesBeingMoved
					, bFragmentsAddedAreObserved ? &NewArchetypeEntityRanges : nullptr);

				for (const FMassEntityHandle& Entity : EntitiesBeingMoved)
				{
					check(GetEntityStorageInterface().IsValidIndex(Entity.Index));

					GetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);
				}

				if (bFragmentsAddedAreObserved && CreationContextOperations.IsAllowedToTriggerObservers())
				{
					ObserverManager.OnCompositionChanged(
						FMassArchetypeEntityCollection(NewArchetypeHandle, MoveTemp(NewArchetypeEntityRanges))
						, FMassArchetypeCompositionDescriptor(MoveTemp(FragmentsAdded))
						, EMassObservedOperation::Add);
				}
			}
		}
		else
		{
			BatchBuildEntities(FMassArchetypeEntityCollectionWithPayload(Collection), NewFragmentComposition, FMassArchetypeSharedFragmentValues());
		}
	}
}

void FMassEntityManager::BatchAddFragmentInstancesForEntities(TConstArrayView<FMassArchetypeEntityCollectionWithPayload> EntityCollections, const FMassFragmentBitSet& FragmentsAffected)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchAddFragmentInstancesForEntities);

	// here's the scenario:
	// * we get entities from potentially different archetypes
	// * adding a fragment instance consists of two operations: A) add fragment type & B) set fragment value
	//		* some archetypes might already have the "added" fragments so no need for step A
	//		* there might be an "empty" archetype in the mix - then step A results in archetype creation and assigning
	//		* if step A is required then the initial FMassArchetypeEntityCollection instance is no longer valid
	// * setting value can be done uniformly for all entities, remembering some might be in different chunks already
	// * @todo note that after adding fragment type some entities originally in different archetypes end up in the same 
	//		archetype. This could be utilized as a basis for optimization. To be investigated.
	// 

	FScopedCreationContextOperations CreationContextOperations(*this);

	for (const FMassArchetypeEntityCollectionWithPayload& EntityRangesWithPayload : EntityCollections)
	{
		FMassArchetypeHandle TargetArchetypeHandle = EntityRangesWithPayload.GetEntityCollection().GetArchetype();
		FMassArchetypeData* CurrentArchetype = TargetArchetypeHandle.DataPtr.Get();

		if (CurrentArchetype)
		{
			FMassArchetypeEntityCollection::FEntityRangeArray TargetArchetypeEntityRanges;
			bool bFragmentsAddedAreObserved = false;
			FMassFragmentBitSet NewFragmentComposition = CurrentArchetype
				? (CurrentArchetype->GetFragmentBitSet() + FragmentsAffected)
				: FragmentsAffected;
			FMassFragmentBitSet FragmentsAdded;

			if (CurrentArchetype->GetFragmentBitSet() != NewFragmentComposition)
			{
				FragmentsAdded = FragmentsAffected - CurrentArchetype->GetFragmentBitSet();
				bFragmentsAddedAreObserved = ObserverManager.HasObserversForBitSet(FragmentsAdded, EMassObservedOperation::Add);

				FMassArchetypeHandle NewArchetypeHandle = InternalCreateSimilarArchetype(TargetArchetypeHandle.DataPtr, NewFragmentComposition);
				checkSlow(NewArchetypeHandle.IsValid());

				// Move the entity over
				TArray<FMassEntityHandle> EntitiesBeingMoved;
				CurrentArchetype->BatchMoveEntitiesToAnotherArchetype(EntityRangesWithPayload.GetEntityCollection(), *NewArchetypeHandle.DataPtr.Get()
					, EntitiesBeingMoved, &TargetArchetypeEntityRanges);

				for (const FMassEntityHandle& Entity : EntitiesBeingMoved)
				{
					check(GetEntityStorageInterface().IsValidIndex(Entity.Index));

					GetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);
				}

				TargetArchetypeHandle = NewArchetypeHandle;
			}
			else
			{
				TargetArchetypeEntityRanges = EntityRangesWithPayload.GetEntityCollection().GetRanges();
			}

			// at this point all the entities are in the target archetype, we can set the values
			// note that even though the "subchunk" information could have changed the order of entities is the same and 
			// corresponds to the order in FMassArchetypeEntityCollectionWithPayload's payload
			TargetArchetypeHandle.DataPtr->BatchSetFragmentValues(TargetArchetypeEntityRanges, EntityRangesWithPayload.GetPayload());
			
			if (bFragmentsAddedAreObserved && CreationContextOperations.IsAllowedToTriggerObservers())
			{
				ObserverManager.OnCompositionChanged(
					FMassArchetypeEntityCollection(TargetArchetypeHandle, MoveTemp(TargetArchetypeEntityRanges))
					, FMassArchetypeCompositionDescriptor(MoveTemp(FragmentsAdded))
					, EMassObservedOperation::Add);
			}
		}
		else 
		{
			BatchBuildEntities(EntityRangesWithPayload, FragmentsAffected, FMassArchetypeSharedFragmentValues());
		}
	}
}

void FMassEntityManager::BatchAddSharedFragmentsForEntities(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections
	, const FMassArchetypeSharedFragmentValues& AddedFragmentValues)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchAddConstSharedFragmentForEntities);

	for (const FMassArchetypeEntityCollection& Collection : EntityCollections)
	{
		FMassArchetypeData* CurrentArchetype = Collection.GetArchetype().DataPtr.Get();
		testableCheckfReturn(CurrentArchetype, continue, TEXT("Adding shared fragments to archetype-less entities is not supported"));

		FMassArchetypeCompositionDescriptor NewComposition(CurrentArchetype->GetCompositionDescriptor());
		NewComposition.SharedFragments += AddedFragmentValues.GetSharedFragmentBitSet();
		NewComposition.ConstSharedFragments += AddedFragmentValues.GetConstSharedFragmentBitSet();

		const FMassArchetypeHandle NewArchetypeHandle = CreateArchetype(NewComposition, FMassArchetypeCreationParams(*CurrentArchetype));
		check(NewArchetypeHandle.IsValid());
		FMassArchetypeData* NewArchetype = NewArchetypeHandle.DataPtr.Get();
		check(NewArchetype);
		if (!testableEnsureMsgf(CurrentArchetype != NewArchetype, TEXT("Setting shared fragment values without archetype change is not supported")))
		{
			UE_LOG(LogMass, Warning, TEXT("Trying to set shared fragment values, without adding new shared fragments, is not supported."));
			continue;
		}

		TArray<FMassEntityHandle> EntitiesBeingMoved;
		CurrentArchetype->BatchMoveEntitiesToAnotherArchetype(Collection, *NewArchetype, EntitiesBeingMoved, /*OutNewChunks=*/nullptr, &AddedFragmentValues);

		for (const FMassEntityHandle& Entity : EntitiesBeingMoved)
		{
			check(GetEntityStorageInterface().IsValidIndex(Entity.Index));
			
			GetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);
		}
	}
}

void FMassEntityManager::MoveEntityToAnotherArchetype(FMassEntityHandle Entity, FMassArchetypeHandle NewArchetypeHandle)
{
	CheckIfEntityIsActive(Entity);

	FMassArchetypeData& NewArchetype = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(NewArchetypeHandle);

	// Move the entity over
	FMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);
	check(CurrentArchetype);
	CurrentArchetype->MoveEntityToAnotherArchetype(Entity, NewArchetype);
	GetEntityStorageInterface().SetArchetypeFromShared(Entity.Index, NewArchetypeHandle.DataPtr);
}

void FMassEntityManager::SetEntityFragmentsValues(FMassEntityHandle Entity, TArrayView<const FInstancedStruct> FragmentInstanceList)
{
	CheckIfEntityIsActive(Entity);

	FMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);
	check(CurrentArchetype);
	CurrentArchetype->SetFragmentsData(Entity, FragmentInstanceList);
}

void FMassEntityManager::BatchSetEntityFragmentsValues(const FMassArchetypeEntityCollection& SparseEntities, TArrayView<const FInstancedStruct> FragmentInstanceList)
{
	if (FragmentInstanceList.Num())
	{
		BatchSetEntityFragmentsValues(MakeArrayView(&SparseEntities, 1), FragmentInstanceList);
	}
}

void FMassEntityManager::BatchSetEntityFragmentsValues(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, TArrayView<const FInstancedStruct> FragmentInstanceList)
{
	if (FragmentInstanceList.IsEmpty())
	{
		return;
	}

	for (const FMassArchetypeEntityCollection& SparseEntities : EntityCollections)
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(Mass_BatchSetEntityFragmentsValues);

		FMassArchetypeData* Archetype = SparseEntities.GetArchetype().DataPtr.Get();
		check(Archetype);

		for (const FInstancedStruct& FragmentTemplate : FragmentInstanceList)
		{
			Archetype->SetFragmentData(SparseEntities.GetRanges(), FragmentTemplate);
		}
	}
}

void* FMassEntityManager::InternalGetFragmentDataChecked(FMassEntityHandle Entity, const UScriptStruct* FragmentType) const
{
	// note that FragmentType is guaranteed to be of valid type - it's either statically checked by the template versions
	// or `checkf`ed by the non-template one
	CheckIfEntityIsActive(Entity);
	const FMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);
	check(CurrentArchetype);
	return CurrentArchetype->GetFragmentDataForEntityChecked(FragmentType, Entity.Index);
}

void* FMassEntityManager::InternalGetFragmentDataPtr(FMassEntityHandle Entity, const UScriptStruct* FragmentType) const
{
	// note that FragmentType is guaranteed to be of valid type - it's either statically checked by the template versions
	// or `checkf`ed by the non-template one
	CheckIfEntityIsActive(Entity);
	const FMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);
	check(CurrentArchetype);
	return CurrentArchetype->GetFragmentDataForEntity(FragmentType, Entity.Index);
}

const FConstSharedStruct* FMassEntityManager::InternalGetConstSharedFragmentPtr(FMassEntityHandle Entity, const UScriptStruct* ConstSharedFragmentType) const
{
	// note that ConstSharedFragmentType is guaranteed to be of valid type - it's either statically checked by the template versions
	// or `checkf`ed by the non-template one
	CheckIfEntityIsActive(Entity);
	const FMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);
	check(CurrentArchetype);
	const FConstSharedStruct* SharedFragment = CurrentArchetype->GetSharedFragmentValues(Entity).GetConstSharedFragments().FindByPredicate(FStructTypeEqualOperator(ConstSharedFragmentType));
	return SharedFragment;
}

const FSharedStruct* FMassEntityManager::InternalGetSharedFragmentPtr(FMassEntityHandle Entity, const UScriptStruct* SharedFragmentType) const
{
	// note that SharedFragmentType is guaranteed to be of valid type - it's either statically checked by the template versions
	// or `checkf`ed by the non-template one
	CheckIfEntityIsActive(Entity);
	const FMassArchetypeData* CurrentArchetype = GetEntityStorageInterface().GetArchetype(Entity.Index);
	check(CurrentArchetype);
	const FSharedStruct* SharedFragment = CurrentArchetype->GetSharedFragmentValues(Entity).GetSharedFragments().FindByPredicate(FStructTypeEqualOperator(SharedFragmentType));
	return SharedFragment;
}

bool FMassEntityManager::IsEntityValid(FMassEntityHandle Entity) const
{
	return (Entity.Index != UE::Mass::Private::InvalidEntityIndex) 
		&& GetEntityStorageInterface().IsValidIndex(Entity.Index) 
		&& (GetEntityStorageInterface().GetSerialNumber(Entity.Index) == Entity.SerialNumber);
}

bool FMassEntityManager::IsEntityBuilt(FMassEntityHandle Entity) const
{
	CheckIfEntityIsValid(Entity);
	const UE::Mass::IEntityStorageInterface::EEntityState CurrentState = GetEntityStorageInterface().GetEntityState(Entity.Index);
	return CurrentState == UE::Mass::IEntityStorageInterface::EEntityState::Created;
}

void FMassEntityManager::CheckIfEntityIsValid(FMassEntityHandle Entity) const
{
	checkf(IsEntityValid(Entity), TEXT("Invalid entity (ID: %d, SN:%d, %s)"), Entity.Index, Entity.SerialNumber,
		   (Entity.Index == 0) ? TEXT("was never initialized") : TEXT("already destroyed"));
}

void FMassEntityManager::CheckIfEntityIsActive(FMassEntityHandle Entity) const
{
	checkf(IsEntityBuilt(Entity), TEXT("Entity not yet created(ID: %d, SN:%d)"), Entity.Index, Entity.SerialNumber);
}

void FMassEntityManager::GetMatchingArchetypes(const FMassFragmentRequirements& Requirements, TArray<FMassArchetypeHandle>& OutValidArchetypes, const uint32 FromArchetypeDataVersion) const
{
	for (int32 ArchetypeIndex = FromArchetypeDataVersion; ArchetypeIndex < AllArchetypes.Num(); ++ArchetypeIndex)
	{
		checkf(AllArchetypes[ArchetypeIndex].IsValid(), TEXT("We never expect to get any invalid shared ptrs in AllArchetypes"));

		FMassArchetypeData& Archetype = *(AllArchetypes[ArchetypeIndex].Get());

		// Only return archetypes with a newer created version than the specified version, this is for incremental query updates
		ensureMsgf(Archetype.GetCreatedArchetypeDataVersion() > FromArchetypeDataVersion
			, TEXT("There's a stron assumption that archetype's data version corresponds to its index in AllArchetypes"));

		if (Requirements.DoesArchetypeMatchRequirements(Archetype.GetCompositionDescriptor()))
		{
			OutValidArchetypes.Add(AllArchetypes[ArchetypeIndex]);
		}
#if WITH_MASSENTITY_DEBUG
		else
		{
			UE_VLOG_UELOG(GetOwner(), LogMass, VeryVerbose, TEXT("%s")
				, *FMassDebugger::GetArchetypeRequirementCompatibilityDescription(Requirements, Archetype.GetCompositionDescriptor()));
		}
#endif // WITH_MASSENTITY_DEBUG
	}
}

FMassExecutionContext FMassEntityManager::CreateExecutionContext(const float DeltaSeconds)
{
	FMassExecutionContext ExecutionContext(*this, DeltaSeconds);
	ExecutionContext.SetDeferredCommandBuffer(DeferredCommandBuffers[OpenedCommandBufferIndex]);
	return MoveTemp(ExecutionContext);
}

void FMassEntityManager::FlushCommands(TSharedPtr<FMassCommandBuffer>& InCommandBuffer)
{
	if (!ensureMsgf(IsInGameThread(), TEXT("Calling %hs is supported only on the Game Tread"), __FUNCTION__))
	{
		return;
	}
	if (!ensureMsgf(IsProcessing() == false, TEXT("Calling %hs is not supported while Mass Processing is active. Call FMassEntityManager::AppendCommands instead."), __FUNCTION__))
	{
		return;
	}

	if (InCommandBuffer && InCommandBuffer->HasPendingCommands()
		&& (Algo::Find(DeferredCommandBuffers, InCommandBuffer) == nullptr))
	{
		AppendCommands(InCommandBuffer);
	}
	FlushCommands();
}

void FMassEntityManager::FlushCommands()
{
	constexpr int32 MaxIterations = 5;

	if (!ensureMsgf(IsInGameThread(), TEXT("Calling %hs is supported only on the Game Tread"), __FUNCTION__))
	{
		return;
	}
	if (!ensureMsgf(IsProcessing() == false, TEXT("Calling %hs is not supported while Mass Processing is active. Call FMassEntityManager::AppendCommands instead."), __FUNCTION__))
	{
		return;
	}

	if (bCommandBufferFlushingInProgress == false && IsProcessing() == false)
	{
		ON_SCOPE_EXIT
		{
			bCommandBufferFlushingInProgress = false;
		};
		bCommandBufferFlushingInProgress = true;

		int32 IterationCount = 0;
		do 
		{
			const int32 CommandBufferIndexToFlush = OpenedCommandBufferIndex;

			// buffer swap. Code instigated by observers can still use Defer() to push commands.
			OpenedCommandBufferIndex = (OpenedCommandBufferIndex + 1) % DeferredCommandBuffers.Num();
			ensureMsgf(DeferredCommandBuffers[OpenedCommandBufferIndex]->HasPendingCommands() == false
				, TEXT("The freshly opened command buffer is expected to be empty upon switching"));

			DeferredCommandBuffers[CommandBufferIndexToFlush]->Flush(*this);

			// repeat if there were commands submitted while commands were being flushed (by observers for example)
		} while (DeferredCommandBuffers[OpenedCommandBufferIndex]->HasPendingCommands() && ++IterationCount < MaxIterations);

		UE_CVLOG_UELOG(IterationCount >= MaxIterations, GetOwner(), LogMass, Error, TEXT("Reached loop count limit while flushing commands. Limiting the number of commands pushed during commands flushing could help."));
	}
}

void FMassEntityManager::AppendCommands(TSharedPtr<FMassCommandBuffer>& InOutCommandBuffer)
{
	if (!ensureMsgf(Algo::Find(DeferredCommandBuffers, InOutCommandBuffer) == nullptr
		, TEXT("We don't expect AppendCommands to be called with EntityManager's command buffer as the input parameter")))
	{
		return;
	}
	Defer().MoveAppend(*InOutCommandBuffer.Get());
}

TSharedRef<FMassEntityManager::FEntityCreationContext> FMassEntityManager::GetOrMakeCreationContext()
{
	if (ActiveCreationContext.IsValid())
	{
		return ActiveCreationContext.Pin().ToSharedRef();
	}
	else
	{
		FEntityCreationContext* CreationContext = new FEntityCreationContext(*this);
		TSharedRef<FEntityCreationContext> SharedContext = MakeShareable(CreationContext);
		ActiveCreationContext = SharedContext;
		return SharedContext;
	}
}

TSharedRef<FMassEntityManager::FEntityCreationContext> FMassEntityManager::GetOrMakeCreationContext(TConstArrayView<FMassEntityHandle> ReservedEntities
	, FMassArchetypeEntityCollection&& EntityCollection)
{
	if (ActiveCreationContext.IsValid())
	{
		TSharedPtr<FEntityCreationContext> SharedContext = ActiveCreationContext.Pin();
		CA_ASSUME(SharedContext);
		SharedContext->AppendEntities(ReservedEntities, MoveTemp(EntityCollection));
		return SharedContext.ToSharedRef();
	}
	else
	{
		FEntityCreationContext* CreationContext = new FEntityCreationContext(*this, ReservedEntities, MoveTemp(EntityCollection));
		TSharedRef<FEntityCreationContext> SharedContext = MakeShareable(CreationContext);
		ActiveCreationContext = SharedContext;
		return SharedContext;
	}
}

bool FMassEntityManager::DirtyCreationContext()
{
	if (TSharedPtr<FEntityCreationContext> AsSharedPtr = ActiveCreationContext.Pin())
	{
		AsSharedPtr->MarkDirty();
		return true;
	}
	return false;
}

bool FMassEntityManager::DebugDoCollectionsOverlapCreationContext(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections) const
{
	if (TSharedPtr<FEntityCreationContext> AsSharedPtr = ActiveCreationContext.Pin())
	{
		TConstArrayView<FMassArchetypeEntityCollection> CreationCollections = AsSharedPtr->EntityCollections;
		return CreationCollections.GetData() <= EntityCollections.GetData()
			&& EntityCollections.GetData() <= CreationCollections.GetData() + CreationCollections.Num();
	}

	return false;
}

void FMassEntityManager::SetDebugName(const FString& NewDebugGame) 
{ 
#if WITH_MASSENTITY_DEBUG
	DebugName = NewDebugGame; 
#endif // WITH_MASSENTITY_DEBUG
}

#if WITH_MASSENTITY_DEBUG
void FMassEntityManager::DebugPrintArchetypes(FOutputDevice& Ar, const bool bIncludeEmpty) const
{
	Ar.Logf(ELogVerbosity::Log, TEXT("Listing archetypes contained in EntityManager owned by %s"), *GetPathNameSafe(GetOwner()));

	int32 NumBuckets = 0;
	int32 NumArchetypes = 0;
	int32 LongestArchetypeBucket = 0;
	for (const auto& KVP : FragmentHashToArchetypeMap)
	{
		for (const TSharedPtr<FMassArchetypeData>& ArchetypePtr : KVP.Value)
		{
			if (ArchetypePtr.IsValid() && (bIncludeEmpty == true || ArchetypePtr->GetChunkCount() > 0))
			{
				ArchetypePtr->DebugPrintArchetype(Ar);
			}
		}

		const int32 NumArchetypesInBucket = KVP.Value.Num();
		LongestArchetypeBucket = FMath::Max(LongestArchetypeBucket, NumArchetypesInBucket);
		NumArchetypes += NumArchetypesInBucket;
		++NumBuckets;
	}

	Ar.Logf(ELogVerbosity::Log, TEXT("FragmentHashToArchetypeMap: %d archetypes across %d buckets, longest bucket is %d"),
		NumArchetypes, NumBuckets, LongestArchetypeBucket);
}

void FMassEntityManager::DebugGetArchetypesStringDetails(FOutputDevice& Ar, const bool bIncludeEmpty) const
{
	Ar.SetAutoEmitLineTerminator(true);
	for (auto Pair : FragmentHashToArchetypeMap)
	{
		Ar.Logf(ELogVerbosity::Log, TEXT("\n-----------------------------------\nHash: %u"), Pair.Key);
		for (TSharedPtr<FMassArchetypeData> Archetype : Pair.Value)
		{
			if (Archetype.IsValid() && (bIncludeEmpty == true || Archetype->GetChunkCount() > 0))
			{
				Archetype->DebugPrintArchetype(Ar);
				Ar.Logf(ELogVerbosity::Log, TEXT("+++++++++++++++++++++++++\n"));
			}
		}
	}
}

void FMassEntityManager::DebugGetArchetypeFragmentTypes(const FMassArchetypeHandle& Archetype, TArray<const UScriptStruct*>& InOutFragmentList) const
{
	if (Archetype.IsValid())
	{
		const FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(Archetype);
		ArchetypeData.GetCompositionDescriptor().Fragments.ExportTypes(InOutFragmentList);
	}
}

int32 FMassEntityManager::DebugGetArchetypeEntitiesCount(const FMassArchetypeHandle& Archetype) const
{
	return Archetype.IsValid() ? FMassArchetypeHelper::ArchetypeDataFromHandleChecked(Archetype).GetNumEntities() : 0;
}

int32 FMassEntityManager::DebugGetArchetypeEntitiesCountPerChunk(const FMassArchetypeHandle& Archetype) const
{
	return Archetype.IsValid() ? FMassArchetypeHelper::ArchetypeDataFromHandleChecked(Archetype).GetNumEntitiesPerChunk() : 0;
}

int32 FMassEntityManager::DebugGetEntityCount() const
{
	return GetEntityStorageInterface().Num() - NumReservedEntities - GetEntityStorageInterface().ComputeFreeSize();
}

int32 FMassEntityManager::DebugGetArchetypesCount() const
{
	return AllArchetypes.Num();
}

void FMassEntityManager::DebugRemoveAllEntities()
{
	for (int EntityIndex = NumReservedEntities, EndIndex = GetEntityStorageInterface().Num(); EntityIndex < EndIndex; ++EntityIndex)
	{
		if (GetEntityStorageInterface().IsValid(EntityIndex) == false)
		{
			// already dead
			continue;
		}
		FMassArchetypeData* Archetype = GetEntityStorageInterface().GetArchetype(EntityIndex);
		check(Archetype);
		FMassEntityHandle Entity;
		Entity.Index = EntityIndex;
		Entity.SerialNumber = GetEntityStorageInterface().GetSerialNumber(EntityIndex);
		Archetype->RemoveEntity(Entity);

		GetEntityStorageInterface().ForceReleaseOne(Entity);
	}
}

void FMassEntityManager::DebugForceArchetypeDataVersionBump()
{
	++ArchetypeDataVersion;
}

void FMassEntityManager::DebugGetArchetypeStrings(const FMassArchetypeHandle& Archetype, TArray<FName>& OutFragmentNames, TArray<FName>& OutTagNames)
{
	if (Archetype.IsValid() == false)
	{
		return;
	}

	const FMassArchetypeData& ArchetypeRef = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(Archetype);
	
	OutFragmentNames.Reserve(ArchetypeRef.GetFragmentConfigs().Num());
	for (const FMassArchetypeFragmentConfig& FragmentConfig : ArchetypeRef.GetFragmentConfigs())
	{
		checkSlow(FragmentConfig.FragmentType);
		OutFragmentNames.Add(FragmentConfig.FragmentType->GetFName());
	}

	ArchetypeRef.GetTagBitSet().DebugGetIndividualNames(OutTagNames);
}

FMassEntityHandle FMassEntityManager::DebugGetEntityIndexHandle(const int32 EntityIndex) const
{
	return GetEntityStorageInterface().IsValidIndex(EntityIndex) ? FMassEntityHandle(EntityIndex, GetEntityStorageInterface().GetSerialNumber(EntityIndex)) : FMassEntityHandle();
}

const FString& FMassEntityManager::DebugGetName() const
{
	return DebugName;
}

FMassRequirementAccessDetector& FMassEntityManager::GetRequirementAccessDetector()
{
	return RequirementAccessDetector;
}

#endif // WITH_MASSENTITY_DEBUG


//-----------------------------------------------------------------------------
// DEPRECATED
//-----------------------------------------------------------------------------

const FMassArchetypeEntityCollection& FMassEntityManager::FEntityCreationContext::GetEntityCollection() const
{
	static FMassArchetypeEntityCollection EmptyCollection;
	return EntityCollections.Num() ? EntityCollections[0] : EmptyCollection;
}

================================================


=== MassEntity/Private/MassEntityManagerConstants.h ===
=======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "HAL/Platform.h"

namespace UE::Mass::Private
{
	// Index 0 is a sentinel for an Empty/Unset EntityHandle
	constexpr int32 InvalidEntityIndex = 0;
};
=======================================================


=== MassEntity/Private/MassEntityManagerStorage.cpp ===
=======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEntityManagerStorage.h"

#include "MassEntityManagerConstants.h"
#include "MassEntityTypes.h"
#include "Templates/SharedPointer.h"

namespace UE::Mass
{
	//-----------------------------------------------------------------------------
	// IEntityStorageInterface
	//-----------------------------------------------------------------------------
	int32 IEntityStorageInterface::Acquire(const int32 Count, TArray<FMassEntityHandle>& OutEntityHandles)
	{
		if (Count)
		{
			const int32 StartingIndex = OutEntityHandles.Num();
			OutEntityHandles.AddZeroed(Count);
			const int32 NumberAdded = Acquire(MakeArrayView(&OutEntityHandles[StartingIndex], Count));
			if (UNLIKELY(NumberAdded < Count))
			{
				// need to remove the redundantly reserved entries
				OutEntityHandles.RemoveAt(StartingIndex + NumberAdded, Count - NumberAdded, EAllowShrinking::No);
			}
			return NumberAdded;
		}
		return 0;
	}

	//-----------------------------------------------------------------------------
	// FSingleThreadedEntityStorage
	//-----------------------------------------------------------------------------

	void FSingleThreadedEntityStorage::Initialize(const FMassEntityManager_InitParams_SingleThreaded&)
	{
		// Index 0 is reserved so we can treat that index as an invalid entity handle
		const FMassEntityHandle SentinelEntity = AcquireOne();
		check(SentinelEntity.Index == UE::Mass::Private::InvalidEntityIndex);
	}

	FMassArchetypeData* FSingleThreadedEntityStorage::GetArchetype(int32 Index)
	{
		return Entities[Index].CurrentArchetype.Get();
	}

	const FMassArchetypeData* FSingleThreadedEntityStorage::GetArchetype(int32 Index) const
	{
		return Entities[Index].CurrentArchetype.Get();
	}

	TSharedPtr<FMassArchetypeData>& FSingleThreadedEntityStorage::GetArchetypeAsShared(int32 Index)
	{
		return Entities[Index].CurrentArchetype;
	}

	const TSharedPtr<FMassArchetypeData>& FSingleThreadedEntityStorage::GetArchetypeAsShared(int32 Index) const
	{
		return Entities[Index].CurrentArchetype;
	}

	void FSingleThreadedEntityStorage::SetArchetypeFromShared(int32 Index, TSharedPtr<FMassArchetypeData>& Archetype)
	{
		Entities[Index].CurrentArchetype = Archetype;
	}

	void FSingleThreadedEntityStorage::SetArchetypeFromShared(int32 Index, const TSharedPtr<FMassArchetypeData>& Archetype)
	{
		Entities[Index].CurrentArchetype = Archetype;
	}

	IEntityStorageInterface::EEntityState FSingleThreadedEntityStorage::GetEntityState(int32 Index) const
	{
		const uint32 CurrentSerialNumber = Entities[Index].SerialNumber;

		if (CurrentSerialNumber != 0)
		{
			return Entities[Index].CurrentArchetype.Get()
				? EEntityState::Created 
				: EEntityState::Reserved;
		}

		return EEntityState::Free;	
	}

	int32 FSingleThreadedEntityStorage::GetSerialNumber(int32 Index) const
	{
		return Entities[Index].SerialNumber;
	}

	bool FSingleThreadedEntityStorage::IsValidIndex(int32 Index) const
	{
		return Entities.IsValidIndex(Index);
	}

	SIZE_T FSingleThreadedEntityStorage::GetAllocatedSize() const
	{
		return Entities.GetAllocatedSize() + EntityFreeIndexList.GetAllocatedSize();
	}

	bool FSingleThreadedEntityStorage::IsValid(int32 Index) const
	{
		return Entities[Index].IsValid();
	}

	FMassEntityHandle FSingleThreadedEntityStorage::AcquireOne()
	{
		const int32 SerialNumber = SerialNumberGenerator.fetch_add(1);
		const int32 Index = (EntityFreeIndexList.Num() > 0) ? EntityFreeIndexList.Pop(EAllowShrinking::No) : Entities.Add();
		Entities[Index].SerialNumber = SerialNumber;

		FMassEntityHandle Handle;
		Handle.SerialNumber = SerialNumber;
		Handle.Index = Index;
		return Handle;
	}

	int32 FSingleThreadedEntityStorage::Acquire(TArrayView<FMassEntityHandle> OutEntityHandles)
	{
		const int32 NumToAdd = OutEntityHandles.Num();

		const int32 SerialNumber = SerialNumberGenerator.fetch_add(1);

		int32 NumAdded = 0;
		int32 CurrentEntityHandleIndex = 0;

		const int32 NumAvailableFromFreeList = FMath::Min(NumToAdd, EntityFreeIndexList.Num());
		if (NumAvailableFromFreeList > 0)
		{
			const int32 FirstIndexToUse = EntityFreeIndexList.Num() - NumAvailableFromFreeList;
			for (int32 Index = FirstIndexToUse; Index < EntityFreeIndexList.Num(); ++Index)
			{
				const int32 EntityIndex = EntityFreeIndexList[Index];
				Entities[EntityIndex].SerialNumber = SerialNumber;
				OutEntityHandles[CurrentEntityHandleIndex++] = { EntityIndex, SerialNumber };
			}
			EntityFreeIndexList.RemoveAt(FirstIndexToUse, NumAvailableFromFreeList, EAllowShrinking::No);
			NumAdded = NumAvailableFromFreeList;
		}

		if (NumAdded < NumToAdd)
		{
			const int32 RemainingCount = NumToAdd - NumAdded;
			const int32 StartingIndex = Entities.Num();
			Entities.Add(RemainingCount);
			for (int32 EntityIndex = StartingIndex; EntityIndex < Entities.Num(); ++EntityIndex)
			{
				Entities[EntityIndex].SerialNumber = SerialNumber;
				OutEntityHandles[CurrentEntityHandleIndex++] = { EntityIndex, SerialNumber };
			}
			NumAdded += RemainingCount;
		}

		return NumAdded;
	}

	int32 FSingleThreadedEntityStorage::Release(TConstArrayView<FMassEntityHandle> Handles)
	{
		int DeallocateCount = 0;

		EntityFreeIndexList.Reserve(EntityFreeIndexList.Num() + Handles.Num());

		for (const FMassEntityHandle& Handle : Handles)
		{
			FEntityData& EntityData = Entities[Handle.Index];
			if (EntityData.SerialNumber == Handle.SerialNumber)
			{
				EntityData.Reset();
				EntityFreeIndexList.Add(Handle.Index);
				++DeallocateCount;
			}
		}
	
		return DeallocateCount;
	}

	int32 FSingleThreadedEntityStorage::ReleaseOne(FMassEntityHandle Handle)
	{
		return Release(MakeArrayView(&Handle, 1));
	}

	int32 FSingleThreadedEntityStorage::ForceRelease(TConstArrayView<FMassEntityHandle> Handles)
	{
		EntityFreeIndexList.Reserve(EntityFreeIndexList.Num() + Handles.Num());
		for (const FMassEntityHandle& Handle : Handles)
		{
			FEntityData& EntityData = Entities[Handle.Index];
			EntityData.Reset();
			EntityFreeIndexList.Add(Handle.Index);
		}
		return Handles.Num();
	}

	int32 FSingleThreadedEntityStorage::ForceReleaseOne(FMassEntityHandle Handle)
	{
		return ForceRelease(MakeArrayView(&Handle, 1));
	}

	int32 FSingleThreadedEntityStorage::Num() const
	{
		return Entities.Num();
	}

	int32 FSingleThreadedEntityStorage::ComputeFreeSize() const
	{
		return EntityFreeIndexList.Num();
	}

	//-----------------------------------------------------------------------------
	// FSingleThreadedEntityStorage::FEntityData
	//-----------------------------------------------------------------------------

	FSingleThreadedEntityStorage::FEntityData::~FEntityData() = default;

	void FSingleThreadedEntityStorage::FEntityData::Reset()
	{
		CurrentArchetype.Reset();
		SerialNumber = 0;
	}

	bool FSingleThreadedEntityStorage::FEntityData::IsValid() const
	{
		return SerialNumber != 0 && CurrentArchetype.IsValid();
	}

	//-----------------------------------------------------------------------------
	// FConcurrentEntityStorage
	//-----------------------------------------------------------------------------

	void FConcurrentEntityStorage::Initialize(const FMassEntityManager_InitParams_Concurrent& InInitializationParams)
	{
		// Compute number of pages required
		check(FMath::IsPowerOfTwo(InInitializationParams.MaxEntitiesPerPage));
		check(FMath::IsPowerOfTwo(InInitializationParams.MaxEntityCount));
		MaxEntitiesPerPage = InInitializationParams.MaxEntitiesPerPage;
		MaximumEntityCountShift = FMath::FloorLog2(InInitializationParams.MaxEntityCount);
		checkf(MaximumEntityCountShift < 32, TEXT("Invalid maximum entity count, cannot exceed 31 bits"));

		const uint64 PagePointerCount = InInitializationParams.MaxEntityCount / InInitializationParams.MaxEntitiesPerPage;

		const uint64 EntityPageSize = sizeof(void*) * PagePointerCount;
		EntityPages = static_cast<FEntityData**>(FMemory::Malloc(EntityPageSize, alignof(FEntityData**)));
		FMemory::Memzero(EntityPages, EntityPageSize);	
	}

	FConcurrentEntityStorage::~FConcurrentEntityStorage()
	{
		if (EntityPages != nullptr)
		{
			for (uint32 Index = 0; Index < PageCount; ++Index)
			{
				FMemory::Free(EntityPages[Index]);
				EntityPages[Index] = nullptr;
			}
			FMemory::Free(EntityPages);
			EntityPages = nullptr;
		}
	}

	FMassArchetypeData* FConcurrentEntityStorage::GetArchetype(int32 Index)
	{
		return LookupEntity(Index).CurrentArchetype.Get();
	}

	const FMassArchetypeData* FConcurrentEntityStorage::GetArchetype(int32 Index) const
	{
		return LookupEntity(Index).CurrentArchetype.Get();
	}

	TSharedPtr<FMassArchetypeData>& FConcurrentEntityStorage::GetArchetypeAsShared(int32 Index)
	{
		return LookupEntity(Index).CurrentArchetype;
	}

	const TSharedPtr<FMassArchetypeData>& FConcurrentEntityStorage::GetArchetypeAsShared(int32 Index) const
	{
		return LookupEntity(Index).CurrentArchetype;
	}

	void FConcurrentEntityStorage::SetArchetypeFromShared(int32 Index, TSharedPtr<FMassArchetypeData>& Archetype)
	{
		LookupEntity(Index).CurrentArchetype = Archetype;
	}

	void FConcurrentEntityStorage::SetArchetypeFromShared(int32 Index, const TSharedPtr<FMassArchetypeData>& Archetype)
	{
		LookupEntity(Index).CurrentArchetype = Archetype;
	}

	IEntityStorageInterface::EEntityState FConcurrentEntityStorage::GetEntityState(int32 Index) const
	{
		//
		// || Archetype || bIsAllocated || Result    |
		//  |  nullptr   |      0       |  Free     |
		//  |  nullptr   |      1       |  Reserved |
		//  | !nullptr   |      1       |  Created  |
		//
	
		const FEntityData& EntityData = LookupEntity(Index);
		if (EntityData.CurrentArchetype != nullptr)
		{
			return EEntityState::Created;
		}
		return EntityData.bIsAllocated
			? EEntityState::Reserved
			: EEntityState::Free;
	}

	int32 FConcurrentEntityStorage::GetSerialNumber(int32 Index) const
	{
		return LookupEntity(Index).GenerationId;
	}

	bool FConcurrentEntityStorage::IsValidIndex(int32 Index) const
	{
		// Page Index is which page in the array of pages we need to access
		if (Index >= 0)
		{
			const uint32 PageIndex = static_cast<uint32>(Index) >> FMath::FloorLog2(MaxEntitiesPerPage);
			return PageIndex < PageCount;
		}
		return false;
	}

	SIZE_T FConcurrentEntityStorage::GetAllocatedSize() const
	{
		const SIZE_T EntityFreeListSizeBytes = EntityFreeIndexList.GetAllocatedSize();

		// Allocated size to pages
		const SIZE_T PageSizeBytes = ComputePageSize();
		const SIZE_T PageAllocatedSizeBytes = PageCount * PageSizeBytes;

		// Size of page pointer array
		const uint32 MaxEntities = 1 << MaximumEntityCountShift;
		const uint32 MagPageCount = (MaxEntities / MaxEntitiesPerPage);
		const SIZE_T PagePointerArraySizeBytes = MagPageCount * sizeof(FEntityData**);
	
		return PageAllocatedSizeBytes + PagePointerArraySizeBytes + EntityFreeListSizeBytes;
	}

	bool FConcurrentEntityStorage::IsValid(int32 Index) const
	{
		return LookupEntity(Index).CurrentArchetype != nullptr;
	}

	bool FConcurrentEntityStorage::AddPage()
	{
		check(FreeListMutex.IsLocked());
		UE::TUniqueLock PageAllocateLock(PageAllocateMutex);

		// Allocate new page
		const uint32 NewPageIndex = PageCount;
		checkf((NewPageIndex + 1) * MaxEntitiesPerPage < (1llu << MaximumEntityCountShift), TEXT("Exhausted number of entities"));

		const uint64 PageSize = ComputePageSize();
		FEntityData* Page = static_cast<FEntityData*>(FMemory::Malloc(PageSize, alignof(FEntityData)));
		
		if (Page == nullptr)
		{
			return false;
		}

		/*for (int32 Index = 0, End = MaxEntitiesPerPage; Index < End; ++Index)
		{
			new (Page + Index) FEntityData();
		}*/
		FMemory::Memzero(Page, PageSize);

		EntityPages[PageCount] = Page;
		++PageCount;

		// Somewhat tricksy thing here to be aware of
		// MassEntityManager expects the very first allocated entity to be at index 0
		static_assert(UE::Mass::Private::InvalidEntityIndex == 0, "Free Entity list algorithm depends on InvalidEntityIndex being 0");
		int32 NewEntityIndexStart;
		if (LIKELY(NewPageIndex != 0))
		{
			NewEntityIndexStart = NewPageIndex * MaxEntitiesPerPage;
		}
		else
		{
			NewEntityIndexStart = 1;
			// Allocate the 0th entity. It will always be the sentinel entity that InvalidEntityIndex points to.
			FEntityData* SentinelEntity = new (Page + UE::Mass::Private::InvalidEntityIndex) FEntityData();
			SentinelEntity->bIsAllocated = 1;
			++SentinelEntity->GenerationId;
		}
		
		const int32 NewEntityIndexEnd = (NewPageIndex + 1) * MaxEntitiesPerPage;

		EntityFreeIndexList.Reserve(NewEntityIndexEnd - NewEntityIndexStart);

		// Push free entities indices onto the stack backwards so new entities pop off in order
		for (int32 NewEntityIndex = NewEntityIndexEnd - 1; NewEntityIndex >= NewEntityIndexStart; --NewEntityIndex)
		{
			// Setup the free list
			EntityFreeIndexList.Push(NewEntityIndex);
		}

		return true;
	}

	FMassEntityHandle FConcurrentEntityStorage::AcquireOne()
	{
		int32 EntityIndex;
		{
			UE::TUniqueLock FreeListLock(FreeListMutex);
		
			if (UNLIKELY(EntityFreeIndexList.IsEmpty()))
			{
				AddPage();
			}

			EntityIndex = EntityFreeIndexList.Pop(EAllowShrinking::No);
		}

		FEntityData& EntityData = LookupEntity(EntityIndex);
		// NOTE: Technically should not be necessary, however FEntityHandle::IsValid() makes the assumption
		// that SerialNum == 0 means an invalid Entity.  FMassArchetypeEntityCollection uses this assumption
		// and will fail IsValid() checks otherwise.
		++EntityData.GenerationId;
		EntityData.bIsAllocated = 1;
		int32 SerialNumber = EntityData.GetSerialNumber();

		EntityCount.fetch_add(1llu);
	
		FMassEntityHandle Handle;
		Handle.SerialNumber = SerialNumber;
		Handle.Index = EntityIndex;
		return Handle;
	}

	int32 FConcurrentEntityStorage::Acquire(TArrayView<FMassEntityHandle> OutEntityHandles)
	{
		const int32 NumberToAdd = OutEntityHandles.Num();

		int32 CountAdded = 0;
		int32 CountLeft = NumberToAdd;
		int32 CurrentEntityHandleIndex = 0;

		while (CountLeft > 0)
		{
			UE::TUniqueLock FreeListLock(FreeListMutex);

			if (UNLIKELY(EntityFreeIndexList.IsEmpty()))
			{
				if (AddPage() == false)
				{
					break;
				}
			}

			const int32 CountToProcess = FMath::Min(CountLeft, EntityFreeIndexList.Num());

			for (int32 Iteration = 0; Iteration < CountToProcess; ++Iteration)
			{
				const int32 EntityIndex = EntityFreeIndexList.Pop(EAllowShrinking::No);

				FEntityData& EntityData = LookupEntity(EntityIndex);
				// NOTE: Technically should not be necessary, however FEntityHandle::IsValid() makes the assumption
				// that SerialNum == 0 means an invalid Entity.  FMassArchetypeEntityCollection uses this assumption
				// and will fail IsValid() checks otherwise.
				++EntityData.GenerationId;
				EntityData.bIsAllocated = 1;
				const int32 SerialNumber = EntityData.GetSerialNumber();

				OutEntityHandles[CurrentEntityHandleIndex++] = { EntityIndex, SerialNumber };
			}
			
			CountAdded += CountToProcess;
			CountLeft -= CountToProcess;
		}

		EntityCount.fetch_add(CountAdded);

		return CountAdded;
	}

	int32 FConcurrentEntityStorage::Release(TConstArrayView<FMassEntityHandle> Handles)
	{
		int32 DeallocateCount = 0;
	
		int32 BeginHandlesIndexToFree = 0;
		int32 AllocatedRunLength = 0;

		// Helper to add a range of handles to the EntityFreeIndexList
		auto FreeRunOfHandles = [this, &BeginHandlesIndexToFree, &AllocatedRunLength, Handles]()
		{
			if (AllocatedRunLength > 0) // Cheaper than taking the lock for each in case of runs of unallocated handles
			{
				UE::TUniqueLock FreeListLock(FreeListMutex);
				EntityFreeIndexList.Reserve(EntityFreeIndexList.Num() + AllocatedRunLength);
				for (int32 IndexToFree = BeginHandlesIndexToFree; IndexToFree < BeginHandlesIndexToFree + AllocatedRunLength; ++IndexToFree)
				{
					const FMassEntityHandle& HandleToFree = Handles[IndexToFree];
					EntityFreeIndexList.Add(HandleToFree.Index);
				}
			}
			BeginHandlesIndexToFree += (AllocatedRunLength + 1); // +1 to skip to next iteration
			AllocatedRunLength = 0;
		};
	
		for (int32 Index = 0, End = Handles.Num(); Index < End; ++Index)
		{
			const FMassEntityHandle& Handle = Handles[Index];
			FEntityData& EntityData = LookupEntity(Handle.Index);
			if (EntityData.GetSerialNumber() == Handle.SerialNumber)
			{
				++AllocatedRunLength;
			
				++EntityData.GenerationId;
				EntityData.bIsAllocated = 0;
				EntityData.CurrentArchetype.Reset();
			
				++DeallocateCount;
			}
			else
			{
				// Skip, this one isn't allocated
				// Return the last run to the free list
				// Ideally this code never runs but we cannot control what is passed into the Release() function
				FreeRunOfHandles();
			}
		}

		// Free any remaining handles
		FreeRunOfHandles();

		EntityCount.fetch_sub(DeallocateCount);
	
		return DeallocateCount;
	}

	int32 FConcurrentEntityStorage::ReleaseOne(FMassEntityHandle Handle)
	{
		return Release(MakeArrayView(&Handle, 1));
	}

	int32 FConcurrentEntityStorage::ForceRelease(TConstArrayView<FMassEntityHandle> Handles)
	{
		// ForceRelease assumes the caller knows all handles are allocated
		// no need to have complexity of tracking "runs" of handles 
		for (const FMassEntityHandle& Handle : Handles)
		{
			FEntityData& EntityData = LookupEntity(Handle.Index);

			++EntityData.GenerationId;
			EntityData.bIsAllocated = 0;
			EntityData.CurrentArchetype.Reset();
		}

		{
			UE::TUniqueLock FreeListLock(FreeListMutex);
			EntityFreeIndexList.Reserve(EntityFreeIndexList.Num() + Handles.Num());
			for (const FMassEntityHandle& Handle : Handles)
			{
				EntityFreeIndexList.Add(Handle.Index);
			}
		}

		EntityCount.fetch_sub(Handles.Num());
	
		return Handles.Num();
	}

	int32 FConcurrentEntityStorage::ForceReleaseOne(FMassEntityHandle Handle)
	{
		return ForceRelease(MakeArrayView(&Handle, 1));
	}

	int32 FConcurrentEntityStorage::Num() const
	{
		return MaxEntitiesPerPage * PageCount;;
	}

	int32 FConcurrentEntityStorage::ComputeFreeSize() const
	{
		return EntityFreeIndexList.Num();
	}

	FConcurrentEntityStorage::FEntityData& FConcurrentEntityStorage::LookupEntity(int32 Index)
	{
		check(Index >= 0);
		// PageIndex is which Page in the array of pages we need to access
		const uint32 PageIndex = static_cast<uint32>(Index) >> FMath::FloorLog2(MaxEntitiesPerPage);

		// Convert the entity index into the index with respect to the page
		const uint32 EntityOffset = (PageIndex * MaxEntitiesPerPage);
		check(Index >= static_cast<int32>(EntityOffset)); // Check against negative values
		const uint32 InternalPageIndex = static_cast<uint32>(Index) - EntityOffset;

		// Pointer to start of page
		FEntityData* PageStart = EntityPages[PageIndex];
		FEntityData& EntityData = PageStart[InternalPageIndex];
		return EntityData;
	}

	const FConcurrentEntityStorage::FEntityData& FConcurrentEntityStorage::LookupEntity(int32 Index) const
	{
		return const_cast<FConcurrentEntityStorage*>(this)->LookupEntity(Index);
	}

	uint64 FConcurrentEntityStorage::ComputePageSize() const
	{
		return sizeof(FEntityData) * MaxEntitiesPerPage;
	}

#if WITH_MASSENTITY_DEBUG
	bool FConcurrentEntityStorage::DebugAssumptionsSelfTest()
	{
		// future proofing in case FEntityData's or TSharedPtr's internals change and make MemZero-ing not produce 
		// the same results as default FEntityData's constructor
		FEntityData DefaultData;
		FEntityData ZeroedData;
		FMemory::Memzero(&ZeroedData, sizeof(FEntityData));

		if (DefaultData != ZeroedData)
		{
			UE_LOG(LogMass, Error, TEXT("%hs assumption about default FEntityData values is no longer true."), __FUNCTION__);
			return false;
		}

		return true;
	}
#endif // WITH_MASSENTITY_DEBUG

	//-----------------------------------------------------------------------------
	// FConcurrentEntityStorage::FEntityData
	//-----------------------------------------------------------------------------
	FConcurrentEntityStorage::FEntityData::~FEntityData() = default;

	int32 FConcurrentEntityStorage::FEntityData::GetSerialNumber() const
	{
		return static_cast<int32>(GenerationId);
	}

	bool FConcurrentEntityStorage::FEntityData::operator==(const FEntityData& Other) const
	{
		return CurrentArchetype == Other.CurrentArchetype
			&& GenerationId == Other.GenerationId
			&& bIsAllocated == Other.bIsAllocated;
	}
}

=======================================================


=== MassEntity/Private/MassEntityModule.cpp ===
===============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "Modules/ModuleInterface.h"
#include "MassEntityTypes.h"
#include "MassProcessingTypes.h"
#include "Modules/ModuleManager.h"

#define LOCTEXT_NAMESPACE "Mass"

class FMassEntityModule : public IModuleInterface
{
	/** IModuleInterface implementation */
	virtual void StartupModule() override;
};

IMPLEMENT_MODULE(FMassEntityModule, MassEntity)

void FMassEntityModule::StartupModule()
{
#if WITH_UNREAL_DEVELOPER_TOOLS
	FModuleManager::Get().LoadModule("MassEntityTestSuite");
#endif // WITH_UNREAL_DEVELOPER_TOOLS

#if MASS_DO_PARALLEL
	UE_LOG(LogMass, Log, TEXT("MassEntity running with MULTITHREADING support."));
#else
	UE_LOG(LogMass, Log, TEXT("MassEntity running in game thread."));
#endif // MASS_DO_PARALLEL
}

#undef LOCTEXT_NAMESPACE 

===============================================


=== MassEntity/Private/MassEntityQuery.cpp ===
==============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEntityQuery.h"
#include "MassDebugger.h"
#include "MassEntityManager.h"
#include "MassArchetypeData.h"
#include "MassCommandBuffer.h"
#include "MassExecutionContext.h"
#include "VisualLogger/VisualLogger.h"
#include "Async/ParallelFor.h"
#include "Containers/UnrealString.h"
#include "MassProcessor.h"
#include "MassProcessorDependencySolver.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(MassEntityQuery)

#if WITH_MASSENTITY_DEBUG
#include "MassRequirementAccessDetector.h"
#endif // WITH_MASSENTITY_DEBUG


namespace UE::Mass::Tweakables
{
	/**
	 * Controls whether ParallelForEachEntityChunk actually performs ParallelFor operations. If `false` the call is passed
	 * the the regular ForEachEntityChunk call.
	 */
	bool bAllowParallelExecution = true;

	namespace
	{
		static FAutoConsoleVariableRef AnonymousCVars[] = {
			{	TEXT("mass.AllowQueryParallelFor"), bAllowParallelExecution, TEXT("Controls whether EntityQueries are allowed to utilize ParallelFor construct"), ECVF_Cheat }
		};
	}
}

//-----------------------------------------------------------------------------
// FScopedSubsystemRequirementsRestore
//-----------------------------------------------------------------------------
FMassEntityQuery::FScopedSubsystemRequirementsRestore::FScopedSubsystemRequirementsRestore(FMassExecutionContext& ExecutionContext)
	: CachedExecutionContext(ExecutionContext)
{
	CachedExecutionContext.GetSubsystemRequirementBits(ConstSubsystemsBitSet, MutableSubsystemsBitSet);
}

FMassEntityQuery::FScopedSubsystemRequirementsRestore::~FScopedSubsystemRequirementsRestore()
{
	CachedExecutionContext.SetSubsystemRequirementBits(ConstSubsystemsBitSet, MutableSubsystemsBitSet);
}

//-----------------------------------------------------------------------------
// FMassEntityQuery
//-----------------------------------------------------------------------------
FMassEntityQuery::FMassEntityQuery()
{
}

FMassEntityQuery::FMassEntityQuery(std::initializer_list<UScriptStruct*> InitList)
	: FMassEntityQuery()
{
	for (const UScriptStruct* FragmentType : InitList)
	{
		AddRequirement(FragmentType, EMassFragmentAccess::ReadWrite, EMassFragmentPresence::All);
	}
}

FMassEntityQuery::FMassEntityQuery(TConstArrayView<const UScriptStruct*> InitList)
	: FMassEntityQuery()
{
	for (const UScriptStruct* FragmentType : InitList)
	{
		AddRequirement(FragmentType, EMassFragmentAccess::ReadWrite, EMassFragmentPresence::All);
	}
}

FMassEntityQuery::FMassEntityQuery(UMassProcessor& Owner)
{
	RegisterWithProcessor(Owner);
}

void FMassEntityQuery::RegisterWithProcessor(UMassProcessor& Owner)
{
	ExpectedContextType = EMassExecutionContextType::Processor;
	Owner.RegisterQuery(*this);
#if WITH_MASSENTITY_DEBUG
	bRegistered = true;
#endif // WITH_MASSENTITY_DEBUG
}

void FMassEntityQuery::CacheArchetypes(const FMassEntityManager& InEntityManager)
{
	const uint32 InEntityManagerHash = PointerHash(&InEntityManager);

	// Do an incremental update if the last updated archetype data version is different 
    bool bUpdateArchetypes = InEntityManager.GetArchetypeDataVersion() != LastUpdatedArchetypeDataVersion;

	// Force a full update if the entity system changed or if the requirements changed
	if (EntitySubsystemHash != InEntityManagerHash || HasIncrementalChanges())
	{
		bUpdateArchetypes = true;
		EntitySubsystemHash = InEntityManagerHash;
		ValidArchetypes.Reset();
		LastUpdatedArchetypeDataVersion = 0;
		ArchetypeFragmentMapping.Reset();

		if (HasIncrementalChanges())
		{
			ConsumeIncrementalChangesCount();
			if (CheckValidity())
			{
				SortRequirements();
			}
			else
			{
				bUpdateArchetypes = false;
				UE_VLOG_UELOG(InEntityManager.GetOwner(), LogMass, Error, TEXT("FMassEntityQuery::CacheArchetypes: requirements not valid: %s"), *FMassDebugger::GetRequirementsDescription(*this));
			}
		}
	}
	
	// Process any new archetype that is newer than the LastUpdatedArchetypeDataVersion
	if (bUpdateArchetypes)
	{
		TArray<FMassArchetypeHandle> NewValidArchetypes;
		InEntityManager.GetMatchingArchetypes(*this, NewValidArchetypes, LastUpdatedArchetypeDataVersion);
		LastUpdatedArchetypeDataVersion = InEntityManager.GetArchetypeDataVersion();
		if (NewValidArchetypes.Num())
		{
			const int32 FirstNewArchetype = ValidArchetypes.Num();
			ValidArchetypes.Append(NewValidArchetypes);

			TRACE_CPUPROFILER_EVENT_SCOPE_STR("Mass RequirementsBinding")
			const TConstArrayView<FMassFragmentRequirementDescription> LocalRequirements = GetFragmentRequirements();
			ArchetypeFragmentMapping.AddDefaulted(NewValidArchetypes.Num());
			for (int i = FirstNewArchetype; i < ValidArchetypes.Num(); ++i)
			{
				FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ValidArchetypes[i]);
				ArchetypeData.GetRequirementsFragmentMapping(LocalRequirements, ArchetypeFragmentMapping[i].EntityFragments);
				if (ChunkFragmentRequirements.Num())
				{
					ArchetypeData.GetRequirementsChunkFragmentMapping(ChunkFragmentRequirements, ArchetypeFragmentMapping[i].ChunkFragments);
				}
				if (ConstSharedFragmentRequirements.Num())
				{
					ArchetypeData.GetRequirementsConstSharedFragmentMapping(ConstSharedFragmentRequirements, ArchetypeFragmentMapping[i].ConstSharedFragments);
				}
				if (SharedFragmentRequirements.Num())
				{
					ArchetypeData.GetRequirementsSharedFragmentMapping(SharedFragmentRequirements, ArchetypeFragmentMapping[i].SharedFragments);
				}
			}
		}
	}
}

void FMassEntityQuery::ForEachEntityChunkInCollections(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext, const FMassExecuteFunction& ExecuteFunction)
{
	for (const FMassArchetypeEntityCollection& EntityCollection : EntityCollections)
	{
		ForEachEntityChunk(EntityCollection, EntityManager, ExecutionContext, ExecuteFunction);
	}
}

void FMassEntityQuery::ForEachEntityChunk(const FMassArchetypeEntityCollection& EntityCollection, FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext, const FMassExecuteFunction& ExecuteFunction)
{
	// mz@todo I don't like that we're copying data here.
	ExecutionContext.SetEntityCollection(EntityCollection);
	ForEachEntityChunk(EntityManager, ExecutionContext, ExecuteFunction);
	ExecutionContext.ClearEntityCollection();
}

void FMassEntityQuery::ForEachEntityChunk(FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext, const FMassExecuteFunction& ExecuteFunction)
{
#if WITH_MASSENTITY_DEBUG
	checkf(ExecutionContext.ExecutionType == ExpectedContextType && (ExpectedContextType == EMassExecutionContextType::Local || bRegistered)
		, TEXT("ExecutionContextType mismatch, make sure all the queries run as part of processor execution are registered with some processor with a FMassEntityQuery::RegisterWithProcessor call"));

	EntityManager.GetRequirementAccessDetector().RequireAccess(*this);
#endif

	FScopedSubsystemRequirementsRestore SubsystemRestore(ExecutionContext);

	if (ExecutionContext.CacheSubsystemRequirements(*this) == false)
	{
		// required subsystems are not available, bail out.
		return;
	}

	if (FMassFragmentRequirements::IsEmpty())
	{
		if (ensureMsgf(ExecutionContext.GetEntityCollection().IsSet(), TEXT("Using empty queries is only supported in combination with Entity Collections that explicitly indicate entities to process")))
		{
			static const FMassQueryRequirementIndicesMapping EmptyMapping;

			const FMassArchetypeHandle& ArchetypeHandle = ExecutionContext.GetEntityCollection().GetArchetype();
			FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);
			ArchetypeData.ExecuteFunction(ExecutionContext, ExecuteFunction
				, EmptyMapping
				, ExecutionContext.GetEntityCollection().GetRanges()
				, ChunkCondition);
		}
	}
	else
	{
		// note that the following function will usually only resort to verifying that the data is up to date by
			// checking the version number. In rare cases when it would result in non trivial cost we actually
			// do need those calculations.
		CacheArchetypes(EntityManager);

		// if there's a chunk collection set by the external code - use that
		if (ExecutionContext.GetEntityCollection().IsSet())
		{
			const FMassArchetypeHandle& ArchetypeHandle = ExecutionContext.GetEntityCollection().GetArchetype();
			const int32 ArchetypeIndex = ValidArchetypes.Find(ArchetypeHandle);

			// if given ArchetypeHandle cannot be found in ValidArchetypes then it doesn't match the query's requirements
			if (ArchetypeIndex == INDEX_NONE)
			{
				UE_VLOG_UELOG(EntityManager.GetOwner(), LogMass, Log, TEXT("Attempted to execute FMassEntityQuery with an incompatible Archetype: %s")
					, *FMassDebugger::GetArchetypeRequirementCompatibilityDescription(*this, ArchetypeHandle));

#if WITH_MASSENTITY_DEBUG
				EntityManager.GetRequirementAccessDetector().ReleaseAccess(*this);
#endif // WITH_MASSENTITY_DEBUG
				return;
			}

			ExecutionContext.SetFragmentRequirements(*this);

			FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);
			ArchetypeData.ExecuteFunction(ExecutionContext, ExecuteFunction
				, GetRequirementsMappingForArchetype(ArchetypeHandle)
				, ExecutionContext.GetEntityCollection().GetRanges()
				, ChunkCondition);
		}
		else
		{
			// it's important to set requirements after caching archetypes due to that call potentially sorting the requirements and the order is relevant here.
			ExecutionContext.SetFragmentRequirements(*this);

			for (int i = 0; i < ValidArchetypes.Num(); ++i)
			{
				const FMassArchetypeHandle& ArchetypeHandle = ValidArchetypes[i];
				FMassArchetypeData& ArchetypeData = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);
				ArchetypeData.ExecuteFunction(ExecutionContext, ExecuteFunction, ArchetypeFragmentMapping[i], ChunkCondition);
				ExecutionContext.ClearFragmentViews();
			}
		}
	}

#if WITH_MASSENTITY_DEBUG
	EntityManager.GetRequirementAccessDetector().ReleaseAccess(*this);
#endif

	ExecutionContext.ClearExecutionData();
	ExecutionContext.FlushDeferred();
}

void FMassEntityQuery::ParallelForEachEntityChunkInCollection(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections
	, FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext, const FMassExecuteFunction& ExecuteFunction
	, const EParallelForMode ParallelMode)
{
	if (UE::Mass::Tweakables::bAllowParallelExecution == false && ParallelMode != ForceParallelExecution)
	{
		ForEachEntityChunkInCollections(EntityCollections, EntityManager, ExecutionContext, ExecuteFunction);
		return;
	}

	ParallelFor(EntityCollections.Num(), [this, &EntityManager, &ExecutionContext, &ExecuteFunction, &EntityCollections, ParallelMode](const int32 JobIndex)
	{
		FMassExecutionContext LocalExecutionContext = ExecutionContext; 
		LocalExecutionContext.SetEntityCollection(EntityCollections[JobIndex]);
		ParallelForEachEntityChunk(EntityManager, LocalExecutionContext, ExecuteFunction, ParallelMode);
	});
}

void FMassEntityQuery::ParallelForEachEntityChunk(FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext
	, const FMassExecuteFunction& ExecuteFunction, const EParallelForMode ParallelMode)
{
	if (UE::Mass::Tweakables::bAllowParallelExecution == false && ParallelMode != ForceParallelExecution)
	{
		ForEachEntityChunk(EntityManager, ExecutionContext, ExecuteFunction);
		return;
	}

#if WITH_MASSENTITY_DEBUG
	checkf(ExecutionContext.ExecutionType == ExpectedContextType && (ExpectedContextType == EMassExecutionContextType::Local || bRegistered)
		, TEXT("ExecutionContextType mismatch, make sure all the queries run as part of processor execution are registered with some processor with a FMassEntityQuery::RegisterWithProcessor call"));

	EntityManager.GetRequirementAccessDetector().RequireAccess(*this);
#endif

	FScopedSubsystemRequirementsRestore SubsystemRestore(ExecutionContext);

	if (ExecutionContext.CacheSubsystemRequirements(*this) == false)
	{
		// required subsystems are not available, bail out.
		return;
	}

	struct FChunkJob
	{
		FMassArchetypeData& Archetype;
		const int32 ArchetypeIndex;
		const FMassArchetypeEntityCollection::FArchetypeEntityRange EntityRange;
	};
	TArray<FChunkJob> Jobs;

	if (FMassFragmentRequirements::IsEmpty())
	{
		if (ensureMsgf(ExecutionContext.GetEntityCollection().IsSet(), TEXT("Using empty queries is only supported in combination with Entity Collections that explicitly indicate entities to process")))
		{
			const FMassArchetypeHandle& ArchetypeHandle = ExecutionContext.GetEntityCollection().GetArchetype();
			FMassArchetypeData& ArchetypeRef = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);
			for (const FMassArchetypeEntityCollection::FArchetypeEntityRange& EntityRange : ExecutionContext.GetEntityCollection().GetRanges())
			{
				Jobs.Add({ ArchetypeRef, INDEX_NONE, EntityRange });
			}
		}
	}
	else
	{

		// note that the following function will usualy only resort to verifying that the data is up to date by
		// checking the version number. In rare cases when it would result in non trivial cost we actually
		// do need those calculations.
		CacheArchetypes(EntityManager);

		// if there's a chunk collection set by the external code - use that
		if (ExecutionContext.GetEntityCollection().IsSet())
		{
			const FMassArchetypeHandle& ArchetypeHandle = ExecutionContext.GetEntityCollection().GetArchetype();
			const int32 ArchetypeIndex = ValidArchetypes.Find(ArchetypeHandle);

			// if given ArchetypeHandle cannot be found in ValidArchetypes then it doesn't match the query's requirements
			if (ArchetypeIndex == INDEX_NONE)
			{
				UE_VLOG_UELOG(EntityManager.GetOwner(), LogMass, Log, TEXT("Attempted to execute FMassEntityQuery with an incompatible Archetype: %s")
					, *FMassDebugger::GetArchetypeRequirementCompatibilityDescription(*this, ExecutionContext.GetEntityCollection().GetArchetype()));

#if WITH_MASSENTITY_DEBUG
				EntityManager.GetRequirementAccessDetector().ReleaseAccess(*this);
#endif // WITH_MASSENTITY_DEBUG
				return;
			}

			ExecutionContext.SetFragmentRequirements(*this);

			FMassArchetypeData& ArchetypeRef = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);
			for (const FMassArchetypeEntityCollection::FArchetypeEntityRange& EntityRange : ExecutionContext.GetEntityCollection().GetRanges())
			{
				Jobs.Add({ ArchetypeRef, ArchetypeIndex, EntityRange });
			}
		}
		else
		{
			ExecutionContext.SetFragmentRequirements(*this);
			for (int ArchetypeIndex = 0; ArchetypeIndex < ValidArchetypes.Num(); ++ArchetypeIndex)
			{
				FMassArchetypeHandle& ArchetypeHandle = ValidArchetypes[ArchetypeIndex];
				FMassArchetypeData& ArchetypeRef = FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);
				const FMassArchetypeEntityCollection AsEntityCollection(ArchetypeHandle);
				for (const FMassArchetypeEntityCollection::FArchetypeEntityRange& EntityRange : AsEntityCollection.GetRanges())
				{
					Jobs.Add({ ArchetypeRef, ArchetypeIndex, EntityRange });
				}
			}
		}
	}

	if (Jobs.Num())
	{
		if (bAllowParallelCommands)
		{
			struct FTaskContext
			{
				FTaskContext() = default;

				TSharedPtr<FMassCommandBuffer> GetCommandBuffer()
				{
					if (!CommandBuffer)
					{
						// lazily creating the command buffer to ensure we create it in the same thread it's going to be used in
						CommandBuffer = MakeShared<FMassCommandBuffer>();
					}
					return CommandBuffer;
				}
			private:
				TSharedPtr<FMassCommandBuffer> CommandBuffer;
			};

			TArray<FTaskContext> TaskContext;

			ParallelForWithTaskContext(TaskContext, Jobs.Num(), [this, &ExecutionContext, &ExecuteFunction, &Jobs](FTaskContext& TaskContext, const int32 JobIndex)
				{
					FMassExecutionContext LocalExecutionContext = ExecutionContext;

					LocalExecutionContext.SetDeferredCommandBuffer(TaskContext.GetCommandBuffer());

					Jobs[JobIndex].Archetype.ExecutionFunctionForChunk(LocalExecutionContext, ExecuteFunction
						, Jobs[JobIndex].ArchetypeIndex != INDEX_NONE ? ArchetypeFragmentMapping[Jobs[JobIndex].ArchetypeIndex] : FMassQueryRequirementIndicesMapping()
						, Jobs[JobIndex].EntityRange
						, ChunkCondition);
				});

			// merge all command buffers
			for (FTaskContext& CommandContext : TaskContext)
			{
				ExecutionContext.Defer().MoveAppend(*CommandContext.GetCommandBuffer());
			}
		}
		else
		{
			ParallelFor(Jobs.Num(), [this, &ExecutionContext, &ExecuteFunction, &Jobs](const int32 JobIndex)
				{
					FMassExecutionContext LocalExecutionContext = ExecutionContext;
					Jobs[JobIndex].Archetype.ExecutionFunctionForChunk(LocalExecutionContext, ExecuteFunction
						, Jobs[JobIndex].ArchetypeIndex != INDEX_NONE ? ArchetypeFragmentMapping[Jobs[JobIndex].ArchetypeIndex] : FMassQueryRequirementIndicesMapping()
						, Jobs[JobIndex].EntityRange
						, ChunkCondition);
				});
		}
	}

#if WITH_MASSENTITY_DEBUG
	EntityManager.GetRequirementAccessDetector().ReleaseAccess(*this);
#endif

	ExecutionContext.ClearExecutionData();
	ExecutionContext.FlushDeferred();
}

int32 FMassEntityQuery::GetNumMatchingEntities(FMassEntityManager& InEntityManager)
{
	CacheArchetypes(InEntityManager);
	int32 TotalEntities = 0;
	for (FMassArchetypeHandle& ArchetypeHandle : ValidArchetypes)
	{
		if (const FMassArchetypeData* Archetype = FMassArchetypeHelper::ArchetypeDataFromHandle(ArchetypeHandle))
		{
			TotalEntities += Archetype->GetNumEntities();
		}
	}
	return TotalEntities;
}

int32 FMassEntityQuery::GetNumMatchingEntities(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections)
{
	int32 TotalEntities = 0;
	for (const FMassArchetypeEntityCollection& EntityCollection : EntityCollections)
	{
		if (DoesArchetypeMatchRequirements(EntityCollection.GetArchetype()))
		{
			for (const FMassArchetypeEntityCollection::FArchetypeEntityRange& EntityRange : EntityCollection.GetRanges())
			{
				TotalEntities += EntityRange.Length;
			}
		}
	}
	return TotalEntities;
}

bool FMassEntityQuery::HasMatchingEntities(FMassEntityManager& InEntityManager)
{
	CacheArchetypes(InEntityManager);

	for (FMassArchetypeHandle& ArchetypeHandle : ValidArchetypes)
	{
		const FMassArchetypeData* Archetype = FMassArchetypeHelper::ArchetypeDataFromHandle(ArchetypeHandle);
		if (Archetype && Archetype->GetNumEntities() > 0)
		{
			return true;
		}
	}
	return false;
}

const FMassQueryRequirementIndicesMapping& FMassEntityQuery::GetRequirementsMappingForArchetype(const FMassArchetypeHandle ArchetypeHandle) const
{
	static const FMassQueryRequirementIndicesMapping FallbackEmptyMapping;
	checkf(HasIncrementalChanges() == false, TEXT("Fetching cached fragments mapping while the query's cached data is out of sync!"));
	const int32 ArchetypeIndex = ValidArchetypes.Find(ArchetypeHandle);
	return ArchetypeIndex != INDEX_NONE ? ArchetypeFragmentMapping[ArchetypeIndex] : FallbackEmptyMapping;
}

void FMassEntityQuery::ExportRequirements(FMassExecutionRequirements& OutRequirements) const
{
	FMassSubsystemRequirements::ExportRequirements(OutRequirements);
	FMassFragmentRequirements::ExportRequirements(OutRequirements);
}

==============================================


=== MassEntity/Private/MassEntitySettings.cpp ===
=================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEntitySettings.h"
#include "MassProcessingPhaseManager.h"
#include "VisualLogger/VisualLogger.h"
#include "UObject/UObjectHash.h"
#include "Misc/CoreDelegates.h"
#include "MassArchetypeData.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(MassEntitySettings)

#if WITH_EDITOR
#include "ObjectEditorUtils.h"
#include "CoreGlobals.h"
#endif // WITH_EDITOR

//----------------------------------------------------------------------//
//  UMassEntitySettings
//----------------------------------------------------------------------//
UMassEntitySettings::UMassEntitySettings(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	for (int i = 0; i < (int)EMassProcessingPhase::MAX; ++i)
	{
		ProcessingPhasesConfig[i].PhaseName = *UEnum::GetDisplayValueAsText(EMassProcessingPhase(i)).ToString();
	}

	FCoreDelegates::OnPostEngineInit.AddUObject(this, &UMassEntitySettings::OnPostEngineInit);
}

void UMassEntitySettings::PostInitProperties()
{
	Super::PostInitProperties();
	ChunkMemorySize = UE::Mass::SanitizeChunkMemorySize(ChunkMemorySize);
}

void UMassEntitySettings::BeginDestroy()
{
	FCoreDelegates::OnPostEngineInit.RemoveAll(this);
	Super::BeginDestroy();
}

void UMassEntitySettings::OnPostEngineInit()
{
	bEngineInitialized = true;
	BuildProcessorListAndPhases();
}

void UMassEntitySettings::BuildProcessorListAndPhases()
{
	if (bInitialized == true || bEngineInitialized == false)
	{
		return;
	}

	BuildProcessorList();
	BuildPhases();
	bInitialized = true;

	OnInitializedEvent.Broadcast();
}

void UMassEntitySettings::BuildPhases()
{
#if WITH_EDITOR
	if (GIsEditor)
	{
		for (int i = 0; i < int(EMassProcessingPhase::MAX); ++i)
		{
			FMassProcessingPhaseConfig& PhaseConfig = ProcessingPhasesConfig[i];
			PhaseConfig.PhaseProcessor = NewObject<UMassCompositeProcessor>(this, PhaseConfig.PhaseGroupClass
				, *FString::Printf(TEXT("ProcessingPhase_%s"), *PhaseConfig.PhaseName.ToString()));
			PhaseConfig.PhaseProcessor->SetGroupName(PhaseConfig.PhaseName);
			PhaseConfig.PhaseProcessor->SetProcessingPhase(EMassProcessingPhase(i));
			const FString PhaseDumpDependencyGraphFileName = !DumpDependencyGraphFileName.IsEmpty() ? DumpDependencyGraphFileName + TEXT("_") + PhaseConfig.PhaseName.ToString() : FString();

			FMassProcessorDependencySolver::FResult Result;
			Result.DependencyGraphFileName = PhaseDumpDependencyGraphFileName;
			FMassPhaseProcessorConfigurationHelper Configurator(*PhaseConfig.PhaseProcessor, PhaseConfig, *this, EMassProcessingPhase(i));
			Configurator.bInitializeCreatedProcessors = false;
			Configurator.bIsGameRuntime = false;
			Configurator.Configure({}, EProcessorExecutionFlags::All, /*EntityManager=*/nullptr, &Result);

			if (Result.PrunedProcessorClasses.Num() > 0)
			{
				UE_VLOG_UELOG(this, LogMass, Warning, TEXT("Calculating dependencies for phase %s resulted in pruned processors:")
					, *PhaseConfig.PhaseName.ToString());
				for (const TSubclassOf<UMassProcessor>& ProcessorClass : Result.PrunedProcessorClasses)
				{
					UE_VLOG_UELOG(this, LogMass, Warning, TEXT("\t%s"), *GetNameSafe(ProcessorClass));
				}
				UE_VLOG_UELOG(this, LogMass, Warning, TEXT("Make sure EntityQueries owned by these processors got registered or override UMassProcessor::ShouldAllowQueryBasedPruning to return the appropriate result"));
			}

			FStringOutputDevice Ar;
			PhaseConfig.PhaseProcessor->DebugOutputDescription(Ar);
			PhaseConfig.Description = FText::FromString(Ar);
		}
	}
#endif // WITH_EDITOR
}

void UMassEntitySettings::BuildProcessorList()
{
	ProcessorCDOs.Reset();
	for (FMassProcessingPhaseConfig& PhaseConfig : ProcessingPhasesConfig)
	{
		PhaseConfig.ProcessorCDOs.Reset();
	}

	TArray<UClass*> SubClassess;
	GetDerivedClasses(UMassProcessor::StaticClass(), SubClassess);

	for (int i = SubClassess.Num() - 1; i >= 0; --i)
	{
		if (SubClassess[i]->HasAnyClassFlags(CLASS_Abstract))
		{
			continue;
		}

		UMassProcessor* ProcessorCDO = GetMutableDefault<UMassProcessor>(SubClassess[i]);
		// we explicitly restrict adding UMassCompositeProcessor. If needed by specific project a derived class can be added
		if (ProcessorCDO && SubClassess[i] != UMassCompositeProcessor::StaticClass()
#if WITH_EDITOR
			&& ProcessorCDO->ShouldShowUpInSettings()
#endif // WITH_EDITOR
		)
		{
			ProcessorCDOs.Add(ProcessorCDO);
			if (ProcessorCDO->ShouldAutoAddToGlobalList())
			{
				ProcessingPhasesConfig[int(ProcessorCDO->GetProcessingPhase())].ProcessorCDOs.Add(ProcessorCDO);
			}
		}
	}

	ProcessorCDOs.Sort([](UMassProcessor& LHS, UMassProcessor& RHS) {
		return LHS.GetName().Compare(RHS.GetName()) < 0;
	});
}

void UMassEntitySettings::AddToActiveProcessorsList(TSubclassOf<UMassProcessor> ProcessorClass)
{
	if (UMassProcessor* ProcessorCDO = GetMutableDefault<UMassProcessor>(ProcessorClass))
	{
		if (ProcessorClass == UMassCompositeProcessor::StaticClass())
		{
			UE_VLOG_UELOG(this, LogMass, Log, TEXT("%s adding MassCompositeProcessor to the global processor list is unsupported"), ANSI_TO_TCHAR(__FUNCTION__));
		}
		else if (ProcessorClass->HasAnyClassFlags(CLASS_Abstract))
		{
			UE_VLOG_UELOG(this, LogMass, Log, TEXT("%s unable to add %s due to it being an abstract class"), ANSI_TO_TCHAR(__FUNCTION__), *ProcessorClass->GetName());
		}
		else if (ProcessorCDOs.Find(ProcessorCDO) != INDEX_NONE)
		{
			UE_VLOG_UELOG(this, LogMass, Log, TEXT("%s already in global processor list"), *ProcessorCDO->GetName());
		}
		else 
		{
			ensureMsgf(ProcessorCDO->ShouldAutoAddToGlobalList() == false, TEXT("%s missing from the global list while it's already marked to be auto-added"), *ProcessorCDO->GetName());
			ProcessorCDOs.Add(ProcessorCDO);
			ProcessorCDO->SetShouldAutoRegisterWithGlobalList(true);
		}
	}
}

TConstArrayView<FMassProcessingPhaseConfig> UMassEntitySettings::GetProcessingPhasesConfig()
{
	BuildProcessorListAndPhases();
	return MakeArrayView(ProcessingPhasesConfig, int32(EMassProcessingPhase::MAX));
}

#if WITH_EDITOR
void UMassEntitySettings::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	static const FName ProcessorCDOsName = GET_MEMBER_NAME_CHECKED(UMassEntitySettings, ProcessorCDOs);
	static const FName ChunkMemorySizeName = GET_MEMBER_NAME_CHECKED(UMassEntitySettings, ChunkMemorySize);

	Super::PostEditChangeProperty(PropertyChangedEvent);

	if (PropertyChangedEvent.ChangeType == EPropertyChangeType::ArrayAdd)
	{
		// ignore adding elements to arrays since it would be 'None' at first
		return;
	}

	if (PropertyChangedEvent.Property)
	{
		const FName PropName = PropertyChangedEvent.Property->GetFName();
		if (PropName == ProcessorCDOsName)
		{
			BuildProcessorList();
		}
		else if (PropName == ChunkMemorySizeName)
		{
			ChunkMemorySize = UE::Mass::SanitizeChunkMemorySize(ChunkMemorySize);
		}

		BuildPhases();
		OnSettingsChange.Broadcast(PropertyChangedEvent);
	}
}

void UMassEntitySettings::PostEditChangeChainProperty(struct FPropertyChangedChainEvent& PropertyChangedEvent)
{
	static const FName AutoRegisterName = TEXT("bAutoRegisterWithProcessingPhases");

	Super::PostEditChangeChainProperty(PropertyChangedEvent);

	FProperty* Property = PropertyChangedEvent.Property;
	FProperty* MemberProperty = nullptr;
	FEditPropertyChain::TDoubleLinkedListNode* LastPropertyNode = PropertyChangedEvent.PropertyChain.GetActiveMemberNode();
	while (LastPropertyNode && LastPropertyNode->GetNextNode())
	{
		LastPropertyNode = LastPropertyNode->GetNextNode();
	}

	if (LastPropertyNode)
	{
		MemberProperty = LastPropertyNode->GetValue();
	}

	if (MemberProperty && MemberProperty->GetFName() == AutoRegisterName)
	{
		BuildProcessorList();
	}
}
#endif // WITH_EDITOR


=================================================


=== MassEntity/Private/MassEntitySubsystem.cpp ===
==================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEntitySubsystem.h"
#include "HAL/IConsoleManager.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(MassEntitySubsystem)

namespace UE::Mass::Private
{
	static bool bEnableMassConcurrentReserveRuntime = true;
	static int32 ConcurrentReserveMaxEntityCount = 1 << 27;
	static int32 ConcurrentReserveMaxEntitiesPerPage = 1 << 16;

	namespace
	{
		FAutoConsoleVariableRef CVars[] = {
			{
				TEXT("Mass.ConcurrentReserve.Enable"),
				bEnableMassConcurrentReserveRuntime,
				TEXT("Enable Mass's concurrent reserve feature in runtime"),
				ECVF_Default
			},
			{
				TEXT("Mass.ConcurrentReserve.MaxEntityCount"),
				ConcurrentReserveMaxEntityCount,
				TEXT("Set maximum number of permissible entities.  Must be power of 2."),
				ECVF_Default
			},
			{
				TEXT("Mass.ConcurrentReserve.EntitiesPerPage"),
				ConcurrentReserveMaxEntitiesPerPage,
				TEXT("Set number of entities per page. Must be power of 2. Larger reduces fixed memory overhead of FEntityData page lookup but requires bigger contiguous memory blocks per page"),
				ECVF_Default
			}
		};
	}
}
//////////////////////////////////////////////////////////////////////
// UMassEntitySubsystem

UMassEntitySubsystem::UMassEntitySubsystem()
	: EntityManager(MakeShareable(new FMassEntityManager(this)))
{
	
}

void UMassEntitySubsystem::GetResourceSizeEx(FResourceSizeEx& CumulativeResourceSize)
{
	Super::GetResourceSizeEx(CumulativeResourceSize);
	EntityManager->GetResourceSizeEx(CumulativeResourceSize);
}

void UMassEntitySubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	FMassEntityManagerStorageInitParams InitializationParams;
	
	if (UE::Mass::Private::bEnableMassConcurrentReserveRuntime)
	{
		InitializationParams.Emplace<FMassEntityManager_InitParams_Concurrent>(
			FMassEntityManager_InitParams_Concurrent
			{
				.MaxEntityCount = static_cast<uint32>(UE::Mass::Private::ConcurrentReserveMaxEntityCount),
				.MaxEntitiesPerPage = static_cast<uint32>(UE::Mass::Private::ConcurrentReserveMaxEntitiesPerPage)
			});
	}
	else
	{
		InitializationParams.Emplace<FMassEntityManager_InitParams_SingleThreaded>();
	}
	
	EntityManager->Initialize(InitializationParams);
	HandleLateCreation();
}

void UMassEntitySubsystem::PostInitialize()
{
	Super::PostInitialize();
	// this needs to be done after all the subsystems have been initialized since some processors might want to access
	// them during processors' initialization
	EntityManager->PostInitialize();
}

void UMassEntitySubsystem::Deinitialize()
{
	EntityManager->Deinitialize();
	EntityManager.Reset();
	Super::Deinitialize();
}

#if WITH_MASSENTITY_DEBUG
//////////////////////////////////////////////////////////////////////
// Debug commands

FAutoConsoleCommandWithWorldArgsAndOutputDevice GPrintArchetypesCmd(
	TEXT("EntityManager.PrintArchetypes"),
	TEXT("Prints information about all archetypes in the current world"),
	FConsoleCommandWithWorldArgsAndOutputDeviceDelegate::CreateStatic(
		[](const TArray<FString>& Params, UWorld* World, FOutputDevice& Ar)
		{
			if (const UMassEntitySubsystem* EntitySubsystem = World ? World->GetSubsystem<UMassEntitySubsystem>() : nullptr)
			{
				EntitySubsystem->GetEntityManager().DebugPrintArchetypes(Ar);
			}
			else
			{
				Ar.Logf(ELogVerbosity::Error, TEXT("Failed to find Entity Subsystem for world %s"), *GetPathNameSafe(World));
			}
		}));
#endif // WITH_MASSENTITY_DEBUG
==================================================


=== MassEntity/Private/MassEntityTypes.cpp ===
==============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEntityTypes.h"

#include "MassArchetypeData.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(MassEntityTypes)

DEFINE_STAT(STAT_Mass_Total);

DEFINE_TYPEBITSET(FMassFragmentBitSet);
DEFINE_TYPEBITSET(FMassTagBitSet);
DEFINE_TYPEBITSET(FMassChunkFragmentBitSet);
DEFINE_TYPEBITSET(FMassSharedFragmentBitSet);
DEFINE_TYPEBITSET(FMassConstSharedFragmentBitSet);
DEFINE_TYPEBITSET(FMassExternalSubsystemBitSet);

//-----------------------------------------------------------------------------
// FMassArchetypeSharedFragmentValues
//-----------------------------------------------------------------------------
FConstSharedStruct FMassArchetypeSharedFragmentValues::AddConstSharedFragment(const FConstSharedStruct& Fragment)
{
	check(Fragment.IsValid());
	const UScriptStruct* StructType = Fragment.GetScriptStruct();
	if (!ensureMsgf(ContainsType(StructType) == false, TEXT("Shared Fragment of type %s already added to FMassArchetypeSharedFragmentValues"), *GetNameSafe(StructType)))
	{
		FConstSharedStruct ExistingSharedStruct = GetConstSharedFragmentStruct(StructType);
		ensureMsgf(ExistingSharedStruct.IsValid(), TEXT("Shared Fragment of type %s already added as NON-CONST shared struct"), *GetNameSafe(StructType));
		return ExistingSharedStruct;
	}

	check(StructType);
	ConstSharedFragmentBitSet.Add(*StructType);
	FConstSharedStruct& StructInstance = ConstSharedFragments.Add_GetRef(Fragment);
	DirtyHashCache();
	return StructInstance;
}

FSharedStruct FMassArchetypeSharedFragmentValues::AddSharedFragment(const FSharedStruct& Fragment)
{
	check(Fragment.IsValid());
	const UScriptStruct* StructType = Fragment.GetScriptStruct();
	if (!ensureMsgf(ContainsType(StructType) == false, TEXT("Shared Fragment of type %s already added to FMassArchetypeSharedFragmentValues"), *GetNameSafe(StructType)))
	{
		FSharedStruct ExistingSharedStruct = GetSharedFragmentStruct(StructType);
		ensureMsgf(ExistingSharedStruct.IsValid(), TEXT("Shared Fragment of type %s already added as CONST shared struct"), *GetNameSafe(StructType));
		return ExistingSharedStruct;
	}

	check(StructType);
	SharedFragmentBitSet.Add(*StructType);
	FSharedStruct& StructInstance = SharedFragments.Add_GetRef(Fragment);
	DirtyHashCache();
	return StructInstance;
}

void FMassArchetypeSharedFragmentValues::ReplaceSharedFragments(TConstArrayView<FSharedStruct> Fragments)
{
	DirtyHashCache();
	for (const FSharedStruct& NewFragment : Fragments)
	{
		const UScriptStruct* NewFragScriptStruct = NewFragment.GetScriptStruct();
		check(NewFragScriptStruct);

		bool bEntryFound = false;
		for (FSharedStruct& MyFragment : SharedFragments)
		{
			if (MyFragment.GetScriptStruct() == NewFragScriptStruct)
			{
				MyFragment = NewFragment;
				bEntryFound = true;
				break;
			}
		}
		ensureMsgf(bEntryFound, TEXT("Existing fragment of type %s could not be found"), *GetNameSafe(NewFragScriptStruct));
	}
}

uint32 FMassArchetypeSharedFragmentValues::CalculateHash() const
{
	if (!testableEnsureMsgf(bSorted, TEXT("Expecting the containers to be sorted for the hash caluclation to be consistent")))
	{
		return 0;
	}

	// Fragments are not part of the uniqueness 
	uint32 Hash = 0;
	for (const FConstSharedStruct& Fragment : ConstSharedFragments)
	{
		Hash = PointerHash(Fragment.GetMemory(), Hash);
	}

	for (const FSharedStruct& Fragment : SharedFragments)
	{
		Hash = PointerHash(Fragment.GetMemory(), Hash);
	}

	return Hash;
}

namespace UE::Mass::Private
{
	template<typename TSharedStruct>
	int32 CountInvalid(const TArray<TSharedStruct>& View)
	{
		int32 Count = 0;
		for (const TSharedStruct& SharedStruct : View)
		{
			const UScriptStruct* StructType = SharedStruct.GetScriptStruct();
			Count += StructType ? 0 : 1;
		}
		return Count;
	}

	/** Note that this function assumes that both ViewA and ViewB do not contain duplicates */
	template<typename TSharedStruct, bool bSkipNulls=true>
	bool ArraysHaveSameContents(const TArray<TSharedStruct>& ViewA, const TArray<TSharedStruct>& ViewB)
	{
		if constexpr (bSkipNulls)
		{
			const int32 NullstCountA = CountInvalid(ViewA);
			const int32 NullstCountB = CountInvalid(ViewB);
			if (ViewA.Num() - NullstCountA != ViewB.Num() - NullstCountB)
			{
				return false;
			}
		}
		else if (ViewA.Num() != ViewB.Num())
		{
			return false;
		}

		for (const TSharedStruct& SharedStruct : ViewA)
		{
			const UScriptStruct* StructType = SharedStruct.GetScriptStruct();
			if constexpr (bSkipNulls)
			{
				if (StructType == nullptr)
				{
					continue;
				}
			}
			const int32 FragmentIndex = ViewB.IndexOfByPredicate(FStructTypeEqualOperator(StructType));
			if (FragmentIndex == INDEX_NONE)
			{
				return false;
			}
			if (ViewB[FragmentIndex].CompareStructValues(SharedStruct) == false)
			{
				return false;
			}
		}

		return true;
	}
}

bool FMassArchetypeSharedFragmentValues::HasSameValues(const FMassArchetypeSharedFragmentValues& Other) const
{
	if (SharedFragmentBitSet.IsEquivalent(Other.SharedFragmentBitSet) == false
		|| ConstSharedFragmentBitSet.IsEquivalent(Other.ConstSharedFragmentBitSet) == false)
	{
		return false;
	}

	return UE::Mass::Private::ArraysHaveSameContents(SharedFragments, Other.GetSharedFragments())
		&& UE::Mass::Private::ArraysHaveSameContents(ConstSharedFragments, Other.GetConstSharedFragments());
}

int32 FMassArchetypeSharedFragmentValues::Append(const FMassArchetypeSharedFragmentValues& Other)
{
	int32 AddedOrModifiedCount = 0;

	for (const FSharedStruct& SharedStruct : Other.GetSharedFragments())
	{
		const UScriptStruct* StructType = SharedStruct.GetScriptStruct();
		check(StructType);
		if (SharedFragmentBitSet.Contains(*StructType))
		{
			const int32 FragmentIndex = SharedFragments.IndexOfByPredicate(FStructTypeEqualOperator(StructType));
			if (testableEnsureMsgf(FragmentIndex != INDEX_NONE, TEXT("%hs trying to switch const fragment to non-const, type %s")
				, __FUNCTION__, *StructType->GetName()))
			{
				SharedFragments[FragmentIndex] = SharedStruct;
				++AddedOrModifiedCount;
			}
		}
		else
		{
			SharedFragments.Add(SharedStruct);
			++AddedOrModifiedCount;
		}
	}

	for (const FConstSharedStruct& SharedStruct : Other.GetConstSharedFragments())
	{
		const UScriptStruct* StructType = SharedStruct.GetScriptStruct();
		check(StructType);
		if (ConstSharedFragmentBitSet.Contains(*StructType))
		{
			const int32 FragmentIndex = ConstSharedFragments.IndexOfByPredicate(FStructTypeEqualOperator(StructType));
			if (testableEnsureMsgf(FragmentIndex != INDEX_NONE, TEXT("%hs trying to switch non-const fragment to const, type %s")
				, __FUNCTION__, *StructType->GetName()))
			{
				ConstSharedFragments[FragmentIndex] = SharedStruct;
				++AddedOrModifiedCount;
			}
		}
		else
		{
			ConstSharedFragments.Add(SharedStruct);
			++AddedOrModifiedCount;
		}
	}

	SharedFragmentBitSet += Other.SharedFragmentBitSet;
	ConstSharedFragmentBitSet += Other.ConstSharedFragmentBitSet;
	DirtyHashCache();

	return AddedOrModifiedCount;
}

int32 FMassArchetypeSharedFragmentValues::Remove(const FMassSharedFragmentBitSet& SharedFragmentToRemoveBitSet)
{
	int32 RemovedCount = 0;
	FMassSharedFragmentBitSet CommonFragments = (SharedFragmentBitSet & SharedFragmentToRemoveBitSet);
	FMassSharedFragmentBitSet::FIndexIterator It = CommonFragments.GetIndexIterator();
	while(It)
	{
		const UScriptStruct* StructType = CommonFragments.GetTypeAtIndex(*It);
		check(StructType);

		const int32 RegularFragmentIndex = SharedFragments.IndexOfByPredicate(FStructTypeEqualOperator(StructType));
		if (RegularFragmentIndex != INDEX_NONE)
		{
			SharedFragments[RegularFragmentIndex].Reset();
			++RemovedCount;
		}

		++It;
	}

	if (RemovedCount)
	{
		SharedFragments.RemoveAllSwap([](const FSharedStruct& SharedStruct) { return !SharedStruct.IsValid(); });
		SharedFragmentBitSet -= CommonFragments;
		DirtyHashCache();
	}
	return RemovedCount;
}

int32 FMassArchetypeSharedFragmentValues::Remove(const FMassConstSharedFragmentBitSet& ConstSharedFragmentToRemoveBitSet)
{
	int32 RemovedCount = 0;
	FMassConstSharedFragmentBitSet CommonFragments = (ConstSharedFragmentBitSet & ConstSharedFragmentToRemoveBitSet);
	FMassConstSharedFragmentBitSet::FIndexIterator It = CommonFragments.GetIndexIterator();
	while(It)
	{
		const UScriptStruct* StructType = CommonFragments.GetTypeAtIndex(*It);
		check(StructType);

		const int32 RegularFragmentIndex = ConstSharedFragments.IndexOfByPredicate(FStructTypeEqualOperator(StructType));
		if (RegularFragmentIndex != INDEX_NONE)
		{
			ConstSharedFragments[RegularFragmentIndex].Reset();
			++RemovedCount;
		}

		++It;
	}

	if (RemovedCount)
	{
		ConstSharedFragments.RemoveAllSwap([](const FConstSharedStruct& SharedStruct) { return !SharedStruct.IsValid(); });
		ConstSharedFragmentBitSet -= CommonFragments;
		DirtyHashCache();
	}
	return RemovedCount;
}

//-----------------------------------------------------------------------------
// FMassGenericPayloadView
//-----------------------------------------------------------------------------
void FMassGenericPayloadView::SwapElementsToEnd(const int32 StartIndex, int32 NumToMove)
{
	check(StartIndex >= 0 && NumToMove >= 0);

	if (UNLIKELY(NumToMove <= 0 || StartIndex < 0))
	{
		return;
	}

	TArray<uint8, TInlineAllocator<16>> MovedElements;

	for (FStructArrayView& StructArrayView : Content)
	{
		check((StartIndex + NumToMove) <= StructArrayView.Num());
		if (StartIndex + NumToMove >= StructArrayView.Num() - 1)
		{
			// nothing to do here, the elements are already at the back
			continue;
		}

		uint8* ViewData = static_cast<uint8*>(StructArrayView.GetData());
		const uint32 ElementSize = StructArrayView.GetTypeSize();
		const uint32 MovedStartOffset = StartIndex * ElementSize;
		const uint32 MovedSize = NumToMove * ElementSize;
		const uint32 MoveOffset = (StructArrayView.Num() - (StartIndex + NumToMove)) * ElementSize;

		MovedElements.Reset();
		MovedElements.Append(ViewData + MovedStartOffset, MovedSize);
		FMemory::Memmove(ViewData + MovedStartOffset, ViewData + MovedStartOffset + MovedSize, MoveOffset);
		FMemory::Memcpy(ViewData + MovedStartOffset + MoveOffset, MovedElements.GetData(), MovedSize);
	}
}

//-----------------------------------------------------------------------------
// FMassArchetypeCreationParams
//-----------------------------------------------------------------------------
FMassArchetypeCreationParams::FMassArchetypeCreationParams(const FMassArchetypeData& Archetype)
	: ChunkMemorySize(static_cast<int32>(Archetype.GetChunkAllocSize()))
{
}
==============================================


=== MassEntity/Private/MassEntityUtils.cpp ===
==============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEntityUtils.h"
#include "MassEntityTypes.h"
#include "MassArchetypeTypes.h"
#include "MassEntityManager.h"
#include "MassEntitySubsystem.h"
#include "Engine/EngineBaseTypes.h"
#include "Engine/World.h"
#if WITH_EDITOR
#include "Editor.h"
#endif // WITH_EDITOR

namespace UE::Mass::Utils
{
EProcessorExecutionFlags GetProcessorExecutionFlagsForWorld(const UWorld& World)
{
#if WITH_EDITOR
	if (World.IsEditorWorld() && !World.IsGameWorld())
	{
		return EProcessorExecutionFlags::EditorWorld;
	}
#endif // WITH_EDITOR

	switch (const ENetMode NetMode = World.GetNetMode())
	{
	case NM_ListenServer:
		return EProcessorExecutionFlags::Client | EProcessorExecutionFlags::Server;
	case NM_DedicatedServer:
		return EProcessorExecutionFlags::Server;
	case NM_Client:
		return EProcessorExecutionFlags::Client;
	case NM_Standalone:
		return EProcessorExecutionFlags::Standalone;
	default:
		checkf(false, TEXT("Unsupported ENetMode type (%i) found while determining MASS processor execution flags."), NetMode);
		return EProcessorExecutionFlags::None;
	}
}

EProcessorExecutionFlags DetermineProcessorExecutionFlags(const UWorld* World, EProcessorExecutionFlags ExecutionFlagsOverride)
{
	if (ExecutionFlagsOverride != EProcessorExecutionFlags::None)
	{
		return ExecutionFlagsOverride;
	}
	if (World)
	{
		return GetProcessorExecutionFlagsForWorld(*World);
	}

#if WITH_EDITOR
	if (GEditor)
	{
		return EProcessorExecutionFlags::Editor;
	}
#endif // WITH_EDITOR
	return EProcessorExecutionFlags::All;
}

uint8 DetermineProcessorSupportedTickTypes(const UWorld* World)
{
#if WITH_EDITOR
	if (World != nullptr && GetProcessorExecutionFlagsForWorld(*World) == EProcessorExecutionFlags::EditorWorld)
	{
		return MAX_uint8;
	}
#endif // WITH_EDITOR
	return (1 << LEVELTICK_All) | (1 << LEVELTICK_TimeOnly);
}

void CreateEntityCollections(const FMassEntityManager& EntityManager, const TConstArrayView<FMassEntityHandle> Entities
	, const FMassArchetypeEntityCollection::EDuplicatesHandling DuplicatesHandling, TArray<FMassArchetypeEntityCollection>& OutEntityCollections)
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("Mass_CreateSparseChunks");

	TMap<const FMassArchetypeHandle, TArray<FMassEntityHandle>> ArchetypeToEntities;

	for (const FMassEntityHandle& Entity : Entities)
	{
		if (EntityManager.IsEntityValid(Entity))
		{
			FMassArchetypeHandle Archetype = EntityManager.GetArchetypeForEntityUnsafe(Entity);
			TArray<FMassEntityHandle>& PerArchetypeEntities = ArchetypeToEntities.FindOrAdd(Archetype);
			PerArchetypeEntities.Add(Entity);
		}
	}

	for (auto& Pair : ArchetypeToEntities)
	{
		OutEntityCollections.Add(FMassArchetypeEntityCollection(Pair.Key, Pair.Value, DuplicatesHandling));
	}
}

FMassEntityManager* GetEntityManager(const UWorld* World)
{
	UMassEntitySubsystem* EntityManager = UWorld::GetSubsystem<UMassEntitySubsystem>(World);
	return EntityManager
		? &EntityManager->GetMutableEntityManager()
		: nullptr;
}

FMassEntityManager& GetEntityManagerChecked(const UWorld& World)
{
	UMassEntitySubsystem* EntityManager = UWorld::GetSubsystem<UMassEntitySubsystem>(&World);
	check(EntityManager);
	return EntityManager->GetMutableEntityManager();
}

} // namespace UE::Mass::Utils
==============================================


=== MassEntity/Private/MassEntityView.cpp ===
=============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEntityView.h"
#include "MassEntityManager.h"
#include "MassArchetypeData.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(MassEntityView)


//////////////////////////////////////////////////////////////////////
// FMassEntityView
FMassEntityView::FMassEntityView(const FMassArchetypeHandle& ArchetypeHandle, FMassEntityHandle InEntity)
{
	Entity = InEntity;
	Archetype = &FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);
	EntityDataHandle = Archetype->MakeEntityHandle(Entity);
}

FMassEntityView::FMassEntityView(const FMassEntityManager& EntityManager, FMassEntityHandle InEntity)
{
	Entity = InEntity;
	const FMassArchetypeHandle ArchetypeHandle = EntityManager.GetArchetypeForEntity(Entity);
	Archetype = &FMassArchetypeHelper::ArchetypeDataFromHandleChecked(ArchetypeHandle);
	EntityDataHandle = Archetype->MakeEntityHandle(Entity);
}

FMassEntityView FMassEntityView::TryMakeView(const FMassEntityManager& EntityManager, FMassEntityHandle InEntity)
{
	const FMassArchetypeHandle ArchetypeHandle = EntityManager.GetArchetypeForEntity(InEntity);
	return ArchetypeHandle.IsValid() ? FMassEntityView(ArchetypeHandle, InEntity) : FMassEntityView();
}

void* FMassEntityView::GetFragmentPtr(const UScriptStruct& FragmentType) const
{
	checkSlow(Archetype && EntityDataHandle.IsValid());
	if (const int32* FragmentIndex = Archetype->GetFragmentIndex(&FragmentType))
	{
		// failing the below Find means given entity's archetype is missing given FragmentType
		return Archetype->GetFragmentData(*FragmentIndex, EntityDataHandle);
	}
	return nullptr;
}

void* FMassEntityView::GetFragmentPtrChecked(const UScriptStruct& FragmentType) const
{
	checkSlow(Archetype && EntityDataHandle.IsValid());
	const int32 FragmentIndex = Archetype->GetFragmentIndexChecked(&FragmentType);
	return Archetype->GetFragmentData(FragmentIndex, EntityDataHandle);
}

const void* FMassEntityView::GetConstSharedFragmentPtr(const UScriptStruct& FragmentType) const
{
	const FConstSharedStruct* SharedFragment = Archetype->GetSharedFragmentValues(Entity).GetConstSharedFragments().FindByPredicate(FStructTypeEqualOperator(&FragmentType));
	return (SharedFragment != nullptr) ? SharedFragment->GetMemory() : nullptr;
}

const void* FMassEntityView::GetConstSharedFragmentPtrChecked(const UScriptStruct& FragmentType) const
{
	const FConstSharedStruct* SharedFragment = Archetype->GetSharedFragmentValues(Entity).GetConstSharedFragments().FindByPredicate(FStructTypeEqualOperator(&FragmentType));
	check(SharedFragment != nullptr);
	return SharedFragment->GetMemory();
}

void* FMassEntityView::GetSharedFragmentPtr(const UScriptStruct& FragmentType) const
{
	const FSharedStruct* SharedFragment = Archetype->GetSharedFragmentValues(Entity).GetSharedFragments().FindByPredicate(FStructTypeEqualOperator(&FragmentType));
	// @todo: fix constness, should the getter be non-const too?
	return (SharedFragment != nullptr) ? const_cast<uint8*>(SharedFragment->GetMemory()) : nullptr;
}

void* FMassEntityView::GetSharedFragmentPtrChecked(const UScriptStruct& FragmentType) const
{
	const FSharedStruct* SharedFragment = Archetype->GetSharedFragmentValues(Entity).GetSharedFragments().FindByPredicate(FStructTypeEqualOperator(&FragmentType));
	check(SharedFragment != nullptr);
	// @todo: fix constness, should the getter be non-const too?
	return const_cast<uint8*>(SharedFragment->GetMemory());
}

bool FMassEntityView::HasTag(const UScriptStruct& TagType) const
{
	checkSlow(Archetype && EntityDataHandle.IsValid());
	return Archetype->HasTagType(&TagType);
}

=============================================


=== MassEntity/Private/MassExecutionContext.cpp ===
===================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassExecutionContext.h"
#include "MassArchetypeData.h"


//////////////////////////////////////////////////////////////////////////
// FMassExecutionContext

FMassExecutionContext::FMassExecutionContext(FMassEntityManager& InEntityManager, const float InDeltaTimeSeconds, const bool bInFlushDeferredCommands)
	: SubsystemAccess(InEntityManager.GetWorld())
	, DeltaTimeSeconds(InDeltaTimeSeconds)
	, EntityManager(InEntityManager.AsShared())
	, bFlushDeferredCommands(bInFlushDeferredCommands)
{
}

void FMassExecutionContext::FlushDeferred()
{
	if (bFlushDeferredCommands && DeferredCommandBuffer)
	{
		EntityManager->FlushCommands(DeferredCommandBuffer);
	}
}

void FMassExecutionContext::ClearExecutionData()
{
	FragmentViews.Reset();
	ChunkFragmentViews.Reset();
	ConstSharedFragmentViews.Reset();
	SharedFragmentViews.Reset();
	CurrentArchetypeCompositionDescriptor.Reset();
	ChunkSerialModificationNumber = -1;
}

bool FMassExecutionContext::CacheSubsystemRequirements(const FMassSubsystemRequirements& SubsystemRequirements)
{
	return SubsystemAccess.CacheSubsystemRequirements(SubsystemRequirements);
}

void FMassExecutionContext::SetEntityCollection(const FMassArchetypeEntityCollection& InEntityCollection)
{
	check(EntityCollection.IsEmpty());
	EntityCollection = InEntityCollection;
}

void FMassExecutionContext::SetEntityCollection(FMassArchetypeEntityCollection&& InEntityCollection)
{
	check(EntityCollection.IsEmpty());
	EntityCollection = MoveTemp(InEntityCollection);
}

void FMassExecutionContext::SetFragmentRequirements(const FMassFragmentRequirements& FragmentRequirements)
{
	FragmentViews.Reset();
	for (const FMassFragmentRequirementDescription& Requirement : FragmentRequirements.GetFragmentRequirements())
	{
		if (Requirement.RequiresBinding())
		{
			FragmentViews.Emplace(Requirement);
		}
	}

	ChunkFragmentViews.Reset();
	for (const FMassFragmentRequirementDescription& Requirement : FragmentRequirements.GetChunkFragmentRequirements())
	{
		if (Requirement.RequiresBinding())
		{
			ChunkFragmentViews.Emplace(Requirement);
		}
	}

	ConstSharedFragmentViews.Reset();
	for (const FMassFragmentRequirementDescription& Requirement : FragmentRequirements.GetConstSharedFragmentRequirements())
	{
		if (Requirement.RequiresBinding())
		{
			ConstSharedFragmentViews.Emplace(Requirement);
		}
	}

	SharedFragmentViews.Reset();
	for (const FMassFragmentRequirementDescription& Requirement : FragmentRequirements.GetSharedFragmentRequirements())
	{
		if (Requirement.RequiresBinding())
		{
			SharedFragmentViews.Emplace(Requirement);
		}
	}
}

UWorld* FMassExecutionContext::GetWorld() 
{ 
	return EntityManager->GetWorld(); 
}

===================================================


=== MassEntity/Private/MassExecutor.cpp ===
===========================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassExecutor.h"
#include "MassProcessingTypes.h"
#include "MassProcessor.h"
#include "MassCommandBuffer.h"
#include "MassExecutionContext.h"
#include "ProfilingDebugging/CpuProfilerTrace.h"

namespace UE::Mass::Executor
{

FORCEINLINE void ExecuteProcessors(FMassEntityManager& EntityManager, TArrayView<UMassProcessor* const> Processors, FMassExecutionContext& ExecutionContext)
{
	for (UMassProcessor* Proc : Processors)
	{
		Proc->CallExecute(EntityManager, ExecutionContext);
	}
}

void Run(FMassRuntimePipeline& RuntimePipeline, FMassProcessingContext& ProcessingContext)
{
	if (!ensure(ProcessingContext.EntityManager) || 
		!ensure(ProcessingContext.DeltaSeconds >= 0.f) ||
		!ensure(RuntimePipeline.GetProcessors().Find(nullptr) == INDEX_NONE))
	{
		return;
	}

	TRACE_CPUPROFILER_EVENT_SCOPE_STR("MassExecutor Run Pipeline")
	RunProcessorsView(RuntimePipeline.GetMutableProcessors(), ProcessingContext);
}

void RunSparse(FMassRuntimePipeline& RuntimePipeline, FMassProcessingContext& ProcessingContext, FMassArchetypeHandle Archetype, TConstArrayView<FMassEntityHandle> Entities)
{
	if (!ensure(ProcessingContext.EntityManager) ||
		!ensure(RuntimePipeline.GetProcessors().Find(nullptr) == INDEX_NONE) ||
		RuntimePipeline.Num() == 0 ||
		!ensureMsgf(Archetype.IsValid(), TEXT("The Archetype passed in to UE::Mass::Executor::RunSparse is invalid")))
	{
		return;
	}

	TRACE_CPUPROFILER_EVENT_SCOPE_STR("MassExecutor RunSparseEntities");

	const FMassArchetypeEntityCollection EntityCollection(Archetype, Entities, FMassArchetypeEntityCollection::NoDuplicates);
	RunProcessorsView(RuntimePipeline.GetMutableProcessors(), ProcessingContext, MakeArrayView(&EntityCollection, 1));
}

void RunSparse(FMassRuntimePipeline& RuntimePipeline, FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection& EntityCollection)
{
	if (!ensure(ProcessingContext.EntityManager) ||
		!ensure(RuntimePipeline.GetProcessors().Find(nullptr) == INDEX_NONE) ||
		RuntimePipeline.Num() == 0 ||
		!ensureMsgf(EntityCollection.GetArchetype().IsValid(), TEXT("The Archetype of EntityCollection passed in to UE::Mass::Executor::RunSparse is invalid")))
	{
		return;
	}

	TRACE_CPUPROFILER_EVENT_SCOPE_STR("MassExecutor RunSparse");

	RunProcessorsView(RuntimePipeline.GetMutableProcessors(), ProcessingContext, MakeArrayView(&EntityCollection, 1));
}

void Run(UMassProcessor& Processor, FMassProcessingContext& ProcessingContext)
{
	if (!ensure(ProcessingContext.EntityManager) || !ensure(ProcessingContext.DeltaSeconds >= 0.f))
	{
		return;
	}

	TRACE_CPUPROFILER_EVENT_SCOPE_STR("MassExecutor Run")

	UMassProcessor* ProcPtr = &Processor;
	RunProcessorsView(MakeArrayView(&ProcPtr, 1), ProcessingContext);
}

void RunProcessorsView(TArrayView<UMassProcessor* const> Processors, FMassProcessingContext& ProcessingContext, TConstArrayView<FMassArchetypeEntityCollection> EntityCollections)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(RunProcessorsView);

	if (!ProcessingContext.EntityManager)
	{
		UE_LOG(LogMass, Error, TEXT("%s ProcessingContext.EntityManager is null. Baling out."), ANSI_TO_TCHAR(__FUNCTION__));
		return;
	}
#if WITH_MASSENTITY_DEBUG
	if (Processors.Find(nullptr) != INDEX_NONE)
	{
		UE_LOG(LogMass, Error, TEXT("%s input Processors contains nullptr. Baling out."), ANSI_TO_TCHAR(__FUNCTION__));
		return;
	}
#endif // WITH_MASSENTITY_DEBUG

	TRACE_CPUPROFILER_EVENT_SCOPE_STR("MassExecutor RunProcessorsView")

	FMassExecutionContext ExecutionContext(*ProcessingContext.EntityManager.Get(), ProcessingContext.DeltaSeconds);

	// if ProcessingContext points at a valid CommandBuffer use that one, otherwise manually create a new command buffer 
	// to let the default one still be used by code unaware of mass processing
	TSharedPtr<FMassCommandBuffer> CommandBuffer = ProcessingContext.CommandBuffer 
		? ProcessingContext.CommandBuffer : MakeShareable(new FMassCommandBuffer());
	ExecutionContext.SetDeferredCommandBuffer(CommandBuffer);
	ExecutionContext.SetFlushDeferredCommands(false);
	ExecutionContext.SetAuxData(ProcessingContext.AuxData);
	ExecutionContext.SetExecutionType(EMassExecutionContextType::Processor);

	FMassEntityManager& EntityManager = *ProcessingContext.EntityManager.Get();
	{
		TRACE_CPUPROFILER_EVENT_SCOPE_STR("Execute Processors")
		
		FMassEntityManager::FScopedProcessing ProcessingScope = EntityManager.NewProcessingScope();

		if (EntityCollections.Num() == 0)
		{
			ExecuteProcessors(*ProcessingContext.EntityManager, Processors, ExecutionContext);
		}
		else
		{
			// @todo change ExecutionContext to contain a TConstArrayView of collections. Will lead up to changes in the entity query as well.
			for (const FMassArchetypeEntityCollection& Collection : EntityCollections)
			{
				ExecutionContext.SetEntityCollection(Collection);
				ExecuteProcessors(*ProcessingContext.EntityManager, Processors, ExecutionContext);
				ExecutionContext.ClearEntityCollection();
			}
		}
	}
	
	if (ProcessingContext.bFlushCommandBuffer)
	{		
		TRACE_CPUPROFILER_EVENT_SCOPE_STR("Flush Deferred Commands")
		
		ExecutionContext.SetFlushDeferredCommands(true);
		// append the commands added from other, non-processor sources (like MassAgentSubsystem)
		ensure(!EntityManager.Defer().IsFlushing());
		ensure(!ExecutionContext.Defer().IsFlushing());
		ExecutionContext.Defer().MoveAppend(EntityManager.Defer());
		ExecutionContext.FlushDeferred();
	}
	// else make sure we don't just lose the commands. Append to the command buffer requested via
	// ProcessingContext.CommandBuffer or to the default EntityManager's command buffer.
	else if (CommandBuffer->HasPendingCommands() && CommandBuffer != ProcessingContext.CommandBuffer)
	{
		if (ProcessingContext.CommandBuffer)
		{
			ProcessingContext.CommandBuffer->MoveAppend(*CommandBuffer.Get());
		}
		else if (CommandBuffer.Get() != &EntityManager.Defer())
		{
			EntityManager.AppendCommands(CommandBuffer);
		}
	}
}

struct FMassExecutorDoneTask
{
	FMassExecutorDoneTask(const FMassExecutionContext& InExecutionContext, TFunction<void()> InOnDoneNotification, const FString& InDebugName)
		: ExecutionContext(InExecutionContext)
		, OnDoneNotification(InOnDoneNotification)
		, DebugName(InDebugName)
	{
	}
	static TStatId GetStatId()
	{
		RETURN_QUICK_DECLARE_CYCLE_STAT(FMassExecutorDoneTask, STATGROUP_TaskGraphTasks);
	}

	static ENamedThreads::Type GetDesiredThread() { return ENamedThreads::GameThread; }
	static ESubsequentsMode::Type GetSubsequentsMode() { return ESubsequentsMode::TrackSubsequents; }
	void DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)
	{
		TRACE_CPUPROFILER_EVENT_SCOPE_STR("Flush Deferred Commands Parallel");
		SCOPE_CYCLE_COUNTER(STAT_Mass_Total);

		FMassEntityManager& EntityManagerRef = ExecutionContext.GetEntityManagerChecked();

		if (&ExecutionContext.Defer() != &EntityManagerRef.Defer())
		{
			ExecutionContext.Defer().MoveAppend(EntityManagerRef.Defer());
		}

		UE_LOG(LogMass, Verbose, TEXT("MassExecutor %s tasks DONE"), *DebugName);
		ExecutionContext.SetFlushDeferredCommands(true);
		ExecutionContext.FlushDeferred();

		OnDoneNotification();
	}
private:
	FMassExecutionContext ExecutionContext;
	TFunction<void()> OnDoneNotification;
	FString DebugName;
};

FGraphEventRef TriggerParallelTasks(UMassProcessor& Processor, FMassProcessingContext& ProcessingContext, TFunction<void()> OnDoneNotification)
{
	if (!ProcessingContext.EntityManager)
	{
		UE_LOG(LogMass, Error, TEXT("%s ProcessingContext.EntityManager is null. Baling out."), ANSI_TO_TCHAR(__FUNCTION__));
		return FGraphEventRef();
	}

	TRACE_CPUPROFILER_EVENT_SCOPE_STR("MassExecutor RunParallel")

	// not going through FMassEntityManager::CreateExecutionContext on purpose - we do need a separate command buffer
	FMassExecutionContext ExecutionContext(*ProcessingContext.EntityManager.Get(), ProcessingContext.DeltaSeconds);
	TSharedPtr<FMassCommandBuffer> CommandBuffer = ProcessingContext.CommandBuffer
		? ProcessingContext.CommandBuffer : MakeShareable(new FMassCommandBuffer());
	ExecutionContext.SetDeferredCommandBuffer(CommandBuffer);
	ExecutionContext.SetFlushDeferredCommands(false);
	ExecutionContext.SetAuxData(ProcessingContext.AuxData);
	ExecutionContext.SetExecutionType(EMassExecutionContextType::Processor);

	FGraphEventRef CompletionEvent;
	{
		TRACE_CPUPROFILER_EVENT_SCOPE_STR("Dispatch Processors")
		CompletionEvent = Processor.DispatchProcessorTasks(ProcessingContext.EntityManager, ExecutionContext, {});
	}

	if (CompletionEvent.IsValid())
	{
		const FGraphEventArray Prerequisites = { CompletionEvent };
		CompletionEvent = TGraphTask<FMassExecutorDoneTask>::CreateTask(&Prerequisites)
			.ConstructAndDispatchWhenReady(ExecutionContext, OnDoneNotification, Processor.GetName());
	}

	return CompletionEvent;
}

//-----------------------------------------------------------------------------
// DEPRECATED
//-----------------------------------------------------------------------------
void RunProcessorsView(TArrayView<UMassProcessor* const> Processors, FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection* EntityCollection)
{
	if (EntityCollection)
	{
		RunProcessorsView(Processors, ProcessingContext, MakeArrayView(EntityCollection, 1));
	}
	else
	{
		RunProcessorsView(Processors, ProcessingContext);
	}
}

} // namespace UE::Mass::Executor

===========================================


=== MassEntity/Private/MassObserverManager.cpp ===
==================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassObserverManager.h"
#include "MassEntityManager.h"
#include "MassEntitySubsystem.h"
#include "MassExecutor.h"
#include "MassProcessingTypes.h"
#include "MassObserverRegistry.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(MassObserverManager)

namespace UE::Mass::ObserverManager
{
	namespace Tweakables
	{
		// Used as a template parameter for TInlineAllocator that we use when gathering UScriptStruct* of the observed types to process.
		constexpr int InlineAllocatorElementsForOverlapTypes = 8;
	} // Tweakables

	namespace Private
	{
	// a helper function to reduce code duplication in FMassObserverManager::Initialize
	template<typename TBitSet, typename TPointerType>
	void SetUpObservers(FMassEntityManager& EntityManager, const EProcessorExecutionFlags WorldExecutionFlags, UObject& Owner
		, const TMap<TPointerType, FMassProcessorClassCollection>& RegisteredObserverTypes, TBitSet& ObservedBitSet, FMassObserversMap& Observers)
	{
		ObservedBitSet.Reset();

		for (auto It : RegisteredObserverTypes)
		{
			if (It.Value.ClassCollection.Num() == 0)
			{
				continue;
			}

			ObservedBitSet.Add(*It.Key);
			FMassRuntimePipeline& Pipeline = (*Observers).FindOrAdd(It.Key);

			for (const TSubclassOf<UMassProcessor>& ProcessorClass : It.Value.ClassCollection)
			{
				if (ProcessorClass->GetDefaultObject<UMassProcessor>()->ShouldExecute(WorldExecutionFlags))
				{
					Pipeline.AppendProcessor(ProcessorClass, Owner);
				}
			}
			Pipeline.Initialize(Owner);
		}
	};
	} // Private
} // UE::Mass::ObserverManager

//----------------------------------------------------------------------//
// FMassObserverManager
//----------------------------------------------------------------------//
FMassObserverManager::FMassObserverManager()
	: EntityManager(GetMutableDefault<UMassEntitySubsystem>()->GetMutableEntityManager())
{

}

FMassObserverManager::FMassObserverManager(FMassEntityManager& Owner)
	: EntityManager(Owner)
{

}

void FMassObserverManager::Initialize()
{
	// instantiate initializers
	const UMassObserverRegistry& Registry = UMassObserverRegistry::Get();

	UObject* Owner = EntityManager.GetOwner();
	check(Owner);
	const UWorld* World = Owner->GetWorld();
	const EProcessorExecutionFlags WorldExecutionFlags = UE::Mass::Utils::DetermineProcessorExecutionFlags(World);

	using UE::Mass::ObserverManager::Private::SetUpObservers;
	for (int i = 0; i < (int)EMassObservedOperation::MAX; ++i)
	{
		SetUpObservers(EntityManager, WorldExecutionFlags, *Owner, *Registry.FragmentObservers[i], ObservedFragments[i], FragmentObservers[i]);
		SetUpObservers(EntityManager, WorldExecutionFlags, *Owner, *Registry.TagObservers[i], ObservedTags[i], TagObservers[i]);
	}
}

void FMassObserverManager::DeInitialize()
{
	for (int32 i = 0; i < (int32)EMassObservedOperation::MAX; ++i)
	{
		(*FragmentObservers[i]).Empty();
		(*TagObservers[i]).Empty();
	}
}

bool FMassObserverManager::OnPostEntitiesCreated(const FMassArchetypeEntityCollection& EntityCollection)
{
	return OnPostEntitiesCreated(MakeArrayView(&EntityCollection , 1));
}

bool FMassObserverManager::OnPostEntitiesCreated(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections)
{
	FMassProcessingContext ProcessingContext(EntityManager, /*DeltaSeconds=*/0.f);
	// requesting not to flush commands since handling creation of new entities can result in multiple collections of
	// processors being executed and flushing commands between these runs would ruin EntityCollection since entities could
	// get their composition changed and get moved to new archetypes
	ProcessingContext.bFlushCommandBuffer = false;
	ProcessingContext.CommandBuffer = MakeShareable(new FMassCommandBuffer());

	if (OnPostEntitiesCreated(ProcessingContext, EntityCollections))
	{
		EntityManager.FlushCommands(ProcessingContext.CommandBuffer);
		return true;
	}
	return false;
}

// DEPRECATED
bool FMassObserverManager::OnPostEntitiesCreated(FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection& EntityCollection)
{
	return OnPostEntitiesCreated(ProcessingContext, MakeArrayView(&EntityCollection, 1));
}

bool FMassObserverManager::OnPostEntitiesCreated(FMassProcessingContext& ProcessingContext, TConstArrayView<FMassArchetypeEntityCollection> EntityCollections)
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("OnPostEntitiesCreated")

	check(ProcessingContext.EntityManager);

	bool bReturnValue = false;

	for (const FMassArchetypeEntityCollection& Collection : EntityCollections)
	{
		const FMassArchetypeCompositionDescriptor& ArchetypeComposition = ProcessingContext.EntityManager->GetArchetypeComposition(Collection.GetArchetype());
		bReturnValue = OnCompositionChanged(ProcessingContext, Collection, ArchetypeComposition, EMassObservedOperation::Add) || bReturnValue;
	}

	return bReturnValue;
}

bool FMassObserverManager::OnPreEntitiesDestroyed(const FMassArchetypeEntityCollection& EntityCollection)
{
	FMassProcessingContext ProcessingContext(EntityManager, /*DeltaSeconds=*/0.f);
	ProcessingContext.bFlushCommandBuffer = false;
	ProcessingContext.CommandBuffer = MakeShareable(new FMassCommandBuffer());

	if (OnPreEntitiesDestroyed(ProcessingContext, EntityCollection))
	{
		EntityManager.FlushCommands(ProcessingContext.CommandBuffer);
		return true;
	}
	return false;
}

bool FMassObserverManager::OnPreEntitiesDestroyed(FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection& EntityCollection)
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("OnPreEntitiesDestroyed")

	check(ProcessingContext.EntityManager);
	const FMassArchetypeCompositionDescriptor& ArchetypeComposition = ProcessingContext.EntityManager->GetArchetypeComposition(EntityCollection.GetArchetype());
	
	return OnCompositionChanged(ProcessingContext, EntityCollection, ArchetypeComposition, EMassObservedOperation::Remove);
}

bool FMassObserverManager::OnPreEntityDestroyed(const FMassArchetypeCompositionDescriptor& ArchetypeComposition, const FMassEntityHandle Entity)
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("OnPreEntityDestroyed")
	return OnCompositionChanged(Entity, ArchetypeComposition, EMassObservedOperation::Remove);
}

bool FMassObserverManager::OnCompositionChanged(FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection& EntityCollection, const FMassArchetypeCompositionDescriptor& CompositionDelta, const EMassObservedOperation Operation)
{
	using UE::Mass::ObserverManager::Tweakables::InlineAllocatorElementsForOverlapTypes;

	const FMassFragmentBitSet FragmentOverlap = ObservedFragments[(uint8)Operation].GetOverlap(CompositionDelta.Fragments);
	const bool bHasFragmentsOverlap = !FragmentOverlap.IsEmpty();
	const FMassTagBitSet TagOverlap = ObservedTags[(uint8)Operation].GetOverlap(CompositionDelta.Tags);
	const bool bHasTagsOverlap = !TagOverlap.IsEmpty();

	if (bHasFragmentsOverlap || bHasTagsOverlap)
	{
		TArray<const UScriptStruct*, TInlineAllocator<InlineAllocatorElementsForOverlapTypes>> ObservedTypesOverlap;

		if (bHasFragmentsOverlap)
		{
			FragmentOverlap.ExportTypes(ObservedTypesOverlap);

			HandleFragmentsImpl(ProcessingContext, EntityCollection, ObservedTypesOverlap, FragmentObservers[(uint8)Operation]);
		}

		if (bHasTagsOverlap)
		{
			ObservedTypesOverlap.Reset();
			TagOverlap.ExportTypes(ObservedTypesOverlap);

			HandleFragmentsImpl(ProcessingContext, EntityCollection, ObservedTypesOverlap, TagObservers[(uint8)Operation]);
		}

		return true;
	}

	return false;
}

bool FMassObserverManager::OnCompositionChanged(const FMassEntityHandle Entity, const FMassArchetypeCompositionDescriptor& CompositionDelta, const EMassObservedOperation Operation)
{
	using UE::Mass::ObserverManager::Tweakables::InlineAllocatorElementsForOverlapTypes;

	const FMassFragmentBitSet FragmentOverlap = ObservedFragments[(uint8)Operation].GetOverlap(CompositionDelta.Fragments);
	const bool bHasFragmentsOverlap = !FragmentOverlap.IsEmpty();
	const FMassTagBitSet TagOverlap = ObservedTags[(uint8)Operation].GetOverlap(CompositionDelta.Tags);
	const bool bHasTagsOverlap = !TagOverlap.IsEmpty();

	if (bHasFragmentsOverlap || bHasTagsOverlap)
	{
		TArray<const UScriptStruct*, TInlineAllocator<InlineAllocatorElementsForOverlapTypes>> ObservedTypesOverlap;
		FMassProcessingContext ProcessingContext(EntityManager, /*DeltaSeconds=*/0.f);
		ProcessingContext.bFlushCommandBuffer = false;
		const FMassArchetypeHandle ArchetypeHandle = EntityManager.GetArchetypeForEntity(Entity);

		if (bHasFragmentsOverlap)
		{
			FragmentOverlap.ExportTypes(ObservedTypesOverlap);

			HandleFragmentsImpl(ProcessingContext, FMassArchetypeEntityCollection(ArchetypeHandle, MakeArrayView(&Entity, 1)
				, FMassArchetypeEntityCollection::NoDuplicates), ObservedTypesOverlap, FragmentObservers[(uint8)Operation]);
		}

		if (bHasTagsOverlap)
		{
			ObservedTypesOverlap.Reset();
			TagOverlap.ExportTypes(ObservedTypesOverlap);

			HandleFragmentsImpl(ProcessingContext, FMassArchetypeEntityCollection(ArchetypeHandle, MakeArrayView(&Entity, 1)
				, FMassArchetypeEntityCollection::NoDuplicates), ObservedTypesOverlap, TagObservers[(uint8)Operation]);
		}
	}

	return bHasFragmentsOverlap || bHasTagsOverlap;
}

void FMassObserverManager::OnFragmentOrTagOperation(const UScriptStruct& FragmentOrTagType, const FMassArchetypeEntityCollection& EntityCollection, const EMassObservedOperation Operation)
{
	check(FragmentOrTagType.IsChildOf(FMassFragment::StaticStruct()) || FragmentOrTagType.IsChildOf(FMassTag::StaticStruct()));

	if (FragmentOrTagType.IsChildOf(FMassFragment::StaticStruct()))
	{
		if (ObservedFragments[(uint8)Operation].Contains(FragmentOrTagType))
		{
			HandleSingleEntityImpl(FragmentOrTagType, EntityCollection, FragmentObservers[(uint8)Operation]);
		}
	}
	else if (ObservedTags[(uint8)Operation].Contains(FragmentOrTagType))
	{
		HandleSingleEntityImpl(FragmentOrTagType, EntityCollection, TagObservers[(uint8)Operation]);
	}
}

void FMassObserverManager::HandleFragmentsImpl(FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection& EntityCollection
	, TArrayView<const UScriptStruct*> ObservedTypes
	/*, const FMassFragmentBitSet& FragmentsBitSet*/, FMassObserversMap& HandlersContainer)
{	
	TRACE_CPUPROFILER_EVENT_SCOPE(MassObserver_HandleFragmentsImpl);

	check(ObservedTypes.Num() > 0);

	for (const UScriptStruct* Type : ObservedTypes)
	{		
		ProcessingContext.AuxData.InitializeAs(Type);
		FMassRuntimePipeline& Pipeline = (*HandlersContainer).FindChecked(Type);

		UE::Mass::Executor::RunProcessorsView(Pipeline.GetMutableProcessors(), ProcessingContext, MakeArrayView(&EntityCollection, 1));
	}
}

void FMassObserverManager::HandleSingleEntityImpl(const UScriptStruct& FragmentType, const FMassArchetypeEntityCollection& EntityCollection, FMassObserversMap& HandlersContainer)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(MassObserver_HandleSingleEntityImpl);

	FMassProcessingContext ProcessingContext(EntityManager, /*DeltaSeconds=*/0.f);
	ProcessingContext.bFlushCommandBuffer = false;
	ProcessingContext.AuxData.InitializeAs(&FragmentType);
	FMassRuntimePipeline& Pipeline = (*HandlersContainer).FindChecked(&FragmentType);

	UE::Mass::Executor::RunProcessorsView(Pipeline.GetMutableProcessors(), ProcessingContext, MakeArrayView(&EntityCollection, 1));
}

void FMassObserverManager::AddObserverInstance(const UScriptStruct& FragmentOrTagType, const EMassObservedOperation Operation, UMassProcessor& ObserverProcessor)
{
	checkSlow(FragmentOrTagType.IsChildOf(FMassFragment::StaticStruct()) || FragmentOrTagType.IsChildOf(FMassTag::StaticStruct()));

	FMassRuntimePipeline* Pipeline = nullptr;

	if (FragmentOrTagType.IsChildOf(FMassFragment::StaticStruct()))
	{
		Pipeline = &(*FragmentObservers[(uint8)Operation]).FindOrAdd(&FragmentOrTagType);
		ObservedFragments[(uint8)Operation].Add(FragmentOrTagType);
	}
	else
	{
		Pipeline = &(*TagObservers[(uint8)Operation]).FindOrAdd(&FragmentOrTagType);
		ObservedTags[(uint8)Operation].Add(FragmentOrTagType);
	}
	Pipeline->AppendProcessor(ObserverProcessor);

	// calling initialize to ensure the given processor is related to the same EntityManager
	if (UObject* Owner = EntityManager.GetOwner())
	{	
		ObserverProcessor.Initialize(*Owner);
	}
}

void FMassObserverManager::RemoveObserverInstance(const UScriptStruct& FragmentOrTagType, const EMassObservedOperation Operation, UMassProcessor& ObserverProcessor)
{
	if (!ensure(FragmentOrTagType.IsChildOf(FMassFragment::StaticStruct()) || FragmentOrTagType.IsChildOf(FMassTag::StaticStruct())))
	{
		return;
	}

	bool bIsFragmentObserver = FragmentOrTagType.IsChildOf(FMassFragment::StaticStruct());

	TMap<TObjectPtr<const UScriptStruct>, FMassRuntimePipeline>& ObserversMap =
		bIsFragmentObserver ? *FragmentObservers[(uint8)Operation] : *TagObservers[(uint8)Operation];

	FMassRuntimePipeline* Pipeline = ObserversMap.Find(&FragmentOrTagType);
	if (!ensureMsgf(Pipeline, TEXT("Trying to remove an observer for a fragment/tag that does not seem to be observed.")))
	{
		return;
	}
	Pipeline->RemoveProcessor(ObserverProcessor);

	if (Pipeline->Num() == 0)
	{
		ObserversMap.Remove(&FragmentOrTagType);
		if (bIsFragmentObserver)
		{
			ObservedFragments[(uint8)Operation].Remove(FragmentOrTagType);
		}
		else
		{
			ObservedTags[(uint8)Operation].Remove(FragmentOrTagType);
		}
	}
}

==================================================


=== MassEntity/Private/MassObserverProcessor.cpp ===
====================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassObserverProcessor.h"
#include "MassObserverRegistry.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(MassObserverProcessor)

//----------------------------------------------------------------------//
// UMassObserverProcessor
//----------------------------------------------------------------------//
UMassObserverProcessor::UMassObserverProcessor()
{
	bAutoRegisterWithProcessingPhases = false;
#if WITH_EDITORONLY_DATA
	bCanShowUpInSettings = false;
#endif // WITH_EDITORONLY_DATA
}

void UMassObserverProcessor::PostInitProperties()
{
	Super::PostInitProperties();

	UClass* MyClass = GetClass();
	CA_ASSUME(MyClass);

	if (HasAnyFlags(RF_ClassDefaultObject) && MyClass->HasAnyClassFlags(CLASS_Abstract) == false)
	{
		if (ensure(ObservedType != nullptr && Operation != EMassObservedOperation::MAX))
		{
			Register();
		}
		else
		{
			UE_LOG(LogMass, Error, TEXT("%s attempting to register %s while it\'s misconfigured, Type: %s, Operation: %s")
				, ANSI_TO_TCHAR(__FUNCTION__), *MyClass->GetName(), *GetNameSafe(ObservedType), *UEnum::GetValueAsString(Operation));
		}
	}
}

void UMassObserverProcessor::Register()
{
	if (bAutoRegisterWithObserverRegistry)
	{
		check(ObservedType);
		UMassObserverRegistry::GetMutable().RegisterObserver(*ObservedType, Operation, GetClass());
	}
}



====================================================


=== MassEntity/Private/MassObserverRegistry.cpp ===
===================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassObserverRegistry.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(MassObserverRegistry)

//----------------------------------------------------------------------//
// UMassObserverRegistry
//----------------------------------------------------------------------//
UMassObserverRegistry::UMassObserverRegistry()
{
	// there can be only one!
	check(HasAnyFlags(RF_ClassDefaultObject));
}

void UMassObserverRegistry::RegisterObserver(const UScriptStruct& ObservedType, const EMassObservedOperation Operation, TSubclassOf<UMassProcessor> ObserverClass)
{
	check(ObserverClass);
	checkSlow(ObservedType.IsChildOf(FMassFragment::StaticStruct()) || ObservedType.IsChildOf(FMassTag::StaticStruct()));

	if (ObservedType.IsChildOf(FMassFragment::StaticStruct()))
	{
		(*FragmentObservers[(uint8)Operation]).FindOrAdd(&ObservedType).ClassCollection.AddUnique(ObserverClass);
	}
	else
	{
		(*TagObservers[(uint8)Operation]).FindOrAdd(&ObservedType).ClassCollection.AddUnique(ObserverClass);
	}
}



===================================================


=== MassEntity/Private/MassProcessingPhaseManager.cpp ===
=========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassProcessingPhaseManager.h"
#include "MassProcessingTypes.h"
#include "MassDebugger.h"
#include "MassProcessor.h"
#include "MassExecutor.h"
#include "MassEntityManager.h"
#include "MassEntitySubsystem.h"
#include "VisualLogger/VisualLogger.h"
#include "Engine/World.h"
#include "MassCommandBuffer.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(MassProcessingPhaseManager)

#define LOCTEXT_NAMESPACE "Mass"

DECLARE_CYCLE_STAT(TEXT("Mass Phase Tick"), STAT_Mass_PhaseTick, STATGROUP_Mass);

namespace UE::Mass::Tweakables
{
	bool bFullyParallel = MASS_DO_PARALLEL;
	bool bMakePrePhysicsTickFunctionHighPriority = true;

	FAutoConsoleVariableRef CVars[] = {
		{TEXT("mass.FullyParallel"), bFullyParallel, TEXT("Enables mass processing distribution to all available thread (via the task graph)")},
		{TEXT("mass.MakePrePhysicsTickFunctionHighPriority"), bMakePrePhysicsTickFunctionHighPriority, TEXT("Whether to make the PrePhysics tick function high priority - can minimise GameThread waits by starting parallel work as soon as possible")},
	};
}

namespace UE::Mass::Private
{
	ETickingGroup PhaseToTickingGroup[int(EMassProcessingPhase::MAX)]
	{
		ETickingGroup::TG_PrePhysics, // EMassProcessingPhase::PrePhysics
		ETickingGroup::TG_StartPhysics, // EMassProcessingPhase::StartPhysics
		ETickingGroup::TG_DuringPhysics, // EMassProcessingPhase::DuringPhysics
		ETickingGroup::TG_EndPhysics,	// EMassProcessingPhase::EndPhysics
		ETickingGroup::TG_PostPhysics,	// EMassProcessingPhase::PostPhysics
		ETickingGroup::TG_LastDemotable, // EMassProcessingPhase::FrameEnd
	};
} // UE::Mass::Private

//----------------------------------------------------------------------//
//  FMassProcessingPhase
//----------------------------------------------------------------------//
FMassProcessingPhase::FMassProcessingPhase()
{
	bCanEverTick = true;
	bStartWithTickEnabled = false;
	SupportedTickTypes = (1 << LEVELTICK_All) | (1 << LEVELTICK_TimeOnly);
}

void FMassProcessingPhase::ExecuteTick(float DeltaTime, ELevelTick TickType, ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)
{
	if (ShouldTick(TickType) == false)
	{
		return;
	}

	SCOPE_CYCLE_COUNTER(STAT_Mass_PhaseTick);
	SCOPE_CYCLE_COUNTER(STAT_Mass_Total);

	checkf(PhaseManager, TEXT("Manager is null which is not a supported case. Either this FMassProcessingPhase has not been initialized properly or it's been left dangling after the FMassProcessingPhase owner got destroyed."));

	TRACE_CPUPROFILER_EVENT_SCOPE_TEXT(*FString::Printf(TEXT("FMassProcessingPhase::ExecuteTick %s"), *UEnum::GetValueAsString(Phase)));

	PhaseManager->OnPhaseStart(*this);
	{
		LLM_SCOPE_BYNAME(TEXT("Mass/PhaseStartDelegate"));
		OnPhaseStart.Broadcast(DeltaTime);
	}

	check(PhaseProcessor);
	
	FMassEntityManager& EntityManager = PhaseManager->GetEntityManagerRef();
	FMassProcessingContext Context(EntityManager, DeltaTime);

	bIsDuringMassProcessing = true;

	if (bRunInParallelMode)
	{
		bool bWorkRequested = false;
		if (PhaseProcessor->IsEmpty() == false)
		{
			const FGraphEventRef PipelineCompletionEvent = UE::Mass::Executor::TriggerParallelTasks(*PhaseProcessor, Context, [this, DeltaTime]()
				{
					OnParallelExecutionDone(DeltaTime);
				});

			if (PipelineCompletionEvent.IsValid())
			{
				MyCompletionGraphEvent->DontCompleteUntil(PipelineCompletionEvent);
				bWorkRequested = true;
			}
		}
		if (bWorkRequested == false)
		{
			OnParallelExecutionDone(DeltaTime);
		}
	}
	else
	{
		UE::Mass::Executor::Run(*PhaseProcessor, Context);

		{
			LLM_SCOPE_BYNAME(TEXT("Mass/PhaseEndDelegate"));
			OnPhaseEnd.Broadcast(DeltaTime);
		}
		PhaseManager->OnPhaseEnd(*this);
		bIsDuringMassProcessing = false;
	}
}

void FMassProcessingPhase::OnParallelExecutionDone(const float DeltaTime)
{
	bIsDuringMassProcessing = false;
	{
		LLM_SCOPE_BYNAME(TEXT("Mass/PhaseEndDelegate"));
		OnPhaseEnd.Broadcast(DeltaTime);
	}
	check(PhaseManager);
	PhaseManager->OnPhaseEnd(*this);
}

FString FMassProcessingPhase::DiagnosticMessage()
{
	return (PhaseManager ? PhaseManager->GetName() : TEXT("NULL-MassProcessingPhaseManager")) + TEXT("[ProcessingPhaseTick]");
}

FName FMassProcessingPhase::DiagnosticContext(bool bDetailed)
{
	return TEXT("MassProcessingPhase");
}

void FMassProcessingPhase::Initialize(FMassProcessingPhaseManager& InPhaseManager, const EMassProcessingPhase InPhase, const ETickingGroup InTickGroup, UMassCompositeProcessor& InPhaseProcessor)
{
	PhaseManager = &InPhaseManager;
	Phase = InPhase;
	TickGroup = InTickGroup;
	PhaseProcessor = &InPhaseProcessor;
}

//----------------------------------------------------------------------//
// FPhaseProcessorConfigurator
//----------------------------------------------------------------------//
void FMassPhaseProcessorConfigurationHelper::Configure(TArrayView<UMassProcessor* const> DynamicProcessors
	, EProcessorExecutionFlags InWorldExecutionFlags, const TSharedPtr<FMassEntityManager>& EntityManager
	, FMassProcessorDependencySolver::FResult* OutOptionalResult)
{
	FMassRuntimePipeline TmpPipeline(InWorldExecutionFlags);
	TmpPipeline.CreateFromArray(PhaseConfig.ProcessorCDOs, ProcessorOuter);
	for (UMassProcessor* Processor : DynamicProcessors)
	{
		checkf(Processor != nullptr, TEXT("Dynamic processor provided to MASS is null."));
		if (Processor->GetProcessingPhase() == Phase)
		{
			TmpPipeline.AppendProcessor(*Processor);
		}
	}

	TArray<FMassProcessorOrderInfo> SortedProcessors;
	FMassProcessorDependencySolver Solver(TmpPipeline.GetMutableProcessors(), bIsGameRuntime);

	Solver.ResolveDependencies(SortedProcessors, EntityManager, OutOptionalResult);

	PhaseProcessor.UpdateProcessorsCollection(SortedProcessors, InWorldExecutionFlags);

#if WITH_MASSENTITY_DEBUG
	for (const FMassProcessorOrderInfo& ProcessorOrderInfo : SortedProcessors)
	{
		TmpPipeline.RemoveProcessor(*ProcessorOrderInfo.Processor);
	}
	
	if (TmpPipeline.Num())
	{
		UE_VLOG_UELOG(&PhaseProcessor, LogMass, Verbose, TEXT("Discarding processors due to not having anything to do (no relevant Archetypes):"));
		for (UMassProcessor* Processor : TmpPipeline.GetProcessors())
		{
			UE_VLOG_UELOG(&PhaseProcessor, LogMass, Verbose, TEXT("\t%s"), *Processor->GetProcessorName());
			// we're ignoring dynamic processors since these instances were explicitly created by the user, and we don't
			// want to destroy them - the user would need to re-add them every time we recalculate the dependency graph
			if (Processor->IsDynamic() == false)
			{
				Processor->MarkAsGarbage();
			}
		}
	}
#endif // WITH_MASSENTITY_DEBUG

	if (Solver.IsSolvingForSingleThread() == false)
	{
		PhaseProcessor.BuildFlatProcessingGraph(SortedProcessors);
	}

	if (bInitializeCreatedProcessors)
	{
		PhaseProcessor.Initialize(ProcessorOuter);
	}
}

//----------------------------------------------------------------------//
// FMassProcessingPhaseManager
//----------------------------------------------------------------------//
void FMassProcessingPhaseManager::Initialize(UObject& InOwner, TConstArrayView<FMassProcessingPhaseConfig> InProcessingPhasesConfig, const FString& DependencyGraphFileName)
{
	UWorld* World = InOwner.GetWorld();
#if WITH_EDITOR
	const bool bCreateProcessorGraphPreview = (World != nullptr) && (World->IsEditorWorld() && !World->IsGameWorld());
#endif // WITH_EDITOR
	Owner = &InOwner;
	ProcessingPhasesConfig = InProcessingPhasesConfig;

	ProcessorExecutionFlags = UE::Mass::Utils::DetermineProcessorExecutionFlags(World, ProcessorExecutionFlags);
	const uint8 SupportedTickTypes = UE::Mass::Utils::DetermineProcessorSupportedTickTypes(World);

	for (int PhaseAsInt = 0; PhaseAsInt < int(EMassProcessingPhase::MAX); ++PhaseAsInt)
	{		
		const EMassProcessingPhase Phase = EMassProcessingPhase(PhaseAsInt);
		FMassProcessingPhase& ProcessingPhase = ProcessingPhases[PhaseAsInt];

		UMassCompositeProcessor* PhaseProcessor = NewObject<UMassCompositeProcessor>(&InOwner, UMassCompositeProcessor::StaticClass()
			, *FString::Printf(TEXT("ProcessingPhase_%s"), *UEnum::GetDisplayValueAsText(Phase).ToString()));
	
		check(PhaseProcessor);
		ProcessingPhase.Initialize(*this, Phase, UE::Mass::Private::PhaseToTickingGroup[PhaseAsInt], *PhaseProcessor);
		ProcessingPhase.SupportedTickTypes = SupportedTickTypes;

		REDIRECT_OBJECT_TO_VLOG(PhaseProcessor, &InOwner);
		PhaseProcessor->SetProcessingPhase(Phase);
		PhaseProcessor->SetGroupName(FName(FString::Printf(TEXT("%s Group"), *UEnum::GetDisplayValueAsText(Phase).ToString())));

#if WITH_MASSENTITY_DEBUG
		FStringOutputDevice Ar;
		PhaseProcessor->DebugOutputDescription(Ar);
		UE_VLOG(&InOwner, LogMass, Log, TEXT("Setting new group processor for phase %s:\n%s"), *UEnum::GetValueAsString(Phase), *Ar);
#endif // WITH_MASSENTITY_DEBUG

#if WITH_EDITOR
		if (bCreateProcessorGraphPreview)
		{
			// populating the phase processor with initial data for editor world so that the default processing graph
			// can be investigated in the editor without running PIE.
			// Runtime processing graph are initialized at runtime base on the actual archetypes instantiated at call time.
			FMassProcessorDependencySolver::FResult Result;
			Result.DependencyGraphFileName = DependencyGraphFileName;
			FMassPhaseProcessorConfigurationHelper Configurator(*PhaseProcessor, ProcessingPhasesConfig[PhaseAsInt], InOwner, EMassProcessingPhase(PhaseAsInt));
			Configurator.bIsGameRuntime = false;
			// passing EProcessorExecutionFlags::All here to gather all available processors since bCreateProcessorGraphPreview 
			// is true when we want to preview processors that might be available at runtime.
			Configurator.Configure({}, EProcessorExecutionFlags::All, /*EntityManager=*/nullptr, &Result);
		}
#endif // WITH_EDITOR
	}

	bIsAllowedToTick = true;
}

void FMassProcessingPhaseManager::Deinitialize()
{
	for (FMassProcessingPhase& Phase : ProcessingPhases)
	{
		Phase.PhaseProcessor = nullptr;
	}

	DynamicProcessors.Reset();
}

const FGraphEventRef& FMassProcessingPhaseManager::TriggerPhase(const EMassProcessingPhase Phase, const float DeltaTime, const FGraphEventRef& MyCompletionGraphEvent)
{
	check(Phase != EMassProcessingPhase::MAX);

	if (bIsAllowedToTick)
	{
		ProcessingPhases[(int)Phase].ExecuteTick(DeltaTime, LEVELTICK_All, ENamedThreads::GameThread, MyCompletionGraphEvent);
	}

	return MyCompletionGraphEvent;
}

void FMassProcessingPhaseManager::Start(UWorld& World)
{
	UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(&World);

	if (ensure(EntitySubsystem))
	{
		Start(EntitySubsystem->GetMutableEntityManager().AsShared());
	}
	else
	{
		UE_VLOG_UELOG(Owner.Get(), LogMass, Error, TEXT("Called %s while missing the EntitySubsystem"), ANSI_TO_TCHAR(__FUNCTION__));
	}
}

void FMassProcessingPhaseManager::Start(const TSharedPtr<FMassEntityManager>& InEntityManager)
{
	EntityManager = InEntityManager;

	OnNewArchetypeHandle = EntityManager->GetOnNewArchetypeEvent().AddRaw(this, &FMassProcessingPhaseManager::OnNewArchetype);

	if (UWorld* World = InEntityManager->GetWorld())
	{
		EnableTickFunctions(*World);
	}

	bIsAllowedToTick = true;
}

void FMassProcessingPhaseManager::AddReferencedObjects(FReferenceCollector& Collector)
{
	for (FMassProcessingPhase& Phase : ProcessingPhases)
	{
		if (Phase.PhaseProcessor)
		{
			Collector.AddReferencedObject(Phase.PhaseProcessor);
		}
	}

	for (auto& DynamicProcessor : DynamicProcessors)
	{
		if (DynamicProcessor)
		{
			Collector.AddReferencedObject(DynamicProcessor);
		}
	}
}

void FMassProcessingPhaseManager::EnableTickFunctions(const UWorld& World)
{
	check(EntityManager);

	const bool bIsGameWorld = World.IsGameWorld();

	for (FMassProcessingPhase& Phase : ProcessingPhases)
	{
		if (UE::Mass::Tweakables::bMakePrePhysicsTickFunctionHighPriority && (Phase.Phase == EMassProcessingPhase::PrePhysics))
		{
			constexpr bool bHighPriority = true;
			Phase.SetPriorityIncludingPrerequisites(bHighPriority);
		}

		Phase.RegisterTickFunction(World.PersistentLevel);
		Phase.SetTickFunctionEnable(true);
#if WITH_MASSENTITY_DEBUG
		if (Phase.PhaseProcessor && bIsGameWorld)
		{
			// not logging this in the editor mode since it messes up the game-recorded vislog display (with its progressively larger timestamp)
			FStringOutputDevice Ar;
			Phase.PhaseProcessor->DebugOutputDescription(Ar);
			UE_VLOG_UELOG(Owner.Get(), LogMass, Log, TEXT("Enabling phase %s tick:\n%s")
				, *UEnum::GetValueAsString(Phase.Phase), *Ar);
		}
#endif // WITH_MASSENTITY_DEBUG
	}

	if (bIsGameWorld)
	{
		// not logging this in the editor mode since it messes up the game-recorded vislog display (with its progressively larger timestamp)
		UE_VLOG_UELOG(Owner.Get(), LogMass, Log, TEXT("MassProcessingPhaseManager %s.%s has been started")
			, *GetNameSafe(Owner.Get()), *GetName());
	}
}

void FMassProcessingPhaseManager::Stop()
{
	bIsAllowedToTick = false;

	if (EntityManager)
	{
		EntityManager->GetOnNewArchetypeEvent().Remove(OnNewArchetypeHandle);
		EntityManager.Reset();
	}
	
	for (FMassProcessingPhase& Phase : ProcessingPhases)
	{
		Phase.SetTickFunctionEnable(false);
	}

	if (UObject* LocalOwner = Owner.Get())
	{
		UWorld* World = LocalOwner->GetWorld();
		if (World && World->IsGameWorld())
		{
			// not logging this in editor mode since it messes up the game-recorded vislog display (with its progressively larger timestamp) 
			UE_VLOG_UELOG(LocalOwner, LogMass, Log, TEXT("MassProcessingPhaseManager %s.%s has been stopped")
				, *GetNameSafe(LocalOwner), *GetName());
		}
	}
}

void FMassProcessingPhaseManager::OnPhaseStart(const FMassProcessingPhase& Phase)
{
	ensure(CurrentPhase == EMassProcessingPhase::MAX);
	CurrentPhase = Phase.Phase;

	const int32 PhaseAsInt = int32(Phase.Phase);
	if (Owner.IsValid()
		&& ensure(Phase.Phase != EMassProcessingPhase::MAX)
		&& (ProcessingGraphBuildStates[PhaseAsInt].bNewArchetypes || ProcessingGraphBuildStates[PhaseAsInt].bProcessorsNeedRebuild)
		// if not a valid index then we're not able to recalculate dependencies 
		&& ensure(ProcessingPhasesConfig.IsValidIndex(PhaseAsInt)))
	{
		TRACE_CPUPROFILER_EVENT_SCOPE_STR("Mass Rebuild Phase Graph");

		FPhaseGraphBuildState& GraphBuildState = ProcessingGraphBuildStates[PhaseAsInt];
		if (GraphBuildState.bInitialized == false 
			|| ProcessingGraphBuildStates[PhaseAsInt].bProcessorsNeedRebuild
			|| FMassProcessorDependencySolver::IsResultUpToDate(GraphBuildState.LastResult, EntityManager) == false)
		{
			UMassCompositeProcessor* PhaseProcessor = ProcessingPhases[PhaseAsInt].PhaseProcessor;
			check(PhaseProcessor);

			GraphBuildState.LastResult.Reset();

			FMassPhaseProcessorConfigurationHelper Configurator(*PhaseProcessor, ProcessingPhasesConfig[PhaseAsInt], *Owner.Get(), Phase.Phase);
			Configurator.Configure(DynamicProcessors, ProcessorExecutionFlags, EntityManager, &GraphBuildState.LastResult);

			GraphBuildState.bInitialized = true;

#if WITH_MASSENTITY_DEBUG
			UObject* OwnerPtr = Owner.Get();
			// print it all out to vislog
			UE_VLOG_UELOG(OwnerPtr, LogMass, Verbose, TEXT("Phases initialization done. Current composition:"));

			FStringOutputDevice OutDescription;
			PhaseProcessor->DebugOutputDescription(OutDescription);
			UE_VLOG_UELOG(OwnerPtr, LogMass, Verbose, TEXT("--- %s"), *OutDescription);
			OutDescription.Reset();
#endif // WITH_MASSENTITY_DEBUG
		}

		ProcessingGraphBuildStates[PhaseAsInt].bProcessorsNeedRebuild = false;
		ProcessingGraphBuildStates[PhaseAsInt].bNewArchetypes = false;
	}
}

void FMassProcessingPhaseManager::OnPhaseEnd(FMassProcessingPhase& Phase)
{
	ensure(CurrentPhase == Phase.Phase);
	CurrentPhase = EMassProcessingPhase::MAX;

	// switch between parallel and single-thread versions only after a given batch of processing has been wrapped up	
	if (Phase.IsConfiguredForParallelMode() != UE::Mass::Tweakables::bFullyParallel)
	{
		if (UE::Mass::Tweakables::bFullyParallel)
		{
			Phase.ConfigureForParallelMode();
		}
		else
		{
			Phase.ConfigureForSingleThreadMode();
		}
	}
}

FString FMassProcessingPhaseManager::GetName() const
{
	return GetNameSafe(Owner.Get()) + TEXT("_MassProcessingPhaseManager");
}

void FMassProcessingPhaseManager::RegisterDynamicProcessor(UMassProcessor& Processor)
{
	DynamicProcessors.Add(&Processor);
	Processor.MarkAsDynamic();
	ProcessingGraphBuildStates[uint32(Processor.GetProcessingPhase())].bProcessorsNeedRebuild = true;
}

void FMassProcessingPhaseManager::UnregisterDynamicProcessor(UMassProcessor& Processor)
{
	int32 Index;
	if (DynamicProcessors.Find(&Processor, Index))
	{
		DynamicProcessors.RemoveAt(Index);
		ProcessingGraphBuildStates[uint32(Processor.GetProcessingPhase())].bProcessorsNeedRebuild = true;
	}
	else
	{
		checkf(false, TEXT("Unable to remove Processor '%s', as it was never added or already removed."), *Processor.GetName());
	}
}

void FMassProcessingPhaseManager::OnNewArchetype(const FMassArchetypeHandle& NewArchetype)
{
	for (FPhaseGraphBuildState& GraphBuildState : ProcessingGraphBuildStates)
	{
		GraphBuildState.bNewArchetypes = true;
	}
}

#undef LOCTEXT_NAMESPACE

=========================================================


=== MassEntity/Private/MassProcessingTypes.cpp ===
==================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassProcessingTypes.h"
#include "MassProcessor.h"
#include "Misc/OutputDevice.h"
#include "MassEntityUtils.h"
#include "VisualLogger/VisualLogger.h"
#include "MassDebugger.h"
#include "Misc/CoreDelegates.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(MassProcessingTypes)

DEFINE_LOG_CATEGORY(LogMass);

//----------------------------------------------------------------------//
//  FMassProcessingContext
//----------------------------------------------------------------------//
FMassProcessingContext::FMassProcessingContext(FMassEntityManager& InEntityManager, const float InDeltaSeconds)
	: EntityManager(InEntityManager.AsShared()), DeltaSeconds(InDeltaSeconds)
{

}

FMassProcessingContext::FMassProcessingContext(TSharedPtr<FMassEntityManager>& InEntityManager, const float InDeltaSeconds)
	: EntityManager(InEntityManager), DeltaSeconds(InDeltaSeconds)
{

}

FMassProcessingContext::~FMassProcessingContext()
{
	if (CommandBuffer && CommandBuffer.IsUnique() && CommandBuffer->HasPendingCommands())
	{
		UE_CLOG(!EntityManager, LogMass, Error, TEXT("Unable to auto-flush FMassProcessingContext\'s commands due to missing EntityManager"));
		if (ensure(EntityManager))
		{
			UE_VLOG(EntityManager->GetOwner(), LogMass, Log, TEXT("Auto-flushing command buffer as part of FMassProcessingContext destruction"));
			checkf(CommandBuffer->IsFlushing() == false, TEXT("A totally unexpected scenario."));
			EntityManager->FlushCommands(CommandBuffer);
		}
	}
}

//----------------------------------------------------------------------//
//  FMassRuntimePipeline
//----------------------------------------------------------------------//
void FMassRuntimePipeline::Reset()
{
	Processors.Reset();
}

void FMassRuntimePipeline::Initialize(UObject& Owner)
{
	// having nulls in Processors should be rare so we run the "remove all nulls" operation below only if we know 
	// for sure that there are any nulls to be removed
	bool bNullsFound = false;

	for (UMassProcessor* Proc : Processors)
	{
		if (Proc)
		{
			if (Proc->IsInitialized() == false)
			{
				REDIRECT_OBJECT_TO_VLOG(Proc, &Owner);
				Proc->Initialize(Owner);
				ensureMsgf(Proc->IsInitialized(), TEXT("Missing Super::Initialize call for %s"), *Proc->GetFullName());
			}
		}
		else
		{
			bNullsFound = true;
		}
	}

	if (bNullsFound)
	{
		Processors.RemoveAll([](const UMassProcessor* Proc) { return Proc == nullptr; });
	}
}

void FMassRuntimePipeline::SetProcessors(TArray<UMassProcessor*>&& InProcessors)
{
	Reset();
	Processors = InProcessors;
}

void FMassRuntimePipeline::CreateFromArray(TConstArrayView<const UMassProcessor*> InProcessors, UObject& InOwner)
{
	Reset();
	AppendOrOverrideRuntimeProcessorCopies(InProcessors, InOwner);
}

void FMassRuntimePipeline::InitializeFromArray(TConstArrayView<const UMassProcessor*> InProcessors, UObject& InOwner)
{
	CreateFromArray(InProcessors, InOwner);
	Initialize(InOwner);
}

void FMassRuntimePipeline::InitializeFromClassArray(TConstArrayView<TSubclassOf<UMassProcessor>> InProcessorClasses, UObject& InOwner)
{
	Reset();

	const UWorld* World = InOwner.GetWorld();
	const EProcessorExecutionFlags WorldExecutionFlags = UE::Mass::Utils::DetermineProcessorExecutionFlags(World, ExecutionFlags);

	for (const TSubclassOf<UMassProcessor>& ProcessorClass : InProcessorClasses)
	{
		if (ProcessorClass)
		{
			UMassProcessor* CDO = ProcessorClass.GetDefaultObject();
			if (CDO && CDO->ShouldExecute(WorldExecutionFlags))
			{
				UMassProcessor* ProcInstance = NewObject<UMassProcessor>(&InOwner, ProcessorClass);
				Processors.Add(ProcInstance);
			}
			else
			{
				UE_CVLOG(CDO, &InOwner, LogMass, Log, TEXT("Skipping %s due to ExecutionFlags"), *CDO->GetName());
			}
		}
	}

	Initialize(InOwner);
}

bool FMassRuntimePipeline::HasProcessorOfExactClass(TSubclassOf<UMassProcessor> InClass) const
{
	UClass* TestClass = InClass.Get();
	return Processors.FindByPredicate([TestClass](const UMassProcessor* Proc){ return Proc != nullptr && Proc->GetClass() == TestClass; }) != nullptr;
}

void FMassRuntimePipeline::AppendUniqueRuntimeProcessorCopies(TConstArrayView<const UMassProcessor*> InProcessors, UObject& InOwner)
{
	const UWorld* World = InOwner.GetWorld();
	const EProcessorExecutionFlags WorldExecutionFlags = UE::Mass::Utils::DetermineProcessorExecutionFlags(World, ExecutionFlags);
	const int32 StartingCount = Processors.Num();
		
	for (const UMassProcessor* Proc : InProcessors)
	{
		if (Proc && Proc->ShouldExecute(WorldExecutionFlags)
			&& (Proc->ShouldAllowMultipleInstances() || (HasProcessorOfExactClass(Proc->GetClass()) == false)))
		{
			// unfortunately the const cast is required since NewObject doesn't support const Template object
			UMassProcessor* ProcCopy = NewObject<UMassProcessor>(&InOwner, Proc->GetClass(), FName(), RF_NoFlags, const_cast<UMassProcessor*>(Proc));
			Processors.Add(ProcCopy);
		}
#if WITH_MASSENTITY_DEBUG
		else if (Proc)
		{
			if (Proc->ShouldExecute(WorldExecutionFlags) == false)
			{
				UE_VLOG(&InOwner, LogMass, Log, TEXT("Skipping %s due to ExecutionFlags"), *Proc->GetName());
			}
			else if (Proc->ShouldAllowMultipleInstances() == false)
			{
				UE_VLOG(&InOwner, LogMass, Log, TEXT("Skipping %s due to it being a duplicate"), *Proc->GetName());
			}
		}
#endif // WITH_MASSENTITY_DEBUG
	}

	for (int32 NewProcIndex = StartingCount; NewProcIndex < Processors.Num(); ++NewProcIndex)
	{
		UMassProcessor* Proc = Processors[NewProcIndex];
		check(Proc);
		
		if (Proc->IsInitialized() == false)
		{
			REDIRECT_OBJECT_TO_VLOG(Proc, &InOwner);
			Proc->Initialize(InOwner);
			ensureMsgf(Proc->IsInitialized(), TEXT("Missing Super::Initialize call for %s"), *Proc->GetFullName());
		}
	}
}

void FMassRuntimePipeline::AppendOrOverrideRuntimeProcessorCopies(TConstArrayView<const UMassProcessor*> InProcessors, UObject& InOwner)
{
	const UWorld* World = InOwner.GetWorld();
	const EProcessorExecutionFlags WorldExecutionFlags = UE::Mass::Utils::DetermineProcessorExecutionFlags(World, ExecutionFlags);

	for (const UMassProcessor* Proc : InProcessors)
	{
		if (Proc && Proc->ShouldExecute(WorldExecutionFlags))
		{
			// unfortunately the const cast is required since NewObject doesn't support const Template object
			UMassProcessor* ProcCopy = NewObject<UMassProcessor>(&InOwner, Proc->GetClass(), FName(), RF_NoFlags, const_cast<UMassProcessor*>(Proc));
			check(ProcCopy);

			if (ProcCopy->ShouldAllowMultipleInstances())
			{
				// we don't care if there are instances of this class in Processors already
				Processors.Add(ProcCopy);
			}
			else 
			{
				const UClass* TestClass = Proc->GetClass();
				TObjectPtr<UMassProcessor>* PrevProcessor = Processors.FindByPredicate([TestClass, ProcCopy](const UMassProcessor* Proc) {
					return Proc != nullptr && Proc->GetClass() == TestClass;
				});

				if (PrevProcessor)
				{
					*PrevProcessor = ProcCopy;
				}
				else
				{
					Processors.Add(ProcCopy);
				}
			}
		}
		else
		{
			UE_CVLOG(Proc, &InOwner, LogMass, Log, TEXT("Skipping %s due to ExecutionFlags"), *Proc->GetName());
		}
	}
}

void FMassRuntimePipeline::AppendProcessor(UMassProcessor& Processor)
{
	Processors.Add(&Processor);
}

void FMassRuntimePipeline::AppendProcessor(TSubclassOf<UMassProcessor> ProcessorClass, UObject& InOwner)
{
	check(ProcessorClass);
	UMassProcessor* ProcInstance = NewObject<UMassProcessor>(&InOwner, ProcessorClass);
	AppendProcessor(*ProcInstance);
}

void FMassRuntimePipeline::RemoveProcessor(UMassProcessor& InProcessor)
{
	Processors.Remove(&InProcessor);
}

UMassCompositeProcessor* FMassRuntimePipeline::FindTopLevelGroupByName(FName GroupName)
{
	for (UMassProcessor* Processor : Processors)
	{
		UMassCompositeProcessor* CompositeProcessor = Cast<UMassCompositeProcessor>(Processor);
		if (CompositeProcessor && CompositeProcessor->GetGroupName() == GroupName)
		{
			return CompositeProcessor;
		}
	}
	return nullptr;
}

uint32 GetTypeHash(const FMassRuntimePipeline& Instance)
{ 
	uint32 Hash = 0;
	for (const UMassProcessor* Proc : Instance.Processors)
	{
		Hash = HashCombine(Hash, PointerHash(Proc));
	}
	return Hash;
}


==================================================


=== MassEntity/Private/MassProcessor.cpp ===
============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassProcessor.h"
#include "MassEntitySettings.h"
#include "MassProcessorDependencySolver.h"
#include "VisualLogger/VisualLogger.h"
#include "Engine/World.h"
#include "MassCommandBuffer.h"
#include "MassExecutionContext.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(MassProcessor)

DECLARE_CYCLE_STAT(TEXT("MassProcessor Group Completed"), Mass_GroupCompletedTask, STATGROUP_TaskGraphTasks);
DECLARE_CYCLE_STAT(TEXT("Mass Processor Task"), STAT_Mass_DoTask, STATGROUP_Mass);

#if WITH_MASSENTITY_DEBUG
namespace UE::Mass::Debug
{
	bool bLogProcessingGraph = false;
	FAutoConsoleVariableRef CVarLogProcessingGraph(TEXT("mass.LogProcessingGraph"), bLogProcessingGraph
		, TEXT("When enabled will log task graph tasks created while dispatching processors to other threads, along with their dependencies"), ECVF_Cheat);
}

#define PROCESSOR_LOG(Verbosity, Fmt, ...) UE_VLOG_UELOG(this, LogMass, Verbosity, Fmt, ##__VA_ARGS__)

// change to 1 to enable more detailed processing tasks logging
#if 0
#define PROCESSOR_TASK_LOG(Fmt, ...) UE_VLOG_UELOG(this, LogMass, Verbose, Fmt, ##__VA_ARGS__)
#else
#define PROCESSOR_TASK_LOG(...) 
#endif // 0

#else 
#define PROCESSOR_LOG(...)
#define PROCESSOR_TASK_LOG(...) 
#endif // WITH_MASSENTITY_DEBUG

class FMassProcessorTask
{
public:
	FMassProcessorTask(const TSharedPtr<FMassEntityManager>& InEntityManager, const FMassExecutionContext& InExecutionContext, UMassProcessor& InProc, bool bInManageCommandBuffer = true)
		: EntityManager(InEntityManager)
		, ExecutionContext(InExecutionContext)
		, Processor(&InProc)
		, bManageCommandBuffer(bInManageCommandBuffer)
	{}

	static TStatId GetStatId()
	{
		RETURN_QUICK_DECLARE_CYCLE_STAT(FMassProcessorTask, STATGROUP_TaskGraphTasks);
	}

	static ESubsequentsMode::Type GetSubsequentsMode() { return ESubsequentsMode::TrackSubsequents; }

	static ENamedThreads::Type GetDesiredThread()
	{
		return ENamedThreads::AnyHiPriThreadHiPriTask;
	}

	void DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)
	{
		checkf(Processor, TEXT("Expecting a valid processor to execute"));

		PROCESSOR_TASK_LOG(TEXT("+--+ Task %s started on %u"), *Processor->GetProcessorName(), FPlatformTLS::GetCurrentThreadId());
		SCOPE_CYCLE_COUNTER(STAT_Mass_DoTask);
		SCOPE_CYCLE_COUNTER(STAT_Mass_Total);

		check(EntityManager);
		FMassEntityManager& EntityManagerRef = *EntityManager.Get();
		FMassEntityManager::FScopedProcessing ProcessingScope = EntityManagerRef.NewProcessingScope();

		TRACE_CPUPROFILER_EVENT_SCOPE_STR("Mass Processor Task");
		
		if (bManageCommandBuffer)
		{
			TSharedPtr<FMassCommandBuffer> MainSharedPtr = ExecutionContext.GetSharedDeferredCommandBuffer();
			ExecutionContext.SetDeferredCommandBuffer(MakeShareable(new FMassCommandBuffer()));
			Processor->CallExecute(EntityManagerRef, ExecutionContext);
			MainSharedPtr->MoveAppend(ExecutionContext.Defer());
		}
		else
		{
			Processor->CallExecute(EntityManagerRef, ExecutionContext);
		}
		PROCESSOR_TASK_LOG(TEXT("+--+ Task %s finished"), *Processor->GetProcessorName());
	}

private:
	TSharedPtr<FMassEntityManager> EntityManager;
	FMassExecutionContext ExecutionContext;
	UMassProcessor* Processor = nullptr;
	/** 
	 * indicates whether this task is responsible for creation of a dedicated command buffer and transferring over the 
	 * commands after processor's execution;
	 */
	bool bManageCommandBuffer = true;
};

class FMassProcessorsTask_GameThread : public FMassProcessorTask
{
public:
	FMassProcessorsTask_GameThread(const TSharedPtr<FMassEntityManager>& InEntityManager, const FMassExecutionContext& InExecutionContext, UMassProcessor& InProc)
		: FMassProcessorTask(InEntityManager, InExecutionContext, InProc)
	{}

	static ENamedThreads::Type GetDesiredThread()
	{
		return ENamedThreads::GameThread;
	}
};

//----------------------------------------------------------------------//
// UMassProcessor 
//----------------------------------------------------------------------//
UMassProcessor::UMassProcessor(const FObjectInitializer& ObjectInitializer)
	: UMassProcessor()
{
}

UMassProcessor::UMassProcessor()
	: ExecutionFlags((int32)(EProcessorExecutionFlags::Server | EProcessorExecutionFlags::Standalone))
{
}

void UMassProcessor::Initialize(UObject& Owner)
{
	bInitialized = true;
}

void UMassProcessor::SetShouldAutoRegisterWithGlobalList(const bool bAutoRegister)
{	
	if (ensureMsgf(HasAnyFlags(RF_ClassDefaultObject), TEXT("Setting bAutoRegisterWithProcessingPhases for non-CDOs has no effect")))
	{
		bAutoRegisterWithProcessingPhases = bAutoRegister;
#if WITH_EDITOR
		if (UClass* Class = GetClass())
		{
			if (FProperty* AutoRegisterProperty = Class->FindPropertyByName(GET_MEMBER_NAME_CHECKED(UMassProcessor, bAutoRegisterWithProcessingPhases)))
			{
				UpdateSinglePropertyInConfigFile(AutoRegisterProperty, *GetDefaultConfigFilename());
			}
		}
#endif // WITH_EDITOR
	}
}

void UMassProcessor::GetArchetypesMatchingOwnedQueries(const FMassEntityManager& EntityManager, TArray<FMassArchetypeHandle>& OutArchetype)
{
	for (FMassEntityQuery* QueryPtr : OwnedQueries)
	{
		CA_ASSUME(QueryPtr);
		QueryPtr->CacheArchetypes(EntityManager);

		for (const FMassArchetypeHandle& ArchetypeHandle : QueryPtr->GetArchetypes())
		{
			OutArchetype.AddUnique(ArchetypeHandle);
		}
	}
}

bool UMassProcessor::DoesAnyArchetypeMatchOwnedQueries(const FMassEntityManager& EntityManager)
{
	for (FMassEntityQuery* QueryPtr : OwnedQueries)
	{
		CA_ASSUME(QueryPtr);
		QueryPtr->CacheArchetypes(EntityManager);

		if (QueryPtr->GetArchetypes().Num() > 0)
		{
			return true;
		}
	}
	return false;
}

void UMassProcessor::PostInitProperties()
{
	Super::PostInitProperties();

	// We want even the CDO processors to be fully set up so that we can reason about processors based on CDOs, without 
	// needing to instantiate processors based on a given class.
	// Note that we skip abstract processors because we're not going to instantiate them at runtime anyway.
	if (GetClass()->HasAnyClassFlags(CLASS_Abstract) == false)
	{
		ConfigureQueries();

		bool bNeedsGameThread = ProcessorRequirements.DoesRequireGameThreadExecution();
		for (const FMassEntityQuery* QueryPtr : OwnedQueries)
		{
			CA_ASSUME(QueryPtr);
			bNeedsGameThread = (bNeedsGameThread || QueryPtr->DoesRequireGameThreadExecution());
		}

		UE_CLOG(bRequiresGameThreadExecution != bNeedsGameThread, LogMass, Verbose
			, TEXT("%s is marked bRequiresGameThreadExecution = %s, while the registered queries' or processor requirements indicate the opposite")
			, *GetProcessorName(), bRequiresGameThreadExecution ? TEXT("TRUE") : TEXT("FALSE"));

		// better safe than sorry - if queries or processor requirements indicate the game thread execution is required, then we marked the whole processor as such
		bRequiresGameThreadExecution = bRequiresGameThreadExecution || bNeedsGameThread;
	}
#if CPUPROFILERTRACE_ENABLED
	StatId = GetProcessorName();
#endif
}

void UMassProcessor::CallExecute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	TRACE_CPUPROFILER_EVENT_SCOPE_TEXT(*StatId);
	LLM_SCOPE_BYNAME(TEXT("Mass/ExecuteProcessor"));
	// Not using a more specific scope by default (i.e. LLM_SCOPE_BYNAME(*StatId)) since LLM is more strict regarding the provided string (no spaces or '_')

#if WITH_MASSENTITY_DEBUG
	Context.DebugSetExecutionDesc(FString::Printf(TEXT("%s (%s)"), *GetProcessorName(), EntityManager.GetWorld() ? *ToString(EntityManager.GetWorld()->GetNetMode()) : TEXT("No World")));
#endif
	// CacheSubsystemRequirements will return true only if all requirements declared with ProcessorRequirements are met
	// meaning if it fails there's no point in calling Execute.
	// Note that we're not testing individual queries in OwnedQueries - processors can function just fine with some 
	// of their queries not having anything to do.
	if (Context.CacheSubsystemRequirements(ProcessorRequirements))
	{
		Execute(EntityManager, Context);
	}
	else
	{
		PROCESSOR_LOG(VeryVerbose, TEXT("%s Skipping Execute due to subsystem requirements not being met"), *GetProcessorName());
	}
}

bool UMassProcessor::ShouldAllowQueryBasedPruning(const bool bRuntimeMode) const
{
	return bRuntimeMode;
}

EMassProcessingPhase UMassProcessor::GetProcessingPhase() const
{
	return ProcessingPhase;
}

void UMassProcessor::SetProcessingPhase(EMassProcessingPhase Phase)
{
	ProcessingPhase = Phase;
}

void UMassProcessor::ExportRequirements(FMassExecutionRequirements& OutRequirements) const
{
	for (FMassEntityQuery* Query : OwnedQueries)
	{
		CA_ASSUME(Query);
		Query->ExportRequirements(OutRequirements);
	}
}

void UMassProcessor::RegisterQuery(FMassEntityQuery& Query)
{
	const uintptr_t ThisStart = (uintptr_t)this;
	const uintptr_t ThisEnd = ThisStart + GetClass()->GetStructureSize();
	const uintptr_t QueryStart = (uintptr_t)&Query;
	const uintptr_t QueryEnd = QueryStart + sizeof(FMassEntityQuery);

	if (QueryStart >= ThisStart && QueryEnd <= ThisEnd)
	{
		OwnedQueries.AddUnique(&Query);
	}
	else
	{
		static constexpr TCHAR MessageFormat[] = TEXT("Registering entity query for %s while the query is not given processor's member variable. Skipping.");
		checkf(false, MessageFormat, *GetProcessorName());
		UE_LOG(LogMass, Error, MessageFormat, *GetProcessorName());
	}
}

FGraphEventRef UMassProcessor::DispatchProcessorTasks(const TSharedPtr<FMassEntityManager>& EntityManager, FMassExecutionContext& ExecutionContext, const FGraphEventArray& Prerequisites)
{
	FGraphEventRef ReturnVal;
	if (bRequiresGameThreadExecution)
	{
		ReturnVal = TGraphTask<FMassProcessorsTask_GameThread>::CreateTask(&Prerequisites).ConstructAndDispatchWhenReady(EntityManager, ExecutionContext, *this);
	}
	else
	{
		ReturnVal = TGraphTask<FMassProcessorTask>::CreateTask(&Prerequisites).ConstructAndDispatchWhenReady(EntityManager, ExecutionContext, *this);
	}	
	return ReturnVal;
}

FString UMassProcessor::GetProcessorName() const
{
	return GetName();
}

void UMassProcessor::DebugOutputDescription(FOutputDevice& Ar, int32 Indent) const
{
#if WITH_MASSENTITY_DEBUG
	Ar.Logf(TEXT("%*s%s"), Indent, TEXT(""), *GetProcessorName());
#endif // WITH_MASSENTITY_DEBUG
}

//----------------------------------------------------------------------//
//  UMassCompositeProcessor
//----------------------------------------------------------------------//
UMassCompositeProcessor::UMassCompositeProcessor()
	: GroupName(TEXT("None"))
{
	// not auto-registering composite processors since the idea of the global processors list is to indicate all 
	// the processors doing the work while composite processors are just containers. Having said that subclasses 
	// can change this behavior if need be.
	bAutoRegisterWithProcessingPhases = false;
}

void UMassCompositeProcessor::SetChildProcessors(TArray<UMassProcessor*>&& InProcessors)
{
	ChildPipeline.SetProcessors(MoveTemp(InProcessors));
}

void UMassCompositeProcessor::ConfigureQueries()
{
	// nothing to do here since ConfigureQueries will get automatically called for all the processors in ChildPipeline
	// via their individual PostInitProperties call
}

FGraphEventRef UMassCompositeProcessor::DispatchProcessorTasks(const TSharedPtr<FMassEntityManager>& EntityManager, FMassExecutionContext& ExecutionContext, const FGraphEventArray& InPrerequisites)
{
	FGraphEventArray Events;
	Events.Reserve(FlatProcessingGraph.Num());
		
	for (FDependencyNode& ProcessingNode : FlatProcessingGraph)
	{
		FGraphEventArray Prerequisites;
		for (const int32 DependencyIndex : ProcessingNode.Dependencies)
		{
			Prerequisites.Add(Events[DependencyIndex]);
		}

		// we don't expect any group nodes at this point. If we get any there's a bug in dependencies solving
		if (ensure(ProcessingNode.Processor))
		{
			Events.Add(ProcessingNode.Processor->DispatchProcessorTasks(EntityManager, ExecutionContext, Prerequisites));
		}
	}


#if WITH_MASSENTITY_DEBUG
	if (UE::Mass::Debug::bLogProcessingGraph)
	{
		for (int i = 0; i < FlatProcessingGraph.Num(); ++i)
		{
			FDependencyNode& ProcessingNode = FlatProcessingGraph[i];
			FString DependenciesDesc;
			for (const int32 DependencyIndex : ProcessingNode.Dependencies)
			{
				DependenciesDesc += FString::Printf(TEXT("%s, "), *FlatProcessingGraph[DependencyIndex].Name.ToString());
			}

			check(ProcessingNode.Processor);
			PROCESSOR_TASK_LOG(TEXT("Task %u %s%s%s"), Events[i]->GetTraceId(), *ProcessingNode.Processor->GetProcessorName()
				, DependenciesDesc.Len() > 0 ? TEXT(" depends on ") : TEXT(""), *DependenciesDesc);
		}
	}
#endif // WITH_MASSENTITY_DEBUG

	FGraphEventRef CompletionEvent = FFunctionGraphTask::CreateAndDispatchWhenReady([this](){}
		, GET_STATID(Mass_GroupCompletedTask), &Events, ENamedThreads::AnyHiPriThreadHiPriTask);

	return CompletionEvent;
}

void UMassCompositeProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	for (UMassProcessor* Proc : ChildPipeline.GetMutableProcessors())
	{
		check(Proc);
		Proc->CallExecute(EntityManager, Context);
	}
}

void UMassCompositeProcessor::Initialize(UObject& Owner)
{
	ChildPipeline.Initialize(Owner);
	Super::Initialize(Owner);
}

void UMassCompositeProcessor::SetProcessors(TArrayView<UMassProcessor*> InProcessorInstances, const TSharedPtr<FMassEntityManager>& EntityManager)
{
	// figure out dependencies
	FMassProcessorDependencySolver Solver(InProcessorInstances);
	TArray<FMassProcessorOrderInfo> SortedProcessors;
	Solver.ResolveDependencies(SortedProcessors, EntityManager);

	UpdateProcessorsCollection(SortedProcessors);

	if (Solver.IsSolvingForSingleThread() == false)
	{
		BuildFlatProcessingGraph(SortedProcessors);
	}
}

void UMassCompositeProcessor::BuildFlatProcessingGraph(TConstArrayView<FMassProcessorOrderInfo> SortedProcessors)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(Mass_BuildFlatProcessingGraph);
#if !MASS_DO_PARALLEL
	UE_LOG(LogMass, Warning
		, TEXT("MassCompositeProcessor::BuildFlatProcessingGraph is not expected to run in a single-threaded Mass setup. The flat graph will not be used at runtime."));
#endif // MASS_DO_PARALLEL

	FlatProcessingGraph.Reset();

	// this part is creating an ordered, flat list of processors that can be executed in sequence
	// with subsequent task only depending on the elements prior on the list
	TMap<FName, int32> NameToDependencyIndex;
	NameToDependencyIndex.Reserve(SortedProcessors.Num());
	TArray<int32> SuperGroupDependency;
	for (const FMassProcessorOrderInfo& Element : SortedProcessors)
	{
		NameToDependencyIndex.Add(Element.Name, FlatProcessingGraph.Num());

		// we don't expect to get any "group" nodes here. If it happens it indicates a bug in dependency solving
		checkSlow(Element.Processor);
		FDependencyNode& Node = FlatProcessingGraph.Add_GetRef({ Element.Name, Element.Processor });
		Node.Dependencies.Reserve(Element.Dependencies.Num());
		for (FName DependencyName : Element.Dependencies)
		{
			checkSlow(DependencyName.IsNone() == false);
			Node.Dependencies.Add(NameToDependencyIndex.FindChecked(DependencyName));
		}
#if WITH_MASSENTITY_DEBUG
		Node.SequenceIndex = Element.SequenceIndex;
#endif // WITH_MASSENTITY_DEBUG
	}

#if WITH_MASSENTITY_DEBUG
	FScopedCategoryAndVerbosityOverride LogOverride(TEXT("LogMass"), ELogVerbosity::Log);
	UE_LOG(LogMass, Log, TEXT("%s flat processing graph:"), *GroupName.ToString());

	int32 Index = 0;
	for (const FDependencyNode& ProcessingNode : FlatProcessingGraph)
	{
		FString DependenciesDesc;
		for (const int32 DependencyIndex : ProcessingNode.Dependencies)
		{
			DependenciesDesc += FString::Printf(TEXT("%d, "), DependencyIndex);
		}
		if (ProcessingNode.Processor)
		{
			UE_LOG(LogMass, Log, TEXT("[%2d]%*s%s%s%s"), Index, ProcessingNode.SequenceIndex * 2, TEXT(""), *ProcessingNode.Processor->GetProcessorName()
				, DependenciesDesc.Len() > 0 ? TEXT(" depends on ") : TEXT(""), *DependenciesDesc);
		}
		++Index;
	}
#endif // WITH_MASSENTITY_DEBUG
}

void UMassCompositeProcessor::UpdateProcessorsCollection(TArrayView<FMassProcessorOrderInfo> InOutOrderedProcessors, EProcessorExecutionFlags InWorldExecutionFlags)
{
	TArray<TObjectPtr<UMassProcessor>> ExistingProcessors(ChildPipeline.GetMutableProcessors());
	ChildPipeline.Reset();

	const UWorld* World = GetWorld();
	const EProcessorExecutionFlags WorldExecutionFlags = UE::Mass::Utils::DetermineProcessorExecutionFlags(World, InWorldExecutionFlags);
	const FMassProcessingPhaseConfig& PhaseConfig = GET_MASS_CONFIG_VALUE(GetProcessingPhaseConfig(ProcessingPhase));

	for (FMassProcessorOrderInfo& ProcessorInfo : InOutOrderedProcessors)
	{
		if (ensureMsgf(ProcessorInfo.NodeType == FMassProcessorOrderInfo::EDependencyNodeType::Processor, TEXT("Encountered unexpected FMassProcessorOrderInfo::EDependencyNodeType while populating %s"), *GetGroupName().ToString()))
		{
			checkSlow(ProcessorInfo.Processor);
			if (ProcessorInfo.Processor->ShouldExecute(WorldExecutionFlags))
			{
				// we want to reuse existing processors to maintain state. It's recommended to keep processors state-less
				// but we already have processors that do have some state, like signaling processors.
				// the following search only makes sense for "single instance" processors
				if (ProcessorInfo.Processor->ShouldAllowMultipleInstances() == false)
				{
					TObjectPtr<UMassProcessor>* FoundProcessor = ExistingProcessors.FindByPredicate([ProcessorClass = ProcessorInfo.Processor->GetClass()](TObjectPtr<UMassProcessor>& Element)
						{
							return Element && (Element->GetClass() == ProcessorClass);
						});

					if (FoundProcessor)
					{
						// overriding the stored value since the InOutOrderedProcessors can get used after the call and it 
						// needs to reflect the actual work performed
						ProcessorInfo.Processor = FoundProcessor->Get();
					}
				}

				CA_ASSUME(ProcessorInfo.Processor);
				ChildPipeline.AppendProcessor(*ProcessorInfo.Processor);
			}
		}
	}
}

FString UMassCompositeProcessor::GetProcessorName() const
{
	return GroupName.ToString();
}

void UMassCompositeProcessor::DebugOutputDescription(FOutputDevice& Ar, int32 Indent) const
{
#if WITH_MASSENTITY_DEBUG
	if (ChildPipeline.Num() == 0)
	{
		Ar.Logf(TEXT("%*sGroup %s: []"), Indent, TEXT(""), *GroupName.ToString());
	}
	else
	{
		Ar.Logf(TEXT("%*sGroup %s:"), Indent, TEXT(""), *GroupName.ToString());
		for (UMassProcessor* Proc : ChildPipeline.GetProcessors())
		{
			check(Proc);
			Ar.Logf(TEXT("\n"));
			Proc->DebugOutputDescription(Ar, Indent + 3);
		}
	}
#endif // WITH_MASSENTITY_DEBUG
}

void UMassCompositeProcessor::SetProcessingPhase(EMassProcessingPhase Phase)
{
	Super::SetProcessingPhase(Phase);
	for (UMassProcessor* Proc : ChildPipeline.GetMutableProcessors())
	{
		Proc->SetProcessingPhase(Phase);
	}
}

void UMassCompositeProcessor::SetGroupName(FName NewName)
{
	GroupName = NewName;
#if CPUPROFILERTRACE_ENABLED
	StatId = GroupName.ToString();
#endif
}

void UMassCompositeProcessor::AddGroupedProcessor(FName RequestedGroupName, UMassProcessor& Processor)
{
	if (RequestedGroupName.IsNone() || RequestedGroupName == GroupName)
	{
		ChildPipeline.AppendProcessor(Processor);
	}
	else
	{
		FString RemainingGroupName;
		UMassCompositeProcessor* GroupProcessor = FindOrAddGroupProcessor(RequestedGroupName, &RemainingGroupName);
		check(GroupProcessor);
		GroupProcessor->AddGroupedProcessor(FName(*RemainingGroupName), Processor);
	}
}

UMassCompositeProcessor* UMassCompositeProcessor::FindOrAddGroupProcessor(FName RequestedGroupName, FString* OutRemainingGroupName)
{
	UMassCompositeProcessor* GroupProcessor = nullptr;
	const FString NameAsString = RequestedGroupName.ToString();
	FString TopGroupName;
	if (NameAsString.Split(TEXT("."), &TopGroupName, OutRemainingGroupName))
	{
		RequestedGroupName = FName(*TopGroupName);
	}
	GroupProcessor = ChildPipeline.FindTopLevelGroupByName(RequestedGroupName);

	if (GroupProcessor == nullptr)
	{
		check(GetOuter());
		GroupProcessor = NewObject<UMassCompositeProcessor>(GetOuter());
		GroupProcessor->SetGroupName(RequestedGroupName);
		ChildPipeline.AppendProcessor(*GroupProcessor);
	}

	return GroupProcessor;
}

//-----------------------------------------------------------------------------
// DEPRECATED
//-----------------------------------------------------------------------------
void UMassCompositeProcessor::Populate(TConstArrayView<FMassProcessorOrderInfo> OrderedProcessors)
{
	TArray<FMassProcessorOrderInfo> OrderedProcessorsCopy(OrderedProcessors);
	UpdateProcessorsCollection(OrderedProcessorsCopy, EProcessorExecutionFlags::None);
}

============================================


=== MassEntity/Private/MassProcessorDependencySolver.cpp ===
============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassProcessorDependencySolver.h"
#include "MassProcessingTypes.h"
#include "MassProcessor.h"
#include "Logging/MessageLog.h"
#include "HAL/FileManager.h"
#include "Misc/Paths.h"
#include "Engine/World.h"

#define LOCTEXT_NAMESPACE "Mass"

namespace UE::Mass::Private
{
	FString NameViewToString(TConstArrayView<FName> View)
	{
		if (View.Num() == 0)
		{
			return TEXT("[]");
		}
		FString ReturnVal = FString::Printf(TEXT("[%s"), *View[0].ToString());
		for (int i = 1; i < View.Num(); ++i)
		{
			ReturnVal += FString::Printf(TEXT(", %s"), *View[i].ToString());
		}
		return ReturnVal + TEXT("]");
	}

	bool DoArchetypeContainersOverlap(TConstArrayView<FMassArchetypeHandle> A, const TArray<FMassArchetypeHandle>& B)
	{
		for (const FMassArchetypeHandle& HandleA : A)
		{
			if (B.Contains(HandleA))
			{
				return true;
			}
		}
		return false;
	}
}

//----------------------------------------------------------------------//
//  FMassExecutionRequirements
//----------------------------------------------------------------------//
void FMassExecutionRequirements::Append(const FMassExecutionRequirements& Other)
{
	for (int i = 0; i < EMassAccessOperation::MAX; ++i)
	{
		Fragments[i] += Other.Fragments[i];
		ChunkFragments[i] += Other.ChunkFragments[i];
		SharedFragments[i] += Other.SharedFragments[i];
		RequiredSubsystems[i] += Other.RequiredSubsystems[i];
	}
	ConstSharedFragments.Read += Other.ConstSharedFragments.Read;

	RequiredAllTags += Other.RequiredAllTags;
	RequiredAnyTags += Other.RequiredAnyTags;
	RequiredNoneTags += Other.RequiredNoneTags;
	// note that we're deliberately ignoring optional tags, they play no role here.

	// signal that it requires recalculation;
	ResourcesUsedCount = INDEX_NONE;
}

void FMassExecutionRequirements::CountResourcesUsed()
{
	ResourcesUsedCount = ConstSharedFragments.Read.CountStoredTypes();

	for (int i = 0; i < EMassAccessOperation::MAX; ++i)
	{
		ResourcesUsedCount += Fragments[i].CountStoredTypes();
		ResourcesUsedCount += ChunkFragments[i].CountStoredTypes();
		ResourcesUsedCount += SharedFragments[i].CountStoredTypes();
		ResourcesUsedCount += RequiredSubsystems[i].CountStoredTypes();
	}
}

int32 FMassExecutionRequirements::GetTotalBitsUsedCount()
{
	CountResourcesUsed();

	return ResourcesUsedCount + RequiredAllTags.CountStoredTypes()
		+ RequiredAnyTags.CountStoredTypes() + RequiredNoneTags.CountStoredTypes();
}

bool FMassExecutionRequirements::IsEmpty() const
{
	return Fragments.IsEmpty() && ChunkFragments.IsEmpty() 
		&& SharedFragments.IsEmpty() && ConstSharedFragments.IsEmpty() && RequiredSubsystems.IsEmpty()
		&& RequiredAllTags.IsEmpty() && RequiredAnyTags.IsEmpty() && RequiredNoneTags.IsEmpty();
}

FMassArchetypeCompositionDescriptor FMassExecutionRequirements::AsCompositionDescriptor() const
{
	return FMassArchetypeCompositionDescriptor(Fragments.Read + Fragments.Write
		, RequiredAllTags + RequiredAnyTags
		, ChunkFragments.Read + ChunkFragments.Write
		, SharedFragments.Read + SharedFragments.Write
		, ConstSharedFragments.Read);
}

//----------------------------------------------------------------------//
//  FProcessorDependencySolver::FResourceUsage
//----------------------------------------------------------------------//
FMassProcessorDependencySolver::FResourceUsage::FResourceUsage(const TArray<FNode>& InAllNodes)
	: AllNodesView(InAllNodes)
{
	for (int i = 0; i < EMassAccessOperation::MAX; ++i)
	{
		FragmentsAccess[i].Access.AddZeroed(FMassFragmentBitSet::GetMaxNum());
		ChunkFragmentsAccess[i].Access.AddZeroed(FMassChunkFragmentBitSet::GetMaxNum());
		SharedFragmentsAccess[i].Access.AddZeroed(FMassSharedFragmentBitSet::GetMaxNum());
		RequiredSubsystemsAccess[i].Access.AddZeroed(FMassExternalSubsystemBitSet::GetMaxNum());
	}
}

template<typename TBitSet>
void FMassProcessorDependencySolver::FResourceUsage::HandleElementType(TMassExecutionAccess<FResourceAccess>& ElementAccess
	, const TMassExecutionAccess<TBitSet>& TestedRequirements, FMassProcessorDependencySolver::FNode& InOutNode, const int32 NodeIndex)
{
	using UE::Mass::Private::DoArchetypeContainersOverlap;

	// for every bit set in TestedRequirements we do the following:
	// 1. For every read-only requirement we make InOutNode depend on the currently stored Writer of this resource
	//    - note that this operation is not destructive, meaning we don't destructively consume the data, since all 
	//      subsequent read access to the given resource will also depend on the Writer
	//    - note 2: we also fine tune what we store as a dependency for InOutNode by checking if InOutNode's archetype
	//      overlap with whoever the current Writer is 
	//    - this will result in InOutNode wait for the current Writer to finish before starting its own work and 
	//      that's exactly what we need to do to avoid accessing data while it's potentially being written
	// 2. For every read-write requirement we make InOutNode depend on all the readers and writers currently stored. 
	//    - once that's done we clean currently stored Readers and Writers since every subsequent operation on this 
	//      resource will be blocked by currently considered InOutNode (as the new Writer)
	//    - again, we do check corresponding archetype collections overlap
	//    - similarly to the read operation waiting on write operations in pt 1. we want to hold off the write 
	//      operations to be performed by InOutNode until all currently registered (and conflicting) writers and readers 
	//      are done with their operations 
	// 3. For all accessed resources we store information that InOutNode is accessing it
	//    - we do this so that the following nodes know that they'll have to wait for InOutNode if an access 
	//      conflict arises. 

	// 1. For every read only requirement we make InOutNode depend on the currently stored Writer of this resource
	for (auto It = TestedRequirements.Read.GetIndexIterator(); It; ++It)
	{
		for (int32 UserIndex : ElementAccess.Write.Access[*It].Users)
		{
			if (DoArchetypeContainersOverlap(AllNodesView[UserIndex].ValidArchetypes, InOutNode.ValidArchetypes))
			{
				InOutNode.OriginalDependencies.Add(UserIndex);
			}
		}
	}

	// 2. For every read-write requirement we make InOutNode depend on all the readers and writers currently stored. 
	for (auto It = TestedRequirements.Write.GetIndexIterator(); It; ++It)
	{
		for (int32 i = ElementAccess.Read.Access[*It].Users.Num() - 1; i >= 0; --i)
		{
			const int32 UserIndex = ElementAccess.Read.Access[*It].Users[i];
			if (DoArchetypeContainersOverlap(AllNodesView[UserIndex].ValidArchetypes, InOutNode.ValidArchetypes))
			{	
				InOutNode.OriginalDependencies.Add(UserIndex);
				ElementAccess.Read.Access[*It].Users.RemoveAtSwap(i);
			}
		}

		for (int32 i = ElementAccess.Write.Access[*It].Users.Num() - 1; i >= 0; --i)
		{
			const int32 UserIndex = ElementAccess.Write.Access[*It].Users[i];
			if (DoArchetypeContainersOverlap(AllNodesView[UserIndex].ValidArchetypes, InOutNode.ValidArchetypes))
			{
				InOutNode.OriginalDependencies.Add(UserIndex);
				ElementAccess.Write.Access[*It].Users.RemoveAtSwap(i);
			}
		}
	}

	// 3. For all accessed resources we store information that InOutNode is accessing it
	for (auto It = TestedRequirements.Read.GetIndexIterator(); It; ++It)
	{
		// mark Element at index indicated by It as being used in mode EMassAccessOperation(i) by NodeIndex
		ElementAccess.Read.Access[*It].Users.Add(NodeIndex);
	}
	for (auto It = TestedRequirements.Write.GetIndexIterator(); It; ++It)
	{
		// mark Element at index indicated by It as being used in mode EMassAccessOperation(i) by NodeIndex
		ElementAccess.Write.Access[*It].Users.Add(NodeIndex);
	}
}

template<typename TBitSet>
bool FMassProcessorDependencySolver::FResourceUsage::CanAccess(const TMassExecutionAccess<TBitSet>& StoredElements, const TMassExecutionAccess<TBitSet>& TestedElements)
{
	// see if there's an overlap of tested write operations with existing read & write operations, as well as 
	// tested read operations with existing write operations
	
	return !(
		// if someone's already writing to what I want to write
		TestedElements.Write.HasAny(StoredElements.Write)
		// or if someone's already reading what I want to write
		|| TestedElements.Write.HasAny(StoredElements.Read)
		// or if someone's already writing what I want to read
		|| TestedElements.Read.HasAny(StoredElements.Write)
	);
}

bool FMassProcessorDependencySolver::FResourceUsage::HasArchetypeConflict(TMassExecutionAccess<FResourceAccess> ElementAccess, const TArray<FMassArchetypeHandle>& InArchetypes) const
{
	using UE::Mass::Private::DoArchetypeContainersOverlap;

	// this function is being run when we've already determined there's an access conflict on given ElementsAccess,
	// meaning whoever's asking is trying to access Elements that are already being used. We can still grant access 
	// though provided that none of the current users of Element access the same archetypes the querier does (as provided 
	// by InArchetypes).
	// @todo this operation could be even more efficient and precise if we tracked which operation (read/write) and which
	// specific Element were conflicting and the we could limit the check to that. That would however significantly 
	// complicate the code and would require a major refactor to keep things clean.
	for (int i = 0; i < EMassAccessOperation::MAX; ++i)
	{
		for (const FResourceUsers& Resource : ElementAccess[i].Access)
		{
			for (const int32 UserIndex : Resource.Users)
			{
				if (DoArchetypeContainersOverlap(AllNodesView[UserIndex].ValidArchetypes, InArchetypes))
				{
					return true;
				}
			}
		}
	}
	return false;
}

bool FMassProcessorDependencySolver::FResourceUsage::CanAccessRequirements(const FMassExecutionRequirements& TestedRequirements, const TArray<FMassArchetypeHandle>& InArchetypes) const
{
	// note that on purpose we're not checking ConstSharedFragments - those are always only read, no danger of conflicting access
	bool bCanAccess = (CanAccess<FMassFragmentBitSet>(Requirements.Fragments, TestedRequirements.Fragments) || !HasArchetypeConflict(FragmentsAccess, InArchetypes))
		&& (CanAccess<FMassChunkFragmentBitSet>(Requirements.ChunkFragments, TestedRequirements.ChunkFragments) || !HasArchetypeConflict(ChunkFragmentsAccess, InArchetypes))
		&& (CanAccess<FMassSharedFragmentBitSet>(Requirements.SharedFragments, TestedRequirements.SharedFragments) || !HasArchetypeConflict(SharedFragmentsAccess, InArchetypes))
		&& CanAccess<FMassExternalSubsystemBitSet>(Requirements.RequiredSubsystems, TestedRequirements.RequiredSubsystems);

	return bCanAccess;
}

void FMassProcessorDependencySolver::FResourceUsage::SubmitNode(const int32 NodeIndex, FNode& InOutNode)
{
	HandleElementType<FMassFragmentBitSet>(FragmentsAccess, InOutNode.Requirements.Fragments, InOutNode, NodeIndex);
	HandleElementType<FMassChunkFragmentBitSet>(ChunkFragmentsAccess, InOutNode.Requirements.ChunkFragments, InOutNode, NodeIndex);
	HandleElementType<FMassSharedFragmentBitSet>(SharedFragmentsAccess, InOutNode.Requirements.SharedFragments, InOutNode, NodeIndex);
	HandleElementType<FMassExternalSubsystemBitSet>(RequiredSubsystemsAccess, InOutNode.Requirements.RequiredSubsystems, InOutNode, NodeIndex);
	// note that on purpose we're not pushing ConstSharedFragments - those are always only read, no danger of conflicting access
	// so there's no point in tracking them

	Requirements.Append(InOutNode.Requirements);
}

//----------------------------------------------------------------------//
//  FProcessorDependencySolver::FNode
//----------------------------------------------------------------------//
void FMassProcessorDependencySolver::FNode::IncreaseWaitingNodesCount(TArrayView<FMassProcessorDependencySolver::FNode> InAllNodes)
{
	// cycle-protection check. If true it means we have a cycle and the whole algorithm result will be unreliable 
	if (TotalWaitingNodes >= FMath::Square(InAllNodes.Num()))
	{
		return;
	}

	++TotalWaitingNodes;

	for (const int32 DependencyIndex : OriginalDependencies)
	{
		check(&InAllNodes[DependencyIndex] != this);
		InAllNodes[DependencyIndex].IncreaseWaitingNodesCount(InAllNodes);
	}
}
//----------------------------------------------------------------------//
//  FProcessorDependencySolver
//----------------------------------------------------------------------//
FMassProcessorDependencySolver::FMassProcessorDependencySolver(TArrayView<UMassProcessor* const> InProcessors, const bool bIsGameRuntime)
	: Processors(InProcessors)
	, bGameRuntime(bIsGameRuntime)
{}

bool FMassProcessorDependencySolver::PerformSolverStep(FResourceUsage& ResourceUsage, TArray<int32>& InOutIndicesRemaining, TArray<int32>& OutNodeIndices)
{
	int32 AcceptedNodeIndex = INDEX_NONE;
	int32 FallbackAcceptedNodeIndex = INDEX_NONE;

	for (int32 i = 0; i < InOutIndicesRemaining.Num(); ++i)
	{
		const int32 NodeIndex = InOutIndicesRemaining[i];
		if (AllNodes[NodeIndex].TransientDependencies.Num() == 0)
		{
			// if we're solving dependencies for a single thread use we don't need to fine-tune the order based on resources nor archetypes
			if (bSingleThreadTarget || ResourceUsage.CanAccessRequirements(AllNodes[NodeIndex].Requirements, AllNodes[NodeIndex].ValidArchetypes))
			{
				AcceptedNodeIndex = NodeIndex;
				break;
			}
			else if (FallbackAcceptedNodeIndex == INDEX_NONE)
			{
				// if none of the nodes left can "cleanly" execute (i.e. without conflicting with already stored nodes)
				// we'll just pick this one up and go with it. 
				FallbackAcceptedNodeIndex = NodeIndex;
			}
		}
	}

	if (AcceptedNodeIndex != INDEX_NONE || FallbackAcceptedNodeIndex != INDEX_NONE)
	{
		const int32 NodeIndex = AcceptedNodeIndex != INDEX_NONE ? AcceptedNodeIndex : FallbackAcceptedNodeIndex;

		FNode& Node = AllNodes[NodeIndex];

		// Note that this is not an unexpected event and will happen during every dependency solving. It's a part 
		// of the algorithm. We initially look for all the things we can run without conflicting with anything else. 
		// But that can't last forever, at some point we'll end up in a situation where every node left waits for 
		// something that has been submitted already. Then we just pick one of the waiting ones (the one indicated by 
		// FallbackAcceptedNodeIndex), "run it" and proceed.
		UE_CLOG(AcceptedNodeIndex == INDEX_NONE, LogMass, Verbose, TEXT("No dependency-free node can be picked, due to resource requirements. Picking %s as the next node.")
			, *Node.Name.ToString());

		ResourceUsage.SubmitNode(NodeIndex, Node);
		InOutIndicesRemaining.RemoveSingle(NodeIndex);
		OutNodeIndices.Add(NodeIndex);
		for (const int32 DependencyIndex : Node.OriginalDependencies)
		{
			Node.SequencePositionIndex = FMath::Max(Node.SequencePositionIndex, AllNodes[DependencyIndex].SequencePositionIndex);
		}
		++Node.SequencePositionIndex;

		for (const int32 RemainingNodeIndex : InOutIndicesRemaining)
		{
			AllNodes[RemainingNodeIndex].TransientDependencies.RemoveSingleSwap(NodeIndex, EAllowShrinking::No);
		}
		
		return true;
	}

	return false;
}

void FMassProcessorDependencySolver::CreateSubGroupNames(FName InGroupName, TArray<FString>& SubGroupNames)
{
	// the function will convert composite group name into a series of progressively more precise group names
	// so "A.B.C" will result in ["A", "A.B", "A.B.C"]

	SubGroupNames.Reset();
	FString GroupNameAsString = InGroupName.ToString();
	FString TopGroupName;

	while (GroupNameAsString.Split(TEXT("."), &TopGroupName, &GroupNameAsString))
	{
		SubGroupNames.Add(TopGroupName);
	}
	SubGroupNames.Add(GroupNameAsString);
	
	for (int i = 1; i < SubGroupNames.Num(); ++i)
	{
		SubGroupNames[i] = FString::Printf(TEXT("%s.%s"), *SubGroupNames[i - 1], *SubGroupNames[i]);
	}
}

int32 FMassProcessorDependencySolver::CreateNodes(UMassProcessor& Processor)
{
	check(Processor.GetClass());
	// for processors supporting multiple instances we use processor name rather than processor's class name for
	// dependency calculations. This makes the user responsible for fine-tuning per-processor dependencies. 
	const FName ProcName = Processor.ShouldAllowMultipleInstances() 
		? Processor.GetFName()
		: Processor.GetClass()->GetFName();

	if (const int32* NodeIndexPtr = NodeIndexMap.Find(ProcName))
	{
		if (Processor.ShouldAllowMultipleInstances())
		{
			UE_LOG(LogMass, Warning, TEXT("%hs Processor %s, name %s, already registered. This processor class does suport duplicates, but individual instances need to have a unique name.")
				, __FUNCTION__, *Processor.GetFullName(), *ProcName.ToString());
		}
		else
		{
			UE_LOG(LogMass, Warning, TEXT("%hs Processor %s already registered. Duplicates are not supported by this processor class.")
				, __FUNCTION__, *ProcName.ToString());
		}
		return *NodeIndexPtr;
	}

	const FMassProcessorExecutionOrder& ExecutionOrder = Processor.GetExecutionOrder();

	// first figure out the groups so that the group nodes come before the processor nodes, this is required for child
	// nodes to inherit group's dependencies like in scenarios where some processor required to ExecuteBefore a given group
	int32 ParentGroupNodeIndex = INDEX_NONE;
	if (ExecutionOrder.ExecuteInGroup.IsNone() == false)
	{
		TArray<FString> AllGroupNames;
		CreateSubGroupNames(ExecutionOrder.ExecuteInGroup, AllGroupNames);
	
		check(AllGroupNames.Num() > 0);

		for (const FString& GroupName : AllGroupNames)
		{
			const FName GroupFName(GroupName);
			int32* LocalGroupIndex = NodeIndexMap.Find(GroupFName);
			// group name hasn't been encountered yet - create it
			if (LocalGroupIndex == nullptr)
			{
				int32 NewGroupNodeIndex = AllNodes.Num();
				NodeIndexMap.Add(GroupFName, NewGroupNodeIndex);
				FNode& GroupNode = AllNodes.Add_GetRef({ GroupFName, nullptr, NewGroupNodeIndex });
				// just ignore depending on the dummy "root" node
				if (ParentGroupNodeIndex != INDEX_NONE)
				{
					GroupNode.OriginalDependencies.Add(ParentGroupNodeIndex);
					AllNodes[ParentGroupNodeIndex].SubNodeIndices.Add(NewGroupNodeIndex);
				}

				ParentGroupNodeIndex = NewGroupNodeIndex;
			}
			else
			{	
				ParentGroupNodeIndex = *LocalGroupIndex;
			}

		}
	}

	const int32 NodeIndex = AllNodes.Num();
	NodeIndexMap.Add(ProcName, NodeIndex);
	FNode& ProcessorNode = AllNodes.Add_GetRef({ ProcName, &Processor, NodeIndex });

	ProcessorNode.ExecuteAfter.Append(ExecutionOrder.ExecuteAfter);
	ProcessorNode.ExecuteBefore.Append(ExecutionOrder.ExecuteBefore);
	Processor.ExportRequirements(ProcessorNode.Requirements);
	ProcessorNode.Requirements.CountResourcesUsed();

	if (ParentGroupNodeIndex > 0)
	{
		AllNodes[ParentGroupNodeIndex].SubNodeIndices.Add(NodeIndex);
	}

	return NodeIndex;
}

void FMassProcessorDependencySolver::BuildDependencies()
{
	// at this point we have collected all the known processors and groups in AllNodes so we can transpose 
	// A.ExecuteBefore(B) type of dependencies into B.ExecuteAfter(A)
	for (int32 NodeIndex = 0; NodeIndex < AllNodes.Num(); ++NodeIndex)
	{
		for (int i = 0; i < AllNodes[NodeIndex].ExecuteBefore.Num(); ++i)
		{
			const FName BeforeDependencyName = AllNodes[NodeIndex].ExecuteBefore[i];
			int32 DependentNodeIndex = INDEX_NONE;
			int32* DependentNodeIndexPtr = NodeIndexMap.Find(BeforeDependencyName);
			if (DependentNodeIndexPtr == nullptr)
			{
				// missing dependency. Adding a "dummy" node representing those to still support ordering based on missing groups or processors 
				// For example, if Processor A and B declare dependency, respectively, "Before C" and "After C" we still 
				// expect A to come before B regardless of whether C exists or not.
				
				DependentNodeIndex = AllNodes.Num();
				NodeIndexMap.Add(BeforeDependencyName, DependentNodeIndex);
				AllNodes.Add({ BeforeDependencyName, nullptr, DependentNodeIndex });

				UE_LOG(LogMass, Log, TEXT("Unable to find dependency \"%s\" declared by %s. Creating a dummy dependency node.")
					, *BeforeDependencyName.ToString(), *AllNodes[NodeIndex].Name.ToString());
			}
			else
			{
				DependentNodeIndex = *DependentNodeIndexPtr;
			}

			check(AllNodes.IsValidIndex(DependentNodeIndex));
			AllNodes[DependentNodeIndex].ExecuteAfter.Add(AllNodes[NodeIndex].Name);
		}
		AllNodes[NodeIndex].ExecuteBefore.Reset();
	}

	// at this point all nodes contain:
	// - single "original dependency" pointing at its parent group
	// - ExecuteAfter populated with node names

	// Now, for every Name in ExecuteAfter we do the following:
	//	if Name represents a processor, add it as "original dependency"
	//	else, if Name represents a group:
	//		- append all group's child node names to ExecuteAfter
	// 
	for (int32 NodeIndex = 0; NodeIndex < AllNodes.Num(); ++NodeIndex)
	{
		for (int i = 0; i < AllNodes[NodeIndex].ExecuteAfter.Num(); ++i)
		{
			const FName AfterDependencyName = AllNodes[NodeIndex].ExecuteAfter[i];
			int32* PrerequisiteNodeIndexPtr = NodeIndexMap.Find(AfterDependencyName);
			int32 PrerequisiteNodeIndex = INDEX_NONE;

			if (PrerequisiteNodeIndexPtr == nullptr)
			{
				// missing dependency. Adding a "dummy" node representing those to still support ordering based on missing groups or processors 
				// For example, if Processor A and B declare dependency, respectively, "Before C" and "After C" we still 
				// expect A to come before B regardless of whether C exists or not.

				PrerequisiteNodeIndex = AllNodes.Num();
				NodeIndexMap.Add(AfterDependencyName, PrerequisiteNodeIndex);
				AllNodes.Add({ AfterDependencyName, nullptr, PrerequisiteNodeIndex });

				UE_LOG(LogMass, Log, TEXT("Unable to find dependency \"%s\" declared by %s. Creating a dummy dependency node.")
					, *AfterDependencyName.ToString(), *AllNodes[NodeIndex].Name.ToString());
			}
			else
			{
				PrerequisiteNodeIndex = *PrerequisiteNodeIndexPtr;
			}

			const FNode& PrerequisiteNode = AllNodes[PrerequisiteNodeIndex];

			if (PrerequisiteNode.IsGroup())
			{
				for (int32 SubNodeIndex : PrerequisiteNode.SubNodeIndices)
				{
					AllNodes[NodeIndex].ExecuteAfter.AddUnique(AllNodes[SubNodeIndex].Name);
				}
			}
			else
			{
				AllNodes[NodeIndex].OriginalDependencies.AddUnique(PrerequisiteNodeIndex);
			}
		}

		// if this node is a group push all the dependencies down on all the children
		// by design all child nodes come after group nodes so the child nodes' dependencies have not been processed yet
		if (AllNodes[NodeIndex].IsGroup() && AllNodes[NodeIndex].SubNodeIndices.Num())
		{
			for (int32 PrerequisiteNodeIndex : AllNodes[NodeIndex].OriginalDependencies)
			{
				checkSlow(PrerequisiteNodeIndex != NodeIndex);
				// in case of processor nodes we can store it directly
				if (AllNodes[PrerequisiteNodeIndex].IsGroup() == false)
				{
					for (int32 ChildNodeIndex : AllNodes[NodeIndex].SubNodeIndices)
					{
						AllNodes[ChildNodeIndex].OriginalDependencies.AddUnique(PrerequisiteNodeIndex);
					}
				}
				// special case - if dependency is a group and we haven't processed that group yet, we need to add it by name
				else if (PrerequisiteNodeIndex > NodeIndex)
				{
					const FName& PrerequisiteName = AllNodes[PrerequisiteNodeIndex].Name;
					for (int32 ChildNodeIndex : AllNodes[NodeIndex].SubNodeIndices)
					{
						AllNodes[ChildNodeIndex].ExecuteAfter.AddUnique(PrerequisiteName);
					}
				}
			}
		}
	}
}

void FMassProcessorDependencySolver::LogNode(const FNode& Node, int Indent)
{
	using UE::Mass::Private::NameViewToString;

	if (Node.IsGroup())
	{
		UE_LOG(LogMass, Log, TEXT("%*s%s before:%s after:%s"), Indent, TEXT(""), *Node.Name.ToString()
			, *NameViewToString(Node.ExecuteBefore)
			, *NameViewToString(Node.ExecuteAfter));

		for (const int32 NodeIndex : Node.SubNodeIndices)
		{
			LogNode(AllNodes[NodeIndex], Indent + 4);
		}
	}
	else
	{
		CA_ASSUME(Node.Processor); // as implied by Node.IsGroup() == false
		UE_LOG(LogMass, Log, TEXT("%*s%s before:%s after:%s"), Indent, TEXT(""), *Node.Name.ToString()
			, *NameViewToString(Node.Processor->GetExecutionOrder().ExecuteBefore)
			, *NameViewToString(Node.Processor->GetExecutionOrder().ExecuteAfter));
	}
}

#if 0 // disabled the graph building for now, leaving the old code here for reference
struct FDumpGraphDependencyUtils
{
	static void DumpGraphNode(FArchive& LogFile, const FProcessorDependencySolver::FNode& Node, int Indent, TSet<const FProcessorDependencySolver::FNode*>& AllNodes, const bool bRoot)
	{
		const FString NodeName = Node.Name.ToString();
		if (!Node.Processor)
		{
			const FString ClusterNodeName = NodeName.Replace(TEXT("."), TEXT("_"));
			const FString GraphNodeName = NodeName.Replace(TEXT("."), TEXT(" "));

			int32 Index = -1;
			Node.Name.ToString().FindLastChar(TEXT('.'), Index);
			const FString GroupName = NodeName.Mid(Index+1);

			LogFile.Logf(TEXT("%*ssubgraph cluster_%s"), Indent, TEXT(""), *ClusterNodeName);
			LogFile.Logf(TEXT("%*s{"), Indent, TEXT(""));
			LogFile.Logf(TEXT("%*slabel =\"%s\";"), Indent + 4, TEXT(""), *GroupName);
			LogFile.Logf(TEXT("%*s\"%s Start\"%s;"), Indent + 4, TEXT(""), *GraphNodeName, bRoot ? TEXT("") : TEXT("[shape=point style=invis]"));
			LogFile.Logf(TEXT("%*s\"%s End\"%s;"), Indent + 4, TEXT(""), *GraphNodeName, bRoot ? TEXT("") : TEXT("[shape=point style=invis]"));
			for (const FProcessorDependencySolver::FNode& SubNode : Node.SubNodes)
			{
				DumpGraphNode(LogFile, SubNode, Indent + 4, AllNodes, false);
			}
			LogFile.Logf(TEXT("%*s}"), Indent, TEXT(""));
		}
		else
		{
			LogFile.Logf(TEXT("%*s\"%s\""), Indent, TEXT(""), *NodeName);
			AllNodes.Add(&Node);
		}
	}

	static const FProcessorDependencySolver::FNode* FindDepNodeInParents(const TArray<const FProcessorDependencySolver::FNode*>& Parents, FName DependencyName)
	{
		for (int32 i = Parents.Num() - 1; i >= 0; --i)
		{
			const FProcessorDependencySolver::FNode* CurNode = Parents[i];
			int32 DependencyIndex = CurNode->FindNodeIndex(DependencyName);
			while(DependencyIndex != INDEX_NONE)
			{
				if(CurNode->SubNodes[DependencyIndex].Name == DependencyName)
				{
					return &CurNode->SubNodes[DependencyIndex];
				}
				else
				{
					// Dig down the chain
					CurNode = &CurNode->SubNodes[DependencyIndex];
					DependencyIndex = CurNode->FindNodeIndex(DependencyName);
				}
			}
		}
		return nullptr;
	};

	static bool DoAllSubNodeHasDependency(const FProcessorDependencySolver::FNode& Node, const FName DependencyName, bool bBeforeDep)
	{
		bool bDepExistInAllSibling = true;
		for (const FProcessorDependencySolver::FNode& SiblingSubNode : Node.SubNodes)
		{
			if (SiblingSubNode.Processor)
			{
				const TArray<FName>& ExecuteDep = bBeforeDep ? SiblingSubNode.Processor->GetExecutionOrder().ExecuteBefore : SiblingSubNode.Processor->GetExecutionOrder().ExecuteAfter;
				if (ExecuteDep.Find(DependencyName) == INDEX_NONE)
				{
					bDepExistInAllSibling = false;
					break;
				}
			}
			else if (!DoAllSubNodeHasDependency(SiblingSubNode, DependencyName, bBeforeDep))
			{
				bDepExistInAllSibling = false;
				break;
			}
		}
		return bDepExistInAllSibling;
	}

	static bool DoesDependencyExistIndirectly(const TArray<const FProcessorDependencySolver::FNode*>& Parents, const FProcessorDependencySolver::FNode& Node, const FName DepNameToFind, bool bBeforeDep)
	{
		check(Node.Processor);
		const TArray<FName>& ExecuteDep = bBeforeDep ? Node.Processor->GetExecutionOrder().ExecuteBefore : Node.Processor->GetExecutionOrder().ExecuteAfter;
		for (const FName& DependencyName : ExecuteDep)
		{
			if (DependencyName == DepNameToFind)
			{
				continue;
			}
			if (const FProcessorDependencySolver::FNode* DepNode = FindDepNodeInParents(Parents, DependencyName))
			{
				if(DepNode->Processor)
				{
					const TArray<FName>& ExecuteDepDep = bBeforeDep ? DepNode->Processor->GetExecutionOrder().ExecuteBefore : DepNode->Processor->GetExecutionOrder().ExecuteAfter;
					if(ExecuteDepDep.Find(DepNameToFind) != INDEX_NONE)
					{
						return true;
					}
				}
				else if(DoAllSubNodeHasDependency(*DepNode, DepNameToFind, bBeforeDep))
				{
					return true;
				}
			}
		}
		return false;
	}

	static void RemoveAllProcessorFromSet(const FProcessorDependencySolver::FNode& DepNode, TSet<const FProcessorDependencySolver::FNode*>& Set)
	{
		if (DepNode.Processor)
		{
			Set.Remove(&DepNode);
		}
		else
		{
			for (const FProcessorDependencySolver::FNode& SubNode : DepNode.SubNodes)
			{
				RemoveAllProcessorFromSet(SubNode, Set);
			}
		}
	}

	static bool AreAllProcessorInSet(const FProcessorDependencySolver::FNode& DepNode, TSet<const FProcessorDependencySolver::FNode*>& Set)
	{
		if (DepNode.Processor)
		{
			if (!Set.Contains(&DepNode))
			{
				return false;
			}
		}
		else
		{
			for (const FProcessorDependencySolver::FNode& SubNode : DepNode.SubNodes)
			{
				if (!AreAllProcessorInSet(SubNode, Set))
				{
					return false;
				}
			}
		}
		return true;
	}

	static void DumpGraphDependencies(FArchive& LogFile, const FProcessorDependencySolver::FNode& Node, TArray<const FProcessorDependencySolver::FNode*> Parents, TArray<const FProcessorDependencySolver::FNode*> CommonBeforeDep, TArray<const FProcessorDependencySolver::FNode*> CommonAfterDep, TSet<const FProcessorDependencySolver::FNode*>& DependsOnStart, TSet<const FProcessorDependencySolver::FNode*>& LinkToEnd)
	{
		const FString NodeName = Node.Name.ToString();
		const FProcessorDependencySolver::FNode* ParentNode = Parents.Num() > 0 ? Parents.Last() : nullptr;
		const FString ParentNodeName = ParentNode ? ParentNode->Name.ToString() : TEXT("");
		const FString ParentGraphNodeName = ParentNodeName.Replace(TEXT("."), TEXT(" "));
		const FString ParentClusterNodeName = ParentNodeName.Replace(TEXT("."), TEXT("_"));
		if (Node.Processor)
		{
			for (const FName& DependencyName : Node.Processor->GetExecutionOrder().ExecuteBefore)
			{
				if (const FProcessorDependencySolver::FNode* DepNode = FindDepNodeInParents(Parents, DependencyName))
				{
					LinkToEnd.Remove(&Node);
					RemoveAllProcessorFromSet(*DepNode, DependsOnStart);

					if (CommonBeforeDep.Find(DepNode) != INDEX_NONE)
					{
						continue;
					}
					if (DoesDependencyExistIndirectly(Parents, Node, DependencyName, true))
					{
						continue;
					}

					const FString DepNodeName = DepNode->Name.ToString();
					if (DepNode->Processor)
					{
						LogFile.Logf(TEXT("    \"%s\" -> \"%s\";"), *NodeName, *DepNodeName);
					}
					else
					{
						const FString DepClusterNodeName = DepNodeName.Replace(TEXT("."), TEXT("_"));
						const FString DepGraphNodeName = DepNodeName.Replace(TEXT("."), TEXT(" "));
						LogFile.Logf(TEXT("    \"%s\" -> \"%s Start\"[lhead=cluster_%s];"), *NodeName, *DepGraphNodeName, *DepClusterNodeName);
					}

				}
			}
			for (const FName& DependencyName : Node.Processor->GetExecutionOrder().ExecuteAfter)
			{
				if (const FProcessorDependencySolver::FNode* DepNode = FindDepNodeInParents(Parents, DependencyName))
				{
					DependsOnStart.Remove(&Node);
					RemoveAllProcessorFromSet(*DepNode, LinkToEnd);

					if (CommonAfterDep.Find(DepNode) != INDEX_NONE)
					{
						continue;
					}
					if (DoesDependencyExistIndirectly(Parents, Node, DependencyName, false))
					{
						continue;
					}

					const FString DepNodeName = DepNode->Name.ToString();
					if (DepNode->Processor)
					{
						LogFile.Logf(TEXT("    \"%s\" -> \"%s\";"), *DepNodeName, *NodeName);
					}
					else
					{
						const FString DepClusterNodeName = DepNodeName.Replace(TEXT("."), TEXT("_"));
						const FString DepGraphNodeName = DepNodeName.Replace(TEXT("."), TEXT(" "));
						LogFile.Logf(TEXT("    \"%s End\" -> \"%s\"[ltail=cluster_%s];"), *DepGraphNodeName, *NodeName, *DepClusterNodeName);
					}
				}
			}

			// Layouting
			LogFile.Logf(TEXT("    \"%s Start\" -> \"%s\" -> \"%s End\"[style=invis];"), *ParentGraphNodeName, *NodeName, *ParentGraphNodeName);
		}
		else if (ParentNode)
		{

			const FString ClusterNodeName = NodeName.Replace(TEXT("."), TEXT("_"));
			const FString GraphNodeName = NodeName.Replace(TEXT("."), TEXT(" "));

			// Find common dependency through out all sub nodes
 			TSet<FName> BeforeDepOuputed;
 			TSet<FName> AfterDepOutputed;
			for (const FProcessorDependencySolver::FNode& SubNode : Node.SubNodes)
			{
				if(SubNode.Processor)
				{
					for (const FName& DependencyName : SubNode.Processor->GetExecutionOrder().ExecuteBefore)
					{
						if (const FProcessorDependencySolver::FNode* DepNode = FindDepNodeInParents(Parents, DependencyName))
						{
							if (DoAllSubNodeHasDependency(Node, DependencyName, true /*bBeforeDep*/))
							{
								CommonBeforeDep.Add(DepNode);

								if (!DoesDependencyExistIndirectly(Parents, SubNode, DependencyName, true))
								{
									if (BeforeDepOuputed.Contains(DependencyName))
									{
										continue;
									}
									BeforeDepOuputed.Add(DependencyName);

									const FString DepNodeName = DepNode->Name.ToString();
									if (DepNode->Processor)
									{
										LogFile.Logf(TEXT("    \"%s End\" -> \"%s\"[ltail=cluster_%s];"), *GraphNodeName, *DepNodeName, *ClusterNodeName);
									}
									else
									{
										const FString DepClusterNodeName = DepNodeName.Replace(TEXT("."), TEXT("_"));
										const FString DepGraphNodeName = DepNodeName.Replace(TEXT("."), TEXT(" "));
										LogFile.Logf(TEXT("    \"%s End\" -> \"%s Start\"[ltail=cluster_%s, lhead=cluster_%s];"), *GraphNodeName, *DepGraphNodeName, *ClusterNodeName, *DepClusterNodeName);
									}
								}
							}
						}
					}

					for (const FName& DependencyName : SubNode.Processor->GetExecutionOrder().ExecuteAfter)
					{
						if (const FProcessorDependencySolver::FNode* DepNode = FindDepNodeInParents(Parents, DependencyName))
						{
							if (DoAllSubNodeHasDependency(Node, DependencyName, false /*bBeforeDep*/))
							{
								CommonAfterDep.Add(DepNode);

								if (!DoesDependencyExistIndirectly(Parents, SubNode, DependencyName, false))
								{
									if (AfterDepOutputed.Contains(DependencyName))
									{
										continue;
									}
									AfterDepOutputed.Add(DependencyName);

									const FString DepNodeName = DepNode->Name.ToString();
									if (DepNode->Processor)
									{
										LogFile.Logf(TEXT("    \"%s\" -> \"%s Start\"[lhead=cluster_%s];"), *DepNodeName, *GraphNodeName, *ClusterNodeName);
									}
									else
									{
										const FString DepClusterNodeName = DepNodeName.Replace(TEXT("."), TEXT("_"));
										const FString DepGraphNodeName = DepNodeName.Replace(TEXT("."), TEXT(" "));
										LogFile.Logf(TEXT("    \"%s End\" -> \"%s Start\"[ltail=cluster_%s, lhead=cluster_%s];"), *DepGraphNodeName,*GraphNodeName, *DepClusterNodeName, *ClusterNodeName);
									}
								}
							}
						}
					}
				}
			}

 			// Layouting
			LogFile.Logf(TEXT("    \"%s Start\" -> \"%s Start\" -> \"%s End\" -> \"%s End\"[style=invis];"), *ParentGraphNodeName, *GraphNodeName, *GraphNodeName, *ParentGraphNodeName);
		}

		Parents.Push(&Node);
		for (const FProcessorDependencySolver::FNode& SubNode : Node.SubNodes)
		{
			DumpGraphDependencies(LogFile, SubNode, Parents, CommonBeforeDep, CommonAfterDep, DependsOnStart, LinkToEnd);
		}
	}

	static void PromoteStartAndEndDependency(FArchive& LogFile, const FString& GraphName, const FProcessorDependencySolver::FNode& Node, TSet<const FProcessorDependencySolver::FNode*>& DependsOnStart, TSet<const FProcessorDependencySolver::FNode*>& LinkToEnd)
	{
		if (Node.Processor)
		{
			return;
		}

		bool bAllDependsOnStart = true;
		bool bAllLinkedToEnd = true;
		for (const FProcessorDependencySolver::FNode& SubNode : Node.SubNodes)
		{
			if (!AreAllProcessorInSet(SubNode, DependsOnStart))
			{
				bAllDependsOnStart = false;
			}

			if (!AreAllProcessorInSet(SubNode, LinkToEnd))
			{
				bAllLinkedToEnd = false;
			}

			if (!bAllDependsOnStart && !bAllLinkedToEnd)
			{
				break;
			}
		}

		const FString NodeName = Node.Name.ToString();
		const FString ClusterNodeName = NodeName.Replace(TEXT("."), TEXT("_"));
		const FString GraphNodeName = NodeName.Replace(TEXT("."), TEXT(" "));
		if (bAllDependsOnStart)
		{
			RemoveAllProcessorFromSet(Node, DependsOnStart);
			LogFile.Logf(TEXT("    \"%s Start\" -> \"%s Start\"[lhead=cluster_%s, weight=0];"), *GraphName, *GraphNodeName, *ClusterNodeName);
		}

		if (bAllLinkedToEnd)
		{
			RemoveAllProcessorFromSet(Node, LinkToEnd);
			LogFile.Logf(TEXT("    \"%s End\" -> \"%s End\"[ltail=cluster_%s, weight=0];"), *GraphNodeName, *GraphName, *ClusterNodeName);
		}

		if(!bAllDependsOnStart || !bAllLinkedToEnd)
		{
			for (const FProcessorDependencySolver::FNode& SubNode : Node.SubNodes)
			{
				PromoteStartAndEndDependency(LogFile, GraphName, SubNode, DependsOnStart, LinkToEnd);
			}
		}
	}

	static void DumpAllGraphDependencies(FArchive& LogFile, const FProcessorDependencySolver::FNode& GroupRootNode, const TSet<const FProcessorDependencySolver::FNode*>& AllNodes)
	{
		TSet<const FProcessorDependencySolver::FNode*> DependsOnStart = AllNodes;
		TSet<const FProcessorDependencySolver::FNode*> LinkToEnd = AllNodes;
		const FString GraphName = GroupRootNode.Name.ToString();
		FDumpGraphDependencyUtils::DumpGraphDependencies(LogFile, GroupRootNode, TArray<const FProcessorDependencySolver::FNode*>(), TArray<const FProcessorDependencySolver::FNode*>(), TArray<const FProcessorDependencySolver::FNode*>(), DependsOnStart, LinkToEnd);
		FDumpGraphDependencyUtils::PromoteStartAndEndDependency(LogFile, GraphName, GroupRootNode, DependsOnStart, LinkToEnd);
		for (const FProcessorDependencySolver::FNode* Node : DependsOnStart)
		{
			LogFile.Logf(TEXT("    \"%s Start\" -> \"%s\"[weight=0];"), *GraphName, *Node->Name.ToString());
		}
		for (const FProcessorDependencySolver::FNode* Node : LinkToEnd)
		{
			LogFile.Logf(TEXT("    \"%s\" -> \"%s End\"[weight=0];"), *Node->Name.ToString(), *GraphName);
		}
	}
};

void FProcessorDependencySolver::DumpGraph(FArchive& LogFile) const
{
	TSet<const FNode*> AllNodes;
	LogFile.Logf(TEXT("digraph MassProcessorGraph"));
	LogFile.Logf(TEXT("{"));
	LogFile.Logf(TEXT("    compound = true;"));
	LogFile.Logf(TEXT("    newrank = true;"));
	FDumpGraphDependencyUtils::DumpGraphNode(LogFile, GroupRootNode, 4/* Indent */, AllNodes, true/* bRoot */);
	FDumpGraphDependencyUtils::DumpAllGraphDependencies(LogFile, GroupRootNode, AllNodes);
	LogFile.Logf(TEXT("}"));
}

#endif // 0; disabled the graph building for now, leaving the old code here for reference

void FMassProcessorDependencySolver::Solve(TArray<FMassProcessorOrderInfo>& OutResult)
{
	using UE::Mass::Private::NameViewToString;

	if (AllNodes.Num() == 0)
	{
		return;
	}

	for (FNode& Node : AllNodes)
	{
		Node.TransientDependencies = Node.OriginalDependencies;
		Node.TotalWaitingNodes = 0;
	}

	TArray<int32> IndicesRemaining;
	IndicesRemaining.Reserve(AllNodes.Num());
	for (int32 i = 0; i < AllNodes.Num(); ++i)
	{
		// skip all the group nodes, all group dependencies have already been converted to individual processor dependencies
		if (AllNodes[i].IsGroup() == false)
		{
			IndicesRemaining.Add(i);
			AllNodes[i].IncreaseWaitingNodesCount(AllNodes);
		}
	}

	IndicesRemaining.Sort([this](const int32 IndexA, const int32 IndexB){
		return AllNodes[IndexA].TotalWaitingNodes > AllNodes[IndexB].TotalWaitingNodes;
	});

	// this is where we'll be tracking what's being accessed by whom
	FResourceUsage ResourceUsage(AllNodes);

	TArray<int32> SortedNodeIndices;
	SortedNodeIndices.Reserve(AllNodes.Num());

	while (IndicesRemaining.Num())
	{
		const bool bStepSuccessful = PerformSolverStep(ResourceUsage, IndicesRemaining, SortedNodeIndices);

		if (bStepSuccessful == false)
		{
			bAnyCyclesDetected = true;

			UE_LOG(LogMass, Error, TEXT("Detected processing dependency cycle:"));
			for (const int32 Index : IndicesRemaining)
			{
				UMassProcessor* Processor = AllNodes[Index].Processor;
				if (Processor)
				{
					UE_LOG(LogMass, Warning, TEXT("\t%s, group: %s, before: %s, after %s")
						, *Processor->GetName()
						, *Processor->GetExecutionOrder().ExecuteInGroup.ToString()
						, *NameViewToString(Processor->GetExecutionOrder().ExecuteBefore)
						, *NameViewToString(Processor->GetExecutionOrder().ExecuteAfter));
				}
				else
				{
					// group
					UE_LOG(LogMass, Warning, TEXT("\tGroup %s"), *AllNodes[Index].Name.ToString());
				}
			}
			UE_LOG(LogMass, Warning, TEXT("Cutting the chain at an arbitrary location."));

			// remove first dependency
			// note that if we're in a cycle handling scenario every node does have some dependencies left
			const int32 DependencyNodeIndex = AllNodes[IndicesRemaining[0]].TransientDependencies.Pop(EAllowShrinking::No);
			// we need to remove this dependency from original dependencies as well, otherwise we'll still have the cycle
			// in the data being produces as a result of the whole algorithm
			AllNodes[IndicesRemaining[0]].OriginalDependencies.Remove(DependencyNodeIndex);
		}
	}

	// now we have the desired order in SortedNodeIndices. We have to traverse it to add to OutResult
	for (int i = 0; i < SortedNodeIndices.Num(); ++i)
	{
		const int32 NodeIndex = SortedNodeIndices[i];

		TArray<FName> DependencyNames;
		for (const int32 DependencyIndex : AllNodes[NodeIndex].OriginalDependencies)
		{
			DependencyNames.AddUnique(AllNodes[DependencyIndex].Name);
		}

		// at this point we expect SortedNodeIndices to only point to regular processors (i.e. no groups)
		if (ensure(AllNodes[NodeIndex].Processor != nullptr))
		{
			OutResult.Add({ AllNodes[NodeIndex].Name, AllNodes[NodeIndex].Processor, FMassProcessorOrderInfo::EDependencyNodeType::Processor, DependencyNames, AllNodes[NodeIndex].SequencePositionIndex });
		}
	}
}

void FMassProcessorDependencySolver::ResolveDependencies(TArray<FMassProcessorOrderInfo>& OutResult, TSharedPtr<FMassEntityManager> EntityManager, FMassProcessorDependencySolver::FResult* InOutOptionalResult)
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("Mass ResolveDependencies");

	if (Processors.Num() == 0)
	{
		return;
	}

	FScopedCategoryAndVerbosityOverride LogOverride(TEXT("LogMass"), ELogVerbosity::Log);

	if (InOutOptionalResult)
	{
		DependencyGraphFileName = InOutOptionalResult->DependencyGraphFileName;
	}

	bAnyCyclesDetected = false;

	UE_LOG(LogMass, Log, TEXT("Gathering dependencies data:"));

	AllNodes.Reset();
	NodeIndexMap.Reset();
	// as the very first node we add a "root" node that represents the "top level group" and also simplifies the rest
	// of the lookup code - if a processor declares it's in group None or depends on Node it we don't need to check that 
	// explicitly. 
	AllNodes.Add(FNode(FName(), nullptr, 0));
	NodeIndexMap.Add(FName(), 0);

	const bool bCreateVirtualArchetypes = (!EntityManager);
	if (bCreateVirtualArchetypes)
	{
		// create FMassEntityManager instance that we'll use to sort out processors' overlaps
		// the idea for this is that for every processor we have we create an archetype matching given processor's requirements. 
		// Once that's done we have a collection of "virtual" archetypes our processors expect. Then we ask every processor 
		// to cache the archetypes they'd accept, using processors' owned queries. The idea is that some of the nodes will 
		// end up with more than just the virtual archetype created for that specific node. The practice proved the idea correct. 
		EntityManager = MakeShareable(new FMassEntityManager());
	}

	// gather the processors information first
	for (UMassProcessor* Processor : Processors)
	{
		if (Processor == nullptr)
		{
			UE_LOG(LogMass, Warning, TEXT("%s nullptr found in Processors collection being processed"), ANSI_TO_TCHAR(__FUNCTION__));
			continue;
		}

		const int32 ProcessorNodeIndex = CreateNodes(*Processor);

		if (bCreateVirtualArchetypes)
		{
			// this line is a part of a nice trick we're doing here utilizing EntityManager's archetype creation based on 
			// what each processor expects, and EntityQuery's capability to cache archetypes matching its requirements (used below)
			EntityManager->CreateArchetype(AllNodes[ProcessorNodeIndex].Requirements.AsCompositionDescriptor());
		}
	}

	UE_LOG(LogMass, Verbose, TEXT("Pruning processors..."));

	int32 PrunedProcessorsCount = 0;
	for (FNode& Node : AllNodes)
	{
		if (Node.IsGroup() == false)
		{
			CA_ASSUME(Node.Processor); // as implied by Node.IsGroup() == false

			// for each processor-representing node we cache information on which archetypes among the once we've created 
			// above (see the EntityManager.CreateArchetype call in the previous loop) match this processor. 
			Node.Processor->GetArchetypesMatchingOwnedQueries(*EntityManager.Get(), Node.ValidArchetypes);

			// prune the archetype-less processors
			if (Node.ValidArchetypes.Num() == 0 && Node.Processor->ShouldAllowQueryBasedPruning(bGameRuntime))
			{
				UE_LOG(LogMass, Verbose, TEXT("\t%s"), *Node.Processor->GetName());

				if (InOutOptionalResult)
				{
					InOutOptionalResult->PrunedProcessorClasses.Add(Node.Processor->GetClass());
				}

				// clearing out the processor will result in the rest of the algorithm to treat it as a group - we still 
				// want to preserve the configured ExecuteBefore and ExecuteAfter dependencies
				Node.Processor = nullptr;
				++PrunedProcessorsCount;
			}
		}
	}

	UE_LOG(LogMass, Verbose, TEXT("Number of processors pruned: %d"), PrunedProcessorsCount);

	check(AllNodes.Num());
	LogNode(AllNodes[0]);

	BuildDependencies();

	// now none of the processor nodes depend on groups - we replaced these dependencies with depending directly 
	// on individual processors. However, we keep the group nodes around since we store the dependencies via index, so 
	// removing nodes would mess that up. Solve below ignores group nodes and OutResult will not have any groups once its done.

	Solve(OutResult);

	UE_LOG(LogMass, Verbose, TEXT("Dependency order:"));
	for (const FMassProcessorOrderInfo& Info : OutResult)
	{
		UE_LOG(LogMass, Verbose, TEXT("\t%s"), *Info.Name.ToString());
	}

	int32 MaxSequenceLength = 0;
	for (FNode& Node : AllNodes)
	{
		MaxSequenceLength = FMath::Max(MaxSequenceLength, Node.SequencePositionIndex);
	}

	UE_LOG(LogMass, Verbose, TEXT("Max sequence length: %d"), MaxSequenceLength);

	if (InOutOptionalResult)
	{
		InOutOptionalResult->MaxSequenceLength = MaxSequenceLength;
		InOutOptionalResult->ArchetypeDataVersion = EntityManager->GetArchetypeDataVersion();
	}
}

bool FMassProcessorDependencySolver::IsResultUpToDate(const FMassProcessorDependencySolver::FResult& InResult, TSharedPtr<FMassEntityManager> EntityManager)
{
	if (InResult.PrunedProcessorClasses.Num() == 0 || !EntityManager || InResult.ArchetypeDataVersion == EntityManager->GetArchetypeDataVersion())
	{
		return true;
	}

	// this is inefficient right now since we're using CDOs and need to check all archetypes every time.
	// Would be more efficient if we had a common place where all processors live, both active and inactive, so that we can utilize those. 
	for (const TSubclassOf<UMassProcessor>& ProcessorClass : InResult.PrunedProcessorClasses)
	{
		if (UMassProcessor* ProcessorCDO = ProcessorClass.GetDefaultObject())
		{
			if (ProcessorCDO->DoesAnyArchetypeMatchOwnedQueries(*EntityManager.Get()))
			{
				return false;
			}
		}
	}
	return true;
}

#undef LOCTEXT_NAMESPACE 
============================================================


=== MassEntity/Private/MassRequirementAccessDetector.cpp ===
============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassRequirementAccessDetector.h"
#if WITH_MASSENTITY_DEBUG
#include "MassEntityQuery.h"
#include "HAL/IConsoleManager.h"

namespace UE::Mass::Private
{
	bool bTrackRequirementsAccess = false;
	
	FAutoConsoleVariableRef CVarTrackRequirementsAccess(TEXT("mass.debug.TrackRequirementsAccess"), bTrackRequirementsAccess
		, TEXT("Enables Mass processing debugging mode where we monitor thread-safety of query requirements access."));
}

void FMassRequirementAccessDetector::Initialize()
{
	check(IsInGameThread());
	AddDetectors(FMassFragmentBitSet::FStructTrackerWrapper::StructTracker);
	AddDetectors(FMassChunkFragmentBitSet::FStructTrackerWrapper::StructTracker);
	AddDetectors(FMassSharedFragmentBitSet::FStructTrackerWrapper::StructTracker);
	AddDetectors(FMassExternalSubsystemBitSet::FStructTrackerWrapper::StructTracker);
}

void FMassRequirementAccessDetector::AddDetectors(const FStructTracker& StructTracker)
{
	TConstArrayView<TWeakObjectPtr<const UStruct>> Types = StructTracker.DebugGetAllStructTypes<UStruct>();
	for (TWeakObjectPtr<const UStruct> Type : Types)
	{
		check(Type.Get());
		Detectors.Add(Type.Get(), MakeShareable(new FRWAccessDetector()));
	}
}

void FMassRequirementAccessDetector::RequireAccess(const FMassEntityQuery& Query)
{
	if (UE::Mass::Private::bTrackRequirementsAccess)
	{
		Operation(Query.RequiredConstSubsystems, &FRWAccessDetector::AcquireReadAccess);
		Operation(Query.RequiredMutableSubsystems, &FRWAccessDetector::AcquireWriteAccess);
		
		Aquire(Query.FragmentRequirements);
		Aquire(Query.ChunkFragmentRequirements);
		Aquire(Query.ConstSharedFragmentRequirements);
		Aquire(Query.SharedFragmentRequirements);
	}
}

void FMassRequirementAccessDetector::ReleaseAccess(const FMassEntityQuery& Query)
{
	if (UE::Mass::Private::bTrackRequirementsAccess)
	{
		Operation(Query.RequiredConstSubsystems, &FRWAccessDetector::ReleaseReadAccess);
		Operation(Query.RequiredMutableSubsystems, &FRWAccessDetector::ReleaseWriteAccess);

		Release(Query.FragmentRequirements);
		Release(Query.ChunkFragmentRequirements);
		Release(Query.ConstSharedFragmentRequirements);
		Release(Query.SharedFragmentRequirements);
	}
}

#endif // WITH_MASSENTITY_DEBUG
============================================================


=== MassEntity/Private/MassRequirements.cpp ===
===============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassRequirements.h"
#include "MassArchetypeData.h"
#include "MassProcessorDependencySolver.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(MassRequirements)

#if WITH_MASSENTITY_DEBUG
#include "MassRequirementAccessDetector.h"
#endif // WITH_MASSENTITY_DEBUG


namespace UE::Mass::Private
{
	template<typename TContainer>
	void ExportRequirements(TConstArrayView<FMassFragmentRequirementDescription> Requirements, TMassExecutionAccess<TContainer>& Out)
	{
		for (const FMassFragmentRequirementDescription& Requirement : Requirements)
		{
			if (Requirement.Presence != EMassFragmentPresence::None)
			{
				check(Requirement.StructType);
				if (Requirement.AccessMode == EMassFragmentAccess::ReadOnly)
				{
					Out.Read.Add(*Requirement.StructType);
				}
				else if (Requirement.AccessMode == EMassFragmentAccess::ReadWrite)
				{
					Out.Write.Add(*Requirement.StructType);
				}
			}
		}
	}

	template<>
	void ExportRequirements<FMassConstSharedFragmentBitSet>(TConstArrayView<FMassFragmentRequirementDescription> Requirements
		, TMassExecutionAccess<FMassConstSharedFragmentBitSet>& Out)
	{
		for (const FMassFragmentRequirementDescription& Requirement : Requirements)
		{
			if (Requirement.Presence != EMassFragmentPresence::None)
			{
				check(Requirement.StructType);
				if (ensureMsgf(Requirement.AccessMode == EMassFragmentAccess::ReadOnly, TEXT("ReadOnly is the only supported AccessMode for ConstSharedFragments")))
				{
					Out.Read.Add(*Requirement.StructType);
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////
// FMassSubsystemRequirements

void FMassSubsystemRequirements::ExportRequirements(FMassExecutionRequirements& OutRequirements) const
{
	OutRequirements.RequiredSubsystems.Read += RequiredConstSubsystems;
	OutRequirements.RequiredSubsystems.Write += RequiredMutableSubsystems;
}

void FMassSubsystemRequirements::Reset()
{
	RequiredConstSubsystems.Reset();
	RequiredMutableSubsystems.Reset();
	bRequiresGameThreadExecution = false;
}

//////////////////////////////////////////////////////////////////////
// FMassFragmentRequirements

FMassFragmentRequirements::FMassFragmentRequirements(std::initializer_list<UScriptStruct*> InitList)
{
	for (const UScriptStruct* FragmentType : InitList)
	{
		AddRequirement(FragmentType, EMassFragmentAccess::ReadWrite, EMassFragmentPresence::All);
	}
}

FMassFragmentRequirements::FMassFragmentRequirements(TConstArrayView<const UScriptStruct*> InitList)
{
	for (const UScriptStruct* FragmentType : InitList)
	{
		AddRequirement(FragmentType, EMassFragmentAccess::ReadWrite, EMassFragmentPresence::All);
	}
}

FMassFragmentRequirements& FMassFragmentRequirements::ClearTagRequirements(const FMassTagBitSet& TagsToRemoveBitSet)
{
	RequiredAllTags.Remove(TagsToRemoveBitSet);
	RequiredAnyTags.Remove(TagsToRemoveBitSet);
	RequiredNoneTags.Remove(TagsToRemoveBitSet);
	RequiredOptionalTags.Remove(TagsToRemoveBitSet);

	return *this;
}

void FMassFragmentRequirements::SortRequirements()
{
	// we're sorting the Requirements the same way ArchetypeData's FragmentConfig is sorted (see FMassArchetypeData::Initialize)
	// so that when we access ArchetypeData.FragmentConfigs in FMassArchetypeData::BindRequirementsWithMapping
	// (via GetFragmentData call) the access is sequential (i.e. not random) and there's a higher chance the memory
	// FragmentConfigs we want to access have already been fetched and are available in processor cache.
	FragmentRequirements.Sort(FScriptStructSortOperator());
	ChunkFragmentRequirements.Sort(FScriptStructSortOperator());
	ConstSharedFragmentRequirements.Sort(FScriptStructSortOperator());
	SharedFragmentRequirements.Sort(FScriptStructSortOperator());
}

FORCEINLINE void FMassFragmentRequirements::CachePropreties() const
{
	if (bPropertiesCached == false)
	{
		bHasPositiveRequirements = !(RequiredAllTags.IsEmpty()
			&& RequiredAnyTags.IsEmpty()
			&& RequiredAllFragments.IsEmpty()
			&& RequiredAnyFragments.IsEmpty()
			&& RequiredAllChunkFragments.IsEmpty()
			&& RequiredAllSharedFragments.IsEmpty()
			&& RequiredAllConstSharedFragments.IsEmpty());

		bHasNegativeRequirements = !(RequiredNoneTags.IsEmpty()
			&& RequiredNoneFragments.IsEmpty()
			&& RequiredNoneChunkFragments.IsEmpty()
			&& RequiredNoneSharedFragments.IsEmpty()
			&& RequiredNoneConstSharedFragments.IsEmpty());

		bHasOptionalRequirements = !(RequiredOptionalFragments.IsEmpty()
				&& RequiredOptionalTags.IsEmpty()
				&& RequiredOptionalChunkFragments.IsEmpty()
				&& RequiredOptionalSharedFragments.IsEmpty()
				&& RequiredOptionalConstSharedFragments.IsEmpty());

		bPropertiesCached = true;
	}
}

bool FMassFragmentRequirements::CheckValidity() const
{
	CachePropreties();
	// @todo we need to add more sophisticated testing somewhere to detect contradicting requirements - like having and not having a given tag.
	return bHasPositiveRequirements || bHasNegativeRequirements || bHasOptionalRequirements;
}

bool FMassFragmentRequirements::IsEmpty() const
{
	CachePropreties();
	// note that even though at the moment the following condition is the same as negation of current CheckValidity value
	// that will change in the future (with additional validity checks).
	return !bHasPositiveRequirements && !bHasNegativeRequirements && !bHasOptionalRequirements;
}

bool FMassFragmentRequirements::DoesMatchAnyOptionals(const FMassArchetypeCompositionDescriptor& ArchetypeComposition) const
{
	return bHasOptionalRequirements
		&& (ArchetypeComposition.Fragments.HasAny(RequiredOptionalFragments)
			|| ArchetypeComposition.Tags.HasAny(RequiredOptionalTags)
			|| ArchetypeComposition.ChunkFragments.HasAny(RequiredOptionalChunkFragments)
			|| ArchetypeComposition.SharedFragments.HasAny(RequiredOptionalSharedFragments)
			|| ArchetypeComposition.ConstSharedFragments.HasAny(RequiredOptionalConstSharedFragments));
}

bool FMassFragmentRequirements::DoesArchetypeMatchRequirements(const FMassArchetypeHandle& ArchetypeHandle) const
{
	check(ArchetypeHandle.IsValid());
	const FMassArchetypeData* Archetype = FMassArchetypeHelper::ArchetypeDataFromHandle(ArchetypeHandle);
	CA_ASSUME(Archetype);

	return DoesArchetypeMatchRequirements(Archetype->GetCompositionDescriptor());
}
	
bool FMassFragmentRequirements::DoesArchetypeMatchRequirements(const FMassArchetypeCompositionDescriptor& ArchetypeComposition) const
{
	CachePropreties();

	const bool bPassNegativeFilter = bHasNegativeRequirements == false
		|| (ArchetypeComposition.Fragments.HasNone(RequiredNoneFragments)
			&& ArchetypeComposition.Tags.HasNone(RequiredNoneTags)
			&& ArchetypeComposition.ChunkFragments.HasNone(RequiredNoneChunkFragments)
			&& ArchetypeComposition.SharedFragments.HasNone(RequiredNoneSharedFragments)
			&& ArchetypeComposition.ConstSharedFragments.HasNone(RequiredNoneConstSharedFragments));
	
	if (bPassNegativeFilter)
	{
		if (bHasPositiveRequirements)
		{
			return ArchetypeComposition.Fragments.HasAll(RequiredAllFragments)
				&& (RequiredAnyFragments.IsEmpty() || ArchetypeComposition.Fragments.HasAny(RequiredAnyFragments))
				&& ArchetypeComposition.Tags.HasAll(RequiredAllTags)
				&& (RequiredAnyTags.IsEmpty() || ArchetypeComposition.Tags.HasAny(RequiredAnyTags))
				&& ArchetypeComposition.ChunkFragments.HasAll(RequiredAllChunkFragments)
				&& ArchetypeComposition.SharedFragments.HasAll(RequiredAllSharedFragments)
				&& ArchetypeComposition.ConstSharedFragments.HasAll(RequiredAllConstSharedFragments);
		}
		else if (bHasOptionalRequirements)
		{
			return DoesMatchAnyOptionals(ArchetypeComposition);
		}
		// else - it's fine, we passed all the filters that have been set up
		return true;
	}
	return false;
}

void FMassFragmentRequirements::ExportRequirements(FMassExecutionRequirements& OutRequirements) const
{
	using UE::Mass::Private::ExportRequirements;
	ExportRequirements<FMassFragmentBitSet>(FragmentRequirements, OutRequirements.Fragments);
	ExportRequirements<FMassChunkFragmentBitSet>(ChunkFragmentRequirements, OutRequirements.ChunkFragments);
	ExportRequirements<FMassSharedFragmentBitSet>(SharedFragmentRequirements, OutRequirements.SharedFragments);
	ExportRequirements<FMassConstSharedFragmentBitSet>(ConstSharedFragmentRequirements, OutRequirements.ConstSharedFragments);

	OutRequirements.RequiredAllTags = RequiredAllTags;
	OutRequirements.RequiredAnyTags = RequiredAnyTags;
	OutRequirements.RequiredNoneTags = RequiredNoneTags;
	// not exporting optional tags by design
}

void FMassFragmentRequirements::Reset()
{
	FragmentRequirements.Reset();
	ChunkFragmentRequirements.Reset();
	ConstSharedFragmentRequirements.Reset();
	SharedFragmentRequirements.Reset();
	RequiredAllTags.Reset();
	RequiredAnyTags.Reset();
	RequiredNoneTags.Reset();
	RequiredAllFragments.Reset();
	RequiredAnyFragments.Reset();
	RequiredOptionalFragments.Reset();
	RequiredNoneFragments.Reset();
	RequiredAllChunkFragments.Reset();
	RequiredOptionalChunkFragments.Reset();
	RequiredNoneChunkFragments.Reset();
	RequiredAllSharedFragments.Reset();
	RequiredOptionalSharedFragments.Reset();
	RequiredNoneSharedFragments.Reset();
	RequiredAllConstSharedFragments.Reset();
	RequiredOptionalConstSharedFragments.Reset();
	RequiredNoneConstSharedFragments.Reset();

	IncrementalChangesCount = 0;
}

===============================================


=== MassEntity/Private/MassSettings.cpp ===
===========================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSettings.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(MassSettings)


//----------------------------------------------------------------------//
//  UMassModuleSettings
//----------------------------------------------------------------------//
void UMassModuleSettings::PostInitProperties()
{
	Super::PostInitProperties();

	if (HasAnyFlags(RF_ClassDefaultObject) && !GetClass()->HasAnyClassFlags(CLASS_Abstract))
	{
		// register with UMassGameplaySettings
		GetMutableDefault<UMassSettings>()->RegisterModuleSettings(*this);
	}
}

//----------------------------------------------------------------------//
//  UMassSettings
//----------------------------------------------------------------------//
void UMassSettings::RegisterModuleSettings(UMassModuleSettings& SettingsCDO)
{
	ensureMsgf(SettingsCDO.HasAnyFlags(RF_ClassDefaultObject), TEXT("Registered ModuleSettings need to be its class's CDO"));

	// we should consider a replacement in case we're hot-reloading
	FName EntryName = SettingsCDO.GetClass()->GetFName();

#if WITH_EDITOR
	static const FName DisplayNameMeta(TEXT("DisplayName")); 
	// try reading better name from meta data, available only in editor. Besides, we don't really care about this out 
	// side of editor. We could even skip populating ModuleSettings but we'll leave it as is for now.
	const FString& DisplayNameValue = SettingsCDO.GetClass()->GetMetaData(DisplayNameMeta);
	if (DisplayNameValue.Len())
	{
		EntryName = *DisplayNameValue;
	}
#endif // WITH_EDITOR

	TObjectPtr<UMassModuleSettings>& FoundModuleEntry = ModuleSettings.FindOrAdd(EntryName, &SettingsCDO);
	FoundModuleEntry = &SettingsCDO;
}


===========================================


=== MassEntity/Private/MassSubsystemAccess.cpp ===
==================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSubsystemAccess.h"


namespace UE::Mass::Private
{
	template<typename T>
	TSubclassOf<T> ConvertToSubsystemClass(TSubclassOf<USubsystem> SubsystemClass)
	{
		return *(reinterpret_cast<TSubclassOf<T>*>(&SubsystemClass));
	}
}

//////////////////////////////////////////////////////////////////////////
// FMassSubsystemAccess

FMassSubsystemAccess::FMassSubsystemAccess(UWorld* InWorld)
	: World(InWorld)
{
	Subsystems.AddZeroed(FMassExternalSubsystemBitSet::GetMaxNum());
}

USubsystem* FMassSubsystemAccess::FetchSubsystemInstance(UWorld* World, TSubclassOf<USubsystem> SubsystemClass)
{
	QUICK_SCOPE_CYCLE_COUNTER(Mass_FetchSubsystemInstance);

	check(SubsystemClass);
	if (SubsystemClass->IsChildOf<UWorldSubsystem>())
	{
		return World 
			? World->GetSubsystemBase(UE::Mass::Private::ConvertToSubsystemClass<UWorldSubsystem>(SubsystemClass)) 
			: nullptr;
	}
	if (SubsystemClass->IsChildOf<UEngineSubsystem>())
	{
		return GEngine->GetEngineSubsystemBase(UE::Mass::Private::ConvertToSubsystemClass<UEngineSubsystem>(SubsystemClass));
	}
	if (SubsystemClass->IsChildOf<UGameInstanceSubsystem>())
	{
		return (World && World->GetGameInstance())
			? World->GetGameInstance()->GetSubsystemBase(UE::Mass::Private::ConvertToSubsystemClass<UGameInstanceSubsystem>(SubsystemClass))
			: nullptr;
	}
	if (SubsystemClass->IsChildOf<ULocalPlayerSubsystem>())
	{
		const ULocalPlayer* LocalPlayer = World ? World->GetFirstLocalPlayerFromController() : nullptr;
		return LocalPlayer
			? LocalPlayer->GetSubsystemBase(UE::Mass::Private::ConvertToSubsystemClass<ULocalPlayerSubsystem>(SubsystemClass))
			: nullptr;
	}
#if WITH_EDITOR
	if (SubsystemClass->IsChildOf<UEditorSubsystem>())
	{
		return GEditor->GetEditorSubsystemBase(UE::Mass::Private::ConvertToSubsystemClass<UEditorSubsystem>(SubsystemClass));
	}
#endif // WITH_EDITOR
	return nullptr;
}

bool FMassSubsystemAccess::CacheSubsystemRequirements(const FMassSubsystemRequirements& SubsystemRequirements)
{
	bool bResult = true;

	if (SubsystemRequirements.IsEmpty() == false)
	{
		for (FMassExternalSubsystemBitSet::FIndexIterator It = SubsystemRequirements.GetRequiredConstSubsystems().GetIndexIterator(); It && bResult; ++It)
		{
			bResult = bResult && CacheSubsystem(*It);
		}

		for (FMassExternalSubsystemBitSet::FIndexIterator It = SubsystemRequirements.GetRequiredMutableSubsystems().GetIndexIterator(); It && bResult; ++It)
		{
			bResult = bResult && CacheSubsystem(*It);
		}
	}

	if (bResult)
	{
		ConstSubsystemsBitSet = SubsystemRequirements.GetRequiredConstSubsystems();
		MutableSubsystemsBitSet = SubsystemRequirements.GetRequiredMutableSubsystems();
	}

	return bResult;
}

bool FMassSubsystemAccess::CacheSubsystem(const uint32 SystemIndex)
{
	if (UNLIKELY(Subsystems.IsValidIndex(SystemIndex) == false))
	{
		Subsystems.AddZeroed(Subsystems.Num() - SystemIndex + 1);
	}

	if (Subsystems[SystemIndex])
	{
		return true;
	}

	const UClass* SubsystemClass = FMassExternalSubsystemBitSet::GetTypeAtIndex(SystemIndex);
	checkSlow(SubsystemClass);

	TSubclassOf<USubsystem> SubsystemSubclass(const_cast<UClass*>(SubsystemClass));
	checkSlow(*SubsystemSubclass);

	if (SubsystemSubclass)
	{
		USubsystem* SystemInstance = FMassSubsystemAccess::FetchSubsystemInstance(World.Get(), SubsystemSubclass);
		Subsystems[SystemIndex] = SystemInstance;
		return SystemInstance != nullptr;
	}

	return false;
}

void FMassSubsystemAccess::SetSubsystemRequirements(const FMassSubsystemRequirements& SubsystemRequirements)
{
	ConstSubsystemsBitSet = SubsystemRequirements.GetRequiredConstSubsystems();
	MutableSubsystemsBitSet = SubsystemRequirements.GetRequiredMutableSubsystems();
}

==================================================


=== MassEntity/Private/MassSubsystemBase.cpp ===
================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSubsystemBase.h"
#include "HAL/IConsoleManager.h"
#include "Engine/World.h"


namespace UE::Mass::Private
{
/** 
 * A helper function calling PostInitialize and OnWorldBeginPlay for the given subsystem, provided the world has already begun play.
 * @see UMassSubsystemBase::HandleLateCreation for more detail
 */
void HandleLateCreation(UWorldSubsystem& MassWorldSubsystem, const UE::Mass::Subsystems::FInitializationState InitializationState)
{
	// handle late creation
	UWorld* World = MassWorldSubsystem.GetWorld();
	if (World)
	{
		if (World->IsInitialized() == true && InitializationState.bPostInitializeCalled == false)
		{
			MassWorldSubsystem.PostInitialize();
		}
		if (World->HasBegunPlay() == true && InitializationState.bOnWorldBeginPlayCalled == false)
		{
			MassWorldSubsystem.OnWorldBeginPlay(*World);
		}
	}
}

bool bRuntimeSubsystemsEnabled = true;

namespace
{
	FAutoConsoleVariableRef AnonymousCVars[] =
	{
		{ TEXT("mass.RuntimeSubsystemsEnabled")
		, bRuntimeSubsystemsEnabled
		, TEXT("true by default, setting to false will prevent auto-creation of game-time Mass-related subsystems. Needs to be set before world loading.")
		, ECVF_Default }
	};
}
} // UE::Mass::Private


//-----------------------------------------------------------------------------
// UMassSubsystemBase
//-----------------------------------------------------------------------------
bool UMassSubsystemBase::AreRuntimeMassSubsystemsAllowed(UObject* Outer)
{
	return UE::Mass::Private::bRuntimeSubsystemsEnabled;
}

bool UMassSubsystemBase::ShouldCreateSubsystem(UObject* Outer) const 
{
	return UMassSubsystemBase::AreRuntimeMassSubsystemsAllowed(Outer) && Super::ShouldCreateSubsystem(Outer);
}

void UMassSubsystemBase::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	// This ensure is here to make sure we handle HandleLateCreation() gracefully, we dont expect it to ever trigger unless users start to manually call the functions
	ensureMsgf(InitializationState.bInitializeCalled == false, TEXT("%hs called multiple times"), __FUNCTION__);
	InitializationState.bInitializeCalled = true;
}

void UMassSubsystemBase::PostInitialize()
{
	Super::PostInitialize();

	// This ensure is here to make sure we handle HandleLateCreation() gracefully, we dont expect it to ever trigger unless users start to manually call the functions
	ensureMsgf(InitializationState.bPostInitializeCalled == false, TEXT("%hs called multiple times"), __FUNCTION__);
	InitializationState.bPostInitializeCalled = true;
}

void UMassSubsystemBase::Deinitialize()
{
	InitializationState = UE::Mass::Subsystems::FInitializationState();

	Super::Deinitialize();
}

void UMassSubsystemBase::OnWorldBeginPlay(UWorld& InWorld)
{
	Super::OnWorldBeginPlay(InWorld);

	// This ensure is here to make sure we handle HandleLateCreation() gracefully, we dont expect it to ever trigger unless users start to manually call the functions
	ensureMsgf(InitializationState.bOnWorldBeginPlayCalled == false, TEXT("%hs called multiple times"), __FUNCTION__);
	InitializationState.bOnWorldBeginPlayCalled = true;
}

void UMassSubsystemBase::HandleLateCreation()
{
	UE::Mass::Private::HandleLateCreation(*this, InitializationState);
}

//-----------------------------------------------------------------------------
// UMassTickableSubsystemBase
//-----------------------------------------------------------------------------
bool UMassTickableSubsystemBase::ShouldCreateSubsystem(UObject* Outer) const
{
	return UMassSubsystemBase::AreRuntimeMassSubsystemsAllowed(Outer) && Super::ShouldCreateSubsystem(Outer);
}

void UMassTickableSubsystemBase::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	// This ensure is here to make sure we handle HandleLateCreation() gracefully, we dont expect it to ever trigger unless users start to manually call the functions
	ensureMsgf(InitializationState.bInitializeCalled == false, TEXT("%hs called multiple times"), __FUNCTION__);
	InitializationState.bInitializeCalled = true;
}

void UMassTickableSubsystemBase::PostInitialize()
{
	Super::PostInitialize();

	// This ensure is here to make sure we handle HandleLateCreation() gracefully, we dont expect it to ever trigger unless users start to manually call the functions
	ensureMsgf(InitializationState.bPostInitializeCalled == false, TEXT("%hs called multiple times"), __FUNCTION__);
	InitializationState.bPostInitializeCalled = true;
}

void UMassTickableSubsystemBase::Deinitialize()
{
	InitializationState = UE::Mass::Subsystems::FInitializationState();

	Super::Deinitialize();
}

void UMassTickableSubsystemBase::OnWorldBeginPlay(UWorld& InWorld)
{
	Super::OnWorldBeginPlay(InWorld);

	// This ensure is here to make sure we handle HandleLateCreation() gracefully, we dont expect it to ever trigger unless users start to manually call the functions
	ensureMsgf(InitializationState.bOnWorldBeginPlayCalled == false, TEXT("%hs called multiple times"), __FUNCTION__);
	InitializationState.bOnWorldBeginPlayCalled = true;
}

void UMassTickableSubsystemBase::HandleLateCreation()
{
	UE::Mass::Private::HandleLateCreation(*this, InitializationState);
}

================================================


=== MassEntity/Public/MassArchetypeTypes.h ===
==============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "UObject/Class.h"
#include "Containers/ArrayView.h"
#include "Containers/StridedView.h"
#include "Containers/UnrealString.h"
#include "MassEntityTypes.h"

struct FMassEntityManager;
struct FMassArchetypeData;
struct FMassExecutionContext;
struct FMassFragment;
struct FMassArchetypeChunkIterator;
struct FMassEntityQuery;
struct FMassArchetypeEntityCollection;
struct FMassEntityView;
struct FMassDebugger;
struct FMassArchetypeHelper;

typedef TFunction< void(FMassExecutionContext& /*ExecutionContext*/) > FMassExecuteFunction;
typedef TFunction< bool(const FMassExecutionContext& /*ExecutionContext*/) > FMassChunkConditionFunction;


//////////////////////////////////////////////////////////////////////
// FMassArchetypeHandle

// An opaque handle to an archetype
struct FMassArchetypeHandle final
{
	FMassArchetypeHandle() = default;
	bool IsValid() const { return DataPtr.IsValid(); }

	bool operator==(const FMassArchetypeHandle& Other) const { return DataPtr == Other.DataPtr; }
	bool operator!=(const FMassArchetypeHandle& Other) const { return DataPtr != Other.DataPtr; }

	MASSENTITY_API friend uint32 GetTypeHash(const FMassArchetypeHandle& Instance);
private:
	FMassArchetypeHandle(const TSharedPtr<FMassArchetypeData>& InDataPtr)
	: DataPtr(InDataPtr)
	{}
	TSharedPtr<FMassArchetypeData> DataPtr;

	friend FMassArchetypeHelper;
	friend FMassEntityManager;
};


//////////////////////////////////////////////////////////////////////
// FMassArchetypeEntityCollection 

/** A struct that converts an arbitrary array of entities of given Archetype into a sequence of continuous
 *  entity chunks. The goal is to have the user create an instance of this struct once and run through a bunch of
 *  systems. The runtime code usually uses FMassArchetypeChunkIterator to iterate on the chunk collection.
 */
struct MASSENTITY_API FMassArchetypeEntityCollection 
{
public:
	struct FArchetypeEntityRange
	{
		int32 ChunkIndex = INDEX_NONE;
		int32 SubchunkStart = 0;
		/** negative or 0-length means "all available entities within chunk" */
		int32 Length = 0;

		FArchetypeEntityRange() = default;
		explicit FArchetypeEntityRange(const int32 InChunkIndex, const int32 InSubchunkStart = 0, const int32 InLength = 0) : ChunkIndex(InChunkIndex), SubchunkStart(InSubchunkStart), Length(InLength) {}
		/** Note that we consider invalid-length chunks valid as long as ChunkIndex and SubchunkStart are valid */
		bool IsSet() const { return ChunkIndex != INDEX_NONE && SubchunkStart >= 0; }

		/** Checks if given InRange comes right after this instance */
		bool IsAdjacentAfter(const FArchetypeEntityRange& Other) const
		{
			return ChunkIndex == Other.ChunkIndex && SubchunkStart + Length == Other.SubchunkStart;
		}

		bool operator==(const FArchetypeEntityRange& Other) const
		{
			return ChunkIndex == Other.ChunkIndex && SubchunkStart == Other.SubchunkStart && Length == Other.Length;
		}
		bool operator!=(const FArchetypeEntityRange& Other) const { return !(*this == Other); }
	};

	enum EDuplicatesHandling
	{
		NoDuplicates,	// indicates that the caller guarantees there are no duplicates in the input Entities collection
						// note that in no-shipping builds a `check` will fail if duplicates are present.
		FoldDuplicates,	// indicates that it's possible that Entities contains duplicates. The input Entities collection 
						// will be processed and duplicates will be removed.
	};

	enum EInitializationType
	{
		GatherAll,	// default behavior, makes given FMassArchetypeEntityCollection instance represent all entities of the given archetype
		DoNothing,	// meant for procedural population by external code (like child classes)
	};

	using FEntityRangeArray = TArray<FArchetypeEntityRange>;
	using FConstEntityRangeArrayView = TConstArrayView<FArchetypeEntityRange>;

private:
	FEntityRangeArray Ranges;
	/** entity indices indicated by EntityRanges are only valid with given Archetype */
	FMassArchetypeHandle Archetype;

public:
	FMassArchetypeEntityCollection() = default;
	FMassArchetypeEntityCollection(const FMassArchetypeHandle& InArchetype, TConstArrayView<FMassEntityHandle> InEntities, EDuplicatesHandling DuplicatesHandling);
	explicit FMassArchetypeEntityCollection(const FMassArchetypeHandle& InArchetypeHandle, const EInitializationType Initialization = EInitializationType::GatherAll);
	explicit FMassArchetypeEntityCollection(TSharedPtr<FMassArchetypeData>& InArchetype, const EInitializationType Initialization = EInitializationType::GatherAll);
	FMassArchetypeEntityCollection(const FMassArchetypeHandle& InArchetypeHandle, FEntityRangeArray&& InEntityRanges)
		: Ranges(MoveTemp(InEntityRanges))
		, Archetype(InArchetypeHandle)
	{}

	FConstEntityRangeArrayView GetRanges() const { return Ranges; }
	const FMassArchetypeHandle& GetArchetype() const { return Archetype; }
	bool IsEmpty() const { return Ranges.Num() == 0 && Archetype.IsValid() == false; }
	bool IsSet() const { return Archetype.IsValid(); }
	void Reset() 
	{ 
		Archetype = FMassArchetypeHandle();
		Ranges.Reset();
	}

	/** The comparison function that checks if Other is identical to this. Intended for diagnostics/debugging. */
	bool IsSame(const FMassArchetypeEntityCollection& Other) const;

protected:
	friend struct FMassArchetypeEntityCollectionWithPayload;
	void BuildEntityRanges(TStridedView<const int32> TrueIndices);
	
private:
	void GatherChunksFromArchetype();
};

struct MASSENTITY_API FMassArchetypeEntityCollectionWithPayload
{
	explicit FMassArchetypeEntityCollectionWithPayload(const FMassArchetypeEntityCollection& InEntityCollection)
		: Entities(InEntityCollection)
	{
	}

	static void CreateEntityRangesWithPayload(const FMassEntityManager& EntitySubsystem, const TConstArrayView<FMassEntityHandle> Entities
		, const FMassArchetypeEntityCollection::EDuplicatesHandling DuplicatesHandling, FMassGenericPayloadView Payload
		, TArray<FMassArchetypeEntityCollectionWithPayload>& OutEntityCollections);

	const FMassArchetypeEntityCollection& GetEntityCollection() const { return Entities; }
	const FMassGenericPayloadViewSlice& GetPayload() const { return PayloadSlice; }

private:
	FMassArchetypeEntityCollectionWithPayload(const FMassArchetypeHandle& InArchetype, TStridedView<const int32> TrueIndices, FMassGenericPayloadViewSlice&& Payload);

	FMassArchetypeEntityCollection Entities;
	FMassGenericPayloadViewSlice PayloadSlice;
};

//////////////////////////////////////////////////////////////////////
// FMassArchetypeChunkIterator

/**
 *  The type used to iterate over given archetype's chunks, be it full, continuous chunks or sparse subchunks. It hides
 *  this details from the rest of the system.
 */
struct MASSENTITY_API FMassArchetypeChunkIterator
{
private:
	FMassArchetypeEntityCollection::FConstEntityRangeArrayView EntityRanges;
	int32 CurrentChunkIndex = 0;

public:
	explicit FMassArchetypeChunkIterator(const FMassArchetypeEntityCollection::FConstEntityRangeArrayView& InEntityRanges) : EntityRanges(InEntityRanges), CurrentChunkIndex(0) {}

	operator bool() const { return EntityRanges.IsValidIndex(CurrentChunkIndex) && EntityRanges[CurrentChunkIndex].IsSet(); }
	FMassArchetypeChunkIterator& operator++() { ++CurrentChunkIndex; return *this; }

	const FMassArchetypeEntityCollection::FArchetypeEntityRange* operator->() const { check(bool(*this)); return &EntityRanges[CurrentChunkIndex]; }
	const FMassArchetypeEntityCollection::FArchetypeEntityRange& operator*() const { check(bool(*this)); return EntityRanges[CurrentChunkIndex]; }
};

//////////////////////////////////////////////////////////////////////
// FMassRawEntityInChunkData

struct FMassRawEntityInChunkData 
{
	FMassRawEntityInChunkData() = default;
	FMassRawEntityInChunkData(uint8* InChunkRawMemory, const int32 InIndexWithinChunk)
        : ChunkRawMemory(InChunkRawMemory), IndexWithinChunk(InIndexWithinChunk)
	{}
	bool IsValid() const { return ChunkRawMemory != nullptr && IndexWithinChunk != INDEX_NONE; }
	bool operator==(const FMassRawEntityInChunkData & Other) const { return ChunkRawMemory == Other.ChunkRawMemory && IndexWithinChunk == Other.IndexWithinChunk; }

	uint8* ChunkRawMemory = nullptr;
	int32 IndexWithinChunk = INDEX_NONE;
};

//////////////////////////////////////////////////////////////////////
// FMassQueryRequirementIndicesMapping

using FMassFragmentIndicesMapping = TArray<int32, TInlineAllocator<16>>;

struct FMassQueryRequirementIndicesMapping
{
	FMassQueryRequirementIndicesMapping() = default;

	FMassFragmentIndicesMapping EntityFragments;
	FMassFragmentIndicesMapping ChunkFragments;
	FMassFragmentIndicesMapping ConstSharedFragments;
	FMassFragmentIndicesMapping SharedFragments;
	FORCEINLINE bool IsEmpty() const
	{
		return EntityFragments.Num() == 0 || ChunkFragments.Num() == 0;
	}
};

==============================================


=== MassEntity/Public/MassCommandBuffer.h ===
=============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "MassEntityManager.h"
#include "Misc/MTAccessDetector.h"
#include "MassEntityUtils.h"
#include "MassCommands.h"

//@TODO: Consider debug information in case there is an assert when replaying the command buffer
// (e.g., which system added the command, or even file/line number in development builds for the specific call via a macro)

#define COMMAND_PUSHING_CHECK() \
checkf(IsFlushing() == false, TEXT("Trying to push commands is not supported while the given buffer is being flushed")); \
checkf(OwnerThreadId == FPlatformTLS::GetCurrentThreadId(), TEXT("Commands can be pushed only in the same thread where the command buffer was created."))

struct MASSENTITY_API FMassCommandBuffer
{
public:
	FMassCommandBuffer();
	~FMassCommandBuffer();

	/** Adds a new entry to a given TCommand batch command instance */
	template< template<typename... TArgs> typename TCommand, typename... TArgs >
	void PushCommand(const FMassEntityHandle Entity, TArgs&&... InArgs)
	{
		COMMAND_PUSHING_CHECK();

		LLM_SCOPE_BYNAME(TEXT("Mass/PushCommand"));
		TCommand<TArgs...>& Instance = CreateOrAddCommand<TCommand<TArgs...>>();
		Instance.Add(Entity, Forward<TArgs>(InArgs)...);
		++ActiveCommandsCounter;
	}

	template<typename TCommand, typename... TArgs>
	void PushCommand(TArgs&&... InArgs)
	{
		COMMAND_PUSHING_CHECK();

		LLM_SCOPE_BYNAME(TEXT("Mass/PushCommand"));
		TCommand& Instance = CreateOrAddCommand<TCommand>();
		Instance.Add(Forward<TArgs>(InArgs)...);
		++ActiveCommandsCounter;
	}

	/** Adds a new entry to a given TCommand batch command instance */
	template< typename TCommand>
	void PushCommand(const FMassEntityHandle Entity)
	{
		COMMAND_PUSHING_CHECK();

		LLM_SCOPE_BYNAME(TEXT("Mass/PushCommand"));
		CreateOrAddCommand<TCommand>().Add(Entity);
		++ActiveCommandsCounter;
	}

	template< typename TCommand>
	void PushCommand(TConstArrayView<FMassEntityHandle> Entities)
	{
		COMMAND_PUSHING_CHECK();

		LLM_SCOPE_BYNAME(TEXT("Mass/PushCommand"));
		CreateOrAddCommand<TCommand>().Add(Entities);
		++ActiveCommandsCounter;
	}

	template<typename T>
	void AddFragment(FMassEntityHandle Entity)
	{
		static_assert(TIsDerivedFrom<T, FMassFragment>::IsDerived, "Given struct type is not a valid fragment type.");
		PushCommand<FMassCommandAddFragmentsInternal<EMassCommandCheckTime::CompileTimeCheck, T>>(Entity);
	}

	template<typename T>
	void AddFragment_RuntimeCheck(FMassEntityHandle Entity)
	{
		checkf(T::StaticStruct()->IsChildOf(FMassFragment::StaticStruct()), TEXT("Given struct type is not a valid fragment type."));
		PushCommand<FMassCommandAddFragmentsInternal<EMassCommandCheckTime::RuntimeCheck, T>>(Entity);
	}

	template<typename T>
	void RemoveFragment(FMassEntityHandle Entity)
	{
		static_assert(TIsDerivedFrom<T, FMassFragment>::IsDerived, "Given struct type is not a valid fragment type.");
		PushCommand<FMassCommandRemoveFragmentsInternal<EMassCommandCheckTime::CompileTimeCheck, T>>(Entity);
	}

	template<typename T>
	void RemoveFragment_RuntimeCheck(FMassEntityHandle Entity)
	{
		checkf(T::StaticStruct()->IsChildOf(FMassFragment::StaticStruct()), TEXT("Given struct type is not a valid fragment type."));
		PushCommand<FMassCommandRemoveFragmentsInternal<EMassCommandCheckTime::RuntimeCheck, T>>(Entity);
	}

	/** the convenience function equivalent to calling PushCommand<FMassCommandAddTag<T>>(Entity) */
	template<typename T>
	void AddTag(FMassEntityHandle Entity)
	{
		static_assert(TIsDerivedFrom<T, FMassTag>::IsDerived, "Given struct type is not a valid tag type.");
		PushCommand<FMassCommandAddTagsInternal<EMassCommandCheckTime::CompileTimeCheck, T>>(Entity);
	}

	template<typename T>
	void AddTag_RuntimeCheck(FMassEntityHandle Entity)
	{
		checkf(T::StaticStruct()->IsChildOf(FMassTag::StaticStruct()), TEXT("Given struct type is not a valid tag type."));
		PushCommand<FMassCommandAddTagsInternal<EMassCommandCheckTime::RuntimeCheck, T>>(Entity);
	}

	/** the convenience function equivalent to calling PushCommand<FMassCommandRemoveTag<T>>(Entity) */
	template<typename T>
	void RemoveTag(FMassEntityHandle Entity)
	{
		static_assert(TIsDerivedFrom<T, FMassTag>::IsDerived, "Given struct type is not a valid tag type.");
		PushCommand<FMassCommandRemoveTagsInternal<EMassCommandCheckTime::CompileTimeCheck, T>>(Entity);
	}

	template<typename T>
	void RemoveTag_RuntimeCheck(FMassEntityHandle Entity)
	{
		checkf(T::StaticStruct()->IsChildOf(FMassTag::StaticStruct()), TEXT("Given struct type is not a valid tag type."));
		PushCommand<FMassCommandRemoveTagsInternal<EMassCommandCheckTime::RuntimeCheck, T>>(Entity);
	}

	/** the convenience function equivalent to calling PushCommand<FMassCommandSwapTags<TOld, TNew>>(Entity)  */
	template<typename TOld, typename TNew>
	void SwapTags(FMassEntityHandle Entity)
	{
		static_assert(TIsDerivedFrom<TOld, FMassTag>::IsDerived, "Given struct type is not a valid tag type.");
		static_assert(TIsDerivedFrom<TNew, FMassTag>::IsDerived, "Given struct type is not a valid tag type.");
		PushCommand<FMassCommandSwapTagsInternal<EMassCommandCheckTime::CompileTimeCheck, TOld, TNew>>(Entity);
	}

	template<typename TOld, typename TNew>
	void SwapTags_RuntimeCheck(FMassEntityHandle Entity)
	{
		checkf(TOld::StaticStruct()->IsChildOf(FMassTag::StaticStruct()), TEXT("Given struct type is not a valid tag type."));
		checkf(TNew::StaticStruct()->IsChildOf(FMassTag::StaticStruct()), TEXT("Given struct type is not a valid tag type."));
		PushCommand<FMassCommandSwapTagsInternal<EMassCommandCheckTime::RuntimeCheck, TOld, TNew>>(Entity);
	}

	void DestroyEntity(FMassEntityHandle Entity)
	{
		PushCommand<FMassCommandDestroyEntities>(Entity);
	}

	void DestroyEntities(TConstArrayView<FMassEntityHandle> InEntitiesToDestroy)
	{
		PushCommand<FMassCommandDestroyEntities>(InEntitiesToDestroy);
	}

	SIZE_T GetAllocatedSize() const;

	/** 
	 * Appends the commands from the passed buffer into this one
	 * @param InOutOther the source buffer to copy the commands from. Note that after the call the InOutOther will be 
	 *	emptied due to the function using Move semantics
	 */
	void MoveAppend(FMassCommandBuffer& InOutOther);

	bool HasPendingCommands() const 
	{
		return ActiveCommandsCounter > 0;
	}
	bool IsFlushing() const { return bIsFlushing; }

private:
	friend FMassEntityManager;

	void ForceUpdateCurrentThreadID();

	template<typename T>
	T& CreateOrAddCommand()
	{
		const int32 Index = FMassBatchedCommand::GetCommandIndex<T>();

		if (CommandInstances.IsValidIndex(Index) == false)
		{
			CommandInstances.AddZeroed(Index - CommandInstances.Num() + 1);
		}
		else if (CommandInstances[Index])
		{
			return (T&)(*CommandInstances[Index].Get());
		}

		CommandInstances[Index] = MakeUnique<T>();
		return (T&)(*CommandInstances[Index].Get());
	}

	/** 
	 * Executes all accumulated commands. 
	 * @return whether any commands have actually been executed
	 */
	bool Flush(FMassEntityManager& EntityManager);
	void CleanUp();

	FCriticalSection AppendingCommandsCS;

	UE_MT_DECLARE_RW_ACCESS_DETECTOR(PendingBatchCommandsDetector);
	/** 
	 * Commands created for this specific command buffer. All commands in the array are unique (by type) and reusable 
	 * with subsequent PushCommand calls
	 */
	TArray<TUniquePtr<FMassBatchedCommand>> CommandInstances;
	/** 
	 * Commands appended to this command buffer (via FMassCommandBuffer::MoveAppend). These commands are just naive list
	 * of commands, potentially containing duplicates with multiple MoveAppend calls. Once appended these commands are 
	 * not being reused and consumed, destructively, during flushing
	 */
	TArray<TUniquePtr<FMassBatchedCommand>> AppendedCommandInstances;

	int32 ActiveCommandsCounter = 0;

	/** Indicates that this specific MassCommandBuffer is currently flushing its contents */
	bool bIsFlushing = false;

	/** 
	 * Identifies the thread where given FMassCommandBuffer instance was created. Adding commands from other
	 * threads is not supported and we use this value to check that.
	 * Note that it could be const since we set it in the constructor, but we need to recache on server forking.
	 */
	uint32 OwnerThreadId;
};

#undef COMMAND_PUSHING_CHECK

=============================================


=== MassEntity/Public/MassCommands.h ===
========================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "ProfilingDebugging/CsvProfilerConfig.h"
#include "Misc/MTAccessDetector.h"
#include "MassEntityTypes.h"
#include "MassEntityUtils.h"
#include "MassEntityManager.h"

#include "MassCommands.generated.h"

/**
 * Enum used by MassBatchCommands to declare their "type". This data is later used to group commands so that command 
 * effects are applied in a controllable fashion 
 * Important: if changed make sure to update FMassCommandBuffer::Flush.CommandTypeOrder as well
 */
UENUM()
enum class EMassCommandOperationType : uint8
{
	None,				// default value. Commands marked this way will be always executed last. Programmers are encouraged to instead use one of the meaningful values below.
	Create,				// signifies commands performing entity creation
	Add,				// signifies commands adding fragments or tags to entities
	Remove,				// signifies commands removing fragments or tags from entities
	ChangeComposition,	// signifies commands both adding and removing fragments and/or tags from entities
	Set,				// signifies commands setting values to pre-existing fragments. The fragments might be added if missing,
						// depending on specific command, so this group will always be executed after the Add group
	Destroy,			// signifies commands removing entities
	MAX
};

enum class EMassCommandCheckTime : bool
{
	RuntimeCheck = true,
	CompileTimeCheck = false
};

#if CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG
#	define DEBUG_NAME(Name) , FName(TEXT(Name))
#	define DEBUG_NAME_PARAM(Name) , const FName InDebugName = TEXT(Name)
#	define FORWARD_DEBUG_NAME_PARAM , InDebugName
#else
#	define DEBUG_NAME(Name)
#	define DEBUG_NAME_PARAM(Name)
#	define FORWARD_DEBUG_NAME_PARAM
#endif // CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG

namespace UE::Mass::Utils
{
	template<typename BitSetType, EMassCommandCheckTime CheckTime, typename... TTypes>
	BitSetType ConstructBitSet()
	{
		if constexpr (CheckTime == EMassCommandCheckTime::RuntimeCheck)
		{
			return BitSetType({ TTypes::StaticStruct()... });
		}
		else
		{
			BitSetType Result;
			UE::Mass::TMultiTypeList<TTypes...>::PopulateBitSet(Result);
			return Result;
		}
	}

	template<EMassCommandCheckTime CheckTime, typename... TTypes>
	FMassFragmentBitSet ConstructFragmentBitSet()
	{
		return ConstructBitSet<FMassFragmentBitSet, CheckTime, TTypes...>();
	}

	template<EMassCommandCheckTime CheckTime, typename... TTypes>
	FMassTagBitSet ConstructTagBitSet()
	{
		return ConstructBitSet<FMassTagBitSet, CheckTime, TTypes...>();
	}
} // namespace UE::Mass::Utils

struct MASSENTITY_API FMassBatchedCommand
{
	FMassBatchedCommand() = default;
	explicit FMassBatchedCommand(EMassCommandOperationType OperationType)
		: OperationType(OperationType)
	{}
#if CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG
	FMassBatchedCommand(EMassCommandOperationType OperationType, FName DebugName)
		: OperationType(OperationType)
		, DebugName(DebugName)
	{}
#endif // CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG
	virtual ~FMassBatchedCommand() { Reset(); }

	virtual void Execute(FMassEntityManager& System) const = 0;
	virtual void Reset()
	{
		bHasWork = false;
	}

	bool HasWork() const { return bHasWork; }
	EMassCommandOperationType GetOperationType() const { return OperationType; }

	template<typename T>
	static uint32 GetCommandIndex()
	{
		static const uint32 ThisTypesStaticIndex = CommandsCounter++;
		return ThisTypesStaticIndex;
	}

	virtual SIZE_T GetAllocatedSize() const = 0;

#if CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG
	virtual int32 GetNumOperationsStat() const = 0;
	FName GetFName() const { return DebugName; }
#endif // CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG

protected:
	// @todo note for reviewers - I could use an opinion if having a virtual function per-command would be a more 
	// preferable way of asking commands if there's anything to do.
	bool bHasWork = false;
	EMassCommandOperationType OperationType = EMassCommandOperationType::None;

#if CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG
	FName DebugName;
#endif // CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG

private:
	static std::atomic<uint32> CommandsCounter;
};

struct FMassBatchedEntityCommand : public FMassBatchedCommand
{
	using Super = FMassBatchedCommand;

	FMassBatchedEntityCommand() = default;
	explicit FMassBatchedEntityCommand(EMassCommandOperationType OperationType DEBUG_NAME_PARAM("BatchedEntityCommand"))
		: Super(OperationType FORWARD_DEBUG_NAME_PARAM)
	{}

	void Add(FMassEntityHandle Entity)
	{
		UE_MT_SCOPED_WRITE_ACCESS(EntitiesAccessDetector);
		TargetEntities.Add(Entity);
		bHasWork = true;
	}

	void Add(TConstArrayView<FMassEntityHandle> Entities)
	{
		UE_MT_SCOPED_WRITE_ACCESS(EntitiesAccessDetector);
		TargetEntities.Append(Entities.GetData(), Entities.Num());
		bHasWork = true;
	}

protected:
	virtual SIZE_T GetAllocatedSize() const
	{
		return TargetEntities.GetAllocatedSize();
	}

	virtual void Reset() override
	{
		TargetEntities.Reset();
		Super::Reset();
	}

#if CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG
	virtual int32 GetNumOperationsStat() const override { return TargetEntities.Num(); }
#endif // CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG

	UE_MT_DECLARE_RW_ACCESS_DETECTOR(EntitiesAccessDetector); 
	TArray<FMassEntityHandle> TargetEntities;
};

//////////////////////////////////////////////////////////////////////
// Entity destruction

struct FMassCommandDestroyEntities : public FMassBatchedEntityCommand
{
	using Super = FMassBatchedEntityCommand;

	FMassCommandDestroyEntities()
		: Super(EMassCommandOperationType::Destroy DEBUG_NAME("DestroyEntities"))
	{
	}

protected:
	virtual void Execute(FMassEntityManager& System) const override
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(MassCommandDestroyEntities_Execute);

		TArray<FMassArchetypeEntityCollection> EntityCollectionsToDestroy;
		UE::Mass::Utils::CreateEntityCollections(System, TargetEntities, FMassArchetypeEntityCollection::FoldDuplicates, EntityCollectionsToDestroy);
		System.BatchDestroyEntityChunks(EntityCollectionsToDestroy);
	}
};

//////////////////////////////////////////////////////////////////////
// Simple fragment composition change

template<EMassCommandCheckTime CheckTime, typename... TTypes>
struct FMassCommandAddFragmentsInternal : public FMassBatchedEntityCommand
{
	using Super = FMassBatchedEntityCommand;
	FMassCommandAddFragmentsInternal()
		: Super(EMassCommandOperationType::Add DEBUG_NAME("AddFragments"))
		, FragmentsAffected(UE::Mass::Utils::ConstructFragmentBitSet<CheckTime, TTypes...>())
	{}

protected:
	virtual void Execute(FMassEntityManager& System) const override
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(MassCommandAddFragments_Execute);
		TArray<FMassArchetypeEntityCollection> EntityCollections;
		UE::Mass::Utils::CreateEntityCollections(System, TargetEntities, FMassArchetypeEntityCollection::FoldDuplicates, EntityCollections);
		System.BatchChangeFragmentCompositionForEntities(EntityCollections, FragmentsAffected, FMassFragmentBitSet());
	}
	FMassFragmentBitSet FragmentsAffected;
};

template<typename... TTypes>
using FMassCommandAddFragments = FMassCommandAddFragmentsInternal<EMassCommandCheckTime::CompileTimeCheck, TTypes...>;

template<EMassCommandCheckTime CheckTime, typename... TTypes>
struct FMassCommandRemoveFragmentsInternal : public FMassBatchedEntityCommand
{
	using Super = FMassBatchedEntityCommand;
	FMassCommandRemoveFragmentsInternal()
		: Super(EMassCommandOperationType::Remove DEBUG_NAME("RemoveFragments"))
		, FragmentsAffected(UE::Mass::Utils::ConstructFragmentBitSet<CheckTime, TTypes...>())
	{}

protected:
	virtual void Execute(FMassEntityManager& System) const override
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(MassCommandRemoveFragments_Execute);
		TArray<FMassArchetypeEntityCollection> EntityCollections;
		UE::Mass::Utils::CreateEntityCollections(System, TargetEntities, FMassArchetypeEntityCollection::FoldDuplicates, EntityCollections);
		System.BatchChangeFragmentCompositionForEntities(EntityCollections, FMassFragmentBitSet(), FragmentsAffected);
	}
	FMassFragmentBitSet FragmentsAffected;
};

template<typename... TTypes>
using FMassCommandRemoveFragments = FMassCommandRemoveFragmentsInternal<EMassCommandCheckTime::CompileTimeCheck, TTypes...>;

//////////////////////////////////////////////////////////////////////
// Simple tag composition change

struct FMassCommandChangeTags : public FMassBatchedEntityCommand
{
	using Super = FMassBatchedEntityCommand;
	FMassCommandChangeTags()
		: Super(EMassCommandOperationType::ChangeComposition DEBUG_NAME("ChangeTags"))
	{}

	FMassCommandChangeTags(EMassCommandOperationType OperationType, FMassTagBitSet TagsToAdd, FMassTagBitSet TagsToRemove DEBUG_NAME_PARAM("ChangeTags"))
		: Super(OperationType FORWARD_DEBUG_NAME_PARAM)
		, TagsToAdd(TagsToAdd)
		, TagsToRemove(TagsToRemove)
	{}

protected:
	virtual void Execute(FMassEntityManager& System) const override
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(MassCommandChangeTags_Execute);
		TArray<FMassArchetypeEntityCollection> EntityCollections;
		UE::Mass::Utils::CreateEntityCollections(System, TargetEntities, FMassArchetypeEntityCollection::FoldDuplicates, EntityCollections);

		System.BatchChangeTagsForEntities(EntityCollections, TagsToAdd, TagsToRemove);
	}

	virtual SIZE_T GetAllocatedSize() const override
	{
		return TagsToAdd.GetAllocatedSize() + TagsToRemove.GetAllocatedSize() + Super::GetAllocatedSize();
	}

	FMassTagBitSet TagsToAdd;
	FMassTagBitSet TagsToRemove;
};

template<EMassCommandCheckTime CheckTime, typename... TTypes>
struct FMassCommandAddTagsInternal : public FMassCommandChangeTags
{
	using Super = FMassCommandChangeTags;
	FMassCommandAddTagsInternal()
		: Super(
			EMassCommandOperationType::Add, 
			UE::Mass::Utils::ConstructTagBitSet<CheckTime, TTypes...>(),
			{} 
			DEBUG_NAME("AddTags"))
	{}
};

template<typename T>
using FMassCommandAddTag = FMassCommandAddTagsInternal<EMassCommandCheckTime::CompileTimeCheck, T>;

template<typename... TTypes>
using FMassCommandAddTags = FMassCommandAddTagsInternal<EMassCommandCheckTime::CompileTimeCheck, TTypes...>;

template<EMassCommandCheckTime CheckTime, typename... TTypes>
struct FMassCommandRemoveTagsInternal : public FMassCommandChangeTags
{
	using Super = FMassCommandChangeTags;
	FMassCommandRemoveTagsInternal()
		: Super(
			EMassCommandOperationType::Remove, 
			{}, 
			UE::Mass::Utils::ConstructTagBitSet<CheckTime, TTypes...>()
			DEBUG_NAME("RemoveTags"))
	{}
};

template<typename T>
using FMassCommandRemoveTag = FMassCommandRemoveTagsInternal<EMassCommandCheckTime::CompileTimeCheck, T>;

template<typename... TTypes>
using FMassCommandRemoveTags = FMassCommandRemoveTagsInternal<EMassCommandCheckTime::CompileTimeCheck, TTypes...>;

template<EMassCommandCheckTime CheckTime, typename TOld, typename TNew>
struct FMassCommandSwapTagsInternal : public FMassCommandChangeTags
{
	using Super = FMassCommandChangeTags;
	FMassCommandSwapTagsInternal()
		: Super(
			EMassCommandOperationType::ChangeComposition,
			UE::Mass::Utils::ConstructTagBitSet<CheckTime, TNew>(),
			UE::Mass::Utils::ConstructTagBitSet<CheckTime, TOld>()
			DEBUG_NAME("SwapTags"))
	{}
};

template<typename TOld, typename TNew>
using FMassCommandSwapTags = FMassCommandSwapTagsInternal<EMassCommandCheckTime::CompileTimeCheck, TOld, TNew>;

//////////////////////////////////////////////////////////////////////
// Struct Instances adding and setting

template<typename... TOthers>
struct FMassCommandAddFragmentInstances : public FMassBatchedEntityCommand
{
	using Super = FMassBatchedEntityCommand;

	FMassCommandAddFragmentInstances(EMassCommandOperationType OperationType = EMassCommandOperationType::Set DEBUG_NAME_PARAM("AddFragmentInstanceList"))
		: Super(EMassCommandOperationType::Set FORWARD_DEBUG_NAME_PARAM)
		, FragmentsAffected(UE::Mass::Utils::ConstructFragmentBitSet<EMassCommandCheckTime::CompileTimeCheck, TOthers...>())
	{}

	void Add(FMassEntityHandle Entity, TOthers... InFragments)
	{
		Super::Add(Entity);
		Fragments.Add(InFragments...);
	}

protected:
	virtual void Reset() override
	{
		Fragments.Reset();
		Super::Reset();
	}

	virtual SIZE_T GetAllocatedSize() const override
	{
		return Super::GetAllocatedSize() + Fragments.GetAllocatedSize() + FragmentsAffected.GetAllocatedSize();
	}

	virtual void Execute(FMassEntityManager& System) const override
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(MassCommandAddFragmentInstances_Execute);

		TArray<FStructArrayView> GenericMultiArray;
		GenericMultiArray.Reserve(Fragments.GetNumArrays());
		Fragments.GetAsGenericMultiArray(GenericMultiArray);

		TArray<FMassArchetypeEntityCollectionWithPayload> EntityCollections;
		FMassArchetypeEntityCollectionWithPayload::CreateEntityRangesWithPayload(System, TargetEntities, FMassArchetypeEntityCollection::FoldDuplicates
			, FMassGenericPayloadView(GenericMultiArray), EntityCollections);

		System.BatchAddFragmentInstancesForEntities(EntityCollections, FragmentsAffected);
	}

	mutable UE::Mass::TMultiArray<TOthers...> Fragments;
	const FMassFragmentBitSet FragmentsAffected;
};

template<typename... TOthers>
struct FMassCommandBuildEntity : public FMassCommandAddFragmentInstances<TOthers...>
{
	using Super = FMassCommandAddFragmentInstances<TOthers...>;

	FMassCommandBuildEntity()
		: Super(EMassCommandOperationType::Create DEBUG_NAME("BuildEntity"))
	{
	}

protected:

	virtual void Execute(FMassEntityManager& System) const override
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(MassCommandBuildEntity_Execute);

		TArray<FStructArrayView> GenericMultiArray;
		GenericMultiArray.Reserve(Super::Fragments.GetNumArrays());
		Super::Fragments.GetAsGenericMultiArray(GenericMultiArray);

		TArray<FMassArchetypeEntityCollectionWithPayload> EntityCollections;
		FMassArchetypeEntityCollectionWithPayload::CreateEntityRangesWithPayload(System, Super::TargetEntities, FMassArchetypeEntityCollection::FoldDuplicates
			, FMassGenericPayloadView(GenericMultiArray), EntityCollections);

		check(EntityCollections.Num() <= 1);
		if (EntityCollections.Num())
		{
			System.BatchBuildEntities(EntityCollections[0], Super::FragmentsAffected, FMassArchetypeSharedFragmentValues());
		}
	}
};

/** 
 * Note: that TSharedFragmentValues is always expected to be FMassArchetypeSharedFragmentValues, but is declared as 
 *	template's param to maintain uniform command adding interface via FMassCommandBuffer.PushCommand. 
 *	PushCommands received all input params in one `typename...` list and as such cannot be easily split up to reason about.
 */
template<typename TSharedFragmentValues, typename... TOthers>
struct FMassCommandBuildEntityWithSharedFragments : public FMassBatchedCommand
{
	using Super = FMassBatchedCommand;

	FMassCommandBuildEntityWithSharedFragments()
		: Super(EMassCommandOperationType::Create DEBUG_NAME("FMassCommandBuildEntityWithSharedFragments"))
		, FragmentsAffected(UE::Mass::Utils::ConstructFragmentBitSet<EMassCommandCheckTime::CompileTimeCheck, TOthers...>())
	{}

	void Add(FMassEntityHandle Entity, FMassArchetypeSharedFragmentValues&& InSharedFragments, TOthers... InFragments)
	{
		InSharedFragments.Sort();

		// Compute hash before adding to the map since evaluation order is not guaranteed
		// and MoveTemp will invalidate InSharedFragments
		const uint32 Hash = GetTypeHash(InSharedFragments);

		FPerSharedFragmentsHashData& Instance = Data.FindOrAdd(Hash, MoveTemp(InSharedFragments));
		Instance.Fragments.Add(InFragments...);
		Instance.TargetEntities.Add(Entity);

		bHasWork = true;
	}

protected:
	virtual SIZE_T GetAllocatedSize() const override
	{
		SIZE_T TotalSize = 0;
		for (const auto& KeyValue : Data)
		{
			TotalSize += KeyValue.Value.GetAllocatedSize();
		}
		TotalSize += Data.GetAllocatedSize();
		TotalSize += FragmentsAffected.GetAllocatedSize();
		return TotalSize;
	}

	virtual void Execute(FMassEntityManager& System) const 
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(MassCommandBuildEntityWithSharedFragments_Execute);

		constexpr int FragmentTypesCount = UE::Mass::TMultiTypeList<TOthers...>::Ordinal + 1;
		TArray<FStructArrayView> GenericMultiArray;
		GenericMultiArray.Reserve(FragmentTypesCount);

		for (auto It : Data)
		{			
			It.Value.Fragments.GetAsGenericMultiArray(GenericMultiArray);

			TArray<FMassArchetypeEntityCollectionWithPayload> EntityCollections;
			FMassArchetypeEntityCollectionWithPayload::CreateEntityRangesWithPayload(System, It.Value.TargetEntities, FMassArchetypeEntityCollection::FoldDuplicates
				, FMassGenericPayloadView(GenericMultiArray), EntityCollections);
			checkf(EntityCollections.Num() <= 1, TEXT("We expect TargetEntities to only contain archetype-less entities, ones that need to be \'build\'"));

			if (EntityCollections.Num())
			{
				System.BatchBuildEntities(EntityCollections[0], FragmentsAffected, It.Value.SharedFragmentValues);
			}

			GenericMultiArray.Reset();
		}
	}

	virtual void Reset() override
	{
		Data.Reset();
		Super::Reset();
	}

#if CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG
	virtual int32 GetNumOperationsStat() const override
	{
		int32 TotalCount = 0;
		for (const auto& KeyValue : Data)
		{
			TotalCount += KeyValue.Value.TargetEntities.Num();
		}
		return TotalCount;
	}
#endif // CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG

	FMassFragmentBitSet FragmentsAffected;

	struct FPerSharedFragmentsHashData
	{
		FPerSharedFragmentsHashData(FMassArchetypeSharedFragmentValues&& InSharedFragmentValues)
			: SharedFragmentValues(MoveTemp(InSharedFragmentValues))
		{	
		}

		SIZE_T GetAllocatedSize() const
		{
			return TargetEntities.GetAllocatedSize() + Fragments.GetAllocatedSize() + SharedFragmentValues.GetAllocatedSize();
		}

		TArray<FMassEntityHandle> TargetEntities;
		mutable UE::Mass::TMultiArray<TOthers...> Fragments;
		FMassArchetypeSharedFragmentValues SharedFragmentValues;
	};

	TMap<uint32, FPerSharedFragmentsHashData> Data;
};

//////////////////////////////////////////////////////////////////////
// Commands that really can't know the types at compile time

template<EMassCommandOperationType OpType>
struct FMassDeferredCommand : public FMassBatchedCommand
{
	using Super = FMassBatchedCommand;
	using FExecFunction = TFunction<void(FMassEntityManager& System)>;

	FMassDeferredCommand()
		: Super(OpType DEBUG_NAME("BatchedDeferredCommand"))
	{}

	void Add(FExecFunction&& ExecFunction)
	{
		DeferredFunctions.Add(MoveTemp(ExecFunction));
		bHasWork = true;
	}

	void Add(const FExecFunction& ExecFunction)
	{
		DeferredFunctions.Add(ExecFunction);
		bHasWork = true;
	}

protected:
	virtual SIZE_T GetAllocatedSize() const
	{
		return DeferredFunctions.GetAllocatedSize();
	}

	virtual void Execute(FMassEntityManager& System) const override
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(MassDeferredCommand_Execute);

		for (const FExecFunction& ExecFunction : DeferredFunctions)
		{
			ExecFunction(System);
		}
	}

	virtual void Reset() override
	{
		DeferredFunctions.Reset();
		Super::Reset();
	}

#if CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG
	virtual int32 GetNumOperationsStat() const override
	{
		return DeferredFunctions.Num();
	}
#endif // CSV_PROFILER_STATS || WITH_MASSENTITY_DEBUG

	TArray<FExecFunction> DeferredFunctions;
};

using FMassDeferredCreateCommand = FMassDeferredCommand<EMassCommandOperationType::Create>;
using FMassDeferredAddCommand = FMassDeferredCommand<EMassCommandOperationType::Add>;
using FMassDeferredRemoveCommand = FMassDeferredCommand<EMassCommandOperationType::Remove>;
using FMassDeferredChangeCompositionCommand = FMassDeferredCommand<EMassCommandOperationType::ChangeComposition>;
using FMassDeferredSetCommand = FMassDeferredCommand<EMassCommandOperationType::Set>;
using FMassDeferredDestroyCommand = FMassDeferredCommand<EMassCommandOperationType::Destroy>;

#undef DEBUG_NAME
#undef DEBUG_NAME_PARAM
#undef FORWARD_DEBUG_NAME_PARAM

========================================


=== MassEntity/Public/MassDebugger.h ===
========================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassProcessingTypes.h"
#if WITH_MASSENTITY_DEBUG
#include "Containers/ContainersFwd.h"
#include "MassEntityQuery.h"
#include "MassProcessor.h"
#include "Misc/SpinLock.h"
#include "StructUtils/InstancedStruct.h"
#include "Logging/TokenizedMessage.h"

class FOutputDevice;
class UMassProcessor;
struct FMassEntityQuery;
struct FMassEntityManager;
struct FMassArchetypeHandle;
struct FMassFragmentRequirements;
struct FMassFragmentRequirementDescription;
enum class EMassFragmentAccess : uint8;
enum class EMassFragmentPresence : uint8;
#endif // WITH_MASSENTITY_DEBUG
#include "MassDebugger.generated.h"

namespace UE::Mass::Debug
{
	struct FArchetypeStats
	{
		/** Number of active entities of the archetype. */
		int32 EntitiesCount = 0;
		/** Number of entities that fit per chunk. */
		int32 EntitiesCountPerChunk = 0;
		/** Number of allocated chunks. */
		int32 ChunksCount = 0;
		/** Total amount of memory taken by this archetype */
		SIZE_T AllocatedSize = 0;
		/** How much memory allocated for entities is being unused */
		SIZE_T WastedEntityMemory = 0;
		/** Total amount of memory needed by a single entity */
		SIZE_T BytesPerEntity = 0;
	};
} // namespace UE::Mass::Debug

USTRUCT()
struct MASSENTITY_API FMassGenericDebugEvent
{
	GENERATED_BODY()
	explicit FMassGenericDebugEvent(const UObject* InContext = nullptr)
#if WITH_EDITORONLY_DATA
		: Context(InContext)
#endif // WITH_EDITORONLY_DATA
	{
	}

#if WITH_EDITORONLY_DATA
	// note that it's not a uproperty since these events are only intended to be used instantly, never stored
	const UObject* Context = nullptr;
#endif // WITH_EDITORONLY_DATA
};

#if WITH_MASSENTITY_DEBUG

namespace UE::Mass::Debug
{
	extern MASSENTITY_API bool bAllowProceduralDebuggedEntitySelection;
	extern MASSENTITY_API bool bAllowBreakOnDebuggedEntity;
	extern MASSENTITY_API bool bTestSelectedEntityAgainstProcessorQueries;
} // namespace UE::Mass::Debug

#define MASS_IF_ENTITY_DEBUGGED(Manager, EntityHandle) (FMassDebugger::GetSelectedEntity(Manager) == EntityHandle)
#define MASS_BREAK_IF_ENTITY_DEBUGGED(Manager, EntityHandle) { if (UE::Mass::Debug::bAllowBreakOnDebuggedEntity && MASS_IF_ENTITY_DEBUGGED(Manager, EntityHandle)) { PLATFORM_BREAK();} }
#define MASS_BREAK_IF_ENTITY_INDEX(EntityHandle, InIndex) { if (UE::Mass::Debug::bAllowBreakOnDebuggedEntity && EntityHandle.Index == InIndex) { PLATFORM_BREAK();} }
#define MASS_SET_ENTITY_DEBUGGED(Manager, EntityHandle) { if (UE::Mass::Debug::bAllowProceduralDebuggedEntitySelection) {FMassDebugger::SelectEntity(Manager, EntityHandle); }}

enum class EMassDebugMessageSeverity : uint8
{
	Error,
	Warning,
	Info,
	// the following two need to remain last
	Default,
	MAX = Default
};

namespace UE::Mass::Debug
{
	struct MASSENTITY_API FQueryRequirementsView
	{
		TConstArrayView<FMassFragmentRequirementDescription> FragmentRequirements;
		TConstArrayView<FMassFragmentRequirementDescription> ChunkRequirements;
		TConstArrayView<FMassFragmentRequirementDescription> ConstSharedRequirements;
		TConstArrayView<FMassFragmentRequirementDescription> SharedRequirements;
		const FMassTagBitSet& RequiredAllTags;
		const FMassTagBitSet& RequiredAnyTags;
		const FMassTagBitSet& RequiredNoneTags;
		const FMassTagBitSet& RequiredOptionalTags;
		const FMassExternalSubsystemBitSet& RequiredConstSubsystems;
		const FMassExternalSubsystemBitSet& RequiredMutableSubsystems;
	};

	FString DebugGetFragmentAccessString(EMassFragmentAccess Access);
	MASSENTITY_API extern void DebugOutputDescription(TConstArrayView<UMassProcessor*> Processors, FOutputDevice& Ar);

	MASSENTITY_API extern bool HasDebugEntities();
	MASSENTITY_API extern bool IsDebuggingSingleEntity();

	/**
	 * Populates OutBegin and OutEnd with entity index ranges as set by mass.debug.SetDebugEntityRange or
	 * mass.debug.DebugEntity console commands.
	 * @return whether any range has been configured.
	 */
	MASSENTITY_API extern bool GetDebugEntitiesRange(int32& OutBegin, int32& OutEnd);
	MASSENTITY_API extern bool IsDebuggingEntity(FMassEntityHandle Entity, FColor* OutEntityColor = nullptr);
	MASSENTITY_API extern FColor GetEntityDebugColor(FMassEntityHandle Entity);

	inline EMessageSeverity::Type MassSeverityToMessageSeverity(EMessageSeverity::Type OriginalSeverity, EMassDebugMessageSeverity MassSeverity)
	{
		static constexpr EMessageSeverity::Type ConversionMap[int(EMassDebugMessageSeverity::MAX)] =
		{
			/*EMassDebugMessageSeverity::Error=*/EMessageSeverity::Error,
			/*EMassDebugMessageSeverity::Warning=*/EMessageSeverity::Warning,
			/*EMassDebugMessageSeverity::Info=*/EMessageSeverity::Info
		};
		return MassSeverity == EMassDebugMessageSeverity::Default 
			? OriginalSeverity
			: ConversionMap[int(MassSeverity)];
	}
} // namespace UE::Mass::Debug

struct MASSENTITY_API FMassDebugger
{
	DECLARE_MULTICAST_DELEGATE_TwoParams(FOnEntitySelected, const FMassEntityManager&, const FMassEntityHandle);
	DECLARE_MULTICAST_DELEGATE_OneParam(FOnMassEntityManagerEvent, const FMassEntityManager&);
	DECLARE_MULTICAST_DELEGATE_ThreeParams(FOnDebugEvent, const FName /*EventName*/, FConstStructView /*Payload*/, const EMassDebugMessageSeverity /*SeverityOverride*/);

	struct FEnvironment
	{
		TWeakPtr<const FMassEntityManager> EntityManager;
		FMassEntityHandle SelectedEntity;

		explicit FEnvironment(const FMassEntityManager& InEntityManager)
			: EntityManager(InEntityManager.AsWeak())
		{}

		bool IsValid() const { return EntityManager.IsValid(); }
	};

	static TConstArrayView<FMassEntityQuery*> GetProcessorQueries(const UMassProcessor& Processor);
	/** fetches all queries registered for given Processor. Note that in order to get up to date information
	 *  FMassEntityQuery::CacheArchetypes will be called on each query */
	static TConstArrayView<FMassEntityQuery*> GetUpToDateProcessorQueries(const FMassEntityManager& EntitySubsystem, UMassProcessor& Processor);

	static UE::Mass::Debug::FQueryRequirementsView GetQueryRequirements(const FMassEntityQuery& Query);
	static void GetQueryExecutionRequirements(const FMassEntityQuery& Query, FMassExecutionRequirements& OutExecutionRequirements);

	static TArray<FMassArchetypeHandle> GetAllArchetypes(const FMassEntityManager& EntitySubsystem);
	static const FMassArchetypeCompositionDescriptor& GetArchetypeComposition(const FMassArchetypeHandle& ArchetypeHandle);

	static void GetArchetypeEntityStats(const FMassArchetypeHandle& ArchetypeHandle, UE::Mass::Debug::FArchetypeStats& OutStats);
	static const TConstArrayView<FName> GetArchetypeDebugNames(const FMassArchetypeHandle& ArchetypeHandle);

	static TConstArrayView<UMassCompositeProcessor::FDependencyNode> GetProcessingGraph(const UMassCompositeProcessor& GraphOwner);
	static TConstArrayView<TObjectPtr<UMassProcessor>> GetHostedProcessors(const UMassCompositeProcessor& GraphOwner);
	
	static FString GetSingleRequirementDescription(const FMassFragmentRequirementDescription& Requirement);
	static FString GetRequirementsDescription(const FMassFragmentRequirements& Requirements);
	static FString GetArchetypeRequirementCompatibilityDescription(const FMassFragmentRequirements& Requirements, const FMassArchetypeHandle& ArchetypeHandle);
	static FString GetArchetypeRequirementCompatibilityDescription(const FMassFragmentRequirements& Requirements, const FMassArchetypeCompositionDescriptor& ArchetypeComposition);

	static void OutputArchetypeDescription(FOutputDevice& Ar, const FMassArchetypeHandle& Archetype);
	static void OutputEntityDescription(FOutputDevice& Ar, const FMassEntityManager& EntityManager, const int32 EntityIndex, const TCHAR* InPrefix = TEXT(""));
	static void OutputEntityDescription(FOutputDevice& Ar, const FMassEntityManager& EntityManager, const FMassEntityHandle Entity, const TCHAR* InPrefix = TEXT(""));

	static void SelectEntity(const FMassEntityManager& EntityManager, const FMassEntityHandle EntityHandle);
	static FMassEntityHandle GetSelectedEntity(const FMassEntityManager& EntityManager);

	static FOnEntitySelected OnEntitySelectedDelegate;

	static FOnMassEntityManagerEvent OnEntityManagerInitialized;
	static FOnMassEntityManagerEvent OnEntityManagerDeinitialized;

	static FOnDebugEvent OnDebugEvent;
	
	static void DebugEvent(const FName EventName, FConstStructView Payload, const EMassDebugMessageSeverity SeverityOverride = EMassDebugMessageSeverity::Default)
	{
		OnDebugEvent.Broadcast(EventName, Payload, SeverityOverride);
	}

	template<typename TMessage, typename... TArgs>
	static void DebugEvent(TArgs&&... InArgs)
	{
		DebugEvent(TMessage::StaticStruct()->GetFName()
			, FConstStructView::Make(TMessage(Forward<TArgs>(InArgs)...)));
	}

	static void RegisterEntityManager(FMassEntityManager& EntityManager);
	static void UnregisterEntityManager(FMassEntityManager& EntityManager);
	static TConstArrayView<FEnvironment> GetEnvironments() { return ActiveEnvironments; }

	/**
	 * Determines whether given Archetype matches given Requirements. In case of a mismatch description of failed conditions will be added to OutputDevice.
	 */
	static bool DoesArchetypeMatchRequirements(const FMassArchetypeHandle& ArchetypeHandle, const FMassFragmentRequirements& Requirements, FOutputDevice& OutputDevice);

private:
	static TArray<FEnvironment> ActiveEnvironments;
	static UE::FSpinLock EntityManagerRegistrationLock;
};

#else

struct FMassArchetypeHandle;
struct FMassFragmentRequirements;
struct FMassFragmentRequirementDescription;
struct FMassArchetypeCompositionDescriptor;

struct MASSENTITY_API FMassDebugger
{
	static FString GetSingleRequirementDescription(const FMassFragmentRequirementDescription&) { return TEXT("[no debug information]"); }
	static FString GetRequirementsDescription(const FMassFragmentRequirements&) { return TEXT("[no debug information]"); }
	static FString GetArchetypeRequirementCompatibilityDescription(const FMassFragmentRequirements&, const FMassArchetypeHandle&) { return TEXT("[no debug information]"); }
	static FString GetArchetypeRequirementCompatibilityDescription(const FMassFragmentRequirements&, const FMassArchetypeCompositionDescriptor&) { return TEXT("[no debug information]"); }
};

#define MASS_IF_ENTITY_DEBUGGED(a, b) false
#define MASS_BREAK_IF_ENTITY_DEBUGGED(a, b)
#define MASS_BREAK_IF_ENTITY_INDEX(a, b)
#define MASS_SET_ENTITY_DEBUGGED(a, b)

#endif // WITH_MASSENTITY_DEBUG

========================================


=== MassEntity/Public/MassEntityManager.h ===
=============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "UObject/GCObject.h"
#include "MassEntityTypes.h"
#include "MassProcessingTypes.h"
#include "MassEntityQuery.h"
#if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_5
#include "StructUtils/InstancedStruct.h"
#include "StructUtils/StructUtilsTypes.h"
#endif
#include "MassObserverManager.h"
#include "Containers/MpscQueue.h"
#include "MassRequirementAccessDetector.h"
#include "Templates/FunctionFwd.h"
#include "MassEntityManagerStorage.h"


struct FInstancedStruct;
struct FMassEntityQuery;
struct FMassExecutionContext;
struct FMassArchetypeData;
struct FMassCommandBuffer;
struct FMassArchetypeEntityCollection;
class FOutputDevice;
struct FMassDebugger;
enum class EMassFragmentAccess : uint8;
enum class EForkProcessRole : uint8;
namespace UE::Mass::Private
{
	struct FEntityStorageInitializer;
}

#define MASS_CONCURRENT_RESERVE 1

/** 
 * The type responsible for hosting Entities managing Archetypes.
 * Entities are stored as FEntityData entries in a chunked array. 
 * Each valid entity is assigned to an Archetype that stored fragments associated with a given entity at the moment. 
 * 
 * FMassEntityManager supplies API for entity creation (that can result in archetype creation) and entity manipulation.
 * Even though synchronized manipulation methods are available in most cases the entity operations are performed via a command 
 * buffer. The default command buffer can be obtained with a Defer() call. @see FMassCommandBuffer for more details.
 * 
 * FMassEntityManager are meant to be stored with a TSharedPtr or TSharedRef. Some of Mass API pass around 
 * FMassEntityManager& but programmers can always use AsShared() call to obtain a shared ref for a given manager instance 
 * (as supplied by deriving from TSharedFromThis<FMassEntityManager>).
 * IMPORTANT: if you create your own FMassEntityManager instance remember to call Initialize() before using it.
 */
struct MASSENTITY_API FMassEntityManager : public TSharedFromThis<FMassEntityManager>, public FGCObject
{
	friend FMassEntityQuery;
	friend FMassDebugger;

	DECLARE_MULTICAST_DELEGATE_OneParam(FOnNewArchetypeDelegate, const FMassArchetypeHandle&);

private:
	// Index 0 is reserved so we can treat that index as an invalid entity handle
	constexpr static int32 NumReservedEntities = 1;
	
public:
	struct FScopedProcessing
	{
		explicit FScopedProcessing(std::atomic<int32>& InProcessingScopeCount) : ScopedProcessingCount(InProcessingScopeCount)
		{
			++ScopedProcessingCount;
		}
		~FScopedProcessing()
		{
			--ScopedProcessingCount;
		}
	private:
		std::atomic<int32>& ScopedProcessingCount;
	};
	using FStructInitializationCallback = TFunctionRef<void(void* Fragment, const UScriptStruct& FragmentType)>;

	const static FMassEntityHandle InvalidEntity;

	explicit FMassEntityManager(UObject* InOwner = nullptr);
	FMassEntityManager(const FMassEntityManager& Other) = delete;
	virtual ~FMassEntityManager();

	// FGCObject interface
	virtual void AddReferencedObjects(FReferenceCollector& Collector) override;
	virtual FString GetReferencerName() const override
	{
		return TEXT("FMassEntityManager");
	}
	// End of FGCObject interface
	void GetResourceSizeEx(FResourceSizeEx& CumulativeResourceSize);

	// Default to use single threaded implementation
	void Initialize();
	void Initialize(const FMassEntityManagerStorageInitParams& InitializationParams);
	void PostInitialize();
	void Deinitialize();

	/** 
	 * A special, relaxed but slower version of CreateArchetype functions that allows FragmentAngTagsList to contain 
	 * both fragments and tags. 
	 */
	FMassArchetypeHandle CreateArchetype(TConstArrayView<const UScriptStruct*> FragmentsAndTagsList, const FMassArchetypeCreationParams& CreationParams = FMassArchetypeCreationParams());

	/**
	 * A special, relaxed but slower version of CreateArchetype functions that allows FragmentAngTagsList to contain
	 * both fragments and tags. This version takes an original archetype and copies it layout, then appends any fragments and tags from the
	 * provided list if they're not already in the original archetype.
	 * 
	 * @param SourceArchetype The archetype where the composition will be copied from.
	 * @param FragmentsAndTagsList The list of fragments and tags to add to the copied composition.
	 */
	FMassArchetypeHandle CreateArchetype(FMassArchetypeHandle SourceArchetype, TConstArrayView<const UScriptStruct*> FragmentsAndTagsList);
	
	/**
	 * A special, relaxed but slower version of CreateArchetype functions that allows FragmentAngTagsList to contain
	 * both fragments and tags. This version takes an original archetype and copies it layout, then appends any fragments and tags from the
	 * provided list if they're not already in the original archetype.
	 * 
	 * @param SourceArchetype The archetype where the composition will be copied from.
	 * @param FragmentsAndTagsList The list of fragments and tags to add to the copied composition.
	 * @param CreationParams Additional arguments used to create the new archetype.
	 */
	FMassArchetypeHandle CreateArchetype(FMassArchetypeHandle SourceArchetype, TConstArrayView<const UScriptStruct*> FragmentsAndTagsList, 
		const FMassArchetypeCreationParams& CreationParams);

	/**
	 * CreateArchetype from a composition descriptor and initial values
	 *
	 * @param Composition of fragment, tag and chunk fragment types
	 * @param CreationParams Parameters used during archetype construction
	 * @return a handle of a new archetype 
	 */
	FMassArchetypeHandle CreateArchetype(const FMassArchetypeCompositionDescriptor& Composition, const FMassArchetypeCreationParams& CreationParams = FMassArchetypeCreationParams());

	/**
	 *  Creates an archetype like SourceArchetype + InFragments.
	 *  @param SourceArchetype the archetype used to initially populate the list of fragments of the archetype being created.
	 *  @param InFragments list of unique fragments to add to fragments fetched from SourceArchetype. Note that
	 *   adding an empty list is not supported and doing so will result in failing a `check`
	 *  @return a handle of a new archetype
	 *  @note it's caller's responsibility to ensure that NewFragmentList is not empty and contains only fragment
	 *   types that SourceArchetype doesn't already have. If the caller cannot guarantee it use of AddFragment functions
	 *   family is recommended.
	 */
	FMassArchetypeHandle CreateArchetype(const TSharedPtr<FMassArchetypeData>& SourceArchetype, const FMassFragmentBitSet& InFragments);
	
	/** 
	 *  Creates an archetype like SourceArchetype + InFragments. 
	 *  @param SourceArchetype the archetype used to initially populate the list of fragments of the archetype being created. 
	 *  @param InFragments list of unique fragments to add to fragments fetched from SourceArchetype. Note that 
	 *   adding an empty list is not supported and doing so will result in failing a `check`
	 *  @param CreationParams Parameters used during archetype construction
	 *  @return a handle of a new archetype
	 *  @note it's caller's responsibility to ensure that NewFragmentList is not empty and contains only fragment
	 *   types that SourceArchetype doesn't already have. If the caller cannot guarantee it use of AddFragment functions
	 *   family is recommended.
	 */
	FMassArchetypeHandle CreateArchetype(const TSharedPtr<FMassArchetypeData>& SourceArchetype, const FMassFragmentBitSet& InFragments, 
		const FMassArchetypeCreationParams& CreationParams);

	/** 
	 * A helper function to be used when creating entities with shared fragments provided, or when adding shared fragments
	 * to existing entities
	 * @param ArchetypeHandle that's the assumed target archetype. But we'll be making sure its composition matches SharedFragmentsBitSet
	 * @param SharedFragmentBitSet indicates which shared fragments we want the target archetype to have. If ArchetypeHandle 
	 *	doesn't have these a new archetype will be created.
	 */
	FMassArchetypeHandle GetOrCreateSuitableArchetype(const FMassArchetypeHandle& ArchetypeHandle
		, const FMassSharedFragmentBitSet& SharedFragmentBitSet
		, const FMassConstSharedFragmentBitSet& ConstSharedFragmentBitSet
		, const FMassArchetypeCreationParams& CreationParams = FMassArchetypeCreationParams());

	/** Fetches the archetype for a given Entity. If Entity is not valid it will still return a handle, just with an invalid archetype */
	FMassArchetypeHandle GetArchetypeForEntity(FMassEntityHandle Entity) const;
	/**
	 * Fetches the archetype for a given Entity. Note that it's callers responsibility the given Entity handle is valid.
	 * If you can't ensure that call GetArchetypeForEntity.
	 */
	FMassArchetypeHandle GetArchetypeForEntityUnsafe(FMassEntityHandle Entity) const;

	/** Method to iterate on all the fragment types of an archetype */
	static void ForEachArchetypeFragmentType(const FMassArchetypeHandle& ArchetypeHandle, TFunction< void(const UScriptStruct* /*FragmentType*/)> Function);

	/**
	 * Go through all archetypes and compact entities
	 * @param TimeAllowed to do entity compaction, once it reach that time it will stop and return
	 */
	void DoEntityCompaction(const double TimeAllowed);

	/**
	 * Creates fully built entity ready to be used by the subsystem
	 * @param ArchetypeHandle you want this entity to be
	 * @param SharedFragmentValues to be associated with the entity
	 * @return FMassEntityHandle id of the newly created entity */
	FMassEntityHandle CreateEntity(const FMassArchetypeHandle& ArchetypeHandle, const FMassArchetypeSharedFragmentValues& SharedFragmentValues = {});

	/**
	 * Creates fully built entity ready to be used by the subsystem
	 * @param FragmentInstanceList is the fragments to create the entity from and initialize values
	 * @param SharedFragmentValues to be associated with the entity
	 * @return FMassEntityHandle id of the newly created entity */
	FMassEntityHandle CreateEntity(TConstArrayView<FInstancedStruct> FragmentInstanceList, const FMassArchetypeSharedFragmentValues& SharedFragmentValues = {}, const FMassArchetypeCreationParams& CreationParams = FMassArchetypeCreationParams());

	/**
	 * A dedicated structure for ensuring the "on entities creation" observers get notified only once all other 
	 * initialization operations are done and this creation context instance gets released. 
	 */
	struct MASSENTITY_API FEntityCreationContext
	{
	private:
		FEntityCreationContext();
		explicit FEntityCreationContext(FMassEntityManager& InManager, const TConstArrayView<FMassEntityHandle> InCreatedEntities = {});
		FEntityCreationContext(FMassEntityManager& InManager, const TConstArrayView<FMassEntityHandle> InCreatedEntities, FMassArchetypeEntityCollection&& EntityCollection);
		
	public:
		~FEntityCreationContext();

		/** Returns EntityCollections, reconstructing them if needed (empty or dirtied). */
		TConstArrayView<FMassArchetypeEntityCollection> GetEntityCollections() const;
		int32 GetSpawnedNum() const { return CreatedEntities.Num(); }
		void MarkDirty();
		FORCEINLINE bool IsDirty() const { return EntityCollections.IsEmpty() && (CreatedEntities.IsEmpty() == false); }
		void AppendEntities(const TConstArrayView<FMassEntityHandle> EntitiesToAppend);
		void AppendEntities(const TConstArrayView<FMassEntityHandle> EntitiesToAppend, FMassArchetypeEntityCollection&& EntityCollection);

		/** Function for debugging/testing purposes. We don't expect users to ever call it, always get collections via GetEntityCollections */
		bool DebugAreEntityCollectionsUpToDate() const { return EntityCollections.IsEmpty() == CreatedEntities.IsEmpty(); }

		UE_DEPRECATED(5.5, "This constructor is now deprecated and defunct. Use one of the others instead.")
		explicit FEntityCreationContext(const int32 InNumSpawned) : FEntityCreationContext() {}
		UE_DEPRECATED(5.5, "This function is now deprecated since FEntityCreationContext can contain more than a single collection now. Use GetEntityCollections instead.")
		const FMassArchetypeEntityCollection& GetEntityCollection() const;

	private:
		friend FMassEntityManager;
		/** To be called in case of processor forking. */
		void ForceUpdateCurrentThreadID();

		/**
		 * Identifies the thread where given FEntityCreationContext instance was created. All subsequent operations are 
		 * expected to be run in the same thread.
		 */
		uint32 OwnerThreadId;
		mutable TArray<FMassArchetypeEntityCollection> EntityCollections;
		TArray<FMassEntityHandle> CreatedEntities;
		FMassArchetypeEntityCollection::EDuplicatesHandling CollectionCreationDuplicatesHandling = FMassArchetypeEntityCollection::EDuplicatesHandling::NoDuplicates;
		TSharedPtr<FMassEntityManager> Manager;
	};
	/**
	 * The main use-case for this function is to create a blank FEntityCreationContext and hold on to it while creating 
	 * a bunch of entities (with multiple calls to BatchCreate* and/or BatchBuild*) and modifying them (with mutating batched API)
	 * while not causing multiple Observers to trigger. All the observers will be triggered at one go, once the FEntityCreationContext 
	 * instance gets destroyed. 
	 * @return ActiveCreationContext. If it's valid FEntityCreationContext instance will be created and assigned to ActiveCreationContext first.
	 */
	TSharedRef<FEntityCreationContext> GetOrMakeCreationContext();

	/**
	 * A version of CreateEntity that's creating a number of entities (Count) in one go
	 * @param ArchetypeHandle you want this entity to be
	 * @param SharedFragmentValues to be associated with the entities
	 * @param ReservedEntities a list of reserved entities that have not yet been assigned to an archetype.
	 * @return a creation context that will notify all the interested observers about newly created fragments once the context is released */
	TSharedRef<FEntityCreationContext> BatchCreateReservedEntities(const FMassArchetypeHandle& ArchetypeHandle,
		const FMassArchetypeSharedFragmentValues& SharedFragmentValues, TConstArrayView<FMassEntityHandle> ReservedEntities);
	FORCEINLINE TSharedRef<FEntityCreationContext> BatchCreateReservedEntities(const FMassArchetypeHandle& ArchetypeHandle,
		TConstArrayView<FMassEntityHandle> OutEntities)
	{
		return BatchCreateReservedEntities(ArchetypeHandle, FMassArchetypeSharedFragmentValues(), OutEntities);
	}
	/**
	 * A version of CreateEntity that's creating a number of entities (Count) in one go
	 * @param ArchetypeHandle you want this entity to be
	 * @param SharedFragmentValues to be associated with the entities
	 * @param Count number of entities to create
	 * @param InOutEntities the newly created entities are appended to given array, i.e. the pre-existing content of OutEntities won't be affected by the call
	 * @return a creation context that will notify all the interested observers about newly created fragments once the context is released */
	TSharedRef<FEntityCreationContext> BatchCreateEntities(const FMassArchetypeHandle& ArchetypeHandle, const FMassArchetypeSharedFragmentValues& SharedFragmentValues, const int32 Count, TArray<FMassEntityHandle>& InOutEntities);
	FORCEINLINE TSharedRef<FEntityCreationContext> BatchCreateEntities(const FMassArchetypeHandle& ArchetypeHandle, const int32 Count, TArray<FMassEntityHandle>& InOutEntities)
	{
		return BatchCreateEntities(ArchetypeHandle, FMassArchetypeSharedFragmentValues(), Count, InOutEntities);
	}

	/**
	 * Destroys a fully built entity, use ReleaseReservedEntity if entity was not yet built.
	 * @param Entity to destroy */
	void DestroyEntity(FMassEntityHandle Entity);

	/**
	 * Reserves an entity in the subsystem, the entity is still not ready to be used by the subsystem, need to call BuildEntity()
	 * @return FMassEntityHandle id of the reserved entity */
	FMassEntityHandle ReserveEntity();

	/**
	 * Builds an entity for it to be ready to be used by the subsystem
	 * @param Entity to build which was retrieved with ReserveEntity() method
	 * @param ArchetypeHandle you want this entity to be
	 * @param SharedFragmentValues to be associated with the entity
	 */
	void BuildEntity(FMassEntityHandle Entity, const FMassArchetypeHandle& ArchetypeHandle, const FMassArchetypeSharedFragmentValues& SharedFragmentValues = {});

	/**
	 * Builds an entity for it to be ready to be used by the subsystem
	 * @param Entity to build which was retrieved with ReserveEntity() method
	 * @param FragmentInstanceList is the fragments to create the entity from and initialize values
	 * @param SharedFragmentValues to be associated with the entity
	 */
	void BuildEntity(FMassEntityHandle Entity, TConstArrayView<FInstancedStruct> FragmentInstanceList, const FMassArchetypeSharedFragmentValues& SharedFragmentValues = {});

	/*
	 * Releases a previously reserved entity that was not yet built, otherwise call DestroyEntity
	 * @param Entity to release */
	void ReleaseReservedEntity(FMassEntityHandle Entity);

	/**
	 * Destroys all the entities in the provided array of entities. The function will also gracefully handle entities
	 * that have been reserved but not created yet.
	 * @note the function doesn't handle duplicates in InEntities.
	 * @param InEntities to destroy
	 */
	void BatchDestroyEntities(TConstArrayView<FMassEntityHandle> InEntities);

	/**
	 * Destroys all the entities provided via the Collection. The function will also gracefully handle entities
	 * that have been reserved but not created yet.
	 * @param Collection to destroy
	 */
	void BatchDestroyEntityChunks(const FMassArchetypeEntityCollection& Collection);
	void BatchDestroyEntityChunks(TConstArrayView<FMassArchetypeEntityCollection> Collections);

	void AddFragmentToEntity(FMassEntityHandle Entity, const UScriptStruct* FragmentType);
	void AddFragmentToEntity(FMassEntityHandle Entity, const UScriptStruct* FragmentType, const FStructInitializationCallback& Initializer);

	/** 
	 *  Ensures that only unique fragments are added. 
	 *  @note It's caller's responsibility to ensure Entity's and FragmentList's validity. 
	 */
	void AddFragmentListToEntity(FMassEntityHandle Entity, TConstArrayView<const UScriptStruct*> FragmentList);

	void AddFragmentInstanceListToEntity(FMassEntityHandle Entity, TConstArrayView<FInstancedStruct> FragmentInstanceList);
	void RemoveFragmentFromEntity(FMassEntityHandle Entity, const UScriptStruct* FragmentType);
	void RemoveFragmentListFromEntity(FMassEntityHandle Entity, TConstArrayView<const UScriptStruct*> FragmentList);

	void AddTagToEntity(FMassEntityHandle Entity, const UScriptStruct* TagType);
	void RemoveTagFromEntity(FMassEntityHandle Entity, const UScriptStruct* TagType);
	void SwapTagsForEntity(FMassEntityHandle Entity, const UScriptStruct* FromFragmentType, const UScriptStruct* ToFragmentType);

	/** 
	 * Adds a new const shared fragment to the given entity. Note that it only works if the given entity doesn't have
	 * a shared fragment of the given type. The function will give a soft "pass" if the entity has the shared fragment
	 * of the same value. Setting shared fragment value (i.e. changing) is not supported and the function will log
	 * a warning if that's attempted.
	 * @return whether the Entity has the Fragment value assigned to it, regardless of its original state (i.e. the function will
	 *	return true also if the Entity already had the same values associated with it)
	 */
	bool AddConstSharedFragmentToEntity(const FMassEntityHandle Entity, const FConstSharedStruct& InConstSharedFragment);

	/**
	 * Removes a const shared fragment of the given type from the entity.
	 * Will do nothing if entity did not have the shared fragment.
	 * @return True if fragment removed from entity, false otherwise.
	 */
	bool RemoveConstSharedFragmentFromEntity(const FMassEntityHandle Entity, const UScriptStruct& ConstSharedFragmentType);

	/** 
	 * Reserves Count number of entities and appends them to InOutEntities
	 * @return a view into InOutEntities containing only the freshly reserved entities
	 */
	TConstArrayView<FMassEntityHandle> BatchReserveEntities(const int32 Count, TArray<FMassEntityHandle>& InOutEntities);
	
	/**
	 * Reserves number of entities corresponding to number of entries in the provided array view InOutEntities.
	 * As a result InOutEntities gets filled with handles of reserved entities
	 * @return the number of entities reserved
	 */
	int32 BatchReserveEntities(TArrayView<FMassEntityHandle> InOutEntities);

	TSharedRef<FEntityCreationContext> BatchBuildEntities(const FMassArchetypeEntityCollectionWithPayload& EncodedEntitiesWithPayload, const FMassFragmentBitSet& FragmentsAffected
		, const FMassArchetypeSharedFragmentValues& SharedFragmentValues = {}, const FMassArchetypeCreationParams& CreationParams = FMassArchetypeCreationParams());
	TSharedRef<FEntityCreationContext> BatchBuildEntities(const FMassArchetypeEntityCollectionWithPayload& EncodedEntitiesWithPayload, FMassArchetypeCompositionDescriptor&& Composition
		, const FMassArchetypeSharedFragmentValues& SharedFragmentValues = {}, const FMassArchetypeCreationParams& CreationParams = FMassArchetypeCreationParams());
	void BatchChangeTagsForEntities(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, const FMassTagBitSet& TagsToAdd, const FMassTagBitSet& TagsToRemove);
	void BatchChangeFragmentCompositionForEntities(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, const FMassFragmentBitSet& FragmentsToAdd, const FMassFragmentBitSet& FragmentsToRemove);
	void BatchAddFragmentInstancesForEntities(TConstArrayView<FMassArchetypeEntityCollectionWithPayload> EntityCollections, const FMassFragmentBitSet& FragmentsAffected);
	/** 
	 * Adds a new const and non-const shared fragments to all entities provided via EntityCollections 
	 */
	void BatchAddSharedFragmentsForEntities(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, const FMassArchetypeSharedFragmentValues& AddedFragmentValues);

	/**
	 * Adds fragments and tags indicated by InOutDescriptor to the Entity. The function also figures out which elements
	 * in InOutDescriptor are missing from the current composition of the given entity and then returns the resulting 
	 * delta via InOutDescriptor.
	 */
	void AddCompositionToEntity_GetDelta(FMassEntityHandle Entity, FMassArchetypeCompositionDescriptor& InOutDescriptor);
	void RemoveCompositionFromEntity(FMassEntityHandle Entity, const FMassArchetypeCompositionDescriptor& InDescriptor);

	const FMassArchetypeCompositionDescriptor& GetArchetypeComposition(const FMassArchetypeHandle& ArchetypeHandle) const;

	/** 
	 * Moves an entity over to a new archetype by copying over fragments common to both archetypes
	 * @param Entity is the entity to move 
	 * @param NewArchetypeHandle the handle to the new archetype
	 */
	void MoveEntityToAnotherArchetype(FMassEntityHandle Entity, FMassArchetypeHandle NewArchetypeHandle);

	/** Copies values from FragmentInstanceList over to Entity's fragment. Caller is responsible for ensuring that 
	 *  the given entity does have given fragments. Failing this assumption will cause a check-fail.*/
	void SetEntityFragmentsValues(FMassEntityHandle Entity, TArrayView<const FInstancedStruct> FragmentInstanceList);

	/** Copies values from FragmentInstanceList over to fragments of given entities collection. The caller is responsible 
	 *  for ensuring that the given entity archetype (FMassArchetypeEntityCollection .Archetype) does have given fragments. 
	 *  Failing this assumption will cause a check-fail. */
	static void BatchSetEntityFragmentsValues(const FMassArchetypeEntityCollection& SparseEntities, TArrayView<const FInstancedStruct> FragmentInstanceList);

	static void BatchSetEntityFragmentsValues(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, TArrayView<const FInstancedStruct> FragmentInstanceList);

	// Return true if it is an valid built entity
	bool IsEntityActive(FMassEntityHandle Entity) const 
	{
		return IsEntityValid(Entity) && IsEntityBuilt(Entity);
	}

	// Returns true if Entity is valid
	bool IsEntityValid(FMassEntityHandle Entity) const;

	// Returns true if Entity is has been fully built (expecting a valid Entity)
	bool IsEntityBuilt(FMassEntityHandle Entity) const;

	// Asserts that IsEntityValid
	void CheckIfEntityIsValid(FMassEntityHandle Entity) const;

	// Asserts that IsEntityBuilt
	void CheckIfEntityIsActive(FMassEntityHandle Entity) const;

	template<typename FragmentType>
	FragmentType& GetFragmentDataChecked(FMassEntityHandle Entity) const
	{
		static_assert(TIsDerivedFrom<FragmentType, FMassFragment>::IsDerived
			, "Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.");
		return *((FragmentType*)InternalGetFragmentDataChecked(Entity, FragmentType::StaticStruct()));
	}

	template<typename FragmentType>
	FragmentType* GetFragmentDataPtr(FMassEntityHandle Entity) const
	{
		static_assert(TIsDerivedFrom<FragmentType, FMassFragment>::IsDerived
			, "Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.");
		return (FragmentType*)InternalGetFragmentDataPtr(Entity, FragmentType::StaticStruct());
	}

	FStructView GetFragmentDataStruct(FMassEntityHandle Entity, const UScriptStruct* FragmentType) const
	{
		checkf((FragmentType != nullptr) && FragmentType->IsChildOf(FMassFragment::StaticStruct())
			, TEXT("GetFragmentDataStruct called with an invalid fragment type '%s'"), *GetPathNameSafe(FragmentType));
		return FStructView(FragmentType, static_cast<uint8*>(InternalGetFragmentDataPtr(Entity, FragmentType)));
	}

	template<typename ConstSharedFragmentType>
	ConstSharedFragmentType* GetConstSharedFragmentDataPtr(FMassEntityHandle Entity) const
	{
		static_assert(TIsDerivedFrom<ConstSharedFragmentType, FMassConstSharedFragment>::IsDerived, "Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.");
		const FConstSharedStruct* ConstSharedStruct = InternalGetConstSharedFragmentPtr(Entity, ConstSharedFragmentType::StaticStruct());
		return (ConstSharedFragmentType*)(ConstSharedStruct ? ConstSharedStruct->GetMemory() : nullptr);
	}

	template<typename ConstSharedFragmentType>
	ConstSharedFragmentType& GetConstSharedFragmentDataChecked(FMassEntityHandle Entity) const
	{
		ConstSharedFragmentType* TypePtr = GetConstSharedFragmentDataPtr<ConstSharedFragmentType>(Entity);
		check(TypePtr);
		return *TypePtr;
	}

	FConstStructView GetConstSharedFragmentDataStruct(FMassEntityHandle Entity, const UScriptStruct* ConstSharedFragmentType) const
	{
		checkf((ConstSharedFragmentType != nullptr) && ConstSharedFragmentType->IsChildOf(FMassConstSharedFragment::StaticStruct())
			, TEXT("GetConstSharedFragmentDataStruct called with an invalid fragment type '%s'"), *GetPathNameSafe(ConstSharedFragmentType));
		const FConstSharedStruct* ConstSharedStruct = InternalGetConstSharedFragmentPtr(Entity, ConstSharedFragmentType);
		return ConstSharedStruct
			? FConstStructView(*ConstSharedStruct)
			: FConstStructView();
	}

	template<typename SharedFragmentType>
	TConstArrayView<FSharedStruct> GetSharedFragmentsOfType()
	{
		static_assert(TIsDerivedFrom<SharedFragmentType, FMassSharedFragment>::IsDerived
			, "Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.");

		TArray<FSharedStruct>* InstancesOfType = SharedFragmentsTypeMap.Find(SharedFragmentType::StaticStruct());
		return InstancesOfType ? *InstancesOfType : TConstArrayView<FSharedStruct>();
	}

	template<typename SharedFragmentType>
	SharedFragmentType* GetSharedFragmentDataPtr(FMassEntityHandle Entity) const
	{
		static_assert(TIsDerivedFrom<SharedFragmentType, FMassSharedFragment>::IsDerived
			, "Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.");
		const FSharedStruct* FragmentPtr = InternalGetSharedFragmentPtr(Entity, SharedFragmentType::StaticStruct());
		return (SharedFragmentType*)(FragmentPtr ? FragmentPtr->GetMemory() : nullptr);
	}

	template<typename SharedFragmentType>
	SharedFragmentType& GetSharedFragmentDataChecked(FMassEntityHandle Entity) const
	{
		SharedFragmentType* TypePtr = GetSharedFragmentDataPtr<SharedFragmentType>(Entity);
		check(TypePtr);
		return *TypePtr;
	}

	FConstStructView GetSharedFragmentDataStruct(FMassEntityHandle Entity, const UScriptStruct* SharedFragmentType) const
	{
		checkf((SharedFragmentType != nullptr) && SharedFragmentType->IsChildOf(FMassSharedFragment::StaticStruct())
			, TEXT("GetSharedFragmentDataStruct called with an invalid fragment type '%s'"), *GetPathNameSafe(SharedFragmentType));
		const FSharedStruct* FragmentPtr = InternalGetSharedFragmentPtr(Entity, SharedFragmentType);
		return FragmentPtr
			? FConstStructView(*FragmentPtr)
			: FConstStructView();
	}

	uint32 GetArchetypeDataVersion() const { return ArchetypeDataVersion; }

	/**
	 * Creates and initializes a FMassExecutionContext instance.
	 */
	FMassExecutionContext CreateExecutionContext(const float DeltaSeconds);

	FScopedProcessing NewProcessingScope() { return FScopedProcessing(ProcessingScopeCount); }

	/** 
	 * Indicates whether there are processors out there performing operations on this instance of MassEntityManager. 
	 * Used to ensure that mutating operations (like entity destruction) are not performed while processors are running, 
	 * which rely on the assumption that the data layout doesn't change during calculations. 
	 */
	bool IsProcessing() const { return ProcessingScopeCount > 0; }

	FMassCommandBuffer& Defer() const { return *DeferredCommandBuffers[OpenedCommandBufferIndex].Get(); }
	/** 
	 * @param InCommandBuffer if not set then the default command buffer will be flushed. If set and there's already 
	 *		a command buffer being flushed (be it the main one or a previously requested one) then this command buffer 
	 *		will be queue itself.
	 */
	void FlushCommands(TSharedPtr<FMassCommandBuffer>& InCommandBuffer);

	void FlushCommands();

	/** 
	 * Depending on the current state of Manager's command buffer the function will either move all the commands out of 
	 * InOutCommandBuffer into the main command buffer or append it to the list of command buffers waiting to be flushed.
	 * @note as a consequence of the call InOutCommandBuffer can get its contents emptied due some of the underlying code using Move semantics
	 */
	void AppendCommands(TSharedPtr<FMassCommandBuffer>& InOutCommandBuffer);

	template<typename T>
	UE_DEPRECATED(5.5, "This method will no longer be exposed. Use GetOrCreateConstSharedFragment instead.")
	const FConstSharedStruct& GetOrCreateConstSharedFragmentByHash(const uint32 Hash, const T& Fragment)
	{
		static_assert(TIsDerivedFrom<T, FMassConstSharedFragment>::IsDerived, "Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.");
		int32& Index = ConstSharedFragmentsMap.FindOrAddByHash(Hash, Hash, INDEX_NONE);
		if (Index == INDEX_NONE)
		{
			Index = ConstSharedFragments.Add(FConstSharedStruct::Make(Fragment));
		}
		return ConstSharedFragments[Index];
	}

private:
	template<typename T>
	const FSharedStruct& GetOrCreateSharedFragmentByHash(const uint32 Hash, const T& Fragment)
	{
		static_assert(TIsDerivedFrom<T, FMassSharedFragment>::IsDerived, "Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.");
		int32& Index = SharedFragmentsMap.FindOrAddByHash(Hash, Hash, INDEX_NONE);
		if (Index == INDEX_NONE)
		{
			Index = SharedFragments.Add(FSharedStruct::Make(Fragment));
			// note that even though we're copying the freshly created FSharedStruct instance it's perfectly fine since 
			// FSharedStruct do guarantee there's not going to be data duplication (via a member shared pointer to hosted data)
			TArray<FSharedStruct>& InstancesOfType = SharedFragmentsTypeMap.FindOrAdd(T::StaticStruct(), {});
			InstancesOfType.Add(SharedFragments[Index]);
		}

		return SharedFragments[Index];
	}

	const FConstSharedStruct& GetOrCreateConstSharedFragmentByHash(const uint32 Hash, const UScriptStruct* InScriptStruct, const uint8* InStructMemory)
	{
		int32& Index = ConstSharedFragmentsMap.FindOrAddByHash(Hash, Hash, INDEX_NONE);
		if (Index == INDEX_NONE)
		{
			Index = ConstSharedFragments.Add(FConstSharedStruct::Make(InScriptStruct, InStructMemory));
		}
		return ConstSharedFragments[Index];
	}

	const FSharedStruct& GetOrCreateSharedFragmentByHash(const uint32 Hash, const UScriptStruct* InScriptStruct, const uint8* InStructMemory)
	{
		int32& Index = SharedFragmentsMap.FindOrAddByHash(Hash, Hash, INDEX_NONE);
		if (Index == INDEX_NONE)
		{
			Index = SharedFragments.Add(FSharedStruct::Make(InScriptStruct, InStructMemory));
			// note that even though we're copying the freshly created FSharedStruct instance it's perfectly fine since 
			// FSharedStruct do guarantee there's not going to be data duplication (via a member shared pointer to hosted data)
			TArray<FSharedStruct>& InstancesOfType = SharedFragmentsTypeMap.FindOrAdd(InScriptStruct, {});
			InstancesOfType.Add(SharedFragments[Index]);
		}
		return SharedFragments[Index];
	}

	template<typename T, typename... TArgs>
	const FConstSharedStruct& GetOrCreateConstSharedFragmentByHash(const uint32 Hash, TArgs&&... InArgs)
	{
		static_assert(TIsDerivedFrom<T, FMassConstSharedFragment>::IsDerived, "Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.");
		int32& Index = ConstSharedFragmentsMap.FindOrAddByHash(Hash, Hash, INDEX_NONE);
		if (Index == INDEX_NONE)
		{
			Index = ConstSharedFragments.Add(FConstSharedStruct::Make<T>(Forward<TArgs>(InArgs)...));
		}

		return ConstSharedFragments[Index];
	}

public:

	template<typename T, typename... TArgs>
	UE_DEPRECATED(5.5, "This method will no longer be exposed. Use GetOrCreateSharedFragment instead.")
	const FSharedStruct& GetOrCreateSharedFragmentByHash(const uint32 Hash, TArgs&&... InArgs)
	{
		static_assert(TIsDerivedFrom<T, FMassSharedFragment>::IsDerived, "Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.");
		int32& Index = SharedFragmentsMap.FindOrAddByHash(Hash, Hash, INDEX_NONE);
		if (Index == INDEX_NONE)
		{
			Index = SharedFragments.Add(FSharedStruct::Make<T>(Forward<TArgs>(InArgs)...));
			// note that even though we're copying the freshly created FSharedStruct instance it's perfectly fine since 
			// FSharedStruct do guarantee there's not going to be data duplication (via a member shared pointer to hosted data)
			TArray<FSharedStruct>& InstancesOfType = SharedFragmentsTypeMap.FindOrAdd(T::StaticStruct(), {});
			InstancesOfType.Add(SharedFragments[Index]);
		}

		return SharedFragments[Index];
	}

	/**
	 * Returns or creates a shared struct associated to a given shared fragment set of values
	 * identified internally by a CRC.
	 * Use this overload when an instance of the desired const shared fragment type is available and
	 * that can be used directly to compute a CRC (i.e., UE::StructUtils::GetStructCrc32)
	 *	e.g.,
	 *	USTRUCT()
	 *	struct FIntConstSharedFragment : public FMassConstSharedFragment
	 *	{
	 *		GENERATED_BODY()
	 *
	 *		UPROPERTY()
	 *		int32 Value = 0;
	 *	};
	 *
	 *	FIntConstSharedFragment Fragment;
	 *	Fragment.Value = 123;
	 *	const FConstSharedStruct SharedStruct = EntityManager.GetOrCreateConstSharedFragment(Fragment);
	 *
	 * @params Fragment Instance of the desired fragment type
	 * @return FConstSharedStruct to the matching, or newly created shared fragment
	 */
	template<typename T>
	const FConstSharedStruct& GetOrCreateConstSharedFragment(const T& Fragment)
	{
		static_assert(TIsDerivedFrom<T, FMassConstSharedFragment>::IsDerived,
			"Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.");
		const uint32 Hash = UE::StructUtils::GetStructCrc32(FConstStructView::Make(Fragment));
PRAGMA_DISABLE_DEPRECATION_WARNINGS
		return GetOrCreateConstSharedFragmentByHash(Hash, Fragment);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
	}

	/**
	 * Returns or creates a shared struct associated to a given shared fragment set of values
	 * identified internally by a CRC.
	 * Use this overload when an instance of the desired shared fragment type is available and
	 * that can be used directly to compute a CRC (i.e., UE::StructUtils::GetStructCrc32)
	 *	e.g.,
	 *	USTRUCT()
	 *	struct FIntSharedFragment : public FMassSharedFragment
	 *	{
	 *		GENERATED_BODY()
	 *
	 *		UPROPERTY()
	 *		int32 Value = 0;
	 *	};
	 *
	 *	FIntSharedFragment Fragment;
	 *	Fragment.Value = 123;
	 *	const FSharedStruct SharedStruct = EntityManager.GetOrCreateSharedFragment(Fragment);
	 *
	 * @params Fragment Instance of the desired fragment type
	 * @return FSharedStruct to the matching, or newly created shared fragment
	 */
	template<typename T>
	const FSharedStruct& GetOrCreateSharedFragment(const T& Fragment)
	{
		static_assert(TIsDerivedFrom<T, FMassSharedFragment>::IsDerived,
			"Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.");
		const uint32 Hash = UE::StructUtils::GetStructCrc32(FConstStructView::Make(Fragment));
		return GetOrCreateSharedFragmentByHash(Hash, Fragment);
	}

	/**
	 * Returns or creates a shared struct associated to a given shared fragment set of values
	 * identified internally by a CRC.
	 * Use this overload when values can be provided as constructor arguments for the desired const shared fragment type and
	 * that can be used directly to compute a CRC (i.e., UE::StructUtils::GetStructCrc32)
 	 *	e.g.,
	 *	USTRUCT()
	 *	struct FIntConstSharedFragment : public FMassConstSharedFragment
	 *	{
	 *		GENERATED_BODY()
	 *
	 *		FIntConstSharedFragment(const int32 InValue) : Value(InValue) {}
	 *
	 *		UPROPERTY()
	 *		int32 Value = 0;
	 *	};
	 *
	 *	const FConstSharedStruct SharedStruct = EntityManager.GetOrCreateConstSharedFragment<FIntConstSharedFragment>(123);
	 *
	 * @params InArgs List of arguments provided to the constructor of the desired fragment type
	 * @return FConstSharedStruct to the matching, or newly created shared fragment
	 */
	template<typename T, typename... TArgs>
	const FConstSharedStruct& GetOrCreateConstSharedFragment(TArgs&&... InArgs)
	{
		static_assert(TIsDerivedFrom<T, FMassConstSharedFragment>::IsDerived,
			"Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.");
		T Struct(Forward<TArgs>(InArgs)...);
		const uint32 Hash = UE::StructUtils::GetStructCrc32(FConstStructView::Make(Struct));
PRAGMA_DISABLE_DEPRECATION_WARNINGS
		return GetOrCreateConstSharedFragmentByHash(Hash, MoveTemp(Struct));
PRAGMA_ENABLE_DEPRECATION_WARNINGS
	}

	/**
	 * Returns or creates a shared struct associated to a given shared fragment set of values
	 * identified internally by a CRC.
	 * Use this overload when values can be provided as constructor arguments for the desired shared fragment type and
	 * that can be used directly to compute a CRC (i.e., UE::StructUtils::GetStructCrc32)
 	 *	e.g.,
	 *	USTRUCT()
	 *	struct FIntSharedFragment : public FMassSharedFragment
	 *	{
	 *		GENERATED_BODY()
	 *
	 *		FIntSharedFragment(const int32 InValue) : Value(InValue) {}
	 *
	 *		UPROPERTY()
	 *		int32 Value = 0;
	 *	};
	 *
	 *	const FSharedStruct SharedStruct = EntityManager.GetOrCreateSharedFragment<FIntSharedFragment>(123);
	 *
	 * @params InArgs List of arguments provided to the constructor of the desired fragment type
	 * @return FSharedStruct to the matching, or newly created shared fragment
	 */
	template<typename T, typename... TArgs>
	const FSharedStruct& GetOrCreateSharedFragment(TArgs&&... InArgs)
	{
		static_assert(TIsDerivedFrom<T, FMassSharedFragment>::IsDerived,
			"Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.");
		T Struct(Forward<TArgs>(InArgs)...);
		const uint32 Hash = UE::StructUtils::GetStructCrc32(FConstStructView::Make(Struct));
		return GetOrCreateSharedFragmentByHash(Hash, MoveTemp(Struct));
	}

	/**
	 * Returns or creates a shared struct associated to a given shared fragment set of values
	 * identified internally by a CRC.
	 * Use this overload when the reflection data and the memory of an instance of the desired const shared fragment type
	 * is available and that can be used directly to compute a CRC (i.e., UE::StructUtils::GetStructCrc32)
	 * e.g.,
	 * FSharedStruct SharedStruct = EntityManager.GetOrCreateConstSharedFragment(*StructView.GetScriptStruct(), StructView.GetMemory());
	 *
	 * @params InScriptStruct Reflection data structure associated to the desired fragment type
	 * @params InStructMemory Actual data of the desired fragment type 
	 * @return FConstSharedStruct to the matching, or newly created shared fragment
	 */
	const FConstSharedStruct& GetOrCreateConstSharedFragment(const UScriptStruct& InScriptStruct, const uint8* InStructMemory)
	{
		checkf(InScriptStruct.IsChildOf(TBaseStructure<FMassConstSharedFragment>::Get()),
			TEXT("Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types."));
		const uint32 Hash = UE::StructUtils::GetStructCrc32(InScriptStruct, InStructMemory);
		return GetOrCreateConstSharedFragmentByHash(Hash, &InScriptStruct, InStructMemory);
	}

	/**
	 * Returns or creates a shared struct associated to a given shared fragment set of values
	 * identified internally by a CRC.
	 * Use this overload when the reflection data and the memory of an instance of the desired shared fragment type
	 * is available and that can be used directly to compute a CRC (i.e., UE::StructUtils::GetStructCrc32)
	 * e.g.,
	 * FSharedStruct SharedStruct = EntityManager.GetOrCreateSharedFragment(*StructView.GetScriptStruct(), StructView.GetMemory());
	 *
	 * @params InScriptStruct Reflection data structure associated to the desired fragment type
	 * @params InStructMemory Actual data of the desired fragment type 
	 * @return FSharedStruct to the matching, or newly created shared fragment
	 */
	const FSharedStruct& GetOrCreateSharedFragment(const UScriptStruct& InScriptStruct, const uint8* InStructMemory)
	{
		checkf(InScriptStruct.IsChildOf(TBaseStructure<FMassSharedFragment>::Get()),
			TEXT("Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types."));
		const uint32 Hash = UE::StructUtils::GetStructCrc32(InScriptStruct, InStructMemory);
		return GetOrCreateSharedFragmentByHash(Hash, &InScriptStruct, InStructMemory);
	}

	/**
	 * Returns or creates a shared struct associated to a given shared fragment set of values
	 * identified internally by a CRC.
	 * Use this overload when a different struct should be used to compute a CRC (i.e., UE::StructUtils::GetStructCrc32)
	 * and values can be provided as constructor arguments for the desired const shared fragment type
	 *	e.g.,
	 *
	 *	USTRUCT()
	 *	struct FIntConstSharedFragmentParams
	 *	{
	 *		GENERATED_BODY()
	 *
	 *		FIntConstSharedFragmentParams(const int32 InValue) : Value(InValue) {}
	 *
	 *		UPROPERTY()
	 *		int32 Value = 0;
	 *	};
	 *
	 *	USTRUCT()
	 *	struct FIntConstSharedFragment : public FMassConstSharedFragment
	 *	{
	 *		GENERATED_BODY()
	 *
	 *		FIntConstSharedFragment(const FIntConstSharedFragmentParams& InParams) : Value(InParams.Value) {}
	 *
	 *		int32 Value = 0;
	 *	};
	 *
	 *	FIntConstSharedFragmentParams Params(123);
	 *	const FConstSharedStruct SharedStruct = EntityManager.GetOrCreateConstSharedFragment<FIntConstSharedFragment>(FConstStructView::Make(Params), Params);
	 *
	 * @params HashingHelperStruct Struct view passed to UE::StructUtils::GetStructCrc32 to compute the CRC
	 * @params InArgs List of arguments provided to the constructor of the desired fragment type
	 * @return FConstSharedStruct to the matching, or newly created shared fragment
	 */
	template<typename T, typename... TArgs>
	const FConstSharedStruct& GetOrCreateConstSharedFragment(const FConstStructView HashingHelperStruct, TArgs&&... InArgs)
	{
		static_assert(TIsDerivedFrom<T, FMassConstSharedFragment>::IsDerived,
			"Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.");
		T Fragment(Forward<TArgs>(InArgs)...);
		const uint32 Hash = UE::StructUtils::GetStructCrc32(HashingHelperStruct);
PRAGMA_DISABLE_DEPRECATION_WARNINGS
		return GetOrCreateConstSharedFragmentByHash(Hash, MoveTemp(Fragment));
PRAGMA_ENABLE_DEPRECATION_WARNINGS
	}

	/**
	 * Returns or creates a shared struct associated to a given shared fragment set of values
	 * identified internally by a CRC.
	 * Use this overload when a different struct should be used to compute a CRC (i.e., UE::StructUtils::GetStructCrc32)
	 * and values can be provided as constructor arguments for the desired shared fragment type
	 *	e.g.,
	 *
	 *	USTRUCT()
	 *	struct FIntSharedFragmentParams
	 *	{
	 *		GENERATED_BODY()
	 *
	 *		FInSharedFragmentParams(const int32 InValue) : Value(InValue) {}
	 *
	 *		UPROPERTY()
	 *		int32 Value = 0;
	 *	};
	 *
	 *	USTRUCT()
	 *	struct FIntSharedFragment : public FMassSharedFragment
	 *	{
	 *		GENERATED_BODY()
	 *
	 *		FIntSharedFragment(const FIntConstSharedFragmentParams& InParams) : Value(InParams.Value) {}
	 *
	 *		int32 Value = 0;
	 *	};
	 *
	 *	FIntSharedFragmentParams Params(123);
	 *	const FSharedStruct SharedStruct = EntityManager.GetOrCreateSharedFragment<FIntSharedFragment>(FConstStructView::Make(Params), Params);
	 *
	 * @params HashingHelperStruct Struct view passed to UE::StructUtils::GetStructCrc32 to compute the CRC
	 * @params InArgs List of arguments provided to the constructor of the desired fragment type
	 * @return FSharedStruct to the matching, or newly created shared fragment
	 */
	template<typename T, typename... TArgs>
	const FSharedStruct& GetOrCreateSharedFragment(const FConstStructView HashingHelperStruct, TArgs&&... InArgs)
	{
		static_assert(TIsDerivedFrom<T, FMassSharedFragment>::IsDerived,
			"Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.");
		T Fragment(Forward<TArgs>(InArgs)...);
		const uint32 Hash = UE::StructUtils::GetStructCrc32(HashingHelperStruct);
		return GetOrCreateSharedFragmentByHash(Hash, MoveTemp(Fragment));
	}

	template<typename T>
	void ForEachSharedFragment(TFunctionRef< void(T& /*SharedFragment*/) > ExecuteFunction)
	{
		if (TArray<FSharedStruct>* InstancesOfType = SharedFragmentsTypeMap.Find(T::StaticStruct()))
		{
			for (const FSharedStruct& SharedStruct : *InstancesOfType)
			{
				ExecuteFunction(SharedStruct.Get<T>());
			}
		}
	}

	template<typename T>
	void ForEachSharedFragmentConditional(TFunctionRef< bool(T& /*SharedFragment*/) > ConditionFunction, TFunctionRef< void(T& /*SharedFragment*/) > ExecuteFunction)
	{
		if (TArray<FSharedStruct>* InstancesOfType = SharedFragmentsTypeMap.Find(T::StaticStruct()))
		{
			for (const FSharedStruct& SharedStruct : *InstancesOfType)
			{
				T& StructInstanceRef = SharedStruct.Get<T>();
				if (ConditionFunction(StructInstanceRef))
				{
					ExecuteFunction(StructInstanceRef);
				}
			}
		}
	}

	FMassObserverManager& GetObserverManager() { return ObserverManager; }

	FOnNewArchetypeDelegate& GetOnNewArchetypeEvent() { return OnNewArchetypeEvent; }
	/** 
	 * Fetches the world associated with the Owner. 
	 * @note that it's ok for a given EntityManager to not have an owner or the owner not being part of a UWorld, depending on the use case
	 */
	UWorld* GetWorld() const { return Owner.IsValid() ? Owner->GetWorld() : nullptr; }
	UObject* GetOwner() const { return Owner.Get(); }

	void SetDebugName(const FString& NewDebugGame);
#if WITH_MASSENTITY_DEBUG
	void DebugPrintArchetypes(FOutputDevice& Ar, const bool bIncludeEmpty = true) const;
	void DebugGetArchetypesStringDetails(FOutputDevice& Ar, const bool bIncludeEmpty = true) const;
	void DebugGetArchetypeFragmentTypes(const FMassArchetypeHandle& Archetype, TArray<const UScriptStruct*>& InOutFragmentList) const;
	int32 DebugGetArchetypeEntitiesCount(const FMassArchetypeHandle& Archetype) const;
	int32 DebugGetArchetypeEntitiesCountPerChunk(const FMassArchetypeHandle& Archetype) const;
	int32 DebugGetEntityCount() const;
	int32 DebugGetArchetypesCount() const;
	void DebugRemoveAllEntities();
	void DebugForceArchetypeDataVersionBump();
	void DebugGetArchetypeStrings(const FMassArchetypeHandle& Archetype, TArray<FName>& OutFragmentNames, TArray<FName>& OutTagNames);
	FMassEntityHandle DebugGetEntityIndexHandle(const int32 EntityIndex) const;
	const FString& DebugGetName() const;

	FMassRequirementAccessDetector& GetRequirementAccessDetector();

	// For use by the friend MassDebugger
	UE::Mass::IEntityStorageInterface& DebugGetEntityStorageInterface();
	// For use by the friend MassDebugger
	const UE::Mass::IEntityStorageInterface& DebugGetEntityStorageInterface() const;
#endif // WITH_MASSENTITY_DEBUG

protected:
	/** Called on the child process upon process's forking */
	void OnPostFork(EForkProcessRole Role);

	void GetMatchingArchetypes(const FMassFragmentRequirements& Requirements, TArray<FMassArchetypeHandle>& OutValidArchetypes, const uint32 FromArchetypeDataVersion) const;
	
	/** 
	 * A "similar" archetype is an archetype exactly the same as SourceArchetype except for one composition aspect 
	 * like Fragments or "Tags" 
	 */
	FMassArchetypeHandle InternalCreateSimilarArchetype(const TSharedPtr<FMassArchetypeData>& SourceArchetype, const FMassTagBitSet& OverrideTags);
	FMassArchetypeHandle InternalCreateSimilarArchetype(const TSharedPtr<FMassArchetypeData>& SourceArchetype, const FMassFragmentBitSet& OverrideFragments);

	FMassArchetypeHandle InternalCreateSimilarArchetype(const FMassArchetypeData& SourceArchetypeRef, FMassArchetypeCompositionDescriptor&& NewComposition);

	void InternalAppendFragmentsAndTagsToArchetypeCompositionDescriptor(FMassArchetypeCompositionDescriptor& InOutComposition,
		TConstArrayView<const UScriptStruct*> FragmentsAndTagsList) const;

private:
	void InternalBuildEntity(FMassEntityHandle Entity, const FMassArchetypeHandle& ArchetypeHandle, const FMassArchetypeSharedFragmentValues& SharedFragmentValues);
	void InternalReleaseEntity(FMassEntityHandle Entity);

	/** 
	 *  Adds fragments in FragmentList to Entity. Only the unique fragments will be added.
	 *  @return Bitset for the added fragments (might be empty or a subset of `InFragments` depending on the current archetype fragments)
	 */
	FMassFragmentBitSet InternalAddFragmentListToEntityChecked(FMassEntityHandle Entity, const FMassFragmentBitSet& InFragments);

	/** 
	 *  Similar to InternalAddFragmentListToEntity but expects NewFragmentList not overlapping with current entity's
	 *  fragment list. It's callers responsibility to ensure that's true. Failing this will cause a `check` fail.
	 */
	void InternalAddFragmentListToEntity(FMassEntityHandle Entity, const FMassFragmentBitSet& InFragments);
	/** Note that it's the caller's responsibility to ensure `FragmentType` is a kind of FMassFragment */
	void* InternalGetFragmentDataChecked(FMassEntityHandle Entity, const UScriptStruct* FragmentType) const;
	/** Note that it's the caller's responsibility to ensure `FragmentType` is a kind of FMassFragment */
	void* InternalGetFragmentDataPtr(FMassEntityHandle Entity, const UScriptStruct* FragmentType) const;
	/** Note that it's the caller's responsibility to ensure `ConstSharedFragmentType` is a kind of FMassSharedFragment */
	const FConstSharedStruct* InternalGetConstSharedFragmentPtr(FMassEntityHandle Entity, const UScriptStruct* ConstSharedFragmentType) const;
	/** Note that it's the caller's responsibility to ensure `SharedFragmentType` is a kind of FMassSharedFragment */
	const FSharedStruct* InternalGetSharedFragmentPtr(FMassEntityHandle Entity, const UScriptStruct* SharedFragmentType) const;

	TSharedRef<FEntityCreationContext> InternalBatchCreateReservedEntities(const FMassArchetypeHandle& ArchetypeHandle,
		const FMassArchetypeSharedFragmentValues& SharedFragmentValues, TConstArrayView<FMassEntityHandle> ReservedEntities);
	
#if MASS_CONCURRENT_RESERVE
	UE::Mass::IEntityStorageInterface& GetEntityStorageInterface();
	const UE::Mass::IEntityStorageInterface& GetEntityStorageInterface() const;
#else
	UE::Mass::FSingleThreadedEntityStorage& GetEntityStorageInterface();
	const UE::Mass::FSingleThreadedEntityStorage& GetEntityStorageInterface() const;
#endif

	/**
	 * If ActiveCreationContext is not valid the function creates a new shared FEntityCreationContext instance and returns that.
	 * Otherwise ActiveCreationContext will get extended with ReservedEntities and EntityCollection, and returned by the function.
	 */
	TSharedRef<FEntityCreationContext> GetOrMakeCreationContext(TConstArrayView<FMassEntityHandle> ReservedEntities, FMassArchetypeEntityCollection&& EntityCollection);
	bool IsDuringEntityCreation() const { return ActiveCreationContext.IsValid(); }
	
	/** 
	 * This type is used in entity mutating batched API to ensure the active FEntityCreationContext gets dirtied 
	 * upon function's end (since the mutating operations render FEntityCreationContext.EntityCollections invalid).
	 * It also serves as a cached IsDuringEntityCreation value.
	 */
	struct FScopedCreationContextOperations
	{
		FScopedCreationContextOperations(FMassEntityManager& InManager)
			: bIsDuringEntityCreation(InManager.IsDuringEntityCreation())
			, Manager(InManager)
		{}
		~FScopedCreationContextOperations()
		{
			if (bIsDuringEntityCreation)
			{
				Manager.DirtyCreationContext();
			}
			// else, there's nothing to do, there's no creation context to call functions for
		}

		bool IsAllowedToTriggerObservers() const { return (bIsDuringEntityCreation == false); }

	private:
		const bool bIsDuringEntityCreation = false;
		FMassEntityManager& Manager;
	};
	friend FScopedCreationContextOperations;

	/** @return whether actual context dirtying took place which is equivalent to IsDuringEntityCreation */
	bool DirtyCreationContext();

	/** 
	 * @return whether it's allowed for observers to get triggered. If not then the active creation context will be dirtied
	 *	to cause observers triggering upon context's destruction
	 */
	bool IsAllowedToTriggerObservers() { return DirtyCreationContext() == false; }
	bool DebugDoCollectionsOverlapCreationContext(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections) const;
		
private:

	friend struct UE::Mass::Private::FEntityStorageInitializer;
	using FEntityStorageContainerType = TVariant<
		FEmptyVariantState,
		UE::Mass::FSingleThreadedEntityStorage,
		UE::Mass::FConcurrentEntityStorage>;
	FEntityStorageContainerType EntityStorage;

	/** Never access directly, use GetOrMakeCreationContext instead. */
	TWeakPtr<FEntityCreationContext> ActiveCreationContext;

	std::atomic<bool> bCommandBufferFlushingInProgress = false;

	/**
	 * This index will be enough to control which buffer is available for pushing commands since flashing is taking place 
	 * in the game thread and pushing commands to the buffer fetched by Defer() is only supported also on the game thread
	 * (due to checking the cached thread ID).
	 * The whole CL aims to support non-mass code trying to push commands while the flushing is going on (as triggered
	 * by MassObservers reacting to the commands being flushed currently).
	 */
	uint8 OpenedCommandBufferIndex = 0;
	TStaticArray<TSharedPtr<FMassCommandBuffer>, 2> DeferredCommandBuffers;
	
	std::atomic<int32> ProcessingScopeCount = 0;

	// the "version" number increased every time an archetype gets added
	uint32 ArchetypeDataVersion = 0;

	// Map of hash of sorted fragment list to archetypes with that hash
	TMap<uint32, TArray<TSharedPtr<FMassArchetypeData>>> FragmentHashToArchetypeMap;

	// Map to list of archetypes that contain the specified fragment type
	TMap<const UScriptStruct*, TArray<TSharedPtr<FMassArchetypeData>>> FragmentTypeToArchetypeMap;

	// Contains all archetypes ever created. The array always growing and a given archetypes remains at a given index 
	// throughout its lifetime, and the index is never reused for another archetype. 
	TArray<TSharedPtr<FMassArchetypeData>> AllArchetypes;

	// Shared fragments
	TArray<FConstSharedStruct> ConstSharedFragments;
	// Hash/Index in array pair
	TMap<uint32, int32> ConstSharedFragmentsMap;

	TArray<FSharedStruct> SharedFragments;
	// Hash/Index in array pair, indices point at SharedFragments
	TMap<uint32, int32> SharedFragmentsMap;
	// Maps specific struct type to a collection of FSharedStruct instances of that type
	TMap<const UScriptStruct*, TArray<FSharedStruct>> SharedFragmentsTypeMap;

	FMassObserverManager ObserverManager;

#if WITH_MASSENTITY_DEBUG
	FMassRequirementAccessDetector RequirementAccessDetector;
	FString DebugName;
#endif // WITH_MASSENTITY_DEBUG

	TWeakObjectPtr<UObject> Owner;

	FOnNewArchetypeDelegate OnNewArchetypeEvent;

	bool bInitialized = false;
	bool bFirstCommandFlush = true;

	FDelegateHandle OnPostForkHandle;
};

=============================================


=== MassEntity/Public/MassEntityManagerStorage.h ===
====================================================

// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "Async/Mutex.h"
#include "Containers/ChunkedArray.h"
#include "Misc/TVariant.h"
#include "Templates/SharedPointer.h"
#include "MassProcessingTypes.h"

struct FMassArchetypeData;
struct FMassEntityHandle;

// Initialization parameters to configure MassEntityManager to reserve entities only single threaded
// Supported in all build configurations
struct MASSENTITY_API FMassEntityManager_InitParams_SingleThreaded {};

// Initialization parameters to configure MassEntityManager to concurrently reserve entities
// Only supported in editor builds.
//
// Expected static memory requirement for array of Page pointers can be computed:
// MaxPages = MaxEntityCount / MaxEntitiesPerPage
// MemorySize = MaxPages * sizeof(Page**)
//
// For default values, expectation is 128kB
struct MASSENTITY_API FMassEntityManager_InitParams_Concurrent
{
	// Maximum supported entities by the MassEntityManager
	// Must be multiple of 2
	uint32 MaxEntityCount = 1 << 30; // 1 billion

	// Number of entities per chunk
	// Must be multiple of 2
	uint32 MaxEntitiesPerPage = 1 << 16; // 65536
};

using FMassEntityManagerStorageInitParams = TVariant<FMassEntityManager_InitParams_SingleThreaded, FMassEntityManager_InitParams_Concurrent>;

namespace UE::Mass
{
	/**
	 * Interface that abstracts the storage system for Mass Entities in the EntityManager
	 * This may be temporary until the concurrent mechanism has been vetted for performance
	 */
	class IEntityStorageInterface
	{
	public:
		enum class EEntityState
		{
			// Entity index refers to an entity that is free to be reserved or created
			Free,
			// Entity index refers to a reserved entity
			Reserved,
			// Entity index refers to an entity assigned to an archetype
			Created
		};
		virtual ~IEntityStorageInterface() = default;

		virtual FMassArchetypeData* GetArchetype(int32 Index) = 0;
		virtual const FMassArchetypeData* GetArchetype(int32 Index) const = 0;
		virtual TSharedPtr<FMassArchetypeData>& GetArchetypeAsShared(int32 Index) = 0;
		virtual const TSharedPtr<FMassArchetypeData>& GetArchetypeAsShared(int32 Index) const = 0;
	
		virtual void SetArchetypeFromShared(int32 Index, TSharedPtr<FMassArchetypeData>& Archetype) = 0;
		virtual void SetArchetypeFromShared(int32 Index, const TSharedPtr<FMassArchetypeData>& Archetype) = 0;

		// Returns true if the given entity at index is currently reserved
		// False if free or assigned an archetype
		virtual EEntityState GetEntityState(int32 Index) const = 0;
	
		virtual int32 GetSerialNumber(int32 Index) const = 0;

		// Checks if index can be used to access entity data
		virtual bool IsValidIndex(int32 Index) const = 0;
		virtual SIZE_T GetAllocatedSize() const = 0;

		// Checks if entity at Index is built
		virtual bool IsValid(int32 Index) const = 0;

		virtual FMassEntityHandle AcquireOne() = 0;
		// @return number of entities actually added
		int32 Acquire(const int32 Count, TArray<FMassEntityHandle>& OutEntityHandles);
		virtual int32 Acquire(TArrayView<FMassEntityHandle> OutEntityHandles) = 0;

		virtual int32 Release(TConstArrayView<FMassEntityHandle> Handles) = 0;
		virtual int32 ReleaseOne(FMassEntityHandle Handles) = 0;
		
		// Bypasses Serial Number Check
		// Only use if caller has ensured serial number matches or for debug purposes
		virtual int32 ForceRelease(TConstArrayView<FMassEntityHandle> Handles) = 0;
		virtual int32 ForceReleaseOne(FMassEntityHandle Handle) = 0;

		// Returns the number of entities that are not free
		// For debug purposes only.  In multi-threaded environments, the result is going to be out of date
		virtual int32 Num() const = 0;

		// Returns the number of entities that are free
		// For debug purposes only.  In multi-threaded environments, the result is going to be out of date
		virtual int32 ComputeFreeSize() const = 0;
	};

	
	//////////////////////////////////////////////////////////////////////
	// FSingleThreadedEntityStorage

	/**
	 * This storage backend should be used when the user of MassEntityManager can guarantee
	 * that all entity management will be done on a single thread.
	 */
	class FSingleThreadedEntityStorage final : public IEntityStorageInterface
	{
	public:
		void Initialize(const FMassEntityManager_InitParams_SingleThreaded&);
		virtual FMassArchetypeData* GetArchetype(int32 Index) override;
		virtual const FMassArchetypeData* GetArchetype(int32 Index) const override;
		virtual TSharedPtr<FMassArchetypeData>& GetArchetypeAsShared(int32 Index) override;
		virtual const TSharedPtr<FMassArchetypeData>& GetArchetypeAsShared(int32 Index) const override;
		virtual void SetArchetypeFromShared(int32 Index, TSharedPtr<FMassArchetypeData>&) override;
		virtual void SetArchetypeFromShared(int32 Index, const TSharedPtr<FMassArchetypeData>&) override;
		virtual EEntityState GetEntityState(int32 Index) const override;
		virtual int32 GetSerialNumber(int32 Index) const override;
		virtual bool IsValidIndex(int32 Index) const override;
		virtual SIZE_T GetAllocatedSize() const override;
		virtual bool IsValid(int32 Index) const override;
		virtual FMassEntityHandle AcquireOne() override;
		using IEntityStorageInterface::Acquire;
		virtual int32 Acquire(TArrayView<FMassEntityHandle> OutEntityHandles) override;
		virtual int32 Release(TConstArrayView<FMassEntityHandle> Handles) override;
		virtual int32 ReleaseOne(FMassEntityHandle Handle) override;
		virtual int32 ForceRelease(TConstArrayView<FMassEntityHandle> Handles) override;
		virtual int32 ForceReleaseOne(FMassEntityHandle Handle) override;
		virtual int32 Num() const override;
		virtual int32 ComputeFreeSize() const override;
	private:
	
		struct FEntityData
		{
			TSharedPtr<FMassArchetypeData> CurrentArchetype;
			int32 SerialNumber = 0;
			
			~FEntityData();
			void Reset();
			bool IsValid() const;
		};

		std::atomic<int32> SerialNumberGenerator = 0;
		TChunkedArray<FEntityData> Entities;
		TArray<int32> EntityFreeIndexList;
	};

	//////////////////////////////////////////////////////////////////////
	// FConcurrentEntityStorage

	/**
	 * This storage backend allows for entities to be concurrently reserved.  Reserved entities can also
	 * be concurrently freed.
	 * Creation of entities (ie. assignment of an archetype and addition of data into chunks) cannot be done
	 * concurrently with this implementation.
	 */
	class FConcurrentEntityStorage final : public IEntityStorageInterface
	{
	public:

		void Initialize(const FMassEntityManager_InitParams_Concurrent& InInitializationParams);

		virtual ~FConcurrentEntityStorage() override;

		virtual FMassArchetypeData* GetArchetype(int32 Index) override;
		virtual const FMassArchetypeData* GetArchetype(int32 Index) const override;
		virtual TSharedPtr<FMassArchetypeData>& GetArchetypeAsShared(int32 Index) override;
		virtual const TSharedPtr<FMassArchetypeData>& GetArchetypeAsShared(int32 Index) const override;
		virtual void SetArchetypeFromShared(int32 Index, TSharedPtr<FMassArchetypeData>& Archetype) override;
		virtual void SetArchetypeFromShared(int32 Index, const TSharedPtr<FMassArchetypeData>& Archetype) override;
		virtual EEntityState GetEntityState(int32 Index) const override;
		virtual int32 GetSerialNumber(int32 Index) const override;
		virtual bool IsValidIndex(int32 Index) const override;
		virtual SIZE_T GetAllocatedSize() const override;
		virtual bool IsValid(int32 Index) const override;
		virtual FMassEntityHandle AcquireOne() override;
		using IEntityStorageInterface::Acquire;
		virtual int32 Acquire(TArrayView<FMassEntityHandle> OutEntityHandles) override;
		virtual int32 Release(TConstArrayView<FMassEntityHandle> Handles) override;
		virtual int32 ReleaseOne(FMassEntityHandle Handle) override;
		virtual int32 ForceRelease(TConstArrayView<FMassEntityHandle> Handles) override;
		virtual int32 ForceReleaseOne(FMassEntityHandle Handle) override;
		virtual int32 Num() const override;
		virtual int32 ComputeFreeSize() const override;
#if WITH_MASSENTITY_DEBUG
		/** @return whether the assumptions are still valid */
		MASSENTITY_API static bool DebugAssumptionsSelfTest();
#endif // WITH_MASSENTITY_DEBUG
	private:	
	
		struct FEntityData
		{
			static constexpr int MaxGenerationBits = 30;
		
			TSharedPtr<FMassArchetypeData> CurrentArchetype;
			// Generation ID or version of the entity in this slot
			uint32 GenerationId : MaxGenerationBits = 0;
			// 1 if the entity is NOT free
			uint32 bIsAllocated : 1 = 0;

			~FEntityData();
			// Converts EntityData state into a SerialNumber for public usage
			int32 GetSerialNumber() const;

			bool operator==(const FEntityData& Other) const;
		};
	
		FEntityData& LookupEntity(int32 Index);
		const FEntityData& LookupEntity(int32 Index) const;

		// Returns size of a page in bytes
		uint64 ComputePageSize() const;

		// @return whether the operation was successful. Will return false when OOM
		bool AddPage();

		// Number of allocated Entities
		std::atomic<uint64> EntityCount = 0;
		uint32 MaximumEntityCountShift = 0;
		uint32 MaxEntitiesPerPage = 0;
		uint32 PageCount = 0;
		// ALWAYS acquire FreeListMutex before this one
		UE::FMutex PageAllocateMutex;
		// Pointer to array of pages
		FEntityData** EntityPages = nullptr;
	
		TArray<int32> EntityFreeIndexList;
		UE::FMutex FreeListMutex;
	};
	
} // namespace UE::Mass
====================================================


=== MassEntity/Public/MassEntityQuery.h ===
===========================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "UObject/Class.h"
#include "Containers/ArrayView.h"
#include "Containers/UnrealString.h"
#include "MassEntityTypes.h"
#include "MassArchetypeTypes.h"
#include "MassExternalSubsystemTraits.h"
#include "MassRequirements.h"
#include "MassEntityQuery.generated.h"


/** 
 *  FMassEntityQuery is a structure that is used to trigger calculations on cached set of valid archetypes as described 
 *  by requirements. See the parent classes FMassFragmentRequirements and FMassSubsystemRequirements for setting up the 
 *	required fragments and subsystems.
 * 
 *  A query to be considered valid needs declared at least one EMassFragmentPresence::All, EMassFragmentPresence::Any 
 *  EMassFragmentPresence::Optional fragment requirement.
 */
USTRUCT()
struct MASSENTITY_API FMassEntityQuery : public FMassFragmentRequirements, public FMassSubsystemRequirements
{
	GENERATED_BODY()

	friend struct FMassDebugger;

public:
	enum EParallelForMode
	{
		Default, // use whatever the whole system has been configured for
		ForceParallelExecution // force
	};

	FMassEntityQuery();
	FMassEntityQuery(std::initializer_list<UScriptStruct*> InitList);
	FMassEntityQuery(TConstArrayView<const UScriptStruct*> InitList);
	FMassEntityQuery(UMassProcessor& Owner);

	void RegisterWithProcessor(UMassProcessor& Owner);

	/** Runs ExecuteFunction on all entities matching Requirements */
	void ForEachEntityChunk(FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext, const FMassExecuteFunction& ExecuteFunction);
	
	/** Will first verify that the archetype given with Collection matches the query's requirements, and if so will run the other, more generic ForEachEntityChunk implementation */
	void ForEachEntityChunk(const FMassArchetypeEntityCollection& EntityCollection, FMassEntityManager& EntitySubsystem
		, FMassExecutionContext& ExecutionContext, const FMassExecuteFunction& ExecuteFunction);

	/**
	 * Attempts to process every chunk of every affected archetype in parallel.
	 */
	void ParallelForEachEntityChunk(FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext
		, const FMassExecuteFunction& ExecuteFunction, const EParallelForMode ParallelMode = Default);

	void ForEachEntityChunkInCollections(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections, FMassEntityManager& EntityManager
		, FMassExecutionContext& ExecutionContext, const FMassExecuteFunction& ExecuteFunction);

	void ParallelForEachEntityChunkInCollection(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections
		, FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext, const FMassExecuteFunction& ExecuteFunction
		, const EParallelForMode ParallelMode);

	/** Will gather all archetypes from InEntityManager matching this->Requirements.
	 *  Note that no work will be done if the cached data is up to date (as tracked by EntitySubsystemHash and 
	 *	ArchetypeDataVersion properties). */
	void CacheArchetypes(const FMassEntityManager& InEntityManager);

	void Clear()
	{
		FMassFragmentRequirements::Reset();
		FMassSubsystemRequirements::Reset();
		DirtyCachedData();
	}

	FORCEINLINE void DirtyCachedData()
	{
		EntitySubsystemHash = 0;
		LastUpdatedArchetypeDataVersion = 0;
	}
	
	bool DoesRequireGameThreadExecution() const 
	{ 
		return FMassFragmentRequirements::DoesRequireGameThreadExecution() 
			|| FMassSubsystemRequirements::DoesRequireGameThreadExecution() 
			|| bRequiresMutatingWorldAccess;
	}

	void RequireMutatingWorldAccess() { bRequiresMutatingWorldAccess = true; }

	bool IsEmpty() const { return FMassFragmentRequirements::IsEmpty() && FMassSubsystemRequirements::IsEmpty(); }

	const TArray<FMassArchetypeHandle>& GetArchetypes() const
	{ 
		return ValidArchetypes; 
	}

	/** 
	 * Goes through ValidArchetypes and sums up the number of entities contained in them.
	 * Note that the function is not const because calling it can result in re-caching of ValidArchetypes 
	 * @return the number of entities this given query would process if called "now"
	 */
	int32 GetNumMatchingEntities(FMassEntityManager& InEntityManager);

	/** 
	 * Sums the entity range lengths for each collection in EntityCollections, where the collection's 
	 * archetype matches the querie's requirements.
	 * @return the number of entities this given query would process if called "now" for EntityCollections
	 */
	int32 GetNumMatchingEntities(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections);

	/**
	 * Checks if any of ValidArchetypes has any entities.
	 * Note that the function is not const because calling it can result in re-caching of ValidArchetypes
	 * @return "true" if any of the ValidArchetypes has any entities, "false" otherwise
	 */
	bool HasMatchingEntities(FMassEntityManager& InEntityManager);

	/** 
	 * Sets a chunk filter condition that will applied to each chunk of all valid archetypes. Note 
	 * that this condition won't be applied when a specific entity colleciton is used (via FMassArchetypeEntityCollection )
	 * The value returned by InFunction controls whether to allow execution (true) or block it (false).
	 */
	void SetChunkFilter(const FMassChunkConditionFunction& InFunction) { checkf(!HasChunkFilter(), TEXT("Chunk filter needs to be cleared before setting a new one.")); ChunkCondition = InFunction; }

	void ClearChunkFilter() { ChunkCondition.Reset(); }

	bool HasChunkFilter() const { return bool(ChunkCondition); }

	/** 
	 * If ArchetypeHandle is among ValidArchetypes then the function retrieves requirements mapping cached for it,
	 * otherwise an empty mapping will be returned (and the requirements binding will be done the slow way).
	 */
	const FMassQueryRequirementIndicesMapping& GetRequirementsMappingForArchetype(const FMassArchetypeHandle ArchetypeHandle) const;

	void ExportRequirements(FMassExecutionRequirements& OutRequirements) const;

	/** 
	 * Controls whether ParallelForEachEntityChunk creates separate command buffers for each job.
	 * @see bAllowParallelCommands for more details
	 */
	void SetParallelCommandBufferEnabled(const bool bInAllowParallelCommands) { bAllowParallelCommands = bInAllowParallelCommands; }

private:
	struct FScopedSubsystemRequirementsRestore
	{
		FScopedSubsystemRequirementsRestore(FMassExecutionContext& ExecutionContext);
		~FScopedSubsystemRequirementsRestore();

		FMassExecutionContext& CachedExecutionContext;
		FMassExternalSubsystemBitSet ConstSubsystemsBitSet;
		FMassExternalSubsystemBitSet MutableSubsystemsBitSet;
	};

	/** 
	 * This function represents a condition that will be called for every chunk to be processed before the actual 
	 * execution function is called. The chunk fragment requirements are already bound and ready to be used by the time 
	 * ChunkCondition is executed.
	 */
	FMassChunkConditionFunction ChunkCondition;

	uint32 EntitySubsystemHash = 0;
	uint32 LastUpdatedArchetypeDataVersion = 0;

	TArray<FMassArchetypeHandle> ValidArchetypes;
	TArray<FMassQueryRequirementIndicesMapping> ArchetypeFragmentMapping;

	/** 
	 * Controls whether ParallelForEachEntityChunk created dedicated command buffer for each job. This is required 
	 * to ensure thread safety. Disable by calling SetParallelCommandBufferEnabled(false) if execution function doesn't 
	 * issue commands. Disabling will save some performance since it will avoid dynamic allocation of command buffers.
	 * 
	 * @Note that disabling parallel commands will result in no command buffer getting passed to execution which in turn
	 *	will cause crashes if the underlying code does try to issue commands. 
	 */
	uint8 bAllowParallelCommands : 1 = true;
	uint8 bRequiresMutatingWorldAccess : 1 = false;

	EMassExecutionContextType ExpectedContextType = EMassExecutionContextType::Local;

#if WITH_MASSENTITY_DEBUG
	uint8 bRegistered : 1;
#endif // WITH_MASSENTITY_DEBUG
};


===========================================


=== MassEntity/Public/MassEntitySettings.h ===
==============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassSettings.h"
#include "MassProcessingPhaseManager.h"
#include "MassProcessor.h"
#include "StructUtils/InstancedStruct.h"
#include "MassEntitySettings.generated.h"


#define GET_MASS_CONFIG_VALUE(a) (GetMutableDefault<UMassEntitySettings>()->a)

struct FPropertyChangedEvent;


/**
 * Implements the settings for MassEntity plugin
 */
UCLASS(config = Mass, defaultconfig, DisplayName = "Mass Entity")
class MASSENTITY_API UMassEntitySettings : public UMassModuleSettings
{
	GENERATED_BODY()
public:
#if WITH_EDITORONLY_DATA
	DECLARE_MULTICAST_DELEGATE_OneParam(FOnSettingsChange, const FPropertyChangedEvent& /*PropertyChangedEvent*/);
#endif // WITH_EDITORONLY_DATA
	DECLARE_MULTICAST_DELEGATE(FOnInitialized);

	UMassEntitySettings(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	void BuildProcessorListAndPhases();
	void AddToActiveProcessorsList(TSubclassOf<UMassProcessor> ProcessorClass);

	TConstArrayView<FMassProcessingPhaseConfig> GetProcessingPhasesConfig();
	const FMassProcessingPhaseConfig& GetProcessingPhaseConfig(const EMassProcessingPhase ProcessingPhase) const { check(ProcessingPhase != EMassProcessingPhase::MAX); return ProcessingPhasesConfig[int(ProcessingPhase)]; }

	static FOnInitialized& GetOnInitializedEvent() { return GET_MASS_CONFIG_VALUE(OnInitializedEvent); }
#if WITH_EDITOR
	FOnSettingsChange& GetOnSettingsChange() { return OnSettingsChange; }

	static bool IsInitialized() { return GET_MASS_CONFIG_VALUE(bInitialized); }

protected:
	virtual void PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent) override;
	virtual void PostEditChangeChainProperty(struct FPropertyChangedChainEvent& PropertyChangedEvent) override;
#endif // WITH_EDITOR

	virtual void PostInitProperties() override;
	virtual void BeginDestroy() override;

	void OnPostEngineInit();
	void BuildPhases();
	void BuildProcessorList();

public:
	UPROPERTY(EditDefaultsOnly, Category = Mass, config, AdvancedDisplay)
	int32 ChunkMemorySize = 128 * 1024;

	/**
	 * The name of the file to dump the processor dependency graph. T
	 * The dot file will be put in the project log folder.
	 * To generate a svg out of that file, simply run dot executable with following parameters: -Tsvg -O filename.dot 
	 */
	UPROPERTY(EditDefaultsOnly, Category = Mass, Transient)
	FString DumpDependencyGraphFileName;

	/** Lets users configure processing phases including the composite processor class to be used as a container for the phases' processors. */
	UPROPERTY(EditDefaultsOnly, Category = Mass, config)
	FMassProcessingPhaseConfig ProcessingPhasesConfig[(uint8)EMassProcessingPhase::MAX];

	/** This list contains all the processors available in the given binary (including plugins). The contents are sorted by display name.*/
	UPROPERTY(VisibleAnywhere, Category = Mass, Transient, Instanced, EditFixedSize)
	TArray<TObjectPtr<UMassProcessor>> ProcessorCDOs;

#if WITH_EDITORONLY_DATA
protected:
	FOnSettingsChange OnSettingsChange;
#endif // WITH_EDITORONLY_DATA
	bool bInitialized = false;
	bool bEngineInitialized = false;

	FOnInitialized OnInitializedEvent;
};

==============================================


=== MassEntity/Public/MassEntitySubsystem.h ===
===============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassSubsystemBase.h"
#include "MassEntityManager.h"
#include "MassEntitySubsystem.generated.h"


/** 
 * The sole responsibility of this world subsystem class is to host the default instance of FMassEntityManager
 * for a given UWorld. All the gameplay-related use cases of Mass (found in MassGameplay and related plugins) 
 * use this by default. 
 */
UCLASS()
class MASSENTITY_API UMassEntitySubsystem : public UMassSubsystemBase
{
	GENERATED_BODY()

	//~USubsystem interface
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void PostInitialize() override;
	virtual void Deinitialize() override;
	//~End of USubsystem interface

public:
	UMassEntitySubsystem();

	//~UObject interface
	virtual void GetResourceSizeEx(FResourceSizeEx& CumulativeResourceSize) override;
	//~End of UObject interface

	const FMassEntityManager& GetEntityManager() const { check(EntityManager); return *EntityManager.Get(); }
	FMassEntityManager& GetMutableEntityManager() { check(EntityManager); return *EntityManager.Get(); }

protected:
	TSharedPtr<FMassEntityManager> EntityManager;
};

===============================================


=== MassEntity/Public/MassEntityTypes.h ===
===========================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "StructUtils/StructTypeBitSet.h"
#include "MassProcessingTypes.h"
#include "StructUtils/StructArrayView.h"
#include "Subsystems/Subsystem.h"
#include "MassExternalSubsystemTraits.h"
#include "StructUtils/SharedStruct.h"
#include "MassEntityTypes.generated.h"
#ifdef WITH_AITESTSUITE
#include "TestableEnsures.h"
#else
#define testableEnsureMsgf ensureMsgf
#define testableCheckf checkf
#define testableCheckfReturn(InExpression, ReturnValue, InFormat, ... ) checkf(InExpression, InFormat, ##__VA_ARGS__)
#endif 


MASSENTITY_API DECLARE_LOG_CATEGORY_EXTERN(LogMass, Warning, All);

DECLARE_STATS_GROUP(TEXT("Mass"), STATGROUP_Mass, STATCAT_Advanced);
DECLARE_CYCLE_STAT_EXTERN(TEXT("Mass Total Frame Time"), STAT_Mass_Total, STATGROUP_Mass, MASSENTITY_API);

// This is the base class for all lightweight fragments
USTRUCT()
struct FMassFragment
{
	GENERATED_BODY()

	FMassFragment() {}
};

// This is the base class for types that will only be tested for presence/absence, i.e. Tags.
// Subclasses should never contain any member properties.
USTRUCT()
struct FMassTag
{
	GENERATED_BODY()

	FMassTag() {}
};

USTRUCT()
struct FMassChunkFragment
{
	GENERATED_BODY()

	FMassChunkFragment() {}
};

USTRUCT()
struct FMassSharedFragment
{
	GENERATED_BODY()

	FMassSharedFragment() {}
};

USTRUCT()
struct FMassConstSharedFragment
{
	GENERATED_BODY()

	FMassConstSharedFragment() {}
};


// A handle to a lightweight entity.  An entity is used in conjunction with the FMassEntityManager
// for the current world and can contain lightweight fragments.
USTRUCT()
struct alignas(8) FMassEntityHandle
{
	GENERATED_BODY()

	FMassEntityHandle() = default;
	FMassEntityHandle(const int32 InIndex, const int32 InSerialNumber)
		: Index(InIndex), SerialNumber(InSerialNumber)
	{
	}
	
	UPROPERTY(VisibleAnywhere, Category = "Mass|Debug", Transient)
	int32 Index = 0;
	
	UPROPERTY(VisibleAnywhere, Category = "Mass|Debug", Transient)
	int32 SerialNumber = 0;

	bool operator==(const FMassEntityHandle Other) const
	{
		return Index == Other.Index && SerialNumber == Other.SerialNumber;
	}

	bool operator!=(const FMassEntityHandle Other) const
	{
		return !operator==(Other);
	}

	/** Has meaning only for sorting purposes */
	bool operator<(const FMassEntityHandle Other) const { return Index < Other.Index; }

	/** Note that this function is merely checking if Index and SerialNumber are set. There's no way to validate if 
	 *  these indicate a valid entity in an EntitySubsystem without asking the system. */
	bool IsSet() const
	{
		return Index != 0 && SerialNumber != 0;
	}

	FORCEINLINE bool IsValid() const
	{
		return IsSet();
	}

	void Reset()
	{
		Index = SerialNumber = 0;
	}

	/** Allows the entity handle to be shared anonymously. */
	uint64 AsNumber() const { return *reinterpret_cast<const uint64*>(this); } // Relying on the fact that this struct only stores 2 integers and is aligned correctly.
	/** Reconstruct the entity handle from an anonymously shared integer. */
	static FMassEntityHandle FromNumber(uint64 Value) 
	{ 
		FMassEntityHandle Result;
		*reinterpret_cast<uint64_t*>(&Result) = Value;
		return Result;
	}

	friend uint32 GetTypeHash(const FMassEntityHandle Entity)
	{
		return HashCombine(Entity.Index, Entity.SerialNumber);
	}

	FString DebugGetDescription() const
	{
		return FString::Printf(TEXT("i: %d sn: %d"), Index, SerialNumber);
	}
};

static_assert(sizeof(FMassEntityHandle) == sizeof(uint64), "Expected FMassEntityHandle to be convertable to a 64-bit integer value, so size needs to be 8 bytes.");
static_assert(alignof(FMassEntityHandle) == sizeof(uint64), "Expected FMassEntityHandle to be convertable to a 64-bit integer value, so alignment needs to be 8 bytes.");

DECLARE_STRUCTTYPEBITSET_EXPORTED(MASSENTITY_API, FMassFragmentBitSet, FMassFragment);
DECLARE_STRUCTTYPEBITSET_EXPORTED(MASSENTITY_API, FMassTagBitSet, FMassTag);
DECLARE_STRUCTTYPEBITSET_EXPORTED(MASSENTITY_API, FMassChunkFragmentBitSet, FMassChunkFragment);
DECLARE_STRUCTTYPEBITSET_EXPORTED(MASSENTITY_API, FMassSharedFragmentBitSet, FMassSharedFragment);
DECLARE_STRUCTTYPEBITSET_EXPORTED(MASSENTITY_API, FMassConstSharedFragmentBitSet, FMassConstSharedFragment);
DECLARE_CLASSTYPEBITSET_EXPORTED(MASSENTITY_API, FMassExternalSubsystemBitSet, USubsystem);

/** The type summarily describing a composition of an entity or an archetype. It contains information on both the
 *  fragments as well as tags */
struct FMassArchetypeCompositionDescriptor
{
	FMassArchetypeCompositionDescriptor() = default;
	FMassArchetypeCompositionDescriptor(const FMassFragmentBitSet& InFragments,
		const FMassTagBitSet& InTags,
		const FMassChunkFragmentBitSet& InChunkFragments,
		const FMassSharedFragmentBitSet& InSharedFragments,
		const FMassConstSharedFragmentBitSet& InConstSharedFragments)
		: Fragments(InFragments)
		, Tags(InTags)
		, ChunkFragments(InChunkFragments)
		, SharedFragments(InSharedFragments)
		, ConstSharedFragments(InConstSharedFragments)
	{}

	FMassArchetypeCompositionDescriptor(TConstArrayView<const UScriptStruct*> InFragments,
		const FMassTagBitSet& InTags,
		const FMassChunkFragmentBitSet& InChunkFragments,
		const FMassSharedFragmentBitSet& InSharedFragments,
		const FMassConstSharedFragmentBitSet& InConstSharedFragments)
		: FMassArchetypeCompositionDescriptor(FMassFragmentBitSet(InFragments), InTags, InChunkFragments, InSharedFragments, InConstSharedFragments)
	{}

	FMassArchetypeCompositionDescriptor(TConstArrayView<FInstancedStruct> InFragmentInstances,
		const FMassTagBitSet& InTags,
		const FMassChunkFragmentBitSet& InChunkFragments,
		const FMassSharedFragmentBitSet& InSharedFragments,
		const FMassConstSharedFragmentBitSet& InConstSharedFragments)
		: FMassArchetypeCompositionDescriptor(FMassFragmentBitSet(InFragmentInstances), InTags, InChunkFragments, InSharedFragments, InConstSharedFragments)
	{}

	FMassArchetypeCompositionDescriptor(FMassFragmentBitSet&& InFragments,
		FMassTagBitSet&& InTags,
		FMassChunkFragmentBitSet&& InChunkFragments,
		FMassSharedFragmentBitSet&& InSharedFragments,
		FMassConstSharedFragmentBitSet&& InConstSharedFragments)
		: Fragments(MoveTemp(InFragments))
		, Tags(MoveTemp(InTags))
		, ChunkFragments(MoveTemp(InChunkFragments))
		, SharedFragments(MoveTemp(InSharedFragments))
		, ConstSharedFragments(MoveTemp(InConstSharedFragments))
	{}

	FMassArchetypeCompositionDescriptor(FMassFragmentBitSet&& InFragments)
		: Fragments(MoveTemp(InFragments))
	{}

	FMassArchetypeCompositionDescriptor(FMassTagBitSet&& InTags)
		: Tags(MoveTemp(InTags))
	{}

	void Reset()
	{
		Fragments.Reset();
		Tags.Reset();
		ChunkFragments.Reset();
		SharedFragments.Reset();
		ConstSharedFragments.Reset();
	}

	bool IsEquivalent(const FMassArchetypeCompositionDescriptor& OtherDescriptor) const
	{
		return Fragments.IsEquivalent(OtherDescriptor.Fragments) &&
			Tags.IsEquivalent(OtherDescriptor.Tags) &&
			ChunkFragments.IsEquivalent(OtherDescriptor.ChunkFragments) &&
			SharedFragments.IsEquivalent(OtherDescriptor.SharedFragments) &&
			ConstSharedFragments.IsEquivalent(OtherDescriptor.ConstSharedFragments);
	}

	bool IsEmpty() const 
	{ 
		return Fragments.IsEmpty() &&
			Tags.IsEmpty() &&
			ChunkFragments.IsEmpty() &&
			SharedFragments.IsEmpty() &&
			ConstSharedFragments.IsEmpty();
	}

	bool HasAll(const FMassArchetypeCompositionDescriptor& OtherDescriptor) const
	{
		return Fragments.HasAll(OtherDescriptor.Fragments) &&
			Tags.HasAll(OtherDescriptor.Tags) &&
			ChunkFragments.HasAll(OtherDescriptor.ChunkFragments) &&
			SharedFragments.HasAll(OtherDescriptor.SharedFragments) &&
			ConstSharedFragments.HasAll(OtherDescriptor.ConstSharedFragments);
	}

	static uint32 CalculateHash(const FMassFragmentBitSet& InFragments, const FMassTagBitSet& InTags
		, const FMassChunkFragmentBitSet& InChunkFragments, const FMassSharedFragmentBitSet& InSharedFragmentBitSet
		, const FMassConstSharedFragmentBitSet& InConstSharedFragmentBitSet)
	{
		const uint32 FragmentsHash = GetTypeHash(InFragments);
		const uint32 TagsHash = GetTypeHash(InTags);
		const uint32 ChunkFragmentsHash = GetTypeHash(InChunkFragments);
		const uint32 SharedFragmentsHash = GetTypeHash(InSharedFragmentBitSet);
		const uint32 ConstSharedFragmentsHash = GetTypeHash(InConstSharedFragmentBitSet);
		return HashCombine(HashCombine(HashCombine(HashCombine(FragmentsHash, TagsHash), ChunkFragmentsHash), SharedFragmentsHash), ConstSharedFragmentsHash);
	}	

	uint32 CalculateHash() const 
	{
		return CalculateHash(Fragments, Tags, ChunkFragments, SharedFragments, ConstSharedFragments);
	}

	int32 CountStoredTypes() const
	{
		return Fragments.CountStoredTypes()
			+ Tags.CountStoredTypes()
			+ ChunkFragments.CountStoredTypes()
			+ SharedFragments.CountStoredTypes()
			+ ConstSharedFragments.CountStoredTypes();
	}

	void DebugOutputDescription(FOutputDevice& Ar) const
	{
#if WITH_MASSENTITY_DEBUG
		if (Fragments.IsEmpty()
			&& Tags.IsEmpty()
			&& ChunkFragments.IsEmpty())
		{
			Ar.Logf(TEXT("Empty"));
			return;
		}

		const bool bAutoLineEnd = Ar.GetAutoEmitLineTerminator();
		Ar.SetAutoEmitLineTerminator(false);

		if (!Fragments.IsEmpty())
		{
			Ar.Logf(TEXT("Fragments:\n"));
			Fragments.DebugGetStringDesc(Ar);
		}

		if (!Tags.IsEmpty())
		{
			Ar.Logf(TEXT("Tags:\n"));
			Tags.DebugGetStringDesc(Ar);
		}

		if (!ChunkFragments.IsEmpty())
		{
			Ar.Logf(TEXT("ChunkFragments:\n"));
			ChunkFragments.DebugGetStringDesc(Ar);
		}

		if (!SharedFragments.IsEmpty())
		{
			Ar.Logf(TEXT("SharedFragments:\n"));
			SharedFragments.DebugGetStringDesc(Ar);
		}

		if (!ConstSharedFragments.IsEmpty())
		{
			Ar.Logf(TEXT("ConstSharedFragments:\n"));
			ConstSharedFragments.DebugGetStringDesc(Ar);
		}

		Ar.SetAutoEmitLineTerminator(bAutoLineEnd);
#endif // WITH_MASSENTITY_DEBUG

	}

	FMassFragmentBitSet Fragments;
	FMassTagBitSet Tags;
	FMassChunkFragmentBitSet ChunkFragments;
	FMassSharedFragmentBitSet SharedFragments;
	FMassConstSharedFragmentBitSet ConstSharedFragments;

	UE_DEPRECATED(5.5, "This FMassArchetypeCompositionDescriptor constructor is deprecated. Please explicitly provide FConstSharedFragmentBitSet.")
	FMassArchetypeCompositionDescriptor(const FMassFragmentBitSet& InFragments, const FMassTagBitSet& InTags, const FMassChunkFragmentBitSet& InChunkFragments, const FMassSharedFragmentBitSet& InSharedFragments)
		: FMassArchetypeCompositionDescriptor(InFragments, InTags, InChunkFragments, InSharedFragments, FMassConstSharedFragmentBitSet())
	{}

	UE_DEPRECATED(5.5, "This FMassArchetypeCompositionDescriptor constructor is deprecated. Please explicitly provide FConstSharedFragmentBitSet.")
	FMassArchetypeCompositionDescriptor(TConstArrayView<const UScriptStruct*> InFragments, const FMassTagBitSet& InTags, const FMassChunkFragmentBitSet& InChunkFragments, const FMassSharedFragmentBitSet& InSharedFragments)
		: FMassArchetypeCompositionDescriptor(FMassFragmentBitSet(InFragments), InTags, InChunkFragments, InSharedFragments, FMassConstSharedFragmentBitSet())
	{}

	UE_DEPRECATED(5.5, "This FMassArchetypeCompositionDescriptor constructor is deprecated. Please explicitly provide FConstSharedFragmentBitSet.")
	FMassArchetypeCompositionDescriptor(TConstArrayView<FInstancedStruct> InFragmentInstances, const FMassTagBitSet& InTags, const FMassChunkFragmentBitSet& InChunkFragments, const FMassSharedFragmentBitSet& InSharedFragments)
		: FMassArchetypeCompositionDescriptor(FMassFragmentBitSet(InFragmentInstances), InTags, InChunkFragments, InSharedFragments, FMassConstSharedFragmentBitSet())
	{}

	UE_DEPRECATED(5.5, "This FMassArchetypeCompositionDescriptor constructor is deprecated. Please explicitly provide FConstSharedFragmentBitSet.")
	FMassArchetypeCompositionDescriptor(FMassFragmentBitSet&& InFragments, FMassTagBitSet&& InTags, FMassChunkFragmentBitSet&& InChunkFragments, FMassSharedFragmentBitSet&& InSharedFragments)
	{
		ensureMsgf(false, TEXT("This constructor is defunct. Please update your implementation based on deprecation warning."));
	}
};

/** 
 * Wrapper for const and non-const shared fragment containers that tracks which struct types it holds (via a FMassSharedFragmentBitSet).
 * Note that having multiple instanced of a given struct type is not supported and Add* functions will fetch the previously 
 * added fragment instead of adding a new one.
 */
struct MASSENTITY_API FMassArchetypeSharedFragmentValues
{
	FMassArchetypeSharedFragmentValues() = default;
	FMassArchetypeSharedFragmentValues(const FMassArchetypeSharedFragmentValues& OtherFragmentValues) = default;
	FMassArchetypeSharedFragmentValues(FMassArchetypeSharedFragmentValues&& OtherFragmentValues) = default;
	FMassArchetypeSharedFragmentValues& operator=(const FMassArchetypeSharedFragmentValues& OtherFragmentValues) = default;
	FMassArchetypeSharedFragmentValues& operator=(FMassArchetypeSharedFragmentValues&& OtherFragmentValues) = default;

	FORCEINLINE bool HasExactFragmentTypesMatch(const FMassSharedFragmentBitSet& InSharedFragmentBitSet, const FMassConstSharedFragmentBitSet& InConstSharedFragmentBitSet) const
	{
		return HasExactSharedFragmentTypesMatch(InSharedFragmentBitSet)
			&& HasExactConstSharedFragmentTypesMatch(InConstSharedFragmentBitSet);
	}

	FORCEINLINE bool HasExactSharedFragmentTypesMatch(const FMassSharedFragmentBitSet& InSharedFragmentBitSet) const
	{
		return SharedFragmentBitSet.IsEquivalent(InSharedFragmentBitSet);
	}

	FORCEINLINE bool HasAllRequiredSharedFragmentTypes(const FMassSharedFragmentBitSet& InSharedFragmentBitSet) const
	{
		return SharedFragmentBitSet.HasAll(InSharedFragmentBitSet);
	}

	FORCEINLINE bool HasExactConstSharedFragmentTypesMatch(const FMassConstSharedFragmentBitSet& InConstSharedFragmentBitSet) const
	{
		return ConstSharedFragmentBitSet.IsEquivalent(InConstSharedFragmentBitSet);
	}

	FORCEINLINE bool HasAllRequiredConstSharedFragmentTypes(const FMassConstSharedFragmentBitSet& InConstSharedFragmentBitSet) const
	{
		return ConstSharedFragmentBitSet.HasAll(InConstSharedFragmentBitSet);
	}

	FORCEINLINE bool IsEquivalent(const FMassArchetypeSharedFragmentValues& OtherSharedFragmentValues) const
	{
		return GetTypeHash(*this) == GetTypeHash(OtherSharedFragmentValues);
	}

	/** 
	 * Compares contents of `this` and the Other, and allows different order of elements in both containers.
	 * Note that the function ignores "nulls", i.e. empty FConstSharedStruct and FSharedStruct instances. The function
	 * does care however about matching "mode", meaning ConstSharedFragments and SharedFragments arrays are compared
	 * independently.
	 */
	bool HasSameValues(const FMassArchetypeSharedFragmentValues& Other) const;

	FORCEINLINE bool ContainsType(const UScriptStruct* FragmentType) const
	{
		if (FragmentType)
		{
			if (FragmentType->IsChildOf(FMassSharedFragment::StaticStruct()))
			{
				return SharedFragmentBitSet.Contains(*FragmentType);
			}

			if (FragmentType->IsChildOf(FMassConstSharedFragment::StaticStruct()))
			{
				return ConstSharedFragmentBitSet.Contains(*FragmentType);
			}
		}

		return false;
	}

	template<typename T>
	FORCEINLINE bool ContainsType() const
	{
		if constexpr (TIsDerivedFrom<T, FMassConstSharedFragment>::IsDerived)
		{
			return ConstSharedFragmentBitSet.Contains(*T::StaticStruct());
		}
		else if constexpr (TIsDerivedFrom<T, FMassSharedFragment>::IsDerived)
		{
			return SharedFragmentBitSet.Contains(*T::StaticStruct());
		}
		else
		{
			return false;
		}
	}

	/** 
	 * Adds Fragment to the collection. If a fragment of the given FMassSharedFragment subclass has already added then 
	 * the function will return the previously added instance. In that case the function will also assert if the given type 
	 * has been added as a CONST shared fragment and if not it will return an empty FConstSharedStruct
	 */
	FConstSharedStruct AddConstSharedFragment(const FConstSharedStruct& Fragment);

	/**
	 * Adds Fragment to the collection. If a fragment of the given FMassSharedFragment subclass has already added then
	 * the function will return the previously added instance. In that case the function will also assert if the given type
	 * has been added as a NON-CONST shared fragment and if not it will return an empty FSharedStruct
	 */
	FSharedStruct AddSharedFragment(const FSharedStruct& Fragment);

	/**
	 * Finds instances of fragment types given by Fragments and replaces their values with contents of respective
	 * element of Fragments.
	 * Note that it's callers responsibility to ensure every fragment type in Fragments already has an instance in
	 * this FMassArchetypeSharedFragmentValues instance. Failing that assumption will result in ensure failure. 
	 */
	void ReplaceSharedFragments(TConstArrayView<FSharedStruct> Fragments);

	/** 
	 * Appends contents of Other to `this` instance. All common fragments will get overridden with values in Other.
	 * Note that changing a fragments "role" (being const or non-const) is not supported and the function will fail an
	 * ensure when that is attempted.
	 * @return number of fragments added or changed
	 */
	int32 Append(const FMassArchetypeSharedFragmentValues& Other);

	/** 
	 * Note that the function removes the shared fragments by type
	 * @return number of fragments types removed
	 */
	int32 Remove(const FMassSharedFragmentBitSet& SharedFragmentToRemoveBitSet);

	/** 
	 * Note that the function removes the const shared fragments by type
	 * @return number of fragments types removed
	 */
	int32 Remove(const FMassConstSharedFragmentBitSet& ConstSharedFragmentToRemoveBitSet);

	FORCEINLINE const TArray<FConstSharedStruct>& GetConstSharedFragments() const
	{
		return ConstSharedFragments;
	}

	FORCEINLINE TArray<FSharedStruct>& GetMutableSharedFragments()
	{
		return SharedFragments;
	}
	
	FORCEINLINE const TArray<FSharedStruct>& GetSharedFragments() const
	{
		return SharedFragments;
	}
	
	FConstSharedStruct GetConstSharedFragmentStruct(const UScriptStruct* StructType) const
	{
		const int32 FragmentIndex = ConstSharedFragments.IndexOfByPredicate(FStructTypeEqualOperator(StructType));
		return FragmentIndex != INDEX_NONE ? ConstSharedFragments[FragmentIndex] : FConstSharedStruct();
	}
		
	FSharedStruct GetSharedFragmentStruct(const UScriptStruct* StructType)
	{
		const int32 FragmentIndex = SharedFragments.IndexOfByPredicate(FStructTypeEqualOperator(StructType));
		return FragmentIndex != INDEX_NONE ? SharedFragments[FragmentIndex] : FSharedStruct();
	}

	const FMassSharedFragmentBitSet& GetSharedFragmentBitSet() const
	{
		return SharedFragmentBitSet;
	}

	const FMassConstSharedFragmentBitSet& GetConstSharedFragmentBitSet() const
	{
		return ConstSharedFragmentBitSet;
	}

	FORCEINLINE void DirtyHashCache()
	{
		HashCache = UINT32_MAX;
		// we consider a single shared fragment as being "sorted"
		bSorted = (SharedFragments.Num() + ConstSharedFragments.Num() <= 1) ;
	}

	FORCEINLINE void CacheHash() const
	{
		if (HashCache == UINT32_MAX)
		{
			HashCache = CalculateHash();
		}
	}

	friend FORCEINLINE uint32 GetTypeHash(const FMassArchetypeSharedFragmentValues& SharedFragmentValues)
	{
		SharedFragmentValues.CacheHash();
		return SharedFragmentValues.HashCache;
	}

	uint32 CalculateHash() const;

	SIZE_T GetAllocatedSize() const
	{
		return ConstSharedFragments.GetAllocatedSize() + SharedFragments.GetAllocatedSize();
	}

	void Sort()
	{
		if(!bSorted)
		{
			ConstSharedFragments.Sort(FStructTypeSortOperator());
			SharedFragments.Sort(FStructTypeSortOperator());
			bSorted = true;
		}
	}

	bool IsSorted() const { return bSorted; }

protected:
	mutable uint32 HashCache = UINT32_MAX;
	/**
	 * We consider empty FMassArchetypeSharedFragmentValues a sorted containter.Same goes for a container containing
	 * a single element, @see DirtyHashCache
	 */ 
	mutable bool bSorted = true; 
	
	FMassSharedFragmentBitSet SharedFragmentBitSet;
	FMassConstSharedFragmentBitSet ConstSharedFragmentBitSet;
	TArray<FConstSharedStruct> ConstSharedFragments;
	TArray<FSharedStruct> SharedFragments;

public:
	//-----------------------------------------------------------------------------
	// DEPRECATED
	//-----------------------------------------------------------------------------
	UE_DEPRECATED(5.5, "HasExactFragmentTypesMatch is deprecated. Use HasExactSharedFragmentTypesMatch or the two-parameter version of HasExactFragmentTypesMatch.")
	FORCEINLINE bool HasExactFragmentTypesMatch(const FMassSharedFragmentBitSet& InSharedFragmentBitSet) const
	{
		return HasExactSharedFragmentTypesMatch(InSharedFragmentBitSet);
	}
};

UENUM()
enum class EMassObservedOperation : uint8
{
	Add,
	Remove,
	// @todo Keeping this here as a indication of design intent. For now we handle entity destruction like removal, but 
	// there might be computationally expensive cases where we might want to avoid for soon-to-be-dead entities. 
	// Destroy,
	// @todo another planned supported operation type
	// Touch,
	MAX
};

enum class EMassExecutionContextType : uint8
{
	Local,
	Processor,
	MAX
};

/** 
 * Note that this is a view and is valid only as long as the source data is valid. Used when flushing mass commands to
 * wrap different kinds of data into a uniform package so that it can be passed over to a common interface.
 */
struct FMassGenericPayloadView
{
	FMassGenericPayloadView() = default;
	FMassGenericPayloadView(TArray<FStructArrayView>&SourceData)
		: Content(SourceData)
	{}
	FMassGenericPayloadView(TArrayView<FStructArrayView> SourceData)
		: Content(SourceData)
	{}

	int32 Num() const { return Content.Num(); }

	void Reset()
	{
		Content = TArrayView<FStructArrayView>();
	}

	FORCEINLINE void Swap(const int32 A, const int32 B)
	{
		for (FStructArrayView& View : Content)
		{
			View.Swap(A, B);
		}
	}

	/** Moves NumToMove elements to the back of the viewed collection. */
	void SwapElementsToEnd(int32 StartIndex, int32 NumToMove);

	TArrayView<FStructArrayView> Content;
};

/**
 * Used to indicate a specific slice of a preexisting FMassGenericPayloadView, it's essentially an access pattern
 * Note: accessing content generates copies of FStructArrayViews stored (still cheap, those are just views). 
 */
struct FMassGenericPayloadViewSlice
{
	FMassGenericPayloadViewSlice() = default;
	FMassGenericPayloadViewSlice(const FMassGenericPayloadView& InSource, const int32 InStartIndex, const int32 InCount)
		: Source(InSource), StartIndex(InStartIndex), Count(InCount)
	{
	}

	FStructArrayView operator[](const int32 Index) const
	{
		return Source.Content[Index].Slice(StartIndex, Count);
	}

	/** @return the number of "layers" (i.e. number of original arrays) this payload has been built from */
	int32 Num() const 
	{
		return Source.Num();
	}

	bool IsEmpty() const
	{
		return !(Source.Num() > 0 && Count > 0);
	}

private:
	FMassGenericPayloadView Source;
	const int32 StartIndex = 0;
	const int32 Count = 0;
};

namespace UE::Mass
{
	/**
	 * A statically-typed list of of related types. Used mainly to differentiate type collections at compile-type as well as
	 * efficiently produce TStructTypeBitSet representing given collection.
	 */
	template<typename T, typename... TOthers>
	struct TMultiTypeList : TMultiTypeList<TOthers...>
	{
		using Super = TMultiTypeList<TOthers...>;
		using FType = std::remove_const_t<typename TRemoveReference<T>::Type>;
		enum
		{
			Ordinal = Super::Ordinal + 1
		};

		template<typename TBitSetType>
		constexpr static void PopulateBitSet(TBitSetType& OutBitSet)
		{
			Super::PopulateBitSet(OutBitSet);
			OutBitSet += TBitSetType::template GetTypeBitSet<FType>();
		}
	};
		
	/** Single-type specialization of TMultiTypeList. */
	template<typename T>
	struct TMultiTypeList<T>
	{
		using FType = std::remove_const_t<typename TRemoveReference<T>::Type>;
		enum
		{
			Ordinal = 0
		};

		template<typename TBitSetType>
		constexpr static void PopulateBitSet(TBitSetType& OutBitSet)
		{
			OutBitSet += TBitSetType::template GetTypeBitSet<FType>();
		}
	};

	/** 
	 * The type hosts a statically-typed collection of TArrays, where each TArray is strongly-typed (i.e. it contains 
	 * instances of given structs rather than structs wrapped up in FInstancedStruct). This type lets us do batched 
	 * fragment values setting by simply copying data rather than setting per-instance. 
	 */
	template<typename T, typename... TOthers>
	struct TMultiArray : TMultiArray<TOthers...>
	{
		using FType = std::remove_const_t<typename TRemoveReference<T>::Type>;
		using Super = TMultiArray<TOthers...>;

		enum
		{
			Ordinal = Super::Ordinal + 1
		};

		SIZE_T GetAllocatedSize() const
		{
			return FragmentInstances.GetAllocatedSize() + Super::GetAllocatedSize();
		}

		int GetNumArrays() const { return Ordinal + 1; }

		void Add(const FType& Item, TOthers... Rest)
		{
			FragmentInstances.Add(Item);
			Super::Add(Rest...);
		}

		void GetAsGenericMultiArray(TArray<FStructArrayView>& A) /*const*/
		{
			Super::GetAsGenericMultiArray(A);
			A.Add(FStructArrayView(FragmentInstances));
		}

		void GetheredAffectedFragments(FMassFragmentBitSet& OutBitSet) const
		{
			Super::GetheredAffectedFragments(OutBitSet);
			OutBitSet += FMassFragmentBitSet::GetTypeBitSet<FType>();
		}

		void Reset()
		{
			Super::Reset();
			FragmentInstances.Reset();
		}

		TArray<FType> FragmentInstances;
	};

	/**TMultiArray simple-type specialization */
	template<typename T>
	struct TMultiArray<T>
	{
		using FType = std::remove_const_t<typename TRemoveReference<T>::Type>;
		enum { Ordinal = 0 };

		SIZE_T GetAllocatedSize() const
		{
			return FragmentInstances.GetAllocatedSize();
		}

		int GetNumArrays() const { return Ordinal + 1; }

		void Add(const FType& Item) { FragmentInstances.Add(Item); }

		void GetAsGenericMultiArray(TArray<FStructArrayView>& A) /*const*/
		{
			A.Add(FStructArrayView(FragmentInstances));
		}

		void GetheredAffectedFragments(FMassFragmentBitSet& OutBitSet) const
		{
			OutBitSet += FMassFragmentBitSet::GetTypeBitSet<FType>();
		}

		void Reset()
		{
			FragmentInstances.Reset();
		}

		TArray<FType> FragmentInstances;
	};

} // UE::Mass


struct FMassArchetypeCreationParams
{
	FMassArchetypeCreationParams() = default;
	explicit FMassArchetypeCreationParams(const struct FMassArchetypeData& Archetype);

	/** Created archetype will have chunks of this size. 0 denotes "use default" (see UE::Mass::ChunkSize) */
	int32 ChunkMemorySize = 0;

	/** Name to identify the archetype while debugging*/
	FName DebugName;
};

===========================================


=== MassEntity/Public/MassEntityUtils.h ===
===========================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassProcessingTypes.h"
#include "MassArchetypeTypes.h"

class UWorld;
struct FMassEntityManager;
struct FMassEntityHandle;

namespace UE::Mass::Utils
{

/** returns the current execution mode for the processors calculated from the world network mode */
MASSENTITY_API extern EProcessorExecutionFlags GetProcessorExecutionFlagsForWorld(const UWorld& World);

/** based on the given World (which can be null) and 'ExecutionFlagsOverride', the function determines the execution flags to use */
MASSENTITY_API extern EProcessorExecutionFlags DetermineProcessorExecutionFlags(const UWorld* World, EProcessorExecutionFlags ExecutionFlagsOverride = EProcessorExecutionFlags::None);

/** based on the given World (which can be null), the function determines additional level tick types for the processing phases */
uint8 DetermineProcessorSupportedTickTypes(const UWorld* World);

UE_DEPRECATED(5.3, "This function is deprecated. Please use the properly spelled GetProcessorExecutionFlagsForWorld instead.")
FORCEINLINE EProcessorExecutionFlags GetProcessorExecutionFlagsForWold(const UWorld& World)
{
	return GetProcessorExecutionFlagsForWorld(World);
}

/** 
 * Fills OutEntityCollections with per-archetype FMassArchetypeEntityCollection instances. 
 * @param DuplicatesHandling used to inform the function whether to expect duplicates.
 */
MASSENTITY_API extern void CreateEntityCollections(const FMassEntityManager& EntitySubsystem, const TConstArrayView<FMassEntityHandle> Entities
	, const FMassArchetypeEntityCollection::EDuplicatesHandling DuplicatesHandling, TArray<FMassArchetypeEntityCollection>& OutEntityCollections);

/**
* AbstractSort is a sorting function that only needs to know how many items there are, how to compare items
* at individual locations - where location is in [0, NumElements) - and how to swap two elements at given locations.
* The main use case is to sort multiple arrays while keeping them in sync. For example:
*
* TArray<float> Lead = { 3.1, 0.2, 2.6, 1.0 };
* TArray<UObject*> Payload = { A, B, C, D };
*
* AbstractSort(Lead.Num()											// NumElements
* 	, [&Lead](const int32 LHS, const int32 RHS)					// Predicate
*		{
*			return Lead[LHS] < Lead[RHS];
*		}
* 	, [&Lead, &Payload](const int32 A, const int32 B)			// SwapFunctor
*	 	{
*			Swap(Lead[A], Lead[B]);
* 			Swap(Payload[A], Payload[B]);
*		}
* );
*/
template<typename TPred, typename TSwap>
inline void AbstractSort(const int32 NumElements, TPred&& Predicate, TSwap&& SwapFunctor)
{
	if (NumElements == 0)
	{
		return;
	}

	TArray<int32> Indices;
	Indices.AddUninitialized(NumElements);
	int i = 0;
	do
	{
		Indices[i] = i;
	} while (++i < NumElements);

	Indices.Sort(Predicate);

	for (i = 0; i < NumElements; ++i)
	{
		int32 SwapFromIndex = Indices[i];
		while (SwapFromIndex < i)
		{
			SwapFromIndex = Indices[SwapFromIndex];
		}

		if (SwapFromIndex != i)
		{
			SwapFunctor(i, SwapFromIndex);
		}
	}
}

MASSENTITY_API extern FMassEntityManager* GetEntityManager(const UWorld* World);
MASSENTITY_API extern FMassEntityManager& GetEntityManagerChecked(const UWorld& World);

} // namespace UE::Mass::Utils


===========================================


=== MassEntity/Public/MassEntityView.h ===
==========================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassArchetypeTypes.h"
#include "StructUtils/InstancedStruct.h"
#include "MassEntityView.generated.h"


struct FMassEntityManager;
struct FMassArchetypeData;
struct FMassArchetypeHandle;

/** 
 * The type representing a single entity in a single archetype. It's of a very transient nature so we guarantee it's 
 * validity only within the scope it has been created in. Don't store it. 
 */
USTRUCT()
struct MASSENTITY_API FMassEntityView
{
	GENERATED_BODY()

	FMassEntityView() = default;

	/** 
	 *  Resolves Entity against ArchetypeHandle. Note that this approach requires the caller to ensure that Entity
	 *  indeed belongs to ArchetypeHandle. If not the call will fail a check. As a remedy calling the 
	 *  FMassEntityManager-flavored constructor is recommended since it will first find the appropriate archetype for
	 *  Entity. 
	 */
	FMassEntityView(const FMassArchetypeHandle& ArchetypeHandle, FMassEntityHandle Entity);

	/** 
	 *  Finds the archetype Entity belongs to and then resolves against it. The caller is responsible for ensuring
	 *  that the given Entity is in fact a valid ID tied to any of the archetypes 
	 */
	FMassEntityView(const FMassEntityManager& EntityManager, FMassEntityHandle Entity);

	/** 
	 * If the given handle represents a valid entity the function will create a FMassEntityView just like a constructor 
	 * would. If the entity is not valid the produced view will be "unset".
	 */
	static FMassEntityView TryMakeView(const FMassEntityManager& EntityManager, FMassEntityHandle Entity);

	FMassEntityHandle GetEntity() const	{ return Entity; }

	/** will fail a check if the viewed entity doesn't have the given fragment */	
	template<typename T>
	T& GetFragmentData() const
	{
		static_assert(!std::is_base_of_v<FMassTag, T>,
			"Given struct doesn't represent a valid fragment type but a tag. Use HasTag instead.");
		static_assert(std::is_base_of_v<FMassTag, T> || std::is_base_of_v<FMassFragment, T>,
			"Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.");

		return *((T*)GetFragmentPtrChecked(*T::StaticStruct()));
	}
		
	/** if the viewed entity doesn't have the given fragment the function will return null */
	template<typename T>
	T* GetFragmentDataPtr() const
	{
		static_assert(!std::is_base_of_v<FMassTag, T>,
			"Given struct doesn't represent a valid fragment type but a tag. Use HasTag instead.");
		static_assert(std::is_base_of_v<FMassTag, T> || std::is_base_of_v<FMassFragment, T>,
			"Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.");

		return (T*)GetFragmentPtr(*T::StaticStruct());
	}

	FStructView GetFragmentDataStruct(const UScriptStruct* FragmentType) const
	{
		check(FragmentType);
		return FStructView(FragmentType, static_cast<uint8*>(GetFragmentPtr(*FragmentType)));
	}

	/** if the viewed entity doesn't have the given const shared fragment the function will return null */
	template<typename T>
	const T* GetConstSharedFragmentDataPtr() const
	{
		static_assert(std::is_base_of_v<FMassConstSharedFragment, T>,
			"Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.");

		return (const T*)GetConstSharedFragmentPtr(*T::StaticStruct());
	}

	/** will fail a check if the viewed entity doesn't have the given const shared fragment */
	template<typename T>
	const T& GetConstSharedFragmentData() const
	{
		static_assert(std::is_base_of_v<FMassConstSharedFragment, T>,
			"Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.");

		return *((const T*)GetConstSharedFragmentPtrChecked(*T::StaticStruct()));
	}

	FConstStructView GetConstSharedFragmentDataStruct(const UScriptStruct* FragmentType) const
	{
		check(FragmentType && FragmentType->IsChildOf(FMassConstSharedFragment::StaticStruct()));
		return FConstStructView(FragmentType, static_cast<const uint8*>(GetConstSharedFragmentPtr(*FragmentType)));
	}

	/** will fail a check if the viewed entity doesn't have the given shared fragment */
	template<typename T UE_REQUIRES(std::is_base_of_v<FMassSharedFragment, T>)>
	T& GetSharedFragmentData() const
	{
		return *((T*)GetSharedFragmentPtrChecked(*T::StaticStruct()));
	}

	/** if the viewed entity doesn't have the given shared fragment the function will return null */
	template<typename T UE_REQUIRES(std::is_base_of_v<FMassSharedFragment, T>)>
	T* GetSharedFragmentDataPtr() const
	{
		return (T*)GetSharedFragmentPtr(*T::StaticStruct());
	}

	template<typename T UE_REQUIRES(std::is_base_of_v<FMassConstSharedFragment, T>)>
	UE_DEPRECATED(5.5, "Using GetSharedFragmentDataPtr with const shared fragments is deprecated. Use GetConstSharedFragmentDataPtr instead")
	T* GetSharedFragmentDataPtr() const
	{
		return const_cast<T*>(GetConstSharedFragmentDataPtr<T>());
	}

	template<typename T UE_REQUIRES(std::is_base_of_v<FMassConstSharedFragment, T>)>
	UE_DEPRECATED(5.5, "Using GetSharedFragmentDataPtr with const shared fragments is deprecated. Use GetConstSharedFragmentData instead")
	T& GetSharedFragmentData() const
	{
		/*static T DummyInstance;
		return DummyInstance;*/
		return const_cast<T&>(GetConstSharedFragmentData<T>());
	}

	FStructView GetSharedFragmentDataStruct(const UScriptStruct* FragmentType) const
	{
		check(FragmentType && FragmentType->IsChildOf(FMassSharedFragment::StaticStruct()));
		return FStructView(FragmentType, static_cast<uint8*>(GetSharedFragmentPtr(*FragmentType)));
	}

	template<typename T>
	bool HasTag() const
	{
		static_assert(std::is_base_of_v<FMassTag, T>, "Given struct doesn't represent a valid tag type. Make sure to inherit from FMassTag or one of its child-types.");
		return HasTag(*T::StaticStruct());
	}

	bool HasTag(const UScriptStruct& TagType) const;

	bool IsSet() const { return Archetype != nullptr && EntityDataHandle.IsValid(); }
	bool IsValid() const { return IsSet(); }
	bool operator==(const FMassEntityView& Other) const { return Archetype == Other.Archetype && EntityDataHandle == Other.EntityDataHandle; }

protected:
	void* GetFragmentPtr(const UScriptStruct& FragmentType) const;
	void* GetFragmentPtrChecked(const UScriptStruct& FragmentType) const;
	const void* GetConstSharedFragmentPtr(const UScriptStruct& FragmentType) const;
	const void* GetConstSharedFragmentPtrChecked(const UScriptStruct& FragmentType) const;
	void* GetSharedFragmentPtr(const UScriptStruct& FragmentType) const;
	void* GetSharedFragmentPtrChecked(const UScriptStruct& FragmentType) const;

private:
	FMassEntityHandle Entity;
	FMassRawEntityInChunkData EntityDataHandle;
	FMassArchetypeData* Archetype = nullptr;
};

==========================================


=== MassEntity/Public/MassExecutionContext.h ===
================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "MassExternalSubsystemTraits.h"
#include "MassEntityQuery.h"
#include "MassSubsystemAccess.h"


#define CHECK_IF_VALID(View, Type) \
	checkf(View \
		, TEXT("Requested fragment type not bound, type %s. Make sure it has been listed as required."), *GetNameSafe(Type))

#define CHECK_IF_READWRITE(View) \
	checkf(View == nullptr || View->Requirement.AccessMode == EMassFragmentAccess::ReadWrite \
		, TEXT("Requested fragment type not bound for writing, type %s. Make sure it has been listed as required in ReadWrite mode.") \
		, View ? *GetNameSafe(View->Requirement.StructType) : TEXT("[Not found]"))


struct MASSENTITY_API FMassExecutionContext
{
private:

	template< typename ViewType >
	struct TFragmentView 
	{
		FMassFragmentRequirementDescription Requirement;
		ViewType FragmentView;

		TFragmentView() {}
		explicit TFragmentView(const FMassFragmentRequirementDescription& InRequirement) : Requirement(InRequirement) {}

		bool operator==(const UScriptStruct* FragmentType) const { return Requirement.StructType == FragmentType; }
	};
	using FFragmentView = TFragmentView<TArrayView<FMassFragment>>;
	TArray<FFragmentView, TInlineAllocator<8>> FragmentViews;

	using FChunkFragmentView = TFragmentView<FStructView>;
	TArray<FChunkFragmentView, TInlineAllocator<4>> ChunkFragmentViews;

	using FConstSharedFragmentView = TFragmentView<FConstStructView>;
	TArray<FConstSharedFragmentView, TInlineAllocator<4>> ConstSharedFragmentViews;

	using FSharedFragmentView = TFragmentView<FStructView>;
	TArray<FSharedFragmentView, TInlineAllocator<4>> SharedFragmentViews;

	FMassSubsystemAccess SubsystemAccess;
	
	// mz@todo make this shared ptr thread-safe and never auto-flush in MT environment. 
	TSharedPtr<FMassCommandBuffer> DeferredCommandBuffer;
	TArrayView<FMassEntityHandle> EntityListView;
	
	/** If set this indicates the exact archetype and its chunks to be processed. 
	 *  @todo this data should live somewhere else, preferably be just a parameter to Query.ForEachEntityChunk function */
	FMassArchetypeEntityCollection EntityCollection;
	
	/** @todo rename to "payload" */
	FInstancedStruct AuxData;
	float DeltaTimeSeconds = 0.0f;
	int32 ChunkSerialModificationNumber = -1;
	FMassArchetypeCompositionDescriptor CurrentArchetypeCompositionDescriptor;

	TSharedRef<FMassEntityManager> EntityManager;

#if WITH_MASSENTITY_DEBUG
	FString DebugExecutionDescription;
#endif
	
	/** Used to control when the context is allowed to flush commands collected in DeferredCommandBuffer. This mechanism 
	 * is mainly utilized to avoid numerous small flushes in favor of fewer larger ones. */
	bool bFlushDeferredCommands = true;

	TArrayView<FFragmentView> GetMutableRequirements() { return FragmentViews; }
	TArrayView<FChunkFragmentView> GetMutableChunkRequirements() { return ChunkFragmentViews; }
	TArrayView<FConstSharedFragmentView> GetMutableConstSharedRequirements() { return ConstSharedFragmentViews; }
	TArrayView<FSharedFragmentView> GetMutableSharedRequirements() { return SharedFragmentViews; }

	void GetSubsystemRequirementBits(FMassExternalSubsystemBitSet& OutConstSubsystemsBitSet, FMassExternalSubsystemBitSet& OutMutableSubsystemsBitSet)
	{
		SubsystemAccess.GetSubsystemRequirementBits(OutConstSubsystemsBitSet, OutMutableSubsystemsBitSet);
	}

	void SetSubsystemRequirementBits(const FMassExternalSubsystemBitSet& InConstSubsystemsBitSet, const FMassExternalSubsystemBitSet& InMutableSubsystemsBitSet)
	{
		SubsystemAccess.SetSubsystemRequirementBits(InConstSubsystemsBitSet, InMutableSubsystemsBitSet);
	}

	EMassExecutionContextType ExecutionType = EMassExecutionContextType::Local;

	friend FMassArchetypeData;
	friend FMassEntityQuery;

public:
	explicit FMassExecutionContext(FMassEntityManager& InEntityManager, const float InDeltaTimeSeconds = 0.f, const bool bInFlushDeferredCommands = true);

	FMassEntityManager& GetEntityManagerChecked() { return EntityManager.Get(); }

#if WITH_MASSENTITY_DEBUG
	const FString& DebugGetExecutionDesc() const { return DebugExecutionDescription; }
	void DebugSetExecutionDesc(const FString& Description) { DebugExecutionDescription = Description; }
#endif

	/** Sets bFlushDeferredCommands. Note that setting to True while the system is being executed doesn't result in
	 *  immediate commands flushing */
	void SetFlushDeferredCommands(const bool bNewFlushDeferredCommands) { bFlushDeferredCommands = bNewFlushDeferredCommands; } 
	void SetDeferredCommandBuffer(const TSharedPtr<FMassCommandBuffer>& InDeferredCommandBuffer) { DeferredCommandBuffer = InDeferredCommandBuffer; }
	void SetEntityCollection(const FMassArchetypeEntityCollection& InEntityCollection);
	void SetEntityCollection(FMassArchetypeEntityCollection&& InEntityCollection);
	void ClearEntityCollection() { EntityCollection.Reset(); }
	void SetAuxData(const FInstancedStruct& InAuxData) { AuxData = InAuxData; }
	void SetExecutionType(EMassExecutionContextType InExecutionType) { check(InExecutionType != EMassExecutionContextType::MAX); ExecutionType = InExecutionType; }

	float GetDeltaTimeSeconds() const
	{
		return DeltaTimeSeconds;
	}

	UWorld* GetWorld();

	TSharedPtr<FMassCommandBuffer> GetSharedDeferredCommandBuffer() const { return DeferredCommandBuffer; }
	FMassCommandBuffer& Defer() const { checkSlow(DeferredCommandBuffer.IsValid()); return *DeferredCommandBuffer.Get(); }

	TConstArrayView<FMassEntityHandle> GetEntities() const { return EntityListView; }
	int32 GetNumEntities() const { return EntityListView.Num(); }

	FMassEntityHandle GetEntity(const int32 Index) const
	{
		return EntityListView[Index];
	}

	bool DoesArchetypeHaveFragment(const UScriptStruct& FragmentType) const
	{
		return CurrentArchetypeCompositionDescriptor.Fragments.Contains(FragmentType);
	}

	template<typename T>
	bool DoesArchetypeHaveFragment() const
	{
		static_assert(TIsDerivedFrom<T, FMassFragment>::IsDerived, "Given struct is not of a valid fragment type.");
		return CurrentArchetypeCompositionDescriptor.Fragments.Contains<T>();
	}

	bool DoesArchetypeHaveTag(const UScriptStruct& TagType) const
	{
		return CurrentArchetypeCompositionDescriptor.Tags.Contains(TagType);
	}

	template<typename T>
	bool DoesArchetypeHaveTag() const
	{
		static_assert(TIsDerivedFrom<T, FMassTag>::IsDerived, "Given struct is not of a valid tag type.");
		return CurrentArchetypeCompositionDescriptor.Tags.Contains<T>();
	}

	/** Chunk related operations */
	void SetCurrentChunkSerialModificationNumber(const int32 SerialModificationNumber) { ChunkSerialModificationNumber = SerialModificationNumber; }
	int32 GetChunkSerialModificationNumber() const { return ChunkSerialModificationNumber; }

	template<typename T>
	T* GetMutableChunkFragmentPtr()
	{
		static_assert(TIsDerivedFrom<T, FMassChunkFragment>::IsDerived, "Given struct doesn't represent a valid chunk fragment type. Make sure to inherit from FMassChunkFragment or one of its child-types.");

		const UScriptStruct* Type = T::StaticStruct();
		FChunkFragmentView* FoundChunkFragmentData = ChunkFragmentViews.FindByPredicate([Type](const FChunkFragmentView& Element) { return Element.Requirement.StructType == Type; } );
		CHECK_IF_READWRITE(FoundChunkFragmentData);
		return FoundChunkFragmentData ? FoundChunkFragmentData->FragmentView.GetPtr<T>() : static_cast<T*>(nullptr);
	}
	
	template<typename T>
	T& GetMutableChunkFragment()
	{
		T* ChunkFragment = GetMutableChunkFragmentPtr<T>();
		CHECK_IF_VALID(ChunkFragment, T::StaticStruct());
		return *ChunkFragment;
	}

	template<typename T>
	const T* GetChunkFragmentPtr() const
	{
		static_assert(TIsDerivedFrom<T, FMassChunkFragment>::IsDerived, "Given struct doesn't represent a valid chunk fragment type. Make sure to inherit from FMassChunkFragment or one of its child-types.");

		const UScriptStruct* Type = T::StaticStruct();
		const FChunkFragmentView* FoundChunkFragmentData = ChunkFragmentViews.FindByPredicate([Type](const FChunkFragmentView& Element) { return Element.Requirement.StructType == Type; } );
		return FoundChunkFragmentData ? FoundChunkFragmentData->FragmentView.GetPtr<T>() : static_cast<const T*>(nullptr);
	}
	
	template<typename T>
	const T& GetChunkFragment() const
	{
		const T* ChunkFragment = GetChunkFragmentPtr<T>();
		CHECK_IF_VALID(ChunkFragment, T::StaticStruct());
		return *ChunkFragment;
	}

	/** Shared fragment related operations */
	const void* GetConstSharedFragmentPtr(const UScriptStruct& SharedFragmentType) const
	{
		const FConstSharedFragmentView* FoundSharedFragmentData = ConstSharedFragmentViews.FindByPredicate([&SharedFragmentType](const FConstSharedFragmentView& Element) { return Element.Requirement.StructType == &SharedFragmentType; });
		return FoundSharedFragmentData ? FoundSharedFragmentData->FragmentView.GetMemory() : nullptr;
	}
	
	template<typename T>
	const T* GetConstSharedFragmentPtr() const
	{
		static_assert(TIsDerivedFrom<T, FMassConstSharedFragment>::IsDerived, "Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.");

		const FConstSharedFragmentView* FoundSharedFragmentData = ConstSharedFragmentViews.FindByPredicate([](const FConstSharedFragmentView& Element) { return Element.Requirement.StructType == T::StaticStruct(); });
		return FoundSharedFragmentData ? FoundSharedFragmentData->FragmentView.GetPtr<const T>() : static_cast<const T*>(nullptr);
	}

	template<typename T>
	const T& GetConstSharedFragment() const
	{
		const T* SharedFragment = GetConstSharedFragmentPtr<const T>();
		CHECK_IF_VALID(SharedFragment, T::StaticStruct());
		return *SharedFragment;
	}

	template<typename T>
	T* GetMutableSharedFragmentPtr()
	{
		static_assert(TIsDerivedFrom<T, FMassSharedFragment>::IsDerived, "Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.");

		FSharedFragmentView* FoundSharedFragmentData = SharedFragmentViews.FindByPredicate([](const FSharedFragmentView& Element) { return Element.Requirement.StructType == T::StaticStruct(); });
		CHECK_IF_READWRITE(FoundSharedFragmentData);
		return FoundSharedFragmentData ? FoundSharedFragmentData->FragmentView.GetPtr<T>() : static_cast<T*>(nullptr);
	}

	template<typename T>
	const T* GetSharedFragmentPtr() const
	{
		static_assert(TIsDerivedFrom<T, FMassSharedFragment>::IsDerived, "Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.");

		const FSharedFragmentView* FoundSharedFragmentData = SharedFragmentViews.FindByPredicate([](const FSharedFragmentView& Element) { return Element.Requirement.StructType == T::StaticStruct(); });
		return FoundSharedFragmentData ? FoundSharedFragmentData->FragmentView.GetPtr<T>() : static_cast<const T*>(nullptr);
	}

	template<typename T>
	T& GetMutableSharedFragment()
	{
		T* SharedFragment = GetMutableSharedFragmentPtr<T>();
		CHECK_IF_VALID(SharedFragment, T::StaticStruct());
		return *SharedFragment;
	}

	template<typename T>
	const T& GetSharedFragment() const
	{
		const T* SharedFragment = GetSharedFragmentPtr<T>();
		CHECK_IF_VALID(SharedFragment, T::StaticStruct());
		return *SharedFragment;
	}

	/* Fragments related operations */
	template<typename TFragment>
	TArrayView<TFragment> GetMutableFragmentView()
	{
		const UScriptStruct* FragmentType = TFragment::StaticStruct();
		const FFragmentView* View = FragmentViews.FindByPredicate([FragmentType](const FFragmentView& Element) { return Element.Requirement.StructType == FragmentType; });
		CHECK_IF_VALID(View, FragmentType);
		CHECK_IF_READWRITE(View);
		return MakeArrayView<TFragment>((TFragment*)View->FragmentView.GetData(), View->FragmentView.Num());
	}

	template<typename TFragment>
	TConstArrayView<TFragment> GetFragmentView() const
	{
		const UScriptStruct* FragmentType = TFragment::StaticStruct();
		const FFragmentView* View = FragmentViews.FindByPredicate([FragmentType](const FFragmentView& Element) { return Element.Requirement.StructType == FragmentType; });
		CHECK_IF_VALID(View, TFragment::StaticStruct());
		return TConstArrayView<TFragment>((const TFragment*)View->FragmentView.GetData(), View->FragmentView.Num());
	}

	TConstArrayView<FMassFragment> GetFragmentView(const UScriptStruct* FragmentType) const
	{
		const FFragmentView* View = FragmentViews.FindByPredicate([FragmentType](const FFragmentView& Element) { return Element.Requirement.StructType == FragmentType; });
		CHECK_IF_VALID(View, FragmentType);
		return TConstArrayView<FMassFragment>((const FMassFragment*)View->FragmentView.GetData(), View->FragmentView.Num());;
	}

	TArrayView<FMassFragment> GetMutableFragmentView(const UScriptStruct* FragmentType) 
	{
		const FFragmentView* View = FragmentViews.FindByPredicate([FragmentType](const FFragmentView& Element) { return Element.Requirement.StructType == FragmentType; });
		CHECK_IF_VALID(View, FragmentType);
		CHECK_IF_READWRITE(View);
		return View->FragmentView;
	}

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	T* GetMutableSubsystem()
	{
		return SubsystemAccess.GetMutableSubsystem<T>();
	}

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	T& GetMutableSubsystemChecked()
	{
		return SubsystemAccess.GetMutableSubsystemChecked<T>();
	}

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	const T* GetSubsystem()
	{
		return SubsystemAccess.GetSubsystem<T>();
	}

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	const T& GetSubsystemChecked()
	{
		return SubsystemAccess.GetSubsystemChecked<T>();
	}

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	T* GetMutableSubsystem(const TSubclassOf<USubsystem> SubsystemClass)
	{
		return SubsystemAccess.GetMutableSubsystem<T>(SubsystemClass);
	}

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	T& GetMutableSubsystemChecked(const TSubclassOf<USubsystem> SubsystemClass)
	{
		return SubsystemAccess.GetMutableSubsystemChecked<T>(SubsystemClass);
	}

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	const T* GetSubsystem(const TSubclassOf<USubsystem> SubsystemClass)
	{
		return SubsystemAccess.GetSubsystem<T>(SubsystemClass);
	}

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	const T& GetSubsystemChecked(const TSubclassOf<USubsystem> SubsystemClass)
	{
		return SubsystemAccess.GetSubsystemChecked<T>(SubsystemClass);
	}

	/** Sparse chunk related operation */
	const FMassArchetypeEntityCollection& GetEntityCollection() const { return EntityCollection; }

	const FInstancedStruct& GetAuxData() const { return AuxData; }
	FInstancedStruct& GetMutableAuxData() { return AuxData; }
	
	template<typename TFragment>
	bool ValidateAuxDataType() const
	{
		const UScriptStruct* FragmentType = GetAuxData().GetScriptStruct();
		return FragmentType != nullptr && FragmentType == TFragment::StaticStruct();
	}

	void FlushDeferred();

	void ClearExecutionData();
	void SetCurrentArchetypeCompositionDescriptor(const FMassArchetypeCompositionDescriptor& Descriptor)
	{
		CurrentArchetypeCompositionDescriptor = Descriptor;
	}

	/** 
	 * Processes SubsystemRequirements to fetch and cache all the indicated subsystems. If a UWorld is required to fetch
	 * a specific subsystem then the one associated with the stored EntityManager will be used.
	 *
	 * @param SubsystemRequirements indicates all the subsystems that are expected to be accessed. Requesting a subsystem 
	 *	not indicated by the SubsystemRequirements will result in a failure.
	 * 
	 * @return `true` if all required subsystems have been found, `false` otherwise.
	 */
	bool CacheSubsystemRequirements(const FMassSubsystemRequirements& SubsystemRequirements);

protected:
	void SetSubsystemRequirements(const FMassSubsystemRequirements& SubsystemRequirements)
	{
		SubsystemAccess.SetSubsystemRequirements(SubsystemRequirements);
	}

	void SetFragmentRequirements(const FMassFragmentRequirements& FragmentRequirements);

	void ClearFragmentViews()
	{
		for (FFragmentView& View : FragmentViews)
		{
			View.FragmentView = TArrayView<FMassFragment>();
		}
		for (FChunkFragmentView& View : ChunkFragmentViews)
		{
			View.FragmentView.Reset();
		}
		for (FConstSharedFragmentView& View : ConstSharedFragmentViews)
		{
			View.FragmentView.Reset();
		}
		for (FSharedFragmentView& View : SharedFragmentViews)
		{
			View.FragmentView.Reset();
		}
	}

public:
	//////////////////////////////////////////////////////////////////////////
	// DEPRECATED functions

	template<typename T>
	UE_DEPRECATED(5.2, "The Get*Subsystem(World) functions have been deprecated. Use the world-less flavor.")
	T* GetMutableSubsystem(const UWorld* World)
	{
		return SubsystemAccess.GetMutableSubsystem<T>();
	}

	template<typename T>
	UE_DEPRECATED(5.2, "The Get*Subsystem(World) functions have been deprecated. Use the world-less flavor.")
	T& GetMutableSubsystemChecked(const UWorld* World)
	{
		return SubsystemAccess.GetMutableSubsystemChecked<T>();
	}

	template<typename T>
	UE_DEPRECATED(5.2, "The Get*Subsystem(World) functions have been deprecated. Use the world-less flavor.")
	const T* GetSubsystem(const UWorld* World)
	{
		return SubsystemAccess.GetSubsystem<T>();
	}

	template<typename T>
	UE_DEPRECATED(5.2, "The Get*Subsystem(World) functions have been deprecated. Use the world-less flavor.")
	const T& GetSubsystemChecked(const UWorld* World)
	{
		return SubsystemAccess.GetSubsystemChecked<T>();
	}

	template<typename T>
	UE_DEPRECATED(5.2, "The Get*Subsystem(World) functions have been deprecated. Use the world-less flavor.")
	T* GetMutableSubsystem(const UWorld* World, const TSubclassOf<USubsystem> SubsystemClass)
	{
		return SubsystemAccess.GetMutableSubsystem<T>(SubsystemClass);
	}

	template<typename T>
	UE_DEPRECATED(5.2, "The Get*Subsystem(World) functions have been deprecated. Use the world-less flavor.")
	T& GetMutableSubsystemChecked(const UWorld* World, const TSubclassOf<USubsystem> SubsystemClass)
	{
		return SubsystemAccess.GetMutableSubsystemChecked<T>(SubsystemClass);
	}

	template<typename T>
	UE_DEPRECATED(5.2, "The Get*Subsystem(World) functions have been deprecated. Use the world-less flavor.")
	const T* GetSubsystem(const UWorld* World, const TSubclassOf<USubsystem> SubsystemClass)
	{
		return SubsystemAccess.GetSubsystem<T>(SubsystemClass);
	}

	template<typename T>
	UE_DEPRECATED(5.2, "The Get*Subsystem(World) functions have been deprecated. Use the world-less flavor.")
	const T& GetSubsystemChecked(const UWorld* World, const TSubclassOf<USubsystem> SubsystemClass)
	{
		return SubsystemAccess.GetSubsystemChecked<T>(SubsystemClass);
	}

	UE_DEPRECATED(5.2, "This version of CacheSubsystemRequirements is deprecated. Use the one without the UWorld parameter")
	bool CacheSubsystemRequirements(const UWorld*, const FMassSubsystemRequirements& SubsystemRequirements)
	{
		return CacheSubsystemRequirements(SubsystemRequirements);
	}

	UE_DEPRECATED(5.4, "Deprecated in favor of 'SetCurrentArchetypeCompositionDescriptor' as this provides information on the entire archetype.")
	void SetCurrentArchetypesTagBitSet(const FMassTagBitSet&) {}
};

#undef CHECK_IF_VALID
#undef CHECK_IF_READWRITE

================================================


=== MassEntity/Public/MassExecutor.h ===
========================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassArchetypeTypes.h"
#include "Async/TaskGraphInterfaces.h"


struct FMassRuntimePipeline;
struct FMassProcessingContext;
struct FMassEntityHandle;
struct FMassArchetypeEntityCollection;
class UMassProcessor;


namespace UE::Mass::Executor
{
	/** Executes processors in a given RuntimePipeline */
	MASSENTITY_API void Run(FMassRuntimePipeline& RuntimePipeline, FMassProcessingContext& ProcessingContext);

	/** Executes given Processor. Used mainly for triggering calculations via MassCompositeProcessors, e.g processing phases */
	MASSENTITY_API void Run(UMassProcessor& Processor, FMassProcessingContext& ProcessingContext);

	/** Similar to the Run function, but instead of using all the entities hosted by ProcessingContext.EntitySubsystem 
	 *  it is processing only the entities given by EntityID via the Entities input parameter. 
	 *  Note that all the entities need to be of Archetype archetype. 
	 *  Under the hood the function converts Archetype-Entities pair to FMassArchetypeEntityCollection and calls the other flavor of RunSparse
	 */
	MASSENTITY_API void RunSparse(FMassRuntimePipeline& RuntimePipeline, FMassProcessingContext& ProcessingContext, FMassArchetypeHandle Archetype, TConstArrayView<FMassEntityHandle> Entities);

	/** Similar to the Run function, but instead of using all the entities hosted by ProcessingContext.EntitySubsystem 
	 *  it is processing only the entities given by SparseEntities input parameter.
	 *  @todo rename
	 */
	MASSENTITY_API void RunSparse(FMassRuntimePipeline& RuntimePipeline, FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection& EntityCollection);

	/** Executes given Processors array view. This function gets called under the hood by the rest of Run* functions */
	MASSENTITY_API void RunProcessorsView(TArrayView<UMassProcessor* const> Processors, FMassProcessingContext& ProcessingContext, TConstArrayView<FMassArchetypeEntityCollection> EntityCollections = {});

	/** 
	 *  Triggers tasks executing Processor (and potentially it's children) and returns the task graph event representing 
	 *  the task (the event will be "completed" once all the processors finish running). 
	 *  @param OnDoneNotification will be called after all the processors are done, just after flushing the command buffer.
	 *    Note that OnDoneNotification will be executed on GameThread.
	 */
	MASSENTITY_API FGraphEventRef TriggerParallelTasks(UMassProcessor& Processor, FMassProcessingContext& ProcessingContext, TFunction<void()> OnDoneNotification);

	UE_DEPRECATED(5.5, "This flavor of RunProcessorsView is deprecated. Use the one with TConstArrayView<FMassArchetypeEntityCollection> parameter instead.")
	MASSENTITY_API void RunProcessorsView(TArrayView<UMassProcessor* const> Processors, FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection* EntityCollection);
};

========================================


=== MassEntity/Public/MassExternalSubsystemTraits.h ===
=======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Engine/World.h"
#include "Subsystems/WorldSubsystem.h"

/**
 * Traits describing how a given piece of code can be used by Mass. We require author or user of a given subsystem to 
 * define its traits. To do it add the following in an accessible location. 
 *
 * template<>
 * struct TMassExternalSubsystemTraits<UMyCustomManager>
 * {
 *		enum { GameThreadOnly = false; }
 * }
 *
 * this will let Mass know it can access UMyCustomManager on any thread.
 *
 * This information is being used to calculate processor and query dependencies as well as appropriate distribution of
 * calculations across threads.
 */
template <typename T>
struct TMassExternalSubsystemTraits final
{
	enum
	{
		// Note that we're not supplying a default value for this property to be able to statically catch code that tries
		// to access given subsystem without including the appropriate headers. See the comment above if you want to use
		// a UWorldSubsystem that has not had its traits defined before. 
		// GameThreadOnly = true,
		ThreadSafeRead = false,
		ThreadSafeWrite = false,
	};
};

namespace FMassExternalSubsystemTraits
{
	/**
	 * Every TMassExternalSubsystemTraits specialization needs to implement the following. Not supplying default implementations
	 * to be able to catch missing implementations and header inclusion at compilation time.
	 * 
	 * This is a getter function that given a UWorld* fetches an instance.
	*/
	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, UWorldSubsystem>::IsDerived>::Type>
	UE_DEPRECATED(5.2, "FMassExternalSubsystemTraits::GetInstance has been marked as deprecated. Use FMassSubsystemAccess::FetchSubsystemInstance instead.")
	FORCEINLINE T* GetInstance(const UWorld* World)
	{ 
		// note that the default implementation works only for UWorldSubsystems
		return UWorld::GetSubsystem<T>(World);
	}

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, UWorldSubsystem>::IsDerived>::Type>
	UE_DEPRECATED(5.2, "FMassExternalSubsystemTraits::GetInstance has been marked as deprecated. Use FMassSubsystemAccess::FetchSubsystemInstance instead.")
	FORCEINLINE T* GetInstance(const UWorld* World, const TSubclassOf<UWorldSubsystem> SubsystemClass)
	{
		return World ? Cast<T>(World->GetSubsystemBase(SubsystemClass)) : (T*)nullptr;
	}
}

/** 
 * Shared Fragments' traits.
 * @see TMassExternalSubsystemTraits
 */
template <typename T>
struct TMassSharedFragmentTraits final
{
	enum
	{
		GameThreadOnly = false,
	};
};

=======================================================


=== MassEntity/Public/MassObserverManager.h ===
===============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "MassObserverManager.generated.h"


struct FMassEntityManager;
struct FMassArchetypeEntityCollection;
class UMassProcessor;
struct FMassProcessingContext;

/** 
 * A wrapper type for a TMap to support having array-of-maps UPROPERTY members in FMassObserverManager
 */
USTRUCT()
struct FMassObserversMap
{
	GENERATED_BODY()

	// a helper accessor simplifying access while still keeping Container private
	TMap<TObjectPtr<const UScriptStruct>, FMassRuntimePipeline>& operator*()
	{
		return Container;
	}

private:
	UPROPERTY()
	TMap<TObjectPtr<const UScriptStruct>, FMassRuntimePipeline> Container;
};

/** 
 * A type that encapsulates logic related to notifying interested parties of entity composition changes. Upon creation it
 * reads information from UMassObserverRegistry and instantiates processors interested in handling given fragment
 * type addition or removal.
 */
USTRUCT()
struct MASSENTITY_API FMassObserverManager
{
	GENERATED_BODY()

public:
	FMassObserverManager();	

	const FMassFragmentBitSet* GetObservedFragmentBitSets() const { return ObservedFragments; }
	const FMassFragmentBitSet& GetObservedFragmentsBitSet(const EMassObservedOperation Operation) const 
	{ 
		return ObservedFragments[(uint8)Operation]; 
	}

	const FMassTagBitSet* GetObservedTagBitSets() const { return ObservedTags; }
	const FMassTagBitSet& GetObservedTagsBitSet(const EMassObservedOperation Operation) const 
	{ 
		return ObservedTags[(uint8)Operation]; 
	}
	
	bool HasObserversForBitSet(const FMassFragmentBitSet& InQueriedBitSet, const EMassObservedOperation Operation) const
	{
		return ObservedFragments[(uint8)Operation].HasAny(InQueriedBitSet);
	}

	bool HasObserversForBitSet(const FMassTagBitSet& InQueriedBitSet, const EMassObservedOperation Operation) const
	{
		return ObservedTags[(uint8)Operation].HasAny(InQueriedBitSet);
	}

	bool HasObserversForComposition(const FMassArchetypeCompositionDescriptor& Composition, const EMassObservedOperation Operation) const
	{
		return HasObserversForBitSet(Composition.Fragments, Operation) || HasObserversForBitSet(Composition.Tags, Operation);
	}

	/** @return whether any observers have been executed */
	bool OnPostEntitiesCreated(const FMassArchetypeEntityCollection& EntityCollection);

	/** @return whether any observers have been executed */
	bool OnPostEntitiesCreated(TConstArrayView<FMassArchetypeEntityCollection> EntityCollections);

	/** @return whether any observers have been executed */
	bool OnPostEntitiesCreated(FMassProcessingContext& InProcessingContext, TConstArrayView<FMassArchetypeEntityCollection> EntityCollections);

	/** @return whether any observers have been executed */
	bool OnPreEntitiesDestroyed(const FMassArchetypeEntityCollection& EntityCollection);

	/** @return whether any observers have been executed */
	bool OnPreEntitiesDestroyed(FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection& EntityCollection);

	/** @return whether any observers have been executed */
	bool OnPreEntityDestroyed(const FMassArchetypeCompositionDescriptor& ArchetypeComposition, const FMassEntityHandle Entity);

	/** @return whether any observers have been executed */
	bool OnCompositionChanged(const FMassEntityHandle Entity, const FMassArchetypeCompositionDescriptor& CompositionDelta, const EMassObservedOperation Operation);

	/** @return whether any observers have been executed */
	bool OnPostCompositionAdded(const FMassEntityHandle Entity, const FMassArchetypeCompositionDescriptor& Composition)
	{
		return OnCompositionChanged(Entity, Composition, EMassObservedOperation::Add);
	}
	/** @return whether any observers have been executed */
	bool OnPreCompositionRemoved(const FMassEntityHandle Entity, const FMassArchetypeCompositionDescriptor& Composition)
	{
		return OnCompositionChanged(Entity, Composition, EMassObservedOperation::Remove);
	}

	/** @return whether any observers have been executed */
	bool OnCompositionChanged(FMassProcessingContext& InProcessingContext, const FMassArchetypeEntityCollection& EntityCollection, const FMassArchetypeCompositionDescriptor& Composition, const EMassObservedOperation Operation);
	/** @return whether any observers have been executed */
	bool OnCompositionChanged(const FMassArchetypeEntityCollection& EntityCollection, const FMassArchetypeCompositionDescriptor& Composition, const EMassObservedOperation Operation)
	{
		FMassProcessingContext LocalContext(EntityManager, /*DeltaSeconds=*/0.f);
		LocalContext.bFlushCommandBuffer = false;
		return OnCompositionChanged(LocalContext, EntityCollection, Composition, Operation);
	}

	void OnPostFragmentOrTagAdded(const UScriptStruct& FragmentOrTagType, const FMassArchetypeEntityCollection& EntityCollection)
	{
		OnFragmentOrTagOperation(FragmentOrTagType, EntityCollection, EMassObservedOperation::Add);
	}
	void OnPreFragmentOrTagRemoved(const UScriptStruct& FragmentOrTagType, const FMassArchetypeEntityCollection& EntityCollection)
	{
		OnFragmentOrTagOperation(FragmentOrTagType, EntityCollection, EMassObservedOperation::Remove);
	}
	// @todo I don't love this name. Alternatively could be OnSingleFragmentOrTagOperation. Long term we'll switch to
	// OnSingleFragmentOperation and advertise that Tags are a type of Fragment as well (conceptually).
	void OnFragmentOrTagOperation(const UScriptStruct& FragmentOrTagType, const FMassArchetypeEntityCollection& EntityCollection, const EMassObservedOperation Operation);

	void AddObserverInstance(const UScriptStruct& FragmentOrTagType, const EMassObservedOperation Operation, UMassProcessor& ObserverProcessor);
	void RemoveObserverInstance(const UScriptStruct& FragmentOrTagType, const EMassObservedOperation Operation, UMassProcessor& ObserverProcessor);

protected:
	friend FMassEntityManager;
	explicit FMassObserverManager(FMassEntityManager& Owner);

	void Initialize();
	void DeInitialize();
	void HandleFragmentsImpl(FMassProcessingContext& ProcessingContext, const FMassArchetypeEntityCollection& EntityCollection
		, TArrayView<const UScriptStruct*> ObservedTypes, FMassObserversMap& HandlersContainer);
	void HandleSingleEntityImpl(const UScriptStruct& FragmentType, const FMassArchetypeEntityCollection& EntityCollection, FMassObserversMap& HandlersContainer);

	FMassFragmentBitSet ObservedFragments[(uint8)EMassObservedOperation::MAX];
	FMassTagBitSet ObservedTags[(uint8)EMassObservedOperation::MAX];

	UPROPERTY()
	FMassObserversMap FragmentObservers[(uint8)EMassObservedOperation::MAX];

	UPROPERTY()
	FMassObserversMap TagObservers[(uint8)EMassObservedOperation::MAX];

	/** 
	 * The owning EntityManager. No need for it to be a UPROPERTY since by design we don't support creation of 
	 * FMassObserverManager outside of an FMassEntityManager instance 
	 */
	FMassEntityManager& EntityManager;

public:
	UE_DEPRECATED(5.4, "This flavor of OnCompositionChanged is deprecated. Please use the one taking a FMassProcessingContext& parameter instead")
	bool OnCompositionChanged(const FMassArchetypeEntityCollection& EntityCollection, const FMassArchetypeCompositionDescriptor& Composition, const EMassObservedOperation Operation, FMassProcessingContext* InProcessingContext)
	{
		if (InProcessingContext)
		{
			return OnCompositionChanged(*InProcessingContext, EntityCollection, Composition, Operation);
		}
		return OnCompositionChanged(EntityCollection, Composition, Operation);
	}

	UE_DEPRECATED(5.5, "This flavor of OnPostEntitiesCreated is deprecated. Please use the one taking a TConstArrayView<FMassArchetypeEntityCollection> parameter instead")
	bool OnPostEntitiesCreated(FMassProcessingContext& InProcessingContext, const FMassArchetypeEntityCollection& EntityCollection);
};

template<>
struct TStructOpsTypeTraits<FMassObserverManager> : public TStructOpsTypeTraitsBase2<FMassObserverManager>
{
	enum
	{
		WithCopy = false,
	};
};

===============================================


=== MassEntity/Public/MassObserverProcessor.h ===
=================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassProcessor.h"
#include "MassObserverProcessor.generated.h"


UCLASS(abstract)
class MASSENTITY_API UMassObserverProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassObserverProcessor();

protected:
	virtual void PostInitProperties() override;

	/** 
	 * By default registers this class as Operation observer of ObservedType. Override to register for multiple 
	 * operations and/or types 
	 */
	virtual void Register();

protected:
	UPROPERTY(EditDefaultsOnly, Category = Processor, config)
	bool bAutoRegisterWithObserverRegistry = true;

	/** Determines which Fragment or Tag type this given UMassObserverProcessor will be observing */
	UPROPERTY()
	TObjectPtr<UScriptStruct> ObservedType = nullptr;

	EMassObservedOperation Operation = EMassObservedOperation::MAX;
};

=================================================


=== MassEntity/Public/MassObserverRegistry.h ===
================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "MassProcessor.h"
#include "MassObserverRegistry.generated.h"


struct FMassObserverManager;

/**
 * A wrapper type for a TArray to support having map-of-arrays UPROPERTY members in FMassEntityObserverClassesMap
 */
USTRUCT()
struct FMassProcessorClassCollection
{
	GENERATED_BODY()

	UPROPERTY()
	TArray<TSubclassOf<UMassProcessor>> ClassCollection;
};

/**
 * A wrapper type for a TMap to support having array-of-maps UPROPERTY members in UMassObserverRegistry
 */
USTRUCT()
struct FMassEntityObserverClassesMap
{
	GENERATED_BODY()

	/** a helper accessor simplifying access while still keeping Container private */
	const TMap<TObjectPtr<const UScriptStruct>, FMassProcessorClassCollection>& operator*() const
	{
		return Container;
	}

	TMap<TObjectPtr<const UScriptStruct>, FMassProcessorClassCollection>& operator*()
	{
		return Container;
	}

private:
	UPROPERTY()
	TMap<TObjectPtr<const UScriptStruct>, FMassProcessorClassCollection> Container;
};

UCLASS()
class MASSENTITY_API UMassObserverRegistry : public UObject
{
	GENERATED_BODY()

public:
	UMassObserverRegistry();

	static UMassObserverRegistry& GetMutable() { return *GetMutableDefault<UMassObserverRegistry>(); }
	static const UMassObserverRegistry& Get() { return *GetDefault<UMassObserverRegistry>(); }

	void RegisterObserver(const UScriptStruct& ObservedType, const EMassObservedOperation Operation, TSubclassOf<UMassProcessor> ObserverClass);

protected:
	friend FMassObserverManager;

	UPROPERTY()
	FMassEntityObserverClassesMap FragmentObservers[(uint8)EMassObservedOperation::MAX];

	UPROPERTY()
	FMassEntityObserverClassesMap TagObservers[(uint8)EMassObservedOperation::MAX];
};

================================================


=== MassEntity/Public/MassProcessingPhaseManager.h ===
======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "UObject/UObjectGlobals.h"
#include "UObject/Object.h"
#include "UObject/GCObject.h"
#include "Engine/EngineBaseTypes.h"
#include "MassProcessingTypes.h"
#include "MassProcessor.h"
#include "MassProcessorDependencySolver.h"
#include "MassProcessingPhaseManager.generated.h"


struct FMassProcessingPhaseManager;
class UMassProcessor;
class UMassCompositeProcessor;
struct FMassEntityManager;
struct FMassCommandBuffer;
struct FMassProcessingPhaseConfig;


USTRUCT()
struct MASSENTITY_API FMassProcessingPhaseConfig
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = Mass, config)
	FName PhaseName;

	UPROPERTY(EditAnywhere, Category = Mass, config, NoClear)
	TSubclassOf<UMassCompositeProcessor> PhaseGroupClass = UMassCompositeProcessor::StaticClass();

	UPROPERTY(Transient)
	TArray<TObjectPtr<UMassProcessor>> ProcessorCDOs;

#if WITH_EDITORONLY_DATA
	// this processor is available only in editor since it's used to present the user the order in which processors
	// will be executed when given processing phase gets triggered
	UPROPERTY(Transient)
	TObjectPtr<UMassCompositeProcessor> PhaseProcessor = nullptr;

	UPROPERTY(VisibleAnywhere, Category = Mass, Transient)
	FText Description;
#endif //WITH_EDITORONLY_DATA
};


struct MASSENTITY_API FMassProcessingPhase : public FTickFunction
{
	DECLARE_MULTICAST_DELEGATE_OneParam(FOnPhaseEvent, const float /*DeltaSeconds*/);

	FMassProcessingPhase();
	FMassProcessingPhase(const FMassProcessingPhase& Other) = delete;
	FMassProcessingPhase& operator=(const FMassProcessingPhase& Other) = delete;

protected:
	// FTickFunction interface
	virtual void ExecuteTick(float DeltaTime, ELevelTick TickType, ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent) override;
	virtual FString DiagnosticMessage() override;
	virtual FName DiagnosticContext(bool bDetailed) override;
	// End of FTickFunction interface

	void OnParallelExecutionDone(const float DeltaTime);

	bool IsConfiguredForParallelMode() const { return bRunInParallelMode; }
	void ConfigureForParallelMode() { bRunInParallelMode = true; }
	void ConfigureForSingleThreadMode() { bRunInParallelMode = false; }

	bool ShouldTick(const ELevelTick TickType) const { return SupportedTickTypes & (1 << TickType); }

public:
	void Initialize(FMassProcessingPhaseManager& InPhaseManager, const EMassProcessingPhase InPhase, const ETickingGroup InTickGroup, UMassCompositeProcessor& InPhaseProcessor);
	void AddSupportedTickType(const ELevelTick TickType) { SupportedTickTypes |= (1 << TickType); }
	void RemoveSupportedTickType(const ELevelTick TickType) { SupportedTickTypes &= ~(1 << TickType); }

protected:
	friend FMassProcessingPhaseManager;

	// composite processor representing work to be performed. GC-referenced via AddReferencedObjects
	TObjectPtr<UMassCompositeProcessor> PhaseProcessor = nullptr;

	EMassProcessingPhase Phase = EMassProcessingPhase::MAX;
	FOnPhaseEvent OnPhaseStart;
	FOnPhaseEvent OnPhaseEnd;

private:
	FMassProcessingPhaseManager* PhaseManager = nullptr;
	std::atomic<bool> bIsDuringMassProcessing = false;
	bool bRunInParallelMode = false;
	uint8 SupportedTickTypes = 0;
};


struct MASSENTITY_API FMassPhaseProcessorConfigurationHelper
{
	FMassPhaseProcessorConfigurationHelper(UMassCompositeProcessor& InOutPhaseProcessor, const FMassProcessingPhaseConfig& InPhaseConfig, UObject& InProcessorOuter, EMassProcessingPhase InPhase)
		: PhaseProcessor(InOutPhaseProcessor), PhaseConfig(InPhaseConfig), ProcessorOuter(InProcessorOuter), Phase(InPhase)
	{
	}

	/** 
	 * @param InWorldExecutionFlags - provide EProcessorExecutionFlags::None to let underlying code decide
	 */
	void Configure(TArrayView<UMassProcessor* const> DynamicProcessors, EProcessorExecutionFlags InWorldExecutionFlags
		, const TSharedPtr<FMassEntityManager>& EntityManager = TSharedPtr<FMassEntityManager>()
		, FMassProcessorDependencySolver::FResult* OutOptionalResult = nullptr);

	UMassCompositeProcessor& PhaseProcessor;
	const FMassProcessingPhaseConfig& PhaseConfig;
	UObject& ProcessorOuter;
	EMassProcessingPhase Phase;
	bool bInitializeCreatedProcessors = true;
	bool bIsGameRuntime = true;

	UE_DEPRECATED(5.2, "This flavor of Configure has been deprecated. Use the one requiring the first parameter to be an array view of additional processors")
	void Configure(const TSharedPtr<FMassEntityManager>& EntityManager = TSharedPtr<FMassEntityManager>(), FMassProcessorDependencySolver::FResult* OutOptionalResult = nullptr)
	{
		Configure({}, EProcessorExecutionFlags::None, EntityManager, OutOptionalResult);
	}

	UE_DEPRECATED(5.3, "This flavor of Configure has been deprecated. Use the one requiring the first parameter to be an array view of additional processors and EProcessorExecutionFlags to be provided")
	void Configure(TArrayView<UMassProcessor* const> DynamicProcessors, const TSharedPtr<FMassEntityManager>& EntityManager = TSharedPtr<FMassEntityManager>(),
		FMassProcessorDependencySolver::FResult* OutOptionalResult = nullptr)
	{
		Configure(DynamicProcessors, EProcessorExecutionFlags::None, EntityManager, OutOptionalResult);
	}
};

/** 
 * MassProcessingPhaseManager owns separate FMassProcessingPhase instances for every ETickingGroup. When activated
 * via Start function it registers and enables the FMassProcessingPhase instances which themselves are tick functions 
 * that host UMassCompositeProcessor which they trigger as part of their Tick function. 
 * MassProcessingPhaseManager serves as an interface to said FMassProcessingPhase instances and allows initialization
 * with collections of processors (via Initialize function) as well as registering arbitrary functions to be called 
 * when a particular phase starts or ends (via GetOnPhaseStart and GetOnPhaseEnd functions). 
 */
struct MASSENTITY_API FMassProcessingPhaseManager : public FGCObject
{
public:
	explicit FMassProcessingPhaseManager(EProcessorExecutionFlags InProcessorExecutionFlags = EProcessorExecutionFlags::None) 
		: ProcessorExecutionFlags(InProcessorExecutionFlags)
	{}
	FMassProcessingPhaseManager(const FMassProcessingPhaseManager& Other) = delete;
	FMassProcessingPhaseManager& operator=(const FMassProcessingPhaseManager& Other) = delete;

	const TSharedPtr<FMassEntityManager>& GetEntityManager() { return EntityManager; }
	FMassEntityManager& GetEntityManagerRef() { check(EntityManager); return *EntityManager.Get(); }

	/** Retrieves OnPhaseStart multicast delegate's reference for a given Phase */
	FMassProcessingPhase::FOnPhaseEvent& GetOnPhaseStart(const EMassProcessingPhase Phase) { return ProcessingPhases[uint8(Phase)].OnPhaseStart; } //-V557
	/** Retrieves OnPhaseEnd multicast delegate's reference for a given Phase */
	FMassProcessingPhase::FOnPhaseEvent& GetOnPhaseEnd(const EMassProcessingPhase Phase) { return ProcessingPhases[uint8(Phase)].OnPhaseEnd; }

	/** 
	 *  Populates hosted FMassProcessingPhase instances with Processors read from MassEntitySettings configuration.
	 *  Calling this function overrides previous configuration of Phases.
	 */
	void Initialize(UObject& InOwner, TConstArrayView<FMassProcessingPhaseConfig> ProcessingPhasesConfig, const FString& DependencyGraphFileName = TEXT(""));

	/** Needs to be called before destruction, ideally before owner's BeginDestroy (a FGCObject's limitation) */
	void Deinitialize();

	const FGraphEventRef& TriggerPhase(const EMassProcessingPhase Phase, const float DeltaTime, const FGraphEventRef& MyCompletionGraphEvent);

	/** 
	 *  Stores EntityManager associated with given world's MassEntitySubsystem and kicks off phase ticking.
	 */
	void Start(UWorld& World);
	
	/**
	 *  Stores InEntityManager as the entity manager. It also kicks off phase ticking if the given InEntityManager is tied to a UWorld.
	 */
	void Start(const TSharedPtr<FMassEntityManager>& InEntityManager);
	void Stop();
	bool IsRunning() const { return EntityManager.IsValid(); }

	FString GetName() const;

	/** Registers a dynamic processor. This needs to be a fully formed processor and will be slotted in during the next tick. */
	void RegisterDynamicProcessor(UMassProcessor& Processor);
	/** Removes a previously registered dynamic processor of throws an assert if not found. */
	void UnregisterDynamicProcessor(UMassProcessor& Processor);

protected:
	// FGCObject interface
	virtual void AddReferencedObjects(FReferenceCollector& Collector) override;
	virtual FString GetReferencerName() const override
	{
		return TEXT("FMassProcessingPhaseManager");
	}
	// End of FGCObject interface

	void EnableTickFunctions(const UWorld& World);

	/** Creates phase processors instances for each declared phase name, based on MassEntitySettings */
	void CreatePhases();

	friend FMassProcessingPhase;

	/** 
	 *  Called by the given Phase at the very start of its execution function (the FMassProcessingPhase::ExecuteTick),
	 *  even before the FMassProcessingPhase.OnPhaseStart broadcast delegate
	 */
	void OnPhaseStart(const FMassProcessingPhase& Phase);

	/**
	 *  Called by the given Phase at the very end of its execution function (the FMassProcessingPhase::ExecuteTick),
	 *  after the FMassProcessingPhase.OnPhaseEnd broadcast delegate
	 */
	void OnPhaseEnd(FMassProcessingPhase& Phase);

	void OnNewArchetype(const FMassArchetypeHandle& NewArchetype);

protected:	
	struct FPhaseGraphBuildState
	{
		FMassProcessorDependencySolver::FResult LastResult;
		bool bNewArchetypes = true;
		bool bProcessorsNeedRebuild = true;
		bool bInitialized = false;
	};

	FMassProcessingPhase ProcessingPhases[(uint8)EMassProcessingPhase::MAX];
	FPhaseGraphBuildState ProcessingGraphBuildStates[(uint8)EMassProcessingPhase::MAX];
	TArray<FMassProcessingPhaseConfig> ProcessingPhasesConfig;
	TArray<TObjectPtr<UMassProcessor>> DynamicProcessors;

	TSharedPtr<FMassEntityManager> EntityManager;

	EMassProcessingPhase CurrentPhase = EMassProcessingPhase::MAX;

	TWeakObjectPtr<UObject> Owner;

	FDelegateHandle OnNewArchetypeHandle;

	EProcessorExecutionFlags ProcessorExecutionFlags = EProcessorExecutionFlags::None;
	bool bIsAllowedToTick = false;
};

======================================================


=== MassEntity/Public/MassProcessingTypes.h ===
===============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "StructUtils/StructUtilsTypes.h"
#include "StructUtils/InstancedStruct.h"
#include "MassProcessingTypes.generated.h"

#ifndef MASS_DO_PARALLEL
#define MASS_DO_PARALLEL !UE_SERVER
#endif // MASS_DO_PARALLEL

#define WITH_MASSENTITY_DEBUG (!(UE_BUILD_SHIPPING || UE_BUILD_SHIPPING_WITH_EDITOR || UE_BUILD_TEST) && WITH_STRUCTUTILS_DEBUG && 1)

struct FMassEntityManager;
class UMassProcessor;
class UMassCompositeProcessor;
struct FMassCommandBuffer;

UENUM(meta = (Bitflags, UseEnumValuesAsMaskValuesInEditor = "true"))
enum class EProcessorExecutionFlags : uint8
{
	None = 0 UMETA(Hidden),
	Standalone = 1 << 0,
	Server = 1 << 1,
	Client = 1 << 2,
	Editor = 1 << 3,
	EditorWorld = 1 << 4,
	AllNetModes = Standalone | Server | Client UMETA(Hidden),
	AllWorldModes = Standalone | Server | Client | EditorWorld UMETA(Hidden),
	All = Standalone | Server | Client | Editor | EditorWorld UMETA(Hidden)
};
ENUM_CLASS_FLAGS(EProcessorExecutionFlags);

USTRUCT()
struct FProcessorAuxDataBase
{
	GENERATED_BODY()
};

USTRUCT(BlueprintType)
struct MASSENTITY_API FMassProcessingContext
{
	GENERATED_BODY()

	TSharedPtr<FMassEntityManager> EntityManager;
	
	UPROPERTY()
	float DeltaSeconds = 0.f;

	UPROPERTY()
	FInstancedStruct AuxData;

	/** 
	 * If set to "true" the MassExecutor will flush commands at the end of given execution function. 
	 * If "false" the caller is responsible for manually flushing the commands.
	 */
	UPROPERTY()
	bool bFlushCommandBuffer = true; 
		
	TSharedPtr<FMassCommandBuffer> CommandBuffer;
	
	FMassProcessingContext() = default;
	FMassProcessingContext(FMassEntityManager& InEntityManager, const float InDeltaSeconds);
	FMassProcessingContext(TSharedPtr<FMassEntityManager>& InEntityManager, const float InDeltaSeconds);
	~FMassProcessingContext();
};

/** 
 *  Runtime-usable array of MassProcessor copies
 */
USTRUCT()
struct MASSENTITY_API FMassRuntimePipeline
{
	GENERATED_BODY()

private:
	UPROPERTY()
	TArray<TObjectPtr<UMassProcessor>> Processors;

	EProcessorExecutionFlags ExecutionFlags = EProcessorExecutionFlags::None;

public:
	explicit FMassRuntimePipeline(EProcessorExecutionFlags WorldExecutionFlags = EProcessorExecutionFlags::None)
		: ExecutionFlags(WorldExecutionFlags)
	{}

	void Reset();
	void Initialize(UObject& Owner);
	
	/** Creates runtime copies of the given UMassProcessors collection. */
	void SetProcessors(TArray<UMassProcessor*>&& InProcessors);

	/** Creates runtime copies of UMassProcessors given in InProcessors input parameter, using InOwner as new UMassProcessors' outer. */
	void CreateFromArray(TConstArrayView<const UMassProcessor*> InProcessors, UObject& InOwner);

	/** Calls CreateFromArray and calls Initialize on all processors afterwards. */
	void InitializeFromArray(TConstArrayView<const UMassProcessor*> InProcessors, UObject& InOwner);
	
	/** Creates runtime instances of UMassProcessors for each processor class given via InProcessorClasses. 
	 *  The instances will be created with InOwner as outer. */
	void InitializeFromClassArray(TConstArrayView<TSubclassOf<UMassProcessor>> InProcessorClasses, UObject& InOwner);

	/** Creates a runtime instance of every processors in the given InProcessors array. If a processor of that class
	 *  already exists in Processors array it gets overridden. Otherwise it gets added to the end of the collection.*/
	void AppendOrOverrideRuntimeProcessorCopies(TConstArrayView<const UMassProcessor*> InProcessors, UObject& InOwner);

	/** Creates a runtime instance of every processors in the given array if there's no processor of that class in Processors already.
	 *  Call this function when adding processors to an already configured FMassRuntimePipeline instance. If you're creating 
	 *  one from scratch calling any of the InitializeFrom* methods will be more efficient (and will produce same results)
	 *  or call AppendOrOverrideRuntimeProcessorCopies.*/
	void AppendUniqueRuntimeProcessorCopies(TConstArrayView<const UMassProcessor*> InProcessors, UObject& InOwner);

	/** Adds InProcessor to Processors without any additional checks */
	void AppendProcessor(UMassProcessor& Processor);

	/** Creates an instance of ProcessorClass and adds it to Processors without any additional checks */
	void AppendProcessor(TSubclassOf<UMassProcessor> ProcessorClass, UObject& InOwner);

	void RemoveProcessor(UMassProcessor& InProcessor);

	/** goes through Processor looking for a UMassCompositeProcessor instance which GroupName matches the one given as the parameter */
	UMassCompositeProcessor* FindTopLevelGroupByName(const FName GroupName);

	bool HasProcessorOfExactClass(TSubclassOf<UMassProcessor> InClass) const;
	bool IsEmpty() const { return Processors.IsEmpty();}

	int32 Num() const { return Processors.Num(); }
	TConstArrayView<TObjectPtr<UMassProcessor>> GetProcessors() const { return Processors; }
	TArrayView<TObjectPtr<UMassProcessor>> GetMutableProcessors() { return Processors; }

	MASSENTITY_API friend uint32 GetTypeHash(const FMassRuntimePipeline& Instance);
};

UENUM()
enum class EMassProcessingPhase : uint8
{
	PrePhysics,
	StartPhysics,
	DuringPhysics,
	EndPhysics,
	PostPhysics,
	FrameEnd,
	MAX,
};

struct FMassProcessorOrderInfo
{
	enum class EDependencyNodeType : uint8
	{
		Invalid,
		Processor,
		GroupStart,
		GroupEnd
	};

	FName Name = TEXT("");
	UMassProcessor* Processor = nullptr;
	EDependencyNodeType NodeType = EDependencyNodeType::Invalid;
	TArray<FName> Dependencies;
	int32 SequenceIndex = INDEX_NONE;
};

===============================================


=== MassEntity/Public/MassProcessor.h ===
=========================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "MassEntityManager.h"
#include "MassProcessingTypes.h"
#include "Async/TaskGraphInterfaces.h"
#include "MassCommandBuffer.h"
#include "MassProcessor.generated.h"


struct FMassProcessingPhaseConfig;
class UMassCompositeProcessor;
struct FMassDebugger;

enum class EProcessorCompletionStatus : uint8
{
	Invalid,
	Threaded,
	Postponed,
	Done
};

USTRUCT()
struct FMassProcessorExecutionOrder
{
	GENERATED_BODY()

	/** Determines which processing group this processor will be placed in. Leaving it empty ("None") means "top-most group for my ProcessingPhase" */
	UPROPERTY(EditAnywhere, Category = Processor, config)
	FName ExecuteInGroup = FName();

	UPROPERTY(EditAnywhere, Category = Processor, config)
	TArray<FName> ExecuteBefore;

	UPROPERTY(EditAnywhere, Category = Processor, config)
	TArray<FName> ExecuteAfter;
};


UCLASS(abstract, EditInlineNew, CollapseCategories, config = Mass, defaultconfig, ConfigDoNotCheckDefaults)
class MASSENTITY_API UMassProcessor : public UObject
{
	GENERATED_BODY()
public:
	UMassProcessor();
	explicit UMassProcessor(const FObjectInitializer& ObjectInitializer);

	bool IsInitialized() const;
	/** Called to initialize the processor. Override to perform custom steps. The super implementation has to be called. */
	virtual void Initialize(UObject& Owner);
	virtual FGraphEventRef DispatchProcessorTasks(const TSharedPtr<FMassEntityManager>& EntityManager, FMassExecutionContext& ExecutionContext, const FGraphEventArray& Prerequisites = FGraphEventArray());

	EProcessorExecutionFlags GetExecutionFlags() const;

	/** Whether this processor should execute according the CurrentExecutionFlags parameters */
	bool ShouldExecute(const EProcessorExecutionFlags CurrentExecutionFlags) const;
	void CallExecute(FMassEntityManager& EntityManager, FMassExecutionContext& Context);

	/** 
	 * Controls whether there can be multiple instances of a given class in a single FMassRuntimePipeline and during 
	 * dependency solving. 
	 */
	bool ShouldAllowMultipleInstances() const;

	void DebugOutputDescription(FOutputDevice& Ar) const;
	virtual void DebugOutputDescription(FOutputDevice& Ar, int32 Indent) const;
	virtual FString GetProcessorName() const;
	
	//----------------------------------------------------------------------//
	// Ordering functions 
	//----------------------------------------------------------------------//
	/** Indicates whether this processor can ever be pruned while considered for a phase processing graph. A processor
	 *  can get pruned if none of its registered queries interact with archetypes instantiated at the moment of graph
	 *  building. This can also happen for special processors that don't register any queries - if that's the case override 
	 *  this function to return an appropriate value
	 *  @param bRuntimeMode indicates whether the pruning is being done for game runtime (true) or editor-time presentation (false) */
	virtual bool ShouldAllowQueryBasedPruning(const bool bRuntimeMode = true) const;

	virtual EMassProcessingPhase GetProcessingPhase() const;
	virtual void SetProcessingPhase(EMassProcessingPhase Phase);
	bool DoesRequireGameThreadExecution() const;
	
	const FMassProcessorExecutionOrder& GetExecutionOrder() const;

	/** By default,  fetches requirements declared entity queries registered via RegisterQuery. Processors can override 
	 *	this function to supply additional requirements */
	virtual void ExportRequirements(FMassExecutionRequirements& OutRequirements) const;

	const FMassSubsystemRequirements& GetProcessorRequirements() const;

	/** Adds Query to RegisteredQueries list. Query is required to be a member variable of this processor. Not meeting
	 *  this requirement will cause check failure and the query won't be registered. */
	void RegisterQuery(FMassEntityQuery& Query);

	void MarkAsDynamic();
	bool IsDynamic() const;

	bool ShouldAutoAddToGlobalList() const;
#if WITH_EDITOR
	bool ShouldShowUpInSettings() const;
#endif // WITH_EDITOR

	/** Sets bAutoRegisterWithProcessingPhases. Setting it to true will result in this processor class being always 
	 * instantiated to be automatically evaluated every frame. @see FMassProcessingPhaseManager
	 * Note that calling this function is only valid on CDOs. Calling it on a regular instance will fail an ensure and 
	 * have no other effect, i.e. CDO's value won't change */
	void SetShouldAutoRegisterWithGlobalList(const bool bAutoRegister);

	void GetArchetypesMatchingOwnedQueries(const FMassEntityManager& EntityManager, TArray<FMassArchetypeHandle>& OutArchetype);
	bool DoesAnyArchetypeMatchOwnedQueries(const FMassEntityManager& EntityManager);
	
#if CPUPROFILERTRACE_ENABLED
	FString StatId;
#endif
	
protected:
	virtual void ConfigureQueries() PURE_VIRTUAL(UMassProcessor::ConfigureQueries);
	virtual void PostInitProperties() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) PURE_VIRTUAL(UMassProcessor::Execute);

protected:
	/** Configures when this given processor can be executed in relation to other processors and processing groups, within its processing phase. */
	UPROPERTY(EditDefaultsOnly, Category = Processor, config)
	FMassProcessorExecutionOrder ExecutionOrder;

	/** Processing phase this processor will be automatically run as part of. Needs to be set before the processor gets
	 *  registered with MassProcessingPhaseManager, otherwise it will have no effect. This property is usually read via
	 *  a given class's CDO, so it's recommended to set it in the constructor. */
	UPROPERTY(EditDefaultsOnly, Category = Processor, config)
	EMassProcessingPhase ProcessingPhase = EMassProcessingPhase::PrePhysics;

	/** Whether this processor should be executed on StandAlone or Server or Client */
	UPROPERTY(EditAnywhere, Category = "Pipeline", meta = (Bitmask, BitmaskEnum = "/Script/MassEntity.EProcessorExecutionFlags"), config)
	uint8 ExecutionFlags;

	/** Configures whether this processor should be automatically included in the global list of processors executed every tick (see ProcessingPhase and ExecutionOrder). */
	UPROPERTY(EditDefaultsOnly, Category = Processor, config)
	uint8 bAutoRegisterWithProcessingPhases : 1 = true;

	/** Meant as a class property, make sure to set it in subclass' constructor. Controls whether there can be multiple
	 *  instances of a given class in a single FMassRuntimePipeline and during dependency solving. */
	uint8 bAllowMultipleInstances : 1 = false;

private:
	/**
	 * Gets set to true when an instance of the processor gets added to the phase processing as a "dynamic processor".
	 * Once set it's never expected to be cleared out to `false` thus the private visibility of the member variable.
	 * A "dynamic" processor is a one that has bAutoRegisterWithProcessingPhases == false, meaning it's not automatically
	 * added to the processing graph. Additionally, making processors dynamic allows one to have multiple instances
	 * of processors of the same class. 
	 * @see MarkAsDynamic()
	 * @see IsDynamic()
	 */
	uint8 bIsDynamic : 1 = false;

	/** Used to track whether Initialized has been called. */
	uint8 bInitialized : 1 = false;

protected:
	UPROPERTY(EditDefaultsOnly, Category = Processor, config)
	uint8 bRequiresGameThreadExecution : 1 = false;

#if WITH_EDITORONLY_DATA
	/** Used to permanently remove a given processor class from PipeSetting's listing. Used primarily for test-time 
	 *  processor classes, but can also be used by project-specific code to prune the processor list. */
	UPROPERTY(config)
	uint8 bCanShowUpInSettings : 1 = true;
#endif // WITH_EDITORONLY_DATA

	friend UMassCompositeProcessor;
	friend FMassDebugger;

	/** A query representing elements this processor is accessing in Execute function outside of query execution */
	FMassSubsystemRequirements ProcessorRequirements;

private:
	/** Stores processor's queries registered via RegisterQuery. 
	 *  @note that it's safe to store pointers here since RegisterQuery does verify that a given registered query is 
	 *  a member variable of a given processor */
	TArray<FMassEntityQuery*> OwnedQueries;
};


UCLASS()
class MASSENTITY_API UMassCompositeProcessor : public UMassProcessor
{
	GENERATED_BODY()

	friend FMassDebugger;
public:
	struct FDependencyNode
	{
		FName Name;
		UMassProcessor* Processor = nullptr;
		TArray<int32> Dependencies;
#if WITH_MASSENTITY_DEBUG
		int32 SequenceIndex = INDEX_NONE;
#endif // WITH_MASSENTITY_DEBUG
	};

public:
	UMassCompositeProcessor();

	void SetChildProcessors(TArray<UMassProcessor*>&& InProcessors);

	virtual void Initialize(UObject& Owner) override;
	virtual void DebugOutputDescription(FOutputDevice& Ar, int32 Indent = 0) const override;
	virtual void SetProcessingPhase(EMassProcessingPhase Phase) override;

	void SetGroupName(FName NewName);
	FName GetGroupName() const;

	virtual void SetProcessors(TArrayView<UMassProcessor*> InProcessorInstances, const TSharedPtr<FMassEntityManager>& EntityManager = nullptr);

	/** 
	 * Builds flat processing graph that's being used for multithreading execution of hosted processors.
	 */
	virtual void BuildFlatProcessingGraph(TConstArrayView<FMassProcessorOrderInfo> SortedProcessors);

	/**
	 * Adds processors in InOutOrderedProcessors to ChildPipeline. 
	 * Note that this operation is non-destructive for the existing processors - the ones of classes found in InOutOrderedProcessors 
	 * will be retained and used instead of the instances provided via InOutOrderedProcessors. Respective entries in InOutOrderedProcessors
	 * will be updated to reflect the reuse.
	 * The described behavior however is available only for processors with bAllowMultipleInstances == false.
	 */
	void UpdateProcessorsCollection(TArrayView<FMassProcessorOrderInfo> InOutOrderedProcessors, EProcessorExecutionFlags InWorldExecutionFlags = EProcessorExecutionFlags::None);

	/** adds SubProcessor to an appropriately named group. If RequestedGroupName == None then SubProcessor
	 *  will be added directly to ChildPipeline. If not then the indicated group will be searched for in ChildPipeline 
	 *  and if it's missing it will be created and AddGroupedProcessor will be called recursively */
	void AddGroupedProcessor(FName RequestedGroupName, UMassProcessor& SubProcessor);

	virtual FGraphEventRef DispatchProcessorTasks(const TSharedPtr<FMassEntityManager>& EntityManager, FMassExecutionContext& ExecutionContext, const FGraphEventArray& Prerequisites = FGraphEventArray()) override;

	bool IsEmpty() const;

	virtual FString GetProcessorName() const override;

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	/** RequestedGroupName can indicate a multi-level group name, like so: A.B.C
	 *  We need to extract the highest-level group name ('A' in the example), and see if it already exists. 
	 *  If not, create it. 
	 *  @param RequestedGroupName name of the group for which we want to find or create the processor.
	 *  @param OutRemainingGroupName contains the group name after cutting the high-level group. In the used example it
	 *    will contain "B.C". This value is then used to recursively create subgroups */
	UMassCompositeProcessor* FindOrAddGroupProcessor(FName RequestedGroupName, FString* OutRemainingGroupName = nullptr);

protected:
	UPROPERTY(VisibleAnywhere, Category=Mass)
	FMassRuntimePipeline ChildPipeline;

	/** Group name that will be used when resolving processor dependencies and grouping */
	UPROPERTY()
	FName GroupName;

	TArray<FDependencyNode> FlatProcessingGraph;

	struct FProcessorCompletion
	{
		FGraphEventRef CompletionEvent;
		EProcessorCompletionStatus Status = EProcessorCompletionStatus::Invalid;

		bool IsDone() const 
		{
			return Status == EProcessorCompletionStatus::Done || (CompletionEvent.IsValid() && CompletionEvent->IsComplete());
		}

		void Wait()
		{
			if (CompletionEvent.IsValid())
			{
				CompletionEvent->Wait();
			}
		}
	};
	TArray<FProcessorCompletion> CompletionStatus;

	//-----------------------------------------------------------------------------
	// DEPRECATED
	//-----------------------------------------------------------------------------
public:
	UE_DEPRECATED(5.3, "Populate is deprecated. Please use UpdateProcessorsCollection instead.")
	void Populate(TConstArrayView<FMassProcessorOrderInfo> OrderedProcessors);
};


//-----------------------------------------------------------------------------
// UMassProcessor inlines
//-----------------------------------------------------------------------------
inline bool UMassProcessor::IsInitialized() const
{
	return bInitialized;
}

inline EProcessorExecutionFlags UMassProcessor::GetExecutionFlags() const
{
	return static_cast<EProcessorExecutionFlags>(ExecutionFlags);
}

inline bool UMassProcessor::ShouldExecute(const EProcessorExecutionFlags CurrentExecutionFlags) const
{
	return (GetExecutionFlags() & CurrentExecutionFlags) != EProcessorExecutionFlags::None;
}

inline bool UMassProcessor::ShouldAllowMultipleInstances() const
{
	return bAllowMultipleInstances;
}

inline void UMassProcessor::DebugOutputDescription(FOutputDevice& Ar) const
{
	DebugOutputDescription(Ar, 0);
}

inline bool UMassProcessor::DoesRequireGameThreadExecution() const
{
	return bRequiresGameThreadExecution;
}
	
inline const FMassProcessorExecutionOrder& UMassProcessor::GetExecutionOrder() const
{
	return ExecutionOrder;
}

inline const FMassSubsystemRequirements& UMassProcessor::GetProcessorRequirements() const
{
	return ProcessorRequirements;
}

inline void UMassProcessor::MarkAsDynamic()
{
	bIsDynamic = true;
}

inline bool UMassProcessor::IsDynamic() const
{
	return bIsDynamic != 0;
}

inline bool UMassProcessor::ShouldAutoAddToGlobalList() const
{
	return bAutoRegisterWithProcessingPhases;
}

#if WITH_EDITOR
inline bool UMassProcessor::ShouldShowUpInSettings() const
{
	return ShouldAutoAddToGlobalList() || bCanShowUpInSettings;
}
#endif // WITH_EDITOR

//-----------------------------------------------------------------------------
// UMassCompositeProcessor inlines
//-----------------------------------------------------------------------------
inline FName UMassCompositeProcessor::GetGroupName() const
{
	return GroupName;
}

inline bool UMassCompositeProcessor::IsEmpty() const
{
	return ChildPipeline.IsEmpty();
}

=========================================


=== MassEntity/Public/MassProcessorDependencySolver.h ===
=========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassProcessingTypes.h"
#include "MassEntityTypes.h"
#include "MassArchetypeTypes.h"
#include "Containers/StaticArray.h"


class UMassProcessor;

namespace EMassAccessOperation
{
	constexpr uint32 Read = 0;
	constexpr uint32 Write = 1;
	constexpr uint32 MAX = 2;
};

template<typename T>
struct TMassExecutionAccess
{
	T Read;
	T Write;

	T& operator[](const uint32 OpIndex)
	{
		check(OpIndex <= EMassAccessOperation::MAX);
		return OpIndex == EMassAccessOperation::Read ? Read : Write;
	}

	const T& operator[](const uint32 OpIndex) const
	{
		check(OpIndex <= EMassAccessOperation::MAX);
		return OpIndex == EMassAccessOperation::Read ? Read : Write;
	}

	TConstArrayView<T> AsArrayView() const { return MakeArrayView(&Read, 2); }

	bool IsEmpty() const { return Read.IsEmpty() && Write.IsEmpty(); }
};

/** 
 * TMassExecutionAccess specialization for FMassConstSharedFragmentBitSet to enforce lack of access (not needed) and
 * no "Write" component (conceptually doesn't make sense).
 */
template<>
struct TMassExecutionAccess<FMassConstSharedFragmentBitSet>
{
	FMassConstSharedFragmentBitSet Read;
	TConstArrayView<FMassConstSharedFragmentBitSet> AsArrayView() const 
	{ 
		return MakeArrayView(&Read, 1); 
	}
	bool IsEmpty() const 
	{ 
		return Read.IsEmpty(); 
	}
};

struct MASSENTITY_API FMassExecutionRequirements
{
	void Append(const FMassExecutionRequirements& Other);
	void CountResourcesUsed();
	int32 GetTotalBitsUsedCount();
	bool IsEmpty() const;
	FMassArchetypeCompositionDescriptor AsCompositionDescriptor() const;

	TMassExecutionAccess<FMassFragmentBitSet> Fragments;
	TMassExecutionAccess<FMassChunkFragmentBitSet> ChunkFragments;
	TMassExecutionAccess<FMassSharedFragmentBitSet> SharedFragments;
	TMassExecutionAccess<FMassConstSharedFragmentBitSet> ConstSharedFragments;
	TMassExecutionAccess<FMassExternalSubsystemBitSet> RequiredSubsystems;
	FMassTagBitSet RequiredAllTags;
	FMassTagBitSet RequiredAnyTags;
	FMassTagBitSet RequiredNoneTags;
	int32 ResourcesUsedCount = INDEX_NONE;
};

struct FMassProcessorDependencySolver
{
private:
	struct FNode
	{
		FNode(const FName InName, UMassProcessor* InProcessor, const int32 InNodeIndex = INDEX_NONE) 
			: Name(InName), Processor(InProcessor), NodeIndex(InNodeIndex)
		{}

		bool IsGroup() const { return Processor == nullptr; }
		void IncreaseWaitingNodesCount(TArrayView<FNode> InAllNodes);

		FName Name = TEXT("");
		UMassProcessor* Processor = nullptr;
		TArray<int32> OriginalDependencies;
		TArray<int32> TransientDependencies;
		TArray<FName> ExecuteBefore;
		TArray<FName> ExecuteAfter;
		FMassExecutionRequirements Requirements;
		int32 NodeIndex = INDEX_NONE;
		/** indicates how often given node can be found in dependencies sequence for other nodes  */
		int32 TotalWaitingNodes = 0;
		/** 
		 * indicates how deep within dependencies graph this give node is, or in other words, what's the longest sequence 
		 * from this node to a dependency-less "parent" node 
		 */
		int32 SequencePositionIndex = 0;
		TArray<int32> SubNodeIndices;
		TArray<FMassArchetypeHandle> ValidArchetypes;
	};

	struct FResourceUsage
	{
		FResourceUsage(const TArray<FNode>& InAllNodes);

		bool CanAccessRequirements(const FMassExecutionRequirements& TestedRequirements, const TArray<FMassArchetypeHandle>& InArchetypes) const;
		void SubmitNode(const int32 NodeIndex, FNode& InOutNode);

	private:
		struct FResourceUsers
		{
			TArray<int32> Users;
		};
		
		struct FResourceAccess
		{
			TArray<FResourceUsers> Access;
		};
		
		FMassExecutionRequirements Requirements;
		TMassExecutionAccess<FResourceAccess> FragmentsAccess;
		TMassExecutionAccess<FResourceAccess> ChunkFragmentsAccess;
		TMassExecutionAccess<FResourceAccess> SharedFragmentsAccess;
		TMassExecutionAccess<FResourceAccess> RequiredSubsystemsAccess;
		TConstArrayView<FNode> AllNodesView;

		template<typename TBitSet>
		void HandleElementType(TMassExecutionAccess<FResourceAccess>& ElementAccess
			, const TMassExecutionAccess<TBitSet>& TestedRequirements, FMassProcessorDependencySolver::FNode& InOutNode, const int32 NodeIndex);

		template<typename TBitSet>
		static bool CanAccess(const TMassExecutionAccess<TBitSet>& StoredElements, const TMassExecutionAccess<TBitSet>& TestedElements);

		/** Determines whether any of the Elements' (i.e. Fragment, Tag,...) users operate on any of the archetypes given via InArchetypes */
		bool HasArchetypeConflict(TMassExecutionAccess<FResourceAccess> ElementAccess, const TArray<FMassArchetypeHandle>& InArchetypes) const;
	};

public:
	/** Optionally returned by ResolveDependencies and contains information about processors that have been pruned and 
	 *  other potentially useful bits. To be used in a transient fashion. */
	struct FResult
	{
		FString DependencyGraphFileName;
		TArray<TSubclassOf<UMassProcessor>> PrunedProcessorClasses;
		int32 MaxSequenceLength = 0;
		uint32 ArchetypeDataVersion = 0;

		void Reset()
		{
			PrunedProcessorClasses.Reset();
			MaxSequenceLength = 0;
			ArchetypeDataVersion = 0;
		}
	};

	MASSENTITY_API FMassProcessorDependencySolver(TArrayView<UMassProcessor* const> InProcessors, const bool bIsGameRuntime = true);
	MASSENTITY_API void ResolveDependencies(TArray<FMassProcessorOrderInfo>& OutResult, TSharedPtr<FMassEntityManager> EntityManager = nullptr, FResult* InOutOptionalResult = nullptr);

	MASSENTITY_API static void CreateSubGroupNames(FName InGroupName, TArray<FString>& SubGroupNames);

	/** Determines whether the dependency solving that produced InResult will produce different results if run with a given EntityManager */
	static bool IsResultUpToDate(const FResult& InResult, TSharedPtr<FMassEntityManager> EntityManager);

	bool IsSolvingForSingleThread() const { return bSingleThreadTarget; }

protected:
	// note that internals are protected rather than private to support unit testing

	/**
	 * Traverses InOutIndicesRemaining in search of the first RootNode's node that has no dependencies left. Once found 
	 * the node's index gets added to OutNodeIndices, removed from dependency lists from all other nodes and the function 
	 * quits.
	 * @return 'true' if a dependency-less node has been found and added to OutNodeIndices; 'false' otherwise.
	 */
	bool PerformSolverStep(FResourceUsage& ResourceUsage, TArray<int32>& InOutIndicesRemaining, TArray<int32>& OutNodeIndices);
	
	int32 CreateNodes(UMassProcessor& Processor);
	void BuildDependencies();
	void Solve(TArray<FMassProcessorOrderInfo>& OutResult);
	void LogNode(const FNode& Node, int Indent = 0);
	
	// @todo due to fundamental change to how nodes are organized the graph generation needs reimplementation
	// friend struct FDumpGraphDependencyUtils;
	// void DumpGraph(FArchive& LogFile) const;

	TArrayView<UMassProcessor* const> Processors;
	bool bAnyCyclesDetected = false;
	/**
	 * indicates whether we're generating processor order to be run in single- or multi-threaded environment (usually
	 * this meas Dedicated Server vs Any other configuration). In Single-Threaded mode we can skip a bunch of expensive, 
	 * fine tunning tests.
	 * @Note: currently the value depends on MASS_DO_PARALLEL and there's no way to configure it otherwise, but there's 
	 * nothing inherently stopping us from letting users configure it.
	 */
	const bool bSingleThreadTarget = bool(!MASS_DO_PARALLEL);
	const bool bGameRuntime = true;
	FString DependencyGraphFileName;
	TArray<FNode> AllNodes;
	TMap<FName, int32> NodeIndexMap;
};
=========================================================


=== MassEntity/Public/MassRequirementAccessDetector.h ===
=========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassProcessingTypes.h"
#if WITH_MASSENTITY_DEBUG
#include "Containers/ArrayView.h"
#include "MassEntityQuery.h"
#include "Misc/MTAccessDetector.h"

struct MASSENTITY_API FMassRequirementAccessDetector
{
	void Initialize();
	void RequireAccess(const FMassEntityQuery& Query);
	void ReleaseAccess(const FMassEntityQuery& Query);

private:
	using FDetectorMethod = bool (FRWAccessDetector::*)() const;
	template<typename TBitSet>
	void Operation(const TBitSet& BitSet, FDetectorMethod Op)
	{
		TArray<const UStruct*> Types;
		BitSet.ExportTypes(Types);
		for (const UStruct* Type : Types)
		{
			if (TSharedRef<FRWAccessDetector>* Detector = Detectors.Find(Type))
			{
				FRWAccessDetector& DetectorRef = Detector->Get();
				(DetectorRef.*Op)();
			}
		}
	}

	void Aquire(TConstArrayView<FMassFragmentRequirementDescription> Requirements)
	{
		for (const FMassFragmentRequirementDescription& Req : Requirements)
		{
			if (Req.Presence != EMassFragmentPresence::None)
			{
				if (Req.AccessMode == EMassFragmentAccess::ReadWrite)
				{
					Detectors.Find(Req.StructType)->Get().AcquireWriteAccess();
				}
				else if (Req.AccessMode == EMassFragmentAccess::ReadOnly)
				{
					Detectors.Find(Req.StructType)->Get().AcquireReadAccess();
				}
			}
		}
	}

	void Release(TConstArrayView<FMassFragmentRequirementDescription> Requirements)
	{
		for (const FMassFragmentRequirementDescription& Req : Requirements)
		{
			if (Req.Presence != EMassFragmentPresence::None)
			{
				if (Req.AccessMode == EMassFragmentAccess::ReadWrite)
				{
					Detectors.Find(Req.StructType)->Get().ReleaseWriteAccess();
				}
				else if (Req.AccessMode == EMassFragmentAccess::ReadOnly)
				{
					Detectors.Find(Req.StructType)->Get().ReleaseReadAccess();
				}
			}
		}
	}

	/** @Note the function is not thread-safe and meant to be only called internally on game thread (see FMassRequirementAccessDetector::Initialize) */
	void AddDetectors(const FStructTracker& StructTracker);

	TMap<const UStruct*, TSharedRef<FRWAccessDetector>> Detectors;
};
#endif // WITH_MASSENTITY_DEBUG
=========================================================


=== MassEntity/Public/MassRequirements.h ===
============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "MassRequirements.generated.h"

struct FMassDebugger;
struct FMassArchetypeHandle;
struct FMassExecutionRequirements;
struct FMassRequirementAccessDetector;

UENUM()
enum class EMassFragmentAccess : uint8
{
	/** no binding required */
	None, 

	/** We want to read the data for the fragment */
	ReadOnly,

	/** We want to read and write the data for the fragment */
	ReadWrite,

	MAX
};

UENUM()
enum class EMassFragmentPresence : uint8
{
	/** All of the required fragments must be present */
	All,

	/** One of the required fragments must be present */
	Any,

	/** None of the required fragments can be present */
	None,

	/** If fragment is present we'll use it, but it missing stop processing of a given archetype */
	Optional,

	MAX
};


struct MASSENTITY_API FMassFragmentRequirementDescription
{
	const UScriptStruct* StructType = nullptr;
	EMassFragmentAccess AccessMode = EMassFragmentAccess::None;
	EMassFragmentPresence Presence = EMassFragmentPresence::Optional;

public:
	FMassFragmentRequirementDescription(){}
	FMassFragmentRequirementDescription(const UScriptStruct* InStruct, const EMassFragmentAccess InAccessMode, const EMassFragmentPresence InPresence)
		: StructType(InStruct)
		, AccessMode(InAccessMode)
		, Presence(InPresence)
	{
		check(InStruct);
	}

	bool RequiresBinding() const { return (AccessMode != EMassFragmentAccess::None); }
	bool IsOptional() const { return (Presence == EMassFragmentPresence::Optional || Presence == EMassFragmentPresence::Any); }

	/** these functions are used for sorting. See FScriptStructSortOperator */
	int32 GetStructureSize() const
	{
		return StructType->GetStructureSize();
	}

	FName GetFName() const
	{
		return StructType->GetFName();
	}
};

/**
 *  FMassSubsystemRequirements is a structure that declares runtime subsystem access type given calculations require.
 */
USTRUCT()
struct MASSENTITY_API FMassSubsystemRequirements
{
	GENERATED_BODY()

	friend FMassDebugger;
	friend FMassRequirementAccessDetector;

	template<typename T>
	FMassSubsystemRequirements& AddSubsystemRequirement(const EMassFragmentAccess AccessMode)
	{
		check(AccessMode != EMassFragmentAccess::None && AccessMode != EMassFragmentAccess::MAX);

		// Compilation errors here like: 'GameThreadOnly': is not a member of 'TMassExternalSubsystemTraits<USmartObjectSubsystem>
		// indicate that there is a missing header that defines the subsystem's trait or that you need to define one for that subsystem type.
		// @see "MassExternalSubsystemTraits.h" for details

		switch (AccessMode)
		{
		case EMassFragmentAccess::ReadOnly:
			RequiredConstSubsystems.Add<T>();
			bRequiresGameThreadExecution |= TMassExternalSubsystemTraits<T>::GameThreadOnly;
			break;
		case EMassFragmentAccess::ReadWrite:
			RequiredMutableSubsystems.Add<T>();
			bRequiresGameThreadExecution |= TMassExternalSubsystemTraits<T>::GameThreadOnly;
			break;
		default:
			check(false);
		}

		return *this;
	}

	FMassSubsystemRequirements& AddSubsystemRequirement(const TSubclassOf<USubsystem> SubsystemClass, const EMassFragmentAccess AccessMode, const bool bGameThreadOnly = true)
	{
		check(AccessMode != EMassFragmentAccess::None && AccessMode != EMassFragmentAccess::MAX);

		switch (AccessMode)
		{
		case EMassFragmentAccess::ReadOnly:
			RequiredConstSubsystems.Add(**SubsystemClass);
			bRequiresGameThreadExecution |= bGameThreadOnly;
			break;
		case EMassFragmentAccess::ReadWrite:
			RequiredMutableSubsystems.Add(**SubsystemClass);
			bRequiresGameThreadExecution |= bGameThreadOnly;
			break;
		default:
			check(false);
		}

		return *this;
	}

	void Reset();

	const FMassExternalSubsystemBitSet& GetRequiredConstSubsystems() const { return RequiredConstSubsystems; }
	const FMassExternalSubsystemBitSet& GetRequiredMutableSubsystems() const { return RequiredMutableSubsystems; }
	bool IsEmpty() const { return RequiredConstSubsystems.IsEmpty() && RequiredMutableSubsystems.IsEmpty(); }

	bool DoesRequireGameThreadExecution() const { return bRequiresGameThreadExecution; }
	void ExportRequirements(FMassExecutionRequirements& OutRequirements) const;

protected:
	FMassExternalSubsystemBitSet RequiredConstSubsystems;
	FMassExternalSubsystemBitSet RequiredMutableSubsystems;

private:
	bool bRequiresGameThreadExecution = false;
};

/** 
 *  FMassFragmentRequirements is a structure that describes properties required of an archetype that's a subject of calculations.
 */
USTRUCT()
struct MASSENTITY_API FMassFragmentRequirements
{
	GENERATED_BODY()

	friend FMassDebugger;
	friend FMassRequirementAccessDetector;

public:
	FMassFragmentRequirements(){}
	FMassFragmentRequirements(std::initializer_list<UScriptStruct*> InitList);
	FMassFragmentRequirements(TConstArrayView<const UScriptStruct*> InitList);

	FMassFragmentRequirements& AddRequirement(const UScriptStruct* FragmentType, const EMassFragmentAccess AccessMode, const EMassFragmentPresence Presence = EMassFragmentPresence::All)
	{
		checkf(FragmentRequirements.FindByPredicate([FragmentType](const FMassFragmentRequirementDescription& Item){ return Item.StructType == FragmentType; }) == nullptr
			, TEXT("Duplicated requirements are not supported. %s already present"), *GetNameSafe(FragmentType));
		
		if (Presence != EMassFragmentPresence::None)
		{
			FragmentRequirements.Emplace(FragmentType, AccessMode, Presence);
		}

		switch (Presence)
		{
		case EMassFragmentPresence::All:
			RequiredAllFragments.Add(*FragmentType);
			break;
		case EMassFragmentPresence::Any:
			RequiredAnyFragments.Add(*FragmentType);
			break;
		case EMassFragmentPresence::Optional:
			RequiredOptionalFragments.Add(*FragmentType);
			break;
		case EMassFragmentPresence::None:
			RequiredNoneFragments.Add(*FragmentType);
			break;
		}
		// force recaching the next time this query is used or the following CacheArchetypes call.
		IncrementChangeCounter();
		return *this;
	}

	/** FMassFragmentRequirements ref returned for chaining */
	template<typename T>
	FMassFragmentRequirements& AddRequirement(const EMassFragmentAccess AccessMode, const EMassFragmentPresence Presence = EMassFragmentPresence::All)
	{
		checkf(FragmentRequirements.FindByPredicate([](const FMassFragmentRequirementDescription& Item) { return Item.StructType == T::StaticStruct(); }) == nullptr
			, TEXT("Duplicated requirements are not supported. %s already present"), *T::StaticStruct()->GetName());

		static_assert(TIsDerivedFrom<T, FMassFragment>::IsDerived, "Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.");
		
		if (Presence != EMassFragmentPresence::None)
		{
			FragmentRequirements.Emplace(T::StaticStruct(), AccessMode, Presence);
		}
		
		switch (Presence)
		{
		case EMassFragmentPresence::All:
			RequiredAllFragments.Add<T>();
			break;
		case EMassFragmentPresence::Any:
			RequiredAnyFragments.Add<T>();
			break;
		case EMassFragmentPresence::Optional:
			RequiredOptionalFragments.Add<T>();
			break;
		case EMassFragmentPresence::None:
			RequiredNoneFragments.Add<T>();
			break;
		}
		// force recaching the next time this query is used or the following CacheArchetypes call.
		IncrementChangeCounter();
		return *this;
	}

	void AddTagRequirement(const UScriptStruct& TagType, const EMassFragmentPresence Presence)
	{
		checkf(int(Presence) != int(EMassFragmentPresence::MAX), TEXT("MAX presence is not a valid value for AddTagRequirement"));
		switch (Presence)
		{
		case EMassFragmentPresence::All:
			RequiredAllTags.Add(TagType);
			break;
		case EMassFragmentPresence::Any:
			RequiredAnyTags.Add(TagType);
			break;
		case EMassFragmentPresence::None:
			RequiredNoneTags.Add(TagType);
			break;
		case EMassFragmentPresence::Optional:
			RequiredOptionalTags.Add(TagType);
			break;
		}
		IncrementChangeCounter();
	}

	template<typename T>
	FMassFragmentRequirements& AddTagRequirement(const EMassFragmentPresence Presence)
	{
		checkf(int(Presence) != int(EMassFragmentPresence::MAX), TEXT("MAX presence is not a valid value for AddTagRequirement"));
		static_assert(TIsDerivedFrom<T, FMassTag>::IsDerived, "Given struct doesn't represent a valid tag type. Make sure to inherit from FMassFragment or one of its child-types.");
		switch (Presence)
		{
			case EMassFragmentPresence::All:
				RequiredAllTags.Add<T>();
				break;
			case EMassFragmentPresence::Any:
				RequiredAnyTags.Add<T>();
				break;
			case EMassFragmentPresence::None:
				RequiredNoneTags.Add<T>();
				break;
			case EMassFragmentPresence::Optional:
				RequiredOptionalTags.Add<T>();
				break;
		}
		IncrementChangeCounter();
		return *this;
	}

	/** actual implementation in specializations */
	template<EMassFragmentPresence Presence> 
	FMassFragmentRequirements& AddTagRequirements(const FMassTagBitSet& TagBitSet)
	{
		static_assert(Presence == EMassFragmentPresence::None || Presence == EMassFragmentPresence::All || Presence == EMassFragmentPresence::Any
			, "The only valid values for AddTagRequirements are All, Any and None");
		return *this;
	}

	/** Clears given tags out of all collected requirements, including negative ones */
	FMassFragmentRequirements& ClearTagRequirements(const FMassTagBitSet& TagsToRemoveBitSet);

	template<typename T>
	FMassFragmentRequirements& AddChunkRequirement(const EMassFragmentAccess AccessMode, const EMassFragmentPresence Presence = EMassFragmentPresence::All)
	{
		static_assert(TIsDerivedFrom<T, FMassChunkFragment>::IsDerived, "Given struct doesn't represent a valid chunk fragment type. Make sure to inherit from FMassChunkFragment or one of its child-types.");
		checkf(ChunkFragmentRequirements.FindByPredicate([](const FMassFragmentRequirementDescription& Item) { return Item.StructType == T::StaticStruct(); }) == nullptr
			, TEXT("Duplicated requirements are not supported. %s already present"), *T::StaticStruct()->GetName());
		checkf(Presence != EMassFragmentPresence::Any, TEXT("\'Any\' is not a valid Presence value for AddChunkRequirement."));

		switch (Presence)
		{
			case EMassFragmentPresence::All:
				RequiredAllChunkFragments.Add<T>();
				ChunkFragmentRequirements.Emplace(T::StaticStruct(), AccessMode, Presence);
				break;
			case EMassFragmentPresence::Optional:
				RequiredOptionalChunkFragments.Add<T>();
				ChunkFragmentRequirements.Emplace(T::StaticStruct(), AccessMode, Presence);
				break;
			case EMassFragmentPresence::None:
				RequiredNoneChunkFragments.Add<T>();
				break;
		}
		IncrementChangeCounter();
		return *this;
	}

	template<typename T>
	FMassFragmentRequirements& AddConstSharedRequirement(const EMassFragmentPresence Presence = EMassFragmentPresence::All)
	{
		static_assert(TIsDerivedFrom<T, FMassConstSharedFragment>::IsDerived, "Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.");
		checkf(ConstSharedFragmentRequirements.FindByPredicate([](const FMassFragmentRequirementDescription& Item) { return Item.StructType == T::StaticStruct(); }) == nullptr
			, TEXT("Duplicated requirements are not supported. %s already present"), *T::StaticStruct()->GetName());
		checkf(Presence != EMassFragmentPresence::Any, TEXT("\'Any\' is not a valid Presence value for AddConstSharedRequirement."));

		switch (Presence)
		{
		case EMassFragmentPresence::All:
			RequiredAllConstSharedFragments.Add<T>();
			ConstSharedFragmentRequirements.Emplace(T::StaticStruct(), EMassFragmentAccess::ReadOnly, Presence);
			break;
		case EMassFragmentPresence::Optional:
			RequiredOptionalConstSharedFragments.Add<T>();
			ConstSharedFragmentRequirements.Emplace(T::StaticStruct(), EMassFragmentAccess::ReadOnly, Presence);
			break;
		case EMassFragmentPresence::None:
			RequiredNoneConstSharedFragments.Add<T>();
			break;
		}
		IncrementChangeCounter();
		return *this;
	}

	FMassFragmentRequirements& AddConstSharedRequirement(const UScriptStruct* FragmentType, const EMassFragmentPresence Presence = EMassFragmentPresence::All)
	{
		if (!ensureMsgf(FragmentType->IsChildOf(FMassConstSharedFragment::StaticStruct())
			, TEXT("Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.")))
		{
			return *this;
		}

		checkf(ConstSharedFragmentRequirements.FindByPredicate([FragmentType](const FMassFragmentRequirementDescription& Item) { return Item.StructType == FragmentType; }) == nullptr
			, TEXT("Duplicated requirements are not supported. %s already present"), *FragmentType->GetName());
		checkf(Presence != EMassFragmentPresence::Any, TEXT("\'Any\' is not a valid Presence value for AddConstSharedRequirement."));

		switch (Presence)
		{
		case EMassFragmentPresence::All:
			RequiredAllConstSharedFragments.Add(*FragmentType);
			ConstSharedFragmentRequirements.Emplace(FragmentType, EMassFragmentAccess::ReadOnly, Presence);
			break;
		case EMassFragmentPresence::Optional:
			RequiredOptionalConstSharedFragments.Add(*FragmentType);
			ConstSharedFragmentRequirements.Emplace(FragmentType, EMassFragmentAccess::ReadOnly, Presence);
			break;
		case EMassFragmentPresence::None:
			RequiredNoneConstSharedFragments.Add(*FragmentType);
			break;
		}
		IncrementChangeCounter();
		return *this;
	}

	template<typename T>
	FMassFragmentRequirements& AddSharedRequirement(const EMassFragmentAccess AccessMode, const EMassFragmentPresence Presence = EMassFragmentPresence::All)
	{
		static_assert(TIsDerivedFrom<T, FMassSharedFragment>::IsDerived, "Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.");
		checkf(SharedFragmentRequirements.FindByPredicate([](const FMassFragmentRequirementDescription& Item) { return Item.StructType == T::StaticStruct(); }) == nullptr
			, TEXT("Duplicated requirements are not supported. %s already present"), *T::StaticStruct()->GetName());
		checkf(Presence != EMassFragmentPresence::Any, TEXT("\'Any\' is not a valid Presence value for AddSharedRequirement."));

		switch (Presence)
		{
		case EMassFragmentPresence::All:
			RequiredAllSharedFragments.Add<T>();
			SharedFragmentRequirements.Emplace(T::StaticStruct(), AccessMode, Presence);
			if (AccessMode == EMassFragmentAccess::ReadWrite)
			{
				bRequiresGameThreadExecution |= TMassSharedFragmentTraits<T>::GameThreadOnly;
			}
			break;
		case EMassFragmentPresence::Optional:
			RequiredOptionalSharedFragments.Add<T>();
			SharedFragmentRequirements.Emplace(T::StaticStruct(), AccessMode, Presence);
			if (AccessMode == EMassFragmentAccess::ReadWrite)
			{
				bRequiresGameThreadExecution |= TMassSharedFragmentTraits<T>::GameThreadOnly;
			}
			break;
		case EMassFragmentPresence::None:
			RequiredNoneSharedFragments.Add<T>();
			break;
		}
		IncrementChangeCounter();
		return *this;
	}

	void Reset();

	/** 
	 * The function validates requirements we make for queries. See the FMassFragmentRequirements struct description for details.
	 * Even though the code of the function is non trivial the consecutive calls will be essentially free due to the result 
	 * being cached (note that the caching gets invalidated if the composition changes).
	 * @return whether this query's requirements follow the rules.
	 */
	bool CheckValidity() const;

	TConstArrayView<FMassFragmentRequirementDescription> GetFragmentRequirements() const { return FragmentRequirements; }
	TConstArrayView<FMassFragmentRequirementDescription> GetChunkFragmentRequirements() const { return ChunkFragmentRequirements; }
	TConstArrayView<FMassFragmentRequirementDescription> GetConstSharedFragmentRequirements() const { return ConstSharedFragmentRequirements; }
	TConstArrayView<FMassFragmentRequirementDescription> GetSharedFragmentRequirements() const { return SharedFragmentRequirements; }
	const FMassFragmentBitSet& GetRequiredAllFragments() const { return RequiredAllFragments; }
	const FMassFragmentBitSet& GetRequiredAnyFragments() const { return RequiredAnyFragments; }
	const FMassFragmentBitSet& GetRequiredOptionalFragments() const { return RequiredOptionalFragments; }
	const FMassFragmentBitSet& GetRequiredNoneFragments() const { return RequiredNoneFragments; }
	const FMassTagBitSet& GetRequiredAllTags() const { return RequiredAllTags; }
	const FMassTagBitSet& GetRequiredAnyTags() const { return RequiredAnyTags; }
	const FMassTagBitSet& GetRequiredNoneTags() const { return RequiredNoneTags; }
	const FMassTagBitSet& GetRequiredOptionalTags() const { return RequiredOptionalTags; }
	const FMassChunkFragmentBitSet& GetRequiredAllChunkFragments() const { return RequiredAllChunkFragments; }
	const FMassChunkFragmentBitSet& GetRequiredOptionalChunkFragments() const { return RequiredOptionalChunkFragments; }
	const FMassChunkFragmentBitSet& GetRequiredNoneChunkFragments() const { return RequiredNoneChunkFragments; }
	const FMassSharedFragmentBitSet& GetRequiredAllSharedFragments() const { return RequiredAllSharedFragments; }
	const FMassSharedFragmentBitSet& GetRequiredOptionalSharedFragments() const { return RequiredOptionalSharedFragments; }
	const FMassSharedFragmentBitSet& GetRequiredNoneSharedFragments() const { return RequiredNoneSharedFragments; }
	const FMassConstSharedFragmentBitSet& GetRequiredAllConstSharedFragments() const { return RequiredAllConstSharedFragments; }
	const FMassConstSharedFragmentBitSet& GetRequiredOptionalConstSharedFragments() const { return RequiredOptionalConstSharedFragments; }
	const FMassConstSharedFragmentBitSet& GetRequiredNoneConstSharedFragments() const { return RequiredNoneConstSharedFragments; }

	bool IsEmpty() const;
	bool HasPositiveRequirements() const { return bHasPositiveRequirements; }
	bool HasNegativeRequirements() const { return bHasNegativeRequirements; }
	bool HasOptionalRequirements() const { return bHasOptionalRequirements; }

	bool DoesArchetypeMatchRequirements(const FMassArchetypeHandle& ArchetypeHandle) const;
	bool DoesArchetypeMatchRequirements(const FMassArchetypeCompositionDescriptor& ArchetypeComposition) const;
	bool DoesMatchAnyOptionals(const FMassArchetypeCompositionDescriptor& ArchetypeComposition) const;

	bool DoesRequireGameThreadExecution() const { return bRequiresGameThreadExecution; }
	void ExportRequirements(FMassExecutionRequirements& OutRequirements) const;

protected:
	void SortRequirements();

	FORCEINLINE void IncrementChangeCounter() 
	{ 
		++IncrementalChangesCount; 
		bPropertiesCached = false;
	}
	void ConsumeIncrementalChangesCount() { IncrementalChangesCount = 0; }
	bool HasIncrementalChanges() const{ return IncrementalChangesCount > 0; }

protected:
	friend FMassRequirementAccessDetector;

	TArray<FMassFragmentRequirementDescription> FragmentRequirements;
	TArray<FMassFragmentRequirementDescription> ChunkFragmentRequirements;
	TArray<FMassFragmentRequirementDescription> ConstSharedFragmentRequirements;
	TArray<FMassFragmentRequirementDescription> SharedFragmentRequirements;
	FMassTagBitSet RequiredAllTags;
	FMassTagBitSet RequiredAnyTags;
	FMassTagBitSet RequiredNoneTags;
	/**
	 * note that optional tags have meaning only if there are no other strict requirements, i.e. everything is optional,
	 * so we're looking for anything matching any of the optionals (both tags as well as fragments).
	 */
	FMassTagBitSet RequiredOptionalTags;
	FMassFragmentBitSet RequiredAllFragments;
	FMassFragmentBitSet RequiredAnyFragments;
	FMassFragmentBitSet RequiredOptionalFragments;
	FMassFragmentBitSet RequiredNoneFragments;
	FMassChunkFragmentBitSet RequiredAllChunkFragments;
	FMassChunkFragmentBitSet RequiredOptionalChunkFragments;
	FMassChunkFragmentBitSet RequiredNoneChunkFragments;
	FMassSharedFragmentBitSet RequiredAllSharedFragments;
	FMassSharedFragmentBitSet RequiredOptionalSharedFragments;
	FMassSharedFragmentBitSet RequiredNoneSharedFragments;
	FMassConstSharedFragmentBitSet RequiredAllConstSharedFragments;
	FMassConstSharedFragmentBitSet RequiredOptionalConstSharedFragments;
	FMassConstSharedFragmentBitSet RequiredNoneConstSharedFragments;

private:
	FORCEINLINE void CachePropreties() const;
	mutable uint16 bPropertiesCached : 1 = false;
	mutable uint16 bHasPositiveRequirements : 1 = false;
	mutable uint16 bHasNegativeRequirements : 1 = false;
	/** 
	 * Indicates that the requirements specify only optional elements, which means any composition having any one of 
	 * the optional elements will be accepted. Note that RequiredNone* requirements are handled separately and if specified 
	 * still need to be satisfied.
	 */
	//mutable uint16 bOptionalsOnly : 1 = false;
	mutable uint16 bHasOptionalRequirements : 1 = false;

	uint16 IncrementalChangesCount = 0;

	bool bRequiresGameThreadExecution = false;
};

template<>
FORCEINLINE FMassFragmentRequirements& FMassFragmentRequirements::AddTagRequirements<EMassFragmentPresence::All>(const FMassTagBitSet& TagBitSet)
{
	RequiredAllTags += TagBitSet;
	// force recaching the next time this query is used or the following CacheArchetypes call.
	IncrementChangeCounter();
	return *this;
}

template<>
FORCEINLINE FMassFragmentRequirements& FMassFragmentRequirements::AddTagRequirements<EMassFragmentPresence::Any>(const FMassTagBitSet& TagBitSet)
{
	RequiredAnyTags += TagBitSet;
	// force recaching the next time this query is used or the following CacheArchetypes call.
	IncrementChangeCounter();
	return *this;
}

template<>
FORCEINLINE FMassFragmentRequirements& FMassFragmentRequirements::AddTagRequirements<EMassFragmentPresence::None>(const FMassTagBitSet& TagBitSet)
{
	RequiredNoneTags += TagBitSet;
	// force recaching the next time this query is used or the following CacheArchetypes call.
	IncrementChangeCounter();
	return *this;
}

template<>
FORCEINLINE FMassFragmentRequirements& FMassFragmentRequirements::AddTagRequirements<EMassFragmentPresence::Optional>(const FMassTagBitSet& TagBitSet)
{
	RequiredOptionalTags += TagBitSet;
	// force recaching the next time this query is used or the following CacheArchetypes call.
	IncrementChangeCounter();
	return *this;
}

============================================


=== MassEntity/Public/MassSettings.h ===
========================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Engine/DeveloperSettings.h"
#include "MassSettings.generated.h"


/** 
 * A common parrent for Mass's per-module settings. Classes extending this class will automatically get registered 
 * with- and show under Mass settings in Project Settings.
 */
UCLASS(Abstract, config = Mass, defaultconfig, collapseCategories)
class MASSENTITY_API UMassModuleSettings : public UObject
{
	GENERATED_BODY()
protected:
	virtual void PostInitProperties() override;
};


UCLASS(config = Mass, defaultconfig, DisplayName = "Mass", AutoExpandCategories = "Mass")
class MASSENTITY_API UMassSettings : public UDeveloperSettings
{
	GENERATED_BODY()

public:
	void RegisterModuleSettings(UMassModuleSettings& SettingsCDO);

public:
	UPROPERTY(VisibleAnywhere, Category = "Mass", NoClear, EditFixedSize, meta = (EditInline))
	TMap<FName, TObjectPtr<UMassModuleSettings>> ModuleSettings;
};

========================================


=== MassEntity/Public/MassSubsystemAccess.h ===
===============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "MassRequirements.h"
#include "Subsystems/EngineSubsystem.h"
#include "Subsystems/GameInstanceSubsystem.h"
#include "Subsystems/LocalPlayerSubsystem.h"
#include "Subsystems/WorldSubsystem.h"
#include "Engine/LocalPlayer.h"
#include "Engine/GameInstance.h"

#if WITH_EDITOR
#include "Editor.h"
#include "EditorSubsystem.h"
#else
#include "Engine/Engine.h"
#endif // WITH_EDITOR


struct MASSENTITY_API FMassSubsystemAccess
{
	explicit FMassSubsystemAccess(UWorld* InWorld = nullptr);

	//////////////////////////////////////////////////////////////////////////
	// Statically-typed subsystems

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	T* GetMutableSubsystem()
	{
		const uint32 SystemIndex = FMassExternalSubsystemBitSet::GetTypeIndex<T>();
		if (ensure(MutableSubsystemsBitSet.IsBitSet(SystemIndex)))
		{
			return GetSubsystemInternal<T>(SystemIndex);
		}

		return nullptr;
	}

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	T& GetMutableSubsystemChecked()
	{
		T* InstancePtr = GetMutableSubsystem<T>();
		check(InstancePtr);
		return *InstancePtr;
	}

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	const T* GetSubsystem()
	{
		const uint32 SystemIndex = FMassExternalSubsystemBitSet::GetTypeIndex<T>();
		if (ensure(ConstSubsystemsBitSet.IsBitSet(SystemIndex) || MutableSubsystemsBitSet.IsBitSet(SystemIndex)))
		{
			return GetSubsystemInternal<T>(SystemIndex);
		}
		return nullptr;
	}

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	const T& GetSubsystemChecked()
	{
		const T* InstancePtr = GetSubsystem<T>();
		check(InstancePtr);
		return *InstancePtr;
	}

	//////////////////////////////////////////////////////////////////////////
	// UClass-provided subsystems

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	T* GetMutableSubsystem(const TSubclassOf<USubsystem> SubsystemClass)
	{
		const uint32 SystemIndex = FMassExternalSubsystemBitSet::GetTypeIndex(**SubsystemClass);
		if (ensure(MutableSubsystemsBitSet.IsBitSet(SystemIndex)))
		{
			return GetSubsystemInternal<T>(SystemIndex, SubsystemClass);
		}

		return nullptr;
	}

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	T& GetMutableSubsystemChecked(const TSubclassOf<USubsystem> SubsystemClass)
	{
		T* InstancePtr = GetMutableSubsystem<T>(SubsystemClass);
		check(InstancePtr);
		return *InstancePtr;
	}

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	const T* GetSubsystem(const TSubclassOf<USubsystem> SubsystemClass)
	{
		const uint32 SystemIndex = FMassExternalSubsystemBitSet::GetTypeIndex(**SubsystemClass);
		if (ensure(ConstSubsystemsBitSet.IsBitSet(SystemIndex) || MutableSubsystemsBitSet.IsBitSet(SystemIndex)))
		{
			return GetSubsystemInternal<T>(SystemIndex, SubsystemClass);
		}
		return nullptr;
	}

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	const T& GetSubsystemChecked(const TSubclassOf<USubsystem> SubsystemClass)
	{
		const T* InstancePtr = GetSubsystem<T>(SubsystemClass);
		check(InstancePtr);
		return *InstancePtr;
	}

	//////////////////////////////////////////////////////////////////////////
	// remaining API

	bool CacheSubsystemRequirements(const FMassSubsystemRequirements& SubsystemRequirements);
	void SetSubsystemRequirements(const FMassSubsystemRequirements& SubsystemRequirements);

	void GetSubsystemRequirementBits(FMassExternalSubsystemBitSet& OutConstSubsystemsBitSet, FMassExternalSubsystemBitSet& OutMutableSubsystemsBitSet)
	{
		OutConstSubsystemsBitSet = ConstSubsystemsBitSet;
		OutMutableSubsystemsBitSet = MutableSubsystemsBitSet;
	}

	void SetSubsystemRequirementBits(const FMassExternalSubsystemBitSet& InConstSubsystemsBitSet, const FMassExternalSubsystemBitSet& InMutableSubsystemsBitSet)
	{
		ConstSubsystemsBitSet = InConstSubsystemsBitSet;
		MutableSubsystemsBitSet = InMutableSubsystemsBitSet;
	}

	template<typename T>
	static constexpr bool DoesRequireWorld()
	{
		constexpr bool bIsWorldSubsystem = TIsDerivedFrom<T, UWorldSubsystem>::IsDerived;
		constexpr bool bIsGameInstanceSubsystem = TIsDerivedFrom<T, UGameInstanceSubsystem>::IsDerived;
		constexpr bool bIsLocalPlayerSubsystem = TIsDerivedFrom<T, ULocalPlayerSubsystem>::IsDerived;

		return (bIsWorldSubsystem || bIsGameInstanceSubsystem || bIsLocalPlayerSubsystem);
	}

	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	static T* FetchSubsystemInstance(UWorld* World)
	{
		check(World);
		if constexpr (TIsDerivedFrom<T, UWorldSubsystem>::IsDerived)
		{
			return UWorld::GetSubsystem<T>(World);
		}
		else if constexpr (TIsDerivedFrom<T, UGameInstanceSubsystem>::IsDerived)
		{
			return UGameInstance::GetSubsystem<T>(World->GetGameInstance());
		}
		else if constexpr (TIsDerivedFrom<T, ULocalPlayerSubsystem>::IsDerived)
		{
			// note that this default implementation will work only for the first player in a local-coop game
			// to customize this behavior specialize the FetchSubsystemInstance template function for the type you need. 
			return ULocalPlayer::GetSubsystem<T>(World->GetFirstLocalPlayerFromController());
		}
		else
		{
			checkf(false, TEXT("FMassSubsystemAccess::FetchSubsystemInstance: Unhandled world-related USubsystem class %s"), *T::StaticClass()->GetName());
		}
	}
	
	template<typename T, typename = typename TEnableIf<TIsDerivedFrom<T, USubsystem>::IsDerived>::Type>
	static T* FetchSubsystemInstance()
	{
		if constexpr (TIsDerivedFrom<T, UEngineSubsystem>::IsDerived)
		{
			return GEngine->GetEngineSubsystem<T>();
		}
#if WITH_EDITOR
		else if constexpr (TIsDerivedFrom<T, UEditorSubsystem>::IsDerived)
		{
			return GEditor->GetEditorSubsystem<T>();
		}
#endif // WITH_EDITOR
		else
		{
			checkf(false, TEXT("FMassSubsystemAccess::FetchSubsystemInstance: Unhandled world-less USubsystem class %s"), *T::StaticClass()->GetName());
		}
	}

	static USubsystem* FetchSubsystemInstance(UWorld* World, TSubclassOf<USubsystem> SubsystemClass);

protected:
	template<typename T>
	T* GetSubsystemInternal(const uint32 SystemIndex)
	{
		if (UNLIKELY(Subsystems.IsValidIndex(SystemIndex) == false))
		{
			Subsystems.AddZeroed(Subsystems.Num() - SystemIndex + 1);
		}

		T* SystemInstance = (T*)Subsystems[SystemIndex];
		if (SystemInstance == nullptr)
		{
			if constexpr (DoesRequireWorld<T>())
			{
				SystemInstance = FetchSubsystemInstance<std::remove_const_t<T>>(World.Get());
			}
			else
			{
				SystemInstance = FetchSubsystemInstance<std::remove_const_t<T>>();
			}
			Subsystems[SystemIndex] = SystemInstance;
		}
		return SystemInstance;
	}

	template<typename T>
	T* GetSubsystemInternal(const uint32 SystemIndex, const TSubclassOf<USubsystem> SubsystemClass)
	{
		if (UNLIKELY(Subsystems.IsValidIndex(SystemIndex) == false))
		{
			Subsystems.AddZeroed(Subsystems.Num() - SystemIndex + 1);
		}

		USubsystem* SystemInstance = (T*)Subsystems[SystemIndex];
		if (SystemInstance == nullptr)
		{
			SystemInstance = FetchSubsystemInstance(World.Get(), SubsystemClass);
			Subsystems[SystemIndex] = SystemInstance;
		}
		return Cast<T>(SystemInstance);
	}

	bool CacheSubsystem(const uint32 SystemIndex);

	FMassExternalSubsystemBitSet ConstSubsystemsBitSet;
	FMassExternalSubsystemBitSet MutableSubsystemsBitSet;
	TArray<USubsystem*> Subsystems;
	TWeakObjectPtr<UWorld> World;
};

===============================================


=== MassEntity/Public/MassSubsystemBase.h ===
=============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Subsystems/WorldSubsystem.h"
#include "MassSubsystemBase.generated.h"


namespace UE::Mass::Subsystems
{
	struct FInitializationState
	{
		uint8 bInitializeCalled : 1 = false;
		uint8 bPostInitializeCalled : 1 = false;
		uint8 bOnWorldBeginPlayCalled : 1 = false;
	};
}

/** 
 * The sole responsibility of this world subsystem class is to serve functionality common to all 
 * Mass-related UWorldSubsystem-based subsystems, like whether the subsystems should get created at all. 
 */
UCLASS(Abstract)
class MASSENTITY_API UMassSubsystemBase : public UWorldSubsystem
{
	GENERATED_BODY()

public:
	static bool AreRuntimeMassSubsystemsAllowed(UObject* Outer);
	UE::Mass::Subsystems::FInitializationState GetInitializationState() const { return InitializationState; }

protected:
	//~USubsystem interface
	virtual bool ShouldCreateSubsystem(UObject* Outer) const override;
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void PostInitialize() override;
	virtual void Deinitialize() override;
	virtual void OnWorldBeginPlay(UWorld& InWorld) override;
	//~End of USubsystem interface

	/**
	 * Needs to be called in Initialize for subsystems we want to behave properly when dynamically added after UWorld::BeginPlay
	 * (for example via GameplayFeatureActions). This is required for subsystems relying on their PostInitialize and/or OnWorldBeginPlay called.
	 */
	void HandleLateCreation();

	/**
	 * Tracks which initialization function had already been called. Requires the child classes to call Super implementation
	 * for their Initialize, PostInitialize, Deinitialize and OnWorldBeginPlayCalled overrides
	 */
	UE::Mass::Subsystems::FInitializationState InitializationState;
};

/**
 * The sole responsibility of this tickable world subsystem class is to serve functionality common to all
 * Mass-related UTickableWorldSubsystem-based subsystems, like whether the subsystems should get created at all.
 */
UCLASS(Abstract)
class MASSENTITY_API UMassTickableSubsystemBase : public UTickableWorldSubsystem
{
	GENERATED_BODY()

public:
	UE::Mass::Subsystems::FInitializationState GetInitializationState() const { return InitializationState; }

protected:
	//~USubsystem interface
	virtual bool ShouldCreateSubsystem(UObject* Outer) const override;
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void PostInitialize() override;
	virtual void Deinitialize() override;
	virtual void OnWorldBeginPlay(UWorld& InWorld) override;
	//~End of USubsystem interface

	/**
	 * Needs to be called in Initialize for subsystems we want to behave properly when dynamically added after UWorld::BeginPlay
	 * (for example via GameplayFeatureActions). This is required for subsystems relying on their PostInitialize and/or OnWorldBeginPlay called.
	 */
	void HandleLateCreation();

private:
	/** 
	 * Tracks which initialization function had already been called. Requires the child classes to call Super implementation
	 * for their Initialize, PostInitialize, Deinitialize and OnWorldBeginPlayCalled overrides
	 */
	UE::Mass::Subsystems::FInitializationState InitializationState;
};

=============================================


=== MassEntity/MassEntity.Build.cs ===
======================================

// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class MassEntity : ModuleRules
{
	public MassEntity(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

		UnsafeTypeCastWarningLevel = WarningLevel.Warning;

		PublicDependencyModuleNames.AddRange(
			new string[] {
				"Core",
				"CoreUObject",
				"Engine",
				"DeveloperSettings",
			}
		);

		if (Target.bBuildEditor || Target.bCompileAgainstEditor)
		{
			PrivateDependencyModuleNames.Add("UnrealEd");
			PrivateDependencyModuleNames.Add("EditorSubsystem");
		}

		if (Target.Configuration != UnrealTargetConfiguration.Shipping
			&& Target.Configuration != UnrealTargetConfiguration.Test)
		{
			// pulling this one in for the testableEnsureMsgf
			PrivateDependencyModuleNames.Add("AITestSuite");
		}

		if (Target.bBuildDeveloperTools)
		{
			DynamicallyLoadedModuleNames.Add("MassEntityTestSuite");
		}
	}
}

======================================

