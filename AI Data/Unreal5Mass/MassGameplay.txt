=== CODEBASE STRUCTURE ===

📁 Source/
    └── 📁 MassActors/
        └── 📁 Private/
            └── 📁 Translators/
                └── 📄 MassCapsuleComponentTranslators.cpp
                └── 📄 MassCharacterMovementTranslators.cpp
                └── 📄 MassSceneComponentLocationTranslator.cpp
                └── 📄 MassTranslators_BehaviorTree.cpp
            └── 📄 MassActorHelper.cpp
            └── 📄 MassActorPoolableInterface.cpp
            └── 📄 MassActorsModule.cpp
            └── 📄 MassActorSpawnerSubsystem.cpp
            └── 📄 MassActorSubsystem.cpp
            └── 📄 MassActorTypes.cpp
            └── 📄 MassAgentComponent.cpp
            └── 📄 MassAgentSubsystem.cpp
            └── 📄 MassAgentTraits.cpp
        └── 📁 Public/
            └── 📁 Translators/
                └── 📄 MassCapsuleComponentTranslators.h
                └── 📄 MassCharacterMovementTranslators.h
                └── 📄 MassSceneComponentLocationTranslator.h
                └── 📄 MassTranslators_BehaviorTree.h
            └── 📄 IMassActorsModule.h
            └── 📄 MassActorHelper.h
            └── 📄 MassActorPoolableInterface.h
            └── 📄 MassActorSpawnerSubsystem.h
            └── 📄 MassActorSubsystem.h
            └── 📄 MassActorTypes.h
            └── 📄 MassAgentComponent.h
            └── 📄 MassAgentSubsystem.h
            └── 📄 MassAgentTraits.h
        └── 📄 MassActors.Build.cs
    └── 📁 MassCommon/
        └── 📁 Private/
            └── 📄 MassCommonModule.cpp
            └── 📄 MassCommonTypes.cpp
            └── 📄 MassCommonUtils.cpp
        └── 📁 Public/
            └── 📄 IMassCommonModule.h
            └── 📄 MassCommonFragments.h
            └── 📄 MassCommonTypes.h
            └── 📄 MassCommonUtils.h
            └── 📄 MassGameplaySettings.h
            └── 📄 RandomSequence.h
        └── 📄 MassCommon.Build.cs
    └── 📁 MassEQS/
        └── 📁 Private/
            └── 📁 Generators/
                └── 📄 MassEnvQueryGenerator_MassEntityHandles.cpp
                └── 📄 MassEnvQueryGenerator.cpp
            └── 📁 Items/
                └── 📄 EnvQueryItemType_MassEntityHandle.cpp
            └── 📁 Processors/
                └── 📄 MassEnvQueryGeneratorProcessor_MassEntityHandles.cpp
                └── 📄 MassEnvQueryProcessorBase.cpp
                └── 📄 MassEnvQueryTestProcessor_MassEntityTags.cpp
            └── 📁 Tests/
                └── 📄 MassEnvQueryTest_MassEntityTags.cpp
                └── 📄 MassEnvQueryTest.cpp
            └── 📄 MassEQS.cpp
            └── 📄 MassEQSBlueprintLibrary.cpp
            └── 📄 MassEQSSubsystem.cpp
            └── 📄 MassEQSTypes.cpp
            └── 📄 MassEQSUtils.cpp
        └── 📁 Public/
            └── 📁 Generators/
                └── 📄 MassEnvQueryGenerator_MassEntityHandles.h
                └── 📄 MassEnvQueryGenerator.h
            └── 📁 Items/
                └── 📄 EnvQueryItemType_MassEntityHandle.h
            └── 📁 Processors/
                └── 📄 MassEnvQueryGeneratorProcessor_MassEntityHandles.h
                └── 📄 MassEnvQueryProcessorBase.h
                └── 📄 MassEnvQueryTestProcessor_MassEntityTags.h
            └── 📁 Tests/
                └── 📄 MassEnvQueryTest_MassEntityTags.h
                └── 📄 MassEnvQueryTest.h
            └── 📄 MassEQS.h
            └── 📄 MassEQSBlueprintLibrary.h
            └── 📄 MassEQSSubsystem.h
            └── 📄 MassEQSTypes.h
            └── 📄 MassEQSUtils.h
        └── 📄 MassEQS.Build.cs
    └── 📁 MassGameplayDebug/
        └── 📁 Private/
            └── 📄 AssignDebugVisProcessor.cpp
            └── 📄 DebugVisLocationProcessor.cpp
            └── 📄 MassDebuggerSubsystem.cpp
            └── 📄 MassDebugVisualizationComponent.cpp
            └── 📄 MassDebugVisualizationTrait.cpp
            └── 📄 MassDebugVisualizer.cpp
            └── 📄 MassGameplayDebugModule.cpp
            └── 📄 MassGameplayDebugTypes.cpp
        └── 📁 Public/
            └── 📄 AssignDebugVisProcessor.h
            └── 📄 DebugVisLocationProcessor.h
            └── 📄 IMassGameplayDebugModule.h
            └── 📄 MassDebuggerSubsystem.h
            └── 📄 MassDebugVisualizationComponent.h
            └── 📄 MassDebugVisualizationTrait.h
            └── 📄 MassDebugVisualizer.h
            └── 📄 MassGameplayDebugTypes.h
        └── 📄 MassGameplayDebug.Build.cs
    └── 📁 MassGameplayEditor/
        └── 📁 Private/
            └── 📄 MassActorEditorSubsystem.cpp
            └── 📄 MassGameplayEditorModule.cpp
            └── 📄 MassTraitRepository.cpp
        └── 📁 Public/
            └── 📄 IMassGameplayEditor.h
            └── 📄 MassActorEditorSubsystem.h
            └── 📄 MassGameplayEditorModule.h
            └── 📄 MassTraitRepository.h
        └── 📄 MassGameplayEditor.Build.cs
    └── 📁 MassGameplayExternalTraits/
        └── 📁 Private/
            └── 📄 MassGameplayExternalTraitsModule.cpp
        └── 📁 Public/
            └── 📄 IMassGameplayExternalTraitsModule.h
            └── 📄 MassGameplayExternalTraits.h
        └── 📄 MassGameplayExternalTraits.Build.cs
    └── 📁 MassGameplayTestSuite/
        └── 📁 Private/
            └── 📄 MassEntityTemplateTest.cpp
            └── 📄 MassGameplayTestSuiteModule.cpp
        └── 📁 Public/
            └── 📄 MassGameplayTestSuiteModule.h
        └── 📄 MassGameplayTestSuite.Build.cs
    └── 📁 MassLOD/
        └── 📁 Private/
            └── 📄 MassLODCollectorProcessor.cpp
            └── 📄 MassLODDistanceCollectorProcessor.cpp
            └── 📄 MassLODLogic.cpp
            └── 📄 MassLODModule.cpp
            └── 📄 MassLODSubsystem.cpp
            └── 📄 MassLODTrait.cpp
            └── 📄 MassLODUtils.cpp
            └── 📄 MassSimulationLOD.cpp
        └── 📁 Public/
            └── 📄 IMassLODModule.h
            └── 📄 MassLODCalculator.h
            └── 📄 MassLODCollector.h
            └── 📄 MassLODCollectorProcessor.h
            └── 📄 MassLODDistanceCollectorProcessor.h
            └── 📄 MassLODFragments.h
            └── 📄 MassLODLogic.h
            └── 📄 MassLODSubsystem.h
            └── 📄 MassLODTickRateController.h
            └── 📄 MassLODTrait.h
            └── 📄 MassLODTypes.h
            └── 📄 MassLODUtils.h
            └── 📄 MassSimulationLOD.h
        └── 📄 MassLOD.Build.cs
    └── 📁 MassMovement/
        └── 📁 Private/
            └── 📄 MassMovementDelegates.cpp
            └── 📄 MassMovementFragments.cpp
            └── 📄 MassMovementModule.cpp
            └── 📄 MassMovementProcessors.cpp
            └── 📄 MassMovementSettings.cpp
            └── 📄 MassMovementTrait.cpp
            └── 📄 MassMovementTypes.cpp
            └── 📄 MassSimpleMovementTrait.cpp
            └── 📄 MassVelocityRandomizerTrait.cpp
        └── 📁 Public/
            └── 📁 Example/
                └── 📄 MassSimpleMovementTrait.h
                └── 📄 MassVelocityRandomizerTrait.h
            └── 📁 Movement/
                └── 📄 MassMovementProcessors.h
                └── 📄 MassMovementTrait.h
            └── 📄 IMassMovementModule.h
            └── 📄 MassMovementDelegates.h
            └── 📄 MassMovementFragments.h
            └── 📄 MassMovementSettings.h
            └── 📄 MassMovementTypes.h
        └── 📄 MassMovement.Build.cs
    └── 📁 MassMovementEditor/
        └── 📁 Private/
            └── 📄 MassMovementEditorModule.cpp
            └── 📄 MassMovementStyleRefDetails.cpp
        └── 📁 Public/
            └── 📄 IMassMovementEditor.h
            └── 📄 MassMovementEditorModule.h
            └── 📄 MassMovementPropertyUtils.h
            └── 📄 MassMovementStyleRefDetails.h
        └── 📄 MassMovementEditor.Build.cs
    └── 📁 MassReplication/
        └── 📁 Private/
            └── 📄 MassClientBubbleInfoBase.cpp
            └── 📄 MassClientBubbleSerializerBase.cpp
            └── 📄 MassReplicationFragments.cpp
            └── 📄 MassReplicationGridProcessor.cpp
            └── 📄 MassReplicationModule.cpp
            └── 📄 MassReplicationProcessor.cpp
            └── 📄 MassReplicationSubsystem.cpp
            └── 📄 MassReplicationTrait.cpp
            └── 📄 MassReplicationTransformHandlers.cpp
            └── 📄 MassReplicationTypes.cpp
        └── 📁 Public/
            └── 📄 IMassReplicationModule.h
            └── 📄 MassClientBubbleHandler.h
            └── 📄 MassClientBubbleInfoBase.h
            └── 📄 MassClientBubbleSerializerBase.h
            └── 📄 MassReplicationFragments.h
            └── 📄 MassReplicationGridProcessor.h
            └── 📄 MassReplicationProcessor.h
            └── 📄 MassReplicationSettings.h
            └── 📄 MassReplicationSubsystem.h
            └── 📄 MassReplicationTrait.h
            └── 📄 MassReplicationTransformHandlers.h
            └── 📄 MassReplicationTypes.h
        └── 📄 MassReplication.Build.cs
    └── 📁 MassRepresentation/
        └── 📁 Private/
            └── 📄 MassDistanceLODProcessor.cpp
            └── 📄 MassDistanceVisualizationTrait.cpp
            └── 📄 MassMovableVisualizationTrait.cpp
            └── 📄 MassRepresentationActorManagement.cpp
            └── 📄 MassRepresentationDebug.cpp
            └── 📄 MassRepresentationFragments.cpp
            └── 📄 MassRepresentationModule.cpp
            └── 📄 MassRepresentationProcessor.cpp
            └── 📄 MassRepresentationSubsystem.cpp
            └── 📄 MassRepresentationTypes.cpp
            └── 📄 MassStationaryDistanceVisualizationTrait.cpp
            └── 📄 MassStationaryISMRepresentationFragmentDestructor.cpp
            └── 📄 MassStationaryISMSwitcherProcessor.cpp
            └── 📄 MassStationaryVisualizationTrait.cpp
            └── 📄 MassUpdateISMProcessor.cpp
            └── 📄 MassVisualizationComponent.cpp
            └── 📄 MassVisualizationLODProcessor.cpp
            └── 📄 MassVisualizationTrait.cpp
            └── 📄 MassVisualizer.cpp
        └── 📁 Public/
            └── 📄 IMassRepresentationModule.h
            └── 📄 MassDistanceLODProcessor.h
            └── 📄 MassDistanceVisualizationTrait.h
            └── 📄 MassMovableVisualizationTrait.h
            └── 📄 MassRepresentationActorManagement.h
            └── 📄 MassRepresentationDebug.h
            └── 📄 MassRepresentationFragments.h
            └── 📄 MassRepresentationProcessor.h
            └── 📄 MassRepresentationSubsystem.h
            └── 📄 MassRepresentationTypes.h
            └── 📄 MassRepresentationUtils.h
            └── 📄 MassStationaryDistanceVisualizationTrait.h
            └── 📄 MassStationaryISMRepresentationFragmentDestructor.h
            └── 📄 MassStationaryISMSwitcherProcessor.h
            └── 📄 MassStationaryVisualizationTrait.h
            └── 📄 MassUpdateISMProcessor.h
            └── 📄 MassVisualizationComponent.h
            └── 📄 MassVisualizationLODProcessor.h
            └── 📄 MassVisualizationTrait.h
            └── 📄 MassVisualizer.h
        └── 📄 MassRepresentation.Build.cs
    └── 📁 MassSignals/
        └── 📁 Private/
            └── 📄 MassSignalProcessorBase.cpp
            └── 📄 MassSignalsModule.cpp
            └── 📄 MassSignalSubsystem.cpp
            └── 📄 MassSignalTypes.cpp
        └── 📁 Public/
            └── 📄 IMassSignalsModule.h
            └── 📄 MassSignalProcessorBase.h
            └── 📄 MassSignalSubsystem.h
            └── 📄 MassSignalTypes.h
        └── 📄 MassSignals.Build.cs
    └── 📁 MassSimulation/
        └── 📁 Private/
            └── 📄 MassSimulationModule.cpp
            └── 📄 MassSimulationSubsystem.cpp
        └── 📁 Public/
            └── 📄 IMassSimulationModule.h
            └── 📄 MassSimulationSettings.h
            └── 📄 MassSimulationSubsystem.h
        └── 📄 MassSimulation.Build.cs
    └── 📁 MassSmartObjects/
        └── 📁 Private/
            └── 📄 MassSmartObjectBehaviorDefinition.cpp
            └── 📄 MassSmartObjectHandler.cpp
            └── 📄 MassSmartObjectProcessor.cpp
            └── 📄 MassSmartObjectRegistration.cpp
            └── 📄 MassSmartObjectSettings.cpp
            └── 📄 MassSmartObjectsModule.cpp
            └── 📄 MassSmartObjectTypes.cpp
            └── 📄 MassSmartObjectUserTrait.cpp
            └── 📄 SmartObjectZoneAnnotations.cpp
        └── 📁 Public/
            └── 📄 IMassSmartObjectsModule.h
            └── 📄 MassSmartObjectBehaviorDefinition.h
            └── 📄 MassSmartObjectFragments.h
            └── 📄 MassSmartObjectHandler.h
            └── 📄 MassSmartObjectProcessor.h
            └── 📄 MassSmartObjectRegistration.h
            └── 📄 MassSmartObjectRequest.h
            └── 📄 MassSmartObjectSettings.h
            └── 📄 MassSmartObjectTypes.h
            └── 📄 MassSmartObjectUserTrait.h
            └── 📄 SmartObjectZoneAnnotations.h
        └── 📄 MassSmartObjects.Build.cs
    └── 📁 MassSpawner/
        └── 📁 Private/
            └── 📄 MassAssortedFragmentsTrait.cpp
            └── 📄 MassEntityConfigAsset.cpp
            └── 📄 MassEntityEQSSpawnPointsGenerator.cpp
            └── 📄 MassEntitySpawnDataGeneratorBase.cpp
            └── 📄 MassEntityTemplate.cpp
            └── 📄 MassEntityTemplateRegistry.cpp
            └── 📄 MassEntityTraitBase.cpp
            └── 📄 MassEntityZoneGraphSpawnPointsGenerator.cpp
            └── 📄 MassSpawner.cpp
            └── 📄 MassSpawnerModule.cpp
            └── 📄 MassSpawnerSubsystem.cpp
            └── 📄 MassSpawnerTypes.cpp
            └── 📄 MassSpawnLocationProcessor.cpp
            └── 📄 MassTranslator.cpp
        └── 📁 Public/
            └── 📄 IMassSpawnerModule.h
            └── 📄 MassAssortedFragmentsTrait.h
            └── 📄 MassEntityConfigAsset.h
            └── 📄 MassEntityEQSSpawnPointsGenerator.h
            └── 📄 MassEntitySpawnDataGeneratorBase.h
            └── 📄 MassEntityTemplate.h
            └── 📄 MassEntityTemplateRegistry.h
            └── 📄 MassEntityTraitBase.h
            └── 📄 MassEntityZoneGraphSpawnPointsGenerator.h
            └── 📄 MassSpawner.h
            └── 📄 MassSpawnerSubsystem.h
            └── 📄 MassSpawnerTypes.h
            └── 📄 MassSpawnLocationProcessor.h
            └── 📄 MassTranslator.h
        └── 📄 MassSpawner.Build.cs


=== FILE CONTENTS ===


=== Source/MassActors/Private/Translators/MassCapsuleComponentTranslators.cpp ===
=================================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "Translators/MassCapsuleComponentTranslators.h"
#include "MassCommonTypes.h"
#include "MassEntityManager.h"
#include "MassExecutionContext.h"
#include "Components/CapsuleComponent.h"


//----------------------------------------------------------------------//
// UMassCapsuleTransformToMassTranslator
//----------------------------------------------------------------------//
UMassCapsuleTransformToMassTranslator::UMassCapsuleTransformToMassTranslator()
	: EntityQuery(*this)
{
	ExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;
	RequiredTags.Add<FMassCapsuleTransformCopyToMassTag>();
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::SyncWorldToMass;
}

void UMassCapsuleTransformToMassTranslator::ConfigureQueries()
{
	AddRequiredTagsToQuery(EntityQuery);
	EntityQuery.AddRequirement<FCapsuleComponentWrapperFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);
}

void UMassCapsuleTransformToMassTranslator::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
		{
			const TConstArrayView<FCapsuleComponentWrapperFragment> CapsuleComponentList = Context.GetFragmentView<FCapsuleComponentWrapperFragment>();
			const TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();
			for (int i = 0; i < CapsuleComponentList.Num(); ++i)
			{
				if (const UCapsuleComponent* CapsuleComp = CapsuleComponentList[i].Component.Get())
				{
					LocationList[i].GetMutableTransform() = CapsuleComp->GetComponentTransform();
				}
			}
		});
}

//----------------------------------------------------------------------//
// UMassTransformToActorCapsuleTranslator
//----------------------------------------------------------------------//
UMassTransformToActorCapsuleTranslator::UMassTransformToActorCapsuleTranslator()
	: EntityQuery(*this)
{
	ExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;
	RequiredTags.Add<FMassCapsuleTransformCopyToActorTag>();
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::UpdateWorldFromMass;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Movement);
	bRequiresGameThreadExecution = true;
}

void UMassTransformToActorCapsuleTranslator::ConfigureQueries()
{
	AddRequiredTagsToQuery(EntityQuery);
	EntityQuery.AddRequirement<FCapsuleComponentWrapperFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.RequireMutatingWorldAccess(); // due to mutating World by setting component transform
}

void UMassTransformToActorCapsuleTranslator::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
		{
			const TArrayView<FCapsuleComponentWrapperFragment> CapsuleComponentList = Context.GetMutableFragmentView<FCapsuleComponentWrapperFragment>();
			const TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
			for (int i = 0; i < CapsuleComponentList.Num(); ++i)
			{
				if (UCapsuleComponent* CapsuleComp = CapsuleComponentList[i].Component.Get())
				{
					CapsuleComp->SetWorldTransform(LocationList[i].GetTransform(), /*bSweep=*/false);
				}
			}
		});
}

=================================================================================


=== Source/MassActors/Private/Translators/MassCharacterMovementTranslators.cpp ===
==================================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "Translators/MassCharacterMovementTranslators.h"
#include "Logging/LogMacros.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "VisualLogger/VisualLogger.h"
#include "MassEntityManager.h"
#include "MassCommonTypes.h"
#include "MassExecutionContext.h"
#include "MassMovementFragments.h"
#include "MassSpawnerTypes.h"

//----------------------------------------------------------------------//
//  UMassCharacterMovementToMassTranslator
//----------------------------------------------------------------------//
UMassCharacterMovementToMassTranslator::UMassCharacterMovementToMassTranslator()
	: EntityQuery(*this)
{
	ExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::SyncWorldToMass;
	RequiredTags.Add<FMassCharacterMovementCopyToMassTag>();
	bRequiresGameThreadExecution = true;
}

void UMassCharacterMovementToMassTranslator::ConfigureQueries()
{
	AddRequiredTagsToQuery(EntityQuery);
	EntityQuery.AddRequirement<FCharacterMovementComponentWrapperFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadWrite);
}

void UMassCharacterMovementToMassTranslator::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
	{
		const TConstArrayView<FCharacterMovementComponentWrapperFragment> ComponentList = Context.GetFragmentView<FCharacterMovementComponentWrapperFragment>();
		const TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();
		const TArrayView<FMassVelocityFragment> VelocityList = Context.GetMutableFragmentView<FMassVelocityFragment>();

		const int32 NumEntities = Context.GetNumEntities();
		
		for (int32 i = 0; i < NumEntities; ++i)
		{
			if (const UCharacterMovementComponent* AsMovementComponent = ComponentList[i].Component.Get())
			{
				LocationList[i].GetMutableTransform().SetLocation(AsMovementComponent->GetActorNavLocation());
				
				VelocityList[i].Value = AsMovementComponent->Velocity;
			}
		}
	});
}

//----------------------------------------------------------------------//
//  UMassCharacterMovementToActorTranslator
//----------------------------------------------------------------------//
UMassCharacterMovementToActorTranslator::UMassCharacterMovementToActorTranslator()
	: EntityQuery(*this)
{
	ExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::UpdateWorldFromMass;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Movement);
	RequiredTags.Add<FMassCharacterMovementCopyToActorTag>();
	bRequiresGameThreadExecution = true;
}

void UMassCharacterMovementToActorTranslator::ConfigureQueries()
{
	AddRequiredTagsToQuery(EntityQuery);
	EntityQuery.AddRequirement<FCharacterMovementComponentWrapperFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadOnly);
}

void UMassCharacterMovementToActorTranslator::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
	{
		const TArrayView<FCharacterMovementComponentWrapperFragment> ComponentList = Context.GetMutableFragmentView<FCharacterMovementComponentWrapperFragment>();
		const TConstArrayView<FMassVelocityFragment> VelocityList = Context.GetFragmentView<FMassVelocityFragment>();
		
		const int32 NumEntities = Context.GetNumEntities();

		for (int32 i = 0; i < NumEntities; ++i)
		{
			if (UCharacterMovementComponent* AsMovementComponent = ComponentList[i].Component.Get())
			{
				AsMovementComponent->RequestDirectMove(VelocityList[i].Value, /*bForceMaxSpeed=*/false);
			}
		}
	});
}

//----------------------------------------------------------------------//
//  UMassCharacterOrientationToMassTranslator
//----------------------------------------------------------------------//
UMassCharacterOrientationToMassTranslator::UMassCharacterOrientationToMassTranslator()
	: EntityQuery(*this)
{
	ExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::SyncWorldToMass;
	RequiredTags.Add<FMassCharacterOrientationCopyToMassTag>();
	bRequiresGameThreadExecution = true;
}

void UMassCharacterOrientationToMassTranslator::ConfigureQueries()
{
	AddRequiredTagsToQuery(EntityQuery);
	EntityQuery.AddRequirement<FCharacterMovementComponentWrapperFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);
}

void UMassCharacterOrientationToMassTranslator::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
	{
		const TConstArrayView<FCharacterMovementComponentWrapperFragment> ComponentList = Context.GetFragmentView<FCharacterMovementComponentWrapperFragment>();
		const TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();

		const int32 NumEntities = Context.GetNumEntities();
		
		for (int32 i = 0; i < NumEntities; ++i)
		{
			if (const UCharacterMovementComponent* AsMovementComponent = ComponentList[i].Component.Get())
			{
				if (AsMovementComponent->UpdatedComponent != nullptr)
				{
					LocationList[i].GetMutableTransform().SetRotation(AsMovementComponent->UpdatedComponent->GetComponentTransform().GetRotation());
				}
			}
		}
	});
}

//----------------------------------------------------------------------//
//  UMassCharacterOrientationToActorTranslator
//----------------------------------------------------------------------//
UMassCharacterOrientationToActorTranslator::UMassCharacterOrientationToActorTranslator()
	: EntityQuery(*this)
{
	ExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::UpdateWorldFromMass;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Movement);
	RequiredTags.Add<FMassCharacterOrientationCopyToActorTag>();
	bRequiresGameThreadExecution = true;
}

void UMassCharacterOrientationToActorTranslator::ConfigureQueries()
{
	AddRequiredTagsToQuery(EntityQuery);
	EntityQuery.AddRequirement<FCharacterMovementComponentWrapperFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.RequireMutatingWorldAccess(); // due to mutating World by setting component rotation
}

void UMassCharacterOrientationToActorTranslator::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
	{
		const TArrayView<FCharacterMovementComponentWrapperFragment> ComponentList = Context.GetMutableFragmentView<FCharacterMovementComponentWrapperFragment>();
		const TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();
		
		const int32 NumEntities = Context.GetNumEntities();

		for (int32 i = 0; i < NumEntities; ++i)
		{
			if (UCharacterMovementComponent* AsMovementComponent = ComponentList[i].Component.Get())
			{
				if (AsMovementComponent->UpdatedComponent != nullptr)
				{
					const FTransformFragment& Transform = TransformList[i];
					AsMovementComponent->bOrientRotationToMovement = false;
					AsMovementComponent->UpdatedComponent->SetWorldRotation(Transform.GetTransform().GetRotation());
				}
			}
		}
	});
}

==================================================================================


=== Source/MassActors/Private/Translators/MassSceneComponentLocationTranslator.cpp ===
======================================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "Translators/MassSceneComponentLocationTranslator.h"
#include "MassCommonTypes.h"
#include "Components/SceneComponent.h"
#include "MassExecutionContext.h"

//----------------------------------------------------------------------//
//  UMassSceneComponentLocationToMassTranslator
//----------------------------------------------------------------------//
UMassSceneComponentLocationToMassTranslator::UMassSceneComponentLocationToMassTranslator()
	: EntityQuery(*this)
{
	ExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::SyncWorldToMass;
	RequiredTags.Add<FMassSceneComponentLocationCopyToMassTag>();
}

void UMassSceneComponentLocationToMassTranslator::ConfigureQueries()
{
	AddRequiredTagsToQuery(EntityQuery);
	EntityQuery.AddRequirement<FMassSceneComponentWrapperFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);
}

void UMassSceneComponentLocationToMassTranslator::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
	{
		const TConstArrayView<FMassSceneComponentWrapperFragment> ComponentList = Context.GetFragmentView<FMassSceneComponentWrapperFragment>();
		const TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();

		const int32 NumEntities = Context.GetNumEntities();
		for (int32 i = 0; i < NumEntities; ++i)
		{
			if (const USceneComponent* AsComponent = ComponentList[i].Component.Get())
			{
				LocationList[i].GetMutableTransform().SetLocation(AsComponent->GetComponentTransform().GetLocation() - FVector(0.f, 0.f, AsComponent->Bounds.BoxExtent.Z));
			}
		}
	});
}

//----------------------------------------------------------------------//
//  UMassSceneComponentLocationToActorTranslator
//----------------------------------------------------------------------//
UMassSceneComponentLocationToActorTranslator::UMassSceneComponentLocationToActorTranslator()
	: EntityQuery(*this)
{
	ExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::UpdateWorldFromMass;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Movement);
	RequiredTags.Add<FMassSceneComponentLocationCopyToActorTag>();
	bRequiresGameThreadExecution = true;
}

void UMassSceneComponentLocationToActorTranslator::ConfigureQueries()
{
	AddRequiredTagsToQuery(EntityQuery);
	EntityQuery.AddRequirement<FMassSceneComponentWrapperFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.RequireMutatingWorldAccess(); // due to mutating World by setting actor's location
}

void UMassSceneComponentLocationToActorTranslator::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
		{
			const TConstArrayView<FMassSceneComponentWrapperFragment> ComponentList = Context.GetFragmentView<FMassSceneComponentWrapperFragment>();
			const TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();

			const int32 NumEntities = Context.GetNumEntities();
			for (int32 i = 0; i < NumEntities; ++i)
			{
				if (USceneComponent* AsComponent = ComponentList[i].Component.Get())
				{
					AsComponent->SetWorldLocation(LocationList[i].GetTransform().GetLocation() + FVector(0.f, 0.f, AsComponent->Bounds.BoxExtent.Z));
				}
			}
		});
}

======================================================================================


=== Source/MassActors/Private/Translators/MassTranslators_BehaviorTree.cpp ===
==============================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "Translators/MassTranslators_BehaviorTree.h"
#include "BehaviorTree/BehaviorTreeComponent.h"
#include "MassEntityManager.h"

UMassTranslator_BehaviorTree::UMassTranslator_BehaviorTree()
	: EntityQuery(*this)
{
	bAutoRegisterWithProcessingPhases = false;
}

void UMassTranslator_BehaviorTree::ConfigureQueries()
{
	EntityQuery.AddRequirement<FDataFragment_BehaviorTreeComponentWrapper>(EMassFragmentAccess::ReadWrite);
}

==============================================================================


=== Source/MassActors/Private/MassActorHelper.cpp ===
=====================================================

// Copyright Epic Games, Inc.All Rights Reserved.

#include "MassActorHelper.h"
#include "MassActorTypes.h"
#include "MassActorSubsystem.h"
#include "MassEntityManager.h"
#include "MassEntitySubsystem.h"
#include "Engine/World.h"

namespace UE::MassActor
{
	bool AddEntityTagToActor(const AActor& Actor, const UScriptStruct& TagType)
	{
		UWorld* World = Actor.GetWorld();
		UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(World);
		UMassActorSubsystem* MassActorSubsystem = UWorld::GetSubsystem<UMassActorSubsystem>(World);
		if (EntitySubsystem && MassActorSubsystem)
		{
			FMassEntityManager& EntityManager = EntitySubsystem->GetMutableEntityManager();
			const FMassEntityHandle AgentHandle = MassActorSubsystem->GetEntityHandleFromActor(&Actor);
			if (AgentHandle.IsValid())
			{
				EntityManager.AddTagToEntity(AgentHandle, &TagType);
				return true;
			}
			UE_LOG(LogMassActor, Warning, TEXT("Failed to add tag %s to actor %s due to it not having an associated entity")
				, *TagType.GetName(), *Actor.GetName());
		}
		else
		{
			UE_LOG(LogMassActor, Warning, TEXT("Failed to add tag %s to actor %s due to missing: %s%s")
				, *TagType.GetName(), *Actor.GetName(), EntitySubsystem ? TEXT("EntitySubsystem, ") : TEXT("")
				, MassActorSubsystem ? TEXT("MassActorSubsystem, ") : TEXT(""));
		}
		return false;
	}

	bool RemoveEntityTagFromActor(const AActor& Actor, const UScriptStruct& TagType)
	{
		UWorld* World = Actor.GetWorld();
		UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(World);
		UMassActorSubsystem* MassActorSubsystem = UWorld::GetSubsystem<UMassActorSubsystem>(World);
		if (EntitySubsystem && MassActorSubsystem)
		{
			const FMassEntityHandle AgentHandle = MassActorSubsystem->GetEntityHandleFromActor(&Actor);
			if (AgentHandle.IsValid())
			{
				FMassEntityManager& EntityManager = EntitySubsystem->GetMutableEntityManager();
				EntityManager.RemoveTagFromEntity(AgentHandle, &TagType);
				return true;
			}
			UE_LOG(LogMassActor, Warning, TEXT("Failed to remove tag %s from actor %s due to it not having an associated entity")
				, *TagType.GetName(), *Actor.GetName());
		}
		else
		{
			UE_LOG(LogMassActor, Warning, TEXT("Failed to remove tag %s from actor %s due to missing: %s%s")
				, *TagType.GetName(), *Actor.GetName(), EntitySubsystem ? TEXT("EntitySubsystem, ") : TEXT("")
				, MassActorSubsystem ? TEXT("MassActorSubsystem, ") : TEXT(""));
		}
		return false;
	}
} // namespace UE::MassActor

=====================================================


=== Source/MassActors/Private/MassActorPoolableInterface.cpp ===
================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassActorPoolableInterface.h"


UMassActorPoolableInterface::UMassActorPoolableInterface(FObjectInitializer const& InOI)
	: UInterface(InOI)
{
}
================================================================


=== Source/MassActors/Private/MassActorsModule.cpp ===
======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "CoreMinimal.h"
#include "IMassActorsModule.h"


class FMassActorsModule : public IMassActorsModule
{
	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

IMPLEMENT_MODULE(FMassActorsModule, MassActors)



void FMassActorsModule::StartupModule()
{
	// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)
}


void FMassActorsModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}




======================================================


=== Source/MassActors/Private/MassActorSpawnerSubsystem.cpp ===
===============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassActorSpawnerSubsystem.h"
#include "MassAgentComponent.h"
#include "MassSimulationSettings.h"
#include "Engine/World.h"
#include "MassActorTypes.h"
#include "VisualLogger/VisualLogger.h"
#include "MassActorPoolableInterface.h"
#include "MassSimulationSubsystem.h"
#include "Logging/LogScopedVerbosityOverride.h"
#include "ProfilingDebugging/CsvProfiler.h"
#include "Engine/Level.h"


CSV_DEFINE_CATEGORY(MassActors, true);

namespace UE::MassActors
{
	int32 bUseActorPooling = 1;
	FAutoConsoleVariableRef CVarDebugRepresentationLOD(TEXT("ai.mass.actorpooling"), bUseActorPooling, TEXT("Use Actor Pooling"), ECVF_Scalability);
}

//----------------------------------------------------------------------//
// UMassActorSpawnerSubsystem 
//----------------------------------------------------------------------//
void UMassActorSpawnerSubsystem::RetryActorSpawnRequest(const FMassActorSpawnRequestHandle SpawnRequestHandle)
{
	check(SpawnRequestHandleManager.IsValidHandle(SpawnRequestHandle));
	const int32 Index = SpawnRequestHandle.GetIndex();
	check(SpawnRequests.IsValidIndex(Index));
	FMassActorSpawnRequest& SpawnRequest = SpawnRequests[SpawnRequestHandle.GetIndex()].GetMutable<FMassActorSpawnRequest>();
	if (ensureMsgf(SpawnRequest.SpawnStatus == ESpawnRequestStatus::Failed, TEXT("Can only retry failed spawn requests")))
	{
		UWorld* World = GetWorld();
		check(World);

		SpawnRequest.SpawnStatus = ESpawnRequestStatus::RetryPending;
		SpawnRequest.SerialNumber = RequestSerialNumberCounter.fetch_add(1);
		SpawnRequest.RequestedTime = World->GetTimeSeconds();
	}
}

bool UMassActorSpawnerSubsystem::RemoveActorSpawnRequest(FMassActorSpawnRequestHandle& SpawnRequestHandle)
{
	if (!ensureMsgf(SpawnRequestHandleManager.RemoveHandle(SpawnRequestHandle), TEXT("Invalid spawn request handle")))
	{
		return false;
	}

	check(SpawnRequests.IsValidIndex(SpawnRequestHandle.GetIndex()));
	FMassActorSpawnRequest& SpawnRequest = SpawnRequests[SpawnRequestHandle.GetIndex()].GetMutable<FMassActorSpawnRequest>();
	check(SpawnRequest.SpawnStatus != ESpawnRequestStatus::Processing);
	SpawnRequestHandle.Invalidate();
	SpawnRequest.Reset();
	return true;
}

void UMassActorSpawnerSubsystem::ConditionalDestroyActor(UWorld& World, AActor& ActorToDestroy)
{
	UWorld* ActorsWorld = ActorToDestroy.GetWorld();

	// we directly call DestroyActors only if they're tied to the current world.
	// Otherwise we rely on engine mechanics to get rid of them.
	if (ActorsWorld == &World)
	{
		World.DestroyActor(&ActorToDestroy);
	}
	else
	{
		ensureMsgf(ActorToDestroy.HasActorBegunPlay() == false, TEXT("Failed to destroy %s due to world mismatch, while the actor is still being valid (as indicated by HasActorBegunPlay() == true)")
			, *ActorToDestroy.GetName());
	}
}

void UMassActorSpawnerSubsystem::DestroyActor(AActor* Actor, bool bImmediate /*= false*/)
{
	check(Actor);

	// We need to unregister immediately MassAgentComponent as it will become out of sync with mass
	if (UMassAgentComponent* AgentComp = Actor->FindComponentByClass<UMassAgentComponent>())
	{
		// All we want here it to unregister with the subsysem, not unregister the component as we want to keep it for futher usage if we put the actor in the pool.
		AgentComp->UnregisterWithAgentSubsystem();
	}

	if(bImmediate)
	{
		if (!ReleaseActorToPool(Actor))
		{
			// Couldn't release actor back to pool, so destroy it
			UWorld* World = GetWorld();
			check(World);
			ConditionalDestroyActor(*World, *Actor);

			--NumActorSpawned;
		}
	}
	else
	{
		ActorsToDestroy.Add(Actor);
	}
}

bool UMassActorSpawnerSubsystem::ReleaseActorToPool(AActor* Actor)
{
	if (!IsActorPoolingEnabled())
	{
		return false;
	}

	const bool bIsPoolableActor = Actor->Implements<UMassActorPoolableInterface>();
	if (bIsPoolableActor && IMassActorPoolableInterface::Execute_CanBePooled(Actor))
	{
		UMassAgentComponent* AgentComp = Actor->FindComponentByClass<UMassAgentComponent>();
		if (!AgentComp || AgentComp->IsReadyForPooling())
		{
			IMassActorPoolableInterface::Execute_PrepareForPooling(Actor);
			Actor->SetActorHiddenInGame(true);
			if (AgentComp)
			{
				AgentComp->UnregisterWithAgentSubsystem();
			}

			auto& Pool = PooledActors.FindOrAdd(Actor->GetClass());
			checkf(Pool.Find(Actor) == INDEX_NONE, TEXT("Actor%s is already in the pool"), *AActor::GetDebugName(Actor));
			Pool.Add(Actor);
			++NumActorPooled;
			return true;
		}
	}
	return false;
}

FMassActorSpawnRequestHandle UMassActorSpawnerSubsystem::RequestActorSpawnInternal(const FConstStructView SpawnRequestView)
{
	// The handle manager has a freelist of the release indexes, so it can return us a index that we previously used.
	const FMassActorSpawnRequestHandle SpawnRequestHandle = SpawnRequestHandleManager.GetNextHandle();
	const int32 Index = SpawnRequestHandle.GetIndex();

	// Check if we need to grow the array, otherwise it is a previously released index that was returned.
	if (!SpawnRequests.IsValidIndex(Index))
	{
		checkf(SpawnRequests.Num() == Index, TEXT("This case should only be when we need to grow the array of one element."));
		SpawnRequests.Emplace(SpawnRequestView);
	}
	else
	{
		SpawnRequests[Index] = SpawnRequestView;
	}

	UWorld* World = GetWorld();
	check(World);

	// Initialize the spawn request status
	FMassActorSpawnRequest& SpawnRequest = GetMutableSpawnRequest<FMassActorSpawnRequest>(SpawnRequestHandle);
	SpawnRequest.SpawnStatus = ESpawnRequestStatus::Pending;
	SpawnRequest.SerialNumber = RequestSerialNumberCounter.fetch_add(1);
	SpawnRequest.RequestedTime = World->GetTimeSeconds();

	return SpawnRequestHandle;
}

// @todo investigate whether storing requests in a sorted array would improve overall perf - if AllHandles was sorted we
// wouldn't need to do any tests other than just checking if a thing is valid and not completed (i.e. pending or retry-pending).
FMassActorSpawnRequestHandle UMassActorSpawnerSubsystem::GetNextRequestToSpawn(int32& InOutHandleIndex) const
{
	const TArray<FMassActorSpawnRequestHandle>& AllHandles = SpawnRequestHandleManager.GetHandles();
	if (AllHandles.Num() == 0)
	{
		InOutHandleIndex = INDEX_NONE;
		return FMassActorSpawnRequestHandle();
	}

	FMassActorSpawnRequestHandle BestSpawnRequestHandle;
	float BestPriority = MAX_FLT;
	bool bBestIsPending = false;
	uint32 BestSerialNumber = MAX_uint32;
	int32 BestIndex = INDEX_NONE;
		
	int32 HandleIndex = InOutHandleIndex != INDEX_NONE ? ((InOutHandleIndex + 1) % AllHandles.Num()) : 0;
	const int32 IterationsLimit = (InOutHandleIndex == INDEX_NONE) ? AllHandles.Num() : (AllHandles.Num() - 1);
	
	for (int32 IterationIndex = 0; IterationIndex < IterationsLimit; ++IterationIndex, HandleIndex = (HandleIndex + 1) % AllHandles.Num())
	{
		const FMassActorSpawnRequestHandle SpawnRequestHandle = AllHandles[HandleIndex];
		if (!SpawnRequestHandle.IsValid())
		{
			continue;
		}
		const FMassActorSpawnRequest& SpawnRequest = GetSpawnRequest<FMassActorSpawnRequest>(SpawnRequestHandle);
		if (SpawnRequest.SpawnStatus == ESpawnRequestStatus::Pending)
		{
			if (!bBestIsPending ||
				SpawnRequest.Priority < BestPriority ||
				(SpawnRequest.Priority == BestPriority && SpawnRequest.SerialNumber < BestSerialNumber))
			{
				BestSpawnRequestHandle = SpawnRequestHandle;
				BestSerialNumber = SpawnRequest.SerialNumber;
				BestPriority = SpawnRequest.Priority;
				bBestIsPending = true;
				BestIndex = HandleIndex;
			}
		}
		else if (!bBestIsPending && SpawnRequest.SpawnStatus == ESpawnRequestStatus::RetryPending)
		{
			// No priority on retries just FIFO
			if (SpawnRequest.SerialNumber < BestSerialNumber)
			{
				BestSpawnRequestHandle = SpawnRequestHandle;
				BestSerialNumber = SpawnRequest.SerialNumber;
				BestIndex = HandleIndex;
			}
		}
	}

	InOutHandleIndex = BestIndex;
	return BestSpawnRequestHandle;
}

ESpawnRequestStatus UMassActorSpawnerSubsystem::SpawnOrRetrieveFromPool(FConstStructView SpawnRequestView, TObjectPtr<AActor>& OutSpawnedActor)
{
	const FMassActorSpawnRequest& SpawnRequest = SpawnRequestView.Get<const FMassActorSpawnRequest>();

	if (IsActorPoolingEnabled())
	{
		auto* Pool = PooledActors.Find(SpawnRequest.Template);

		if (Pool && Pool->Num() > 0)
		{
			AActor* PooledActor = (*Pool)[0];
			Pool->RemoveAt(0);
			--NumActorPooled;
			PooledActor->SetActorHiddenInGame(false);
			PooledActor->SetActorTransform(SpawnRequest.Transform, false, nullptr, ETeleportType::ResetPhysics);

			IMassActorPoolableInterface::Execute_PrepareForGame(PooledActor);

			if (UMassAgentComponent* AgentComp = PooledActor->FindComponentByClass<UMassAgentComponent>())
			{
				// normally this function gets called from UMassAgentComponent::OnRegister. We need to call it manually here
				// since we're bringing this actor our of a pool.
				AgentComp->RegisterWithAgentSubsystem();
			}

			OutSpawnedActor = PooledActor;
			return ESpawnRequestStatus::Succeeded;
		}
	}

	FActorSpawnParameters ActorSpawnParameters;
	ESpawnRequestStatus SpawnStatus = SpawnActor(SpawnRequestView, OutSpawnedActor, ActorSpawnParameters);

	if (SpawnStatus == ESpawnRequestStatus::Succeeded)
	{
		if (IsValidChecked(OutSpawnedActor))
		{
			++NumActorSpawned;
		}
	}
	else
	{
		UE_VLOG_CAPSULE(this, LogMassActor, Error,
					SpawnRequest.Transform.GetLocation(),
					SpawnRequest.Template.GetDefaultObject()->GetSimpleCollisionHalfHeight(),
					SpawnRequest.Template.GetDefaultObject()->GetSimpleCollisionRadius(),
					SpawnRequest.Transform.GetRotation(),
					FColor::Red,
					TEXT("Unable to spawn actor for Mass entity [%s]"), *SpawnRequest.MassAgent.DebugGetDescription());
	}

	return SpawnStatus;
}

TObjectPtr<AActor> UMassActorSpawnerSubsystem::FindActorByName(const FName ActorName, ULevel* OverrideLevel) const
{
	TObjectPtr<AActor> FoundActor;
	check(GetWorld());
	OverrideLevel = OverrideLevel ? OverrideLevel : GetWorld()->GetCurrentLevel();
	
	if (UObject* FoundObject = StaticFindObjectFast(nullptr, OverrideLevel, ActorName))
	{
		FoundActor = Cast<AActor>(FoundObject);
		if (FoundObject)
		{
			if (IsValid(FoundActor) == false)
			{
				FoundActor->ClearGarbage();
			}
		}
	}
	return FoundActor;
}

 ESpawnRequestStatus UMassActorSpawnerSubsystem::SpawnActor(FConstStructView SpawnRequestView, TObjectPtr<AActor>& OutSpawnedActor, FActorSpawnParameters& InOutSpawnParameters) const
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassActorSpawnerSubsystem::SpawnActor);

	UWorld* World = GetWorld();
	check(World);

	const FMassActorSpawnRequest& SpawnRequest = SpawnRequestView.Get<const FMassActorSpawnRequest>();

	if (SpawnRequest.Guid.IsValid())
	{
		// offsetting `D` by 1 since `0` has special meaning for FNames
		InOutSpawnParameters.Name = FName(FString::Printf(TEXT("%s_%ud_%ud_%ud"), *SpawnRequest.Template->GetName(), SpawnRequest.Guid.A, SpawnRequest.Guid.B, SpawnRequest.Guid.C), SpawnRequest.Guid.D + 1);
		//InOutSpawnParameters.OverrideLevel = InOutSpawnParameters.OverrideLevel ? OverrideLevel : World->GetCurrentLevel();

		OutSpawnedActor = FindActorByName(InOutSpawnParameters.Name, InOutSpawnParameters.OverrideLevel ? InOutSpawnParameters.OverrideLevel : World->GetCurrentLevel());
		if (OutSpawnedActor)
		{
			OutSpawnedActor->SetActorEnableCollision(true);
			OutSpawnedActor->SetActorHiddenInGame(false);
			return ESpawnRequestStatus::Succeeded;
		}
	}
	
	InOutSpawnParameters.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
	OutSpawnedActor = World->SpawnActor<AActor>(SpawnRequest.Template, SpawnRequest.Transform, InOutSpawnParameters);

	return IsValid(OutSpawnedActor) ? ESpawnRequestStatus::Succeeded : ESpawnRequestStatus::Failed;
}

void UMassActorSpawnerSubsystem::ProcessPendingSpawningRequest(const double MaxTimeSlicePerTick)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassActorSpawnerSubsystem::ProcessPendingSpawningRequest);

	SpawnRequestHandleManager.ShrinkHandles();

	const double TimeSliceEnd = FPlatformTime::Seconds() + MaxTimeSlicePerTick;

	const int32 IterationsLimit = SpawnRequestHandleManager.CalcNumUsedHandles();
	int32 IterationsCount = 0;

	while (FPlatformTime::Seconds() < TimeSliceEnd && IterationsCount++ < IterationsLimit)
	{
		const FMassActorSpawnRequestHandle SpawnRequestHandle = GetNextRequestToSpawn(StartingHandleIndex);

		// getting an invalid handle is fine - it indicates no more handles are there to be considered. 
		if (!SpawnRequestHandle.IsValid() 
			|| !SpawnRequestHandleManager.IsValidHandle(SpawnRequestHandle))
		{
			return;
		}

		FStructView SpawnRequestView = SpawnRequests[SpawnRequestHandle.GetIndex()];
		FMassActorSpawnRequest& SpawnRequest = SpawnRequestView.Get<FMassActorSpawnRequest>();

		if (!ensureMsgf(SpawnRequest.SpawnStatus == ESpawnRequestStatus::Pending ||
						SpawnRequest.SpawnStatus == ESpawnRequestStatus::RetryPending, TEXT("GetNextRequestToSpawn returned a request that was already processed, need to return only request with pending status.")))
		{
			return;
		}

		ESpawnRequestStatus Result = ProcessSpawnRequest(SpawnRequestHandle, SpawnRequestView, SpawnRequest);
		ensureMsgf(Result != ESpawnRequestStatus::None, TEXT("Getting ESpawnRequestStatus::None as a result in this context is unexpected. Needs to be investigated."));
	}
}

ESpawnRequestStatus UMassActorSpawnerSubsystem::ProcessSpawnRequest(const FMassActorSpawnRequestHandle SpawnRequestHandle)
{
	if (!SpawnRequestHandle.IsValid()
		|| !SpawnRequestHandleManager.IsValidHandle(SpawnRequestHandle))
	{
		return ESpawnRequestStatus::None;
	}

	FStructView SpawnRequestView = SpawnRequests[SpawnRequestHandle.GetIndex()];
	FMassActorSpawnRequest& SpawnRequest = SpawnRequestView.Get<FMassActorSpawnRequest>();

	return ProcessSpawnRequest(SpawnRequestHandle, SpawnRequestView, SpawnRequest);
}

ESpawnRequestStatus UMassActorSpawnerSubsystem::ProcessSpawnRequest(const FMassActorSpawnRequestHandle SpawnRequestHandle, FStructView SpawnRequestView, FMassActorSpawnRequest& SpawnRequest)
{
	if (!ensureMsgf(SpawnRequest.IsFinished() == false, TEXT("Finished spawn requests are not expected to be processed again. Bailing out.")))
	{
		// returning None rather than the actual SpawnRequest.SpawnStatus to indicate the issue has occurred. 
		return ESpawnRequestStatus::None;
	}

	// Do the spawning
	SpawnRequest.SpawnStatus = ESpawnRequestStatus::Processing;

	// Call the pre spawn delegate on the spawn request
	if (SpawnRequest.ActorPreSpawnDelegate.IsBound())
	{
		SpawnRequest.ActorPreSpawnDelegate.Execute(SpawnRequestHandle, SpawnRequestView);
	}

	SpawnRequest.SpawnStatus = SpawnOrRetrieveFromPool(SpawnRequestView, SpawnRequest.SpawnedActor);

	if (SpawnRequest.IsFinished())
	{
		if (SpawnRequest.SpawnStatus == ESpawnRequestStatus::Succeeded && IsValid(SpawnRequest.SpawnedActor))
		{
			if (UMassAgentComponent* AgentComp = SpawnRequest.SpawnedActor->FindComponentByClass<UMassAgentComponent>())
			{
				AgentComp->SetPuppetHandle(SpawnRequest.MassAgent);
			}
		}

		EMassActorSpawnRequestAction PostAction = EMassActorSpawnRequestAction::Remove;

		// Call the post spawn delegate on the spawn request
		if (SpawnRequest.ActorPostSpawnDelegate.IsBound())
		{
			PostAction = SpawnRequest.ActorPostSpawnDelegate.Execute(SpawnRequestHandle, SpawnRequestView);
		}

		if (PostAction == EMassActorSpawnRequestAction::Remove)
		{
			// If notified, remove the spawning request
			ensureMsgf(SpawnRequestHandleManager.RemoveHandle(SpawnRequestHandle), TEXT("When providing a delegate, the spawn request gets automatically removed, no need to remove it on your side"));
		}
	}
	else
	{
		// lower priority
		SpawnRequest.SpawnStatus = ESpawnRequestStatus::RetryPending;
	}

	return SpawnRequest.SpawnStatus;
}

void UMassActorSpawnerSubsystem::ProcessPendingDestruction(const double MaxTimeSlicePerTick)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassActorSpawnerSubsystem::ProcessPendingDestruction);

	UWorld* World = GetWorld();
	check(World);

	const ENetMode CurrentWorldNetMode = World->GetNetMode();
	const bool bHasToDestroyAllActorsOnServerSide = CurrentWorldNetMode != NM_Client && CurrentWorldNetMode != NM_Standalone;
	const double TimeSliceEnd = FPlatformTime::Seconds() + MaxTimeSlicePerTick;

	{
		// Try release to pool actors or destroy them
		TRACE_CPUPROFILER_EVENT_SCOPE(DestroyActors);
		while ((DeactivatedActorsToDestroy.Num() || ActorsToDestroy.Num()) && 
			   (bHasToDestroyAllActorsOnServerSide || FPlatformTime::Seconds() <= TimeSliceEnd))
		{
			AActor* ActorToDestroy = DeactivatedActorsToDestroy.Num() ? DeactivatedActorsToDestroy.Pop(EAllowShrinking::No) : ActorsToDestroy.Pop(EAllowShrinking::No);
			if (ActorToDestroy && !ReleaseActorToPool(ActorToDestroy))
			{
				// Couldn't release actor back to pool, so destroy it
				ConditionalDestroyActor(*World, *ActorToDestroy);
				--NumActorSpawned;
			}
		}
	}

	if(ActorsToDestroy.Num())
	{
		// Try release to pool remaining actors or deactivate them
		TRACE_CPUPROFILER_EVENT_SCOPE(DeactivateActors);
		for (AActor* ActorToDestroy : ActorsToDestroy)
		{
			if (!ReleaseActorToPool(ActorToDestroy))
			{
				// Couldn't release actor back to pool, do simple deactivate instead
				ActorToDestroy->SetActorEnableCollision(false);
				ActorToDestroy->SetActorHiddenInGame(true);
				ActorToDestroy->SetActorTickEnabled(false);
				DeactivatedActorsToDestroy.Add(ActorToDestroy);
			}
		}
		ActorsToDestroy.Reset();
	}
}

void UMassActorSpawnerSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	UMassSimulationSubsystem* SimSystem = Collection.InitializeDependency<UMassSimulationSubsystem>();
	check(SimSystem);

	Super::Initialize(Collection);

	SimSystem->GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).AddUObject(this, &UMassActorSpawnerSubsystem::OnPrePhysicsPhaseStarted);
	SimSystem->GetOnProcessingPhaseFinished(EMassProcessingPhase::PrePhysics).AddUObject(this, &UMassActorSpawnerSubsystem::OnPrePhysicsPhaseFinished);
}

void UMassActorSpawnerSubsystem::Deinitialize()
{
	Super::Deinitialize();

	if (const UWorld* World = GetWorld())
	{
		if (UMassSimulationSubsystem* SimSystem = UWorld::GetSubsystem<UMassSimulationSubsystem>(World))
		{
			SimSystem->GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).RemoveAll(this);
			SimSystem->GetOnProcessingPhaseFinished(EMassProcessingPhase::PrePhysics).RemoveAll(this);
		}
	}
}

void UMassActorSpawnerSubsystem::OnPrePhysicsPhaseStarted(const float DeltaSeconds)
{
	// Spawn actors before processors run so they can operate on deterministic actor state for the frame
	// 
	// Note: MassRepresentationProcessor relies on actor spawns being processed before it runs so it can confirm the
	// spawn and clean up the previous representation  
	ProcessPendingSpawningRequest(GET_MASSSIMULATION_CONFIG_VALUE(DesiredActorSpawningTimeSlicePerTick));

	CSV_CUSTOM_STAT(MassActors, NumSpawned, NumActorSpawned, ECsvCustomStatOp::Accumulate);
	CSV_CUSTOM_STAT(MassActors, NumPooled, NumActorPooled, ECsvCustomStatOp::Accumulate);
}

void UMassActorSpawnerSubsystem::OnPrePhysicsPhaseFinished(const float DeltaSeconds)
{
	// Destroy any actors queued for destruction this frame and hide any we didn't get to within the max processing time
	// 
	// Note: MassRepresentationProcessor relies on actor destruction processing after it runs so it can clean up
	// unwanted actor representations that it has replaced for this frame. It also relies on this running before physics
	// so unwanted representations don't interfere with new physics enabled actors 
	ProcessPendingDestruction(GET_MASSSIMULATION_CONFIG_VALUE(DesiredActorDestructionTimeSlicePerTick));
}

void UMassActorSpawnerSubsystem::AddReferencedObjects(UObject* InThis, FReferenceCollector& Collector)
{
	UMassActorSpawnerSubsystem* MASS = Cast<UMassActorSpawnerSubsystem>(InThis);
	if (MASS)
	{
		for (auto It = MASS->PooledActors.CreateIterator(); It; ++It)
		{
			Collector.AddReferencedObjects<AActor>(It.Value());
		}
	}

	Super::AddReferencedObjects(InThis, Collector);
}

void UMassActorSpawnerSubsystem::EnableActorPooling() 
{ 
	bActorPoolingEnabled = true; 
}

void UMassActorSpawnerSubsystem::DisableActorPooling() 
{
	bActorPoolingEnabled = false;

	ReleaseAllResources();

}

bool UMassActorSpawnerSubsystem::IsActorPoolingEnabled()
{
	return UE::MassActors::bUseActorPooling && bActorPoolingEnabled;
}

void UMassActorSpawnerSubsystem::ReleaseAllResources()
{
	if (UWorld* World = GetWorld())
	{
		for (auto It = PooledActors.CreateIterator(); It; ++It)
		{
			auto& ActorArray = It.Value();
			for (int i = 0; i < ActorArray.Num(); i++)
			{
				if (ActorArray[i])
				{
					ConditionalDestroyActor(*World, *ActorArray[i]);
				}
			}
			NumActorSpawned -= ActorArray.Num();
		}
	}
	PooledActors.Empty();

	NumActorPooled = 0;
	CSV_CUSTOM_STAT(MassActors, NumSpawned, NumActorSpawned, ECsvCustomStatOp::Accumulate);
	CSV_CUSTOM_STAT(MassActors, NumPooled, NumActorPooled, ECsvCustomStatOp::Accumulate);
}

//-----------------------------------------------------------------------------
// DEPRECATED
//-----------------------------------------------------------------------------
FMassActorSpawnRequestHandle UMassActorSpawnerSubsystem::GetNextRequestToSpawn() const
{
	int32 DummyIndex = 0;
	return GetNextRequestToSpawn(DummyIndex);
}

===============================================================


=== Source/MassActors/Private/MassActorSubsystem.cpp ===
========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassActorSubsystem.h"
#include "MassCommonTypes.h"
#include "MassActorTypes.h"
#include "Engine/World.h"
#include "MassEntityManager.h"
#include "MassEntitySubsystem.h"
#include "MassSimulationSubsystem.h"
#include "VisualLogger/VisualLogger.h"

//----------------------------------------------------------------------//
//  FMassActorFragment 
//----------------------------------------------------------------------//

void FMassActorFragment::SetAndUpdateHandleMap(const FMassEntityHandle MassAgent, AActor* InActor, const bool bInIsOwnedByMass)
{
	SetNoHandleMapUpdate(MassAgent, InActor, bInIsOwnedByMass);

	if (InActor)
	{
		UWorld* World = InActor->GetWorld();
		check(World);
		if (UMassActorSubsystem* MassActorSubsystem = UWorld::GetSubsystem<UMassActorSubsystem>(World))
		{
			MassActorSubsystem->SetHandleForActor(InActor, MassAgent);
		}
	}
}

void FMassActorFragment::ResetAndUpdateHandleMap(UMassActorSubsystem* CachedActorSubsystem)
{
	if (AActor* ActorPtr = Cast<AActor>(Actor.Get()))
	{
		if (CachedActorSubsystem == nullptr)
		{
			UWorld* World = Actor->GetWorld();
			UE_CLOG(World == nullptr, LogMassActor, Warning, TEXT("%hs: got Null while fetching World for actor %s. Can cause issues down the line. Pass in the optional CachedActorSubsystem parameter to address")
				, __FUNCTION__, *GetNameSafe(ActorPtr));
			CachedActorSubsystem = UWorld::GetSubsystem<UMassActorSubsystem>(World);
		}

		if (CachedActorSubsystem)
		{
			CachedActorSubsystem->RemoveHandleForActor(ActorPtr);
		}
	}

	ResetNoHandleMapUpdate();
}

void FMassActorFragment::SetNoHandleMapUpdate(const FMassEntityHandle MassAgent, AActor* InActor, const bool bInIsOwnedByMass)
{
	check(InActor);
	check(!Actor.IsValid());
	check(MassAgent.IsValid());
	Actor = InActor;
	bIsOwnedByMass = bInIsOwnedByMass;
}

void FMassActorFragment::ResetNoHandleMapUpdate()
{
	Actor.Reset();
	bIsOwnedByMass = false;
}

AActor* FMassActorFragment::GetMutable(EActorAccess Access)
{
	switch (Access)
	{
	case EActorAccess::OnlyWhenAlive:
		return Actor.Get();
	case EActorAccess::IncludePendingKill:
		return Actor.Get(true);
	case EActorAccess::IncludeUnreachable:
		return Actor.GetEvenIfUnreachable();
	default:
		checkf(false, TEXT("Invalid ActorAccess value: %i."), static_cast<int32>(Access));
		return nullptr;
	}
}

const AActor* FMassActorFragment::Get(EActorAccess Access) const
{
	return const_cast<FMassActorFragment*>(this)->GetMutable(Access);
}

//----------------------------------------------------------------------//
//  UMassActorSubsystem 
//----------------------------------------------------------------------//
void UMassActorSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);
	// making sure UMassSimulationSubsystem gets created before the MassActorSubsystem
	Collection.InitializeDependency<UMassSimulationSubsystem>();
	
	if (UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(GetWorld()))
	{
		ActorManager = MakeShareable(new FMassActorManager(EntitySubsystem->GetMutableEntityManager().AsShared()));
	}
}

void UMassActorSubsystem::Deinitialize()
{
	ActorManager.Reset();
	Super::Deinitialize();
}

//----------------------------------------------------------------------//
//  FMassActorManager
//----------------------------------------------------------------------//
FMassActorManager::FMassActorManager(const TSharedPtr<FMassEntityManager>& InEntityManager, UObject* InOwner)
	: EntityManager(InEntityManager)
	, Owner(InOwner)
{

}

FMassEntityHandle FMassActorManager::GetEntityHandleFromActor(const TObjectKey<const AActor> Actor)
{
	checkSlow(EntityManager);

	UE_MT_SCOPED_READ_ACCESS(ActorHandleMapDetector);
	FMassEntityHandle* Entity = ActorHandleMap.Find(Actor);
	if (Entity == nullptr || EntityManager->IsEntityValid(*Entity) == false)
	{
		return FMassEntityManager::InvalidEntity;
	}

	check(TObjectKey<const AActor>(GetActorFromHandle(*Entity, FMassActorFragment::EActorAccess::IncludeUnreachable)) == Actor);
	return *Entity;
}

AActor* FMassActorManager::GetActorFromHandle(const FMassEntityHandle Handle, FMassActorFragment::EActorAccess Access) const
{
	check(EntityManager);
	FMassActorFragment* Data = EntityManager->GetFragmentDataPtr<FMassActorFragment>(Handle);
	return Data != nullptr ? Data->GetMutable(Access) : nullptr;
}

void FMassActorManager::SetHandleForActor(const TObjectKey<const AActor> Actor, const FMassEntityHandle Handle)
{
	UE_MT_SCOPED_WRITE_ACCESS(ActorHandleMapDetector);
	ActorHandleMap.Add(Actor, Handle);
}

void FMassActorManager::RemoveHandleForActor(const TObjectKey<const AActor> Actor)
{
	UE_MT_SCOPED_WRITE_ACCESS(ActorHandleMapDetector);
	ActorHandleMap.Remove(Actor);
}

void FMassActorManager::DisconnectActor(const TObjectKey<const AActor> Actor, const FMassEntityHandle Handle)
{
	if (Handle.IsValid() == false)
	{
		return;
	}

	FMassEntityHandle FoundEntity;
	{
		UE_MT_SCOPED_WRITE_ACCESS(ActorHandleMapDetector);
		// We're assuming the Handle does match Actor, so we're RemoveAndCopyValue. If if doesn't we'll add it back.
		// The expectation is that this won't happen on a regular basis..
		if (ActorHandleMap.RemoveAndCopyValue(Actor, FoundEntity) == false)
		{
			// the entity doesn't match the actor
			return;
		}
	}

	if (FoundEntity == Handle)
	{
		check(EntityManager);
		if (FMassActorFragment* Data = EntityManager->GetFragmentDataPtr<FMassActorFragment>(Handle))
		{
			Data->ResetAndUpdateHandleMap();
		}
	}
	else
	{
		// unexpected mismatch. Add back and notify.
		UE_VLOG_UELOG(Owner.Get(), LogMass, Warning, TEXT("%s: Trying to disconnect actor %s while the Handle given doesn't match the system\'s records")
			, ANSI_TO_TCHAR(__FUNCTION__), *AActor::GetDebugName(Actor.ResolveObjectPtr()));
		SetHandleForActor(Actor, Handle);
	}
}

========================================================


=== Source/MassActors/Private/MassActorTypes.cpp ===
====================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassActorTypes.h"

DEFINE_LOG_CATEGORY(LogMassActor);

====================================================


=== Source/MassActors/Private/MassAgentComponent.cpp ===
========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassAgentComponent.h"
#include "EngineUtils.h"
#include "MassEntityView.h"
#include "MassEntityManager.h"
#include "MassEntitySubsystem.h"
#include "MassCommonTypes.h"
#include "MassAgentSubsystem.h"
#include "VisualLogger/VisualLogger.h"
#include "MassActorSubsystem.h"
#include "MassSpawner.h"
#include "Net/UnrealNetwork.h"
#include "MassReplicationSubsystem.h"
#include "MassReplicationFragments.h"
#include "MassMovementFragments.h"
#include "GameFramework/CharacterMovementComponent.h"

#define MASSAGENT_CHECK( condition, Format, ... ) \
	UE_CVLOG(!(condition), GetOwner(), LogMass, Error, Format, ##__VA_ARGS__); \
	checkf( condition, Format, ##__VA_ARGS__ );

//----------------------------------------------------------------------//
// UMassAgentComponent
//----------------------------------------------------------------------//
UMassAgentComponent::UMassAgentComponent()
	: EntityConfig(*this)
{
#if WITH_EDITORONLY_DATA
	bAutoRegisterInEditorMode = true;
#endif // WITH_EDITORONLY_DATA
	bAutoRegister = true;
	State = EAgentComponentState::None;
	SetIsReplicatedByDefault(true);
}

#if WITH_EDITOR
void UMassAgentComponent::PostInitProperties() 
{
	Super::PostInitProperties();

	if (HasAnyFlags(RF_ClassDefaultObject | RF_ArchetypeObject | RF_NeedLoad) || GetOuter() == nullptr || GetOuter()->HasAnyFlags(RF_ClassDefaultObject | RF_ArchetypeObject))
	{
		return;
	}
	
	if (GetWorld())
	{
		bAutoRegister = bAutoRegisterInEditorMode || GetWorld()->IsGameWorld();
	}
}
void UMassAgentComponent::PostLoad()
{
	Super::PostLoad();
	if (HasAnyFlags(RF_ClassDefaultObject | RF_ArchetypeObject) || GetOuter() == nullptr || GetOuter()->HasAnyFlags(RF_ClassDefaultObject | RF_ArchetypeObject))
	{
		return;
	}

	if (GetWorld())
	{
		bAutoRegister = bAutoRegisterInEditorMode || GetWorld()->IsGameWorld();
	}
}
#endif // WITH_EDITOR

void UMassAgentComponent::OnRegister()
{
	Super::OnRegister();

	if (IsRunningCommandlet() || IsRunningCookCommandlet() || GIsCookerLoadingPackage)
	{
		// ignore, we're not doing any registration while cooking or running a commandlet
		return;
	}

	if (GetOuter() == nullptr || GetOuter()->HasAnyFlags(RF_ClassDefaultObject | RF_ArchetypeObject) || HasAnyFlags(RF_ArchetypeObject))
	{
		// we won't try registering a CDO's component with Mass
		ensure(false && "temp, wanna know this happened");
		return;
	}

	UWorld* World = GetWorld();
	if (World == nullptr
#if WITH_EDITOR
		|| World->IsPreviewWorld() || (bAutoRegisterInEditorMode == false && World->IsGameWorld() == false)
#endif // WITH_EDITOR
		)
	{
		// we don't care about preview worlds. Those are transient, temporary worlds like the one created when opening a BP editor.
		return;
	}

	// @todo hook up to pawn possessing stuff, maybe?
	RegisterWithAgentSubsystem();
}

bool UMassAgentComponent::IsReadyForPooling() const
{
	// If we're waiting for puppet initialization, we could have some bad interactions
	if (IsPuppetPendingInitialization())
	{
		return false;
	}

	return true;
}

void UMassAgentComponent::RegisterWithAgentSubsystem()
{
	UMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(GetWorld());
	UE_CVLOG_UELOG(AgentSubsystem == nullptr, GetOwner(), LogMass, Error, TEXT("Unable to find UMassAgentSubsystem instance. Make sure the world is initialized"));
	if (ensureMsgf(AgentSubsystem, TEXT("Unable to find UMassAgentSubsystem instance. Make sure the world is initialized")))
	{
		TemplateID = AgentSubsystem->RegisterAgentComponent(*this);
	}
}

void UMassAgentComponent::UnregisterWithAgentSubsystem()
{
	if (State != EAgentComponentState::None)
	{
		if (UMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(GetWorld()))
		{
			UE_VLOG(GetOwner(), LogMass, Verbose, TEXT("%s"), ANSI_TO_TCHAR(__FUNCTION__));
			AgentSubsystem->ShutdownAgentComponent(*this);
			MASSAGENT_CHECK(State == EAgentComponentState::None ||
				State == EAgentComponentState::PuppetPaused ||
				State == EAgentComponentState::PuppetReplicatedOrphan,
				TEXT("%s is expecting to be in state[None|PuppetPaused|PuppetReplicatedOrphan] state but is in %s"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));
		}
	}
	DebugCheckStateConsistency();
	if (AgentHandle.IsValid())
	{
		ClearEntityHandleInternal();
	}

	State = EAgentComponentState::None;
	TemplateID = FMassEntityTemplateID();
}

void UMassAgentComponent::OnUnregister()
{
	UE_VLOG(GetOwner(), LogMass, Verbose, TEXT("%s"), ANSI_TO_TCHAR(__FUNCTION__));
	UnregisterWithAgentSubsystem();

	Super::OnUnregister();
}

void UMassAgentComponent::SetEntityHandle(const FMassEntityHandle NewHandle)
{
	MASSAGENT_CHECK(State == EAgentComponentState::EntityPendingCreation,
		TEXT("%s is expecting to be in state[EntityPendingCreation] but is in %s"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));

	SetEntityHandleInternal(NewHandle);
	SwitchToState(EAgentComponentState::EntityCreated);
}

void UMassAgentComponent::SetEntityHandleInternal(const FMassEntityHandle NewHandle)
{
	ensureMsgf((AgentHandle.IsValid() && NewHandle.IsValid()) == false, TEXT("Overriding an existing entity ID might result in a dangling entity still affecting the simulation"));
	AgentHandle = NewHandle;

	UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(GetWorld());
#if	UE_REPLICATION_COMPILE_SERVER_CODE
	// Fetch NetID if it exist
	if (EntitySubsystem)
	{
		if (const FMassNetworkIDFragment* NetIDFragment = EntitySubsystem->GetEntityManager().GetFragmentDataPtr<FMassNetworkIDFragment>(AgentHandle))
		{
			if (!IsNetSimulating())
			{
				NetID = NetIDFragment->NetID;
			}
			else
			{
				check(NetID == NetIDFragment->NetID);
			}
		}
	}
#endif // UE_REPLICATION_COMPILE_SERVER_CODE

	if (const UMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(GetWorld()))
	{
		AgentSubsystem->NotifyMassAgentComponentEntityAssociated(*this);
	}

	// Sync up with mass
	if (EntitySubsystem)
	{
		if (IsNetSimulating())
		{
			const FMassEntityView EntityView(EntitySubsystem->GetEntityManager(), AgentHandle);

			// @todo Find a way to add these initialization into either translator initializer or adding new fragments
			// Make sure to fetch the fragment after any release, as that action can move the entity around into new archetype and 
			// by the same fact change the references to the fragments.
			if (FMassActorFragment* ActorInfo = EntityView.GetFragmentDataPtr<FMassActorFragment>())
			{
				checkf(!ActorInfo->IsValid(), TEXT("Expecting ActorInfo fragment to be null"));
				ActorInfo->SetAndUpdateHandleMap(AgentHandle, GetOwner(), !IsNetSimulating()/*bIsOwnedByMass*/);
			}

			// Initialize location of the replicated actor to match the mass replicated one
			if (const FTransformFragment* TransformFragment = EntityView.GetFragmentDataPtr<FTransformFragment>())
			{
				GetOwner()->SetActorTransform(TransformFragment->GetTransform(), /*bSweep*/false, /*OutSweepHitResult*/nullptr, ETeleportType::TeleportPhysics);
			}

			// Initialize velocity of the replicated actor to match the mass replicated one
			if (const FMassVelocityFragment* Velocity = EntityView.GetFragmentDataPtr<FMassVelocityFragment>())
			{
				if (UCharacterMovementComponent* MovementComp = GetOwner()->FindComponentByClass<UCharacterMovementComponent>())
				{
					MovementComp->Velocity = Velocity->Value;
				}
			}
		}
	}
}

void UMassAgentComponent::SetPuppetHandle(const FMassEntityHandle NewHandle)
{
	MASSAGENT_CHECK(State == EAgentComponentState::EntityPendingCreation,
		TEXT("%s is expecting to be in state[EntityPendingCreation] but is in %s"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));
	DebugCheckStateConsistency();

	checkf(AgentHandle.IsValid() == false, TEXT("Can't set a new puppet handle of top of a regular agent handle. Entities would end up dangling."));
	SetEntityHandleInternal(NewHandle);

	if (UMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(GetWorld()))
	{
		AgentSubsystem->MakePuppet(*this);
	}
}

void UMassAgentComponent::PuppetInitializationPending()
{
	MASSAGENT_CHECK(State == EAgentComponentState::EntityPendingCreation ||
		State == EAgentComponentState::PuppetPendingReplication ||
		State == EAgentComponentState::PuppetPaused ||
		State == EAgentComponentState::PuppetReplicatedOrphan,
		TEXT("%s is expecting to be in state[EntityPendingCreation|PuppetPendingReplication|PuppetPaused|PuppetReplicatedOrphan] but is in %s"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));
	SwitchToState(EAgentComponentState::PuppetPendingInitialization);
}

void UMassAgentComponent::PuppetInitializationDone()
{
	MASSAGENT_CHECK(State == EAgentComponentState::PuppetPendingInitialization,
		TEXT("%s is expecting to be in state[PuppetPendingInitialization] but is in %s"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));
	SwitchToState(EAgentComponentState::PuppetInitialized);
}

void UMassAgentComponent::PuppetInitializationAborted()
{
	MASSAGENT_CHECK(State == EAgentComponentState::PuppetPendingInitialization,
		TEXT("%s is expecting to be in state[PuppetPendingInitialization] but is in %s"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));
	SwitchToState(EAgentComponentState::PuppetPaused);
}

void UMassAgentComponent::ClearEntityHandle()
{
	MASSAGENT_CHECK(State == EAgentComponentState::EntityCreated,
		TEXT("%s is expecting to be in state[EntityCreated] but is in %s"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));

	ClearEntityHandleInternal();
	SwitchToState(EAgentComponentState::None);
}

void UMassAgentComponent::ClearEntityHandleInternal()
{
	if (UWorld* World = GetWorld())
	{
		if (const UMassAgentSubsystem* AgentSubsystem = World->GetSubsystem<UMassAgentSubsystem>())
		{
			AgentSubsystem->NotifyMassAgentComponentEntityDetaching(*this);
		}

		if (IsNetSimulating())
		{
			// Sync up with mass
			if (const UMassEntitySubsystem* EntitySubsystem = World->GetSubsystem<UMassEntitySubsystem>())
			{
				const FMassEntityView EntityView(EntitySubsystem->GetEntityManager(), AgentHandle);
				if (FMassActorFragment* ActorInfo = EntityView.GetFragmentDataPtr<FMassActorFragment>())
				{
					checkf(!ActorInfo->IsValid() || ActorInfo->Get() == GetOwner(), TEXT("Expecting actor pointer to be the Component\'s owner"));
					ActorInfo->ResetAndUpdateHandleMap(World->GetSubsystem<UMassActorSubsystem>());
				}
			}
		}
	}
	
	AgentHandle = FMassEntityManager::InvalidEntity;
}

void UMassAgentComponent::PuppetUnregistrationDone()
{	
	MASSAGENT_CHECK(State == EAgentComponentState::PuppetPaused ||
			 State == EAgentComponentState::PuppetInitialized,
		TEXT("%s is expecting to be in state[PuppetPaused|PuppetInitialized] state but is in %s"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));

	SwitchToState(EAgentComponentState::PuppetPaused);

	PuppetSpecificAddition.Reset();

	// AgentHandle on purpose. It's possible to unregister the AgentComponent just to
	// re-register it soon after in which case having this information stored is beneficial to avoid a need to 
	// re-configure the component as a puppet
}

void UMassAgentComponent::EntityCreationPending()
{
	MASSAGENT_CHECK(State == EAgentComponentState::None,
		TEXT("%s is expecting to be in state[None] but is in %s"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));
	SwitchToState(EAgentComponentState::EntityPendingCreation);
}

void UMassAgentComponent::EntityCreationAborted()
{
	MASSAGENT_CHECK(State == EAgentComponentState::EntityPendingCreation,
		TEXT("%s is expecting to be in state[EntityPendingCreation] but is in %s"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));
	SwitchToState(EAgentComponentState::None);
}

void UMassAgentComponent::SwitchToState(EAgentComponentState NewState)
{
	UE_VLOG(GetOwner(), LogMass, Verbose, TEXT("Entity[%s] %s From:%s To:%s"), *AgentHandle.DebugGetDescription(), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State), *UEnum::GetValueAsString(NewState));
	State = NewState;
	DebugCheckStateConsistency();
}

void UMassAgentComponent::DebugCheckStateConsistency()
{
#if DO_CHECK
	switch (State)
	{
		case EAgentComponentState::None:
		case EAgentComponentState::EntityPendingCreation:
			MASSAGENT_CHECK(AgentHandle.IsValid() == false, TEXT("Not expecting a valid mass agent handle in state %s"), *UEnum::GetValueAsString(State));
			break;
		case EAgentComponentState::EntityCreated:
			MASSAGENT_CHECK(AgentHandle.IsValid() == true, TEXT("Expecting a valid mass agent handle in state %s"), *UEnum::GetValueAsString(State));
			break;
		case EAgentComponentState::PuppetPendingInitialization:
		case EAgentComponentState::PuppetInitialized:
		case EAgentComponentState::PuppetPaused:
		{
			const bool bValidAgentHandle = AgentHandle.IsValid();
			MASSAGENT_CHECK(bValidAgentHandle, TEXT("Expecting a valid mass agent handle in state %s"), *UEnum::GetValueAsString(State));
			if (bValidAgentHandle)
			{
				if (const UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(GetWorld()))
				{
					const FMassEntityManager& EntityManager = EntitySubsystem->GetEntityManager();
					const bool bIsValidEntity = EntityManager.IsEntityValid(AgentHandle);
					MASSAGENT_CHECK(bIsValidEntity, TEXT("Exepecting a valid entity in state"), *UEnum::GetValueAsString(State))
					if (bIsValidEntity)
					{
						const bool bIsBuiltEntity = EntityManager.IsEntityBuilt(AgentHandle);
						MASSAGENT_CHECK(bIsBuiltEntity, TEXT("Expecting a fully built entity in state %s"), *UEnum::GetValueAsString(State));
						if (bIsBuiltEntity)
						{
							AActor* Owner = GetOwner();
							const AActor* Actor = EntityManager.GetFragmentDataChecked<FMassActorFragment>(AgentHandle).Get();
							MASSAGENT_CHECK(Actor == nullptr || Actor == Owner, TEXT("Mass Actor and Owner mismatched in state %s"), *UEnum::GetValueAsString(State));
						}
					}
				}
			}
			break;
		}
		case EAgentComponentState::PuppetPendingReplication:
			MASSAGENT_CHECK(IsNetSimulating(), TEXT("Expecting to be a replicated none authoritative actor in state %s"), *UEnum::GetValueAsString(State));
			MASSAGENT_CHECK(AgentHandle.IsValid() == false, TEXT("Not expecting a valid mass agent handle in state %s"), *UEnum::GetValueAsString(State));
			MASSAGENT_CHECK(NetID.IsValid() == false, TEXT("Not expecting a valid net id in state %s"), *UEnum::GetValueAsString(State));
			break;
		case EAgentComponentState::PuppetReplicatedOrphan:
			MASSAGENT_CHECK(IsNetSimulating(), TEXT("Expecting to be a replicated none authoritative actor in state %s"), *UEnum::GetValueAsString(State));
			MASSAGENT_CHECK(AgentHandle.IsValid() == false, TEXT("Not expecting a valid mass agent handle in state %s"), *UEnum::GetValueAsString(State));
			MASSAGENT_CHECK(NetID.IsValid() == true, TEXT("Expecting a valid net id in state %s"), *UEnum::GetValueAsString(State));
			break;
		default:
			MASSAGENT_CHECK(false, TEXT("Unsuported agent component state"));
			break;
	}
#endif // DO_CHECK
}

void UMassAgentComponent::SetEntityConfig(const FMassEntityConfig& InEntityConfig)
{
	EntityConfig = InEntityConfig;
	EntityConfig.SetOwner(*this);
}

void UMassAgentComponent::Enable()
{
	if (IsRegistered() == false)
	{
		UE_VLOG(GetOwner(), LogMass, Verbose, TEXT("%s"), ANSI_TO_TCHAR(__FUNCTION__));
		RegisterComponent();
	}
}

void UMassAgentComponent::Disable()
{
	if (IsRegistered())
	{
		UE_VLOG(GetOwner(), LogMass, Verbose, TEXT("%s"), ANSI_TO_TCHAR(__FUNCTION__));
		UnregisterComponent();
	}
}

/* This method is evil and if it get called before while spawning the AgentHandle is not set yet and some early code was destroying actor after a certain time even if the kill entity did not worked. */
void UMassAgentComponent::KillEntity(const bool bDestroyActor)
{
	UE_VLOG(GetOwner(), LogMass, Verbose, TEXT("%s"), ANSI_TO_TCHAR(__FUNCTION__));

	AActor* Owner = GetOwner();
	UWorld* World = GetWorld();
	if (Owner == nullptr)
	{
		return;
	}

	// Caching the entity and if we have to disconnect actor as the next operation will invalidate that information
	const FMassEntityHandle EntityHandleToDespawn = AgentHandle;
	const bool bDisconnectActor = IsPuppet() && bDestroyActor == false;
	if (State != EAgentComponentState::None)
	{
		if (UMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(World))
		{
			AgentSubsystem->UnregisterAgentComponent(*this);
			MASSAGENT_CHECK(State == EAgentComponentState::None ||
				State == EAgentComponentState::PuppetPaused,
				TEXT("%s is expecting to be in state[None|PuppetPaused] but is in %s"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));
			// We need to clear the entity now as it will be despawned below.
			ClearEntityHandleInternal();
			// Since we cleared the entity handle, need to switch to none state to prevent the call to UnregisterAgentComponent upon actor destruction.
			SwitchToState(EAgentComponentState::None);
		}
	}

	if (bDisconnectActor)
	{
		// break connection between entity and actor so that the actor doesn't get destroyed as part of the entity's 
		// removal. Removal is to be expected for puppet actors.
		if (UMassActorSubsystem* ActorSubsystem = UWorld::GetSubsystem<UMassActorSubsystem>(World))
		{
			ActorSubsystem->DisconnectActor(Owner, EntityHandleToDespawn);
		}
	}

	// @todo temp hack to utilize the same path as Spawners (i.e. using EntityTemplate's deinitialization pipeline). 
	// this will go away once we switch over to system-component based approach or monitors
	if (EntityHandleToDespawn.IsValid())
	{
		for (TActorIterator<AMassSpawner> It(World); It; ++It)
		{
			(*It)->DespawnEntity(EntityHandleToDespawn);
		}
	}
}

void UMassAgentComponent::PausePuppet(const bool bPause)
{
	MASSAGENT_CHECK(IsPuppet(), TEXT("%s can only be called when the the mass agent component acts as a puppet. Current state is %s"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));
	if (IsPuppetPaused() != bPause)
	{
		if (UMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(GetWorld()))
		{
			if (bPause)
			{
				MASSAGENT_CHECK(State == EAgentComponentState::PuppetPendingInitialization ||
					State == EAgentComponentState::PuppetInitialized,
					TEXT("%s(true) is expecting to be in state[PuppetPendingInitialization|PuppetInitialized] but is in %s"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));

				AgentSubsystem->UnregisterAgentComponent(*this);
			}
			else
			{
				MASSAGENT_CHECK(State == EAgentComponentState::PuppetPaused,
					TEXT("%s(false) is expecting to be in state[PuppetPaused] but is in %s"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));

				AgentSubsystem->RegisterAgentComponent(*this);
			}
		}
	}
	DebugCheckStateConsistency();
}

void UMassAgentComponent::PuppetReplicationPending()
{
	checkf(IsNetSimulating(), TEXT("Expecting a replicated pupet"));
	MASSAGENT_CHECK(State == EAgentComponentState::None,
		TEXT("%s is expecting to be in state[None] but is in %s"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));

	SwitchToState(EAgentComponentState::PuppetPendingReplication);
}

void UMassAgentComponent::SetReplicatedPuppetHandle(FMassEntityHandle NewHandle)
{
	checkf(IsNetSimulating(), TEXT("Expecting a replicated pupet"));
	MASSAGENT_CHECK(State == EAgentComponentState::PuppetPendingReplication ||
		State == EAgentComponentState::PuppetReplicatedOrphan,
		TEXT("%s is expecting to be in state [PuppetPendingReplication|PuppetReplicatedOrphan] but is in %s"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));

	SetEntityHandleInternal(NewHandle);
}

void UMassAgentComponent::ClearReplicatedPuppetHandle()
{
	checkf(IsNetSimulating(), TEXT("Expecting a replicated pupet"));
	MASSAGENT_CHECK(State == EAgentComponentState::PuppetPaused,
		TEXT("%s is expecting to be in state [PuppetPaused] but is in %s"), ANSI_TO_TCHAR(__FUNCTION__), *UEnum::GetValueAsString(State));

	if (UMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(GetWorld()))
	{
		UE_VLOG(GetOwner(), LogMass, Verbose, TEXT("%s"), ANSI_TO_TCHAR(__FUNCTION__));
		AgentSubsystem->UnregisterAgentComponent(*this);
	}
	ClearEntityHandleInternal();
	SwitchToState(EAgentComponentState::PuppetReplicatedOrphan);
}

void UMassAgentComponent::MakePuppetAReplicatedOrphan()
{
	checkf(IsNetSimulating(), TEXT("Expecting a replicated pupet"));

	SwitchToState(EAgentComponentState::PuppetReplicatedOrphan);
}

void UMassAgentComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	FDoRepLifetimeParams SharedParams;
	DOREPLIFETIME_WITH_PARAMS_FAST(UMassAgentComponent, NetID, SharedParams);
}

void UMassAgentComponent::OnRep_NetID()
{
#if UE_REPLICATION_COMPILE_CLIENT_CODE
	if (UMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(GetWorld()))
	{
		AgentSubsystem->NotifyMassAgentComponentReplicated(*this);
	}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE
}

========================================================


=== Source/MassActors/Private/MassAgentSubsystem.cpp ===
========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassAgentSubsystem.h"
#include "MassCommandBuffer.h"
#include "Engine/World.h"
#include "MassEntityManager.h"
#include "MassCommonTypes.h"
#include "MassSimulationSubsystem.h"
#include "MassSpawnerSubsystem.h"
#include "MassActorTypes.h"
#include "MassAgentComponent.h"
#include "MassEntityTemplateRegistry.h"
#include "VisualLogger/VisualLogger.h"
#include "MassEntityView.h"
#include "MassReplicationSubsystem.h"
#include "Engine/NetDriver.h"
#include "MassEntityUtils.h"


namespace FMassAgentSubsystemHelper
{

inline void InitializeAgentComponentFragments(const UMassAgentComponent& AgentComp, FMassEntityView& EntityView, const EMassTranslationDirection Direction
	, TConstArrayView<FMassEntityTemplateData::FObjectFragmentInitializerFunction> ObjectFragmentInitializers)
{
	AActor* Owner = AgentComp.GetOwner();
	check(Owner);
	for (const FMassEntityTemplateData::FObjectFragmentInitializerFunction& Initializer : ObjectFragmentInitializers)
	{
		Initializer(*Owner, EntityView, Direction);
	}
}

}

//----------------------------------------------------------------------//
// UMassAgentSubsystem 
//----------------------------------------------------------------------//
void UMassAgentSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	// making sure UMassSimulationSubsystem gets created before the MassAgentSubsystem
	Collection.InitializeDependency<UMassSimulationSubsystem>();
	Collection.InitializeDependency<UMassSpawnerSubsystem>();
#if UE_REPLICATION_COMPILE_CLIENT_CODE
	Collection.InitializeDependency<UMassReplicationSubsystem>();
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE
	
	UWorld* World = GetWorld();
	check(World);

	EntityManager = UE::Mass::Utils::GetEntityManagerChecked(*World).AsShared();

	SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(World);

	SimulationSystem = UWorld::GetSubsystem<UMassSimulationSubsystem>(World);
	SimulationSystem->GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).AddUObject(this, &UMassAgentSubsystem::OnProcessingPhaseStarted, EMassProcessingPhase::PrePhysics);

#if UE_REPLICATION_COMPILE_CLIENT_CODE
	ReplicationSubsystem = UWorld::GetSubsystem<UMassReplicationSubsystem>(World);
	check(ReplicationSubsystem);

	ReplicationSubsystem->GetOnMassAgentAdded().AddUObject(this, &UMassAgentSubsystem::OnMassAgentAddedToReplication);
	ReplicationSubsystem->GetOnRemovingMassAgent().AddUObject(this, &UMassAgentSubsystem::OnMassAgentRemovedFromReplication);
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE
}

void UMassAgentSubsystem::Deinitialize()
{
	EntityManager.Reset();
	Super::Deinitialize();
}

FMassEntityTemplateID UMassAgentSubsystem::RegisterAgentComponent(UMassAgentComponent& AgentComp)
{
	check(EntityManager);
	check(SpawnerSystem);

	if (AgentComp.IsPuppet())
	{
		MakePuppet(AgentComp);
		return AgentComp.GetTemplateID();
	}

	// @todo note that this will happen when a regular actor with AgentComp gets unregister and then registered again.
	if (AgentComp.GetTemplateID().IsValid())
	{
		UE_VLOG_UELOG(this, LogMassActor, Warning, TEXT("UMassAgentSubsystem::RegisterAgentComponent called while the given agent component has already been registered (Owner: %s, entity handle %s, template ID %s)")
			, *GetNameSafe(AgentComp.GetOwner()), *AgentComp.GetEntityHandle().DebugGetDescription(), *AgentComp.GetTemplateID().ToString());
		return FMassEntityTemplateID();
	}

	AActor* AgentActor = AgentComp.GetOwner();
	check(AgentActor);
	UWorld* World = AgentActor->GetWorld();
	check(World);

	const FMassEntityConfig& EntityConfig = AgentComp.GetEntityConfig();
	const FMassEntityTemplate& EntityTemplate = EntityConfig.GetOrCreateEntityTemplate(*World);

#if UE_REPLICATION_COMPILE_CLIENT_CODE
	if (AgentComp.IsNetSimulating())
	{
		AgentComp.PuppetReplicationPending();
	}
	else
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE
	{
		FMassAgentInitializationQueue& AgentQueue = PendingAgentEntities.FindOrAdd(EntityTemplate.GetTemplateID());
		// Agent already in the queue! Earlier conditions should have failed or data is inconsistent.
		check(AgentQueue.AgentComponents.Find(&AgentComp) == INDEX_NONE);
		AgentQueue.AgentComponents.Add(&AgentComp);

		UE_VLOG(this, LogMassActor, Verbose, TEXT("%s registered and PENDING entity creation."), *AgentActor->GetName());
   		AgentComp.EntityCreationPending();
	}

	return EntityTemplate.GetTemplateID();
}

void UMassAgentSubsystem::UpdateAgentComponent(const UMassAgentComponent& AgentComp)
{
	check(EntityManager);
	check(SpawnerSystem)

	if (!ensureMsgf(AgentComp.GetEntityHandle().IsValid(), TEXT("Caling %s is valid only for already registered MassAgentComponents"), ANSI_TO_TCHAR(__FUNCTION__)))
	{
		UE_VLOG(this, LogMassActor, Warning, TEXT("%s: called while the given agent component has not been registered yet (Owner: %s)")
			, ANSI_TO_TCHAR(__FUNCTION__), *GetNameSafe(AgentComp.GetOwner()));
		return;
	}

	AActor* AgentActor = AgentComp.GetOwner();
	check(AgentActor);
	UWorld* World = AgentActor->GetWorld();
	check(World);

	const FMassEntityConfig& EntityConfig = AgentComp.GetEntityConfig();
	const FMassEntityTemplate& EntityTemplate = EntityConfig.GetOrCreateEntityTemplate(*World);

	const FMassEntityHandle Entity = AgentComp.GetEntityHandle();
	const FMassArchetypeHandle CurrentArchetypeHandle = EntityManager->GetArchetypeForEntity(Entity);
	if (CurrentArchetypeHandle == EntityTemplate.GetArchetype())
	{
		UE_VLOG(this, LogMassActor, Log, TEXT("%s called for %s but no archetype changes have been found")
			, ANSI_TO_TCHAR(__FUNCTION__), *AgentActor->GetName());
	}
	else
	{
		// the tricky case: we want to move the entity over to the new archetype and initialize its fragments, 
		// but only the ones that the previous archetype didn't have - "delta initialize"
		ensureMsgf(false, TEXT("Not implemented yet"));
			
		// @todo add override flag so that we always initialize a new when moving between archetypes
	}

	check(AgentComp.GetEntityHandle().IsValid());
}

void UMassAgentSubsystem::UnregisterAgentComponent(UMassAgentComponent& AgentComp)
{
	if (!EntityManager || SpawnerSystem == nullptr || SimulationSystem == nullptr)
	{
		return;
	}

	if (AgentComp.IsPuppet())
	{
		if (AgentComp.IsPuppetPendingInitialization())
		{
			FMassAgentInitializationQueue* PuppetQueue = PendingPuppets.Find(AgentComp.GetTemplateID());
		
			if (ensureMsgf(PuppetQueue, TEXT("Trying to remove a puppet's agent component from initialization queue but there's no such queue")))
			{
				ensureMsgf(PuppetQueue->AgentComponents.Remove(&AgentComp), TEXT("Trying to remove a puppet's agent component from initialization queue while it's not in the queue"));
			}
			AgentComp.PuppetInitializationAborted();
		}
		else if (ensureMsgf(AgentComp.GetEntityHandle().IsValid(), TEXT("Trying to unregister a puppet's agent component while it's neither pending initialization nor having a valid entity handle")) )
		{
			if (AgentComp.GetPuppetSpecificAddition().IsEmpty() == false)
			{
				const FMassEntityHandle Entity = AgentComp.GetEntityHandle();

			    // remove fragments that have been added for the puppet agent
			    if (EntityManager->IsProcessing())
			    {
				    // need to request via command buffer since we can't move entities while processing is happening
					FMassArchetypeCompositionDescriptor Composition = AgentComp.GetPuppetSpecificAddition();
					EntityManager->Defer().PushCommand<FMassDeferredRemoveCommand>([Entity, Composition](FMassEntityManager& System)
						{
							if (System.IsEntityValid(Entity) == false)
							{
								return;
							}
							System.RemoveCompositionFromEntity(Entity, Composition);
						});
			    }
			    else
			    {
					EntityManager->RemoveCompositionFromEntity(Entity, AgentComp.GetPuppetSpecificAddition());
			    }
			}
			AgentComp.PuppetUnregistrationDone();
		}
	}
	else
	{
		if (AgentComp.GetEntityHandle().IsValid())
		{
			// the entity has already been created. Destroy!
			const FMassEntityTemplate* EntityTemplate = nullptr;
			AActor* AgentActor = AgentComp.GetOwner();
			UWorld* World = AgentActor ? AgentActor->GetWorld() : nullptr;
			if (ensure(World))
			{
				const FMassEntityConfig& EntityConfig = AgentComp.GetEntityConfig();
				EntityTemplate = &EntityConfig.GetEntityTemplateChecked(*World);
			}

			FMassEntityHandle Entity = AgentComp.GetEntityHandle();
			// Clearing the entity before it become invalid as the clear contains notifications
			AgentComp.ClearEntityHandle();

			// Destroy the entity
			if (EntityManager->IsProcessing())
			{
				// need to request via command buffer since we can't move entities while processing is happening
				EntityManager->Defer().DestroyEntity(Entity);
			}
			else if (ensure(EntityTemplate))
			{
				SpawnerSystem->DestroyEntities(TArrayView<FMassEntityHandle>(&Entity, 1));
			}
		}
		else if (AgentComp.IsEntityPendingCreation())
		{
			// hasn't been registered yet. Just remove it from the queue		
			FMassAgentInitializationQueue* AgentQueue = PendingAgentEntities.Find(AgentComp.GetTemplateID());
			if (ensureMsgf(AgentQueue, TEXT("Trying to remove an agent component from initialization queue but there's no such queue")))
			{
				ensureMsgf(AgentQueue->AgentComponents.Remove(&AgentComp), TEXT("Trying to remove an agent component from initialization queue it's missing from the queue"));
			}
			AgentComp.EntityCreationAborted();
		}
	}
}

void UMassAgentSubsystem::ShutdownAgentComponent(UMassAgentComponent& AgentComp)
{
	UnregisterAgentComponent(AgentComp);

#if UE_REPLICATION_COMPILE_CLIENT_CODE
	ReplicatedAgentComponents.Remove(AgentComp.GetNetID());
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

}

void UMassAgentSubsystem::MakePuppet(UMassAgentComponent& AgentComp)
{
	if (!ensureMsgf(AgentComp.GetTemplateID().IsValid(), TEXT("%s tried to used %s as puppet but it doesn't have a valid entity template ID"), ANSI_TO_TCHAR(__FUNCTION__), *GetNameSafe(AgentComp.GetOwner())))
	{
		return;
	}
		
	if (AgentComp.IsEntityPendingCreation())
	{
		FMassAgentInitializationQueue* AgentQueue = PendingAgentEntities.Find(AgentComp.GetTemplateID());
		if (ensureMsgf(AgentQueue, TEXT("Trying to remove an agent component from initialization queue but there's no such queue")))
		{
			ensureMsgf(AgentQueue->AgentComponents.Remove(&AgentComp), TEXT("Trying to remove an agent component from initialization queue it's missing from the queue"));
		}
	}

	FMassAgentInitializationQueue& PuppetQueue = PendingPuppets.FindOrAdd(AgentComp.GetTemplateID());
	// Agent already in the queue! Earlier conditions should have failed or data is inconsistent.
	check(PuppetQueue.AgentComponents.Find(&AgentComp) == INDEX_NONE);
	PuppetQueue.AgentComponents.Add(&AgentComp);

	AgentComp.PuppetInitializationPending();
}

void UMassAgentSubsystem::OnProcessingPhaseStarted(const float DeltaSeconds, const EMassProcessingPhase Phase)
{
	switch (Phase)
	{
	case EMassProcessingPhase::PrePhysics:
		// initialize what needs initialization
		if (PendingAgentEntities.Num() > 0 || PendingPuppets.Num() > 0)
		{
			HandlePendingInitialization();
		}
		break;
	default:
		// unhandled phases, by design, not every phase needs to be handled by the Actor subsystem
		break;
	}
}

void UMassAgentSubsystem::HandlePendingInitialization()
{
	check(EntityManager);
	check(SpawnerSystem);
	check(SimulationSystem);
	check(SimulationSystem->IsDuringMassProcessing() == false);

	for (TTuple<FMassEntityTemplateID, FMassAgentInitializationQueue>& Data : PendingAgentEntities)
	{
		const FMassEntityTemplateID EntityTemplateID = Data.Get<0>();
		const TSharedRef<FMassEntityTemplate>* EntityTemplatePtr = SpawnerSystem->GetTemplateRegistryInstance().FindTemplateFromTemplateID(EntityTemplateID);
		check(EntityTemplatePtr);
		const FMassEntityTemplate& EntityTemplate = EntityTemplatePtr->Get();
		
		TArray<TObjectPtr<UMassAgentComponent>>& AgentComponents = Data.Get<1>().AgentComponents;
		const int32 NewEntityCount = AgentComponents.Num();
		
		if (NewEntityCount <= 0)
		{
			// this case is perfectly fine, all agents registered and unregistered before we processed the queue
			continue;
		}
		
		TArray<FMassEntityHandle> Entities;
		SpawnerSystem->SpawnEntities(EntityTemplate, NewEntityCount, Entities);
		check(Entities.Num() == NewEntityCount);

		if (EntityTemplate.GetObjectFragmentInitializers().Num())
		{
			const TConstArrayView<FMassEntityTemplateData::FObjectFragmentInitializerFunction> ObjectFragmentInitializers = EntityTemplate.GetObjectFragmentInitializers();

			for (int AgentIndex = 0; AgentIndex < Entities.Num(); ++AgentIndex)
			{
				FMassEntityView EntityView(EntityTemplate.GetArchetype(), Entities[AgentIndex]);
				FMassAgentSubsystemHelper::InitializeAgentComponentFragments(*AgentComponents[AgentIndex], EntityView, EMassTranslationDirection::ActorToMass, ObjectFragmentInitializers);
			}
		}

		for (int AgentIndex = 0; AgentIndex < Entities.Num(); ++AgentIndex)
		{		
			AgentComponents[AgentIndex]->SetEntityHandle(Entities[AgentIndex]);
		}
	}

	PendingAgentEntities.Reset();

	for (TTuple<FMassEntityTemplateID, FMassAgentInitializationQueue>& Data : PendingPuppets)
	{
		const FMassEntityTemplateID EntityTemplateID = Data.Get<0>();
		const TSharedRef<FMassEntityTemplate>* EntityTemplatePtr = SpawnerSystem->GetTemplateRegistryInstance().FindTemplateFromTemplateID(EntityTemplateID);

		if (!ensure(EntityTemplatePtr))
		{
			// note that this condition is temporary, we'll be switched to a `check` once we set up characters
			continue;
		}
		const FMassEntityTemplate& EntityTemplate = EntityTemplatePtr->Get();

		const FMassArchetypeCompositionDescriptor TemplateDescriptor = EntityTemplate.GetCompositionDescriptor();

		TArray<TObjectPtr<UMassAgentComponent>>& AgentComponents = Data.Get<1>().AgentComponents;

		for (UMassAgentComponent* AgentComp : AgentComponents)
		{
			const FMassEntityHandle PuppetEntity = AgentComp->GetEntityHandle();
			if (!ensureMsgf(PuppetEntity.IsSet(), TEXT("Trying to initialize puppet's fragments while the pupped doesn't have a corresponding Entity identifier set. This should not happen.")))
			{
				continue;
			}

			FMassArchetypeCompositionDescriptor& PuppetDescriptor = AgentComp->GetMutablePuppetSpecificAddition();
			PuppetDescriptor = TemplateDescriptor;
			EntityManager->AddCompositionToEntity_GetDelta(PuppetEntity, PuppetDescriptor);
			
			if (EntityTemplate.GetObjectFragmentInitializers().Num())
			{
				const FMassArchetypeHandle ArchetypeHandle = EntityManager->GetArchetypeForEntity(PuppetEntity);
				FMassEntityView EntityView(ArchetypeHandle, PuppetEntity);
				FMassAgentSubsystemHelper::InitializeAgentComponentFragments(*AgentComp, EntityView, EMassTranslationDirection::MassToActor, EntityTemplate.GetObjectFragmentInitializers());
			}

			AgentComp->PuppetInitializationDone();
		}
	}

	PendingPuppets.Reset();
}

void UMassAgentSubsystem::NotifyMassAgentComponentReplicated(UMassAgentComponent& AgentComp)
{
#if UE_REPLICATION_COMPILE_CLIENT_CODE
	UWorld* World = GetWorld();
	if (World && ensureMsgf(World->IsNetMode(NM_Client), TEXT("%s: Expecting to only be called in network game on the client"), ANSI_TO_TCHAR(__FUNCTION__)))
	{
		check(ReplicationSubsystem);
		check(AgentComp.GetNetID().IsValid());
		check(!ReplicatedAgentComponents.Find(AgentComp.GetNetID()));
		ReplicatedAgentComponents.Add(AgentComp.GetNetID(), &AgentComp);
		const FMassEntityHandle Entity = ReplicationSubsystem->FindEntity(AgentComp.GetNetID());

		// If not found, the NotifyMassAgentAddedToReplication will link it later once replicated.
		if (Entity.IsSet())
		{
			AgentComp.SetReplicatedPuppetHandle(FMassEntityHandle(Entity));
			MakePuppet(AgentComp);
		}
		else
		{
			AgentComp.MakePuppetAReplicatedOrphan();
		}
	}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE
}

void UMassAgentSubsystem::NotifyMassAgentComponentEntityAssociated(const UMassAgentComponent& AgentComp) const
{
	OnMassAgentComponentEntityAssociated.Broadcast(AgentComp);
}

void UMassAgentSubsystem::NotifyMassAgentComponentEntityDetaching(const UMassAgentComponent& AgentComp) const
{
	OnMassAgentComponentEntityDetaching.Broadcast(AgentComp);
}

void UMassAgentSubsystem::OnMassAgentAddedToReplication(FMassNetworkID NetID, FMassEntityHandle Entity)
{
#if UE_REPLICATION_COMPILE_CLIENT_CODE
	UWorld* World = GetWorld();
	if (World && World->IsNetMode(NM_Client))
	{
		if (TObjectPtr<UMassAgentComponent>* AgentComp = ReplicatedAgentComponents.Find(NetID))
		{
			(*AgentComp)->SetReplicatedPuppetHandle(FMassEntityHandle(Entity));
			MakePuppet(**AgentComp);
		}
	}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE
}

void UMassAgentSubsystem::OnMassAgentRemovedFromReplication(FMassNetworkID NetID, FMassEntityHandle Entity)
{
#if UE_REPLICATION_COMPILE_CLIENT_CODE
	UWorld* World = GetWorld();
	if (World && World->IsNetMode(NM_Client))
	{
		if (TObjectPtr<UMassAgentComponent>* AgentComp = ReplicatedAgentComponents.Find(NetID))
		{
			UnregisterAgentComponent(**AgentComp);
			(*AgentComp)->ClearReplicatedPuppetHandle();
		}
	}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE
}

========================================================


=== Source/MassActors/Private/MassAgentTraits.cpp ===
=====================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassAgentTraits.h"
#include "MassCommonTypes.h"
#include "MassMovementFragments.h"
#include "MassEntityTemplate.h"
#include "MassEntityTemplateRegistry.h"
#include "Translators/MassCapsuleComponentTranslators.h"
#include "Translators/MassCharacterMovementTranslators.h"
#include "Translators/MassSceneComponentLocationTranslator.h"
#include "Components/CapsuleComponent.h"
#include "GameFramework/Actor.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "VisualLogger/VisualLogger.h"
#include "MassEntityView.h"

namespace FMassAgentTraitsHelper 
{
	template<typename T>
	T* AsComponent(UObject& Owner)
	{
		T* Component = nullptr;
		if (AActor* AsActor = Cast<AActor>(&Owner))
		{
			Component = AsActor->FindComponentByClass<T>();
		}
		else
		{
			Component = Cast<T>(&Owner);
		}

		UE_CVLOG_UELOG(Component == nullptr, &Owner, LogMass, Error, TEXT("Trying to extract %s from %s failed")
			, *T::StaticClass()->GetName(), *Owner.GetName());

		return Component;
	}
}

//----------------------------------------------------------------------//
//  UMassAgentCapsuleCollisionSyncTrait
//----------------------------------------------------------------------//
void UMassAgentCapsuleCollisionSyncTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	BuildContext.AddFragment<FCapsuleComponentWrapperFragment>();
	BuildContext.AddFragment<FAgentRadiusFragment>();
	if (bSyncTransform || BuildContext.IsInspectingData())
	{
		BuildContext.AddFragment<FTransformFragment>();
	}
	
	BuildContext.GetMutableObjectFragmentInitializers().Add([this](UObject& Owner, FMassEntityView& EntityView, const EMassTranslationDirection CurrentDirection)
		{
			if (UCapsuleComponent* CapsuleComponent = FMassAgentTraitsHelper::AsComponent<UCapsuleComponent>(Owner))
			{
				FCapsuleComponentWrapperFragment& CapsuleFragment = EntityView.GetFragmentData<FCapsuleComponentWrapperFragment>();
				CapsuleFragment.Component = CapsuleComponent;

				FAgentRadiusFragment& RadiusFragment = EntityView.GetFragmentData<FAgentRadiusFragment>();
				RadiusFragment.Radius = CapsuleComponent->GetScaledCapsuleRadius();

				if (bSyncTransform)
				{
					FTransformFragment& TransformFragment = EntityView.GetFragmentData<FTransformFragment>();
					TransformFragment.GetMutableTransform() = CapsuleComponent->GetComponentTransform();
				}
			}
		});

	if (bSyncTransform || BuildContext.IsInspectingData())
	{
		if (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::ActorToMass) || BuildContext.IsInspectingData())
		{
			BuildContext.AddTranslator<UMassCapsuleTransformToMassTranslator>();
		}

		if (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::MassToActor) || BuildContext.IsInspectingData())
		{
			BuildContext.AddTranslator<UMassTransformToActorCapsuleTranslator>();
		}
	}
}

//----------------------------------------------------------------------//
//  UMassAgentMovementSyncTrait
//----------------------------------------------------------------------//
void UMassAgentMovementSyncTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	BuildContext.AddFragment<FCharacterMovementComponentWrapperFragment>();
	BuildContext.AddFragment<FMassVelocityFragment>();
	
	BuildContext.GetMutableObjectFragmentInitializers().Add([=](UObject& Owner, FMassEntityView& EntityView, const EMassTranslationDirection CurrentDirection)
		{
			if (UCharacterMovementComponent* MovementComp = FMassAgentTraitsHelper::AsComponent<UCharacterMovementComponent>(Owner))
			{
				FCharacterMovementComponentWrapperFragment& ComponentFragment = EntityView.GetFragmentData<FCharacterMovementComponentWrapperFragment>();
				ComponentFragment.Component = MovementComp;

				FMassVelocityFragment& VelocityFragment = EntityView.GetFragmentData<FMassVelocityFragment>();

				// the entity is the authority
				if (CurrentDirection ==  EMassTranslationDirection::MassToActor)
				{
					MovementComp->bRunPhysicsWithNoController = true;
					MovementComp->SetMovementMode(EMovementMode::MOVE_Walking);
					MovementComp->Velocity = VelocityFragment.Value;
				}
				// actor is the authority
				else
				{
					VelocityFragment.Value = MovementComp->GetLastUpdateVelocity();
				}
			}
		});

	if (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::ActorToMass) || BuildContext.IsInspectingData())
	{
		BuildContext.AddTranslator<UMassCharacterMovementToMassTranslator>();
	}

	if (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::MassToActor) || BuildContext.IsInspectingData())
	{
		BuildContext.AddTranslator<UMassCharacterMovementToActorTranslator>();
	}
}

//----------------------------------------------------------------------//
//  UMassAgentOrientationSyncTrait
//----------------------------------------------------------------------//
void UMassAgentOrientationSyncTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	BuildContext.RequireFragment<FCharacterMovementComponentWrapperFragment>();

	if (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::ActorToMass) 
		|| BuildContext.IsInspectingData())
	{
		BuildContext.AddTranslator<UMassCharacterOrientationToMassTranslator>();
	}

	if (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::MassToActor)
		|| BuildContext.IsInspectingData())
	{
		BuildContext.AddTranslator<UMassCharacterOrientationToActorTranslator>();
	}
}

//----------------------------------------------------------------------//
//  UMassAgentFeetLocationSyncTrait
//----------------------------------------------------------------------//
void UMassAgentFeetLocationSyncTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	BuildContext.AddFragment<FMassSceneComponentWrapperFragment>();
	BuildContext.AddFragment<FTransformFragment>();

	BuildContext.GetMutableObjectFragmentInitializers().Add([=](UObject& Owner, FMassEntityView& EntityView, const EMassTranslationDirection CurrentDirection)
		{
			AActor* AsActor = Cast<AActor>(&Owner);
			if (AsActor && AsActor->GetRootComponent())
			{
				USceneComponent* Component = AsActor->GetRootComponent();
				FMassSceneComponentWrapperFragment& ComponentFragment = EntityView.GetFragmentData<FMassSceneComponentWrapperFragment>();
				ComponentFragment.Component = Component;

				FTransformFragment& TransformFragment = EntityView.GetFragmentData<FTransformFragment>();

				REDIRECT_OBJECT_TO_VLOG(Component, &Owner);
				UE_VLOG_LOCATION(&Owner, LogMass, Log, Component->GetComponentLocation(), 30, FColor::Yellow, TEXT("Initial component location"));
				UE_VLOG_LOCATION(&Owner, LogMass, Log, TransformFragment.GetTransform().GetLocation(), 30, FColor::Red, TEXT("Initial entity location"));

				// the entity is the authority
				if (CurrentDirection == EMassTranslationDirection::MassToActor)
				{
					// Temporary disabling this as it is already done earlier in the MassRepresentation and we needed to do a sweep to find the floor
					//Component->SetWorldLocation(FeetLocation, /*bSweep*/true, nullptr, ETeleportType::TeleportPhysics);
				}
				// actor is the authority
				else
				{
					TransformFragment.GetMutableTransform().SetLocation(Component->GetComponentTransform().GetLocation() - FVector(0.f, 0.f, Component->Bounds.BoxExtent.Z));
				}
			}
		});

	if (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::ActorToMass)
		|| BuildContext.IsInspectingData())
	{
		BuildContext.AddTranslator<UMassSceneComponentLocationToMassTranslator>();
	}

	if (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::MassToActor)
		|| BuildContext.IsInspectingData())
	{
		BuildContext.AddTranslator<UMassSceneComponentLocationToActorTranslator>();
	}
}


=====================================================


=== Source/MassActors/Public/Translators/MassCapsuleComponentTranslators.h ===
==============================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassCommonFragments.h"
#include "MassTranslator.h"
#include "MassCapsuleComponentTranslators.generated.h"


class UCapsuleComponent;
struct FAgentRadiusFragment;

USTRUCT()
struct FCapsuleComponentWrapperFragment : public FObjectWrapperFragment
{
	GENERATED_BODY()
	TWeakObjectPtr<UCapsuleComponent> Component;
};

/**
 * @todo TBD
 * I'm a bit on a fence regarding having separate tags per copy direction. My concern is that we can end up with a very 
 * dispersed entity population spread across multiple archetypes storing a small number of entities each. An alternative
 * would be to have a property on the Wrapper fragment, but that doesn't sit well with me either, since that data would be 
 * essentially static, meaning it will (in most cases) never change for a given entity, and we could waste a lot of time 
 * iterating over fragments just to check that specific value.
 */
USTRUCT()
struct FMassCapsuleTransformCopyToMassTag : public FMassTag
{
	GENERATED_BODY()
};

UCLASS()
class MASSACTORS_API UMassCapsuleTransformToMassTranslator : public UMassTranslator
{
	GENERATED_BODY()
public:
	UMassCapsuleTransformToMassTranslator();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;	

	FMassEntityQuery EntityQuery;
};

USTRUCT()
struct FMassCapsuleTransformCopyToActorTag : public FMassTag
{
	GENERATED_BODY()
};

UCLASS()
class MASSACTORS_API UMassTransformToActorCapsuleTranslator : public UMassTranslator
{
	GENERATED_BODY()
public:
	UMassTransformToActorCapsuleTranslator();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};

==============================================================================


=== Source/MassActors/Public/Translators/MassCharacterMovementTranslators.h ===
===============================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassCommonFragments.h"
#include "MassTranslator.h"
#include "MassObserverProcessor.h"
#include "MassCharacterMovementTranslators.generated.h"

class UCharacterMovementComponent;

USTRUCT()
struct FCharacterMovementComponentWrapperFragment : public FObjectWrapperFragment
{
	GENERATED_BODY()
	TWeakObjectPtr<UCharacterMovementComponent> Component;
};

USTRUCT()
struct FMassCharacterMovementCopyToMassTag : public FMassTag
{
	GENERATED_BODY()
};

UCLASS()
class MASSACTORS_API UMassCharacterMovementToMassTranslator : public UMassTranslator
{
	GENERATED_BODY()

public:
	UMassCharacterMovementToMassTranslator();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};

USTRUCT()
struct FMassCharacterMovementCopyToActorTag : public FMassTag
{
	GENERATED_BODY()
};


UCLASS()
class MASSACTORS_API UMassCharacterMovementToActorTranslator : public UMassTranslator
{
	GENERATED_BODY()

public:
	UMassCharacterMovementToActorTranslator();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};


USTRUCT()
struct FMassCharacterOrientationCopyToMassTag : public FMassTag
{
	GENERATED_BODY()
};

UCLASS()
class MASSACTORS_API UMassCharacterOrientationToMassTranslator : public UMassTranslator
{
	GENERATED_BODY()

public:
	UMassCharacterOrientationToMassTranslator();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};

USTRUCT()
struct FMassCharacterOrientationCopyToActorTag : public FMassTag
{
	GENERATED_BODY()
};


UCLASS()
class MASSACTORS_API UMassCharacterOrientationToActorTranslator : public UMassTranslator
{
	GENERATED_BODY()

public:
	UMassCharacterOrientationToActorTranslator();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};

===============================================================================


=== Source/MassActors/Public/Translators/MassSceneComponentLocationTranslator.h ===
===================================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassCommonFragments.h"
#include "MassTranslator.h"
#include "MassSceneComponentLocationTranslator.generated.h"


USTRUCT()
struct FMassSceneComponentWrapperFragment : public FObjectWrapperFragment
{
	GENERATED_BODY()
	TWeakObjectPtr<USceneComponent> Component;
};

USTRUCT()
struct FMassSceneComponentLocationCopyToMassTag : public FMassTag
{
	GENERATED_BODY()
};

UCLASS()
class MASSACTORS_API UMassSceneComponentLocationToMassTranslator : public UMassTranslator
{
	GENERATED_BODY()

public:
	UMassSceneComponentLocationToMassTranslator();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};


USTRUCT()
struct FMassSceneComponentLocationCopyToActorTag : public FMassTag
{
	GENERATED_BODY()
};

UCLASS()
class MASSACTORS_API UMassSceneComponentLocationToActorTranslator : public UMassTranslator
{
	GENERATED_BODY()

public:
	UMassSceneComponentLocationToActorTranslator();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};
===================================================================================


=== Source/MassActors/Public/Translators/MassTranslators_BehaviorTree.h ===
===========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassTranslator.h"
#include "MassCommonFragments.h"
#include "MassTranslators_BehaviorTree.generated.h"

//////////////////////////////////////////////////////////////////////////
class UBehaviorTreeComponent;

USTRUCT()
struct FDataFragment_BehaviorTreeComponentWrapper : public FObjectWrapperFragment
{
	GENERATED_BODY()
	TWeakObjectPtr<UBehaviorTreeComponent> Component;
};

UCLASS()
class MASSACTORS_API UMassTranslator_BehaviorTree : public UMassTranslator
{
	GENERATED_BODY()

public:
	UMassTranslator_BehaviorTree();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override {}

	FMassEntityQuery EntityQuery;
};

===========================================================================


=== Source/MassActors/Public/IMassActorsModule.h ===
====================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleInterface.h"
#include "Modules/ModuleManager.h"


/**
 * The public interface to this module.  In most cases, this interface is only public to sibling modules 
 * within this plugin.
 */
class IMassActorsModule : public IModuleInterface
{

public:

	/**
	 * Singleton-like access to this module's interface.  This is just for convenience!
	 * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.
	 *
	 * @return Returns singleton instance, loading the module on demand if needed
	 */
	static inline IMassActorsModule& Get()
	{
		return FModuleManager::LoadModuleChecked<IMassActorsModule>( "MassActors" );
	}

	/**
	 * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.
	 *
	 * @return True if the module is loaded and ready to use
	 */
	static inline bool IsAvailable()
	{
		return FModuleManager::Get().IsModuleLoaded( "MassActors" );
	}
};


====================================================


=== Source/MassActors/Public/MassActorHelper.h ===
==================================================

// Copyright Epic Games, Inc.All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"

class UScriptStruct;
class AActor;

namespace UE::MassActor
{
	/** 
	 * Finds the entity associated with Actor and adds TagType to it,
	 * @return true if successful, false otherwise (see log for details)
	 */
	bool MASSACTORS_API AddEntityTagToActor(const AActor& Actor, const UScriptStruct& TagType);

	/**
	 * Finds the entity associated with Actor and adds TagType to it,
	 * @return true if successful, false otherwise (see log for details)
	 */
	template<typename TagType>
	bool AddEntityTagToActor(const AActor& Actor)
	{
		static_assert(TIsDerivedFrom<TagType, FMassTag>::IsDerived, "Given struct doesn't represent a valid tag type.");
		return AddEntityTagToActor(Actor, *TagType::StaticStruct());
	}

	/**
	 * Finds the entity associated with Actor and remove TagType from its composition
	 * @return true if successful, false otherwise (see log for details)
	 */
	bool MASSACTORS_API RemoveEntityTagFromActor(const AActor& Actor, const UScriptStruct& TagType);

	/**
	 * Finds the entity associated with Actor and remove TagType from its composition
	 * @return true if successful, false otherwise (see log for details)
	 */
	template<typename TagType>
	bool RemoveEntityTagFromActor(const AActor& Actor)
	{
		static_assert(TIsDerivedFrom<TagType, FMassTag>::IsDerived, "Given struct doesn't represent a valid tag type.");
		return RemoveEntityTagFromActor(Actor, *TagType::StaticStruct());
	}
} // namespace UE::MassActor

==================================================


=== Source/MassActors/Public/MassActorPoolableInterface.h ===
=============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "UObject/Interface.h"

#include "MassActorPoolableInterface.generated.h"

UINTERFACE(Blueprintable)
class MASSACTORS_API UMassActorPoolableInterface : public UInterface
{
	GENERATED_UINTERFACE_BODY()
};

class MASSACTORS_API IMassActorPoolableInterface : public IInterface
{
	GENERATED_IINTERFACE_BODY()

public:

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Mass|Actor Pooling")
	bool CanBePooled();

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Mass|Actor Pooling")
	void PrepareForPooling();

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Mass|Actor Pooling")
	void PrepareForGame();
};
=============================================================


=== Source/MassActors/Public/MassActorSpawnerSubsystem.h ===
============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "StructUtils/InstancedStruct.h"
#include "IndexedHandle.h"
#include "Delegates/Delegate.h"
#include "MassCommonTypes.h"
#include "Templates/SubclassOf.h"
#include "GameFramework/Actor.h"
#include "MassSubsystemBase.h"

#include "MassActorSpawnerSubsystem.generated.h"


class ULevel; 
struct FActorSpawnParameters;

// Handle for an actor spawning request
USTRUCT()
struct MASSACTORS_API FMassActorSpawnRequestHandle : public FIndexedHandleBase
{
	GENERATED_BODY()

	FMassActorSpawnRequestHandle() = default;

	/** @note passing INDEX_NONE as index will make this handle Invalid */
	FMassActorSpawnRequestHandle(const int32 InIndex, const uint32 InSerialNumber) : FIndexedHandleBase(InIndex, InSerialNumber)
	{
	}
};

// Managing class of spawning requests handles
typedef FIndexedHandleManager<FMassActorSpawnRequestHandle, true/*bOptimizeHandleReuse*/> FMassEntityHandleManager_ActorSpawnRequest;


DECLARE_DELEGATE_TwoParams(FMassActorPreSpawnDelegate, const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest);
enum class EMassActorSpawnRequestAction : uint8
{
	Keep, // Will leave spawning request in the queue and it will be users job to call RemoveActorSpawnRequest
	Remove, // Will remove the spawning request from the queue once the callback ends
};
DECLARE_DELEGATE_RetVal_TwoParams(EMassActorSpawnRequestAction, FMassActorPostSpawnDelegate, const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest);

UENUM()
enum class ESpawnRequestStatus : uint8
{
	None, // Not in the queue to be spawn
	Pending, // Still in the queue to be spawn
	Processing, // in the process of spawning the actor
	Succeeded, // Successfully spawned the actor
	Failed, // Error while spawning the actor
	RetryPending, // Failed spawn request that are being retried (lower priority)
};

/**
 * Base class for all spawn request
 */
USTRUCT()
struct MASSACTORS_API FMassActorSpawnRequest
{
	GENERATED_BODY()
public:
	/** The actual mass agent handle corresponding to the actor to spawn */
	FMassEntityHandle MassAgent;

	/** The template BP actor to spawn */
	UPROPERTY(Transient)
	TSubclassOf<AActor> Template;

	/** The location of where to spawn that actor */
	FTransform	Transform;

	/** Priority of this spawn request in comparison with the others, the lower the value is, the higher the priority is */
	float Priority = MAX_FLT;

	/** Delegate that will be called just before the spawning an actor, giving the chance to the processor to prepare it */
	FMassActorPreSpawnDelegate ActorPreSpawnDelegate;

	/** 
	 * Delegate that will be called once the spawning is done. Note that it will be called regardless of whether 
	 * the spawning was successful. 
	 */
	FMassActorPostSpawnDelegate ActorPostSpawnDelegate;

	/** The current status of the spawn request */
	ESpawnRequestStatus SpawnStatus = ESpawnRequestStatus::None;

	/** The pointer to the actor once it is spawned */
	UPROPERTY(Transient)
	TObjectPtr<AActor> SpawnedActor = nullptr;

	/** Internal request serial number (used to cycle through next spawning request) */
	uint32 SerialNumber = 0;

	/** Requested world time seconds */
	double RequestedTime = 0.;

	/** If set, will be used to name the spawned character */
	FGuid Guid;

	void Reset()
	{
		MassAgent = FMassEntityHandle();
		Template = nullptr;
		Priority = MAX_FLT;
		ActorPreSpawnDelegate.Unbind();
		ActorPostSpawnDelegate.Unbind();
		SpawnStatus = ESpawnRequestStatus::None;
		SpawnedActor = nullptr;
		SerialNumber = 0;
		RequestedTime = 0.0f;
	}

	bool IsFinished() const { return SpawnStatus == ESpawnRequestStatus::Failed || SpawnStatus == ESpawnRequestStatus::Succeeded; }
};

/**
 * A subsystem managing spawning of actors for all mass subsystems
 */
UCLASS(transient)
class MASSACTORS_API UMassActorSpawnerSubsystem : public UMassSubsystemBase
{
	GENERATED_BODY()

protected:
	// USubsystem BEGIN
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;
	// USubsystem END

public:
	static void AddReferencedObjects(UObject* InThis, FReferenceCollector& Collector);

	/** Request an actor to spawn
	 * Note: If you do not provide a spawn delegate, the requester is responsible to remove the request by hand.
	 * It will be auto removed after the execution of the spawn delegate.
	 * @param InSpawnRequest the spawn request parameters, You can provide any type of UStruct as long at it derives from FMassActorSpawnRequest. This let you add more spawning information.
	 */
	template< typename T, typename = typename TEnableIf<TIsDerivedFrom<typename TRemoveReference<T>::Type, FMassActorSpawnRequest>::IsDerived, void>::Type >
	FMassActorSpawnRequestHandle RequestActorSpawn(const T& InSpawnRequest)
	{
		return RequestActorSpawnInternal(FConstStructView::Make(InSpawnRequest));
	}

	/**
	 * Process a valid spawn request indicated by given handle. Can be used to force instant-spawn of an actor provided 
	 * a valid handle is obtained by calling RequestActorSpawn first. 
	 * @return indicates the status of processed spawn request, with ESpawnRequestStatus::None indicating that "something 
	 *	went wrong" and spawning request has not been processed. 
	 */
	[[nodiscard]] ESpawnRequestStatus ProcessSpawnRequest(const FMassActorSpawnRequestHandle SpawnRequestHandle);

	/** 
	 * Similar to the other ProcessSpawnRequest flavor, but with SpawnRequestView and SpawnRequest already provided. 
	 */
	[[nodiscard]] ESpawnRequestStatus ProcessSpawnRequest(const FMassActorSpawnRequestHandle SpawnRequestHandle, FStructView SpawnRequestView, FMassActorSpawnRequest& SpawnRequest);

	/** Retries a failed spawn request
	 * @param SpawnRequestHandle the spawn request handle to retry
	 */
	void RetryActorSpawnRequest(const FMassActorSpawnRequestHandle SpawnRequestHandle);

	/**
	 * Removes a spawn request
	 * The only time a spawn request cannot be removed is when its state is processing
	 * Also spawn requests are auto removed if you provided a spawn delegate after it was being executed.
	 * @param SpawnRequestHandle [IN/OUT] the spawn request handle to remove
	 * @return true if successfully removed the request
	 */
	bool RemoveActorSpawnRequest(FMassActorSpawnRequestHandle& SpawnRequestHandle);

	/**
	 * Returns the stored spawn request from the handle, useful to update the transform
	 * @param SpawnRequestHandle the spawn request handle to get the request from
	 * @return The spawn request cast in the provided template argument
	 */
	template<typename T>
	const T& GetSpawnRequest(const FMassActorSpawnRequestHandle SpawnRequestHandle) const
	{
		check(SpawnRequestHandleManager.IsValidHandle(SpawnRequestHandle));
		check(SpawnRequests.IsValidIndex(SpawnRequestHandle.GetIndex()));
		return SpawnRequests[SpawnRequestHandle.GetIndex()].Get<T>();
	}

	/**
	 * Returns the stored spawn request from the handle, useful to update the transform
	 * @param SpawnRequestHandle the spawn request handle to get the request from
	 * @return The spawn request cast in the provided template argument
	 */
	template<typename T> 
	T& GetMutableSpawnRequest(const FMassActorSpawnRequestHandle SpawnRequestHandle)
	{
		check(SpawnRequestHandleManager.IsValidHandle(SpawnRequestHandle));
		check(SpawnRequests.IsValidIndex(SpawnRequestHandle.GetIndex()));
		return SpawnRequests[SpawnRequestHandle.GetIndex()].GetMutable<T>();
	}

	bool IsSpawnRequestHandleValid(const FMassActorSpawnRequestHandle SpawnRequestHandle) const
	{
		return SpawnRequestHandleManager.IsValidHandle(SpawnRequestHandle);
	}

	/**
	 * Destroy an actor 
	 * @param Actor to destroy
	 * @param bImmediate to do the destruction immediately, otherwise will be queued up for later
	 */
	virtual void DestroyActor(AActor* Actor, bool bImmediate = false);
	
	void EnableActorPooling();
	void DisableActorPooling();
	bool IsActorPoolingEnabled();

	void ReleaseAllResources();

protected:
	/** 
	 * Provides consistent way of conditional destroying Actor within World. The actual destruction depends on Actor's state
	 * and whether it belongs to World
	 */
	static void ConditionalDestroyActor(UWorld& World, AActor& ActorToDestroy);

	/** Called at the start of the PrePhysics mass processing phase and calls ProcessPendingSpawningRequest */ 
	void OnPrePhysicsPhaseStarted(const float DeltaSeconds);
	
	/** Called at the end of the PrePhysics mass processing phase and calls ProcessPendingDestruction */ 
	void OnPrePhysicsPhaseFinished(const float DeltaSeconds); 
	
	/** 
	 *  Retrieve what would be the next best spawning request to spawn, can be overridden to have different logic
	 *  Default implementation is the first valid request in the list, no interesting logic yet
	 *  @param InOutHandleIndex used to start the search in subsequent locations. Also the index ensures the same handle 
	 *    won't get returned twice in a row. InOutHandleIndex being INDEX_NONE indicates this is the first run, so all 
	 *    handles are to be considered. If it's a  valid index then we iterate all but one to not even consider the 
	 *    handle indicated by InOutHandleIndex.
	 *  @return the next best handle to spawn. 
	 */
	virtual FMassActorSpawnRequestHandle GetNextRequestToSpawn(int32& InOutHandleIndex) const;

	virtual ESpawnRequestStatus SpawnOrRetrieveFromPool(FConstStructView SpawnRequestView, TObjectPtr<AActor>& OutSpawnedActor);

	/** Actual code that will spawn the actor, overridable by subclass if need to be.
	 *  @return spawned actor if succeeded. */
	virtual ESpawnRequestStatus SpawnActor(FConstStructView SpawnRequestView, TObjectPtr<AActor>& OutSpawnedActor, FActorSpawnParameters& InOutSpawnParameters) const;

	TObjectPtr<AActor> FindActorByName(const FName ActorName, ULevel* OverrideLevel) const;

	/** Go through the spawning request and spawn them until we reach the budget 
	 * @param MaxTimeSlicePerTick is the budget in seconds allowed to do spawning */
	void ProcessPendingSpawningRequest(const double MaxTimeSlicePerTick);

	/** Go through the queued actors to destroy and destroy them until we reach the budget
	 * @param MaxTimeSlicePerTick is the budget in seconds allowed to do destruction */
	void ProcessPendingDestruction(const double MaxTimeSlicePerTick);

	/** Try releasing this actor to pool if possible 
	 * @param Actor to release to the bool
	 * @return true if the actor was actually released to the pool */
	virtual bool ReleaseActorToPool(AActor* Actor);

	/** Internal generic request actor spawn to make sure the request derives from FMassActorSpawnRequest 
	 *  @param SpawnRequest the spawn request parameters, We are allowing any type of spawn request, let's store it internally as a FInstancedStruct. This parameter is the FStructView over provide user struct */
	FMassActorSpawnRequestHandle RequestActorSpawnInternal(const FConstStructView SpawnRequest);

protected:

	UPROPERTY()
	TArray<FInstancedStruct> SpawnRequests;

	UPROPERTY()
	TArray<TObjectPtr<AActor>> ActorsToDestroy;

	UPROPERTY()
	TArray<TObjectPtr<AActor>> DeactivatedActorsToDestroy;

	bool bActorPoolingEnabled = true;

	TMap<TSubclassOf<AActor>, TArray<TObjectPtr<AActor>>> PooledActors;

	FMassEntityHandleManager_ActorSpawnRequest SpawnRequestHandleManager;

	std::atomic<uint32> RequestSerialNumberCounter;

	mutable int32 NumActorSpawned = 0;
	mutable int32 NumActorPooled = 0;

	int32 StartingHandleIndex = INDEX_NONE;

public:
	UE_DEPRECATED(5.4, "This flavor of GetNextRequestToSpawn is deprecated. Use the alternative taking an int32& parameter")
	virtual FMassActorSpawnRequestHandle GetNextRequestToSpawn() const final;
};

============================================================


=== Source/MassActors/Public/MassActorSubsystem.h ===
=====================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "Engine/ActorInstanceHandle.h"
#include "MassCommonFragments.h"
#include "Misc/MTAccessDetector.h"
#include "UObject/ObjectKey.h"
#include "MassSubsystemBase.h"
#include "MassActorSubsystem.generated.h"

struct FMassEntityHandle;
class AActor;
struct FMassEntityManager;
class UMassActorSubsystem;

USTRUCT()
struct MASSACTORS_API FMassGuidFragment : public FObjectWrapperFragment
{
	GENERATED_BODY()

	FGuid Guid;
};

/**
 * Fragment to store the instanced actor handle of a mass entity if it needs one.
 */
USTRUCT()
struct MASSACTORS_API FMassActorInstanceFragment : public FMassFragment
{
	GENERATED_BODY();

	FMassActorInstanceFragment() = default;
	explicit FMassActorInstanceFragment(const FActorInstanceHandle& InHandle)
		: Handle(InHandle)
	{
	}

	UPROPERTY()
	FActorInstanceHandle Handle;
};

namespace UE::Mass::Signals
{
	/** Signal use when the actor instance handle is set or cleared in the associated fragment. */
	const FName ActorInstanceHandleChanged = FName(TEXT("ActorInstanceHandleChanged"));
}

/**
 * Fragment to save the actor pointer of a mass entity if it exists
 */
USTRUCT()
struct MASSACTORS_API FMassActorFragment : public FObjectWrapperFragment
{
	GENERATED_BODY()

	enum class EActorAccess
	{
		OnlyWhenAlive, // Only return an actor pointer if the actor is alive. This is the default.
		IncludePendingKill, // Return an actor pointer even if the actor is marked for destruction.
		IncludeUnreachable // Return an actor pointer even if the actor is unreachable. This implies it's being destroyed.
	};

	/**
	 * Set the actor associated to a mass agent, will also keep the map back in MassActorSubsystem up to date.
	 * @param MassAgent to associated with the actor
	 * @param InActor the actor associated with the mass agent
	 * @param bInIsOwnedByMass tell whether the actors was spawned by mass(MassVisualization) or externally(ReplicatedActors)
	 */
	void SetAndUpdateHandleMap(const FMassEntityHandle MassAgent, AActor* InActor, const bool bInIsOwnedByMass);

	/** 
	 * Resets the actor pointed by this fragment, will also keep the map back in UMassActorSubsystem up to date 
	 * @param CachedActorSubsystem if provided will be used directly, otherwise an instance of UMassActorSubsystem will 
	 *	be deduced from Actor's world (at additional runtime cost)
	 */
	void ResetAndUpdateHandleMap(UMassActorSubsystem* CachedActorSubsystem = nullptr);

	/**
	 * Set the actor associated to a mass agent, will NOT keep map back in MassActorSubsystem up to date.
	 * The user needs to do the map update by hand.
	 * Useful in multithreaded environment, to queue the update of the map inside a deferred command
	 * @param MassAgent to associated with the actor
	 * @param InActor the actor associated with the mass agent
	 * @param bInIsOwnedByMass tell whether the actors was spawned by mass(MassVisualization) or externally(ReplicatedActors)
	 */
	void SetNoHandleMapUpdate(const FMassEntityHandle MassAgent, AActor* InActor, const bool bInIsOwnedByMass);

	/** Resets the actor pointed by this fragment, will NOT keep map back in MassActorSubsystem up to date.
	 * The user needs to do the map update by hand.
	 * Useful in multithreaded environment, to queue the update of the map inside a deferred command
	 */
	void ResetNoHandleMapUpdate();


	/** @return none const pointer to the actor	*/
	FORCEINLINE AActor* GetMutable() { return Actor.Get(); }
	AActor* GetMutable(EActorAccess Access);

	/** @return none const pointer to the actor	only if owned by mass */
	FORCEINLINE AActor* GetOwnedByMassMutable() { return bIsOwnedByMass ? Actor.Get() : nullptr; }

	/** @return none const pointer to the actor	only if owned by mass */
	FORCEINLINE const AActor* Get() const { return Actor.Get(); }
	const AActor* Get(EActorAccess Access) const;

	/** @return if the actor is owned by mass */
	FORCEINLINE bool IsOwnedByMass() const { return bIsOwnedByMass; }

	/** @return if the actor is a valid pointer */
	FORCEINLINE bool IsValid() const { return Actor.IsValid(); }

private:
	// made visible for debugging purposes. It will show up in Mass's gameplay debugger category when viewing fragment details
	UPROPERTY(VisibleAnywhere, Category="Mass", Transient)
	TWeakObjectPtr<AActor> Actor;

	/** Ownership of the actor */
	bool bIsOwnedByMass = false;
};

struct MASSACTORS_API FMassActorManager : public TSharedFromThis<FMassActorManager>
{
public:
	explicit FMassActorManager(const TSharedPtr<FMassEntityManager>& EntityManager, UObject* InOwner = nullptr);

	/** Get mass handle from an actor */
	FMassEntityHandle GetEntityHandleFromActor(const TObjectKey<const AActor> Actor);

	/** Set the mass handle associated to an actor */
	void SetHandleForActor(const TObjectKey<const AActor> Actor, const FMassEntityHandle Handle);

	/** Remove entry associated to an actor */
	void RemoveHandleForActor(const TObjectKey<const AActor> Actor);

	/** Get an actor pointer from a mass handle */
	AActor* GetActorFromHandle(const FMassEntityHandle Handle, 
		FMassActorFragment::EActorAccess Access = FMassActorFragment::EActorAccess::OnlyWhenAlive) const;

	/** 
	 *  Removes the connection between Actor and the given entity. Does all the required book keeping 
	 *  (as opposed to straight up RemoveHandleForActor call). If the Handle doesn't match Actor no action is taken.
	 */
	void DisconnectActor(const TObjectKey<const AActor> Actor, const FMassEntityHandle Handle);

protected:

	TMap<TObjectKey<const AActor>, FMassEntityHandle> ActorHandleMap;
	UE_MT_DECLARE_RW_ACCESS_DETECTOR(ActorHandleMapDetector);
	
	TSharedPtr<FMassEntityManager> EntityManager;

	/** Points at an UObject hosting this instance of the FMassActorManager. It's fine for this to be null. */
	TWeakObjectPtr<UObject> Owner;
};

/**
 * A subsystem managing communication between Actors and Mass
 */
UCLASS()
class MASSACTORS_API UMassActorSubsystem : public UMassSubsystemBase
{
	GENERATED_BODY()

public:
	/** Get mass handle from an actor */
	inline FMassEntityHandle GetEntityHandleFromActor(const TObjectKey<const AActor> Actor);

	/** Set the mass handle associated to an actor */
	inline void SetHandleForActor(const TObjectKey<const AActor> Actor, const FMassEntityHandle Handle);

	/** Remove entry associated to an actor */
	inline void RemoveHandleForActor(const TObjectKey<const AActor> Actor);

	/** Get an actor pointer from a mass handle */
	inline AActor* GetActorFromHandle(const FMassEntityHandle Handle,
		FMassActorFragment::EActorAccess Access = FMassActorFragment::EActorAccess::OnlyWhenAlive) const;

	/** 
	 *  Removes the connection between Actor and the given entity. Does all the required book keeping 
	 *  (as opposed to straight up RemoveHandleForActor call). If the Handle doesn't match Actor no action is taken.
	 */
	inline void DisconnectActor(const TObjectKey<const AActor> Actor, const FMassEntityHandle Handle);

protected:
	// USubsystem BEGIN
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;
	// USubsystem END
	
	TSharedPtr<FMassActorManager> ActorManager;
};

template<>
struct TMassExternalSubsystemTraits<UMassActorSubsystem> final
{
	enum
	{
		GameThreadOnly = false
	};
};

/**
 * UMassActorSubsystem's inlines
 */
FMassEntityHandle UMassActorSubsystem::GetEntityHandleFromActor(const TObjectKey<const AActor> Actor)
{
	return ActorManager->GetEntityHandleFromActor(Actor);
}

void UMassActorSubsystem::SetHandleForActor(const TObjectKey<const AActor> Actor, const FMassEntityHandle Handle)
{
	ActorManager->SetHandleForActor(Actor, Handle);
}

void UMassActorSubsystem::RemoveHandleForActor(const TObjectKey<const AActor> Actor)
{
	ActorManager->RemoveHandleForActor(Actor);
}

AActor* UMassActorSubsystem::GetActorFromHandle(const FMassEntityHandle Handle,
	FMassActorFragment::EActorAccess Access) const
{
	return ActorManager->GetActorFromHandle(Handle, Access);
}

void UMassActorSubsystem::DisconnectActor(const TObjectKey<const AActor> Actor, const FMassEntityHandle Handle) 
{ 
	return ActorManager->DisconnectActor(Actor, Handle); 
}


=====================================================


=== Source/MassActors/Public/MassActorTypes.h ===
=================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Logging/LogMacros.h"


DECLARE_LOG_CATEGORY_EXTERN(LogMassActor, Warning, All);

=================================================


=== Source/MassActors/Public/MassAgentComponent.h ===
=====================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Components/ActorComponent.h"
#include "MassCommonTypes.h"
#include "MassEntityTemplate.h"
#include "MassEntityConfigAsset.h"
#include "MassAgentComponent.generated.h"


UENUM()
enum class EAgentComponentState : uint8
{
	None, // Default starting state

	// States of actors needing mass entity creation
	EntityPendingCreation, // Actor waiting for entity creation
	EntityCreated, // Actor with a created entity

	// States are for Actor driven by Mass (puppet) needing fragments initialization
	PuppetPendingInitialization, // Puppet actor queued for fragments initialization
	PuppetInitialized, // Puppet actor with all initialized fragments
	PuppetPaused, // Puppet actor with all fragments removed 
	PuppetPendingReplication, // Replicated puppet actor waiting for NetID
	PuppetReplicatedOrphan, // Replicated puppet actor not associated to a MassAgent
};


/** 
 *  There are two primary use cases for this component:
 *  1. If placed on an AActor blueprint it lets the user specify additional fragments that will be created for 
 *     entities spawned based on this given blueprint. 
 *  2. If present on an actor in the world it makes it communicate with the MassSimulation which will create an 
 *     entity representing given actor. Use case 1) will also be applicable in this case. The component is unregistered by 
 *     default and requires manual enabling via a 'Enable' call.
 * 
 *  @todo use case 2) is currently sitting in a shelved CL of mine. Will be worked on next.
 */
UCLASS(Blueprintable, ClassGroup = Mass, meta = (BlueprintSpawnableComponent), hidecategories = (Sockets, Collision))
class MASSACTORS_API UMassAgentComponent : public UActorComponent
{
	GENERATED_BODY()

public:

	UMassAgentComponent();

protected:
	virtual void OnRegister() override;
	virtual void OnUnregister() override;

#if WITH_EDITOR
	virtual void PostInitProperties() override;
	virtual void PostLoad() override;
#endif // WITH_EDITOR

public:
	// Support poolable mass agents going into stasis
	void RegisterWithAgentSubsystem();
	void UnregisterWithAgentSubsystem();
	bool IsReadyForPooling() const;

	/** @todo to enforce encapsulation we could make this protected and have a UMassAgentSubsystem friend. I'm not sure I like it though. */

	/** Methods handling the state for actors that needs mass entity creation*/
	FMassEntityHandle GetEntityHandle() const { return AgentHandle; }
	void SetEntityHandle(const FMassEntityHandle NewHandle);
	void ClearEntityHandle();
	void EntityCreationPending();
	void EntityCreationAborted();
	bool IsEntityPendingCreation() const { return (State == EAgentComponentState::EntityPendingCreation); }

	/** Methods handling the state of puppet actors that needs fragments initialization */
	void SetPuppetHandle(const FMassEntityHandle NewHandle);
	void PuppetInitializationPending();
	void PuppetInitializationDone();
	void PuppetInitializationAborted();
	void PuppetUnregistrationDone();
	bool IsPuppetPendingInitialization() const { return (State == EAgentComponentState::PuppetPendingInitialization); }
	bool IsPuppetReplicationPending() const { return (State == EAgentComponentState::PuppetPendingReplication); }
	bool IsPuppet() const { return State == EAgentComponentState::PuppetInitialized || State == EAgentComponentState::PuppetPendingInitialization || State == EAgentComponentState::PuppetPaused; }
	/**
	 * Re-adds/Removes all puppet fragments added on the mass agent
	 * This is only supported in Puppet flow
	 * @param bPause true to pause or false to unpause
	 */
	void PausePuppet(const bool bPause);
	/* @return boolean whether this component was paused via PausePuppet method */
	bool IsPuppetPaused() const { return State == EAgentComponentState::PuppetPaused; }

	/** Methods handling the state of a server replicated puppet */
	void PuppetReplicationPending();
	void SetReplicatedPuppetHandle(FMassEntityHandle NewHandle);
	void ClearReplicatedPuppetHandle();
	void MakePuppetAReplicatedOrphan();

	FMassEntityTemplateID GetTemplateID() const { return TemplateID; }

	const FMassEntityConfig& GetEntityConfig() const { return EntityConfig; }
	void SetEntityConfig(const FMassEntityConfig& InEntityConfig);

	const FMassArchetypeCompositionDescriptor& GetPuppetSpecificAddition() const { return PuppetSpecificAddition; }
	FMassArchetypeCompositionDescriptor& GetMutablePuppetSpecificAddition() { return PuppetSpecificAddition; }

	/** Registers the component with the owner effectively turning it on. Calling it multiple times won't break anything  */
	UFUNCTION(BlueprintCallable, Category = Mass)
	void Enable();

	/** Registers the component with the owner effectively turning it off */
	UFUNCTION(BlueprintCallable, Category = Mass)
	void Disable();

	UFUNCTION(BlueprintCallable, Category = Mass)
	void KillEntity(const bool bDestroyActor);

	//~ Begin UObject Interface
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	//~ End UObject Interface

	FMassNetworkID GetNetID() const
	{
		return NetID;
	}

	UFUNCTION()
	virtual void OnRep_NetID();

protected:

	void SwitchToState(EAgentComponentState NewState);
	void SetEntityHandleInternal(const FMassEntityHandle NewHandle);
	void ClearEntityHandleInternal();
	void DebugCheckStateConsistency();

	/**
	 *  Contains all the fragments added to the entity during puppet's initialization. Required for clean up when
	 *  despawning puppet while the entity remains alive.
	 */
	FMassArchetypeCompositionDescriptor PuppetSpecificAddition;

	UPROPERTY(EditAnywhere, Category = "Mass")
	FMassEntityConfig EntityConfig;
	
	FMassEntityHandle AgentHandle;
	FMassEntityTemplateID TemplateID;

	EAgentComponentState State;

	UPROPERTY(replicatedUsing = OnRep_NetID)
	FMassNetworkID NetID;
	
#if WITH_EDITORONLY_DATA
	UPROPERTY(EditAnywhere, Category = "Mass")
	uint32 bAutoRegisterInEditorMode : 1;
#endif // WITH_EDITORONLY_DATA
};

=====================================================


=== Source/MassActors/Public/MassAgentSubsystem.h ===
=====================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "MassProcessingTypes.h"
#include "MassEntityTemplate.h"
#include "MassSubsystemBase.h"
#include "MassAgentSubsystem.generated.h"

class AActor;
struct FMassEntityManager;
class UMassSpawnerSubsystem;
class UMassAgentComponent;
class UMassSimulationSubsystem;
class UMassAgentSubsystem;
class UMassAgentComponent;
class UMassReplicationSubsystem;

namespace UE::MassActor
{
	DECLARE_MULTICAST_DELEGATE_OneParam(FMassAgentComponentDelegate, const UMassAgentComponent& /*AgentComponent*/);

} // UE::MassActor

USTRUCT()
struct MASSACTORS_API FMassAgentInitializationQueue
{
	GENERATED_BODY()

	UPROPERTY()
	TArray<TObjectPtr<UMassAgentComponent>> AgentComponents;
};

/**
 * A subsystem managing communication between Actors and Mass
 */
UCLASS()
class MASSACTORS_API UMassAgentSubsystem : public UMassSubsystemBase
{
	GENERATED_BODY()

protected:
	// USubsystem BEGIN
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;
	// USubsystem END

public:
	/** Registers given AgentComp with the Mass Simulation, including creation of a FMassEntityHandle using 
	 *  UMassAgentComponent.LWComponentList to determine the Archetype to use. */
	FMassEntityTemplateID RegisterAgentComponent(UMassAgentComponent& AgentComp);

	/** Called for AgentComp that has already been registered with the Agent Manager to notify it that AgentComp's 
	 *  Mass-relevant properties had changed, most notably its fragment composition. The Agent Manager will update 
	 *  the information on Mass side potentially reallocating the associated entity to a different archetype */
	void UpdateAgentComponent(const UMassAgentComponent& AgentComp);

	/**
	 * Removes given AgentComp instance from the system. If there's an entity created with the AgentComp
	 *  instance then it will be destroyed.
	 * @param AgentComp the component to unregister from the system
	 */
	 void UnregisterAgentComponent(UMassAgentComponent& AgentComp);

	 /**
	  * Same as UnregisterAgentComponent, but on top of that it tells the system it will never register again
	  * @param AgentComp the component to shutdown from the system
	  */
	 void ShutdownAgentComponent(UMassAgentComponent& AgentComp);

	/** lets the system know given agent is a puppet (an unreal-side representation of a mass entity) */
	void MakePuppet(UMassAgentComponent& AgentComp);

	/**
	 * Notifies that this MassAgentComponent is now replicated with a valid NetID
	 * @param AgentComp that is now replicated
	 */
	void NotifyMassAgentComponentReplicated(UMassAgentComponent& AgentComp);

	/**
	 * Notifies that this MassAgentComponent is now associated to a mass entity
	 * @param AgentComp that is now associated to a mass entity
	 */
	void NotifyMassAgentComponentEntityAssociated(const UMassAgentComponent& AgentComp) const;

	/**
	 * Notifies that this MassAgentComponent is now detaching from its mass entity
	 * @param AgentComp that is detaching from its mass entity
	 */
	void NotifyMassAgentComponentEntityDetaching(const UMassAgentComponent& AgentComp) const;

	/**
	 * @return The delegate of when MassAgentComponent gets associated to a mass entity
	 */
	UE::MassActor::FMassAgentComponentDelegate& GetOnMassAgentComponentEntityAssociated()
	{
		return OnMassAgentComponentEntityAssociated;
	}

	/**
	 * @return The delegate of when MassAgentComponent is detaching from its mass entity
	 */
	UE::MassActor::FMassAgentComponentDelegate& GetOnMassAgentComponentEntityDetaching()
	{
		return OnMassAgentComponentEntityDetaching;
	}

protected:
	/** 
	 * Processes PendingAgentEntities to initialize fragments of recently created agent entities and PendingPuppets 
	 * to create and initialize puppet-specific fragments 
	 */
	void HandlePendingInitialization();

	/** Bound to UMassSimulationSubsystem.OnProcessingPhaseStartedDelegate and called before every processing phase start */
	void OnProcessingPhaseStarted(const float DeltaSeconds, const EMassProcessingPhase Phase);

	/** Callback registered to the replication manager when a mass agent is added to the replication (client only) */
	void OnMassAgentAddedToReplication(FMassNetworkID NetID, FMassEntityHandle Entity);

	/** Callback registered to the replication manager when a mass agent is removed from the replication (client only) */
	void OnMassAgentRemovedFromReplication(FMassNetworkID NetID, FMassEntityHandle Entity);

protected:
	TSharedPtr<FMassEntityManager> EntityManager;

	UPROPERTY()
	TObjectPtr<UMassSpawnerSubsystem> SpawnerSystem;

	UPROPERTY()
	TObjectPtr<UMassSimulationSubsystem> SimulationSystem;

	UPROPERTY()
	TMap<FMassEntityTemplateID, FMassAgentInitializationQueue> PendingAgentEntities;

	UPROPERTY()
	TMap<FMassEntityTemplateID, FMassAgentInitializationQueue> PendingPuppets;

	UPROPERTY()
	TObjectPtr<UMassReplicationSubsystem> ReplicationSubsystem;

	UPROPERTY()
	TMap<FMassNetworkID, TObjectPtr<UMassAgentComponent>> ReplicatedAgentComponents;

	UE::MassActor::FMassAgentComponentDelegate OnMassAgentComponentEntityAssociated;
	UE::MassActor::FMassAgentComponentDelegate OnMassAgentComponentEntityDetaching;
};

=====================================================


=== Source/MassActors/Public/MassAgentTraits.h ===
==================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "MassEntityTraitBase.h"
#include "MassTranslator.h"
#include "MassAgentTraits.generated.h"

class USceneComponent;

UCLASS(Abstract)
class MASSACTORS_API UMassAgentSyncTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

public:
	EMassTranslationDirection GetSyncDirection() const { return SyncDirection; }
	void SetSyncDirection(const EMassTranslationDirection NewDirection) { SyncDirection = NewDirection; }

protected:
	UPROPERTY(EditAnywhere, Category = Mass)
	EMassTranslationDirection SyncDirection = EMassTranslationDirection::BothWays;
};

/** The trait initializes the entity with actor capsule component's radius. In addition, if bSyncTransform is true 
 *  the trait keeps actor capsule component's and entity's transforms in sync. */
UCLASS(BlueprintType, EditInlineNew, CollapseCategories, meta = (DisplayName = "Agent Capsule Collision Sync"))
class MASSACTORS_API UMassAgentCapsuleCollisionSyncTrait : public UMassAgentSyncTrait
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;

	UPROPERTY(EditAnywhere, Category = Mass)
	bool bSyncTransform = true;
};

UCLASS(BlueprintType, EditInlineNew, CollapseCategories, meta = (DisplayName = "Agent Movement Sync"))
class MASSACTORS_API UMassAgentMovementSyncTrait : public UMassAgentSyncTrait
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;
};

UCLASS(BlueprintType, EditInlineNew, CollapseCategories, meta = (DisplayName = "Agent Orientation Sync"))
class MASSACTORS_API UMassAgentOrientationSyncTrait : public UMassAgentSyncTrait
{
	GENERATED_BODY()

	protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;
};

UCLASS(BlueprintType, EditInlineNew, CollapseCategories, meta = (DisplayName = "Agent Feet Location Sync"))
class MASSACTORS_API UMassAgentFeetLocationSyncTrait : public UMassAgentSyncTrait
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;
};


==================================================


=== Source/MassActors/MassActors.Build.cs ===
=============================================

// Copyright Epic Games, Inc. All Rights Reserved.

namespace UnrealBuildTool.Rules
{
	public class MassActors : ModuleRules
	{
		public MassActors(ReadOnlyTargetRules Target) : base(Target)
		{
			PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

			UnsafeTypeCastWarningLevel = WarningLevel.Warning;

			PublicDependencyModuleNames.AddRange(
				new string[] {
					"Core",
					"CoreUObject",
					"Engine",
					"MassEntity",
					"AIModule",
					"MassCommon",
					"MassMovement",
					"MassSpawner",
					"MassSimulation",
					"MassReplication",
					"MassSignals",
					"NetCore",
				}
			);

			if (Target.bBuildEditor == true)
			{
				PrivateDependencyModuleNames.Add("EditorFramework");
				PrivateDependencyModuleNames.Add("UnrealEd");
			}
		}
	}
}

=============================================


=== Source/MassCommon/Private/MassCommonModule.cpp ===
======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "CoreMinimal.h"
#include "IMassCommonModule.h"
#include "MassCommonTypes.h"


class FMassCommonModule : public IMassCommonModule
{
	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

IMPLEMENT_MODULE(FMassCommonModule, MassCommon)



void FMassCommonModule::StartupModule()
{
	// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)
}


void FMassCommonModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}




======================================================


=== Source/MassCommon/Private/MassCommonTypes.cpp ===
=====================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassCommonTypes.h"

=====================================================


=== Source/MassCommon/Private/MassCommonUtils.cpp ===
=====================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassCommonUtils.h"
#include "Misc/App.h"

namespace UE::Mass::Private
{
    int32 RandomSeedOverride = 7;
    FAutoConsoleVariableRef CVarRandomSeedOverride(
		TEXT("mass.RandomSeedOverride"), 
		RandomSeedOverride, 
		TEXT("If FApp::bUseFixedSeed is true (e.g., -FixedSeed or -Deterministic) this value is used as random seed for all Mass uses."));
}

namespace UE::Mass::Utils
{

	TArray<FMassEntityHandle> EntityQueueToArray(TQueue<FMassEntityHandle, EQueueMode::Mpsc>& EntitiesQueue, const int32 EntitiesCount)
	{
		check(EntitiesCount > 0);
		TArray<FMassEntityHandle> EntitiesArray;
		EntitiesArray.AddUninitialized(EntitiesCount);

		FMassEntityHandle TempEntity;
		uint32 CurrentIndex = 0;
		while (EntitiesQueue.Dequeue(TempEntity))
		{
			EntitiesArray[CurrentIndex++] = TempEntity;
		}
		ensure(CurrentIndex == EntitiesCount);

		return MoveTemp(EntitiesArray);
	}

#if !UE_BUILD_SHIPPING

	bool IsDeterministic()
	{
		return FApp::bUseFixedSeed;
	}

	int32 OverrideRandomSeedForTesting(int32 InSeed)
	{
		if (IsDeterministic())
		{
			return UE::Mass::Private::RandomSeedOverride;
		}
		return InSeed;
	}

	int32 GenerateRandomSeed()
	{
		if (IsDeterministic())
		{
			return UE::Mass::Private::RandomSeedOverride;
		}
		return FMath::Rand();
	}
#endif

} // namespace UE::Mass::Utils

=====================================================


=== Source/MassCommon/Public/IMassCommonModule.h ===
====================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleInterface.h"
#include "Modules/ModuleManager.h"


/**
 * The public interface to this module.  In most cases, this interface is only public to sibling modules 
 * within this plugin.
 */
class IMassCommonModule : public IModuleInterface
{

public:

	/**
	 * Singleton-like access to this module's interface.  This is just for convenience!
	 * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.
	 *
	 * @return Returns singleton instance, loading the module on demand if needed
	 */
	static inline IMassCommonModule& Get()
	{
		return FModuleManager::LoadModuleChecked<IMassCommonModule>( "MassCommon" );
	}

	/**
	 * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.
	 *
	 * @return True if the module is loaded and ready to use
	 */
	static inline bool IsAvailable()
	{
		return FModuleManager::Get().IsModuleLoaded( "MassCommon" );
	}
};


====================================================


=== Source/MassCommon/Public/MassCommonFragments.h ===
======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_2
#include "AI/Navigation/NavigationTypes.h"
#endif //UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_2
#include "MassCommonFragments.generated.h"


USTRUCT()
struct MASSCOMMON_API FTransformFragment : public FMassFragment
{
	GENERATED_BODY()

	FTransformFragment() = default;
	FTransformFragment(const FTransform& InTransform) 
	: Transform(InTransform)
	{}

	const FTransform& GetTransform() const { return Transform; }
	void SetTransform(const FTransform& InTransform) { Transform = InTransform; }
	FTransform& GetMutableTransform() { return Transform; }

protected:
	UPROPERTY(Transient)
	FTransform Transform;
};

USTRUCT()
struct MASSCOMMON_API FAgentRadiusFragment : public FMassFragment
{
	GENERATED_BODY()
	UPROPERTY(EditAnywhere, Category = "")
	float Radius = 40.f;
};

/** This is a common type for all the wrappers pointing at UObjects used to copy data from them or set data based on
 *	Mass simulation..
 */
USTRUCT()
struct FObjectWrapperFragment : public FMassFragment
{
	GENERATED_BODY()
};

======================================================


=== Source/MassCommon/Public/MassCommonTypes.h ===
==================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "MassProcessingTypes.h"
#include "StructUtils/InstancedStruct.h"
#include "SequentialID.h"
#include "MassCommonTypes.generated.h"

#define WITH_MASSGAMEPLAY_DEBUG (!(UE_BUILD_SHIPPING || UE_BUILD_SHIPPING_WITH_EDITOR || UE_BUILD_TEST) && WITH_MASSENTITY_DEBUG && 1)

class UStaticMesh;
class UMaterialInterface;

namespace UE::Mass::ProcessorGroupNames
{
	const FName UpdateWorldFromMass = FName(TEXT("UpdateWorldFromMass"));
	const FName SyncWorldToMass = FName(TEXT("SyncWorldToMass"));
	const FName Behavior = FName(TEXT("Behavior"));
	const FName Tasks = FName(TEXT("Tasks"));
	const FName Avoidance = FName(TEXT("Avoidance"));
	const FName Movement = FName(TEXT("Movement"));
}

USTRUCT()
struct FMassNetworkID : public FSequentialIDBase
{
	GENERATED_BODY()

	FMassNetworkID() = default;
	explicit FMassNetworkID(uint32 InID) : FSequentialIDBase(InID) {}
};

/** Float encoded in int16, 1cm accuracy. */
USTRUCT()
struct MASSCOMMON_API FMassInt16Real
{
	GENERATED_BODY()

	FMassInt16Real() = default;
	
	explicit FMassInt16Real(const float InValue)
	{
		Set(InValue);
	}
	
	void Set(const float InValue)
	{
		Value = (int16)FMath::Clamp(FMath::RoundToInt32(InValue), -(int32)MAX_int16, (int32)MAX_int16);
	}

	float Get() const
	{
		return (float)Value;
	}

	bool operator<(const FMassInt16Real RHS) const { return Value < RHS.Value; }
	bool operator<=(const FMassInt16Real RHS) const { return Value <= RHS.Value; }
	bool operator>(const FMassInt16Real RHS) const { return Value > RHS.Value; }
	bool operator>=(const FMassInt16Real RHS) const { return Value >= RHS.Value; }
	bool operator==(const FMassInt16Real RHS) const { return Value == RHS.Value; }
	bool operator!=(const FMassInt16Real RHS) const { return Value != RHS.Value; }
	
protected:
	UPROPERTY(Transient)
	int16 Value = 0;
};

/** Float encoded in int16, 10cm accuracy. */
USTRUCT()
struct MASSCOMMON_API FMassInt16Real10
{
	GENERATED_BODY()

	static constexpr float Scale = 0.1f;
	
	FMassInt16Real10() = default;
	
	explicit FMassInt16Real10(const float InValue)
	{
		Set(InValue);
	}
	
	void Set(const float InValue)
	{
		Value = (int16)FMath::Clamp(FMath::RoundToInt32(InValue * Scale), -(int32)MAX_int16, (int32)MAX_int16);
	}

	float Get() const
	{
		return (float)Value / Scale;
	}

	bool operator<(const FMassInt16Real10 RHS) const { return Value < RHS.Value; }
	bool operator<=(const FMassInt16Real10 RHS) const { return Value <= RHS.Value; }
	bool operator>(const FMassInt16Real10 RHS) const { return Value > RHS.Value; }
	bool operator>=(const FMassInt16Real10 RHS) const { return Value >= RHS.Value; }
	bool operator==(const FMassInt16Real10 RHS) const { return Value == RHS.Value; }
	bool operator!=(const FMassInt16Real10 RHS) const { return Value != RHS.Value; }

protected:
	UPROPERTY(Transient)
	int16 Value = 0;
};

/** Vector which components are in range [-1..1], encoded in signed bytes. */
USTRUCT()
struct MASSCOMMON_API FMassSnorm8Vector
{
	GENERATED_BODY()

	static constexpr float Scale = (float)MAX_int8;   

	FMassSnorm8Vector() = default;
	
	explicit FMassSnorm8Vector(const FVector& InVector)
	{
		Set(InVector);
	}
	
	void Set(const FVector& InVector)
	{
		X = (int8)FMath::Clamp(FMath::RoundToInt32(InVector.X * Scale), -(int32)MAX_int8, (int32)MAX_int8);
		Y = (int8)FMath::Clamp(FMath::RoundToInt32(InVector.Y * Scale), -(int32)MAX_int8, (int32)MAX_int8);
		Z = (int8)FMath::Clamp(FMath::RoundToInt32(InVector.Z * Scale), -(int32)MAX_int8, (int32)MAX_int8);
	}

	FVector Get() const
	{
		return FVector(X / Scale, Y / Scale, Z / Scale);
	}

protected:
	UPROPERTY(Transient)
	int8 X = 0;

	UPROPERTY(Transient)
	int8 Y = 0;

	UPROPERTY(Transient)
	int8 Z = 0;
};

/** Vector2D which components are in range [-1..1], encoded in signed bytes. */
USTRUCT()
struct MASSCOMMON_API FMassSnorm8Vector2D
{
	GENERATED_BODY()

	static constexpr float Scale = (float)MAX_int8;

	FMassSnorm8Vector2D() = default;

	explicit FMassSnorm8Vector2D(const FVector2D& InVector)
	{
		Set(InVector);
	}
	
	explicit FMassSnorm8Vector2D(const FVector& InVector)
	{
		Set(FVector2D(InVector));
	}

	void Set(const FVector2D& InVector)
	{
		X = (int8)FMath::Clamp(FMath::RoundToInt32(InVector.X * Scale), -(int32)MAX_int8, (int32)MAX_int8);
		Y = (int8)FMath::Clamp(FMath::RoundToInt32(InVector.Y * Scale), -(int32)MAX_int8, (int32)MAX_int8);
	}

	FVector2D Get() const
	{
		return FVector2D(X / Scale, Y / Scale);
	}

	FVector GetVector(const float InZ = 0.0f) const
	{
		return FVector(X / Scale, Y / Scale, InZ);
	}
	
protected:
	UPROPERTY(Transient)
	int8 X = 0;

	UPROPERTY(Transient)
	int8 Y = 0;
};

/** Real in range [0..1], encoded in signed bytes. */
USTRUCT()
struct MASSCOMMON_API FMassUnorm8Real
{
	GENERATED_BODY()

	static constexpr float Scale = MAX_uint8;

	FMassUnorm8Real() = default;

	explicit FMassUnorm8Real(const float InValue)
	{
		Set(InValue);
	}

	void Set(const float InValue)
	{
		Value = (int8)FMath::Clamp(FMath::RoundToInt32(InValue * Scale), 0, (int32)MAX_uint8);
	}

	float Get() const
	{
		return (Value / Scale);
	}

protected:
	UPROPERTY(Transient)
	uint8 Value = 0;
};

/** Vector encoded in int16, 1cm accuracy. */
USTRUCT()
struct MASSCOMMON_API FMassInt16Vector
{
	GENERATED_BODY()

	FMassInt16Vector() = default;
	FMassInt16Vector(const FVector& InVector)
	{
		Set(InVector);
	}
	
	void Set(const FVector& InVector)
	{
		X = (int16)FMath::Clamp(FMath::RoundToInt32(InVector.X), -(int32)MAX_int16, (int32)MAX_int16);
		Y = (int16)FMath::Clamp(FMath::RoundToInt32(InVector.Y), -(int32)MAX_int16, (int32)MAX_int16);
		Z = (int16)FMath::Clamp(FMath::RoundToInt32(InVector.Z), -(int32)MAX_int16, (int32)MAX_int16);
	}

	FVector Get() const
	{
		return FVector(X, Y, Z);
	}

protected:
	UPROPERTY(Transient)
	int16 X = 0;

	UPROPERTY(Transient)
	int16 Y = 0;

	UPROPERTY(Transient)
	int16 Z = 0;
};

/** Vector2D encoded in int16, 1cm accuracy. */
USTRUCT()
struct MASSCOMMON_API FMassInt16Vector2D
{
	GENERATED_BODY()

	FMassInt16Vector2D() = default;
	FMassInt16Vector2D(const FVector2D& InVector)
	{
		Set(InVector);
	}
	FMassInt16Vector2D(const FVector& InVector)
	{
		Set(FVector2D(InVector));
	}
	
	void Set(const FVector2D& InVector)
	{
		X = (int16)FMath::Clamp(FMath::RoundToInt32(InVector.X), -(int32)MAX_int16, (int32)MAX_int16);
		Y = (int16)FMath::Clamp(FMath::RoundToInt32(InVector.Y), -(int32)MAX_int16, (int32)MAX_int16);
	}

	FVector2D Get() const
	{
		return FVector2D(X, Y);
	}

	FVector GetVector(const float InZ = 0.0f) const
	{
		return FVector(X, Y, InZ);
	}

protected:
	UPROPERTY(Transient)
	int16 X = 0;

	UPROPERTY(Transient)
	int16 Y = 0;
};

==================================================


=== Source/MassCommon/Public/MassCommonUtils.h ===
==================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassCommonTypes.h"
#include "Containers/Array.h"
#include "Containers/Queue.h"

namespace UE::Mass::Utils
{
	/** 
	 * Creates a TArray of entities based on the given EntitiesQueue. Note that it's the caller's responsibility to 
	 * ensure EntitiesCount > 0, otherwise the function will fail a check (with explosive results).
	 */
	MASSCOMMON_API TArray<FMassEntityHandle> EntityQueueToArray(TQueue<FMassEntityHandle, EQueueMode::Mpsc>& EntitiesQueue, const int32 EntitiesCount);

#if !UE_BUILD_SHIPPING

	/**
	 * If this is true, then the mass systems should strive to be as deterministic as possible, this will also enable the fixed random seed
	 * Currently maps to FApp::bUseFixedSeed
	 */
	MASSCOMMON_API bool IsDeterministic();

	/**
	 * If IsDeterministic() returns true, then this function will return the value of ai.massrepresentation.OverrideRandomSeed in place of InSeed
	 */
	MASSCOMMON_API int32 OverrideRandomSeedForTesting(int32 InSeed);

	/**
	 * If IsDeterministic() returns true, then this function will return the value of ai.massrepresentation.OverrideRandomSeed in place of FMath::Rand()
	 */
	MASSCOMMON_API int32 GenerateRandomSeed();

#else

	FORCEINLINE constexpr bool IsDeterministic() { return false; }

	FORCEINLINE int32 OverrideRandomSeedForTesting(int32 InSeed) { return InSeed; }

	FORCEINLINE int32 GenerateRandomSeed() { return FMath::Rand(); }
#endif

} // namespace UE::Mass::Utils
==================================================


=== Source/MassCommon/Public/MassGameplaySettings.h ===
=======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassSettings.h"
#include "MassGameplaySettings.generated.h"


UCLASS(config = Mass, defaultconfig, DisplayName = "Mass Gameplay")
class MASSCOMMON_API UMassGameplaySettings : public UMassModuleSettings
{
	GENERATED_BODY()

public:

	UPROPERTY(EditAnywhere, config, Category = Debug, meta = (ConsoleVariable = "mass.debug.VLogSpawnLocations"))
	bool bLogSpawnLocations = true;
};

=======================================================


=== Source/MassCommon/Public/RandomSequence.h ===
=================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreTypes.h"

/**
 * Helper functions to get a random number in a sequence based on Fibonacci hashing.
 * The random numbers are uniformly distributed.
 *
 * In contrast to FRandomStream, where each call to a random function will return new random number,
 * these functions will always return the same value for the same input.
 * That is UE::RandomSequence::FRand(42) is always 0.575462.
 *
 * This is useful for randomizing behaviors or appearances, where an entity index can be used to get a random value,
 * without having to store the actual value:
 *
 *   const float PreferredSpeed = UE::RandomSequence::FRandRange(EntityId.Index, MinSpeed, MaxSpeed);
 * 
 * If multiple values are needed, different parts of the sequence can be used by offsetting the index:
 *
 *   const int32 HatIndex = UE::RandomSequence::RandHelper(EntityId.Index + 31, 0, Hats.Num());
 *   const int32 GroomIndex = UE::RandomSequence::RandHelper(EntityId.Index + 1021, Grooms.Num());
 */

namespace UE::RandomSequence
{
	/**
	 * @return 32 bit fibonacci hash at specified index.
	 */
	FORCEINLINE uint32 FibonacciHash(const int32 SeqIndex)
	{
		constexpr uint32 K = 2654435769u; // 2^32 / phi (golden ratio)
		// Offset the sequence by 1, so that index 0 is not always 0.
		return (uint32)(SeqIndex + 1) * K;
	}
	
	/**
	 * Helper function to return random float.
	 * @return A random number in [0..1]
	 */
	FORCEINLINE float FRand(const int32 SeqIndex)
	{
		float Result;
		*(uint32*)&Result = 0x3F800000U | (FibonacciHash(SeqIndex) >> 9);
		return Result - 1.0f; 
	}

	/**
	 * Helper function to return random int on specified range.
	 * @return A random number in [0..A)
	 */
	FORCEINLINE int32 RandHelper(const int32 SeqIndex, const int32 A)
	{
		return (int32)(((int64)FibonacciHash(SeqIndex) * (int64)A) >> 32);
	}

	/** 
	 * Helper function to return random int in specified range.
	 * @return A random number >= Min and <= Max
	 */
	FORCEINLINE int32 RandRange(const int32 SeqIndex, const int32 InMin, const int32 InMax)
	{
		const int32 Range = (InMax - InMin) + 1;
		return InMin + RandHelper(SeqIndex, Range);
	}
	
	/** 
	 * Helper function to return random float in specified range.
	 * @return A random number >= Min and <= Max
	 */
	FORCEINLINE float FRandRange(const int32 SeqIndex, const float InMin, const float InMax)
	{
		return InMin + (InMax - InMin) * FRand(SeqIndex);
	}

	/** 
	 * Helper function to return random float in specified range.
	 * @return A random number >= Min and <= Max
	 */
	FORCEINLINE float RandRange(const int32 SeqIndex, const float InMin, const float InMax)
	{
		return FRandRange(SeqIndex, InMin, InMax);
	}

	UE_DEPRECATED(5.4, "Please use the correctly spelled version FibonacciHash()")
	FORCEINLINE uint32 FibocciHash(const int32 SeqIndex)
	{
		return FibonacciHash(SeqIndex);
	}
}; // UE::RandomSequence
=================================================


=== Source/MassCommon/MassCommon.Build.cs ===
=============================================

// Copyright Epic Games, Inc. All Rights Reserved.

namespace UnrealBuildTool.Rules
{
	public class MassCommon : ModuleRules
	{
		public MassCommon(ReadOnlyTargetRules Target) : base(Target)
		{
			PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

			UnsafeTypeCastWarningLevel = WarningLevel.Warning;

			PublicDependencyModuleNames.AddRange(
				new string[] {
					"Core",
					"CoreUObject",
					"Engine",
					"AIModule",
					"MassEntity",
				}
			);

			if (Target.bBuildEditor == true)
			{
				PrivateDependencyModuleNames.Add("UnrealEd");
			}
		}
	}
}

=============================================


=== Source/MassEQS/Private/Generators/MassEnvQueryGenerator_MassEntityHandles.cpp ===
=====================================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "Generators/MassEnvQueryGenerator_MassEntityHandles.h"

#include "EnvironmentQuery/Contexts/EnvQueryContext_Querier.h"
#include "Items/EnvQueryItemType_MassEntityHandle.h"
#include "MassEQSSubsystem.h"
#include "MassEQSUtils.h"

#include "MassEntityTypes.h"

UMassEnvQueryGenerator_MassEntityHandles::UMassEnvQueryGenerator_MassEntityHandles(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	ItemType = UEnvQueryItemType_MassEntityHandle::StaticClass();

	SearchRadius.DefaultValue = 500.0f;
	SearchCenter = UEnvQueryContext_Querier::StaticClass();
}

bool UMassEnvQueryGenerator_MassEntityHandles::TryAcquireResults(FEnvQueryInstance& QueryInstance) const
{
	check(MassEQSRequestHandler.MassEQSSubsystem);

	TUniquePtr<FMassEQSRequestData> RawRequestData = MassEQSRequestHandler.MassEQSSubsystem->TryAcquireResults(MassEQSRequestHandler.RequestHandle);
	if (FMassEnvQueryResultData_MassEntityHandles* RequestData = FMassEQSUtils::TryAndEnsureCast<FMassEnvQueryResultData_MassEntityHandles>(RawRequestData))
	{
		QueryInstance.AddItemData<UEnvQueryItemType_MassEntityHandle>(RequestData->GeneratedEntityInfo);
		return true;
	}

	return false;
}

TUniquePtr<FMassEQSRequestData> UMassEnvQueryGenerator_MassEntityHandles::GetRequestData(FEnvQueryInstance& QueryInstance) const
{
	TArray<FVector> PreparedContextPositions = {};
	QueryInstance.PrepareContext(SearchCenter, PreparedContextPositions);

	return MakeUnique<FMassEQSRequestData_MassEntityHandles>(MoveTemp(PreparedContextPositions), SearchRadius.GetValue());
}
=====================================================================================


=== Source/MassEQS/Private/Generators/MassEnvQueryGenerator.cpp ===
===================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "Generators/MassEnvQueryGenerator.h"
#include "MassEQSSubsystem.h"

UMassEnvQueryGenerator::UMassEnvQueryGenerator(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	bCanRunAsync = true;
}

void UMassEnvQueryGenerator::GenerateItems(FEnvQueryInstance& QueryInstance) const
{
	MassEQSRequestHandler.SendOrRecieveRequest(QueryInstance, *this);
}

===================================================================


=== Source/MassEQS/Private/Items/EnvQueryItemType_MassEntityHandle.cpp ===
==========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "Items/EnvQueryItemType_MassEntityHandle.h"

#include "EnvironmentQuery/EnvQueryTypes.h"

#include "MassEntitySubsystem.h"

UEnvQueryItemType_MassEntityHandle::UEnvQueryItemType_MassEntityHandle()
{
	ValueSize = sizeof(FMassEnvQueryEntityInfo);
}

const FMassEnvQueryEntityInfo& UEnvQueryItemType_MassEntityHandle::GetValue(const uint8* RawData)
{
	return GetValueFromMemory<FMassEnvQueryEntityInfo>(RawData);
}

void UEnvQueryItemType_MassEntityHandle::SetValue(uint8* RawData, const FMassEnvQueryEntityInfo& Value)
{
	return SetValueInMemory<FMassEnvQueryEntityInfo>(RawData, Value);
}

FVector UEnvQueryItemType_MassEntityHandle::GetItemLocation(const uint8* RawData) const
{
	const FMassEnvQueryEntityInfo& EntityInfo = GetValue(RawData);	
	return EntityInfo.CachedTransform.GetLocation();
}

FRotator UEnvQueryItemType_MassEntityHandle::GetItemRotation(const uint8* RawData) const
{
	const FMassEnvQueryEntityInfo& EntityInfo = GetValue(RawData);
	return EntityInfo.CachedTransform.GetRotation().Rotator();
}

==========================================================================


=== Source/MassEQS/Private/Processors/MassEnvQueryGeneratorProcessor_MassEntityHandles.cpp ===
==============================================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "Processors/MassEnvQueryGeneratorProcessor_MassEntityHandles.h"

#include "MassExecutionContext.h"
#include "MassCommonFragments.h"
#include "MassObserverRegistry.h"

#include "MassEQSUtils.h"
#include "MassEQSSubsystem.h"

#include "EnvironmentQuery/EnvQueryTypes.h"
#include "Items/EnvQueryItemType_MassEntityHandle.h"
#include "Generators/MassEnvQueryGenerator_MassEntityHandles.h"

UMassEnvQueryGeneratorProcessor_MassEntityHandles::UMassEnvQueryGeneratorProcessor_MassEntityHandles()
	: EntityQuery(*this)
{
	CorrespondingRequestClass = UMassEnvQueryGenerator_MassEntityHandles::StaticClass();
}

void UMassEnvQueryGeneratorProcessor_MassEntityHandles::ConfigureQueries()
{
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	ProcessorRequirements.AddSubsystemRequirement<UMassEQSSubsystem>(EMassFragmentAccess::ReadWrite);
}

void UMassEnvQueryGeneratorProcessor_MassEntityHandles::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	const UWorld* World = GetWorld();
	check(World);

	UMassEQSSubsystem* MassEQSSubsystem = Context.GetMutableSubsystem<UMassEQSSubsystem>();
	check(MassEQSSubsystem);

	// Check for any requests of this type from MassEQSSubsystem, complete one if found.
	TUniquePtr<FMassEQSRequestData> GeneratorDataUniquePtr = MassEQSSubsystem->PopRequest(CachedRequestQueryIndex);
	FMassEQSRequestData_MassEntityHandles* GeneratorData = FMassEQSUtils::TryAndEnsureCast<FMassEQSRequestData_MassEntityHandles>(GeneratorDataUniquePtr);
	if (!GeneratorData)
	{
		return;
	}

	const float SearchRadius = GeneratorData->SearchRadius;
	const TArray<FVector>& ContextPositions = GeneratorData->ContextPositions;

	TArray<FMassEnvQueryEntityInfo> Items = {};
	if (SearchRadius <= 0)
	{
		EntityQuery.ForEachEntityChunk(EntityManager, Context, [&GeneratorData, &Items, &SearchRadius, &ContextPositions](FMassExecutionContext& ChunkContext)
		{
			const TConstArrayView<FTransformFragment> TransformFragmentList = ChunkContext.GetFragmentView<FTransformFragment>();
			const int32 NumEntities = ChunkContext.GetNumEntities();
			for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
			{
				FMassEntityHandle EntityHandle = ChunkContext.GetEntity(EntityIndex);
				Items.Emplace(EntityHandle.Index, EntityHandle.SerialNumber, TransformFragmentList[EntityIndex].GetTransform());
			}
		});
	}
	else
	{
		FVector::FReal SearchRadiusSqr = FMath::Square(SearchRadius);
		EntityQuery.ForEachEntityChunk(EntityManager, Context, [&GeneratorData, &Items, &SearchRadiusSqr, &ContextPositions](FMassExecutionContext& ChunkContext)
		{
			const TConstArrayView<FTransformFragment> TransformFragmentList = ChunkContext.GetFragmentView<FTransformFragment>();
			const int32 NumEntities = ChunkContext.GetNumEntities();
			for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
			{
				const FTransformFragment& TransformFragment = TransformFragmentList[EntityIndex];
				const FVector& EntityPosition = TransformFragment.GetTransform().GetTranslation();
				for (const FVector& ContextPosition : ContextPositions)
				{
					const FVector::FReal ContextDistanceToEntitySqr = FVector::DistSquared(EntityPosition, ContextPosition);

					if (ContextDistanceToEntitySqr <= SearchRadiusSqr)
					{
						FMassEntityHandle EntityHandle = ChunkContext.GetEntity(EntityIndex);
						Items.Emplace(EntityHandle.Index, EntityHandle.SerialNumber, TransformFragmentList[EntityIndex].GetTransform());
						break;
					}
				}
			}
		});
	}
	MassEQSSubsystem->SubmitResults(GeneratorData->RequestHandle, MakeUnique<FMassEnvQueryResultData_MassEntityHandles>(MoveTemp(Items)));
}
==============================================================================================


=== Source/MassEQS/Private/Processors/MassEnvQueryProcessorBase.cpp ===
=======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "Processors/MassEnvQueryProcessorBase.h"

#include "MassEQSSubsystem.h"

void UMassEnvQueryProcessorBase::Initialize(UObject& Owner)
{
	Super::Initialize(Owner);

	if (CorrespondingRequestClass)
	{
		UWorld* World = Owner.GetWorld();
		check(World);
		UMassEQSSubsystem* MassEQSSubsystem = World->GetSubsystem<UMassEQSSubsystem>();
		check(MassEQSSubsystem)
	
		CachedRequestQueryIndex = MassEQSSubsystem->GetRequestQueueIndex(CorrespondingRequestClass);
	}
}
=======================================================================


=== Source/MassEQS/Private/Processors/MassEnvQueryTestProcessor_MassEntityTags.cpp ===
======================================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "Processors/MassEnvQueryTestProcessor_MassEntityTags.h"

#include "Tests/MassEnvQueryTest_MassEntityTags.h"

#include "MassEQSSubsystem.h"
#include "MassEQSTypes.h"
#include "MassEQSUtils.h"
#include "MassEQS.h"

#include "MassCommonFragments.h"
#include "MassExecutionContext.h"

namespace Mass::EQS::Utils
{

	bool TestChunkForAnyTags(const TArray<FInstancedStruct>& Tags, const FMassExecutionContext& Context);
	bool TestChunkForAllTags(const TArray<FInstancedStruct>& Tags, const FMassExecutionContext& Context);
	bool TestChunkForNoTags(const TArray<FInstancedStruct>& Tags, const FMassExecutionContext& Context);

} // namespace Mass::EQS::Utils


UMassEnvQueryTestProcessor_MassEntityTags::UMassEnvQueryTestProcessor_MassEntityTags()
	: EntityQuery(*this)
{
	CorrespondingRequestClass = UMassEnvQueryTest_MassEntityTags::StaticClass();
}

void UMassEnvQueryTestProcessor_MassEntityTags::ConfigureQueries()
{
	ProcessorRequirements.AddSubsystemRequirement<UMassEQSSubsystem>(EMassFragmentAccess::ReadWrite);
}

void UMassEnvQueryTestProcessor_MassEntityTags::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& ExecutionContext)
{
	const UWorld* World = GetWorld();
	check(World);

	UMassEQSSubsystem* MassEQSSubsystem = ExecutionContext.GetMutableSubsystem<UMassEQSSubsystem>();
	check(MassEQSSubsystem);

	// Check for any requests of this type from MassEQSSubsystem, complete one if found.
	TUniquePtr<FMassEQSRequestData> TestDataUniquePtr = MassEQSSubsystem->PopRequest(CachedRequestQueryIndex);
	FMassEQSRequestData_MassEntityTags* TestData = FMassEQSUtils::TryAndEnsureCast<FMassEQSRequestData_MassEntityTags>(TestDataUniquePtr);
	if (!TestData)
	{
		return;
	}
	if (TestDataUniquePtr->EntityHandles.IsEmpty())
	{
		UE_LOG(LogMassEQS, Error, TEXT("Request: [%s] Acquired by UMassEnvQueryTestProcessor_MassEntityTags, but had no Entities to query."), *TestDataUniquePtr->RequestHandle.ToString());
		return;
	}

	const EMassEntityTagsTestMode TagTestMode = TestData->TagTestMode;
	const TArray<FInstancedStruct> Tags = TestData->Tags;

	TFunction<bool(const TArray<FInstancedStruct>&, const FMassExecutionContext&)> ScoringFunction;
	TMap<FMassEntityHandle, bool> ScoreMap = {};

	switch (TagTestMode)
	{
	case EMassEntityTagsTestMode::Any:
	{
		ScoringFunction = Mass::EQS::Utils::TestChunkForAnyTags;
		break;
	}
	case EMassEntityTagsTestMode::All:
	{
		ScoringFunction = Mass::EQS::Utils::TestChunkForAllTags;
		break;
	}
	case EMassEntityTagsTestMode::None:
	{
		ScoringFunction = Mass::EQS::Utils::TestChunkForNoTags;
		break;
	}
	default:
	{
		ScoringFunction = [](const TArray<FInstancedStruct>& Tags, const FMassExecutionContext& Context) { return false; };
		break;
	}
	}

	ensureMsgf(ExecutionContext.GetEntityCollection().IsEmpty(), TEXT("We don't expect any collections to be set at this point. The data is going to be overridden."));

	TArray<FMassArchetypeEntityCollection> EntityCollectionsToTest;
	UE::Mass::Utils::CreateEntityCollections(EntityManager, TestDataUniquePtr->EntityHandles, FMassArchetypeEntityCollection::NoDuplicates, EntityCollectionsToTest);

	EntityQuery.ForEachEntityChunkInCollections(EntityCollectionsToTest, EntityManager, ExecutionContext
		, [&ScoreMap, &ScoringFunction, &Tags](FMassExecutionContext& Context)
		{
			bool ChunkSuccess = ScoringFunction(Tags, Context);

			const int32 NumEntities = Context.GetNumEntities();
			for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
			{
				const FMassEntityHandle EntityHandle = Context.GetEntity(EntityIndex);
				ScoreMap.Add(EntityHandle, ChunkSuccess);
			}
		});

	MassEQSSubsystem->SubmitResults(TestData->RequestHandle, MakeUnique<FMassEnvQueryResultData_MassEntityTags>(MoveTemp(ScoreMap)));
}


bool Mass::EQS::Utils::TestChunkForAnyTags(const TArray<FInstancedStruct>& Tags, const FMassExecutionContext& Context)
{
	for (const FInstancedStruct& Tag : Tags)
	{
		const UScriptStruct* TagScriptStruct = Tag.GetScriptStruct();
#if !UE_BUILD_SHIPPING
		if (!ensureMsgf(TagScriptStruct && TagScriptStruct->IsChildOf(FMassTag::StaticStruct()), TEXT("Non Tag Element Detected in Enviroment Query Mass-Entity-Tags-Test. Likely left empty.")))
		{
			continue;
		}
#endif
		if (Context.DoesArchetypeHaveTag(*Tag.GetScriptStruct()))
		{
			return true;
		}
	}

	return false;
}

bool Mass::EQS::Utils::TestChunkForAllTags(const TArray<FInstancedStruct>& Tags, const FMassExecutionContext& Context)
{
	for (const FInstancedStruct& Tag : Tags)
	{
		const UScriptStruct* TagScriptStruct = Tag.GetScriptStruct();
#if !UE_BUILD_SHIPPING
		if (!ensureMsgf(TagScriptStruct && TagScriptStruct->IsChildOf(FMassTag::StaticStruct()), TEXT("Non Tag Element Detected in Enviroment Query Mass-Entity-Tags-Test. Likely left empty.")))
		{
			continue;
		}
#endif
		if (!Context.DoesArchetypeHaveTag(*Tag.GetScriptStruct()))
		{
			return false;
		}
	}

	return true;
}

bool Mass::EQS::Utils::TestChunkForNoTags(const TArray<FInstancedStruct>& Tags, const FMassExecutionContext& Context)
{
	for (const FInstancedStruct& Tag : Tags)
	{
		const UScriptStruct* TagScriptStruct = Tag.GetScriptStruct();
#if !UE_BUILD_SHIPPING
		if (!ensureMsgf(TagScriptStruct && TagScriptStruct->IsChildOf(FMassTag::StaticStruct()), TEXT("Non Tag Element Detected in Enviroment Query Mass-Entity-Tags-Test. Likely left empty.")))
		{
			continue;
		}
#endif
		if (Context.DoesArchetypeHaveTag(*Tag.GetScriptStruct()))
		{
			return false;
		}
	}

	return true;
}









======================================================================================


=== Source/MassEQS/Private/Tests/MassEnvQueryTest_MassEntityTags.cpp ===
========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "Tests/MassEnvQueryTest_MassEntityTags.h"

#include "Items/EnvQueryItemType_MassEntityHandle.h"

#include "MassEQSUtils.h"
#include "MassEQSTypes.h"
#include "MassEQSSubsystem.h"

#include "MassCommandBuffer.h"
#include "MassEntityManager.h"
#include "MassEntitySubsystem.h"

UMassEnvQueryTest_MassEntityTags::UMassEnvQueryTest_MassEntityTags(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	Cost = EEnvTestCost::Low;
	TestPurpose = EEnvTestPurpose::Type::Filter;
	FilterType = EEnvTestFilterType::Type::Match;

	ValidItemType = UEnvQueryItemType_MassEntityHandle::StaticClass();

	SetWorkOnFloatValues(false);

}

TUniquePtr<FMassEQSRequestData> UMassEnvQueryTest_MassEntityTags::GetRequestData(FEnvQueryInstance& QueryInstance) const
{
	return MakeUnique<FMassEQSRequestData_MassEntityTags>(TagTestMode, Tags);
}

bool UMassEnvQueryTest_MassEntityTags::TryAcquireResults(FEnvQueryInstance& QueryInstance) const
{
	check(MassEQSRequestHandler.MassEQSSubsystem)
	TUniquePtr<FMassEQSRequestData> RawRequestData = MassEQSRequestHandler.MassEQSSubsystem->TryAcquireResults(MassEQSRequestHandler.RequestHandle);
	FMassEnvQueryResultData_MassEntityTags* RequestData = FMassEQSUtils::TryAndEnsureCast<FMassEnvQueryResultData_MassEntityTags>(RawRequestData);
	if (!RequestData)
	{
		return false;
	}

	FEnvQueryInstance::ItemIterator It(this, QueryInstance);
	for (It.IgnoreTimeLimit(); It; ++It)
	{
		const FMassEnvQueryEntityInfo& EntityInfo = FMassEQSUtils::GetItemAsEntityInfo(QueryInstance, It.GetIndex());

		const bool bSuccess = RequestData->ResultMap.Contains(EntityInfo.EntityHandle) && RequestData->ResultMap[EntityInfo.EntityHandle];

		It.SetScore(TestPurpose, FilterType, bSuccess, true);
	}

	return true;
}

FText UMassEnvQueryTest_MassEntityTags::GetDescriptionTitle() const
{
	return FText::FromString(FString::Printf(TEXT("Mass Entity Tags Test : Match %s Tags"),
		TagTestMode == EMassEntityTagsTestMode::Any ? TEXT("Any") :
		TagTestMode == EMassEntityTagsTestMode::All ? TEXT("All") : TEXT("None")));
}

FText UMassEnvQueryTest_MassEntityTags::GetDescriptionDetails() const
{
	return DescribeFloatTestParams();
}
========================================================================


=== Source/MassEQS/Private/Tests/MassEnvQueryTest.cpp ===
=========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "Tests/MassEnvQueryTest.h"
#include "MassEQSSubsystem.h"

UMassEnvQueryTest::UMassEnvQueryTest(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
}

void UMassEnvQueryTest::RunTest(FEnvQueryInstance& QueryInstance) const
{
	MassEQSRequestHandler.SendOrRecieveRequest(QueryInstance, *this);
}
=========================================================


=== Source/MassEQS/Private/MassEQS.cpp ===
==========================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEQS.h"

DEFINE_LOG_CATEGORY(LogMassEQS);

IMPLEMENT_GAME_MODULE(FMassEQSModule, MassEQS);

==========================================


=== Source/MassEQS/Private/MassEQSBlueprintLibrary.cpp ===
==========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEQSBlueprintLibrary.h"

#include "MassCommonFragments.h"
#include "MassSignalSubsystem.h"
#include "MassEntitySubsystem.h"

#include "Items/EnvQueryItemType_MassEntityHandle.h"
#include "EnvironmentQuery/EnvQueryInstanceBlueprintWrapper.h"

UMassEQSBlueprintLibrary::UMassEQSBlueprintLibrary(const FObjectInitializer& ObjectInitializer)
	: UBlueprintFunctionLibrary(ObjectInitializer)
{
}

//----------------------------------------------------------------------//
// Commands
//----------------------------------------------------------------------//

void UMassEQSBlueprintLibrary::SendSignalToEntity(const AActor* Owner, const FMassEnvQueryEntityInfoBlueprintWrapper& EntityInfo, const FName Signal)
{
	if (!ensureMsgf(Owner, TEXT("Must supply owner to function. Reference to self should suffice.")))
	{
		return;
	}

	const UWorld* World = Owner->GetWorld();
	check(World);

	UMassEntitySubsystem* EntitySubsystem = World->GetSubsystem<UMassEntitySubsystem>();
	check(EntitySubsystem);

	UMassSignalSubsystem* SignalSubsystem = World->GetSubsystem<UMassSignalSubsystem>();
	check(SignalSubsystem);

	FMassEntityManager& EntityManager = EntitySubsystem->GetMutableEntityManager();

	FMassEntityHandle EntityHandle = EntityInfo.GetEntityHandle();
	if (!EntityManager.IsEntityValid(EntityHandle))
	{
		return;
	}

	SignalSubsystem->SignalEntity(Signal, EntityHandle);
}

//----------------------------------------------------------------------//
// Utils
//----------------------------------------------------------------------//

FVector UMassEQSBlueprintLibrary::GetCurrentEntityPosition(const AActor* Owner, const FMassEnvQueryEntityInfoBlueprintWrapper& EntityInfo)
{
	if (!ensureMsgf(Owner, TEXT("Must supply owner to function. Reference to self should suffice.")))
	{
		return FVector::ZeroVector;
	}

	const UWorld* World = Owner->GetWorld();
	check(World);

	UMassEntitySubsystem* EntitySubsystem = World->GetSubsystem<UMassEntitySubsystem>();
	check(EntitySubsystem);

	FMassEntityManager& EntityManager = EntitySubsystem->GetMutableEntityManager();

	const FTransformFragment* TransformFragment = EntityManager.GetFragmentDataPtr<FTransformFragment>(EntityInfo.GetEntityHandle());
	if (TransformFragment)
	{
		return TransformFragment->GetTransform().GetLocation();
	}

	return FVector::ZeroVector;
}

bool UMassEQSBlueprintLibrary::ContainsEntity(const TArray<FMassEnvQueryEntityInfoBlueprintWrapper>& EntityList, const FMassEnvQueryEntityInfoBlueprintWrapper& EntityInfo)
{
	for (const FMassEnvQueryEntityInfoBlueprintWrapper& Entity : EntityList)
	{
		if (Entity == EntityInfo)
		{
			return true;
		}
	}

	return false;
}

TArray<FMassEnvQueryEntityInfoBlueprintWrapper> UMassEQSBlueprintLibrary::GetEnviromentQueryResultAsEntityInfo(const UEnvQueryInstanceBlueprintWrapper* QueryInstance)
{
	check(QueryInstance);

	TArray<FMassEnvQueryEntityInfoBlueprintWrapper> ResultInfo = {};

	if (const FEnvQueryResult* QueryResult = QueryInstance->GetQueryResult())
	{
		const TSubclassOf<UEnvQueryItemType> ItemType = QueryResult->ItemType;
		const EEnvQueryRunMode::Type RunMode = QueryInstance->GetRunMode();

		if ((QueryResult->GetRawStatus() == EEnvQueryStatus::Success) 
			&& ItemType && ItemType->IsChildOf(UEnvQueryItemType_MassEntityHandle::StaticClass()))
		{
			if (RunMode != EEnvQueryRunMode::AllMatching)
			{
				ResultInfo.Add(GetItemAsEntityInfoBPWrapper(QueryResult, 0));
			}
			else
			{
				GetAllAsEntityInfoBPWrappers(QueryResult, ResultInfo);
			}
		}
	}

	return ResultInfo;
}

FMassEnvQueryEntityInfoBlueprintWrapper UMassEQSBlueprintLibrary::GetItemAsEntityInfoBPWrapper(const FEnvQueryResult* QueryResult, int32 Index)
{
	UEnvQueryItemType_MassEntityHandle* DefTypeOb = QueryResult->ItemType->GetDefaultObject<UEnvQueryItemType_MassEntityHandle>();

	check(DefTypeOb != nullptr);
	FMassEnvQueryEntityInfo EntityInfo = DefTypeOb->GetValue(QueryResult->RawData.GetData() + QueryResult->Items[Index].DataOffset);

	return FMassEnvQueryEntityInfoBlueprintWrapper(EntityInfo);
}

void UMassEQSBlueprintLibrary::GetAllAsEntityInfoBPWrappers(const FEnvQueryResult* QueryResult, TArray<FMassEnvQueryEntityInfoBlueprintWrapper>& OutInfo)
{
	UEnvQueryItemType_MassEntityHandle* DefTypeOb = QueryResult->ItemType->GetDefaultObject<UEnvQueryItemType_MassEntityHandle>();
	check(DefTypeOb != nullptr);

	OutInfo.Reserve(OutInfo.Num() + QueryResult->Items.Num());

	for (const FEnvQueryItem& Item : QueryResult->Items)
	{
		FMassEnvQueryEntityInfo EntityInfo = DefTypeOb->GetValue(QueryResult->RawData.GetData() + Item.DataOffset);
		OutInfo.Add(FMassEnvQueryEntityInfoBlueprintWrapper(EntityInfo));
	}
}
==========================================================


=== Source/MassEQS/Private/MassEQSSubsystem.cpp ===
===================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEQSSubsystem.h"

#include "MassCommandBuffer.h"
#include "MassEntitySubsystem.h"
#include "MassEQS.h"

#include "Items/EnvQueryItemType_MassEntityHandle.h"
#include "Generators/MassEnvQueryGenerator.h"
#include "Tests/MassEnvQueryTest.h"
#include "MassEQSUtils.h"

//----------------------------------------------------------------------//
// RequestQueue
//----------------------------------------------------------------------//

FMassEQSRequestHandle UMassEQSSubsystem::PushRequest(const FEnvQueryInstance& QueryInstance, const int32 RequestQueueIndex, TUniquePtr<FMassEQSRequestData>&& Request)
{
	// It's a "read" since the detector only cares about the RequestQueues array, not its elements
	UE_MT_SCOPED_READ_ACCESS(RequestAccessDetector);
	check(RequestQueueIndex >= 0);

	FMassEQSRequestHandle RequestHandle = HandleManager.GetNextHandle();
	Request.Get()->RequestHandle = RequestHandle;

	// Fill up the Requests EntityHandle List with all Entities previously generated. 
	// Won't do anything for Generators.
	FMassEQSUtils::GetAllAsEntityHandles(QueryInstance, Request->EntityHandles);

	RequestQueues[RequestQueueIndex].Enqueue(MoveTemp(Request));

	return RequestHandle;
}


TUniquePtr<FMassEQSRequestData> UMassEQSSubsystem::PopRequest(const int32 RequestQueueIndex)
{
	// It's a "read" since the detector only cares about the RequestQueues array, not its elements
	UE_MT_SCOPED_READ_ACCESS(RequestAccessDetector);
	check(RequestQueueIndex >= 0);

	TUniquePtr<FMassEQSRequestData> OutRequest = nullptr;
	RequestQueues[RequestQueueIndex].Dequeue(OutRequest);

	return OutRequest;
}

//----------------------------------------------------------------------//
// Results
//----------------------------------------------------------------------//

void UMassEQSSubsystem::SubmitResults(FMassEQSRequestHandle RequestHandle, TUniquePtr<FMassEQSRequestData>&& Result)
{
	UE_MT_SCOPED_WRITE_ACCESS(ResultAccessDetector);

	check(RequestHandle.IsValid());

	int32 CancelledRequestIndex = CancelledRequests.Find(RequestHandle);
	if (CancelledRequestIndex >= 0)
	{
		CancelledRequests.RemoveAt(CancelledRequestIndex);
		FinalizeRequest(RequestHandle);
		return;
	}
	
	Result->RequestHandle = RequestHandle;
	Results.Add(RequestHandle, MoveTemp(Result));
}

TUniquePtr<FMassEQSRequestData> UMassEQSSubsystem::TryAcquireResults(FMassEQSRequestHandle RequestHandle)
{
	UE_MT_SCOPED_WRITE_ACCESS(ResultAccessDetector);

	// Should never try to Acquire invalid RequestHandle
	check(RequestHandle.IsValid());

	TUniquePtr<FMassEQSRequestData> Result = nullptr;
	if (Results.RemoveAndCopyValue(RequestHandle, Result))
	{
		FinalizeRequest(RequestHandle);
	}
	
	return Result;
}

//----------------------------------------------------------------------//
// Misc
//----------------------------------------------------------------------//

void UMassEQSSubsystem::FinalizeRequest(FMassEQSRequestHandle RequestHandle)
{
	HandleManager.RemoveHandle(RequestHandle);
}

void UMassEQSSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);
	bIsInitialized = true;
}

void UMassEQSSubsystem::Deinitialize()
{
	UE_MT_SCOPED_WRITE_ACCESS(RequestAccessDetector);
	UE_MT_SCOPED_WRITE_ACCESS(ResultAccessDetector);

	Super::Deinitialize();

	Results.Empty();
	RequestQueues.Empty();
	RequestQueueLookup.Reset();

	bIsInitialized = false;
}

int32 UMassEQSSubsystem::GetRequestQueueIndex(TSubclassOf<UEnvQueryNode> RequestClass)
{
	if (int32* IndexPtr = RequestQueueLookup.Find(RequestClass))
	{
		return *IndexPtr;
	}

	UE_MT_SCOPED_WRITE_ACCESS(RequestAccessDetector);
	RequestQueues.Emplace();
	int32 NewIndex = RequestQueues.Num() - 1;
	
	return RequestQueueLookup.Add(RequestClass, NewIndex);
}

void UMassEQSSubsystem::CancelRequest(FMassEQSRequestHandle RequestHandle)
{
	// Not necessary after De-initialization
	if (!bIsInitialized)
	{
		return;
	}

	UE_MT_SCOPED_WRITE_ACCESS(ResultAccessDetector);

	int32 NumRemoved = Results.Remove(RequestHandle);

	// Log this query if its results are not yet present, we need to ignore results once they are submitted.
	if (NumRemoved == 0u)
	{
		CancelledRequests.Add(RequestHandle);
	}
}

===================================================


=== Source/MassEQS/Private/MassEQSTypes.cpp ===
===============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEQSTypes.h"
#include "EnvironmentQuery/EnvQueryTypes.h"
#include "MassEQSSubsystem.h"
#include "MassEQS.h"


//-----------------------------------------------------------------------------
// FMassEnvQueryEntityInfo
//-----------------------------------------------------------------------------
FMassEnvQueryEntityInfo::FMassEnvQueryEntityInfo(int32 Index, int32 SerialNumber, const FTransform& Transform)
	: EntityHandle(Index, SerialNumber)
	, CachedTransform(Transform)
{
}

//-----------------------------------------------------------------------------
// FMassEQSRequestHandle
//-----------------------------------------------------------------------------
FMassEQSRequestHandle FMassEQSRequestHandle::Invalid = FMassEQSRequestHandle(INDEX_NONE, 0);

FString FMassEQSRequestHandle::ToString() const
{
	return FString::Printf(TEXT("[%d,%u]"), Index, SerialNumber);
}

//-----------------------------------------------------------------------------
// IMassEQSRequestInterface::FMassEQSRequestHandler
//-----------------------------------------------------------------------------
void IMassEQSRequestInterface::FMassEQSRequestHandler::SendOrRecieveRequest(FEnvQueryInstance& QueryInstance, const IMassEQSRequestInterface& MassEQSRequestInterface)
{
#if WITH_EDITOR
	if (QueryInstance.World->IsEditorWorld() && !QueryInstance.World->IsPlayInEditor())
	{
		UE_LOG(LogEQS, Warning, TEXT("Asynchronous request type [%s] is only available when simulating the game."), *MassEQSRequestInterface.GetRequestClass()->GetName());
		return;
	}
#endif
	if (!MassEQSSubsystem)
	{
		check(QueryInstance.World)

		MassEQSSubsystem = QueryInstance.World->GetSubsystem<UMassEQSSubsystem>();
		CachedRequestQueueIndex = MassEQSSubsystem->GetRequestQueueIndex(MassEQSRequestInterface.GetRequestClass());
		check(MassEQSSubsystem);
	}
	
	if (RequestHandle > 0u)
	{
		float CurrentTime = QueryInstance.World->GetTimeSeconds();
		if (CurrentTime - RequestStartTime > MaxRequestTime)
		{
			CancelRequest();
			Reset();
		}
		else if (MassEQSRequestInterface.TryAcquireResults(QueryInstance))
		{
			Reset();
		}
	}
	else
	{
		RequestHandle = MassEQSSubsystem->PushRequest(QueryInstance, CachedRequestQueueIndex, MassEQSRequestInterface.GetRequestData(QueryInstance));
		RequestStartTime = QueryInstance.World->GetTimeSeconds();
	}
}

void IMassEQSRequestInterface::FMassEQSRequestHandler::CancelRequest() const
{
	if (!IsPendingResults())
	{
		// No active request
		return;
	}

	check(MassEQSSubsystem)
	MassEQSSubsystem->CancelRequest(RequestHandle);
}

void IMassEQSRequestInterface::FMassEQSRequestHandler::Reset()
{
	RequestHandle = FMassEQSRequestHandle::Invalid;
	RequestStartTime = -1.f;
}

IMassEQSRequestInterface::FMassEQSRequestHandler::~FMassEQSRequestHandler()
{
	CancelRequest();
}

===============================================


=== Source/MassEQS/Private/MassEQSUtils.cpp ===
===============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEQSUtils.h"

#include "MassEQSTypes.h"
#include "EnvironmentQuery/EnvQueryTypes.h"
#include "Items/EnvQueryItemType_MassEntityHandle.h"

#include "MassEntityTypes.h"

FMassEnvQueryEntityInfo FMassEQSUtils::GetItemAsEntityInfo(const FEnvQueryInstance& QueryInstance, int32 Index)
{
	UEnvQueryItemType_MassEntityHandle* DefTypeOb = QueryInstance.ItemType->GetDefaultObject<UEnvQueryItemType_MassEntityHandle>();
	check(DefTypeOb != nullptr);

	return DefTypeOb->GetValue(QueryInstance.RawData.GetData() + QueryInstance.Items[Index].DataOffset);
}

FMassEnvQueryEntityInfo FMassEQSUtils::GetItemAsEntityInfo(const FEnvQueryResult& QueryResult, int32 Index)
{
	UEnvQueryItemType_MassEntityHandle* DefTypeOb = QueryResult.ItemType->GetDefaultObject<UEnvQueryItemType_MassEntityHandle>();
	check(DefTypeOb != nullptr);

	return DefTypeOb->GetValue(QueryResult.RawData.GetData() + QueryResult.Items[Index].DataOffset);
}

void FMassEQSUtils::GetAllAsEntityInfo(const FEnvQueryInstance& QueryInstance, TArray<FMassEnvQueryEntityInfo>& OutEntityInfo)
{
	UEnvQueryItemType_MassEntityHandle* DefTypeOb = QueryInstance.ItemType->GetDefaultObject<UEnvQueryItemType_MassEntityHandle>();
	check(DefTypeOb != nullptr);

	OutEntityInfo.Reserve(OutEntityInfo.Num() + QueryInstance.Items.Num());
	for (const FEnvQueryItem& Item : QueryInstance.Items)
	{
		OutEntityInfo.Add(DefTypeOb->GetValue(QueryInstance.RawData.GetData() + Item.DataOffset));
	}
}

void FMassEQSUtils::GetAllAsEntityInfo(const FEnvQueryResult& QueryResult, TArray<FMassEnvQueryEntityInfo>& OutEntityInfo)
{
	UEnvQueryItemType_MassEntityHandle* DefTypeOb = QueryResult.ItemType->GetDefaultObject<UEnvQueryItemType_MassEntityHandle>();
	check(DefTypeOb != nullptr);

	OutEntityInfo.Reserve(OutEntityInfo.Num() + QueryResult.Items.Num());
	for (const FEnvQueryItem& Item : QueryResult.Items)
	{
		OutEntityInfo.Add(DefTypeOb->GetValue(QueryResult.RawData.GetData() + Item.DataOffset));
	}
}

void FMassEQSUtils::GetEntityHandles(const TArray<FMassEnvQueryEntityInfo>& EntityInfo, TArray<FMassEntityHandle>& OutHandles)
{
	OutHandles.Reserve(OutHandles.Num() + EntityInfo.Num());
	for (const FMassEnvQueryEntityInfo& Info : EntityInfo)
	{
		OutHandles.Add(Info.EntityHandle);
	}
}

void FMassEQSUtils::GetAllAsEntityHandles(const FEnvQueryInstance& QueryInstance, TArray<FMassEntityHandle>& OutHandles)
{
	UEnvQueryItemType_MassEntityHandle* DefTypeOb = QueryInstance.ItemType->GetDefaultObject<UEnvQueryItemType_MassEntityHandle>();
	check(DefTypeOb != nullptr);

	OutHandles.Reserve(OutHandles.Num() + QueryInstance.Items.Num());
	for (const FEnvQueryItem& Item : QueryInstance.Items)
	{
		OutHandles.Add(DefTypeOb->GetValue(QueryInstance.RawData.GetData() + Item.DataOffset).EntityHandle);
	}
}
===============================================


=== Source/MassEQS/Public/Generators/MassEnvQueryGenerator_MassEntityHandles.h ===
==================================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "DataProviders/AIDataProvider.h"
#include "Generators/MassEnvQueryGenerator.h"
#include "MassEQSTypes.h"

#include "MassEnvQueryGenerator_MassEntityHandles.generated.h"

struct FMassEnvQueryEntityInfo;

/**
 * Generator to be sent to MassEQSSubsystem for processing on Mass.
 * This will Generate UEnvQueryItemType_MassEntityHandles within SearchRadius of any ContextPositions.
 * Set SearchRadius to a value <= 0 in order to get all EntityHandles who have an FTransformFragment.
 */
UCLASS(meta = (DisplayName = "Mass Entity Handles"), MinimalAPI)
class UMassEnvQueryGenerator_MassEntityHandles : public UMassEnvQueryGenerator
{
	GENERATED_UCLASS_BODY()

public:
	// Begin IMassEQSRequestInterface
	virtual TUniquePtr<FMassEQSRequestData> GetRequestData(FEnvQueryInstance& QueryInstance) const override;
	virtual UClass* GetRequestClass() const override { return StaticClass(); }
	
	virtual bool TryAcquireResults(FEnvQueryInstance& QueryInstance) const override;
	// ~IMassEQSRequestInterface

protected:
	/** Any Entity who is within SearchRadius of any SearchCenter will be acquired */
	UPROPERTY(EditDefaultsOnly, Category=Generator)
	FAIDataProviderFloatValue SearchRadius;

	/** Context of query */
	UPROPERTY(EditAnywhere, Category=Generator)
	TSubclassOf<UEnvQueryContext> SearchCenter = nullptr;
};

/** Data required to be sent to Mass for processing this Generator Request */
struct FMassEQSRequestData_MassEntityHandles : public FMassEQSRequestData
{
	FMassEQSRequestData_MassEntityHandles(const TArray<FVector>& InContextPositions, const float InSearchRadius)
		: ContextPositions(InContextPositions)
		, SearchRadius(InSearchRadius)
	{
	}

	TArray<FVector> ContextPositions;
	float SearchRadius;
};

struct FMassEnvQueryResultData_MassEntityHandles: public FMassEQSRequestData
{
	FMassEnvQueryResultData_MassEntityHandles(TArray<FMassEnvQueryEntityInfo>&& InGeneratedEntityInfo)
		: GeneratedEntityInfo(MoveTemp(InGeneratedEntityInfo))
	{
	}

	TArray<FMassEnvQueryEntityInfo> GeneratedEntityInfo;
};
==================================================================================


=== Source/MassEQS/Public/Generators/MassEnvQueryGenerator.h ===
================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "EnvironmentQuery/EnvQueryGenerator.h"
#include "MassEQSTypes.h"

#include "MassEnvQueryGenerator.generated.h"

/** Generator that will send its work to MassEQSSubsystem in order to be processed in a Mass Processor */
UCLASS(EditInlineNew, Abstract, meta = (Category = "Generators"), MinimalAPI)
class UMassEnvQueryGenerator : public UEnvQueryGenerator, public IMassEQSRequestInterface
{
	GENERATED_UCLASS_BODY()
public:
	/** 
	 * This will send this Generator Request to MassEQSSubsystem the first time it is called,
	 * and Try to complete Generation with the Result from MassEQSSubsystem on subsequent calls.
	*/
	virtual void GenerateItems(FEnvQueryInstance& QueryInstance) const final;

	virtual FORCEINLINE bool IsCurrentlyRunningAsync() const final { return MassEQSRequestHandler.IsPendingResults(); }

	// To be implemented by child class:
	// Begin IMassEQSRequestInterface
	virtual TUniquePtr<FMassEQSRequestData> GetRequestData(FEnvQueryInstance& QueryInstance) const override PURE_VIRTUAL(UMassEnvQueryGenerator::GetRequestData, return nullptr;);
	virtual UClass* GetRequestClass() const override PURE_VIRTUAL(UMassEnvQueryGenerator::GetRequestData, return nullptr;);
	virtual bool TryAcquireResults(FEnvQueryInstance& QueryInstance) const override PURE_VIRTUAL(UMassEnvQueryGenerator::TryAcquireResults, return false;);
	// ~IMassEQSRequestInterface

protected:
	mutable FMassEQSRequestHandler MassEQSRequestHandler;
};
================================================================


=== Source/MassEQS/Public/Items/EnvQueryItemType_MassEntityHandle.h ===
=======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEQSTypes.h"
#include "EnvironmentQuery/Items/EnvQueryItemType_VectorBase.h"
#include "EnvQueryItemType_MassEntityHandle.generated.h"

/** 
 * EnvQueryType representing a MassEntity. Additionally stores a Cached Transform of the Entity at the
 * time of acquisition, in order to use in the implemented UEnvQueryItemType_VectorBase functions.
 */
UCLASS(meta = (DisplayName = "Mass Entity Handles Item Type"), MinimalAPI)
class UEnvQueryItemType_MassEntityHandle : public UEnvQueryItemType_VectorBase
{
	GENERATED_BODY()

public:
	typedef FMassEnvQueryEntityInfo FValueType;

	UEnvQueryItemType_MassEntityHandle();

	static const FMassEnvQueryEntityInfo& GetValue(const uint8* RawData);
	static void SetValue(uint8* RawData, const FMassEnvQueryEntityInfo& Value);

	virtual FVector GetItemLocation(const uint8* RawData) const override;
	virtual FRotator GetItemRotation(const uint8* RawData) const override;
};

=======================================================================


=== Source/MassEQS/Public/Processors/MassEnvQueryGeneratorProcessor_MassEntityHandles.h ===
===========================================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Processors/MassEnvQueryProcessorBase.h"
#include "MassEnvQueryGeneratorProcessor_MassEntityHandles.generated.h"

/** Processor for completing MassEQSSubsystem Requests sent from UMassEnvQueryGenerator_MassEntityHandles */
UCLASS(meta = (DisplayName = "Mass Entity Handles Generator Processor"))
class UMassEnvQueryGeneratorProcessor_MassEntityHandles : public UMassEnvQueryProcessorBase
{
	GENERATED_BODY()
public:
	UMassEnvQueryGeneratorProcessor_MassEntityHandles();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};
===========================================================================================


=== Source/MassEQS/Public/Processors/MassEnvQueryProcessorBase.h ===
====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassProcessor.h"
#include "MassEnvQueryProcessorBase.generated.h"

class UEnvQueryNode;

/** Processor for completing MassEQSSubsystem Requests sent from UMassEnvQueryTest_MassEntityTags */
UCLASS(Abstract, meta = (DisplayName = "Mass EQS Processor Base"))
class UMassEnvQueryProcessorBase : public UMassProcessor
{
	GENERATED_BODY()

protected:
	virtual void Initialize(UObject& Owner);
	
	TSubclassOf<UEnvQueryNode> CorrespondingRequestClass = nullptr;
	int32 CachedRequestQueryIndex = -1;
};
====================================================================


=== Source/MassEQS/Public/Processors/MassEnvQueryTestProcessor_MassEntityTags.h ===
===================================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Processors/MassEnvQueryProcessorBase.h"
#include "MassEnvQueryTestProcessor_MassEntityTags.generated.h"

/** Processor for completing MassEQSSubsystem Requests sent from UMassEnvQueryTest_MassEntityTags */
UCLASS(meta = (DisplayName = "Mass Entity Tags Test Processor"))
class UMassEnvQueryTestProcessor_MassEntityTags : public UMassEnvQueryProcessorBase
{
	GENERATED_BODY()
public:
	UMassEnvQueryTestProcessor_MassEntityTags();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;
	virtual bool ShouldAllowQueryBasedPruning(const bool bRuntimeMode = true) const override { return false; }

	FMassEntityQuery EntityQuery;
};
===================================================================================


=== Source/MassEQS/Public/Tests/MassEnvQueryTest_MassEntityTags.h ===
=====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Tests/MassEnvQueryTest.h"
#include "MassEnvQueryTest_MassEntityTags.generated.h"

struct FInstancedStruct;
struct FMassEntityHandle;

/** Different modes that this Test can be run in */
UENUM(BlueprintType)
enum class EMassEntityTagsTestMode : uint8
{
	Any = 0	UMETA(DisplayName = "Any Tags", Tooltip = "Filter will require just one of the tags to be present on the Entity."),
	All		UMETA(DisplayName = "All Tags", Tooltip = "Filter will require All of the tags to be present on the Entity."),
	None	UMETA(DisplayName = "None of the Tags", Tooltip = "Filter will require that none of the tags are present on the Entity.")
};

/**
 * Test to be sent to MassEQSSubsystem for processing on Mass.
 * This will test the Entities in the QueryInstance based on the MassTags they have in comparison to the input Tags, and the TagTestMode selected.
 */
UCLASS(MinimalAPI)
class UMassEnvQueryTest_MassEntityTags : public UMassEnvQueryTest
{
	GENERATED_UCLASS_BODY()
public:
	// Begin IMassEQSRequestInterface
	virtual TUniquePtr<FMassEQSRequestData> GetRequestData(FEnvQueryInstance& QueryInstance) const override;
	virtual UClass* GetRequestClass() const override { return StaticClass(); }

	virtual bool TryAcquireResults(FEnvQueryInstance& QueryInstance) const override;
	// ~IMassEQSRequestInterface

protected:
	virtual FText GetDescriptionTitle() const override;
	virtual FText GetDescriptionDetails() const override;

	UPROPERTY(EditAnywhere, Category = "MassEntityTagsTest")
	EMassEntityTagsTestMode TagTestMode = EMassEntityTagsTestMode::All;

	UPROPERTY(EditAnywhere, Category = "MassEntityTagsTest", meta = (BaseStruct = "/Script/MassEntity.MassTag", ExcludeBaseStruct))
	TArray<FInstancedStruct> Tags;
};

/** Data required to be sent to Mass for processing this Test Request */
struct FMassEQSRequestData_MassEntityTags : public FMassEQSRequestData
{
	FMassEQSRequestData_MassEntityTags(EMassEntityTagsTestMode InTagTestMode, TArray<FInstancedStruct> InTags)
		: TagTestMode(InTagTestMode)
		, Tags(InTags)
	{
	}
	EMassEntityTagsTestMode TagTestMode;
	TArray<FInstancedStruct> Tags;
};

/** Data required to be sent to Mass for processing this Test Request */
struct FMassEnvQueryResultData_MassEntityTags : public FMassEQSRequestData
{
	FMassEnvQueryResultData_MassEntityTags(TMap<FMassEntityHandle, bool>&& InResultMap)
		: ResultMap(MoveTemp(InResultMap))
	{
	}

	TMap<FMassEntityHandle, bool> ResultMap;
};
=====================================================================


=== Source/MassEQS/Public/Tests/MassEnvQueryTest.h ===
======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "EnvironmentQuery/EnvQueryTest.h"
#include "MassEQSTypes.h"

#include "MassEnvQueryTest.generated.h"

/** Test that will send its work to MassEQSSubsystem in order to be processed in a Mass Processor */
UCLASS(EditInlineNew, Abstract, meta = (Category = "Tests"), MinimalAPI)
class UMassEnvQueryTest : public UEnvQueryTest, public IMassEQSRequestInterface
{
	GENERATED_UCLASS_BODY()
public:
	/**
	 * This will send this Test Request to MassEQSSubsystem the first time it is called,
	 * and Try to complete Testing with the Result from MassEQSSubsystem on subsequent calls.
	 */
	virtual void RunTest(FEnvQueryInstance& QueryInstance) const final;
	virtual FORCEINLINE bool IsCurrentlyRunningAsync() const final { return MassEQSRequestHandler.IsPendingResults(); }

	// Begin IMassEQSRequestInterface
	virtual TUniquePtr<FMassEQSRequestData> GetRequestData(FEnvQueryInstance& QueryInstance) const override PURE_VIRTUAL(UMassEnvQueryTest::GetRequestData, return nullptr;)
	virtual UClass* GetRequestClass() const override PURE_VIRTUAL(UMassEnvQueryTest::GetRequestClass, return nullptr;);

	virtual bool TryAcquireResults(FEnvQueryInstance& QueryInstance) const override PURE_VIRTUAL(UMassEnvQueryTest::GetRequestData, return false;)
	// ~IMassEQSRequestInterface

protected:
	mutable FMassEQSRequestHandler MassEQSRequestHandler;
};
======================================================


=== Source/MassEQS/Public/MassEQS.h ===
=======================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Modules/ModuleManager.h"

DECLARE_LOG_CATEGORY_EXTERN(LogMassEQS, Log, All);

class FMassEQSModule : public IModuleInterface
{
};

=======================================


=== Source/MassEQS/Public/MassEQSBlueprintLibrary.h ===
=======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Kismet/BlueprintFunctionLibrary.h"

#include "MassEntityTypes.h"
#include "MassEQSTypes.h"
#include "MassEQSUtils.h"

#include "MassEQSBlueprintLibrary.generated.h"

class UEnvQueryInstanceBlueprintWrapper;
struct FEnvQueryResult;

/** Wrapper for Blueprints to be able to parse MassEntityInfo to use functions defined in UMassEQSBlueprintLibrary */
USTRUCT(Blueprintable, BlueprintType, meta = (DisplayName = "Mass Entity Info"))
struct FMassEnvQueryEntityInfoBlueprintWrapper
{
    GENERATED_BODY()

public:
	FMassEnvQueryEntityInfoBlueprintWrapper() = default;
	FMassEnvQueryEntityInfoBlueprintWrapper(FMassEnvQueryEntityInfo InEntityInfo)
		: EntityInfo(InEntityInfo)
	{
	}

	FORCEINLINE FVector GetCachedEntityPosition() const { return EntityInfo.CachedTransform.GetLocation(); }
	FORCEINLINE FMassEntityHandle GetEntityHandle() const { return EntityInfo.EntityHandle; }
	FORCEINLINE void SetEntityHandle(FMassEntityHandle Handle) { EntityInfo.EntityHandle = Handle; }

	const FMassEnvQueryEntityInfo& GetEntityInfo() const { return EntityInfo; };
	inline bool operator==(const FMassEnvQueryEntityInfoBlueprintWrapper& Other) const { return GetEntityInfo() == Other.GetEntityInfo(); }

private:
	FMassEnvQueryEntityInfo EntityInfo;

};

/** Function library for interfacing with EntityInfo inside blueprints. */
UCLASS()
class UMassEQSBlueprintLibrary : public UBlueprintFunctionLibrary
{
    GENERATED_UCLASS_BODY()

public:
	
	//----------------------------------------------------------------------//
	// Commands
	//----------------------------------------------------------------------//

	/** Sends the input Signal to the Entity defined by EntityInfo.EntityHandle using the UMassSignalSubsystem. */
	UFUNCTION(BlueprintCallable, Category = "MassEnvQuery|Commands")
	static void SendSignalToEntity(const AActor* Owner, const FMassEnvQueryEntityInfoBlueprintWrapper& EntityInfo, const FName Signal);

	//----------------------------------------------------------------------//
	// Utils
	//----------------------------------------------------------------------//

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "MassEnvQuery|Utils")
	static FORCEINLINE FString EntityToString(const FMassEnvQueryEntityInfoBlueprintWrapper& EntityInfo){ return EntityInfo.GetEntityHandle().DebugGetDescription(); }

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "MassEnvQuery|Utils")
	static FORCEINLINE FVector GetCachedEntityPosition(const FMassEnvQueryEntityInfoBlueprintWrapper& EntityInfo) { return EntityInfo.GetCachedEntityPosition(); }

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "MassEnvQuery|Utils")
	static FVector GetCurrentEntityPosition(const AActor* Owner, const FMassEnvQueryEntityInfoBlueprintWrapper& EntityInfo);

	/** Custom comparison function, as the Blueprint Equals did not seem to work. */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "MassEnvQuery|Utils")
	static FORCEINLINE bool EntityComparison(const FMassEnvQueryEntityInfoBlueprintWrapper& A, const FMassEnvQueryEntityInfoBlueprintWrapper& B) { return A == B; }

	/** Custom array-contains function, as the Blueprint version did not seem to work. */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "MassEnvQuery|Utils")
	static bool ContainsEntity(const TArray<FMassEnvQueryEntityInfoBlueprintWrapper>& EntityList, const FMassEnvQueryEntityInfoBlueprintWrapper& EntityInfo);

	/** Outputs an array filled with resulting EntityInfos. Note that it makes sense only if ItemType is a EnvQueryItemType_MassEntityHandle-derived type. */
	UFUNCTION(BlueprintCallable, Category = "AI|EQS")
	static TArray<FMassEnvQueryEntityInfoBlueprintWrapper> GetEnviromentQueryResultAsEntityInfo(const UEnvQueryInstanceBlueprintWrapper* QueryInstance);

private:
	/** Get result and immediately convert to EntityInfoBlueprintWrapper to skip an extra copy step */
	static FMassEnvQueryEntityInfoBlueprintWrapper GetItemAsEntityInfoBPWrapper(const FEnvQueryResult* QueryResult, int32 Index);

	/** Get result array and convert each EntityInfo to EntityInfoBlueprintWrapper along the way to skip extra copy steps */
	static void GetAllAsEntityInfoBPWrappers(const FEnvQueryResult* QueryResult, TArray<FMassEnvQueryEntityInfoBlueprintWrapper>& OutEntityInfo);
};
=======================================================


=== Source/MassEQS/Public/MassEQSSubsystem.h ===
================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Containers/Queue.h"

#include "EnvironmentQuery/EnvQueryNode.h"
#include "MassEQSTypes.h"

#include "MassSubsystemBase.h"

#include "MassEQSSubsystem.generated.h"

/**
 * Subsystem for sending UMassEQSGenerator and UMassEQSTest requests to Mass Processors, 
 * and for returning the results back to EQS. 
 */
UCLASS()
class UMassEQSSubsystem : public UMassSubsystemBase
{
	GENERATED_BODY()
	/** Queue holding UniquePtrs to the data required for each Request */
	using FRequestQueue = TQueue<TUniquePtr<FMassEQSRequestData>>;

public:
	/** Push new Request into RequestQueue */
	FMassEQSRequestHandle PushRequest(const FEnvQueryInstance& QueryInstance, const int32 RequestQueueIndex, TUniquePtr<FMassEQSRequestData>&& Request);

	/** Dequeue next Request off the RequestQueue, removing it from the queue, and transferring ownership of UniquePtr */
	TUniquePtr<FMassEQSRequestData> PopRequest(const int32 RequestQueueIndex);

	/** Send results from a finished/processed request to be stored in this subsystem */
	void SubmitResults(FMassEQSRequestHandle RequestHandle, TUniquePtr<FMassEQSRequestData>&& Result);
	/** Try to Acquire the results from a request from the QueryInstance, if it is available. */
	TUniquePtr<FMassEQSRequestData> TryAcquireResults(FMassEQSRequestHandle RequestHandle);

	/** Returns the index into RequestQueues for the input class */
	int32 GetRequestQueueIndex(TSubclassOf<UEnvQueryNode> RequestClass);

	/**
	 * If Request in RequestQueue -> Remove from Queue
	 * If Result in Results -> Remove from Results
	 * Otherwise, Request is currently being processed -> Log this ID as Cancelled, and ignore result when submitted.
	 */
	void CancelRequest(FMassEQSRequestHandle RequestHandle);

	/** Finalization step for Handle Management */
	 void FinalizeRequest(FMassEQSRequestHandle RequestHandle);

	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;

protected:
	/**
	 * Mapping from Class of requester, to index into RequestQueues.
	 * Each Class that extends UMassEQSGenerator or UMassEQSTest 
	 * can be a requester, this will store a Queue for each of these types.
	 * @see PostInitialize()
	 */
	TMap<TSubclassOf<UEnvQueryNode>, int32> RequestQueueLookup = {};
	/**
	 * Array of Queues holding each Request. 
	 * TQueue does not support copy/assignment, which TMap requires.
	 * This is the reason the TQueues are stored in a separate Array.
	 */
	TArray<FRequestQueue> RequestQueues = {};
	/** 
	 * The detector only guards the extension of RequestQueues array. Modifying specific elements is not guarded since 
	 * those are a thread safe queues.
	 */
	UE_MT_DECLARE_RW_ACCESS_DETECTOR(RequestAccessDetector);

	/** Holds results for finished Query */
	TMap<FMassEQSRequestHandle, TUniquePtr<FMassEQSRequestData>> Results;
	UE_MT_DECLARE_RW_ACCESS_DETECTOR(ResultAccessDetector);

	FIndexedHandleManagerBase<FMassEQSRequestHandle, int32, uint32, true> HandleManager;

	/** 
	 * Holds all RequestHandles of requests who have been canceled, and not yet submitted.
	 * Once this request is submitted, we will ignore the results.
	 */
	TArray<FMassEQSRequestHandle> CancelledRequests;

	/** Used to ignore request cancellation after subsystem is De-Initialized */
	bool bIsInitialized = false;
};

template<>
struct TMassExternalSubsystemTraits<UMassEQSSubsystem> final
{
	enum
	{
		GameThreadOnly = false,
		ThreadSafeRead = true,
		ThreadSafeWrite = true,
	};
};
================================================


=== Source/MassEQS/Public/MassEQSTypes.h ===
============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "IndexedHandle.h"
#include "MassEntityTypes.h"

#include "MassEQSTypes.generated.h"

struct FEnvQueryInstance;
struct FMassEQSRequestHandle;
class UMassEQSSubsystem;

/** Contents of EnvQueryItemType_MassEntityHandle
 *  @see EnvQueryItemType_MassEntityHandle
 */
USTRUCT()
struct FMassEnvQueryEntityInfo
{
	GENERATED_BODY()

	FMassEnvQueryEntityInfo() = default;
	FMassEnvQueryEntityInfo(int32 Index, int32 SerialNumber, const FTransform& Transform);

	FMassEntityHandle EntityHandle;
	/** Cached Transform from time of acquisition allows EnvQueryItemType_MassEntityHandle to implement UEnvQueryItemType_VectorBase */
	FTransform CachedTransform;

	inline bool operator==(const FMassEnvQueryEntityInfo& Other) const { return EntityHandle == Other.EntityHandle; }
};

/**
 * Provides a Unique Handle for incoming MassEQS Requests
 */
USTRUCT()
struct FMassEQSRequestHandle : public FIndexedHandleBase
{
	GENERATED_BODY()
	FMassEQSRequestHandle() = default;
	FMassEQSRequestHandle(int32 InIndex, uint32 InSerialNumber) : FIndexedHandleBase(InIndex, InSerialNumber)
	{
	}

	FString ToString() const;

	static FMassEQSRequestHandle Invalid;
};

/** To be extended to hold any data which needs to be transferred between EQS and Mass for a given Request. */
struct FMassEQSRequestData
{
	FMassEQSRequestData() = default;
	FMassEQSRequestData(FMassEQSRequestHandle Handle)
		: RequestHandle(Handle)
	{
	}

	/** Unique ID that MassEQSSubsystem's HandleManager has assigned to this Request */
	FMassEQSRequestHandle RequestHandle = FMassEQSRequestHandle::Invalid;

	/** EntityHandles to run this request on. Used for Tests. */
	TArray<FMassEntityHandle> EntityHandles;
};

/** Interface for sending and receiving EQS Requests to and from MassEQSSubsystem */
UINTERFACE()
class UMassEQSRequestInterface : public UInterface
{
	GENERATED_BODY()
};

/** Interface for sending and receiving EQS Requests to and from MassEQSSubsystem utilizing a MassEQSRequestHandler */
class IMassEQSRequestInterface
{
	GENERATED_BODY()
public:

	/**
	 * Stores relevant information for managing requests sent to MassEQSSubsystem.
	 * Provides generic functionality for Sending, Receiving, and Canceling these requests.
	 * Any class who implements IMassEQSRequestInterface should have one of these.
	 */
	struct FMassEQSRequestHandler
	{
		/**
		 * Called when an EnvQueryInstance is trying to run a Generator or Test who implements this.
		 * If this Request has not yet been sent (IE. RequestID == 0u) then we will send this request
		 * Otherwise, if this Request was already sent (IE. RequestID > 0u) then we will call TryAcquireResults on the input MassEnvRequestInterface.
		 * @param QueryInstance - The EnvQueryInstance sending/receiving this request
		 * @param MassEQSRequestInterface - The Interface used to call this,
		 * @return A unique ID that the QueryInstance can hold on to in order to later retrieve this request result.
		 */
		void SendOrRecieveRequest(FEnvQueryInstance& QueryInstance, const IMassEQSRequestInterface& MassEQSRequestInterface);

		/** Cancel request if currently ongoing. */
		void CancelRequest() const;

		/** Reset RequestID to 0 and RequestStartTime to -1.f */
		void Reset();

		FORCEINLINE bool IsPendingResults() const { return RequestHandle.IsValid(); }

		// Handle for request in MassEQSSubsystem.
		FMassEQSRequestHandle RequestHandle = FMassEQSRequestHandle::Invalid;
		// Cached MassEQSSubsystem pointer for interacting with this subsystem
		TObjectPtr<UMassEQSSubsystem> MassEQSSubsystem = nullptr;
		// The point in time that an ongoing request was sent, -1 if none have been sent.
		float RequestStartTime = -1.f;
		// The max amount of time allowed for this request. CancelRequest will be called if this is used after this time has elapsed.
		float MaxRequestTime = DefaultMaxRequestTime;

		int32 CachedRequestQueueIndex = -1;

		FMassEQSRequestHandler() = default;
		~FMassEQSRequestHandler();

	protected:
		static constexpr float DefaultMaxRequestTime = 5.f;
	};


	/**
	 * Called inside RequestProcessing, in order to create a copy of the relevant data for this Request.
	 * @param QueryInstance - The EnvQueryInstance that owns this Generator
	 * @return A UniquePtr to the Data-Copy created.
	 */
	virtual TUniquePtr<FMassEQSRequestData> GetRequestData(FEnvQueryInstance& QueryInstance) const = 0;

	/**
	 * Get StaticClass of the ImplementingClass. Implementer of this Interface must provide this so we can use
	 * the correct StaticClass inside RequestProcessing.
	 * Implementation should just be StaticClass() called in derived class.
	 */
	virtual UClass* GetRequestClass() const = 0;

	/**
	 * Called when EnvQueryInstance is checking to try to complete its request.
	 * @param QueryInstance - The EnvQueryInstance that owns this Generator
	 */
	virtual bool TryAcquireResults(FEnvQueryInstance& QueryInstance) const = 0;
};
============================================


=== Source/MassEQS/Public/MassEQSUtils.h ===
============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "HAL/Platform.h"
#include "MassEQSTypes.h"

struct FEnvQueryResult;
struct FEnvQueryInstance;
struct FMassEnvQueryEntityInfo;
struct FMassEntityHandle;
struct FMassEntityHandle;
struct FMassEQSRequestData;

/** Holds Utility functions for Mass EQS Needs */
struct FMassEQSUtils
{

	/** Returns the Item stored in QueryInstance/QueryResult Items[Index] as EntityInfo */
	static FMassEnvQueryEntityInfo GetItemAsEntityInfo(const FEnvQueryInstance& QueryInstance, int32 Index);
	static FMassEnvQueryEntityInfo GetItemAsEntityInfo(const FEnvQueryResult& QueryResult, int32 Index);

	/** Returns all Items stored in QueryInstance/QueryResult as EntityInfo */
	static void GetAllAsEntityInfo(const FEnvQueryInstance& QueryInstance, TArray<FMassEnvQueryEntityInfo>& OutEntityInfo);
	static void GetAllAsEntityInfo(const FEnvQueryResult& QueryResult, TArray<FMassEnvQueryEntityInfo>& OutEntityInfo);

	/** Extracts all EntityHandles out of an array of EntityInfo */
	static void GetEntityHandles(const TArray<FMassEnvQueryEntityInfo>& EntityInfo, TArray<FMassEntityHandle>& OutHandles);
	static void GetAllAsEntityHandles(const FEnvQueryInstance& QueryInstance, TArray<FMassEntityHandle>& OutHandles);

	/**
	 * Used in MassEnvQueryProcessors, to cast generic FMassEQSRequestData to its corresponding child class.
	 * If InPtr is not null, then this Cast should never fail.
	 */
	template<typename RequestDataType>
	static FORCEINLINE RequestDataType* TryAndEnsureCast(TUniquePtr<FMassEQSRequestData>& InPtr)
	{
		if (!InPtr)
		{
			return nullptr;
		}

		RequestDataType* OutPtr = static_cast<RequestDataType*>(InPtr.Get());
		ensureMsgf(OutPtr, TEXT("RequestData was pushed to MassEQSSubsystem, but corresponding child RequestData was not found."));

		return OutPtr;
	}
};

============================================


=== Source/MassEQS/MassEQS.Build.cs ===
=======================================

// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

namespace UnrealBuildTool.Rules
{
	public class MassEQS : ModuleRules
	{
		public MassEQS(ReadOnlyTargetRules Target) : base(Target)
		{
			PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

			PublicIncludePaths.AddRange(
				new string[] {
				}
			);

			PublicDependencyModuleNames.AddRange(
				new string[] {
					"Core",
					"CoreUObject",
					"Engine",
					"AIModule",
					"MassCommon",
					"MassEntity",
					"MassSignals",
				}
			);
		}
	}
}
=======================================


=== Source/MassGameplayDebug/Private/AssignDebugVisProcessor.cpp ===
====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "AssignDebugVisProcessor.h"
#include "MassGameplayDebugTypes.h"
#include "MassDebugVisualizationComponent.h"
#include "MassDebuggerSubsystem.h"
#include "MassExecutionContext.h"

//----------------------------------------------------------------------//
// UAssignDebugVisProcessor
//----------------------------------------------------------------------//
UAssignDebugVisProcessor::UAssignDebugVisProcessor()
	: EntityQuery(*this)
{
	bAutoRegisterWithProcessingPhases = false;
	bRequiresGameThreadExecution = true; // due to UMassDebuggerSubsystem
	ObservedType = FSimDebugVisFragment::StaticStruct();
	Operation = EMassObservedOperation::Add;
}

void UAssignDebugVisProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FSimDebugVisFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddSubsystemRequirement<UMassDebuggerSubsystem>(EMassFragmentAccess::ReadWrite);

	ProcessorRequirements.AddSubsystemRequirement<UMassDebuggerSubsystem>(EMassFragmentAccess::ReadWrite);
}

void UAssignDebugVisProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
#if WITH_EDITORONLY_DATA
	QUICK_SCOPE_CYCLE_COUNTER(AssignDebugVisProcessor_Execute);
	
	// @todo this code bit is temporary, so is the Visualizer->DirtyVisuals at the end of the function. Will be wrapped in
	// "executable task" once that's implemented. 
	UMassDebugVisualizationComponent* Visualizer = nullptr;
	UMassDebuggerSubsystem& Debugger = Context.GetMutableSubsystemChecked<UMassDebuggerSubsystem>();
	check(Debugger.GetVisualizationComponent());
	Visualizer = Debugger.GetVisualizationComponent();
	// note that this function will create the "visual components" only it they're missing or out of sync. 
	Debugger.GetVisualizationComponent()->ConditionallyConstructVisualComponent();

	EntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
	{
		UMassDebuggerSubsystem& Debugger = Context.GetMutableSubsystemChecked<UMassDebuggerSubsystem>();
		UMassDebugVisualizationComponent* Visualizer = Debugger.GetVisualizationComponent();
		check(Visualizer);

		const TArrayView<FSimDebugVisFragment> DebugVisList = Context.GetMutableFragmentView<FSimDebugVisFragment>();
		for (FSimDebugVisFragment& VisualComp : DebugVisList)
		{
			// VisualComp.VisualType needs to be assigned by now. Should be performed as part of spawning, copied from the AgentTemplate
			if (ensure(VisualComp.VisualType != INDEX_NONE))
			{
				VisualComp.InstanceIndex = Visualizer->AddDebugVisInstance(VisualComp.VisualType);
			}
		}
	});

	if (ensure(Visualizer))
	{
		Visualizer->DirtyVisuals();
	}
#endif // WITH_EDITORONLY_DATA
}

====================================================================


=== Source/MassGameplayDebug/Private/DebugVisLocationProcessor.cpp ===
======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "DebugVisLocationProcessor.h"
#include "MassDebuggerSubsystem.h"
#include "MassDebugVisualizationComponent.h"
#include "MassCommonFragments.h"
#include "Components/HierarchicalInstancedStaticMeshComponent.h"
#include "MassEntityManager.h"
#include "MassExecutionContext.h"
#include "MassMovementFragments.h"

//----------------------------------------------------------------------//
// UDebugVisLocationProcessor
//----------------------------------------------------------------------//
UDebugVisLocationProcessor::UDebugVisLocationProcessor()
	: EntityQuery(*this)
{
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::SyncWorldToMass);
	bRequiresGameThreadExecution = true; // due to UMassDebuggerSubsystem access
}

void UDebugVisLocationProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FSimDebugVisFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddTagRequirement<FMassDebuggableTag>(EMassFragmentPresence::All);
	EntityQuery.AddSubsystemRequirement<UMassDebuggerSubsystem>(EMassFragmentAccess::ReadWrite);
}

void UDebugVisLocationProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
#if WITH_EDITORONLY_DATA
	QUICK_SCOPE_CYCLE_COUNTER(DebugVisLocationProcessor_Run);

	EntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
	{
		UMassDebuggerSubsystem& Debugger = Context.GetMutableSubsystemChecked<UMassDebuggerSubsystem>();
		UMassDebugVisualizationComponent* Visualizer = Debugger.GetVisualizationComponent();
		check(Visualizer);
		TArrayView<UHierarchicalInstancedStaticMeshComponent* const> VisualDataISMCs = Visualizer->GetVisualDataISMCs();
		if (VisualDataISMCs.Num() > 0)
		{
			const int32 NumEntities = Context.GetNumEntities();
			const TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
			const TConstArrayView<FSimDebugVisFragment> DebugVisList = Context.GetFragmentView<FSimDebugVisFragment>();

			for (int32 i = 0; i < NumEntities; ++i)
			{
				const FSimDebugVisFragment& VisualComp = DebugVisList[i];

				// @todo: remove this code once the asset is exported with correct alignment SM_Mannequin.uasset
				FTransform SMTransform = LocationList[i].GetTransform();
				FQuat FromEngineToSM(FVector::UpVector, -HALF_PI);
				SMTransform.SetRotation(FromEngineToSM * SMTransform.GetRotation());

				VisualDataISMCs[VisualComp.VisualType]->UpdateInstanceTransform(VisualComp.InstanceIndex, SMTransform, true);
			}
		}
		else
		{
			UE_LOG(LogMassDebug, Log, TEXT("UDebugVisLocationProcessor: Trying to update InstanceStaticMeshes while none created. Check your debug visualization setup"));
		}
	});

	UMassDebuggerSubsystem* Debugger = UWorld::GetSubsystem<UMassDebuggerSubsystem>(EntityManager.GetWorld());
	if (ensure(Debugger))
	{
		Debugger->GetVisualizationComponent()->DirtyVisuals();
	}
#endif // WITH_EDITORONLY_DATA
}

//----------------------------------------------------------------------//
//  UMassProcessor_UpdateDebugVis
//----------------------------------------------------------------------//
UMassProcessor_UpdateDebugVis::UMassProcessor_UpdateDebugVis()
	: EntityQuery(*this)
{
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::UpdateWorldFromMass);
	bRequiresGameThreadExecution = true; // due to UMassDebuggerSubsystem access
}

void UMassProcessor_UpdateDebugVis::ConfigureQueries() 
{
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FDataFragment_DebugVis>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FAgentRadiusFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddTagRequirement<FMassDebuggableTag>(EMassFragmentPresence::All);

	ProcessorRequirements.AddSubsystemRequirement<UMassDebuggerSubsystem>(EMassFragmentAccess::ReadWrite);
}

void UMassProcessor_UpdateDebugVis::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	QUICK_SCOPE_CYCLE_COUNTER(UMassProcessor_UpdateDebugVis_Run);

	UMassDebuggerSubsystem& Debugger = Context.GetMutableSubsystemChecked<UMassDebuggerSubsystem>();
	Debugger.ResetDebugShapes();

	EntityQuery.ForEachEntityChunk(EntityManager, Context, [&Debugger](FMassExecutionContext& Context)
		{
			const int32 NumEntities = Context.GetNumEntities();
			const TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
			const TArrayView<FDataFragment_DebugVis> DebugVisList = Context.GetMutableFragmentView<FDataFragment_DebugVis>();
			const TArrayView<FAgentRadiusFragment> RadiiList = Context.GetMutableFragmentView<FAgentRadiusFragment>();

			for (int32 i = 0; i < NumEntities; ++i)
			{
				Debugger.AddShape(DebugVisList[i].Shape, LocationList[i].GetTransform().GetLocation(), RadiiList[i].Radius);
			}
		});
}

======================================================================


=== Source/MassGameplayDebug/Private/MassDebuggerSubsystem.cpp ===
==================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassDebuggerSubsystem.h"
#include "EngineUtils.h"
#include "MassCommonTypes.h"
#include "MassSimulationSubsystem.h"
#include "MassDebugVisualizationComponent.h"
#include "MassEntityManager.h"
#include "MassDebugVisualizer.h"
#include "MassDebugger.h"
#include "MassEntityManager.h"


void UMassDebuggerSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Collection.InitializeDependency(UMassSimulationSubsystem::StaticClass());
	Super::Initialize(Collection);

	UMassSimulationSubsystem* SimSystem = UWorld::GetSubsystem<UMassSimulationSubsystem>(GetWorld());
	check(SimSystem);
	SimSystem->GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).AddUObject(this, &UMassDebuggerSubsystem::OnProcessingPhaseStarted);

#if WITH_MASSENTITY_DEBUG
	OnEntitySelectedHandle = FMassDebugger::OnEntitySelectedDelegate.AddUObject(this, &UMassDebuggerSubsystem::OnEntitySelected);
#endif // WITH_MASSENTITY_DEBUG
}

void UMassDebuggerSubsystem::Deinitialize()
{
#if WITH_MASSENTITY_DEBUG
	FMassDebugger::OnEntitySelectedDelegate.Remove(OnEntitySelectedHandle);
#endif // WITH_MASSENTITY_DEBUG
	Super::Deinitialize();
}

#if WITH_MASSENTITY_DEBUG
void UMassDebuggerSubsystem::OnEntitySelected(const FMassEntityManager& EntityManager, const FMassEntityHandle EntityHandle)
{
	if (EntityManager.GetWorld() == GetWorld())
	{
		SetSelectedEntity(EntityHandle);
	}
}
#endif // WITH_MASSENTITY_DEBUG

void UMassDebuggerSubsystem::ResetDebugShapes()
{
	// get ready to receive new debug info
	for (TArray<FShapeDesc>& Array : Shapes)
	{
		Array.Reset();
	}
}

void UMassDebuggerSubsystem::PreTickProcessors()
{
	Entities.Reset();
	Locations.Reset();
	SelectedEntityDetails.Empty();
}

void UMassDebuggerSubsystem::OnProcessingPhaseStarted(const float DeltaSeconds)
{
	PreTickProcessors();
}

void UMassDebuggerSubsystem::SetSelectedEntity(const FMassEntityHandle InSelectedEntity)
{
	SelectedEntity = InSelectedEntity;
	SelectedEntityDetails.Empty();
}

void UMassDebuggerSubsystem::AppendSelectedEntityInfo(const FString& Info)
{
	SelectedEntityDetails += Info;
}

UMassDebugVisualizationComponent* UMassDebuggerSubsystem::GetVisualizationComponent()
{ 
#if WITH_EDITORONLY_DATA
	if (VisualizationComponent == nullptr)
	{
		if (!ensureMsgf(DebugVisualizer == nullptr, TEXT("If we do have a DebugVisualizer but don't have VisualizationComponent then somethin's wrong")))
		{
			VisualizationComponent = &DebugVisualizer->GetDebugVisComponent();
		}
		else
		{
			if (UWorld* World = GetWorld())
			{
				const AMassDebugVisualizer& VisualizerActor = GetOrSpawnDebugVisualizer(*World);
				VisualizationComponent = &VisualizerActor.GetDebugVisComponent();
			}
		}
	}
	ensureMsgf(VisualizationComponent,  TEXT("In editor builds we always expect to have a visualizer component available"));
#endif // WITH_EDITORONLY_DATA
	return VisualizationComponent;
}

#if WITH_EDITORONLY_DATA
AMassDebugVisualizer& UMassDebuggerSubsystem::GetOrSpawnDebugVisualizer(UWorld& InWorld)
{
	if (DebugVisualizer)
	{
		return *DebugVisualizer;
	}

	// see if there is one already and we've missed it somehow
	for (const TActorIterator<AMassDebugVisualizer> It(&InWorld); It;)
	{
		DebugVisualizer = *It;
		return *DebugVisualizer;
	}

	FActorSpawnParameters SpawnInfo;
	SpawnInfo.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
	// The helper actor is created on demand and only once per world so we can allow it to spawn during construction script.
	SpawnInfo.bAllowDuringConstructionScript = true;
	DebugVisualizer = InWorld.SpawnActor<AMassDebugVisualizer>(SpawnInfo);
	check(DebugVisualizer);
	VisualizationComponent = &DebugVisualizer->GetDebugVisComponent();

	return *DebugVisualizer;
}
#endif
==================================================================


=== Source/MassGameplayDebug/Private/MassDebugVisualizationComponent.cpp ===
============================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassDebugVisualizationComponent.h"
#include "Components/HierarchicalInstancedStaticMeshComponent.h"


#if WITH_EDITORONLY_DATA
#include "MassDebugVisualizer.h"

void UMassDebugVisualizationComponent::PostInitProperties()
{
	Super::PostInitProperties();
	if (HasAnyFlags(RF_ClassDefaultObject) == false && GetOuter())
	{
		ensureMsgf(GetOuter()->GetClass()->IsChildOf(AMassDebugVisualizer::StaticClass()), TEXT("UMassDebugVisualizationComponent should only be added to AMassDebugVisualizer-like instances"));
	}
}

void UMassDebugVisualizationComponent::DirtyVisuals()
{
	for (UHierarchicalInstancedStaticMeshComponent* ISM : VisualDataISMCs)
	{
		if (ensure(ISM))
		{
			ISM->MarkRenderStateDirty();
		}
	}
}

int32 UMassDebugVisualizationComponent::AddDebugVisInstance(const uint16 VisualType)
{
	return VisualDataISMCs[VisualType]->AddInstance(FTransform::Identity);
}

void UMassDebugVisualizationComponent::ConditionallyConstructVisualComponent()
{
	if (VisualDataISMCs.Num() == 0 || VisualDataISMCs.Num() != VisualDataTable.Num())
	{
		ConstructVisualComponent();
	}
}

void UMassDebugVisualizationComponent::ConstructVisualComponent()
{
	AActor* ActorOwner = GetOwner();
	check(ActorOwner);
	
	// add HISMCs only for types not added yet
	for (int NewTypeIndex = VisualDataISMCs.Num(); NewTypeIndex < VisualDataTable.Num(); ++NewTypeIndex)
	{
		const FAgentDebugVisualization& VisualData = VisualDataTable[NewTypeIndex];
		UHierarchicalInstancedStaticMeshComponent* HISMC = NewObject<UHierarchicalInstancedStaticMeshComponent>(ActorOwner);
		HISMC->SetStaticMesh(VisualData.Mesh);
		if (VisualData.MaterialOverride != nullptr)
		{
			HISMC->SetMaterial(0, VisualData.MaterialOverride);
		}

		HISMC->SetCullDistances(VisualData.VisualNearCullDistance, VisualData.VisualFarCullDistance);
		HISMC->SetupAttachment(ActorOwner->GetRootComponent());
		HISMC->SetCanEverAffectNavigation(false);
		HISMC->bDisableCollision = true;
		HISMC->SetCastShadow(false);
		HISMC->RegisterComponent();

		VisualDataISMCs.Add(HISMC);
	}
}

uint16 UMassDebugVisualizationComponent::AddDebugVisType(const FAgentDebugVisualization& Data)
{
	const int32 Index = VisualDataTable.Add(Data);
	check(VisualDataTable.Num() <= (int32)MAX_uint16);
	return (uint16)Index;
}

void UMassDebugVisualizationComponent::Clear()
{
	for (UHierarchicalInstancedStaticMeshComponent* ISM : VisualDataISMCs)
	{
		if (ensure(ISM))
		{
			ISM->ClearInstances();
			ISM->UnregisterComponent();
		}
	}
	VisualDataISMCs.Reset();
}
#endif // WITH_EDITORONLY_DATA

============================================================================


=== Source/MassGameplayDebug/Private/MassDebugVisualizationTrait.cpp ===
========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassDebugVisualizationTrait.h"
#include "MassDebuggerSubsystem.h"
#include "MassDebugVisualizationComponent.h"
#include "MassEntityTemplateRegistry.h"
#include "MassCommonFragments.h"
#include "Engine/World.h"

void UMassDebugVisualizationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
#if WITH_EDITORONLY_DATA
	const UStaticMesh* const DebugMesh = DebugShape.Mesh;
#else
	const UStaticMesh* const DebugMesh = nullptr;
#endif
	
	if (DebugMesh || BuildContext.IsInspectingData())
	{
#if WITH_EDITORONLY_DATA
		FSimDebugVisFragment& DebugVisFragment = BuildContext.AddFragment_GetRef<FSimDebugVisFragment>();
		if (!BuildContext.IsInspectingData())
		{
			UMassDebuggerSubsystem* Debugger = World.GetSubsystem<UMassDebuggerSubsystem>();
			if (ensure(Debugger))
			{
				UMassDebugVisualizationComponent* DebugVisComponent = Debugger->GetVisualizationComponent();
				if (ensure(DebugVisComponent))
				{
					DebugVisFragment.VisualType = DebugVisComponent->AddDebugVisType(DebugShape);
				}
				// @todo this path requires a fragment destructor that will remove the mesh from the debugger.
			}
		}
#endif // WITH_EDITORONLY_DATA
	}
	// add fragments needed whenever we have debugging capabilities
#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
	BuildContext.AddTag<FMassDebuggableTag>();
#if WITH_EDITORONLY_DATA
	BuildContext.AddFragment_GetRef<FDataFragment_DebugVis>().Shape = DebugShape.WireShape;
#else
	// DebugShape unavailable, will used default instead
	BuildContext.AddFragment<FDataFragment_DebugVis>();
#endif // WITH_EDITORONLY_DATA
	BuildContext.AddFragment<FAgentRadiusFragment>();

	BuildContext.AddFragment<FTransformFragment>();
#endif // if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)

}
========================================================================


=== Source/MassGameplayDebug/Private/MassDebugVisualizer.cpp ===
================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassDebugVisualizer.h"

#if WITH_EDITORONLY_DATA
#include "MassDebugVisualizationComponent.h"
#endif // WITH_EDITORONLY_DATA

AMassDebugVisualizer::AMassDebugVisualizer()
{
#if WITH_EDITORONLY_DATA
	RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("SceneComp"));
	DebugVisComponent = CreateDefaultSubobject<UMassDebugVisualizationComponent>(TEXT("VisualizerComponent"));
#endif
}


================================================================


=== Source/MassGameplayDebug/Private/MassGameplayDebugModule.cpp ===
====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"
#include "IMassGameplayDebugModule.h"
#include "MassCommonTypes.h"
#include "MassGameplayDebugTypes.h"

DEFINE_LOG_CATEGORY(LogMassDebug);

class FMassGameplayDebug : public IMassGameplayDebugModule
{
	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

IMPLEMENT_MODULE(FMassGameplayDebug, MassGameplayDebug)

void FMassGameplayDebug::StartupModule()
{
}

void FMassGameplayDebug::ShutdownModule()
{
}




====================================================================


=== Source/MassGameplayDebug/Private/MassGameplayDebugTypes.cpp ===
===================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassGameplayDebugTypes.h"
#include "MassCommonTypes.h"
#include "MassCommonFragments.h"
#include "MassEntityManager.h"
#if WITH_MASSGAMEPLAY_DEBUG
#include "MassDebugger.h"


namespace UE::Mass::Debug
{

void GetDebugEntitiesAndLocations(const FMassEntityManager& EntityManager, TArray<FMassEntityHandle>& OutEntities, TArray<FVector>& OutLocations)
{
	int32 DebugEntityEnd, DebugEntityBegin;
	if (GetDebugEntitiesRange(DebugEntityEnd, DebugEntityBegin) == false)
	{
		return;
	}

	OutEntities.Reserve(DebugEntityEnd - DebugEntityBegin);
	OutLocations.Reserve(DebugEntityEnd - DebugEntityBegin);

	for (int32 i = DebugEntityBegin; i <= DebugEntityEnd; ++i)
	{
		const FMassEntityHandle EntityHandle = ConvertEntityIndexToHandle(EntityManager, i);
		if (EntityHandle.IsSet())
		{
			if (const FTransformFragment* TransformFragment = EntityManager.GetFragmentDataPtr<FTransformFragment>(EntityHandle))
			{
				OutEntities.Add(EntityHandle);
				OutLocations.Add(TransformFragment->GetTransform().GetLocation());
			}
		}
	}
}

FMassEntityHandle ConvertEntityIndexToHandle(const FMassEntityManager& EntityManager, const int32 EntityIndex)
{
	return EntityManager.DebugGetEntityIndexHandle(EntityIndex);
}

} // namespace UE::Mass::Debug
#endif // WITH_MASSGAMEPLAY_DEBUG
===================================================================


=== Source/MassGameplayDebug/Public/AssignDebugVisProcessor.h ===
=================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassObserverProcessor.h"
#include "AssignDebugVisProcessor.generated.h"


class UMassDebugVisualizationComponent;
struct FSimDebugVisFragment;

UCLASS()
class MASSGAMEPLAYDEBUG_API UAssignDebugVisProcessor : public UMassObserverProcessor
{
	GENERATED_BODY()
public:
	UAssignDebugVisProcessor();
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

protected:
	FMassEntityQuery EntityQuery;
};

=================================================================


=== Source/MassGameplayDebug/Public/DebugVisLocationProcessor.h ===
===================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassProcessor.h"
#include "DebugVisLocationProcessor.generated.h"

class UMassDebugVisualizationComponent;
struct FSimDebugVisFragment;

UCLASS()
class MASSGAMEPLAYDEBUG_API UDebugVisLocationProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UDebugVisLocationProcessor();
	
protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};

//----------------------------------------------------------------------//
// new one 
//----------------------------------------------------------------------//
//class UMassDebugger;

UCLASS()
class MASSGAMEPLAYDEBUG_API UMassProcessor_UpdateDebugVis : public UMassProcessor
{
	GENERATED_BODY()
public:
	UMassProcessor_UpdateDebugVis();
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

protected:
	FMassEntityQuery EntityQuery;
};


===================================================================


=== Source/MassGameplayDebug/Public/IMassGameplayDebugModule.h ===
==================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleInterface.h"
#include "Modules/ModuleManager.h"


/**
 * The public interface to this module.  In most cases, this interface is only public to sibling modules 
 * within this plugin.
 */
class IMassGameplayDebugModule : public IModuleInterface
{

public:

	/**
	 * Singleton-like access to this module's interface.  This is just for convenience!
	 * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.
	 *
	 * @return Returns singleton instance, loading the module on demand if needed
	 */
	static inline IMassGameplayDebugModule& Get()
	{
		return FModuleManager::LoadModuleChecked<IMassGameplayDebugModule>( "MassGameplayDebug" );
	}

	/**
	 * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.
	 *
	 * @return True if the module is loaded and ready to use
	 */
	static inline bool IsAvailable()
	{
		return FModuleManager::Get().IsModuleLoaded( "MassGameplayDebug" );
	}
};


==================================================================


=== Source/MassGameplayDebug/Public/MassDebuggerSubsystem.h ===
===============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassGameplayDebugTypes.h"
#include "MassSubsystemBase.h"
#include "MassDebuggerSubsystem.generated.h"


class UMassDebugVisualizationComponent;
class AMassDebugVisualizer;

UCLASS()
class MASSGAMEPLAYDEBUG_API UMassDebuggerSubsystem : public UMassSubsystemBase
{
	GENERATED_BODY()
public:
	struct FShapeDesc
	{
		FVector Location = {}; // no init on purpose, value will come from constructor
		float Size = {};
		FShapeDesc(const FVector InLocation, const float InSize) : Location(InLocation), Size(InSize) {}
	};

	// Methods to optimize the collection of data to only when category is enabled
	bool IsCollectingData() const { return bCollectingData; }
	void SetCollectingData() { bCollectingData = true; }
	void DataCollected() { bCollectingData = false; }

	void AddShape(EMassEntityDebugShape Shape, FVector Location, float Size) { Shapes[uint8(Shape)].Add(FShapeDesc(Location, Size)); }
	const TArray<FShapeDesc>* GetShapes() const { return Shapes; }
	void ResetDebugShapes();

	FMassEntityHandle GetSelectedEntity() const { return SelectedEntity; }
	void SetSelectedEntity(const FMassEntityHandle InSelectedEntity);

	void AppendSelectedEntityInfo(const FString& Info);
	const FString& GetSelectedEntityInfo() const { return SelectedEntityDetails; }
	
	/** Fetches the UMassDebugVisualizationComponent owned by lazily created DebugVisualizer */
	UMassDebugVisualizationComponent* GetVisualizationComponent();

#if WITH_EDITORONLY_DATA
	AMassDebugVisualizer& GetOrSpawnDebugVisualizer(UWorld& InWorld);
#endif

protected:
	// USubsystem BEGIN
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;
	// USubsystem END
	
	void OnProcessingPhaseStarted(const float DeltaSeconds);
	void PreTickProcessors();
	void OnEntitySelected(const FMassEntityManager& EntityManager, const FMassEntityHandle EntityHandle);

protected:
	bool bCollectingData = false;

	TArray<FShapeDesc> Shapes[uint8(EMassEntityDebugShape::MAX)];
	TArray<FMassEntityHandle> Entities;
	TArray<FVector> Locations;
	FMassEntityHandle SelectedEntity;
	FString SelectedEntityDetails;

	UPROPERTY(Transient)
	TObjectPtr<UMassDebugVisualizationComponent> VisualizationComponent;

	UPROPERTY(Transient)
	TObjectPtr<AMassDebugVisualizer> DebugVisualizer;

	FDelegateHandle OnEntitySelectedHandle;
};


template<>
struct TMassExternalSubsystemTraits<UMassDebuggerSubsystem> final
{
	enum
	{
		GameThreadOnly = true
	};
};
===============================================================


=== Source/MassGameplayDebug/Public/MassDebugVisualizationComponent.h ===
=========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassGameplayDebugTypes.h"
#include "Components/ActorComponent.h"
#include "MassDebugVisualizationComponent.generated.h"


class UHierarchicalInstancedStaticMeshComponent;

/** meant to be created procedurally and owned by an AMassDebugVisualizer instance. Will ensure if placed on a different type of actor */
UCLASS()
class MASSGAMEPLAYDEBUG_API UMassDebugVisualizationComponent : public UActorComponent
{
	GENERATED_BODY()
public:
#if WITH_EDITORONLY_DATA
	/**  will create Owner's "visual components" only it they're missing or out of sync with VisualDataTable */
	void ConditionallyConstructVisualComponent();
	void DirtyVisuals();
	int32 AddDebugVisInstance(const uint16 VisualType);
	/** returns index to the newly created VisualDataTable entry */
	uint16 AddDebugVisType(const FAgentDebugVisualization& Data);
	TArrayView<UHierarchicalInstancedStaticMeshComponent* const> GetVisualDataISMCs() { return MakeArrayView(VisualDataISMCs); }

	void Clear();
protected:
	virtual void PostInitProperties() override;
	void ConstructVisualComponent();

protected:

	UPROPERTY(Transient)
	TArray<FAgentDebugVisualization> VisualDataTable;

	UPROPERTY(Transient)
	TArray<TObjectPtr<UHierarchicalInstancedStaticMeshComponent>> VisualDataISMCs;
#endif // WITH_EDITORONLY_DATA
};

=========================================================================


=== Source/MassGameplayDebug/Public/MassDebugVisualizationTrait.h ===
=====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "MassEntityTraitBase.h"
#include "MassGameplayDebugTypes.h"
#include "MassDebugVisualizationTrait.generated.h"


UCLASS(meta = (DisplayName = "Debug Visualization"))
class MASSGAMEPLAYDEBUG_API UMassDebugVisualizationTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:

	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;

#if WITH_EDITORONLY_DATA
	UPROPERTY(EditAnywhere, Category = "Mass|Spawn")
	FAgentDebugVisualization DebugShape;
#endif // WITH_EDITORONLY_DATA
};

=====================================================================


=== Source/MassGameplayDebug/Public/MassDebugVisualizer.h ===
=============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "GameFramework/Actor.h"
#include "MassDebugVisualizer.generated.h"


UCLASS(NotPlaceable, Transient)
class MASSGAMEPLAYDEBUG_API AMassDebugVisualizer : public AActor
{
	GENERATED_BODY()
public:
	AMassDebugVisualizer();

#if WITH_EDITORONLY_DATA
	/** If this function is callable we guarantee the debug vis component to exist*/
	class UMassDebugVisualizationComponent& GetDebugVisComponent() const { return *DebugVisComponent; }

protected:
	UPROPERTY()
	TObjectPtr<class UMassDebugVisualizationComponent> DebugVisComponent;
#endif // WITH_EDITORONLY_DATA
};

=============================================================


=== Source/MassGameplayDebug/Public/MassGameplayDebugTypes.h ===
================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "UObject/ObjectMacros.h"
#include "Logging/LogMacros.h"
#include "Engine/DataTable.h"
#include "MassEntityTypes.h"
#include "MassSpawnerTypes.h"
#include "MassGameplayDebugTypes.generated.h"


DECLARE_LOG_CATEGORY_EXTERN(LogMassDebug, Warning, All);

#if WITH_EDITORONLY_DATA
class UBillboardComponent;
#endif // WITH_EDITORONLY_DATA
class UStaticMesh;
class UMaterialInterface;

#if WITH_MASSGAMEPLAY_DEBUG
namespace UE::Mass::Debug
{
	/**
	 * Fetches entity handles and their locations for entities indicated by index range as set by
	 * mass.debug.SetDebugEntityRange or mass.debug.DebugEntity console commands.
	 */
	MASSGAMEPLAYDEBUG_API extern void GetDebugEntitiesAndLocations(const FMassEntityManager& EntitySubsystem, TArray<FMassEntityHandle>& OutEntities, TArray<FVector>& OutLocations);
	MASSGAMEPLAYDEBUG_API extern FMassEntityHandle ConvertEntityIndexToHandle(const FMassEntityManager& EntitySubsystem, const int32 EntityIndex);
} // namespace UE::Mass::Debug
#endif // WITH_MASSGAMEPLAY_DEBUG

USTRUCT()
struct FSimDebugDataRow : public FTableRowBase
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = Debug)
	TObjectPtr<UStaticMesh> Mesh = nullptr;

	UPROPERTY(EditAnywhere, Category = Debug)
	TObjectPtr<UMaterialInterface> MaterialOverride = nullptr;

	UPROPERTY(EditAnywhere, Category = Debug)
	float Scale = 1.f;
};

USTRUCT()
struct FSimDebugVisFragment : public FMassFragment
{
	GENERATED_BODY()
	int32 InstanceIndex = INDEX_NONE;
	int16 VisualType = INDEX_NONE;
};

UENUM()
enum class EMassEntityDebugShape : uint8
{
	Box,
	Cone,
	Cylinder,
	Capsule,
	MAX
};

USTRUCT()
struct FDataFragment_DebugVis : public FMassFragment
{
	GENERATED_BODY()
	UPROPERTY(EditAnywhere, Category = Debug)
	EMassEntityDebugShape Shape = EMassEntityDebugShape::Box;
};

USTRUCT()
struct FMassDebuggableTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct FAgentDebugVisualization : public FTableRowBase
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = "Mass|Debug")
	TObjectPtr<UStaticMesh> Mesh = nullptr;

	UPROPERTY(EditAnywhere, Category = "Mass|Debug")
	TObjectPtr<UMaterialInterface> MaterialOverride = nullptr;

	/** Near cull distance to override default value for that agent type */
	UPROPERTY(EditAnywhere, Category = "Mass|Debug")
	uint32 VisualNearCullDistance = 5000;

	/** Far cull distance to override default value for that agent type */
	UPROPERTY(EditAnywhere, Category = "Mass|Debug")
	uint32 VisualFarCullDistance = 7500;

	/** If Mesh is not set this WireShape will be used for debug drawing via GameplayDebugger */
	UPROPERTY(EditAnywhere, Category = "Mass|Debug")
	EMassEntityDebugShape WireShape = EMassEntityDebugShape::Box;
};

================================================================


=== Source/MassGameplayDebug/MassGameplayDebug.Build.cs ===
===========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

namespace UnrealBuildTool.Rules
{
	public class MassGameplayDebug : ModuleRules
	{
		public MassGameplayDebug(ReadOnlyTargetRules Target) : base(Target)
		{
			PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

			UnsafeTypeCastWarningLevel = WarningLevel.Warning;

			PublicDependencyModuleNames.AddRange(
				new string[] {
					"Core",
					"CoreUObject",
					"Engine",
					"InputCore",
					"MassEntity",
					"NavigationSystem",
					"StateTreeModule",
					"MassActors",
					"MassCommon",
					"MassMovement",
					"MassSmartObjects",
					"MassSpawner",
					"MassSimulation",
					"MassRepresentation",
					"MassLOD",
				}
			);

			if (Target.bBuildEditor == true)
			{
				PrivateDependencyModuleNames.Add("UnrealEd");
				PublicDependencyModuleNames.Add("MassEntityEditor");
			}

			SetupGameplayDebuggerSupport(Target);
		}
	}
}

===========================================================


=== Source/MassGameplayEditor/Private/MassActorEditorSubsystem.cpp ===
======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassActorEditorSubsystem.h"
#include "MassActorSubsystem.h"
#include "MassEntityManager.h"
#include "MassEntityEditorSubsystem.h"


//----------------------------------------------------------------------//
//  UMassActorEditorSubsystem
//----------------------------------------------------------------------//
void UMassActorEditorSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	UMassEntityEditorSubsystem* MassEditorEditorSubsystem = Collection.InitializeDependency<UMassEntityEditorSubsystem>();
	check(MassEditorEditorSubsystem);
	TSharedRef<FMassEntityManager> MassEntityManager = MassEditorEditorSubsystem->GetMutableEntityManager();
	ActorManager = MakeShareable(new FMassActorManager(MassEntityManager));

	Super::Initialize(Collection);
}

======================================================================


=== Source/MassGameplayEditor/Private/MassGameplayEditorModule.cpp ===
======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassGameplayEditorModule.h"
#include "Modules/ModuleManager.h"
#include "PropertyEditorModule.h"


#define LOCTEXT_NAMESPACE "MassGameplayEditor"

IMPLEMENT_MODULE(FMassGameplayEditorModule, MassGameplayEditor)

void FMassGameplayEditorModule::StartupModule()
{
	// Register the details customizers
	FPropertyEditorModule& PropertyModule = FModuleManager::LoadModuleChecked<FPropertyEditorModule>("PropertyEditor");

	RegisterSectionMappings();
	
	PropertyModule.NotifyCustomizationModuleChanged();
}

void FMassGameplayEditorModule::ShutdownModule()
{
}

void FMassGameplayEditorModule::RegisterSectionMappings()
{
	static const FName PropertyEditor("PropertyEditor");
	FPropertyEditorModule& PropertyModule = FModuleManager::GetModuleChecked<FPropertyEditorModule>(PropertyEditor);

	{
		TSharedRef<FPropertySection> Section = PropertyModule.FindOrCreateSection("MassSpawner", "Mass", LOCTEXT("Mass", "Mass"));
		Section->AddCategory("Mass");
		Section->AddCategory("Debug");
	}

	{
		TSharedRef<FPropertySection> Section = PropertyModule.FindOrCreateSection("MassAgentComponent", "Mass", LOCTEXT("Mass", "Mass"));
		Section->AddCategory("Mass");
	}
}
#undef LOCTEXT_NAMESPACE

======================================================================


=== Source/MassGameplayEditor/Private/MassTraitRepository.cpp ===
=================================================================

// Copyright Epic Games, Inc. All Rights Reserved.
 
#include "MassTraitRepository.h"
#include "MassEntityTraitBase.h"
#include "Engine/Engine.h"
#include "Engine/World.h"
#include "Misc/CoreDelegates.h"
#include "UObject/UObjectIterator.h"
#include "Editor.h"
#include "MassEntityTemplateRegistry.h"
#include "Misc/UObjectToken.h"
#include "Framework/Docking/TabManager.h"
#include "Logging/MessageLog.h"
#include "MassAssortedFragmentsTrait.h"
#include "DataValidationFixers.h"
#include "MassEntityConfigAsset.h"
#include "MassEntityEditor.h"

#define LOCTEXT_NAMESPACE "Mass"


namespace UE::Mass
{
	namespace Editor
	{
		TConstArrayView<FName> GetTraitsNameAddingElements(const FName ElementName)
		{
			if (UMassTraitRepository* TraitRepo = GEditor->GetEditorSubsystem<UMassTraitRepository>())
			{
				return TraitRepo->GetTraitsNameAddingElements(ElementName);
			}
			return TConstArrayView<FName>();
		}
	}

	namespace Private
	{
		/** a helper function that wraps up code for fixing the WeakConfig by adding a trait of class WeakTraitClass */
		FFixResult AddTraitToConfigFix(const TWeakObjectPtr<UMassEntityConfigAsset>& WeakConfig, const TWeakObjectPtr<UClass>& WeakTraitClass)
		{
			if (UMassEntityConfigAsset* ConfigAsset = WeakConfig.Get())
			{
				if (TSubclassOf<UMassEntityTraitBase> TraitClass = WeakTraitClass.Get())
				{
					if (ConfigAsset->AddTrait(TraitClass) != nullptr)
					{
						return FFixResult::Success();
					}
					return FFixResult::Failure(LOCTEXT("FailedToCreateTrait", "Failed to create an instance of the trait."));
				}
				return FFixResult::Failure(LOCTEXT("TraitClassNoLongerAvailable", "Trait class no longer available."));
			}
			return FFixResult::Failure(LOCTEXT("ConfigAssetNoLongerAvailable", "Config asset no longer available."));
		}
	}
};

//-----------------------------------------------------------------------------
// FMassTraitInspectionContext
//-----------------------------------------------------------------------------
FMassTraitInspectionContext::FMassTraitInspectionContext()
	: EntityTemplate()
	, BuildContext(EntityTemplate)
{
	BuildContext.EnableDataInvestigationMode();
}

FMassTraitInspectionContext::FInvestigationContext::FInvestigationContext(FMassEntityTemplateData& InTemplate)
	: Super(InTemplate)
{
}

void FMassTraitInspectionContext::FInvestigationContext::SetTrait(const UMassEntityTraitBase& Trait)
{
	SetTraitBeingProcessed(&Trait);
}

//-----------------------------------------------------------------------------
// UMassTraitRepository
//-----------------------------------------------------------------------------
TWeakObjectPtr<UWorld> UMassTraitRepository::GlobalInvestigationWorld;

void UMassTraitRepository::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

#if WITH_MASSENTITY_DEBUG
	OnNewTraitTypeHandle = UMassEntityTraitBase::GetOnNewTraitTypeEvent().AddUObject(this, &UMassTraitRepository::OnNewTraitType);
	FMassDebugger::OnDebugEvent.AddUObject(this, &UMassTraitRepository::OnDebugEvent);
#endif // WITH_MASSENTITY_DEBUG
}

// @todo we have an opportunity here to make it really flexible. Every message name could be associated with a 
// dedicated TFunction (via some map) that would handle the given message type. This way users could extend or override
// the way certain events are handled. 
#if WITH_MASSENTITY_DEBUG
void UMassTraitRepository::OnDebugEvent(const FName EventName, FConstStructView Payload, EMassDebugMessageSeverity SeverityOverride)
{
	static const FName MissingTraitMessageName = FMassMissingTraitMessage::StaticStruct()->GetFName();
	static const FName DuplicateElementsMessageName = FMassDuplicateElementsMessage::StaticStruct()->GetFName();

#define OVERRIDABLE_SEVERITY(DefaultSeverity) UE::Mass::Debug::MassSeverityToMessageSeverity(DefaultSeverity, SeverityOverride)

	if (EventName == MissingTraitMessageName)
	{
		if (const FMassMissingTraitMessage* MissingTraitMessage = Payload.GetPtr<const FMassMissingTraitMessage>())
		{
			FMessageLog MessageLog(UE::Mass::Editor::MessageLogPageName);

			TArray<TSharedRef<FTokenizedMessage>> Messages;

			const FName MissingElement = GetFNameSafe(MissingTraitMessage->MissingType);
			const FName TraitClassName = MissingTraitMessage->RequestingTrait ? GetFNameSafe(MissingTraitMessage->RequestingTrait->GetClass()) : FName();

			TSharedRef<FTokenizedMessage> IntroMessage = Messages.Add_GetRef(FTokenizedMessage::Create(OVERRIDABLE_SEVERITY(EMessageSeverity::Error)))
				->AddToken(FAssetNameToken::Create(GetPathNameSafe(MissingTraitMessage->RequestingTrait)
					, FText::FormatOrdered(LOCTEXT("MissingElementSuggestionHeader"
						, "Trait {0}")
						, FText::FromName(TraitClassName))
				));

			// if the missing elements has been added but removed by some trait that's all we need to tell the user:
			if (MissingTraitMessage->RemovedByTrait)
			{
				IntroMessage->AddText(FText::FormatOrdered(LOCTEXT("MissingElementSuggestionRemoved"
					, "has unsatisfied dependency of {0}. The type has been explicitly removed by {1}.")
					, FText::FromName(MissingElement)
					, FText::FromName(MissingTraitMessage->RemovedByTrait->GetFName())));
			}
			else
			{
				UMassTraitRepository* TraitRepo = GEditor->GetEditorSubsystem<UMassTraitRepository>();
				TConstArrayView<FName> SuggestedTraitNames = TraitRepo
					? TraitRepo->GetTraitsNameAddingElements(MissingElement)
					: TConstArrayView<FName>();

				if (SuggestedTraitNames.Num())
				{
					// The FixController will coordinate IFixer instances and the relevant FFixToken to
					// ensure that only one of them can be applied. Once any of the fixes is applied
					// the rest will become inactive (the FFixToken tokens will become grayed out and non-clickable).
					// @todo at the moment FMutuallyExclusiveFixSet doesn't care whether fixing was successful. 
					//		Should be relatively easy to address but needs to be coordinated with the author
					TSharedRef<UE::DataValidation::FMutuallyExclusiveFixSet> FixController = MakeShareable(new UE::DataValidation::FMutuallyExclusiveFixSet());

					IntroMessage->AddText(FText::FormatOrdered(LOCTEXT("MissingElementSuggestionOptions"
						, "has unsatisfied dependency of {0}. The following actions can address it:")
						, FText::FromName(MissingElement)));

					for (const FName& SuggestedTraitName : SuggestedTraitNames)
					{
						bool bFixable = false;
						if (MissingTraitMessage->RequestingTrait)
						{
							TWeakObjectPtr<UClass> WeakTraitClass = GetTraitClass(SuggestedTraitName);
							UMassEntityConfigAsset* EntityConfigAsset = Cast<UMassEntityConfigAsset>(MissingTraitMessage->RequestingTrait->GetOuter());

							if (EntityConfigAsset && WeakTraitClass.IsValid())
							{
								bFixable = true;

								TWeakObjectPtr<UMassEntityConfigAsset> WeakConfig = EntityConfigAsset;
							
								// capturing FixController to make sure it exists as long as the fixes are alive. The lambda will
								// be destroyed once the Fixer tokens get destroyed, for example during MessageLog page clearing.
								TFunction<FFixResult()> ApplyFix = [WeakConfig, WeakTraitClass, _ = FixController]()
								{
									return UE::Mass::Private::AddTraitToConfigFix(WeakConfig, WeakTraitClass);
								};

								const TSharedRef<UE::DataValidation::IFixer> Fixer = UE::DataValidation::MakeFix(MoveTemp(ApplyFix));

								FixController->Add(FText::FormatOrdered(LOCTEXT("AddMissingTrait", "Add {0} trait to {1} entity config")
											, FText::FromName(SuggestedTraitName)
											, FText::FromName(EntityConfigAsset->GetFName()))
										, Fixer);
							}
						}
					
						if (bFixable == false)
						{
							// unfixable (since we're unable to determine the UMassEntityConfigAsset outer), so just report
							Messages.Add_GetRef(FTokenizedMessage::Create(OVERRIDABLE_SEVERITY(EMessageSeverity::Info)))
								->AddText(FText::FormatOrdered(LOCTEXT("MissingElementSuggestionUnfixable", "\t{0}")
									, FText::FromName(SuggestedTraitName)));
						}
					}

					// for every IFixer instance we created in the loop above the call bellow will create a FFixToken
					// related to that specific "fix". We attach all the tokens to the initial "here are your options" message
					FixController->CreateTokens([IntroMessage](TSharedRef<FFixToken> FixToken)
						{
							IntroMessage->AddToken(FixToken);
						}
					);
				}
				else
				{
					IntroMessage->AddText(FText::FormatOrdered(LOCTEXT("MissingElementSuggestionNoOptions"
						, "has unsatisfied dependency of {0}. There are no registered Traits that provide the type. Try using {1}.")
						, FText::FromName(MissingElement)
						, FText::FromName(UMassAssortedFragmentsTrait::StaticClass()->GetFName())));
				}
			}

			MessageLog.AddMessages(Messages);
		}
	}
	else if (EventName == UE::Mass::Debug::TraitFailedValidation)
	{
		if (const FMassGenericDebugEvent* GenericEvent = Payload.GetPtr<const FMassGenericDebugEvent>())
		{
			const UMassEntityTraitBase* Trait = Cast<UMassEntityTraitBase>(GenericEvent->Context);
			FMessageLog MessageLog(UE::Mass::Editor::MessageLogPageName);
			MessageLog.AddMessage(FTokenizedMessage::Create(OVERRIDABLE_SEVERITY(EMessageSeverity::Error)))
				->AddToken(FUObjectToken::Create(Trait))
				->AddToken(FTextToken::Create(LOCTEXT("TraitFailedValidation", "trait-specific validation failed")));
		}
	}
	else if (EventName == UE::Mass::Debug::TraitIgnored)
	{
		if (const FMassGenericDebugEvent* GenericEvent = Payload.GetPtr<const FMassGenericDebugEvent>())
		{
			const UMassEntityTraitBase* Trait = Cast<UMassEntityTraitBase>(GenericEvent->Context);
			FMessageLog MessageLog(UE::Mass::Editor::MessageLogPageName);
			MessageLog.AddMessage(FTokenizedMessage::Create(OVERRIDABLE_SEVERITY(EMessageSeverity::Warning)))
				->AddToken(FUObjectToken::Create(Trait))
				->AddToken(FTextToken::Create(LOCTEXT("TraitIgnoredTrait", "trait was ignored. Check if it's not a duplicate.")));
		}
	}
	else if (EventName == DuplicateElementsMessageName)
	{
		if (const FMassDuplicateElementsMessage* DuplicateElementsMessage = Payload.GetPtr<const FMassDuplicateElementsMessage>())
		{
			FMessageLog MessageLog(UE::Mass::Editor::MessageLogPageName);
			MessageLog.AddMessage(FTokenizedMessage::Create(OVERRIDABLE_SEVERITY(EMessageSeverity::Warning)))
				->AddToken(FUObjectToken::Create(DuplicateElementsMessage->DuplicatingTrait))
				->AddToken(FTextToken::Create(FText::FormatOrdered(
					LOCTEXT("TraitFragmentDuplicationWarning", "trying to add fragment of type {0} while it has already been added by")
					, FText::FromName(GetFNameSafe(DuplicateElementsMessage->Element))
					)))
				->AddToken(FUObjectToken::Create(DuplicateElementsMessage->OriginalTrait))
				->AddToken(FTextToken::Create(LOCTEXT("TraitFragmentDuplicationWarningCheckConflicts", "Check your entity config for conflicting traits")));
		}
	}

#undef OVERRIDABLE_SEVERITY
}
#endif // WITH_MASSENTITY_DEBUG

TConstArrayView<FName> UMassTraitRepository::GetTraitsNameAddingElements(const FName ElementName)
{
	if (bIsRepositoryInitialized == false)
	{
		InitRepository();
	}

	if (TArray<FName>* FoundTraits = ElementTypeToTraitMap.Find(ElementName))
	{
		return MakeArrayView(*FoundTraits);
	}

	return TConstArrayView<FName>();
}

void UMassTraitRepository::InitRepository()
{
	if (bIsRepositoryInitialized == true)
	{
		return;
	}

#if WITH_MASSENTITY_DEBUG
	UWorld::InitializationValues IVS;
	IVS.InitializeScenes(false)
		.AllowAudioPlayback(false)
		.RequiresHitProxies(false)
		.CreatePhysicsScene(false)
		.CreateNavigation(false)
		.CreateAISystem(false)
		.ShouldSimulatePhysics(false)
		.EnableTraceCollision(false)
		.SetTransactional(false)
		.CreateFXSystem(false);

	InvestigationWorld = UWorld::CreateWorld(EWorldType::Inactive
		, /*bInformEngineOfWorld=*/false
		, /*WorldName=*/TEXT("MassTraitRepository_InvestigationWorld")
		, /*Package=*/nullptr
		, /*bAddToRoot=*/false
		, /*InFeatureLevel=*/ERHIFeatureLevel::Num
		, &IVS
		, /*bInSkipInitWorld=*/true);
	GlobalInvestigationWorld = InvestigationWorld;
	check(InvestigationWorld);
	InvestigationWorld->InitWorld(IVS);

	// Marking as "initialized" so that the OnNewTraitType calls below do their job as expected. 
	bIsRepositoryInitialized = true;

	// Using RF_NoFlags to include CDOs (filtered out by default), since that's all we care about.
	for (TObjectIterator<UMassEntityTraitBase> ClassIterator(/*AdditionalExclusionFlags=*/RF_NoFlags); ClassIterator; ++ClassIterator)
	{
		if (ClassIterator && ClassIterator->HasAnyFlags(RF_ClassDefaultObject))
		{
			OnNewTraitType(**ClassIterator);
		}
	}
#endif // WITH_MASSENTITY_DEBUG
}

void UMassTraitRepository::Deinitialize()
{
#if WITH_MASSENTITY_DEBUG
	UMassEntityTraitBase::GetOnNewTraitTypeEvent().Remove(OnNewTraitTypeHandle);

	if (IsValid(InvestigationWorld))
	{
		InvestigationWorld->DestroyWorld(/*bInformEngineOfWorld=*/false);
	}
#endif // WITH_MASSENTITY_DEBUG

	Super::Deinitialize();
}

#if WITH_MASSENTITY_DEBUG
void UMassTraitRepository::OnNewTraitType(UMassEntityTraitBase& Trait)
{
	if (bIsRepositoryInitialized == false)
	{
		// since the repository is not initialized yet we assume we don't need to collect the information about Trait just yet.
		// Once InitRepository is called all existing Trait CDOs will be collected and processed.
		return;
	}

	// simply ignore abstract classes, we don't care about these since the user will never be able to use them anyway.
	if (Trait.GetClass()->HasAnyClassFlags(CLASS_Abstract))
	{
		return;
	}

	checkf(Trait.HasAnyFlags(RF_ClassDefaultObject), TEXT("Only CDOs are expected here."));
	check(InvestigationWorld);

	const FName TraitName = Trait.GetClass()->GetFName();
	FTraitAndElements TraitData;

	// first check if we have this one already. If so we need to remove and re-add in the type got updated
	if (TraitClassNameToDataMap.RemoveAndCopyValue(TraitName, TraitData))
	{
		for (const FName TypeName : TraitData.ElementNames)
		{
			ElementTypeToTraitMap.FindChecked(TypeName).RemoveSingleSwap(TraitName, EAllowShrinking::No);
		}
	}

	TraitData.TraitClass = Trait.GetClass();
	TraitData.ElementNames.Reset();

	FMassTraitInspectionContext InvestigationContext;
	InvestigationContext.BuildContext.SetTrait(Trait);
	Trait.BuildTemplate(InvestigationContext.BuildContext, *InvestigationWorld);

	const FMassArchetypeCompositionDescriptor& Composition = InvestigationContext.EntityTemplate.GetCompositionDescriptor();

	for (FMassFragmentBitSet::FIndexIterator It = Composition.Fragments.GetIndexIterator(); It; ++It)
	{
		const FName StructName = Composition.Fragments.DebugGetStructTypeName(*It);
		TraitData.ElementNames.Add(StructName);
	}

	for (FMassTagBitSet::FIndexIterator It = Composition.Tags.GetIndexIterator(); It; ++It)
	{
		const FName StructName = Composition.Tags.DebugGetStructTypeName(*It);
		TraitData.ElementNames.Add(StructName);
	}

	for (FMassChunkFragmentBitSet::FIndexIterator It = Composition.ChunkFragments.GetIndexIterator(); It; ++It)
	{
		const FName StructName = Composition.ChunkFragments.DebugGetStructTypeName(*It);
		TraitData.ElementNames.Add(StructName);
	}

	for (FMassSharedFragmentBitSet::FIndexIterator It = Composition.SharedFragments.GetIndexIterator(); It; ++It)
	{
		const FName StructName = Composition.SharedFragments.DebugGetStructTypeName(*It);
		TraitData.ElementNames.Add(StructName);
	}

	for (FMassConstSharedFragmentBitSet::FIndexIterator It = Composition.ConstSharedFragments.GetIndexIterator(); It; ++It)
	{
		const FName StructName = Composition.ConstSharedFragments.DebugGetStructTypeName(*It);
		TraitData.ElementNames.Add(StructName);
	}

	for (const FName ElementTypeName : TraitData.ElementNames)
	{
		ElementTypeToTraitMap.FindOrAdd(ElementTypeName).Add(TraitName);
	}
	TraitClassNameToDataMap.Add(TraitName, MoveTemp(TraitData));
}
#endif // WITH_MASSENTITY_DEBUG

UWorld* UMassTraitRepository::GetInvestigationWorld()
{
	return GlobalInvestigationWorld.Get();
}

TWeakObjectPtr<UClass> UMassTraitRepository::GetTraitClass(const FName TraitClassName) const
{
	if (const FTraitAndElements* Data = TraitClassNameToDataMap.Find(TraitClassName))
	{
		return Data->TraitClass;
	}
	return TWeakObjectPtr<UClass>();
}

//-----------------------------------------------------------------------------
// UMassDebugEntitySubsystem
//-----------------------------------------------------------------------------
bool UMassDebugEntitySubsystem::ShouldCreateSubsystem(UObject* Outer) const
{
	return Outer != nullptr && Outer == UMassTraitRepository::GetInvestigationWorld();
}

#undef LOCTEXT_NAMESPACE 
=================================================================


=== Source/MassGameplayEditor/Public/IMassGameplayEditor.h ===
==============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Toolkits/AssetEditorToolkit.h"


/** Mass Editor public interface */
class MASSGAMEPLAYEDITOR_API IMassGameplayEditor : public FAssetEditorToolkit
{
public:
};

==============================================================


=== Source/MassGameplayEditor/Public/MassActorEditorSubsystem.h ===
===================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "EditorSubsystem.h"
#include "MassActorEditorSubsystem.generated.h"


struct FMassActorManager;

UCLASS()
class MASSGAMEPLAYEDITOR_API UMassActorEditorSubsystem : public UEditorSubsystem
{
	GENERATED_BODY()

public:
	FMassActorManager& GetMutableActorManager() { return *ActorManager.Get(); }

protected:
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;

	TSharedPtr<FMassActorManager> ActorManager;
};

===================================================================


=== Source/MassGameplayEditor/Public/MassGameplayEditorModule.h ===
===================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma  once

#include "Modules/ModuleInterface.h"

/**
* The public interface to this module
*/
class MASSGAMEPLAYEDITOR_API FMassGameplayEditorModule : public IModuleInterface
{
public:
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;

protected:
	void RegisterSectionMappings();
};

#if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_3
#include "CoreMinimal.h"
#include "Toolkits/AssetEditorToolkit.h"
#endif

===================================================================


=== Source/MassGameplayEditor/Public/MassTraitRepository.h ===
==============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTemplateRegistry.h"
#include "EditorSubsystem.h"
#include "MassEntitySubsystem.h"
#include "StructUtils/StructView.h"
#include "MassDebugger.h"
#include "MassTraitRepository.generated.h"

class UMassEntityTraitBase;
class UWorld;

namespace UE::Mass::Editor
{
	extern MASSGAMEPLAYEDITOR_API TConstArrayView<FName> GetTraitsNameAddingElements(const FName ElementName);
}

struct FMassTraitInspectionContext
{
	struct FInvestigationContext : public FMassEntityTemplateBuildContext
	{
		using Super = FMassEntityTemplateBuildContext;
		explicit FInvestigationContext(FMassEntityTemplateData& InTemplate);
		void SetTrait(const UMassEntityTraitBase& Trait);
	};

	FMassTraitInspectionContext();

	FMassEntityTemplateData EntityTemplate;
	FInvestigationContext BuildContext;
};

/** 
 * Subsystem to store information about Mass traits so that we can make helpful suggestions to users like which
 * traits supply a fragment they need.
 * It also serves to post trait validation information and fix options to the MessageLog.
 */
UCLASS()
class MASSGAMEPLAYEDITOR_API UMassTraitRepository : public UEditorSubsystem
{
	GENERATED_BODY()
	
public:
	static UWorld* GetInvestigationWorld();

	TConstArrayView<FName> GetTraitsNameAddingElements(const FName ElementName);
	TWeakObjectPtr<UClass> GetTraitClass(const FName TraitClassName) const;

protected:
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;

#if WITH_MASSENTITY_DEBUG
	/** 
	 * Note that the function does nothing until InitRepository is called. This is done to avoid collecting trait
	 * data until it's actually necessary.
	 */
	void OnNewTraitType(UMassEntityTraitBase& Trait);

	void OnDebugEvent(const FName EventName, FConstStructView Payload, EMassDebugMessageSeverity SeverityOverride);
#endif // WITH_MASSENTITY_DEBUG
	/** 
	 * The method gathers all existing trait classes and processed them. We don't do that on subsystem's init since
	 * very often the data won't be needed during the given editor run. We call the function lazily the first time 
	 * the data is needed.
	 */
	void InitRepository();

	FDelegateHandle OnNewTraitTypeHandle;
	struct FTraitAndElements
	{
		TWeakObjectPtr<UClass> TraitClass;
		TArray<FName> ElementNames;
	};
	TMap<FName, FTraitAndElements> TraitClassNameToDataMap;
	TMap<FName, TArray<FName>> ElementTypeToTraitMap;


	/** the World we use to host all the subsystems required to process traits */
	UPROPERTY()
	TObjectPtr<UWorld> InvestigationWorld;

	/** We initialize the repository's data lazily and this property indicates whether it has been already done. */
	bool bIsRepositoryInitialized;

	static TWeakObjectPtr<UWorld> GlobalInvestigationWorld;
};


UCLASS()
class UMassDebugEntitySubsystem : public UMassEntitySubsystem
{
	GENERATED_BODY()
	
	virtual bool ShouldCreateSubsystem(UObject* Outer) const override;
};

==============================================================


=== Source/MassGameplayEditor/MassGameplayEditor.Build.cs ===
=============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

namespace UnrealBuildTool.Rules
{
	public class MassGameplayEditor : ModuleRules
	{
		public MassGameplayEditor(ReadOnlyTargetRules Target) : base(Target)
		{
			PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

			UnsafeTypeCastWarningLevel = WarningLevel.Warning;

			PublicIncludePaths.AddRange(
			new string[] {
			}
			);

			PublicDependencyModuleNames.AddRange(
			new string[] {
				"Core",
				"CoreUObject",
				"Engine",
				"InputCore",
				"AssetTools",
				"UnrealEd",
				"Slate",
				"SlateCore",
				
				"PropertyEditor",
				"MassSpawner",
				"MassEntity",
				"MassEntityEditor",
				"MassActors",
				"DetailCustomizations",
				"ComponentVisualizers",
				"Projects",
				"EditorSubsystem",
			}
			);

			PrivateDependencyModuleNames.AddRange(
			new string[] {
				"RenderCore",
				"GraphEditor",
				"KismetWidgets",
				"PropertyEditor",
				"AIGraph",
				"ToolMenus",
				"DataValidation",
			}
			);
		}

	}
}

=============================================================


=== Source/MassGameplayExternalTraits/Private/MassGameplayExternalTraitsModule.cpp ===
======================================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "IMassGameplayExternalTraitsModule.h"

class FMassGameplayExternalTraitsModule : public IMassGameplayExternalTraitsModule
{

};

IMPLEMENT_MODULE(FMassGameplayExternalTraitsModule, MassGameplayExternalTraits)

======================================================================================


=== Source/MassGameplayExternalTraits/Public/IMassGameplayExternalTraitsModule.h ===
====================================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Modules/ModuleInterface.h"
#include "Modules/ModuleManager.h"


/**
 * The public interface to this module.  In most cases, this interface is only public to sibling modules 
 * within this plugin.
 */
class IMassGameplayExternalTraitsModule : public IModuleInterface
{

public:

	/**
	 * Singleton-like access to this module's interface.  This is just for convenience!
	 * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.
	 *
	 * @return Returns singleton instance, loading the module on demand if needed
	 */
	static inline IMassGameplayExternalTraitsModule& Get()
	{
		return FModuleManager::LoadModuleChecked<IMassGameplayExternalTraitsModule>( "MassGameplayExternalTraits" );
	}

	/**
	 * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.
	 *
	 * @return True if the module is loaded and ready to use
	 */
	static inline bool IsAvailable()
	{
		return FModuleManager::Get().IsModuleLoaded( "MassGameplayExternalTraits" );
	}
};


====================================================================================


=== Source/MassGameplayExternalTraits/Public/MassGameplayExternalTraits.h ===
=============================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassExternalSubsystemTraits.h"

/**
 * The point of this module and header is to have a common place for all the non-Mass subsystems MassGameplay modules
 * are using. This is the most convenient way to ensure we define these only once. The Mass code declaring the system 
 * below as requirements (for example MassEntityQuery's requirements) need to include this header. Otherwise 
 * a compilation error concerning TMassExternalSubsystemTraits will be generated by the compiler.
 */

class USmartObjectSubsystem;
template<>
struct TMassExternalSubsystemTraits<USmartObjectSubsystem> final
{
	enum
	{
		GameThreadOnly = false
	};
};

class UZoneGraphSubsystem;
template<>
struct TMassExternalSubsystemTraits<UZoneGraphSubsystem> final
{
	enum
	{
		GameThreadOnly = false
	};
};

class UZoneGraphAnnotationSubsystem;
template<>
struct TMassExternalSubsystemTraits<UZoneGraphAnnotationSubsystem> final
{
	enum
	{
		GameThreadOnly = false
	};
};

=============================================================================


=== Source/MassGameplayExternalTraits/MassGameplayExternalTraits.Build.cs ===
=============================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

namespace UnrealBuildTool.Rules
{
	public class MassGameplayExternalTraits : ModuleRules
	{
		public MassGameplayExternalTraits(ReadOnlyTargetRules Target) : base(Target)
		{
			PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

			PublicDependencyModuleNames.AddRange(
				new string[] {
					"Core",
					"MassEntity",
				}
			);
		}
	}
}

=============================================================================


=== Source/MassGameplayTestSuite/Private/MassEntityTemplateTest.cpp ===
=======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "AITestsCommon.h"
#include "MassEntityTypes.h"
#include "MassEntityTestTypes.h"
#include "MassEntityTemplate.h"
#include "MassEntityTemplateRegistry.h"

#define LOCTEXT_NAMESPACE "MassTest"

UE_DISABLE_OPTIMIZATION_SHIP

namespace FMassEntityTemplateTest
{

struct FEntityTemplateBase : FExecutionTestBase
{
	FMassEntityTemplateRegistry TemplateRegistry;

	virtual bool SetUp() override
	{
		if (FExecutionTestBase::SetUp())
		{
			TemplateRegistry.Initialize(EntityManager);
			return true;
		}
		return false;
	}
};


struct FEntityTemplate_Empty : FEntityTemplateBase
{
	virtual bool InstantTest() override
	{
		const FMassEntityTemplateID InitialTemplateID = FMassEntityTemplateIDFactory::Make(FGuid::NewGuid());
		FMassEntityTemplateData TemplateData;

		const TSharedRef<FMassEntityTemplate>& FinalizedTemplate = TemplateRegistry.FindOrAddTemplate(InitialTemplateID, MoveTemp(TemplateData));
		
		const FMassEntityTemplateID TemplateID = FinalizedTemplate->GetTemplateID();
		AITEST_TRUE("Empty template is expected to be registered as a valid template", TemplateID.IsValid());
		AITEST_EQUAL("Empty template's ID is expected to be the same as the input template", TemplateID, InitialTemplateID);

		const FMassArchetypeHandle& ArchetypeHandle = FinalizedTemplate->GetArchetype();
		AITEST_TRUE("Empty template is expected to produce a valid (if empty) archetype", ArchetypeHandle.IsValid());

		const FMassArchetypeCompositionDescriptor& ArchetypeDescription = EntityManager->GetArchetypeComposition(ArchetypeHandle);
		AITEST_TRUE("Empty template is expected to produce an empty-composition archetype", ArchetypeDescription.IsEmpty());

		return true;
	}
};
IMPLEMENT_AI_INSTANT_TEST(FEntityTemplate_Empty, "System.Mass.EntityTemplate.Empty");


struct FEntityTemplate_Composition : FEntityTemplateBase
{
	virtual bool InstantTest() override
	{
		FMassEntityTemplateData TemplateData;

		TemplateData.AddFragment<FTestFragment_Int>();
		TemplateData.AddFragment<FTestFragment_Float>();
		TemplateData.AddChunkFragment<FTestChunkFragment_Int>();
		{
			FSharedStruct SharedFragment = EntityManager->GetOrCreateSharedFragment<FTestSharedFragment_Int>(0);
			TemplateData.AddSharedFragment(SharedFragment);
		}
		{
			FSharedStruct SharedFragment = EntityManager->GetOrCreateSharedFragment<FTestSharedFragment_Float>(1);
			TemplateData.AddSharedFragment(SharedFragment);
		}
		TemplateData.Sort();

		FMassArchetypeCompositionDescriptor ExpectedComposition;
		ExpectedComposition.Fragments.Add<FTestFragment_Int>();
		ExpectedComposition.Fragments.Add<FTestFragment_Float>();
		ExpectedComposition.ChunkFragments.Add<FTestChunkFragment_Int>();
		ExpectedComposition.SharedFragments.Add<FTestSharedFragment_Int>();
		ExpectedComposition.SharedFragments.Add<FTestSharedFragment_Float>();

		AITEST_TRUE("The composition should end up being the same regardless of whether the data is added via a template data or a composition descriptor"
			, ExpectedComposition.IsEquivalent(TemplateData.GetCompositionDescriptor()));

		const FMassEntityTemplateID TemplateID = FMassEntityTemplateIDFactory::Make(FGuid::NewGuid());
		const TSharedRef<FMassEntityTemplate>& FinalizedTemplate = TemplateRegistry.FindOrAddTemplate(TemplateID, MoveTemp(TemplateData));

		const FMassArchetypeHandle& ArchetypeHandle = FinalizedTemplate->GetArchetype();
		AITEST_TRUE("Empty template is expected to produce a valid (if empty) archetype", ArchetypeHandle.IsValid());

		const FMassArchetypeCompositionDescriptor& ArchetypeDescription = EntityManager->GetArchetypeComposition(ArchetypeHandle);
		AITEST_TRUE("Empty template is expected to produce an empty-composition archetype", ArchetypeDescription.IsEquivalent(ExpectedComposition));

		return true;
	}
};
IMPLEMENT_AI_INSTANT_TEST(FEntityTemplate_Composition, "System.Mass.EntityTemplate.Composition");


struct FEntityTemplate_Trivial : FEntityTemplateBase
{
	virtual bool InstantTest() override
	{
		FMassEntityTemplateData EmptyTemplateData;
		FMassEntityTemplateData TemplateDataA;
		FMassEntityTemplateData TemplateDataB;

		TemplateDataA.AddFragment<FTestFragment_Int>();
		TemplateDataB.AddFragment<FTestFragment_Int>();
		const FGuid NonEmptyTemplateGuid = FGuid::NewGuid();

		const TSharedRef<FMassEntityTemplate>& FinalizedEmptyTemplate = TemplateRegistry.FindOrAddTemplate(FMassEntityTemplateIDFactory::Make(FGuid::NewGuid()), MoveTemp(EmptyTemplateData));
		const TSharedRef<FMassEntityTemplate>& FinalizedTemplateA = TemplateRegistry.FindOrAddTemplate(FMassEntityTemplateIDFactory::Make(NonEmptyTemplateGuid), MoveTemp(TemplateDataA));
		const TSharedRef<FMassEntityTemplate>& FinalizedTemplateB = TemplateRegistry.FindOrAddTemplate(FMassEntityTemplateIDFactory::Make(NonEmptyTemplateGuid), MoveTemp(TemplateDataB));

		AITEST_NOT_EQUAL("Non-empty template data should result in a finalized template different from the empty one", FinalizedEmptyTemplate->GetTemplateID(), FinalizedTemplateA->GetTemplateID());
		AITEST_EQUAL("Non-empty template data should result in the very same finalized template", FinalizedTemplateA, FinalizedTemplateB);

		const FMassArchetypeHandle& ArchetypeHandle = FinalizedTemplateA->GetArchetype();
		AITEST_TRUE("Non-empty template is expected to produce a valid archetype", ArchetypeHandle.IsValid());

		return true;
	}
};
IMPLEMENT_AI_INSTANT_TEST(FEntityTemplate_Trivial, "System.Mass.EntityTemplate.Trivial");


struct FEntityTemplate_Modified : FEntityTemplateBase
{
	virtual bool InstantTest() override
	{
		UScriptStruct* IntFragmentType = FTestFragment_Int::StaticStruct();
		FMassArchetypeHandle IntsArchetype = EntityManager->CreateArchetype(MakeArrayView(&IntFragmentType, 1));

		FMassEntityTemplateData OriginalTemplateData;
		FTestFragment_Int& IntFragment = OriginalTemplateData.AddFragment_GetRef<FTestFragment_Int>();
		IntFragment.Value = FTestFragment_Int::TestIntValue;

		FMassEntityTemplateData MovedOriginalTemplateData = OriginalTemplateData;
		const TSharedRef<FMassEntityTemplate>& FinalizedOriginalTemplate = TemplateRegistry.FindOrAddTemplate(FMassEntityTemplateIDFactory::Make(FGuid::NewGuid()), MoveTemp(MovedOriginalTemplateData));

		FMassEntityTemplateData NewTemplateData(*FinalizedOriginalTemplate);

		AITEST_TRUE("Template data created from a finalized template should match the composition of the original data"
			, NewTemplateData.GetCompositionDescriptor().IsEquivalent(OriginalTemplateData.GetCompositionDescriptor()));

		// need to set a new name, otherwise the hash calculated while creating finalized template will end up being the 
		// same as the original template's. This is the case since we're not using struct's contents while calculating hash (yet).
		NewTemplateData.SetTemplateName(TEXT("ModifiedTemplate"));
		FTestFragment_Int* CoppiedFragment = NewTemplateData.GetMutableFragment<FTestFragment_Int>();
		AITEST_NOT_NULL("The fragment instance is expected to be found", CoppiedFragment);
		AITEST_EQUAL("The fragment instance is expected to have the same value as the original one", CoppiedFragment->Value, IntFragment.Value);
		CoppiedFragment->Value = FTestFragment_Int::TestIntValue + 1;
		AITEST_NOT_EQUAL("Modifying the coppied instance of the fragment doesn't affect the original", CoppiedFragment->Value, IntFragment.Value);

		const FMassEntityTemplateID NewTemplateID = FMassEntityTemplateIDFactory::MakeFlavor(FinalizedOriginalTemplate->GetTemplateID(), 1);
		const TSharedRef<FMassEntityTemplate>& FinalizedModifiedTemplate = TemplateRegistry.FindOrAddTemplate(NewTemplateID, MoveTemp(NewTemplateData));

		AITEST_NOT_EQUAL("The original and modified templates should end up resulting in two different templates", FinalizedModifiedTemplate->GetTemplateID(), FinalizedOriginalTemplate->GetTemplateID());
		AITEST_EQUAL("The original and modified templates should still point at the same archetype", FinalizedModifiedTemplate->GetArchetype(), FinalizedOriginalTemplate->GetArchetype());

		AITEST_EQUAL("The resulting archetype should match the IntArchetypeHandle", FinalizedModifiedTemplate->GetArchetype(), IntsArchetype);

		return true;
	}
};
IMPLEMENT_AI_INSTANT_TEST(FEntityTemplate_Modified, "System.Mass.EntityTemplate.Modification");


//struct FEntityTemplate_Modified : FEntityTemplateBase
//{
//	virtual bool InstantTest() override
//	{
//		FMassEntityTemplateData OriginalTemplateData;
//		OriginalTemplateData.AddFragment<FTestFragment_Int>();
//
//		FMassEntityTemplateData OriginalTemplateDataCopy = OriginalTemplateData;
//		const TSharedRef<FMassEntityTemplate>& FinalizedOriginalTemplate = TemplateRegistry.FindOrAddTemplate(MoveTemp(OriginalTemplateData));
//		
//
//		AITEST_NOT_EQUAL("Non-empty template data should result in a finalized template different from the empty one", FinalizedEmptyTemplate->GetTemplateID(), FinalizedTemplateA->GetTemplateID());
//		AITEST_EQUAL("Non-empty template data should result in the very same finalized template", FinalizedTemplateA, FinalizedTemplateB);
//
//		const FMassArchetypeHandle& ArchetypeHandle = FinalizedTemplateA->GetArchetype();
//		AITEST_TRUE("Non-empty template is expected to produce a valid archetype", ArchetypeHandle.IsValid());*/
//
//		return true;
//	}
//};
//IMPLEMENT_AI_INSTANT_TEST(FEntityTemplate_Modified, "System.Mass.EntityTemplate.Modification");

} // FMassEntityTemplateTest

UE_ENABLE_OPTIMIZATION_SHIP

#undef LOCTEXT_NAMESPACE

=======================================================================


=== Source/MassGameplayTestSuite/Private/MassGameplayTestSuiteModule.cpp ===
============================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassGameplayTestSuiteModule.h"

#define LOCTEXT_NAMESPACE "MassTest"

class FMassGameplayTestSuiteModule : public IMassGameplayTestSuiteModule
{
};

IMPLEMENT_MODULE(FMassGameplayTestSuiteModule, MassGameplayTestSuite)

#undef LOCTEXT_NAMESPACE

============================================================================


=== Source/MassGameplayTestSuite/Public/MassGameplayTestSuiteModule.h ===
=========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

/**
* The public interface to this module
*/
class IMassGameplayTestSuiteModule : public IModuleInterface
{

public:

	/**
	* Singleton-like access to this module's interface.  This is just for convenience!
	* Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.
	*
	* @return Returns singleton instance, loading the module on demand if needed
	*/
	static inline IMassGameplayTestSuiteModule& Get()
	{
		return FModuleManager::LoadModuleChecked<IMassGameplayTestSuiteModule>("MassGameplayTestSuite");
	}

	/**
	* Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.
	*
	* @return True if the module is loaded and ready to use
	*/
	static inline bool IsAvailable()
	{
		return FModuleManager::Get().IsModuleLoaded("MassGameplayTestSuite");
	}
};


=========================================================================


=== Source/MassGameplayTestSuite/MassGameplayTestSuite.Build.cs ===
===================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

namespace UnrealBuildTool.Rules
{
	public class MassGameplayTestSuite : ModuleRules
	{
		public MassGameplayTestSuite(ReadOnlyTargetRules Target) : base(Target)
		{
			PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

			PublicIncludePaths.AddRange(
				new string[] {
				}
			);

			PublicDependencyModuleNames.AddRange(
				new string[] {
					"Core",
					"CoreUObject",
					"Engine",
					"AITestSuite",
					"MassEntity",
					"MassEntityTestSuite",
					"MassSpawner",
				}
			);
		}
	}
}
===================================================================


=== Source/MassLOD/Private/MassLODCollectorProcessor.cpp ===
============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassLODCollectorProcessor.h"
#include "MassLODUtils.h"
#include "MassCommonFragments.h"
#include "MassExecutionContext.h"
#include "Engine/World.h"
#include "MassSimulationLOD.h"

UMassLODCollectorProcessor::UMassLODCollectorProcessor()
{
	bAutoRegisterWithProcessingPhases = false;

	ExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;

	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::LODCollector;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::SyncWorldToMass);
}

void UMassLODCollectorProcessor::ConfigureQueries()
{
	FMassEntityQuery BaseQuery;
	BaseQuery.AddTagRequirement<FMassCollectLODViewerInfoTag>(EMassFragmentPresence::All);
	BaseQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	BaseQuery.AddRequirement<FMassViewerInfoFragment>(EMassFragmentAccess::ReadWrite);
	BaseQuery.AddChunkRequirement<FMassSimulationVariableTickChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);
	BaseQuery.AddChunkRequirement<FMassVisualizationChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);
	BaseQuery.SetChunkFilter([](const FMassExecutionContext& Context)
	{
		return FMassVisualizationChunkFragment::IsChunkHandledThisFrame(Context)
			|| FMassSimulationVariableTickChunkFragment::IsChunkHandledThisFrame(Context);
	});

	EntityQuery_VisibleRangeAndOnLOD = BaseQuery;
	EntityQuery_VisibleRangeAndOnLOD.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::None);
	EntityQuery_VisibleRangeAndOnLOD.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);
	EntityQuery_VisibleRangeAndOnLOD.RegisterWithProcessor(*this);

	EntityQuery_VisibleRangeOnly = BaseQuery;
	EntityQuery_VisibleRangeOnly.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::None);
	EntityQuery_VisibleRangeOnly.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::All);
	EntityQuery_VisibleRangeOnly.RegisterWithProcessor(*this);

	EntityQuery_OnLODOnly = BaseQuery;
	EntityQuery_OnLODOnly.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::All);
	EntityQuery_OnLODOnly.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);
	EntityQuery_OnLODOnly.RegisterWithProcessor(*this);

	EntityQuery_NotVisibleRangeAndOffLOD = BaseQuery;
	EntityQuery_NotVisibleRangeAndOffLOD.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::All);
	EntityQuery_NotVisibleRangeAndOffLOD.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::All);
	EntityQuery_NotVisibleRangeAndOffLOD.RegisterWithProcessor(*this);

	ProcessorRequirements.AddSubsystemRequirement<UMassLODSubsystem>(EMassFragmentAccess::ReadOnly);
}

template <bool bLocalViewersOnly>
void UMassLODCollectorProcessor::CollectLODForChunk(FMassExecutionContext& Context)
{
	TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
	TArrayView<FMassViewerInfoFragment> ViewerInfoList = Context.GetMutableFragmentView<FMassViewerInfoFragment>();

	Collector.CollectLODInfo<FTransformFragment, FMassViewerInfoFragment, bLocalViewersOnly, true/*bCollectDistanceToFrustum*/>(Context, LocationList, ViewerInfoList);
}

template <bool bLocalViewersOnly>
void UMassLODCollectorProcessor::ExecuteInternal(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(Close);
		EntityQuery_VisibleRangeAndOnLOD.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context) { CollectLODForChunk<bLocalViewersOnly>(Context); });
		EntityQuery_VisibleRangeOnly.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context) { CollectLODForChunk<bLocalViewersOnly>(Context); });
		EntityQuery_OnLODOnly.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context) { CollectLODForChunk<bLocalViewersOnly>(Context); });
	}

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(Far);
		EntityQuery_NotVisibleRangeAndOffLOD.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context) { CollectLODForChunk<bLocalViewersOnly>(Context); });
	}
}

void UMassLODCollectorProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	const UMassLODSubsystem& LODSubsystem = Context.GetSubsystemChecked<UMassLODSubsystem>();
	const TArray<FViewerInfo>& Viewers = LODSubsystem.GetViewers();
	Collector.PrepareExecution(Viewers);

	UWorld* World = EntityManager.GetWorld();
	check(World);
	if (World->IsNetMode(NM_DedicatedServer))
	{
		ExecuteInternal<false/*bLocalViewersOnly*/>(EntityManager, Context);
	}
	else
	{
		ExecuteInternal<true/*bLocalViewersOnly*/>(EntityManager, Context);
	}

}

============================================================


=== Source/MassLOD/Private/MassLODDistanceCollectorProcessor.cpp ===
====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassLODDistanceCollectorProcessor.h"
#include "MassLODUtils.h"
#include "MassCommonFragments.h"
#include "MassExecutionContext.h"
#include "Engine/World.h"
#include "MassSimulationLOD.h"


//-----------------------------------------------------------------------------
// UMassLODDistanceCollectorProcessor
//-----------------------------------------------------------------------------
UMassLODDistanceCollectorProcessor::UMassLODDistanceCollectorProcessor()
{
	bAutoRegisterWithProcessingPhases = true;

	ExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;

	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::LODCollector;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::SyncWorldToMass);
}

void UMassLODDistanceCollectorProcessor::ConfigureQueries()
{
	FMassEntityQuery BaseQuery;
	BaseQuery.AddTagRequirement<FMassCollectDistanceLODViewerInfoTag>(EMassFragmentPresence::All);
	BaseQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	BaseQuery.AddRequirement<FMassViewerInfoFragment>(EMassFragmentAccess::ReadWrite);
	BaseQuery.AddChunkRequirement<FMassSimulationVariableTickChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);
	BaseQuery.AddChunkRequirement<FMassVisualizationChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);
	BaseQuery.SetChunkFilter([](const FMassExecutionContext& Context)
	{
		return FMassVisualizationChunkFragment::IsChunkHandledThisFrame(Context)
			|| FMassSimulationVariableTickChunkFragment::IsChunkHandledThisFrame(Context);
	});

	EntityQuery_RelevantRangeAndOnLOD = BaseQuery;
	EntityQuery_RelevantRangeAndOnLOD.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::None);
	EntityQuery_RelevantRangeAndOnLOD.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);
	EntityQuery_RelevantRangeAndOnLOD.RegisterWithProcessor(*this);

	EntityQuery_RelevantRangeOnly = BaseQuery;
	EntityQuery_RelevantRangeOnly.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::None);
	EntityQuery_RelevantRangeOnly.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::All);
	EntityQuery_RelevantRangeOnly.RegisterWithProcessor(*this);

	EntityQuery_OnLODOnly = BaseQuery;
	EntityQuery_OnLODOnly.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::All);
	EntityQuery_OnLODOnly.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);
	EntityQuery_OnLODOnly.RegisterWithProcessor(*this);

	EntityQuery_NotRelevantRangeAndOffLOD = BaseQuery;
	EntityQuery_NotRelevantRangeAndOffLOD.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::All);
	EntityQuery_NotRelevantRangeAndOffLOD.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::All);
	EntityQuery_NotRelevantRangeAndOffLOD.RegisterWithProcessor(*this);

	ProcessorRequirements.AddSubsystemRequirement<UMassLODSubsystem>(EMassFragmentAccess::ReadOnly);
}

template <bool bLocalViewersOnly>
void UMassLODDistanceCollectorProcessor::CollectLODForChunk(FMassExecutionContext& Context)
{
	TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
	TArrayView<FMassViewerInfoFragment> ViewerInfoList = Context.GetMutableFragmentView<FMassViewerInfoFragment>();

	Collector.CollectLODInfo<FTransformFragment, FMassViewerInfoFragment, bLocalViewersOnly, false/*bCollectDistanceToFrustum*/>(Context, LocationList, ViewerInfoList);
}

template <bool bLocalViewersOnly>
void UMassLODDistanceCollectorProcessor::ExecuteInternal(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(LODDistanceCollector_Close);
		{
			TRACE_CPUPROFILER_EVENT_SCOPE(LODDistanceCollector_Close_RelevantRangeAndOnLOD);
			EntityQuery_RelevantRangeAndOnLOD.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context) { CollectLODForChunk<bLocalViewersOnly>(Context); });
		}
		{
			TRACE_CPUPROFILER_EVENT_SCOPE(LODDistanceCollector_Close_OnLODOnly);
			EntityQuery_RelevantRangeOnly.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context) { CollectLODForChunk<bLocalViewersOnly>(Context); });
		}
		{
			TRACE_CPUPROFILER_EVENT_SCOPE(LODDistanceCollector_Close_OnLODOnly);
			EntityQuery_OnLODOnly.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context) { CollectLODForChunk<bLocalViewersOnly>(Context); });
		}
	}

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(LODDistanceCollector_Far);
		EntityQuery_NotRelevantRangeAndOffLOD.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context) { CollectLODForChunk<bLocalViewersOnly>(Context); });
	}
}

void UMassLODDistanceCollectorProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	const UMassLODSubsystem& LODSubsystem = Context.GetSubsystemChecked<UMassLODSubsystem>();
	const TArray<FViewerInfo>& Viewers = LODSubsystem.GetViewers();
	Collector.PrepareExecution(Viewers);

	UWorld* World = EntityManager.GetWorld();
	check(World);
	if (World->IsNetMode(NM_DedicatedServer))
	{
		ExecuteInternal<false/*bLocalViewersOnly*/>(EntityManager, Context);
	}
	else
	{
		ExecuteInternal<true/*bLocalViewersOnly*/>(EntityManager, Context);
	}
}

====================================================================


=== Source/MassLOD/Private/MassLODLogic.cpp ===
===============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassLODLogic.h"
#include "Engine/World.h"
#include "GameFramework/PlayerController.h"

void FMassLODBaseLogic::CacheViewerInformation(TConstArrayView<FViewerInfo> ViewerInfos)
{
	if(Viewers.Num() < ViewerInfos.Num())
	{
		Viewers.AddDefaulted(ViewerInfos.Num() - Viewers.Num());
	}

	// Cache viewer info
	for (int ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)
	{
		const FViewerInfo& Viewer =  ViewerInfos.IsValidIndex(ViewerIdx) ? ViewerInfos[ViewerIdx] : FViewerInfo();
		const FMassViewerHandle ViewerHandle =  Viewer.bEnabled ? Viewer.Handle : FMassViewerHandle();

		// Check if it is the same client as before
		FViewerLODInfo& ViewerLOD = Viewers[ViewerIdx];
		ViewerLOD.bClearData = Viewers[ViewerIdx].Handle != ViewerHandle;
		ViewerLOD.Handle = ViewerHandle;
		ViewerLOD.bLocal = Viewer.IsLocal();

		if (ViewerHandle.IsValid())
		{
			ViewerLOD.Location = Viewer.Location;
			ViewerLOD.Direction = Viewer.Rotation.Vector();

			if (bBuildFrustumData)
			{
				const float HalfHorizontalFOVAngle = Viewer.FOV * 0.5f;
				const float HalfVerticalFOVAngle = FMath::RadiansToDegrees(FMath::Atan(FMath::Tan(FMath::DegreesToRadians(HalfHorizontalFOVAngle)) * Viewer.AspectRatio));

				const FVector RightPlaneNormal = Viewer.Rotation.RotateVector(FRotator(0.0f, HalfHorizontalFOVAngle, 0.0f).RotateVector(FVector::RightVector));
				const FVector LeftPlaneNormal = Viewer.Rotation.RotateVector(FRotator(0.0f, -HalfHorizontalFOVAngle, 0.0f).RotateVector(FVector::LeftVector));
				const FVector TopPlaneNormal = Viewer.Rotation.RotateVector(FRotator(HalfVerticalFOVAngle, 0.0f, 0.0f).RotateVector(FVector::UpVector));
				const FVector BottomPlaneNormal = Viewer.Rotation.RotateVector(FRotator(-HalfVerticalFOVAngle, 0.0f, 0.0f).RotateVector(FVector::DownVector));

				TArray<FPlane, TInlineAllocator<6>> Planes;
				Planes.Emplace(ViewerLOD.Location, RightPlaneNormal);
				Planes.Emplace(ViewerLOD.Location, LeftPlaneNormal);
				Planes.Emplace(ViewerLOD.Location, TopPlaneNormal);
				Planes.Emplace(ViewerLOD.Location, BottomPlaneNormal);

				ViewerLOD.Frustum = FConvexVolume(Planes);
			}
		}
	}
}
===============================================


=== Source/MassLOD/Private/MassLODModule.cpp ===
================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "CoreMinimal.h"
#include "IMassLODModule.h"
#include "UObject/CoreRedirects.h"


class FMassLODModule : public IMassLODModule
{
	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

IMPLEMENT_MODULE(FMassLODModule, MassLOD)



void FMassLODModule::StartupModule()
{
	// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)
}


void FMassLODModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}




================================================


=== Source/MassLOD/Private/MassLODSubsystem.cpp ===
===================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassLODSubsystem.h"
#include "GameFramework/PlayerController.h"
#include "WorldPartition/WorldPartition.h"
#include "WorldPartition/WorldPartitionStreamingSource.h"
#include "Engine/World.h"
#include "MassSimulationSubsystem.h"
#include "Camera/PlayerCameraManager.h"
#include "GameFramework/Pawn.h"
#if WITH_EDITOR
#include "CoreGlobals.h" // GIsEditor
#include "Editor.h" // GEditor
#include "LevelEditorViewport.h"
#include "Editor/EditorEngine.h"
#endif // WITH_EDITOR

namespace UE::MassLOD
{
	FColor LODColors[] =
	{
		FColor::Red,
		FColor::Yellow,
		FColor::Emerald,
		FColor::White,
	};
	
	namespace Tweakables
	{

		bool bLODSubsystemIncludeAllPlayerControllers = true;
		namespace
		{
			static FAutoConsoleVariableRef AnonymousCVars[] = {
				{ TEXT("mass.LODSubsystem.IncludeAllPlayerControllers"), bLODSubsystemIncludeAllPlayerControllers, TEXT("Include all player controllers, even those without a camera or pawn."), ECVF_Default }
			};
		}
	}  // UE::Mass::Tweakables

#if WITH_MASSGAMEPLAY_DEBUG
	namespace Debug
	{
		/** Returns whether getting the UMassLODSubsystem and the bool parameter was successful */
		bool GetSubsystemAndBoolArgument(const TArray<FString>& Args, UWorld* World, UMassLODSubsystem*& OutMassLODSubsystem, bool& bOutBool)
		{
			if (!World)
			{
				UE_LOG(LogConsoleResponse, Display, TEXT("Error: invalid world"));
				return false;
			}

			OutMassLODSubsystem = World->GetSubsystem<UMassLODSubsystem>();
			if (OutMassLODSubsystem == nullptr)
			{
				UE_LOG(LogConsoleResponse, Display, TEXT("Error: Unable to fetch MassLODSubsystem instance"));
				return false;
			}

			if (Args.Num() < 1)
			{
				UE_LOG(LogConsoleResponse, Display, TEXT("Error: Expecting 1 parameter"));
				return false;
			}

			if (!LexTryParseString<bool>(bOutBool, *Args[0]))
			{
				UE_LOG(LogConsoleResponse, Display, TEXT("Error: parameter must be an integer or a boolean"));
				return false;
			}

			return true;
		}

		FAutoConsoleCommandWithWorldArgsAndOutputDevice ToggleUsePlayerLocationCmd(
			TEXT("mass.debug.LODSubsystem.UsePlayerLocation"),
			TEXT("Sets UMassLODSubsystem::bUsePlayerPawnLocationInsteadOfCamera. Note that this is a command that doesn't retain state and usually needs running both for the client and the server"),
			FConsoleCommandWithWorldArgsAndOutputDeviceDelegate::CreateLambda([](const TArray<FString>& Args, UWorld* World, FOutputDevice& Ar)
				{
					UMassLODSubsystem* MassLODSubsystem = nullptr;
					bool bNewValue = false;

					if (GetSubsystemAndBoolArgument(Args, World, MassLODSubsystem, bNewValue))
					{
						MassLODSubsystem->DebugSetUsePlayerPawnLocationInsteadOfCamera(bNewValue);
					}
				}));

		FAutoConsoleCommandWithWorldArgsAndOutputDevice ToggleGatherPlayers(
			TEXT("mass.debug.LODSubsystem.GatherPlayers"),
			TEXT("Sets UMassLODSubsystem::bGatherPlayerControllers. Note that this is a command that doesn't retain state and usually needs running both for the client and the server"),
			FConsoleCommandWithWorldArgsAndOutputDeviceDelegate::CreateLambda([](const TArray<FString>& Args, UWorld* World, FOutputDevice& Ar)
				{
					UMassLODSubsystem* MassLODSubsystem = nullptr;
					bool bNewValue = false;

					if (GetSubsystemAndBoolArgument(Args, World, MassLODSubsystem, bNewValue))
					{
						MassLODSubsystem->DebugSetGatherPlayers(bNewValue);
					}
				})); 
	}
#endif // WITH_MASSGAMEPLAY_DEBUG
}

//-----------------------------------------------------------------------------
// UMassLODSubsystem
//-----------------------------------------------------------------------------
void UMassLODSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Collection.InitializeDependency(UMassSimulationSubsystem::StaticClass());

	Super::Initialize(Collection);
	
	if (UWorld* World = GetWorld())
	{
		UMassSimulationSubsystem* SimSystem = World->GetSubsystem<UMassSimulationSubsystem>();
		check(SimSystem);
		SimSystem->GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).AddUObject(this, &UMassLODSubsystem::OnPrePhysicsPhaseStarted);
#if WITH_EDITOR
		bIgnorePlayerControllersDueToSimulation = (GEditor && GEditor->IsSimulateInEditorInProgress());
		bUseEditorLevelViewports = bIgnorePlayerControllersDueToSimulation || (GIsEditor && World->WorldType == EWorldType::Editor);
#endif // WITH_EDITOR
	}

	SynchronizeViewers();
}

void UMassLODSubsystem::OnPrePhysicsPhaseStarted(float DeltaTime)
{
	SynchronizeViewers();
}

void UMassLODSubsystem::Deinitialize()
{
	// Remove all viewers from the viewer info list
	for (FViewerInfo& ViewerInfo : Viewers)
	{
		if (ViewerInfo.Handle.IsValid())
		{
			// Safe to remove while iterating as it is a sparse array with a free list
			RemoveViewer(ViewerInfo.Handle);
		}
	}
	
	if (UWorld* World = GetWorld())
	{
		if (UMassSimulationSubsystem* SimSystem = World->GetSubsystem<UMassSimulationSubsystem>())
		{
			SimSystem->GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).RemoveAll(this);
		}
	}

	Super::Deinitialize();
}

int32 UMassLODSubsystem::GetValidViewerIdx(const FMassViewerHandle& ViewerHandle) const
{
	// Check against invalid handle
	if (!ViewerHandle.IsValid())
	{
		return INDEX_NONE;
	}

	// Check against removed viewers
	const int32 ViewerIdx = ViewerHandle.GetIndex();
	if (ViewerIdx >= Viewers.Num() || ViewerHandle != Viewers[ViewerIdx].Handle)
	{
		return INDEX_NONE;
	}

	return ViewerIdx;
}

const TArray<FViewerInfo>& UMassLODSubsystem::GetSynchronizedViewers()
{
	SynchronizeViewers();

	return Viewers;
}

FMassViewerHandle UMassLODSubsystem::GetViewerHandleFromActor(const AActor& Actor) const
{
	const FMassViewerHandle* Handle = ViewerMap.Find(GetTypeHash(Actor.GetFName()));
	return Handle ? *Handle : FMassViewerHandle();
}


FMassViewerHandle UMassLODSubsystem::GetViewerHandleFromStreamingSource(const FName StreamingSourceName) const
{
	const FMassViewerHandle* Handle = ViewerMap.Find(GetTypeHash(StreamingSourceName));
	return Handle ? *Handle : FMassViewerHandle();
}

APlayerController* UMassLODSubsystem::GetPlayerControllerFromViewerHandle(const FMassViewerHandle& ViewerHandle) const
{
	const int32 ViewerIdx = GetValidViewerIdx(ViewerHandle);
	return ViewerIdx != INDEX_NONE ? Viewers[ViewerIdx].GetPlayerController() : nullptr;
}

void UMassLODSubsystem::SynchronizeViewers()
{
	if (LastSynchronizedFrame == GFrameCounter)
	{
		return;
	}
	LastSynchronizedFrame = GFrameCounter;

	bool bNeedShrinking = false;

	const UWorld* World = GetWorld();
	UWorldPartition* WorldPartition = World ? World->GetWorldPartition() : nullptr;
	const TArray<FWorldPartitionStreamingSource>& StreamingSources = WorldPartition ? WorldPartition->GetStreamingSources() : TArray<FWorldPartitionStreamingSource>();

	// Go through the list and check validity and store the valid one into a map
	TMap<uint32, FMassViewerHandle> LocalViewerMap;
	for (int32 ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)
	{
		FViewerInfo& ViewerInfo = Viewers[ViewerIdx];
		if (!ViewerInfo.Handle.IsValid())
		{
			check(ViewerFreeIndices.Find(ViewerIdx) != INDEX_NONE);
			continue;
		}

		APlayerController* ViewerAsPlayerController = ViewerInfo.GetPlayerController();
		if (ViewerAsPlayerController != nullptr
#if WITH_EDITOR
			&& bIgnorePlayerControllersDueToSimulation == false
#endif // WITH_EDITOR
			)
		{
			LocalViewerMap.Add(GetTypeHash(ViewerAsPlayerController->GetFName()), ViewerInfo.Handle);
		}
		else if (!ViewerInfo.StreamingSourceName.IsNone() && StreamingSources.FindByPredicate([&ViewerInfo](const FWorldPartitionStreamingSource& Source){ return Source.Name == ViewerInfo.StreamingSourceName; }) != nullptr)
		{
			LocalViewerMap.Add(GetTypeHash(ViewerInfo.StreamingSourceName), ViewerInfo.Handle);
		}
#if WITH_EDITOR
		else if (bUseEditorLevelViewports && ViewerInfo.EditorViewportClientIndex != INDEX_NONE
			&& GEditor && GEditor->GetLevelViewportClients().IsValidIndex(ViewerInfo.EditorViewportClientIndex)
			&& GEditor->GetLevelViewportClients()[ViewerInfo.EditorViewportClientIndex])
		{
			
			const int32 HashValue = GetTypeHash(GEditor->GetLevelViewportClients()[ViewerInfo.EditorViewportClientIndex]);
			LocalViewerMap.Add(HashValue, ViewerInfo.Handle);
		}
#endif // WITH_EDITOR
		else
		{
			// Safe to remove while iterating as it is a sparse array with a free list
			RemoveViewer(ViewerInfo.Handle);
			bNeedShrinking |= ViewerIdx == Viewers.Num() - 1;
		}
	}

	if (World)
	{
		if (bGatherPlayerControllers)
		{
			// Now go through all current player controllers and add if they do not exist
			for (FConstPlayerControllerIterator PlayerIterator = World->GetPlayerControllerIterator(); PlayerIterator; ++PlayerIterator)
			{
				APlayerController* PlayerController = (*PlayerIterator).Get();
				check(PlayerController);

				// Check if the controller already exists by trying to remove it from the map which was filled up with controllers we were tracking
				if (LocalViewerMap.Remove(GetTypeHash(PlayerController->GetFName())) == 0)
				{
					// If not add it to the list
					AddPlayerViewer(*PlayerController);
				}
			}
		}

		if (bGatherStreamingSources)
		{
			// Now go through all current streaming source and add if they do not exist
			for (const FWorldPartitionStreamingSource& StreamingSource : StreamingSources)
			{
				if (LocalViewerMap.Remove(GetTypeHash(StreamingSource.Name)) == 0)
				{
					AddStreamingSourceViewer(StreamingSource.Name);
				}
			}
		}

		if (bAllowNonPlayerViwerActors)
		{
			for (int32 ActorViewerIndex = RegisteredActorViewers.Num() - 1; ActorViewerIndex >= 0; --ActorViewerIndex)
			{
				if (RegisteredActorViewers[ActorViewerIndex])
				{
					AddActorViewer(*RegisteredActorViewers[ActorViewerIndex]);
				}
				else
				{
					RegisteredActorViewers.RemoveAtSwap(ActorViewerIndex, EAllowShrinking::No);
				}
			}
		}
	}
#if WITH_EDITOR
	if (bUseEditorLevelViewports)
	{
		CA_ASSUME(GEditor);
		for (int32 ClientIndex = 0; ClientIndex < GEditor->GetLevelViewportClients().Num(); ++ClientIndex)
		{
			const FLevelEditorViewportClient* LevelVC = GEditor->GetLevelViewportClients()[ClientIndex];
			if (LevelVC && LevelVC->IsPerspective())
			{
				const int32 HashValue = GetTypeHash(LevelVC);
				if (LocalViewerMap.Remove(HashValue) == 0)
				{
					AddEditorViewer(HashValue, ClientIndex);
				}
			}
		}
	}
	
#endif // WITH_EDITOR

	// Anything left in the map need to be removed from the list
	for (TMap<uint32, FMassViewerHandle>::TIterator Itr = LocalViewerMap.CreateIterator(); Itr; ++Itr)
	{
		const int32 ViewerIdx = Itr->Value.GetIndex();
		RemoveViewer(Viewers[ViewerIdx].Handle);
		bNeedShrinking |= ViewerIdx == Viewers.Num() - 1;
	}

	if (bNeedShrinking)
	{
		// Check to shrink the array of viewers if possible
		while (Viewers.Num() > 0 && ViewerFreeIndices.Num() > 0 && ViewerFreeIndices.Remove(Viewers.Num() - 1))
		{
			Viewers.Pop(EAllowShrinking::No);
		}
	}

	// Update location and direction for every type of viewer
	for (FViewerInfo& ViewerInfo : Viewers)
	{
		if (!ViewerInfo.Handle.IsValid())
		{
			continue;
		}

		if (APlayerController* ViewerAsPlayerController = ViewerInfo.GetPlayerController())
		{
			ViewerInfo.bEnabled = !WorldPartition || ViewerAsPlayerController->bEnableStreamingSource;

			// Note: Using bUsePlayerPawnLocationInsteadOfCamera will not work correctly with FOV based LOD, since the
			// camera will be at wrong location.  
			// @todo: separate "player location" and "view location", and use the player location on distance based LOD 
			// calculations for stability, and view location in FOV based LOD for view precision.
			if (bUsePlayerPawnLocationInsteadOfCamera && ViewerAsPlayerController->GetPawn())
			{
				ViewerInfo.Location = ViewerAsPlayerController->GetPawn()->GetActorLocation();
				ViewerInfo.Rotation = ViewerAsPlayerController->GetPawn()->GetActorRotation();
			}
			else
			{
				FVector PlayerCameraLocation(ForceInitToZero);
				FRotator PlayerCameraRotation(FRotator::ZeroRotator);
				ViewerAsPlayerController->GetPlayerViewPoint(PlayerCameraLocation, PlayerCameraRotation);
				ViewerInfo.Location = PlayerCameraLocation;
				ViewerInfo.Rotation = PlayerCameraRotation;
			}

			// Try to fetch a more precise FOV
			if (ViewerAsPlayerController->PlayerCameraManager)
			{
				ViewerInfo.FOV = ViewerAsPlayerController->PlayerCameraManager->GetFOVAngle();

				// @todo need to find a way to retrieve aspect ratio, this does not seems to work
				//ViewerInfo.AspectRatio = MinViewInfo.AspectRatio;
			}
		}
		else if (AActor* Actor = ViewerInfo.ActorViewer.Get())
		{
			ViewerInfo.Location = Actor->GetActorLocation();
			ViewerInfo.Rotation = Actor->GetActorRotation();
		}
#if WITH_EDITOR
		else if (bUseEditorLevelViewports && ViewerInfo.EditorViewportClientIndex != INDEX_NONE)
		{
			CA_ASSUME(GEditor);
			const FLevelEditorViewportClient* LevelVC = GEditor->GetLevelViewportClients()[ViewerInfo.EditorViewportClientIndex];
			checkSlow(LevelVC);
			ViewerInfo.bEnabled = LevelVC && LevelVC->IsPerspective();
			ViewerInfo.Location = LevelVC->GetViewLocation();
			ViewerInfo.Rotation = LevelVC->GetViewRotation();
			
		}
#endif // WITH_EDITOR
		else
		{
			checkf(!ViewerInfo.StreamingSourceName.IsNone(), TEXT("Expecting to have a streamingsourcename if the playercontroller is null"));
			const FWorldPartitionStreamingSource* StreamingSource = StreamingSources.FindByPredicate([&ViewerInfo](const FWorldPartitionStreamingSource& Source) { return Source.Name == ViewerInfo.StreamingSourceName; });
			checkf(StreamingSource, TEXT("Expecting to be pointing to a valid streaming source"));
			ViewerInfo.bEnabled = StreamingSource != nullptr;
			if (StreamingSource)
			{
				ViewerInfo.Location = StreamingSource->Location;
				ViewerInfo.Rotation = StreamingSource->Rotation;
			}
		}
	}
}

void UMassLODSubsystem::AddViewer(APlayerController* PlayerController, FName StreamingSourceName /* = NAME_None*/)
{
	if (PlayerController)
	{
		AddPlayerViewer(*PlayerController);
	}
	else
	{
		AddStreamingSourceViewer(StreamingSourceName);
	}
}

void UMassLODSubsystem::AddPlayerViewer(APlayerController& PlayerController)
{
#if WITH_EDITOR
	if (bIgnorePlayerControllersDueToSimulation)
	{
		return;
	}
#endif // WITH_EDITOR

	// ignore players that don't have a pawn nor a camera
	if (UE::MassLOD::Tweakables::bLODSubsystemIncludeAllPlayerControllers == false &&
		PlayerController.GetPawn() == nullptr
		&& (bool(PlayerController.PlayerCameraManager) == false
			|| PlayerController.PlayerCameraManager->GetLastFrameCameraCacheTime() == 0.f)
		)	
	{
		return;
	}

	const int32 HashValue = GetTypeHash(PlayerController.GetFName());

	FMassViewerHandle& ViewerHandle = ViewerMap.FindOrAdd(HashValue, FMassViewerHandle());
	if (ViewerHandle.IsValid())
	{
		// We are only interested to set the player controller if it was not already set.
		const int32 ViewerHandleIdx = GetValidViewerIdx(ViewerHandle);
		check(ViewerHandleIdx != INDEX_NONE);

		FViewerInfo& ViewerInfo = Viewers[ViewerHandleIdx];
		check(ViewerInfo.ActorViewer == nullptr);
		ViewerInfo.ActorViewer = &PlayerController;
	}
	else
	{
		// Add new viewer
#if UE_ALLOW_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER
		//for debugging / profiling purposes create DebugNumberViwersPerController
		//in this case ViewerMap will only contain a hash to the most recent viewer handle created.
		for (int Idx = 0; Idx < UE::MassLOD::DebugNumberViewersPerController; ++Idx)
#endif //UE_ALLOW_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER
		{
			const bool bAddNew = ViewerFreeIndices.Num() == 0;
			const int NewIdx = bAddNew ? Viewers.Num() : ViewerFreeIndices.Pop();
			FViewerInfo& NewViewerInfo = bAddNew ? Viewers.AddDefaulted_GetRef() : Viewers[NewIdx];
			NewViewerInfo.ActorViewer = &PlayerController;
			NewViewerInfo.Handle.Index = NewIdx;
			NewViewerInfo.Handle.SerialNumber = GetNextViewerSerialNumber();
			NewViewerInfo.HashValue = HashValue;

			ViewerHandle = NewViewerInfo.Handle;

			OnViewerAddedDelegate.Broadcast(NewViewerInfo);
		}
	}

	PlayerController.OnEndPlay.AddUniqueDynamic(this, &UMassLODSubsystem::OnPlayerControllerEndPlay);
}

void UMassLODSubsystem::AddStreamingSourceViewer(const FName StreamingSourceName)
{
	const int32 HashValue = GetTypeHash(StreamingSourceName);

	FMassViewerHandle& ViewerHandle = ViewerMap.FindOrAdd(HashValue, FMassViewerHandle());
	// only add new viewer if it hasn't been added yet
	if (ViewerHandle.IsValid() == false)
	{
		const bool bAddNew = ViewerFreeIndices.Num() == 0;
		const int NewIdx = bAddNew ? Viewers.Num() : ViewerFreeIndices.Pop();
		FViewerInfo& NewViewerInfo = bAddNew ? Viewers.AddDefaulted_GetRef() : Viewers[NewIdx];
		NewViewerInfo.StreamingSourceName = StreamingSourceName;
		NewViewerInfo.Handle.Index = NewIdx;
		NewViewerInfo.Handle.SerialNumber = GetNextViewerSerialNumber();
		NewViewerInfo.HashValue = HashValue;

		ViewerHandle = NewViewerInfo.Handle;

		OnViewerAddedDelegate.Broadcast(NewViewerInfo);
	}
}

void UMassLODSubsystem::AddActorViewer(AActor& ActorViewer)
{
	// @todo we might need to use PathName instead 
	const int32 HashValue = GetTypeHash(ActorViewer.GetFName());

	FMassViewerHandle& ViewerHandle = ViewerMap.FindOrAdd(HashValue, FMassViewerHandle());
	if (ViewerHandle.IsValid())
	{
		// We are only interested to set the player controller if it was not already set.
		const int32 ViewerHandleIdx = GetValidViewerIdx(ViewerHandle);
		check(ViewerHandleIdx != INDEX_NONE);

		FViewerInfo& ViewerInfo = Viewers[ViewerHandleIdx];
		ViewerInfo.ActorViewer = &ActorViewer;
	}
	else
	{
		// Add new viewer
		const bool bAddNew = ViewerFreeIndices.Num() == 0;
		const int NewIdx = bAddNew ? Viewers.Num() : ViewerFreeIndices.Pop();

		FViewerInfo& NewViewerInfo = bAddNew ? Viewers.AddDefaulted_GetRef() : Viewers[NewIdx];
		NewViewerInfo.ActorViewer = &ActorViewer;
		NewViewerInfo.Handle.Index = NewIdx;
		NewViewerInfo.Handle.SerialNumber = GetNextViewerSerialNumber();
		NewViewerInfo.HashValue = HashValue;
		ViewerHandle = NewViewerInfo.Handle;

		OnViewerAddedDelegate.Broadcast(NewViewerInfo);
	}
}

#if WITH_EDITOR
void UMassLODSubsystem::AddEditorViewer(const int32 HashValue, const int32 ClientIndex)
{
	FMassViewerHandle& ViewerHandle = ViewerMap.FindOrAdd(HashValue, FMassViewerHandle());
	// only add new viewer if it hasn't been added yet
	if (ViewerHandle.IsValid() == false)
	{
		const bool bAddNew = ViewerFreeIndices.Num() == 0;
		const int NewIdx = bAddNew ? Viewers.Num() : ViewerFreeIndices.Pop();
		FViewerInfo& NewViewerInfo = bAddNew ? Viewers.AddDefaulted_GetRef() : Viewers[NewIdx];

		using ClientIndexType = decltype(NewViewerInfo.EditorViewportClientIndex);
		check(ClientIndex >= std::numeric_limits<ClientIndexType>::min() && ClientIndex <= std::numeric_limits<ClientIndexType>::max());
		NewViewerInfo.EditorViewportClientIndex = static_cast<ClientIndexType>(ClientIndex);
		NewViewerInfo.Handle.Index = NewIdx;
		NewViewerInfo.Handle.SerialNumber = GetNextViewerSerialNumber();
		NewViewerInfo.HashValue = HashValue;

		ViewerHandle = NewViewerInfo.Handle;

		OnViewerAddedDelegate.Broadcast(NewViewerInfo);
	}
}
#endif // WITH_EDITOR

void UMassLODSubsystem::RemoveViewer(const FMassViewerHandle& ViewerHandle)
{
#if UE_ALLOW_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER

	const int32 ViewerHandleIdx = GetValidViewerIdx(ViewerHandle);
	check(ViewerHandleIdx != INDEX_NONE);

	//find all the viewer handles the slow way and remove them
	for (int32 ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)
	{
		FViewerInfo& ViewerInfo = Viewers[ViewerIdx];

		if (ViewerInfo.PlayerController == Viewers[ViewerHandleIdx].PlayerController)
		{
			RemoveViewerInternal(ViewerInfo.Handle);
		}
	}

#else

	RemoveViewerInternal(ViewerHandle);

#endif //UE_ALLOW_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER
}

void UMassLODSubsystem::RemoveViewerInternal(const FMassViewerHandle& ViewerHandle)
{
	const int32 ViewerIdx = GetValidViewerIdx(ViewerHandle);
	check(ViewerIdx != INDEX_NONE);
	FViewerInfo& ViewerInfo = Viewers[ViewerIdx];

	OnViewerRemovedDelegate.Broadcast(ViewerInfo);

	if (APlayerController* ViewerAsPlayerController = ViewerInfo.GetPlayerController())
	{
		ViewerAsPlayerController->OnEndPlay.RemoveDynamic(this, &UMassLODSubsystem::OnPlayerControllerEndPlay);
	}

	ViewerMap.Remove(ViewerInfo.HashValue);

	ViewerInfo.Reset();
	ViewerFreeIndices.Push(ViewerIdx);
}

void UMassLODSubsystem::OnPlayerControllerEndPlay(AActor* Actor, EEndPlayReason::Type EndPlayReason)
{
	APlayerController* PlayerController = Cast<APlayerController>(Actor);
	if (ensure(PlayerController))
	{
		const FMassViewerHandle ViewerHandle = GetViewerHandleFromActor(*PlayerController);
		if (ensure(ViewerHandle.IsValid()))
		{
			RemoveViewer(ViewerHandle);
		}
	}
}

void UMassLODSubsystem::RegisterActorViewer(AActor& ActorViewer)
{
	RegisteredActorViewers.AddUnique(&ActorViewer);
}

void UMassLODSubsystem::UnregisterActorViewer(AActor& ActorViewer)
{
	if (RegisteredActorViewers.RemoveSingleSwap(&ActorViewer, EAllowShrinking::No))
	{
		const FMassViewerHandle ViewerHandle = GetViewerHandleFromActor(ActorViewer);
		if (ensure(ViewerHandle.IsValid()))
		{
			RemoveViewer(ViewerHandle);
		}
	}
}

FMassViewerHandle UMassLODSubsystem::GetViewerHandleFromPlayerController(const APlayerController* PlayerController) const
{
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	return PlayerController ? GetViewerHandleFromActor(*PlayerController) : FMassViewerHandle();
	PRAGMA_ENABLE_DEPRECATION_WARNINGS
}

#if WITH_MASSGAMEPLAY_DEBUG
void UMassLODSubsystem::DebugUnregisterActorViewer()
{
	for (const TObjectPtr<AActor>& RegisteredActorViewer : RegisteredActorViewers)
	{
		if (const AActor* ActorViewer = RegisteredActorViewer)
		{
			const FMassViewerHandle ViewerHandle = GetViewerHandleFromActor(*ActorViewer);
			if (ensure(ViewerHandle.IsValid()))
			{
				RemoveViewer(ViewerHandle);
			}
		}
	}
	RegisteredActorViewers.Reset();
}
#endif // WITH_MASSGAMEPLAY_DEBUG

//-----------------------------------------------------------------------------
// FViewerInfo
//-----------------------------------------------------------------------------
void FViewerInfo::Reset()
{
	Handle.Invalidate();
	ActorViewer = nullptr;
#if WITH_EDITOR
	EditorViewportClientIndex = INDEX_NONE;
#endif // WITH_EDITOR
	HashValue = 0;
}

bool FViewerInfo::IsLocal() const
{
	APlayerController* ViewerAsPlayerController = GetPlayerController();
	return (ViewerAsPlayerController && ViewerAsPlayerController->IsLocalController()) || !StreamingSourceName.IsNone()
#if WITH_EDITOR
		|| EditorViewportClientIndex != INDEX_NONE
#endif // WITH_EDITOR
		;
}

APlayerController* FViewerInfo::GetPlayerController() const
{
	return Cast<APlayerController>(ActorViewer.Get());
}

===================================================


=== Source/MassLOD/Private/MassLODTrait.cpp ===
===============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassLODTrait.h"
#include "MassEntityTemplateRegistry.h"
#include "Engine/World.h"
#include "MassCommonFragments.h"
#include "MassLODFragments.h"
#include "MassEntityUtils.h"


//-----------------------------------------------------------------------------
// UMassLODCollectorTrait
//-----------------------------------------------------------------------------
void UMassLODCollectorTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	BuildContext.AddFragment<FMassViewerInfoFragment>();
	BuildContext.AddTag<FMassCollectLODViewerInfoTag>();
	BuildContext.RequireFragment<FTransformFragment>();
}

//-----------------------------------------------------------------------------
// UMassDistanceLODCollectorTrait
//-----------------------------------------------------------------------------
void UMassDistanceLODCollectorTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	BuildContext.AddFragment<FMassViewerInfoFragment>();
	BuildContext.AddTag<FMassCollectDistanceLODViewerInfoTag>();
	BuildContext.RequireFragment<FTransformFragment>();
}

//-----------------------------------------------------------------------------
// UMassSimulationLODTrait
//-----------------------------------------------------------------------------
void UMassSimulationLODTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	BuildContext.RequireFragment<FMassViewerInfoFragment>();
	BuildContext.RequireFragment<FTransformFragment>();

	FMassSimulationLODFragment& LODFragment = BuildContext.AddFragment_GetRef<FMassSimulationLODFragment>();

	// Start all simulation LOD in the Off 
	if (Params.bSetLODTags || bEnableVariableTicking || BuildContext.IsInspectingData())
	{
		LODFragment.LOD = EMassLOD::Off;
		BuildContext.AddTag<FMassOffLODTag>();
	}

	FMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(World);

	FConstSharedStruct ParamsFragment = EntityManager.GetOrCreateConstSharedFragment(Params);
	BuildContext.AddConstSharedFragment(ParamsFragment);

	FSharedStruct SharedFragment = EntityManager.GetOrCreateSharedFragment<FMassSimulationLODSharedFragment>(FConstStructView::Make(Params), Params);
	BuildContext.AddSharedFragment(SharedFragment);

	// Variable ticking from simulation LOD
	if (bEnableVariableTicking || BuildContext.IsInspectingData())
	{
		BuildContext.AddFragment<FMassSimulationVariableTickFragment>();
		BuildContext.AddChunkFragment<FMassSimulationVariableTickChunkFragment>();

		FConstSharedStruct VariableTickParamsFragment = EntityManager.GetOrCreateConstSharedFragment(VariableTickParams);
		BuildContext.AddConstSharedFragment(VariableTickParamsFragment);

		FSharedStruct VariableTickSharedFragment = EntityManager.GetOrCreateSharedFragment<FMassSimulationVariableTickSharedFragment>(FConstStructView::Make(VariableTickParams), VariableTickParams);
		BuildContext.AddSharedFragment(VariableTickSharedFragment);
	}
}

===============================================


=== Source/MassLOD/Private/MassLODUtils.cpp ===
===============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassLODUtils.h"
#include "MassCommandBuffer.h"
#include "HAL/IConsoleManager.h"

DEFINE_LOG_CATEGORY(LogMassLOD);
#if WITH_MASSGAMEPLAY_DEBUG
namespace UE::MassLOD::Debug
{
	bool bLODCalculationsPaused = false;
	
	FAutoConsoleVariableRef CVarLODPause(TEXT("mass.lod.pause"), bLODCalculationsPaused, TEXT("If non zero will pause all LOD calculations"));
} // UE::MassLOD::Debug
#endif // WITH_MASSGAMEPLAY_DEBUG

namespace UE::MassLOD
{
void PushSwapTagsCommand(FMassCommandBuffer& CommandBuffer, const FMassEntityHandle Entity, const EMassLOD::Type PrevLOD, const EMassLOD::Type NewLOD)
{
#define CASE_SWAP_TAGS(OldLOD, NewLOD) \
case NewLOD: \
	CommandBuffer.SwapTags<TMassLODTagForLevel<OldLOD>::FTag, TMassLODTagForLevel<NewLOD>::FTag>(Entity); \
	break

#define CASE_ADD_TAG(NewLOD) \
case NewLOD: \
	CommandBuffer.AddTag<TMassLODTagForLevel<NewLOD>::FTag>(Entity); \
	break

#define DEFAULT_REMOVE_TAG(OldLOD) \
case EMassLOD::Max: /* fall through on purpose */ \
default: \
	CommandBuffer.RemoveTag<TMassLODTagForLevel<OldLOD>::FTag>(Entity); \
	break

	check(PrevLOD != NewLOD);

	switch (PrevLOD)
	{
	case EMassLOD::High:
		switch (NewLOD)
		{
			CASE_SWAP_TAGS(EMassLOD::High, EMassLOD::Medium);
			CASE_SWAP_TAGS(EMassLOD::High, EMassLOD::Low);
			CASE_SWAP_TAGS(EMassLOD::High, EMassLOD::Off);
			DEFAULT_REMOVE_TAG(EMassLOD::High);
		}
		break;
	case EMassLOD::Medium:
		switch (NewLOD)
		{
			CASE_SWAP_TAGS(EMassLOD::Medium, EMassLOD::High);
			CASE_SWAP_TAGS(EMassLOD::Medium, EMassLOD::Low);
			CASE_SWAP_TAGS(EMassLOD::Medium, EMassLOD::Off);
			DEFAULT_REMOVE_TAG(EMassLOD::Medium);
		}
		break;
	case EMassLOD::Low:
		switch (NewLOD)
		{
			CASE_SWAP_TAGS(EMassLOD::Low, EMassLOD::High);
			CASE_SWAP_TAGS(EMassLOD::Low, EMassLOD::Medium);
			CASE_SWAP_TAGS(EMassLOD::Low, EMassLOD::Off);
			DEFAULT_REMOVE_TAG(EMassLOD::Low);
		}
		break;
	case EMassLOD::Off:
		switch (NewLOD)
		{
			CASE_SWAP_TAGS(EMassLOD::Off, EMassLOD::High);
			CASE_SWAP_TAGS(EMassLOD::Off, EMassLOD::Medium);
			CASE_SWAP_TAGS(EMassLOD::Off, EMassLOD::Low);
			DEFAULT_REMOVE_TAG(EMassLOD::Off);
		}
		break;
	case EMassLOD::Max:
		switch (NewLOD)
		{
			CASE_ADD_TAG(EMassLOD::High);
			CASE_ADD_TAG(EMassLOD::Medium);
			CASE_ADD_TAG(EMassLOD::Low);
			CASE_ADD_TAG(EMassLOD::Off);
			default:
				checkf(false, TEXT("Unsupported LOD types!"));
				break;
		}
		break;
	default:
		checkf(false, TEXT("Unsupported LOD type!"));
		break;
	}

#undef CASE_SWAP_TAGS
#undef DEFAULT_REMOVE_TAG
}
}
===============================================


=== Source/MassLOD/Private/MassSimulationLOD.cpp ===
====================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSimulationLOD.h"

#include "MassCommonFragments.h"
#include "MassExecutionContext.h"
#include "GameFramework/PlayerController.h"
#include "Engine/World.h"
#include "VisualLogger/VisualLogger.h"
#include "MassLODUtils.h"

//-----------------------------------------------------------------------------
// FMassSimulationLODParameters
//-----------------------------------------------------------------------------
FMassSimulationLODParameters::FMassSimulationLODParameters()
{
	LODDistance[EMassLOD::High] = 0.0f;
	LODDistance[EMassLOD::Medium] = 5000.0f;
	LODDistance[EMassLOD::Low] = 10000.0f;
	LODDistance[EMassLOD::Off] = 30000.0f;

	LODMaxCount[EMassLOD::High] = 100;
	LODMaxCount[EMassLOD::Medium] = 200;
	LODMaxCount[EMassLOD::Low] = 300;
	LODMaxCount[EMassLOD::Off] = INT_MAX;
}

//-----------------------------------------------------------------------------
// FMassSimulationVariableTickParameters
//-----------------------------------------------------------------------------
FMassSimulationVariableTickParameters::FMassSimulationVariableTickParameters()
{
	TickRates[EMassLOD::High] = 0.0f;
	TickRates[EMassLOD::Medium] = 0.5f;
	TickRates[EMassLOD::Low] = 1.0f;
	TickRates[EMassLOD::Off] = 1.5f;
}

//-----------------------------------------------------------------------------
// FMassSimulationLODSharedFragment
//-----------------------------------------------------------------------------
FMassSimulationLODSharedFragment::FMassSimulationLODSharedFragment(const FMassSimulationLODParameters& LODParams)
{
	LODCalculator.Initialize(LODParams.LODDistance, LODParams.BufferHysteresisOnDistancePercentage / 100.0f, LODParams.LODMaxCount);
}

//-----------------------------------------------------------------------------
// FMassSimulationLODSharedFragment
//-----------------------------------------------------------------------------
FMassSimulationVariableTickSharedFragment::FMassSimulationVariableTickSharedFragment(const FMassSimulationVariableTickParameters& TickRateParams)
{
	LODTickRateController.Initialize(TickRateParams.TickRates, TickRateParams.bSpreadFirstSimulationUpdate);
}

//-----------------------------------------------------------------------------
// UMassSimulationLODProcessor
//-----------------------------------------------------------------------------

namespace UE::MassLOD
{
	int32 bDebugSimulationLOD = 0;
	FAutoConsoleVariableRef CVarDebugSimulationLODTest(TEXT("mass.debug.SimulationLOD"), bDebugSimulationLOD, TEXT("Debug Simulation LOD"), ECVF_Cheat);
} // UE::MassLOD

UMassSimulationLODProcessor::UMassSimulationLODProcessor()
	: EntityQuery(*this)
	, EntityQueryCalculateLOD(*this)
	, EntityQueryAdjustDistances(*this)
	, EntityQueryVariableTick(*this)
	, EntityQuerySetLODTag(*this)
{
	ExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::LOD;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LODCollector);
}

void UMassSimulationLODProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassViewerInfoFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassSimulationLODFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddConstSharedRequirement<FMassSimulationLODParameters>();
	EntityQuery.AddSharedRequirement<FMassSimulationLODSharedFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddChunkRequirement<FMassSimulationVariableTickChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);
	EntityQuery.AddSharedRequirement<FMassSimulationVariableTickSharedFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);

	EntityQueryCalculateLOD = EntityQuery;
	EntityQueryCalculateLOD.SetChunkFilter(FMassSimulationVariableTickSharedFragment::ShouldCalculateLODForChunk);

	EntityQueryAdjustDistances = EntityQuery;
	EntityQueryAdjustDistances.SetChunkFilter([](const FMassExecutionContext& Context)
	{
		const FMassSimulationLODSharedFragment& LODSharedFragment = Context.GetSharedFragment<FMassSimulationLODSharedFragment>();
		return LODSharedFragment.bHasAdjustedDistancesFromCount && FMassSimulationVariableTickSharedFragment::ShouldAdjustLODFromCountForChunk(Context);
	});

	EntityQueryVariableTick.AddRequirement<FMassSimulationLODFragment>(EMassFragmentAccess::ReadOnly);
	EntityQueryVariableTick.AddRequirement<FMassSimulationVariableTickFragment>(EMassFragmentAccess::ReadWrite);
	EntityQueryVariableTick.AddConstSharedRequirement<FMassSimulationVariableTickParameters>();
	EntityQueryVariableTick.AddChunkRequirement<FMassSimulationVariableTickChunkFragment>(EMassFragmentAccess::ReadWrite);
	EntityQueryVariableTick.AddSharedRequirement<FMassSimulationVariableTickSharedFragment>(EMassFragmentAccess::ReadWrite);

	// In case where the variableTick isn't enabled, we might need to set LOD tags as if the users still wants them
	EntityQuerySetLODTag.AddRequirement<FMassSimulationLODFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuerySetLODTag.AddRequirement<FMassSimulationVariableTickFragment>(EMassFragmentAccess::ReadWrite, EMassFragmentPresence::None);
	EntityQuerySetLODTag.AddConstSharedRequirement<FMassSimulationLODParameters>();
	EntityQuerySetLODTag.SetChunkFilter([](const FMassExecutionContext& Context)
	{
		const FMassSimulationLODParameters& LODParams = Context.GetConstSharedFragment<FMassSimulationLODParameters>();
		return LODParams.bSetLODTags;
	});

	ProcessorRequirements.AddSubsystemRequirement<UMassLODSubsystem>(EMassFragmentAccess::ReadOnly);
}

void UMassSimulationLODProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(SimulationLOD)

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(PrepareExecution);

		const UMassLODSubsystem& LODSubsystem = Context.GetSubsystemChecked<UMassLODSubsystem>();
		const TArray<FViewerInfo>& Viewers = LODSubsystem.GetViewers();

		EntityManager.ForEachSharedFragment<FMassSimulationLODSharedFragment>([&Viewers](FMassSimulationLODSharedFragment& LODSharedFragment)
		{
			LODSharedFragment.LODCalculator.PrepareExecution(Viewers);
		});
	}

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(CalculateLOD);
		EntityQueryCalculateLOD.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)
		{
			FMassSimulationLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassSimulationLODSharedFragment>();
			TConstArrayView<FMassViewerInfoFragment> ViewersInfoList = Context.GetFragmentView<FMassViewerInfoFragment>();
			TArrayView<FMassSimulationLODFragment> SimulationLODFragments = Context.GetMutableFragmentView<FMassSimulationLODFragment>();
			LODSharedFragment.LODCalculator.CalculateLOD(Context, ViewersInfoList, SimulationLODFragments);
		});
	}

	if (bDoAdjustmentFromCount)
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(AdjustDistancesAndLODFromCount);
		EntityManager.ForEachSharedFragment<FMassSimulationLODSharedFragment>([](FMassSimulationLODSharedFragment& LODSharedFragment)
		{
			LODSharedFragment.bHasAdjustedDistancesFromCount = LODSharedFragment.LODCalculator.AdjustDistancesFromCount();
		});

		EntityQueryAdjustDistances.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)
		{
			FMassSimulationLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassSimulationLODSharedFragment>();
			TConstArrayView<FMassViewerInfoFragment> ViewersInfoList = Context.GetFragmentView<FMassViewerInfoFragment>();
			TArrayView<FMassSimulationLODFragment> SimulationLODFragments = Context.GetMutableFragmentView<FMassSimulationLODFragment>();
			LODSharedFragment.LODCalculator.AdjustLODFromCount(Context, ViewersInfoList, SimulationLODFragments);
		});
	}

	UWorld* World = EntityManager.GetWorld();
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(VariableTickRates)
		check(World);
		const double Time = World->GetTimeSeconds();
		EntityQueryVariableTick.ForEachEntityChunk(EntityManager, Context, [Time](FMassExecutionContext& Context)
		{
			FMassSimulationVariableTickSharedFragment& TickRateSharedFragment = Context.GetMutableSharedFragment<FMassSimulationVariableTickSharedFragment>();
			TConstArrayView<FMassSimulationLODFragment> SimulationLODFragments = Context.GetFragmentView<FMassSimulationLODFragment>();
			TArrayView<FMassSimulationVariableTickFragment> SimulationVariableTickFragments = Context.GetMutableFragmentView<FMassSimulationVariableTickFragment>();

			TickRateSharedFragment.LODTickRateController.UpdateTickRateFromLOD(Context, SimulationLODFragments, SimulationVariableTickFragments, Time);
		});
	}

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(SetLODTags)
		check(World);
		EntityQuerySetLODTag.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)
		{
			TConstArrayView<FMassSimulationLODFragment> SimulationLODFragments = Context.GetFragmentView<FMassSimulationLODFragment>();
			const int32 NumEntities = Context.GetNumEntities();
			for (int32 Index = 0; Index < NumEntities; ++Index)
			{
				const FMassSimulationLODFragment& EntityLOD = SimulationLODFragments[Index];
				if (EntityLOD.PrevLOD != EntityLOD.LOD)
				{
					const FMassEntityHandle Entity = Context.GetEntity(Index);
					UE::MassLOD::PushSwapTagsCommand(Context.Defer(), Entity, EntityLOD.PrevLOD, EntityLOD.LOD);
				}
			}
		});
	}

#if WITH_MASSGAMEPLAY_DEBUG
	// Optional debug display
	if (UE::MassLOD::bDebugSimulationLOD)
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(DebugDisplayLOD);
		EntityQuery.ForEachEntityChunk(EntityManager, Context, [World](FMassExecutionContext& Context)
		{
			FMassSimulationLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassSimulationLODSharedFragment>();
			TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
			TConstArrayView<FMassSimulationLODFragment> SimulationLODList = Context.GetFragmentView<FMassSimulationLODFragment>();
			LODSharedFragment.LODCalculator.DebugDisplayLOD(Context, SimulationLODList, LocationList, World);
		});
	}
#endif // WITH_MASSGAMEPLAY_DEBUG
}

====================================================


=== Source/MassLOD/Public/IMassLODModule.h ===
==============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleInterface.h"
#include "Modules/ModuleManager.h"


/**
 * The public interface to this module.  In most cases, this interface is only public to sibling modules 
 * within this plugin.
 */
class IMassLODModule : public IModuleInterface
{

public:

	/**
	 * Singleton-like access to this module's interface.  This is just for convenience!
	 * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.
	 *
	 * @return Returns singleton instance, loading the module on demand if needed
	 */
	static inline IMassLODModule& Get()
	{
		return FModuleManager::LoadModuleChecked<IMassLODModule>( "MassLOD" );
	}

	/**
	 * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.
	 *
	 * @return True if the module is loaded and ready to use
	 */
	static inline bool IsAvailable()
	{
		return FModuleManager::Get().IsModuleLoaded( "MassLOD" );
	}
};


==============================================


=== Source/MassLOD/Public/MassLODCalculator.h ===
=================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassLODLogic.h"
#include "MassLODUtils.h"
#include "DrawDebugHelpers.h"
#include "VisualLogger/VisualLogger.h"
/**
 * Helper struct to calculate LOD for each agent and maximize count per LOD
 *   Requires TViewerInfoFragment fragment collected by the TMassLODCollector.
 *   Stores information in TLODFragment fragment.
*/
template <typename FLODLogic = FLODDefaultLogic >
struct TMassLODCalculator : public FMassLODBaseLogic
{
	TMassLODCalculator()
		: FMassLODBaseLogic(/*bShouldBuildFrustumData=*/FLODLogic::bDoVisibilityLogic)
	{}

	/**
	 * Initializes the LOD calculator, needed to be called once at initialization time
	 * @Param InBaseLODDistance distances used to calculate LOD
	 * @Param InBufferHysteresisOnFOVRatio distance hysteresis used to calculate LOD
	 * @Param InLODMaxCount the maximum count for each LOD - Supports nullptr being passed in now and will put INT_MAX everywhere by default
	 * @Param InLODMaxCountPerViewer the maximum count for each LOD per viewer (Only when FLODLogic::bMaximizeCountPerViewer is enabled)
	 * @Param InVisibleDistanceToFrustum is the distance from the frustum to start considering this entity is visible (Only when FLODLogic::bDoVisibilityLogic is enabled)
	 * @Param InVisibleDistanceToFrustumHysteresis once visible, what extra distance the entity need to be before considered not visible anymore (Only when FLODLogic::bDoVisibilityLogic is enabled)
	 * @Param InVisibleLODDistance the maximum count for each LOD per viewer (Only when FLODLogic::bDoVisibilityLogic is enabled)
	 */
	void Initialize(const float InBaseLODDistance[EMassLOD::Max], 
					const float InBufferHysteresisOnDistanceRatio, 
					const int32 InLODMaxCount[EMassLOD::Max], 
					const int32 InLODMaxCountPerViewer[EMassLOD::Max] = nullptr,
					const float InVisibleDistanceToFrustum = 0.0f,
					const float InVisibleDistanceToFrustumHysteresis = 0.0f,
					const float InVisibleLODDistance[EMassLOD::Max] = nullptr);

	/**
	 * Prepares execution for the current frame, needed to be called before every execution
	 * @Param Viewers is the array of all the known viewers
	 */
	void PrepareExecution(TConstArrayView<FViewerInfo> Viewers);

	/**
	 * Calculate LOD, called for each entity chunks
	 * Use next method when FLODLogic::bStoreInfoPerViewer is enabled
	 * @Param Context of the chunk execution
	 * @Param ViewersInfoList is the source information fragment for LOD calculation
	 * @Param LODList is the fragment where calculation are stored
	 */
	template <typename TViewerInfoFragment,
			  typename TLODFragment,
			  bool bCalculateLocalViewers = FLODLogic::bLocalViewersOnly,
			  bool bCalculateVisibility = FLODLogic::bDoVisibilityLogic>
	FORCEINLINE void CalculateLOD(FMassExecutionContext& Context,
					  			  TConstArrayView<TViewerInfoFragment> ViewersInfoList,
					  			  TArrayView<TLODFragment> LODList)
	{
		CalculateLOD<TViewerInfoFragment,
			TLODFragment,
			/*TPerViewerInfoFragment*/void*,
			bCalculateLocalViewers,
			bCalculateVisibility,
			/*bCalculateLODPerViewer*/false,
			/*bCalculateVisibilityPerViewer*/false,
			/*bMaximizeCountPerViewer*/false>(Context, ViewersInfoList, LODList, TConstArrayView<void*>());
	}

	/**
	 * Calculate LOD, called for each entity chunks
	 * Use this version when FLODLogic::bStoreInfoPerViewer is enabled
	 * It calculates a LOD per viewer and needs information per viewer via PerViewerInfoList fragments
	 * @Param Context of the chunk execution
	 * @Param ViewersInfoList is the source information fragment for LOD calculation
	 * @Param LODList is the fragment where calculation are stored
	 * @Param PerViewerInfoList is the Per viewer source information
	 */
	template <typename TViewerInfoFragment,
			  typename TLODFragment,
			  typename TPerViewerInfoFragment,
			  bool bCalculateLocalViewers = FLODLogic::bLocalViewersOnly,
			  bool bCalculateVisibility = FLODLogic::bDoVisibilityLogic,
			  bool bCalculateLODPerViewer = FLODLogic::bCalculateLODPerViewer,
			  bool bCalculateVisibilityPerViewer = FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer,
			  bool bMaximizeCountPerViewer = FLODLogic::bMaximizeCountPerViewer>
	void CalculateLOD(FMassExecutionContext& Context,
					  TConstArrayView<TViewerInfoFragment> ViewersInfoList,
					  TArrayView<TLODFragment> LODList,
					  TConstArrayView<TPerViewerInfoFragment> PerViewerInfoList);

	/**
	 * Adjust LOD distances by clamping them to respect the maximum LOD count
	 * @Return true if any LOD distances clamping was done
	 */
	template <bool bCalculateVisibility = FLODLogic::bDoVisibilityLogic,
			  bool bCalculateVisibilityPerViewer = FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer,
			  bool bMaximizeCountPerViewer = FLODLogic::bMaximizeCountPerViewer>
	bool AdjustDistancesFromCount();

	/**
	 * Adjust LOD from newly adjusted distances, only needed to be called when AdjustDistancesFromCount return true, called for each entity chunks
	 * Use next method when FLODLogic::bStoreInfoPerViewer is enabled
	 * @Param Context of the chunk execution
	 * @Param ViewersInfoList is the source information fragment for LOD calculation
	 * @Param LODList is the fragment where calculation are stored
	 */
	template <typename TViewerInfoFragment, 
			  typename TLODFragment,
			  bool bCalculateLocalViewers = FLODLogic::bLocalViewersOnly,
			  bool bCalculateVisibility = FLODLogic::bDoVisibilityLogic>
	FORCEINLINE void AdjustLODFromCount(FMassExecutionContext& Context,
										TConstArrayView<TViewerInfoFragment> ViewersInfoList,
										TArrayView<TLODFragment> LODList)
	{
		AdjustLODFromCount<TViewerInfoFragment,
			TLODFragment,
			/*TPerViewerInfoFragment*/void*,
			bCalculateLocalViewers,
			bCalculateVisibility,
			/*bCalculateLODPerViewer*/false,
			/*bCalculateVisibilityPerViewer*/false,
			/*bMaximizeCountPerViewer*/false>(Context, ViewersInfoList, LODList, TConstArrayView<void*>());
	}


	/**
	 * Adjust LOD from newly adjusted distances, only needed to be called when AdjustDistancesFromCount return true, called for each entity chunks
	 * Use this version when FLODLogic::bStoreInfoPerViewer is enabled
	 * It calculates a LOD per viewer and needs information per viewer via PerViewerInfoList fragments
	 * @Param Context of the chunk execution
	 * @Param ViewersInfoList is the source information fragment for LOD calculation
	 * @Param LODList is the fragment where calculation are stored
	 * @Param PerViewerInfoList is the Per viewer source information
	 */
	template <typename TViewerInfoFragment,
			  typename TLODFragment,
			  typename TPerViewerInfoFragment,
			  bool bCalculateLocalViewers = FLODLogic::bLocalViewersOnly,
			  bool bCalculateVisibility = FLODLogic::bDoVisibilityLogic,
			  bool bCalculateLODPerViewer = FLODLogic::bCalculateLODPerViewer,
			  bool bCalculateVisibilityPerViewer = FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer,
			  bool bMaximizeCountPerViewer = FLODLogic::bMaximizeCountPerViewer>
	void AdjustLODFromCount(FMassExecutionContext& Context,
							TConstArrayView<TViewerInfoFragment> ViewersInfoList,
							TArrayView<TLODFragment> LODList,
							TConstArrayView<TPerViewerInfoFragment> PerViewerInfoList);

	/**
	 * Turn Off all LOD, called for each entity chunks
	 * @Param Context of the chunk execution
	 * @Param LODList is the fragment where calculation are stored
	 */
	template <typename TLODFragment>
	void ForceOffLOD(FMassExecutionContext& Context, TArrayView<TLODFragment> LODList);

#if WITH_MASSGAMEPLAY_DEBUG
	/**
	 * Debug draw the current state of each agent as a color coded square
	 * @Param Context of the chunk execution
	 * @Param LODList is the fragment where calculation are stored
	 * @Param LocationList is the fragment transforms of the entities
	 * @Param World where the debug display should be drawn
	 */
	template <typename TLODFragment, typename TTransformFragment>
	void DebugDisplayLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TConstArrayView<TTransformFragment> LocationList, UWorld* World);

	/**
	 * Debug draw the current state of each agent as a color coded square, within MaxLODSignificance range
	 * @Param Context of the chunk execution
	 * @Param LODList is the fragment where calculation are stored
	 * @Param LocationList is the fragment transforms of the entities
	 * @Param World where the debug display should be drawn
	 * @Param MaxLODSignificance is the max allowed value of LODList[i].LODSignificance for an agent's state to debug draw
	 */
	template <typename TLODFragment, typename TTransformFragment>
	void DebugDisplaySignificantLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TConstArrayView<TTransformFragment> LocationList, UWorld* World, float MaxLODSignificance);

	/**
	 * Add Visual Log entries for the current state of each agent as a color coded location
	 * @Param Context of the chunk execution
	 * @Param LODList is the fragment where calculation are stored
	 * @Param LocationList is the fragment transforms of the entities
	 * @Param World where the debug display should be drawn
	 */
	template <typename TLODFragment, typename TTransformFragment>
	void VisLogLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TConstArrayView<TTransformFragment> LocationList, UObject* LogOwner);

	/**
	 * Add Visual Log entries for the current state of each agent as a color coded location, within MaxLODSignificance range
	 * @Param Context of the chunk execution
	 * @Param LODList is the fragment where calculation are stored
	 * @Param LocationList is the fragment transforms of the entities
	 * @Param World where the debug display should be drawn
	 * @Param MaxLODSignificance is the max allowed value of LODList[i].LODSignificance for an agent's state to vislog
	 */
	template <typename TLODFragment, typename TTransformFragment>
	void VisLogSignificantLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TConstArrayView<TTransformFragment> LocationList, UObject* LogOwner, float MaxLODSignificance);
#endif // WITH_MASSGAMEPLAY_DEBUG

	/**
	 * Return the maximum distance at which the LOD will be turn off
	 */
	 float GetMaxLODDistance() const { return MaxLODDistance; }

protected:

	struct FMassLODRuntimeData
	{
		/** Reset values to default */
		void Reset(const TStaticArray<float, EMassLOD::Max>& InBaseLODDistance, const TStaticArray<float, EMassLOD::Max>& InVisibleLODDistance)
		{
			// Reset the AdjustedLODDistances as they might have been changed by the max count calculation previous frame
			for (int32 LODDistIdx = 0; LODDistIdx < EMassLOD::Max; LODDistIdx++)
			{
				AdjustedBaseLODDistance[LODDistIdx] = InBaseLODDistance[LODDistIdx];
				AdjustedBaseLODDistanceSq[LODDistIdx] = FMath::Square(AdjustedBaseLODDistance[LODDistIdx]);
				if (FLODLogic::bDoVisibilityLogic)
				{
					AdjustedVisibleLODDistance[LODDistIdx] = InVisibleLODDistance[LODDistIdx];
					AdjustedVisibleLODDistanceSq[LODDistIdx] = FMath::Square(AdjustedVisibleLODDistance[LODDistIdx]);
				}
			}
			FMemory::Memzero(BaseBucketCounts);
			if (FLODLogic::bDoVisibilityLogic)
			{
				FMemory::Memzero(VisibleBucketCounts);
			}
		}

		/** Distance where each LOD becomes relevant (Squared and Normal) */
		TStaticArray<float, EMassLOD::Max> AdjustedBaseLODDistanceSq;
		TStaticArray<float, EMassLOD::Max> AdjustedVisibleLODDistanceSq;
		TStaticArray<float, EMassLOD::Max> AdjustedBaseLODDistance;
		TStaticArray<float, EMassLOD::Max> AdjustedVisibleLODDistance;

		/** Count of entities in each subdivision */
		TStaticArray< TStaticArray<int32, UE::MassLOD::MaxBucketsPerLOD>, EMassLOD::Max > BaseBucketCounts;
		TStaticArray< TStaticArray<int32, UE::MassLOD::MaxBucketsPerLOD>, EMassLOD::Max > VisibleBucketCounts;

#if WITH_MASSGAMEPLAY_DEBUG
		/* Last calculation count per LOD */
		TStaticArray<int32, EMassLOD::Max> LastCalculatedLODCount;
#endif // WITH_MASSGAMEPLAY_DEBUG
	};


	template <bool bCalculateVisibility, bool bCalculateLODSignificance>
	float AccumulateCountInRuntimeData(const EMassLOD::Type LOD, const float ViewerDistanceSq, const bool bIsVisible, FMassLODRuntimeData& Data) const;

	template <bool bCalculateVisibility>
	bool AdjustDistancesFromCountForRuntimeData(const TStaticArray<int32, EMassLOD::Max>& MaxCount, FMassLODRuntimeData& RuntimeData) const;

	template<bool bCalculateVisibility>
	EMassLOD::Type ComputeLODFromSettings(const EMassLOD::Type PrevLOD, const float DistanceToViewerSq, const bool bIsVisible, bool* bIsInAVisibleRange, const FMassLODRuntimeData& Data) const;

	bool CalculateVisibility(const bool bWasVisible, const float DistanceToFrustum) const;

	/** LOD distances */
	TStaticArray<float, EMassLOD::Max> BaseLODDistance;
	TStaticArray<float, EMassLOD::Max> VisibleLODDistance;

	/** MaxCount total */
	TStaticArray<int32, EMassLOD::Max> LODMaxCount;

	/** MaxCount total per viewers*/
	TStaticArray<int32, EMassLOD::Max> LODMaxCountPerViewer;

	/** Ratio for Buffer Distance Hysteresis */
	float BufferHysteresisOnDistanceRatio = 0.1f;

	/** How far away from frustum does this entities are considered visible */
	float VisibleDistanceToFrustum = 0.0f;

	/** Once visible how much further than distance to frustum does the entities need to be before being consider not visible */
	float VisibleDistanceToFrustumWithHysteresis = 0.0f;

	/** The size of each subdivision per LOD (LOD Size/MaxBucketsPerLOD) */
	TStaticArray<float, EMassLOD::Max> BaseBucketSize;
	TStaticArray<float, EMassLOD::Max> VisibleBucketSize;

	/** Maximum LOD Distance  */
	float MaxLODDistance = 0.0f;

	/** Runtime data for LOD calculation */
	FMassLODRuntimeData RuntimeData;

	/** Runtime data for each viewer specific LOD calculation, used only when bMaximizeCountPerViewer is true */
	TArray<FMassLODRuntimeData> RuntimeDataPerViewer;
};

template <typename FLODLogic>
void TMassLODCalculator<FLODLogic>::Initialize(const float InBaseLODDistance[EMassLOD::Max],
											   const float InBufferHysteresisOnDistanceRatio,
											   const int32 InLODMaxCount[EMassLOD::Max],
											   const int32 InLODMaxCountPerViewer[EMassLOD::Max] /*= nullptr*/,
											   const float InVisibleDistanceToFrustum /*= 0.0f*/,
											   const float InVisibleDistanceToFrustumHysteresis /*= 0.0f*/,
											   const float InVisibleLODDistance[EMassLOD::Max] /*= nullptr*/ )
{
	static_assert(!FLODLogic::bCalculateLODPerViewer || FLODLogic::bStoreInfoPerViewer, "Need to enable store info per viewer to be able to calculate LOD per viewer");
	static_assert(!FLODLogic::bMaximizeCountPerViewer || FLODLogic::bCalculateLODPerViewer, "Need to enable CalculatedLODPerviewer in order to maximize count per viewer");

	checkf(FLODLogic::bMaximizeCountPerViewer == (InLODMaxCountPerViewer != nullptr), TEXT("Missmatched between expected parameter InLODMaxCountPerViewer and LOD logic trait bMaximizeCountPerViewer."));
	checkf(FLODLogic::bDoVisibilityLogic == (InVisibleLODDistance != nullptr), TEXT("Missmatched between expected parameter InVisibleLODDistance and LOD logic trait bDoVisibilityLogic."));

	// Make a copy of all the settings
	for (int x = 0; x < EMassLOD::Max; x++)
	{
		BaseLODDistance[x] = InBaseLODDistance[x];
		
		// @todo Treat InLODMaxCount as a possible nullptr by default for this Initialize function, would need to come as an option from FLODLogic as well
		LODMaxCount[x] = (InLODMaxCount != nullptr) ? InLODMaxCount[x] : INT_MAX;
		if (FLODLogic::bDoVisibilityLogic && InVisibleLODDistance)
		{
			VisibleLODDistance[x] = InVisibleLODDistance[x];
		}
		if (FLODLogic::bMaximizeCountPerViewer && InLODMaxCountPerViewer)
		{
			LODMaxCountPerViewer[x] = InLODMaxCountPerViewer[x];
		}
	}

	// Some values should always be constant
	BaseLODDistance[EMassLOD::High] = 0.0f;
	BaseBucketSize[EMassLOD::Off] = FLT_MAX;
	VisibleLODDistance[EMassLOD::High] = 0.0f;
	VisibleBucketSize[EMassLOD::Off] = FLT_MAX;
	LODMaxCount[EMassLOD::Off] = INT_MAX;
	LODMaxCountPerViewer[EMassLOD::Off] = INT_MAX;
	BufferHysteresisOnDistanceRatio = InBufferHysteresisOnDistanceRatio;

	// Calculate the size for each LOD buckets
	float BasePrevLODDistance = BaseLODDistance[0];
	float VisiblePrevLODDistance = VisibleLODDistance[0];
	for (int32 LODDistIdx = 1; LODDistIdx < EMassLOD::Max; LODDistIdx++)
	{
		BaseBucketSize[LODDistIdx - 1] = (BaseLODDistance[LODDistIdx] - BasePrevLODDistance) / UE::MassLOD::MaxBucketsPerLOD;
		BasePrevLODDistance = BaseLODDistance[LODDistIdx];

		if (FLODLogic::bDoVisibilityLogic)
		{
			VisibleBucketSize[LODDistIdx - 1] = (VisibleLODDistance[LODDistIdx] - VisiblePrevLODDistance) / UE::MassLOD::MaxBucketsPerLOD;
			VisiblePrevLODDistance = VisibleLODDistance[LODDistIdx];
		}
	}

	// Assuming that off is the farthest distance, calculate the max LOD distance
	MaxLODDistance = !FLODLogic::bDoVisibilityLogic || BaseLODDistance[EMassLOD::Off] >= VisibleLODDistance[EMassLOD::Off] ? BaseLODDistance[EMassLOD::Off] : VisibleLODDistance[EMassLOD::Off];

	// Distance to frustum settings
	VisibleDistanceToFrustum = InVisibleDistanceToFrustum;
	VisibleDistanceToFrustumWithHysteresis = InVisibleDistanceToFrustum + InVisibleDistanceToFrustumHysteresis;
}

template <typename FLODLogic>
bool TMassLODCalculator<FLODLogic>::CalculateVisibility(const bool bWasVisible, const float DistanceToFrustum) const
{
	return DistanceToFrustum < (bWasVisible ? VisibleDistanceToFrustumWithHysteresis : VisibleDistanceToFrustum);
}

template <typename FLODLogic>
void TMassLODCalculator<FLODLogic>::PrepareExecution(TConstArrayView<FViewerInfo> ViewersInfo)
{
	CacheViewerInformation(ViewersInfo);

	if (FLODLogic::bMaximizeCountPerViewer)
	{
		RuntimeDataPerViewer.SetNum(Viewers.Num());
		for (int ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)
		{
			// Reset viewer data
			if (Viewers[ViewerIdx].Handle.IsValid())
			{
				RuntimeDataPerViewer[ViewerIdx].Reset(BaseLODDistance, VisibleLODDistance);
			}
		}
	}

	RuntimeData.Reset(BaseLODDistance, VisibleLODDistance);
}


template <typename FLODLogic>
template <bool bCalculateVisibility, bool bCalculateLODSignificance>
float TMassLODCalculator<FLODLogic>::AccumulateCountInRuntimeData(const EMassLOD::Type LOD, const float ViewerDistanceSq, const bool bIsVisible, FMassLODRuntimeData& Data) const
{
	TStaticArray< TStaticArray<int32, UE::MassLOD::MaxBucketsPerLOD>, EMassLOD::Max>& BucketCounts = bCalculateVisibility && bIsVisible ? Data.VisibleBucketCounts : Data.BaseBucketCounts;

	// Cumulate LOD in buckets for Max LOD count calculation
	if (LOD == EMassLOD::Off)
	{
		// A single bucket for Off LOD
		BucketCounts[EMassLOD::Off][0]++;
		if (bCalculateLODSignificance)
		{
			return float(EMassLOD::Off);
		}
	}
	else
	{
		const TStaticArray<float, EMassLOD::Max>& BucketSize = bCalculateVisibility && bIsVisible ? VisibleBucketSize : BaseBucketSize;
		const TStaticArray<float, EMassLOD::Max>& AdjustedLODDistance = bCalculateVisibility && bIsVisible ? Data.AdjustedVisibleLODDistance : Data.AdjustedBaseLODDistance;

		const int32 LODDistIdx = (int32)LOD;

		// Need to clamp as the Sqrt is not precise enough and always end up with floating calculation errors
		const int32 BucketIdx = FMath::Clamp((int32)((FMath::Sqrt(ViewerDistanceSq) - AdjustedLODDistance[LODDistIdx]) / BucketSize[LODDistIdx]), 0, UE::MassLOD::MaxBucketsPerLOD - 1);
		BucketCounts[LODDistIdx][BucketIdx]++;

		if (bCalculateLODSignificance)
		{
			// Derive significance from LODDistIdx combined with BucketIdx
			const float PartialLODSignificance = float(BucketIdx) / float(UE::MassLOD::MaxBucketsPerLOD);
			return float(LODDistIdx) + PartialLODSignificance;
		}
	}
	return 0.0f;
}

template <typename FLODLogic>
template <typename TViewerInfoFragment, typename TLODFragment, typename TPerViewerInfoFragment,
		  bool bCalculateLocalViewers, bool bCalculateVisibility, bool bCalculateLODPerViewer, bool bCalculateVisibilityPerViewer,bool bMaximizeCountPerViewer>
void TMassLODCalculator<FLODLogic>::CalculateLOD(FMassExecutionContext& Context, 
												 TConstArrayView<TViewerInfoFragment> ViewersInfoList, 
												 TArrayView<TLODFragment> LODList, 
												 TConstArrayView<TPerViewerInfoFragment> PerViewerInfoList)
{
	static_assert(!bCalculateVisibility || FLODLogic::bDoVisibilityLogic, "FLODLogic must have bDoVisibilityLogic enabled to calculate visibility.");
	static_assert(!bCalculateLODPerViewer || FLODLogic::bCalculateLODPerViewer, "FLODLogic must have bCalculateLODPerViewer enabled to calculate LOD Per viewer.");
	static_assert(!bCalculateVisibilityPerViewer || (FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer), "FLODLogic must have bDoVisibilityLogic and bStoreInfoPerViewer enabled to calculate visibility per viewer.");
	static_assert(!bMaximizeCountPerViewer || FLODLogic::bMaximizeCountPerViewer, "FLODLogic must have bMaximizeCountPerViewer enabled to maximize count per viewer.");

#if WITH_MASSGAMEPLAY_DEBUG
	if (UE::MassLOD::Debug::bLODCalculationsPaused)
	{
		return;
	}
#endif // WITH_MASSGAMEPLAY_DEBUG

	const int32 NumEntities = Context.GetNumEntities();
	for (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
	{
		// Calculate the LOD purely upon distances
		const TViewerInfoFragment& EntityViewersInfo = ViewersInfoList[EntityIdx];
		TLODFragment& EntityLOD = LODList[EntityIdx];
		const float ClosestDistanceToFrustum = GetClosestDistanceToFrustum<bCalculateVisibility>(EntityViewersInfo, FLT_MAX);
		const EMassVisibility PrevVisibility = GetVisibility<bCalculateVisibility>(EntityLOD, EMassVisibility::Max);
		const bool bIsVisibleByAViewer = CalculateVisibility(PrevVisibility == EMassVisibility::CanBeSeen, ClosestDistanceToFrustum);
		bool bIsInAVisibleRange = false;

		// Find new LOD
		EntityLOD.PrevLOD = EntityLOD.LOD;
		EntityLOD.LOD = ComputeLODFromSettings<bCalculateVisibility>(EntityLOD.PrevLOD, EntityViewersInfo.ClosestViewerDistanceSq, bIsVisibleByAViewer, &bIsInAVisibleRange, RuntimeData);

		// Set visibility
		SetPrevVisibility<bCalculateVisibility>(EntityLOD, PrevVisibility);
		SetVisibility<bCalculateVisibility>(EntityLOD, bIsInAVisibleRange ? (bIsVisibleByAViewer ? EMassVisibility::CanBeSeen : EMassVisibility::CulledByFrustum) : EMassVisibility::CulledByDistance);

		// Accumulate in buckets
		const float LODSignificance = AccumulateCountInRuntimeData<bCalculateVisibility, FLODLogic::bCalculateLODSignificance>(EntityLOD.LOD, EntityViewersInfo.ClosestViewerDistanceSq, bIsVisibleByAViewer, RuntimeData);
		SetLODSignificance<FLODLogic::bCalculateLODSignificance>(EntityLOD, LODSignificance);

		// Do per viewer logic if asked for
		if (bCalculateLODPerViewer || bCalculateVisibilityPerViewer)
		{
			const TPerViewerInfoFragment& EntityPerViewerInfo = PerViewerInfoList[EntityIdx];

			SetLODPerViewerNum<bCalculateLODPerViewer>(EntityLOD, Viewers.Num());
			SetPrevLODPerViewerNum<bCalculateLODPerViewer>(EntityLOD, Viewers.Num());
			SetVisibilityPerViewerNum<bCalculateVisibilityPerViewer>(EntityLOD, Viewers.Num());
			SetPrevVisibilityPerViewerNum<bCalculateVisibilityPerViewer>(EntityLOD, Viewers.Num());

			for (int ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)
			{
				const FViewerLODInfo& Viewer = Viewers[ViewerIdx];
				if (Viewer.bClearData)
				{
					SetLODPerViewer<bCalculateLODPerViewer>(EntityLOD, ViewerIdx, EMassLOD::Max);
					SetPrevLODPerViewer<bCalculateLODPerViewer>(EntityLOD, ViewerIdx, EMassLOD::Max);
					SetPrevVisibilityPerViewer<bCalculateVisibilityPerViewer>(EntityLOD, ViewerIdx, EMassVisibility::Max);
					SetVisibilityPerViewer<bCalculateVisibilityPerViewer>(EntityLOD, ViewerIdx, EMassVisibility::Max);
				}

				// Check to see if we want only local viewer only
				if (bCalculateLocalViewers && !Viewer.bLocal)
				{
					continue;
				}

				if (Viewer.Handle.IsValid())
				{
					const float DistanceToFrustum = GetDistanceToFrustum<bCalculateVisibilityPerViewer>(EntityPerViewerInfo, ViewerIdx, FLT_MAX);
					const EMassVisibility PrevVisibilityPerViewer = GetVisibilityPerViewer<bCalculateVisibilityPerViewer>(EntityLOD, ViewerIdx, EMassVisibility::Max);
					const bool bIsVisibleByViewer = CalculateVisibility(PrevVisibilityPerViewer == EMassVisibility::CanBeSeen, DistanceToFrustum);
					bool bIsInVisibleRange = false;

					if (bCalculateLODPerViewer)
					{
						const float DistanceToViewerSq = GetDistanceToViewerSq<bCalculateLODPerViewer>(EntityPerViewerInfo, ViewerIdx, FLT_MAX);
						const EMassLOD::Type PrevLODPerViewer = GetLODPerViewer<bCalculateLODPerViewer>(EntityLOD, ViewerIdx, EntityLOD.LOD);

						// Find new LOD
						const EMassLOD::Type LODPerViewer = ComputeLODFromSettings<bCalculateVisibilityPerViewer>(PrevLODPerViewer, DistanceToViewerSq, bIsInVisibleRange, &bIsInAVisibleRange, RuntimeData);

						// Set Per viewer LOD
						SetPrevLODPerViewer<bCalculateLODPerViewer>(EntityLOD, ViewerIdx, PrevLODPerViewer);
						SetLODPerViewer<bCalculateLODPerViewer>(EntityLOD, ViewerIdx, LODPerViewer);

						if (bMaximizeCountPerViewer)
						{
							// Accumulate in buckets
							AccumulateCountInRuntimeData<bCalculateVisibilityPerViewer, false>(LODPerViewer, DistanceToViewerSq, bIsInVisibleRange, RuntimeDataPerViewer[ViewerIdx]);
						}
					}

					// Set visibility
					SetPrevVisibilityPerViewer<bCalculateVisibilityPerViewer>(EntityLOD, ViewerIdx, bIsInAVisibleRange ? (bIsVisibleByAViewer ? EMassVisibility::CanBeSeen : EMassVisibility::CulledByFrustum) : EMassVisibility::CulledByDistance);
					SetVisibilityPerViewer<bCalculateVisibilityPerViewer>(EntityLOD, ViewerIdx, PrevVisibilityPerViewer);
				}
			}
		}
	}
}

template <typename FLODLogic>
template <bool bCalculateVisibility>
bool TMassLODCalculator<FLODLogic>::AdjustDistancesFromCountForRuntimeData(const TStaticArray<int32, EMassLOD::Max>& MaxCount, FMassLODRuntimeData& Data) const
{
	int32 Count = 0;
	int32 ProcessingLODIdx = EMassLOD::High;

	bool bNeedAdjustments = false;

	// Go through all LOD can start counting from the high LOD
	for (int32 BucketLODIdx = 0; BucketLODIdx < EMassLOD::Max - 1; ++BucketLODIdx)
	{
		// Switch to next LOD if we have not reach the max
		if (ProcessingLODIdx < BucketLODIdx)
		{
#if WITH_MASSGAMEPLAY_DEBUG
			// Save the count of this LOD for this frame
			Data.LastCalculatedLODCount[ProcessingLODIdx] = Count;
#endif // WITH_MASSGAMEPLAY_DEBUG

			// Switch to next LOD
			ProcessingLODIdx = BucketLODIdx;

			// Restart the count
			Count = 0;
		}

		// Count entities through all buckets of this LOD
		for (int32 BucketIdx = 0; BucketIdx < UE::MassLOD::MaxBucketsPerLOD; ++BucketIdx)
		{
			if (bCalculateVisibility)
			{
				// Do visible count first to prioritize them over none visible for that bucket idx
				Count += Data.VisibleBucketCounts[BucketLODIdx][BucketIdx];

				while (Count > MaxCount[ProcessingLODIdx])
				{
#if WITH_MASSGAMEPLAY_DEBUG
					// Save the count of this LOD for this frame
					Data.LastCalculatedLODCount[ProcessingLODIdx] = Count - Data.VisibleBucketCounts[BucketLODIdx][BucketIdx];
#endif // WITH_MASSGAMEPLAY_DEBUG

					// Switch to next LOD
					ProcessingLODIdx++;

					// Adjust distance for this LOD
					Data.AdjustedBaseLODDistance[ProcessingLODIdx] = BaseLODDistance[BucketLODIdx] + (static_cast<float>(BucketIdx) * BaseBucketSize[BucketLODIdx]);
					Data.AdjustedBaseLODDistanceSq[ProcessingLODIdx] = FMath::Square(Data.AdjustedBaseLODDistance[ProcessingLODIdx]);
					Data.AdjustedVisibleLODDistance[ProcessingLODIdx] = VisibleLODDistance[BucketLODIdx] + (static_cast<float>(BucketIdx) * VisibleBucketSize[BucketLODIdx]);
					Data.AdjustedVisibleLODDistanceSq[ProcessingLODIdx] = FMath::Square(Data.AdjustedVisibleLODDistance[ProcessingLODIdx]);

					// Check if we are done
					if (ProcessingLODIdx == EMassLOD::Off)
					{
						return true;
					}

					// Start the next LOD count with the bucket count that made it go over
					Count = Data.VisibleBucketCounts[BucketLODIdx][BucketIdx];

					bNeedAdjustments = true;
				}
			}

			// Add base count
			Count += Data.BaseBucketCounts[BucketLODIdx][BucketIdx];

			// Check if the count is going over max
			while (Count > MaxCount[ProcessingLODIdx])
			{
#if WITH_MASSGAMEPLAY_DEBUG
				// Save the count of this LOD for this frame
				Data.LastCalculatedLODCount[ProcessingLODIdx] = Count - Data.BaseBucketCounts[BucketLODIdx][BucketIdx];
#endif // WITH_MASSGAMEPLAY_DEBUG

				// Switch to next LOD
				ProcessingLODIdx++;

				// Adjust distance for this LOD
				Data.AdjustedBaseLODDistance[ProcessingLODIdx] = BaseLODDistance[BucketLODIdx] + (static_cast<float>(BucketIdx) * BaseBucketSize[BucketLODIdx]);
				Data.AdjustedBaseLODDistanceSq[ProcessingLODIdx] = FMath::Square(Data.AdjustedBaseLODDistance[ProcessingLODIdx]);
				if (bCalculateVisibility)
				{
					Data.AdjustedVisibleLODDistance[ProcessingLODIdx] = VisibleLODDistance[BucketLODIdx] + (static_cast<float>(BucketIdx + 1) * VisibleBucketSize[BucketLODIdx]);
					Data.AdjustedVisibleLODDistanceSq[ProcessingLODIdx] = FMath::Square(Data.AdjustedVisibleLODDistance[ProcessingLODIdx]);
				}

				// Check if we are done
				if (ProcessingLODIdx == EMassLOD::Off)
				{
					return true;
				}

				// Start the next LOD count with the bucket count that made it go over
				Count = Data.BaseBucketCounts[BucketLODIdx][BucketIdx];

				bNeedAdjustments = true;
			}
		}
	}

#if WITH_MASSGAMEPLAY_DEBUG
	if (ProcessingLODIdx < EMassLOD::Max - 1)
	{
		// Save the count of this LOD for this frame
		Data.LastCalculatedLODCount[ProcessingLODIdx] = Count;
	}
#endif // WITH_MASSGAMEPLAY_DEBUG

	return bNeedAdjustments;
}


template <typename FLODLogic>
template <bool bCalculateVisibility, bool bCalculateVisibilityPerViewer, bool bMaximizeCountPerViewer>
bool TMassLODCalculator<FLODLogic>::AdjustDistancesFromCount()
{
	static_assert(!bCalculateVisibility || FLODLogic::bDoVisibilityLogic, "FLODLogic must have bDoVisibilityLogic enabled to calculate visibility.");
	static_assert(!bCalculateVisibilityPerViewer || (FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer), "FLODLogic must have bDoVisibilityLogic and bStoreInfoPerViewer enabled to calculate visibility per viewer.");
	static_assert(!bMaximizeCountPerViewer || FLODLogic::bMaximizeCountPerViewer, "FLODLogic must have bMaximizeCountPerViewer enabled to maximize count per viewer.");

	bool bDistanceAdjusted = false;
	if (bMaximizeCountPerViewer)
	{
		for (int ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)
		{
			if (!Viewers[ViewerIdx].Handle.IsValid())
			{
				continue;
			}

			bDistanceAdjusted |= AdjustDistancesFromCountForRuntimeData<bCalculateVisibilityPerViewer>(LODMaxCountPerViewer, RuntimeDataPerViewer[ViewerIdx]);
		}
	}

	bDistanceAdjusted |= AdjustDistancesFromCountForRuntimeData<bCalculateVisibility>(LODMaxCount, RuntimeData);
	return bDistanceAdjusted;
}

template <typename FLODLogic>
template <typename TViewerInfoFragment, typename TLODFragment, typename TPerViewerInfoFragment,
		  bool bCalculateLocalViewers, bool bCalculateVisibility, bool bCalculateLODPerViewer, bool bCalculateVisibilityPerViewer, bool bMaximizeCountPerViewer>
void TMassLODCalculator<FLODLogic>::AdjustLODFromCount(FMassExecutionContext& Context,
													   TConstArrayView<TViewerInfoFragment> ViewersInfoList,
													   TArrayView<TLODFragment> LODList,
													   TConstArrayView<TPerViewerInfoFragment> PerViewerInfoList)
{
	static_assert(!bCalculateVisibility || FLODLogic::bDoVisibilityLogic, "FLODLogic must have bDoVisibilityLogic enabled to calculate visibility.");
	static_assert(!bCalculateLODPerViewer || FLODLogic::bCalculateLODPerViewer, "FLODLogic must have bCalculateLODPerViewer enabled to calculate LOD Per viewer.");
	static_assert(!bCalculateVisibilityPerViewer || (FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer), "FLODLogic must have bDoVisibilityLogic and bStoreInfoPerViewer enabled to calculate visibility per viewer.");
	static_assert(!bMaximizeCountPerViewer || FLODLogic::bMaximizeCountPerViewer, "FLODLogic must have bMaximizeCountPerViewer enabled to maximize count per viewer.");

	const int32 NumEntities = Context.GetNumEntities();
	// Adjust LOD for each viewer and remember the new highest
	for (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
	{
		const TViewerInfoFragment& EntityViewersInfo = ViewersInfoList[EntityIdx];
		TLODFragment& EntityLOD = LODList[EntityIdx];
		EMassLOD::Type HighestViewerLOD = EMassLOD::Off;
		if (bMaximizeCountPerViewer)
		{
			const TPerViewerInfoFragment& EntityPerViewerInfo = PerViewerInfoList[EntityIdx];

			for (int ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)
			{
				const FViewerLODInfo& Viewer = Viewers[ViewerIdx];
				if (!Viewer.Handle.IsValid())
				{
					continue;
				}

				// Check to see if we want only local viewer only
				if (bCalculateLocalViewers && !Viewer.bLocal)
				{
					continue;
				}

				const float DistanceToViewerSq = GetDistanceToViewerSq<bMaximizeCountPerViewer>(EntityPerViewerInfo, ViewerIdx, FLT_MAX);
				// Using the prev visibility here as it was already updated for this frame in the CalculateLOD method and we want the previous one
				const bool bIsVisibleByViewer = GetPrevVisibilityPerViewer<bCalculateVisibilityPerViewer>(EntityLOD, ViewerIdx, EMassVisibility::Max) == EMassVisibility::CanBeSeen;
				EMassLOD::Type LODPerViewer = GetLODPerViewer<bCalculateLODPerViewer>(EntityLOD, ViewerIdx, EntityLOD.LOD);

				LODPerViewer = ComputeLODFromSettings<bCalculateVisibilityPerViewer>(LODPerViewer, DistanceToViewerSq, bIsVisibleByViewer, nullptr, RuntimeDataPerViewer[ViewerIdx]);

				if (LODPerViewer < HighestViewerLOD)
				{
					HighestViewerLOD = LODPerViewer;
				}

				SetLODPerViewer<bCalculateLODPerViewer>(EntityLOD, ViewerIdx, LODPerViewer);
			}
		}

		// Using the prev visibility here as it was already updated for this frame in the CalculateLOD method and we want the previous one
		const bool bIsVisibleByAViewer = GetPrevVisibility<bCalculateVisibility>(EntityLOD, EMassVisibility::Max) == EMassVisibility::CanBeSeen;
		EMassLOD::Type NewLOD = ComputeLODFromSettings<bCalculateVisibility>(EntityLOD.PrevLOD, EntityViewersInfo.ClosestViewerDistanceSq, bIsVisibleByAViewer, nullptr, RuntimeData);

		// Maybe the highest of all the viewers is now lower than the global entity LOD, make sure to update it accordingly
		if (bMaximizeCountPerViewer && NewLOD > HighestViewerLOD)
		{
			NewLOD = HighestViewerLOD;
		}
		if (EntityLOD.LOD != NewLOD)
		{
			EntityLOD.LOD = NewLOD;
			if (FLODLogic::bCalculateLODSignificance)
			{
				float LODSignificance = 0.f;
				if (NewLOD == EMassLOD::Off)
				{
					LODSignificance = float(EMassLOD::Off);
				}
				else
				{
					const TStaticArray<float, EMassLOD::Max>& AdjustedLODDistance = bCalculateVisibility && bIsVisibleByAViewer ? RuntimeData.AdjustedVisibleLODDistance : RuntimeData.AdjustedBaseLODDistance;

					// Need to clamp as the Sqrt is not precise enough and always end up with floating calculation errors
					const float DistanceBetweenLODThresholdAndEntity = FMath::Max(FMath::Sqrt(EntityViewersInfo.ClosestViewerDistanceSq) - AdjustedLODDistance[NewLOD], 0.f);

					// Derive significance from distance between viewer and where the agent stands between both LOD threshold
					const float AdjustedDistanceBetweenCurrentLODAndNext = AdjustedLODDistance[NewLOD + 1] - AdjustedLODDistance[NewLOD];
					const float PartialLODSignificance = DistanceBetweenLODThresholdAndEntity / AdjustedDistanceBetweenCurrentLODAndNext;
					LODSignificance = float(NewLOD) + PartialLODSignificance;
				}

				SetLODSignificance<FLODLogic::bCalculateLODSignificance>(EntityLOD, LODSignificance);
			}
		}
	}
}

template <typename FLODLogic>
template <typename TLODFragment>
void TMassLODCalculator<FLODLogic>::ForceOffLOD(FMassExecutionContext& Context, TArrayView<TLODFragment> LODList)
{
	const int32 NumEntities = Context.GetNumEntities();
	for (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
	{
		TLODFragment& EntityLOD = LODList[EntityIdx];

		// Force off LOD
		EntityLOD.PrevLOD = EntityLOD.LOD;
		EntityLOD.LOD = EMassLOD::Off;

		// Set visibility as not calculated
		SetPrevVisibility<FLODLogic::bDoVisibilityLogic>(EntityLOD, EMassVisibility::Max);
		SetVisibility<FLODLogic::bDoVisibilityLogic>(EntityLOD, EMassVisibility::Max);

		if (FLODLogic::bStoreInfoPerViewer)
		{
			for (int ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)
			{
				if (!Viewers[ViewerIdx].Handle.IsValid())
				{
					continue;
				}

				SetLODPerViewer<FLODLogic::bCalculateLODPerViewer>(EntityLOD, ViewerIdx, EMassLOD::Off);
				SetPrevLODPerViewer<FLODLogic::bCalculateLODPerViewer>(EntityLOD, ViewerIdx, EMassLOD::Off);
				SetPrevVisibilityPerViewer<FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer>(EntityLOD, ViewerIdx, EMassVisibility::Max);
				SetVisibilityPerViewer<FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer>(EntityLOD, ViewerIdx, EMassVisibility::Max);
			}
		}

		SetLODSignificance<FLODLogic::bCalculateLODSignificance>(EntityLOD, float(EMassLOD::Off));
	}
}

#if WITH_MASSGAMEPLAY_DEBUG
template <typename FLODLogic>
template <typename TLODFragment, typename TTransformFragment>
void TMassLODCalculator<FLODLogic>::DebugDisplayLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TConstArrayView<TTransformFragment> LocationList, UWorld* World)
{
	const int32 NumEntities = Context.GetNumEntities();
	for (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
	{
		const TTransformFragment& EntityLocation = LocationList[EntityIdx];
		const TLODFragment& EntityLOD = LODList[EntityIdx];
		int32 LODIdx = (int32)EntityLOD.LOD;
		DrawDebugSolidBox(World, EntityLocation.GetTransform().GetLocation() + FVector(0.0f, 0.0f, 120.0f), FVector(25.0f), UE::MassLOD::LODColors[LODIdx]);
	}
}

template <typename FLODLogic>
template <typename TLODFragment, typename TTransformFragment>
void TMassLODCalculator<FLODLogic>::DebugDisplaySignificantLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TConstArrayView<TTransformFragment> LocationList, UWorld* World, const float MaxLODSignificance)
{
	const int32 NumEntities = Context.GetNumEntities();
	for (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
	{
		const TLODFragment& EntityLOD = LODList[EntityIdx];
		if (EntityLOD.LODSignificance <= MaxLODSignificance)
		{
			const TTransformFragment& EntityLocation = LocationList[EntityIdx];
			int32 LODIdx = (int32)EntityLOD.LOD;
			DrawDebugSolidBox(World, EntityLocation.GetTransform().GetLocation() + FVector(0.0f, 0.0f, 120.0f), FVector(25.0f), UE::MassLOD::LODColors[LODIdx]);
		}
	}
}

template <typename FLODLogic>
template <typename TLODFragment, typename TTransformFragment>
void TMassLODCalculator<FLODLogic>::VisLogLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TConstArrayView<TTransformFragment> LocationList, UObject* LogOwner)
{
#if ENABLE_VISUAL_LOG
	const int32 NumEntities = Context.GetNumEntities();
	for (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
	{
		const TTransformFragment& EntityLocation = LocationList[EntityIdx];
		const TLODFragment& EntityLOD = LODList[EntityIdx];
		int32 LODIdx = (int32)EntityLOD.LOD;
		UE_VLOG_LOCATION(LogOwner, LogMassLOD, Verbose, EntityLocation.GetTransform().GetLocation(), 20.0f, UE::MassLOD::LODColors[LODIdx], TEXT("%s %d"), *Context.GetEntity(EntityIdx).DebugGetDescription(), LODIdx);
	}
#endif
}

template <typename FLODLogic>
template <typename TLODFragment, typename TTransformFragment>
void TMassLODCalculator<FLODLogic>::VisLogSignificantLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TConstArrayView<TTransformFragment> LocationList, UObject* LogOwner, const float MaxLODSignificance)
{
#if ENABLE_VISUAL_LOG
	const int32 NumEntities = Context.GetNumEntities();
	for (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
	{
		const TLODFragment& EntityLOD = LODList[EntityIdx];
		if (EntityLOD.LODSignificance <= MaxLODSignificance)
		{
			const TTransformFragment& EntityLocation = LocationList[EntityIdx];
			int32 LODIdx = (int32)EntityLOD.LOD;
			UE_VLOG_LOCATION(LogOwner, LogMassLOD, Verbose, EntityLocation.GetTransform().GetLocation(), 20, UE::MassLOD::LODColors[LODIdx], TEXT("%s %d"), *Context.GetEntity(EntityIdx).DebugGetDescription(), LODIdx);
		}
	}
#endif
}
#endif // WITH_MASSGAMEPLAY_DEBUG

template <typename FLODLogic>
template<bool bCalculateVisibility>
EMassLOD::Type TMassLODCalculator<FLODLogic>::ComputeLODFromSettings(const EMassLOD::Type PrevLOD, const float DistanceToViewerSq, const bool bIsVisible, bool* bIsInAVisibleRange, const FMassLODRuntimeData& Data) const
{
	const TStaticArray<float, EMassLOD::Max>& AdjustedLODDistanceSq = bCalculateVisibility && bIsVisible ? Data.AdjustedVisibleLODDistanceSq : Data.AdjustedBaseLODDistanceSq;
	int32 LODDistIdx = EMassLOD::Max - 1;
	for (; LODDistIdx > 0; LODDistIdx--)
	{
		if (DistanceToViewerSq >= AdjustedLODDistanceSq[LODDistIdx])
		{
			// Validate that we allow going to a single higher LOD level after considering an extended buffer hysteresis on distance for the LOD level we are about to quit to prevent oscillating LOD states
			if (PrevLOD != EMassLOD::Max && (PrevLOD - (EMassLOD::Type)LODDistIdx) == 1)
			{
				const TStaticArray<float, EMassLOD::Max>& AdjustedLODDistance = bCalculateVisibility && bIsVisible ? Data.AdjustedVisibleLODDistance : Data.AdjustedBaseLODDistance;
				float HysteresisDistance = FMath::Lerp(AdjustedLODDistance[LODDistIdx], AdjustedLODDistance[LODDistIdx + 1], 1.f - BufferHysteresisOnDistanceRatio);
				if (DistanceToViewerSq >= FMath::Square(HysteresisDistance))
				{
					// Keep old
					LODDistIdx = PrevLOD;
				}
			}

			break;
		}
	}

	EMassLOD::Type NewLOD = (EMassLOD::Type)LODDistIdx;
	if(bCalculateVisibility && bIsInAVisibleRange)
	{
		*bIsInAVisibleRange = bIsVisible ? (NewLOD != EMassLOD::Off) : (DistanceToViewerSq < Data.AdjustedVisibleLODDistanceSq[EMassLOD::Off]);
	}

	return NewLOD;
}
=================================================


=== Source/MassLOD/Public/MassLODCollector.h ===
================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassLODLogic.h"
#include "MassExecutionContext.h"
#include "DrawDebugHelpers.h"



/**
 * Helper struct to collect needed information on each agent that will be needed later for LOD calculation
 *   Requires TTransformFragment fragment.
 *   Stores information in TViewerInfoFragment fragment.
 */
template <typename FLODLogic = FLODDefaultLogic >
struct TMassLODCollector : public FMassLODBaseLogic
{
	TMassLODCollector()
		: FMassLODBaseLogic(/*bShouldBuildFrustumData=*/FLODLogic::bDoVisibilityLogic)
	{}

	/**
	 * Prepares execution for the current frame, needed to be called before every execution
	 * @Param Viewers is the array of all the known viewers
	 */
	void PrepareExecution(TConstArrayView<FViewerInfo> Viewers);

	/**
	 * Collects the information for LOD calculation, called for each entity chunks
	 * Use next method when FLODLogic::bStoreInfoPerViewer is enabled
	 * @Param Context of the chunk execution
	 * @Param TransformList is the fragment transforms of the entities
	 * @Param ViewersInfoList is the fragment where to store source information for LOD calculation
	 */
	template <typename TTransformFragment, 
			  typename TViewerInfoFragment,
			  bool bCollectLocalViewers = FLODLogic::bLocalViewersOnly,
			  bool bCollectDistanceToFrustum = FLODLogic::bDoVisibilityLogic>
	FORCEINLINE void CollectLODInfo(FMassExecutionContext& Context, 
									TConstArrayView<TTransformFragment> TransformList, 
									TArrayView<TViewerInfoFragment> ViewersInfoList)
	{
		CollectLODInfo<TTransformFragment,
			TViewerInfoFragment,
			/*TPerViewerInfoFragment*/void*,
			bCollectLocalViewers,
			bCollectDistanceToFrustum,
			/*bCollectDistancePerViewer*/false,
			/*bCollectDistanceToFrustumPerViewer*/false>(Context, TransformList, ViewersInfoList, TArrayView<void*>());
	}


	/**
	 * Collects the information for LOD calculation, called for each entity chunks
	 * Use this version when FLODLogic::bStoreInfoPerViewer is enabled
	 * It collects information per viewer into the PerViewerInfoList fragments
	 * @Param Context of the chunk execution
	 * @Param TransformList is the fragment transforms of the entities
	 * @Param ViewersInfoList is the fragment where to store source information for LOD calculation
	 * @Param PerViewerInfoList is the per viewer information
	 */
	template <typename TTransformFragment,
			  typename TViewerInfoFragment,
			  typename TPerViewerInfoFragment,
			  bool bCollectLocalViewers = FLODLogic::bLocalViewersOnly,
			  bool bCollectDistanceToFrustum = FLODLogic::bDoVisibilityLogic,
			  bool bCollectDistancePerViewer = FLODLogic::bStoreInfoPerViewer,
			  bool bCollectDistanceToFrustumPerViewer = FLODLogic::bDoVisibilityLogic && FLODLogic::bStoreInfoPerViewer>
	void CollectLODInfo(FMassExecutionContext& Context, 
						TConstArrayView<TTransformFragment> TransformList, 
						TArrayView<TViewerInfoFragment> ViewersInfoList, 
						TArrayView<TPerViewerInfoFragment> PerViewerInfoList);
};

template <typename FLODLogic>
void TMassLODCollector<FLODLogic>::PrepareExecution(TConstArrayView<FViewerInfo> ViewersInfo)
{
	CacheViewerInformation(ViewersInfo);
}

template <typename FLODLogic>
template <typename TTransformFragment, 
		  typename TViewerInfoFragment, 
		  typename TPerViewerInfoFragment,
		  bool bCollectLocalViewers,
		  bool bCollectDistanceToFrustum,
		  bool bCollectDistancePerViewer,
		  bool bCollectDistanceToFrustumPerViewer>
void TMassLODCollector<FLODLogic>::CollectLODInfo(FMassExecutionContext& Context, 
												  TConstArrayView<TTransformFragment> TransformList, 
												  TArrayView<TViewerInfoFragment> ViewersInfoList, 
												  TArrayView<TPerViewerInfoFragment> PerViewerInfoList)
{
	static TPerViewerInfoFragment DummyFragment;
	const int32 NumEntities = Context.GetNumEntities();
	for (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
	{
		float ClosestViewerDistanceSq = FLT_MAX;
		float ClosestDistanceToFrustum = FLT_MAX;
		const TTransformFragment& EntityTransform = TransformList[EntityIdx];
		TViewerInfoFragment& EntityViewerInfo = ViewersInfoList[EntityIdx];
		TPerViewerInfoFragment& EntityInfoPerViewer = FLODLogic::bStoreInfoPerViewer ? PerViewerInfoList[EntityIdx] : DummyFragment;

		SetDistanceToViewerSqNum<bCollectDistancePerViewer>(EntityInfoPerViewer, Viewers.Num());
		SetDistanceToFrustumNum<bCollectDistanceToFrustumPerViewer>(EntityInfoPerViewer, Viewers.Num());
		for (int ViewerIdx = 0; ViewerIdx < Viewers.Num(); ++ViewerIdx)
		{
			const FViewerLODInfo& Viewer = Viewers[ViewerIdx];
			if (Viewer.bClearData)
			{
				SetDistanceToViewerSq<bCollectDistancePerViewer>(EntityInfoPerViewer, ViewerIdx, FLT_MAX);
				SetDistanceToFrustum<bCollectDistanceToFrustumPerViewer>(EntityInfoPerViewer, ViewerIdx, FLT_MAX);
			}

			// Check to see if we want only local viewer only
			if (bCollectLocalViewers && !Viewer.bLocal)
			{
				continue;
			}

			if (Viewer.Handle.IsValid())
			{
				const FVector& EntityLocation = EntityTransform.GetTransform().GetLocation();
				const FVector ViewerToEntity = EntityLocation - Viewer.Location;
				const float DistanceToViewerSq = static_cast<float>(ViewerToEntity.SizeSquared()); // float precision is acceptable for LOD
				if (ClosestViewerDistanceSq > DistanceToViewerSq)
				{
					ClosestViewerDistanceSq = DistanceToViewerSq;
				}
				SetDistanceToViewerSq<bCollectDistancePerViewer>(EntityInfoPerViewer, ViewerIdx, DistanceToViewerSq);

				if constexpr (bCollectDistanceToFrustum)
				{
					const float DistanceToFrustum = Viewer.Frustum.DistanceTo(EntityLocation);
					SetDistanceToFrustum<bCollectDistanceToFrustumPerViewer>(EntityInfoPerViewer, ViewerIdx, DistanceToFrustum);
					if (ClosestDistanceToFrustum > DistanceToFrustum)
					{
						ClosestDistanceToFrustum = DistanceToFrustum;
					}
				}
			}
		}
		EntityViewerInfo.ClosestViewerDistanceSq = ClosestViewerDistanceSq;
		SetClosestDistanceToFrustum<bCollectDistanceToFrustum>(EntityViewerInfo, ClosestDistanceToFrustum);
	}
}
================================================


=== Source/MassLOD/Public/MassLODCollectorProcessor.h ===
=========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "MassProcessor.h"
#include "MassLODCollector.h"

#include "MassLODCollectorProcessor.generated.h"

struct FMassGenericCollectorLogic : public FLODDefaultLogic
{
	enum
	{
		bDoVisibilityLogic = true,
	};
};

/*
 * LOD collector which combines collection of LOD information for both Viewer and Simulation LODing when possible.
 */
UCLASS(meta = (DisplayName = "LOD Collector"))
class MASSLOD_API UMassLODCollectorProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassLODCollectorProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	template <bool bLocalViewersOnly>
	void CollectLODForChunk(FMassExecutionContext& Context);

	template <bool bLocalViewersOnly>
	void ExecuteInternal(FMassEntityManager& EntityManager, FMassExecutionContext& Context);

	TMassLODCollector<FMassGenericCollectorLogic> Collector;

	// Queries for visualization and simulation calculation
	/** All entities that are in visible range and are On LOD*/
	FMassEntityQuery EntityQuery_VisibleRangeAndOnLOD;
	/** All entities that are in visible range but are Off LOD */
	FMassEntityQuery EntityQuery_VisibleRangeOnly;
	/** All entities that are NOT in visible range but are On LOD */
	FMassEntityQuery EntityQuery_OnLODOnly;
	/** All entities that are Not in visible range and are at Off LOD */
	FMassEntityQuery EntityQuery_NotVisibleRangeAndOffLOD;
};

=========================================================


=== Source/MassLOD/Public/MassLODDistanceCollectorProcessor.h ===
=================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "MassProcessor.h"
#include "MassLODCollector.h"
#include "MassLODLogic.h"
#include "MassLODDistanceCollectorProcessor.generated.h"

/*
 * LOD Distance collector which combines collection of LOD information for both Viewer and Simulation LODing.
 * This collector cares only about the entities' distance to LOD viewer location, nothing else. 
 * Matches MassDistanceLODProcessor logic which uses the same Calculator LODLogic
 */
UCLASS(meta = (DisplayName = "LOD Distance Collector"))
class MASSLOD_API UMassLODDistanceCollectorProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassLODDistanceCollectorProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	template <bool bLocalViewersOnly>
	void CollectLODForChunk(FMassExecutionContext& Context);

	template <bool bLocalViewersOnly>
	void ExecuteInternal(FMassEntityManager& EntityManager, FMassExecutionContext& Context);

	TMassLODCollector<FMassDistanceLODLogic> Collector;

	// Queries for visualization and simulation calculation
	/** All entities that are in relevant range and are On LOD*/
	FMassEntityQuery EntityQuery_RelevantRangeAndOnLOD;
	/** All entities that are in relevant range but are Off LOD */
	FMassEntityQuery EntityQuery_RelevantRangeOnly;
	/** All entities that are NOT in relevant range but are On LOD */
	FMassEntityQuery EntityQuery_OnLODOnly;
	/** All entities that are Not in relevant range and are at Off LOD */
	FMassEntityQuery EntityQuery_NotRelevantRangeAndOffLOD;
};

=================================================================


=== Source/MassLOD/Public/MassLODFragments.h ===
================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassLODTypes.h"
#include "MassExecutionContext.h"
#include "MassLODFragments.generated.h"

USTRUCT()
struct MASSLOD_API FMassHighLODTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct MASSLOD_API FMassMediumLODTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct MASSLOD_API FMassLowLODTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct MASSLOD_API FMassOffLODTag : public FMassTag
{
	GENERATED_BODY()
};

/*
 * Data fragment to store the calculated distances to viewers
 */
USTRUCT()
struct MASSLOD_API FMassViewerInfoFragment : public FMassFragment
{
	GENERATED_BODY()

	// Closest viewer distance
	UPROPERTY()
	float ClosestViewerDistanceSq = FLT_MAX;

	// Closest distance to frustum
	UPROPERTY()
	float ClosestDistanceToFrustum = FLT_MAX;
};

USTRUCT()
struct MASSLOD_API FMassVariableTickChunkFragment : public FMassChunkFragment
{
	GENERATED_BODY();

	bool ShouldTickThisFrame() const
	{
		return bShouldTickThisFrame;
	}

	float GetTimeUntilNextTick() const
	{
		return TimeUntilNextTick;
	}

	int32 GetLastChunkSerialModificationNumber() const
	{
		return LastChunkSerialModificationNumber;
	}

	EMassLOD::Type GetLOD() const
	{
		return LOD;
	}

	void SetLOD(EMassLOD::Type InLOD)
	{
		checkf(LOD == EMassLOD::Max, TEXT("Chunk LOD should never change, it is allowed to only set it once"))
		LOD = InLOD;
	}

	void Update(const bool bInShouldTickThisFrame, const float InTimeUntilNextTick, int32 ChunkSerialModificationNumber)
	{
		bShouldTickThisFrame = bInShouldTickThisFrame;
		TimeUntilNextTick = InTimeUntilNextTick;
		LastChunkSerialModificationNumber = ChunkSerialModificationNumber;
	}

private:
	UPROPERTY()
	bool bShouldTickThisFrame = true;

	UPROPERTY()
	TEnumAsByte<EMassLOD::Type> LOD = EMassLOD::Max;

	UPROPERTY()
	float TimeUntilNextTick = 0.0f;

	UPROPERTY()
	int32 LastChunkSerialModificationNumber = INDEX_NONE;
};

USTRUCT()
struct FMassCollectLODViewerInfoTag : public FMassTag
{
	GENERATED_BODY();
};

/*
 * Tag to use to trigger the collector processor that uses the LODCollector without Visibility Logic, so strictly based of distance
 */
USTRUCT()
struct FMassCollectDistanceLODViewerInfoTag : public FMassTag
{
	GENERATED_BODY();
};

USTRUCT()
struct MASSLOD_API FMassVisibilityCanBeSeenTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct MASSLOD_API FMassVisibilityCulledByFrustumTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct MASSLOD_API FMassVisibilityCulledByDistanceTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct MASSLOD_API FMassVisualizationChunkFragment : public FMassChunkFragment
{
	GENERATED_BODY();

	/**
	 * Fetched existing chunk fragment to know if there is a possibility of a an entity that is visible
	 * In the case that there is not chunk information, we cannot assume that all entities are not visible.
	 *
	 * @param Context of the execution from the entity sub system
	 * @return true if there is a possibility that the chunk contains a visible entity
	 */
	static bool AreAnyEntitiesVisibleInChunk(const FMassExecutionContext& Context)
	{
		return Context.GetChunkFragment<FMassVisualizationChunkFragment>().AreAnyEntitiesVisible();
	}

	/**
	 * Returns if there could be a visible entities in that chunk
	 *
	 * @return true if that is the case
	 */
	bool AreAnyEntitiesVisible() const
	{
		return (Visibility != EMassVisibility::CulledByDistance && Visibility != EMassVisibility::CulledByFrustum) || bContainsNewlyVisibleEntity;
	}

	/**
	 * IsChunkHandledThisFrame
	 *
	 * This function is used by LOD collector query chunk filters to check that visual LOD will be updated this frame. 
	 * It defaults to false (no LOD update), if visualization chunk fragment is NOT present.
	 * 
	 * @param Context of the execution from the entity sub system
	 * @return true if the visual LOD will be updated this frame
	 */
	static bool IsChunkHandledThisFrame(const FMassExecutionContext& Context)
	{
		const FMassVisualizationChunkFragment* ChunkFragment = Context.GetChunkFragmentPtr<FMassVisualizationChunkFragment>();
		return ChunkFragment != nullptr && ChunkFragment->ShouldUpdateVisualization();
	}

	/**
	 * ShouldUpdateVisualizationForChunk
	 * 
	 * This function is used by query chunk filters in processors that require variable visual LOD update. 
	 * It defaults to true (always updating) if visualization chunk fragment is NOT present.
	 *
	 * @param Context of the execution from the entity sub system
	 * @return true if the chunk should update the visual this frame
	 */
	static bool ShouldUpdateVisualizationForChunk(const FMassExecutionContext& Context)
	{
		const FMassVisualizationChunkFragment* ChunkFragment = Context.GetChunkFragmentPtr<FMassVisualizationChunkFragment>();
		return ChunkFragment == nullptr || ChunkFragment->ShouldUpdateVisualization();
	}

	/**
	 * Representation type of all currently visible entities are always updated
	 * But as an optimization, we use a frequency check on the not visible one.
	 *
	 * @return true if we should update the representation type for this chunk
	 */
	bool ShouldUpdateVisualization() const
	{
		return Visibility != EMassVisibility::CulledByDistance || DeltaTime <= 0.0f;
	}

	void SetContainsNewlyVisibleEntity(bool bInContainsNewlyVisibleEntity)
	{
		if (bInContainsNewlyVisibleEntity)
		{
			checkfSlow(Visibility != EMassVisibility::CanBeSeen, TEXT("Something is not adding up, how can an entity be newly visible in a can be seen chunk?"));
			bContainsNewlyVisibleEntity = true;
		}
	}

	void SetVisibility(const EMassVisibility InVisibility)
	{
		checkf(Visibility == EMassVisibility::Max, TEXT("Chunk visibility should never change, it is allowed to only set it once"));
		Visibility = InVisibility;
	}

	EMassVisibility GetVisibility() const
	{
		return Visibility;
	}

	float GetDeltaTime() const
	{
		return DeltaTime;
	}

	void Update(float InDeltaTime)
	{
		bContainsNewlyVisibleEntity = false;
		DeltaTime = InDeltaTime;
	}

protected:

	/** Visibility of the current chunk, should never change */
	UPROPERTY()
	EMassVisibility Visibility = EMassVisibility::Max;

	/** Not visible chunks, might contains entity that are newly visible and not yet moved. */
	UPROPERTY()
	bool bContainsNewlyVisibleEntity = true;

	/** Not visible chunks delta time until next update */
	UPROPERTY()
	float DeltaTime = 0;
};

================================================


=== Source/MassLOD/Public/MassLODLogic.h ===
============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassLODSubsystem.h"
#include "Containers/StaticArray.h"
#include "ConvexVolume.h"


#define DECLARE_CONDITIONAL_MEMBER_ACCESSORS( Condition, MemberType, MemberName ) \
template <bool Condition, typename TemplateClass> static FORCEINLINE typename TEnableIf< Condition, MemberType>::Type Get##MemberName(TemplateClass& Obj, MemberType DefaultValue) { return Obj.MemberName; } \
template <bool Condition, typename TemplateClass> static FORCEINLINE typename TEnableIf<!Condition, MemberType>::Type Get##MemberName(TemplateClass& Obj, MemberType DefaultValue) { return DefaultValue; } \
template <bool Condition, typename TemplateClass> static FORCEINLINE void Set##MemberName(TemplateClass& Obj, typename TEnableIf< Condition, MemberType>::Type Value) { Obj.MemberName = Value; } \
template <bool Condition, typename TemplateClass> static FORCEINLINE void Set##MemberName(TemplateClass& Obj, typename TEnableIf<!Condition, MemberType>::Type Value) {}

#define DECLARE_CONDITIONAL_MEMBER_ARRAY_ACCESSORS( Condition, MemberType, MemberName ) \
template <bool Condition, typename TemplateClass> static FORCEINLINE void Set##MemberName##Num(TemplateClass& Obj, typename TEnableIf< Condition, int32>::Type Num) { Obj.MemberName.SetNum(Num); } \
template <bool Condition, typename TemplateClass> static FORCEINLINE void Set##MemberName##Num(TemplateClass& Obj, typename TEnableIf<!Condition, int32>::Type Num) {} \
template <bool Condition, typename TemplateClass> static FORCEINLINE typename TEnableIf< Condition, MemberType>::Type Get##MemberName(TemplateClass& Obj, int32 Index, MemberType DefaultValue) { return Obj.MemberName[Index]; } \
template <bool Condition, typename TemplateClass> static FORCEINLINE typename TEnableIf<!Condition, MemberType>::Type Get##MemberName(TemplateClass& Obj, int32 Index, MemberType DefaultValue) { return DefaultValue; } \
template <bool Condition, typename TemplateClass> static FORCEINLINE void Set##MemberName(TemplateClass& Obj, int32 Index, typename TEnableIf< Condition, MemberType>::Type Value) { Obj.MemberName[Index] = Value; } \
template <bool Condition, typename TemplateClass> static FORCEINLINE void Set##MemberName(TemplateClass& Obj, int32 Index, typename TEnableIf<!Condition, MemberType>::Type Value) {}

/**
 * Traits for LOD logic calculation behaviors
 */
struct FLODDefaultLogic
{
	enum
	{
		bStoreInfoPerViewer = false, // Enable to store all calculated information per viewer
		bCalculateLODPerViewer = false, // Enable to calculate and store the result LOD per viewer in the FMassLODResultInfo::LODPerViewer and FMassLODResultInfo::PrevLODPerViewer, requires bStoreInfoPerViewer to be true as well.
		bMaximizeCountPerViewer = false, // Enable to maximize count per viewer, requires a valid InLODMaxCountPerViewer parameter during initialization of TMassLODCalculator.
		bDoVisibilityLogic = false, // Enable to calculate visibility and apply its own LOD distances. Requires a valid InVisibleLODDistance parameter during initialization of TMassLODCalculator.
		bCalculateLODSignificance = false, // Enable to calculate and set the a more precise LOD floating point significance in member FMassLODResultInfo::LODSignificance.
		bLocalViewersOnly = false, // Enable to calculate LOD from LocalViewersOnly, otherwise will be done on all viewers.
	};
};

struct FMassSimulationLODLogic : public FLODDefaultLogic
{
};

struct FMassRepresentationLODLogic : public FLODDefaultLogic
{
	enum
	{
		bDoVisibilityLogic = true,
		bCalculateLODSignificance = true,
		bLocalViewersOnly = true,
	};
};

struct FMassCombinedLODLogic : public FLODDefaultLogic
{
	enum
	{
		bDoVisibilityLogic = true,
		bCalculateLODSignificance = true,
		bLocalViewersOnly = true,
	};
};

/** Simplest version of RepresentationLODLogic strictly based on Distance to Viewer
 *	Compared to FMassRepresentationLODLogic, we:
 *	* Do not care about doing the Visibility Logic
 *	* For now we will keep the Significance computation as it could allow for finer grained control later on
*/
struct FMassDistanceLODLogic : public FLODDefaultLogic
{
	enum
	{
		bCalculateLODSignificance = true,
		bLocalViewersOnly = true,
	};
};

/**
 * TMassLODCollector outputs
 *
struct FMassViewerInfoFragment
{
	// Closest viewer distance  (Always needed)
	float ClosestViewerDistanceSq;

	// Square distances to each valid viewers (Required when FLODLogic::bStoreInfoPerViewer is enabled)
	TArray<float> DistanceToViewerSq;
};

struct FMassInfoPerViewerFragment
{
	// Square distances to each valid viewers (Required when FLODLogic::bStoreInfoPerViewer is enabled)
	TArray<float> DistanceToViewerSq;

	// Distances to each valid viewers frustums (Required when FLODLogic::bDoVisibilityLogic and FLODLogic::bStoreInfoPerViewer are enabled)
	TArray<float> DistanceToFrustum;
};

*/

/**
 * TMassLODCalculator outputs
 *
 struct FMassLODFragment
{
	// LOD information
	TEnumAsByte<EMassLOD::Type> LOD;
	TEnumAsByte<EMassLOD::Type> PrevLOD;

	// Visibility information (Required when FLODLogic::bDoVisibilityLogic is enabled)
	EMassVisibility Visibility;
	EMassVisibility PrevVisibility

	// Floating point LOD value, scaling from 0 to 3, 0 highest LOD and 3 being completely off LOD 
	// (Required only when FLODLogic::bCalculateLODSignificance is enabled)
	float LODSignificance = 0.0f; // 

	// Per viewer LOD information (Required when FLODLogic::bCalculateLODPerViewer is enabled)
	TArray<EMassLOD::Type> LODPerViewer;
	TArray<EMassLOD::Type> PrevLODPerViewer;

	// Visibility information per viewer (Required when FLODLogic::bDoVisibilityLogic and FLODLogicbStoreInfoPerViewer are enabled)
	TArray<EMassVisibility> VisibilityPerViewer;
	TArray<EMassVisibility> PrevVisibilityPerViewer;
}
*/

/**
 * TMassLODTickRateController outputs
 *
 struct FMassVariableTickFragment
{
	// Accumulated DeltaTime
	float DeltaTime = 0.0f;
	float LastTickedTime = 0.0f;
};
*/

struct FViewerLODInfo
{
	/* Boolean indicating the viewer is local or not */
	bool bLocal = false;

	/* Boolean indicating the viewer data needs to be cleared */
	bool bClearData = false;

	/** The handle to the viewer */
	FMassViewerHandle Handle;

	/** Viewer location and looking direction */
	FVector Location;
	FVector Direction;

	/** Viewer frustum (will not include near and far planes) */
	FConvexVolume Frustum;
};

/**
 * Base struct for the LOD calculation helpers
 */
struct MASSLOD_API FMassLODBaseLogic
{
	FMassLODBaseLogic(bool bShouldBuildFrustumData)
		: bBuildFrustumData(bShouldBuildFrustumData)
	{}

protected:
	void CacheViewerInformation(TConstArrayView<FViewerInfo> ViewerInfos);

	/** Per viewer LOD information conditional fragment accessors */
	DECLARE_CONDITIONAL_MEMBER_ARRAY_ACCESSORS(Condition, EMassLOD::Type, LODPerViewer);
	DECLARE_CONDITIONAL_MEMBER_ARRAY_ACCESSORS(Condition, EMassLOD::Type, PrevLODPerViewer);

	/** LOD Significance conditional fragment accessors */
	DECLARE_CONDITIONAL_MEMBER_ACCESSORS(Condition, float, LODSignificance);

	/** Visibility conditional fragment accessors */
	DECLARE_CONDITIONAL_MEMBER_ACCESSORS(Condition, float, ClosestDistanceToFrustum);
	DECLARE_CONDITIONAL_MEMBER_ACCESSORS(Condition, EMassVisibility, Visibility);
	DECLARE_CONDITIONAL_MEMBER_ACCESSORS(Condition, EMassVisibility, PrevVisibility);

	/** Per viewer distance conditional fragment accessors */
	DECLARE_CONDITIONAL_MEMBER_ARRAY_ACCESSORS(Condition, float, DistanceToViewerSq);

	/** Per viewer visibility conditional fragment accessors */
	DECLARE_CONDITIONAL_MEMBER_ARRAY_ACCESSORS(Condition, float, DistanceToFrustum);
	DECLARE_CONDITIONAL_MEMBER_ARRAY_ACCESSORS(Condition, EMassVisibility, VisibilityPerViewer);
	DECLARE_CONDITIONAL_MEMBER_ARRAY_ACCESSORS(Condition, EMassVisibility, PrevVisibilityPerViewer);

	TArray<FViewerLODInfo> Viewers;

private:
	/** 
	 * Setting to false will prevent costly FViewerLODInfo.Frustum creation. Makes sense only if that data is not required.
	 * Note that this property is not expected to be changed at runtime.
	 */
	bool bBuildFrustumData = true;
};
============================================


=== Source/MassLOD/Public/MassLODSubsystem.h ===
================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassCommonTypes.h"
#include "MassProcessor.h"
#include "IndexedHandle.h"
#include "MassLODTypes.h"
#include "MassSubsystemBase.h"
#include "MassExternalSubsystemTraits.h"
#include "MassLODSubsystem.generated.h"

class UMassLODSubsystem;
class AActor;
class APlayerController;

/*
 * Handle that lets you reference the concept of a viewer
 */
USTRUCT()
struct MASSLOD_API FMassViewerHandle : public FIndexedHandleBase
{
	GENERATED_BODY()

	friend class UMassLODSubsystem;
};

USTRUCT()
struct FViewerInfo
{
	GENERATED_BODY()

	FViewerInfo() = default;
PRAGMA_DISABLE_DEPRECATION_WARNINGS
	FViewerInfo(const FViewerInfo& Other) = default;
PRAGMA_ENABLE_DEPRECATION_WARNINGS

	UPROPERTY(transient)
	TObjectPtr<AActor> ActorViewer = nullptr;
	
	FName StreamingSourceName;

#if WITH_EDITOR
	int8 EditorViewportClientIndex = INDEX_NONE;
#endif // WITH_EDITOR

	FMassViewerHandle Handle;
	uint32 HashValue = 0;

	FVector Location;
	FRotator Rotation;
	float FOV = 90.0f;
	float AspectRatio = 16.0f / 9.0f;

	bool bEnabled = true;

	void Reset();

	bool IsLocal() const;

	MASSLOD_API APlayerController* GetPlayerController() const;
private:
	UE_DEPRECATED_FORGAME(5.4, "PlayerController member variable has been deprecated in favor of more generic ActorViewer. Use that instead.")
	TObjectPtr<APlayerController> PlayerController = nullptr;
};

UE_DEPRECATED(5.3, "FOnViewerAdded is deprecated. Use UMassLODSubsystem::FOnViewerAdded instead.")
DECLARE_MULTICAST_DELEGATE_ThreeParams(FOnViewerAdded, FMassViewerHandle ViewerHandle, APlayerController* PlayerController, FName StreamingSourceName);
UE_DEPRECATED(5.3, "FOnViewerRemoved is deprecated. Use UMassLODSubsystem::FOnViewerRemoved instead.")
DECLARE_MULTICAST_DELEGATE_ThreeParams(FOnViewerRemoved, FMassViewerHandle ViewerHandle, APlayerController* PlayerController, FName StreamingSourceName);

/*
 * Manager responsible to manage and synchronized available viewers
 */
UCLASS(config = Mass, defaultconfig)
class MASSLOD_API UMassLODSubsystem : public UMassSubsystemBase
{
	GENERATED_BODY()

	DECLARE_MULTICAST_DELEGATE_OneParam(FOnViewerAdded, const FViewerInfo& ViewerInfo);
	DECLARE_MULTICAST_DELEGATE_OneParam(FOnViewerRemoved, const FViewerInfo& ViewerInfo);

public:
	/** Checks the validity of a viewer handle */
	bool IsValidViewer(const FMassViewerHandle& ViewerHandle) const { return GetValidViewerIdx(ViewerHandle) != INDEX_NONE; }

	/** Returns the index of the viewer if valid, otherwise INDEX_NONE is return */
	int32 GetValidViewerIdx(const FMassViewerHandle& ViewerHandle) const;

	/** Returns the array of viewers */
	const TArray<FViewerInfo>& GetViewers() const { return Viewers; }

	/** Synchronize the viewers if not done this frame and returns the updated array */
	const TArray<FViewerInfo>& GetSynchronizedViewers();

	/** Returns viewer handle from the PlayerController pointer */
	FMassViewerHandle GetViewerHandleFromActor(const AActor& Actor) const;

	/** Returns viewer handle from the streaming source name */
	FMassViewerHandle GetViewerHandleFromStreamingSource(const FName StreamingSourceName) const;

	/** Returns PlayerController pointer from the viewer handle */
	APlayerController* GetPlayerControllerFromViewerHandle(const FMassViewerHandle& ViewerHandle) const;

	/** Returns the delegate called when new viewer are added to the list */
	FOnViewerAdded& GetOnViewerAddedDelegate() { return OnViewerAddedDelegate;  }

	/** Returns the delegate called when viewer are removed from the list */
	FOnViewerRemoved& GetOnViewerRemovedDelegate() { return OnViewerRemovedDelegate; }

	void RegisterActorViewer(AActor& ActorViewer);
	void UnregisterActorViewer(AActor& ActorViewer);

	bool IsUsingPlayerPawnLocationInsteadOfCamera() const { return bUsePlayerPawnLocationInsteadOfCamera; }

#if WITH_MASSGAMEPLAY_DEBUG
	void DebugSetGatherPlayers(const bool bInValue) { bGatherPlayerControllers = bInValue; }
	void DebugSetUsePlayerPawnLocationInsteadOfCamera(const bool bInValue) { bUsePlayerPawnLocationInsteadOfCamera = bInValue; }
	void DebugUnregisterActorViewer();
#endif

protected:
	// USubsystem BEGIN
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;
	// USubsystem END

	/** Called at the start of the PrePhysics mass processing phase and calls SynchronizeViewers */ 
	void OnPrePhysicsPhaseStarted(float DeltaTime);

	/** Synchronizes the viewers from the engine PlayerController list */
	void SynchronizeViewers();

	UE_DEPRECATED(5.3, "AddViewer has been deprecated. Use AddPlayerViewer or AddStreamingSourceViewer instead")
	void AddViewer(APlayerController* PlayerController, FName StreamingSourceName = NAME_None);

	/** Adds the given player as a viewer to the list and sends notification about addition */
	void AddPlayerViewer(APlayerController& PlayerController);

	/** Adds the given streaming source as a viewer to the list and sends notification about addition */
	void AddStreamingSourceViewer(const FName StreamingSourceName);

	void AddActorViewer(AActor& ActorViewer);

#if WITH_EDITOR
	/** Adds the editor viewport client (identified via an index) as a viewer to the list and sends notification about addition */
	void AddEditorViewer(const int32 HashValue, const int32 ClientIndex);
#endif // WITH_EDITOR

	/** Removes a viewer to the list and send notification about removal */
	void RemoveViewer(const FMassViewerHandle& ViewerHandle);

	/** Returns the next new viewer serial number */
	uint32 GetNextViewerSerialNumber() { return ViewerSerialNumberCounter++; }

	/** Player controller EndPlay callback, removing viewers from the list */
	UFUNCTION()
	void OnPlayerControllerEndPlay(AActor* Actor, EEndPlayReason::Type EndPlayReason);

protected:
	/** If true, all PlayerControllers will be gathered as viewers for LOD calculations. */
	UPROPERTY(EditDefaultsOnly, Category = "Mass|LOD", config)
	uint8 bGatherPlayerControllers : 1 = true;

	/** If true, all streaming sources will be gathered as viewers for LOD calculations. */
	UPROPERTY(EditDefaultsOnly, Category = "Mass|LOD", config)
	uint8 bGatherStreamingSources : 1 = true;

	/** Whether using non-player actors as LOD Viewers is supported. */
	UPROPERTY(EditDefaultsOnly, Category = "Mass|LOD", config)
	uint8 bAllowNonPlayerViwerActors : 1 = true;

	/** 
	 * If set to true will prefer to use Player-owned Pawn's location and rotation over Player's camera as the viewer's 
	 * location and rotation.
	 * Note that this works best with distance-only LOD and can introduce subtle inaccuracies if Frustum-based LOD is being used. 
	 */
	UPROPERTY(EditDefaultsOnly, Category = "Mass|LOD", config)
	uint8 bUsePlayerPawnLocationInsteadOfCamera : 1 = false;

private:
	/** Removes a viewer to the list and send notification about removal */
	void RemoveViewerInternal(const FMassViewerHandle& ViewerHandle);

	/** The actual array of viewer's information*/
	UPROPERTY(Transient)
	TArray<FViewerInfo> Viewers;

	/** The map that do reverse look up to get ViewerHandle */
	UPROPERTY(Transient)
	TMap<uint32, FMassViewerHandle> ViewerMap;

	UPROPERTY(Transient)
	TArray<TObjectPtr<AActor>> RegisteredActorViewers;

	uint64 LastSynchronizedFrame = 0;

	/** Viewer serial number counter */
	uint32 ViewerSerialNumberCounter = 0;

#if WITH_EDITOR
	bool bUseEditorLevelViewports = false;
	bool bIgnorePlayerControllersDueToSimulation = false;
#endif // WITH_EDITOR

	/** Free list of indices in the sparse viewer array */
	TArray<int32> ViewerFreeIndices;

	/** Delegates to notify anyone who needs to know about viewer changes */
	FOnViewerAdded OnViewerAddedDelegate;
	FOnViewerRemoved OnViewerRemovedDelegate;

public:
	UE_DEPRECATED(5.4, "GetViewerHandleFromPlayerController is deprecated. Use more teneric GetViewerHandleFromActor")
	FMassViewerHandle GetViewerHandleFromPlayerController(const APlayerController* PlayerController) const;
};

template<>
struct TMassExternalSubsystemTraits<UMassLODSubsystem> final
{
	enum
	{
		GameThreadOnly = true
	};
};

================================================


=== Source/MassLOD/Public/MassLODTickRateController.h ===
=========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassLODLogic.h"
#include "MassLODUtils.h"
#include "MassCommonUtils.h"
#include "MassCommandBuffer.h"

/**
 * Helper struct to control LOD tick rate for each agent, 
 * It will add a fragment tag to group the agent of the same LOD together, that way the user can do tick rate logic per chunk.
 */
template <typename TVariableTickChunkFragment, typename FLODLogic = FLODDefaultLogic >
struct TMassLODTickRateController : public FMassLODBaseLogic
{
public:
	TMassLODTickRateController()
		: FMassLODBaseLogic(/*bShouldBuildFrustumData=*/false)
	{}

	/**
	 * Initializes the LOD trick rate controller, needed to be called once at initialization time (Only when FLODLogic::bDoVariableTickRate is enabled)
	 * @Param InTickRate the rate at which entities should be ticked per 
	 * @Param bInShouldSpreadFirstUpdate over the period specified in InTickRate parameter
	 */
	void Initialize(const float InTickRate[EMassLOD::Max], const bool bInShouldSpreadFirstUpdate = false);

	/**
	 * Retrieve if it is needed to calculate the LOD for this chunk
	 *
	 * @return if the LOD needs to be calculated
	 */
	bool ShouldCalculateLODForChunk(const FMassExecutionContext& Context) const;

	/**
	 * Retrieve if it is needed to adjust LOD from the newly calculated count for this chunk
	 * 
	 * @return if the LOD needs to be adjusted
	 */
	bool ShouldAdjustLODFromCountForChunk(const FMassExecutionContext& Context) const;

	/**
	 * Updates tick rate for this chunk and its entities
	 * @param Context of the chunk execution 
	 * @param LODList is the fragment where calculation are stored 
	 * @param Time of the simulation to use for this update
	 * @return bool return if the chunk should be tick this frame
	 */
	template <typename TLODFragment, typename TVariableTickRateFragment>
	bool UpdateTickRateFromLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TArrayView<TVariableTickRateFragment> TickRateList, const double Time);

	friend FORCEINLINE uint32 GetTypeHash(const TMassLODTickRateController<TVariableTickChunkFragment, FLODLogic>& SharedFragmentInstance)
	{
		return HashCombineFast(GetTypeHash(SharedFragmentInstance.TickRates), uint32(SharedFragmentInstance.bShouldSpreadFirstUpdate));
	}

protected:

	/** Tick rate for each LOD */
	TStaticArray<float, EMassLOD::Max> TickRates;

	/* Whether or not to spread the first update over the period specified in tick rate member for its LOD */
	bool bShouldSpreadFirstUpdate = false;
};

template <typename TVariableTickChunkFragment, typename FLODLogic>
void TMassLODTickRateController<TVariableTickChunkFragment, FLODLogic>::Initialize(const float InTickRates[EMassLOD::Max], const bool bInShouldSpreadFirstUpdate/* = false*/)
{
	checkf(InTickRates, TEXT("You need to provide tick rate values to use this class."));

	// Make a copy of all the settings
	for (int x = 0; x < EMassLOD::Max; x++)
	{
		TickRates[x] = InTickRates[x];
	}

	bShouldSpreadFirstUpdate = bInShouldSpreadFirstUpdate;
}

template <typename TVariableTickChunkFragment, typename FLODLogic>
bool TMassLODTickRateController<TVariableTickChunkFragment, FLODLogic>::ShouldCalculateLODForChunk(const FMassExecutionContext& Context) const
{
	// EMassLOD::Off does not need to handle max count, so we can use ticking rate for them if available
	const FMassVariableTickChunkFragment& ChunkData = Context.GetChunkFragment<TVariableTickChunkFragment>();
	return ChunkData.GetLOD() != EMassLOD::Off || ChunkData.ShouldTickThisFrame();
}

template <typename TVariableTickChunkFragment, typename FLODLogic>
bool TMassLODTickRateController<TVariableTickChunkFragment, FLODLogic>::ShouldAdjustLODFromCountForChunk(const FMassExecutionContext& Context) const
{
	// EMassLOD::Off does not need to handle max count, so we can skip it
	const FMassVariableTickChunkFragment& ChunkData = Context.GetChunkFragment<TVariableTickChunkFragment>();
	return ChunkData.GetLOD() != EMassLOD::Off;
}

template <typename TVariableTickChunkFragment, typename FLODLogic>
template <typename TLODFragment, typename TVariableTickRateFragment>
bool TMassLODTickRateController<TVariableTickChunkFragment, FLODLogic>::UpdateTickRateFromLOD(FMassExecutionContext& Context, TConstArrayView<TLODFragment> LODList, TArrayView<TVariableTickRateFragment> TickRateList, const double Time)
{
	bool bShouldTickThisFrame = true;
	bool bWasChunkTicked = true;
	const float DeltaTime = Context.GetDeltaTimeSeconds();
	bool bFirstUpdate = false;

	FMassVariableTickChunkFragment& ChunkData = Context.GetMutableChunkFragment<TVariableTickChunkFragment>();
	EMassLOD::Type ChunkLOD = ChunkData.GetLOD();
	if (ChunkLOD == EMassLOD::Max)
	{
		// The LOD on the chunk fragment data isn't set yet, let see if the Archetype has an LOD tag and set it on the ChunkData
		ChunkLOD = UE::MassLOD::GetLODFromArchetype(Context);
		ChunkData.SetLOD(ChunkLOD);
		bFirstUpdate = bShouldSpreadFirstUpdate;
	}
	else
	{
		checkfSlow(UE::MassLOD::IsLODTagSet(Context, ChunkLOD), TEXT("Expecting the same LOD as what we saved in the chunk data, maybe external code is modifying the tags"))
	}

	if (ChunkLOD != EMassLOD::Max)
	{
		float TimeUntilNextTick = ChunkData.GetTimeUntilNextTick();
		bWasChunkTicked = ChunkData.ShouldTickThisFrame();

		const int32 LastChunkSerialModificationNumber = ChunkData.GetLastChunkSerialModificationNumber();
		const int32 ChunkSerialModificationNumber = Context.GetChunkSerialModificationNumber();

		// Prevent the chunk modification tracking logic to trigger a tick until we actually tick from the first update tick calculation
		int32 NewChunkSerialModificationNumber = (LastChunkSerialModificationNumber == INDEX_NONE) ? INDEX_NONE : ChunkSerialModificationNumber;

		const float TickRate = TickRates[ChunkLOD];
		if (bFirstUpdate)
		{
			// @todo: Add some randomization for deterministic runs too. The randomization is used to distribute the infrequent ticks evenly on different frames.
			TimeUntilNextTick = UE::Mass::Utils::IsDeterministic() ? TickRate * 0.5f : FMath::RandRange(0.0f, TickRate);
		}
		else if(bWasChunkTicked)
		{
			// Reset DeltaTime if we ticked last frame and start tracking chunk modifications
			// @todo: Add some randomization for deterministic runs too. The randomization is used to distribute the infrequent ticks evenly on different frames.
			TimeUntilNextTick = UE::Mass::Utils::IsDeterministic() ? TickRate : (TickRate * (1.0f + FMath::RandRange(-0.1f, 0.1f)));
			NewChunkSerialModificationNumber = ChunkSerialModificationNumber;
		}
		else
		{
			// Decrement delta time
			TimeUntilNextTick -= DeltaTime;
		}

		// Should we tick this frame?
		bShouldTickThisFrame = TimeUntilNextTick <= 0.0f || LastChunkSerialModificationNumber != NewChunkSerialModificationNumber;
		ChunkData.Update(bShouldTickThisFrame, TimeUntilNextTick, NewChunkSerialModificationNumber);
	}

	if (bWasChunkTicked)
	{
		const int32 NumEntities = Context.GetNumEntities();
		for (int32 Index = 0; Index < NumEntities; ++Index)
		{
			const TLODFragment& EntityLOD = LODList[Index];
			TVariableTickRateFragment& TickRate = TickRateList[Index];
			TickRate.DeltaTime = TickRate.LastTickedTime != 0.0 ? static_cast<float>(Time - TickRate.LastTickedTime) : DeltaTime;
			TickRate.LastTickedTime = Time;
			if (EntityLOD.LOD != ChunkLOD)
			{
				const FMassEntityHandle Entity = Context.GetEntity(Index);
				UE::MassLOD::PushSwapTagsCommand(Context.Defer(), Entity, ChunkLOD, EntityLOD.LOD);
			}
		}
	}

	return bShouldTickThisFrame;
}

=========================================================


=== Source/MassLOD/Public/MassLODTrait.h ===
============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "MassEntityTraitBase.h"
#include "MassSimulationLOD.h"

#include "MassLODTrait.generated.h"

UCLASS(meta = (DisplayName = "LODCollector"))
class MASSLOD_API UMassLODCollectorTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

public:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;
};

// Simplest version of UMassLODCollectorTrait that will ensure collection strictly based on Distance from Viewer
UCLASS(meta = (DisplayName = "DistanceLODCollector"))
class MASSLOD_API UMassDistanceLODCollectorTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

public:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;
};

UCLASS(meta = (DisplayName = "SimulationLOD"))
class MASSLOD_API UMassSimulationLODTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

	UPROPERTY(Category = "Config", EditAnywhere)
	FMassSimulationLODParameters Params;

	UPROPERTY(Category = "Config", EditAnywhere)
	bool bEnableVariableTicking = false;

	UPROPERTY(Category = "Config", EditAnywhere, meta = (EditCondition = "bEnableVariableTicking", EditConditionHides))
	FMassSimulationVariableTickParameters VariableTickParams;

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;
};

============================================


=== Source/MassLOD/Public/MassLODTypes.h ===
============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "Containers/StaticArray.h"
#include "MassEntityManager.h"

#include "MassLODTypes.generated.h"

/** Debug option to allow multiple viewers per controller. Useful for testing and profiling purposes */
#define UE_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER 0

#define UE_ALLOW_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER (UE_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER && !UE_BUILD_SHIPPING)

namespace UE::MassLOD
{
#if UE_ALLOW_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER
	constexpr int32 DebugNumberViewersPerController = 50;
#endif // UE_ALLOW_DEBUG_REPLICATION_DUPLICATE_VIEWERS_PER_CONTROLLER

	constexpr int32 MaxBucketsPerLOD = 250;

	extern MASSLOD_API FColor LODColors[];
} // UE::MassLOD

namespace UE::Mass::ProcessorGroupNames
{
	const FName LODCollector = FName(TEXT("LODCollector"));
	const FName LOD = FName(TEXT("LOD"));
}

// We are not using enum class here because we are doing so many arithmetic operation and comparison on them 
// that it is not worth polluting int32 casts everywhere in the code.
UENUM()
namespace EMassLOD
{
	enum Type : int
	{
		High,
		Medium,
		Low,
		Off,
		Max
	};
}


UENUM()
enum class EMassVisibility : uint8
{
	CanBeSeen, // Not too far and within camera frustum
	CulledByFrustum, // Not in camera frustum but within visibility distance
	CulledByDistance, // Too far whether in or out of frustum
	Max
};
============================================


=== Source/MassLOD/Public/MassLODUtils.h ===
============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "MassEntityManager.h"
#include "MassCommonTypes.h"
#include "MassLODFragments.h"
#include "Logging/LogMacros.h"

MASSLOD_API DECLARE_LOG_CATEGORY_EXTERN(LogMassLOD, Log, All);

struct FMassCommandBuffer;

namespace UE::MassLOD 
{

inline EMassLOD::Type GetLODFromArchetype(const FMassExecutionContext& Context)
{
	if (Context.DoesArchetypeHaveTag<FMassOffLODTag>())
	{
		return EMassLOD::Off;
	}
	if (Context.DoesArchetypeHaveTag<FMassLowLODTag>())
	{
		return EMassLOD::Low;
	}
	if (Context.DoesArchetypeHaveTag<FMassMediumLODTag>())
	{
		return EMassLOD::Medium;
	}
	if (Context.DoesArchetypeHaveTag<FMassHighLODTag>())
	{
		return EMassLOD::High;
	}
	return EMassLOD::Max;
}

template <EMassLOD::Type Level>
struct TMassLODTagForLevel
{
	typedef FMassOffLODTag FTag;
};

template<>
struct TMassLODTagForLevel<EMassLOD::High>
{
	typedef FMassHighLODTag FTag;
};

template<>
struct TMassLODTagForLevel<EMassLOD::Medium>
{
	typedef FMassMediumLODTag FTag;
};

template<>
struct TMassLODTagForLevel<EMassLOD::Low>
{
	typedef FMassLowLODTag FTag;
};


inline const UScriptStruct* GetLODTagFromLOD(EMassLOD::Type LOD)
{
	switch (LOD)
	{
		case EMassLOD::High:
			return TMassLODTagForLevel<EMassLOD::High>::FTag::StaticStruct();
		case EMassLOD::Medium:
			return TMassLODTagForLevel<EMassLOD::Medium>::FTag::StaticStruct();
		case EMassLOD::Low:
			return TMassLODTagForLevel<EMassLOD::Low>::FTag::StaticStruct();
		case EMassLOD::Off:
			return TMassLODTagForLevel<EMassLOD::Off>::FTag::StaticStruct();
		default:
			checkf(false, TEXT("Unsupported LOD Type"));
		case EMassLOD::Max:
			return nullptr;
	}
}

inline bool IsLODTagSet(const FMassExecutionContext& Context, EMassLOD::Type LOD)
{
	switch (LOD)
	{
		case EMassLOD::High:
			return Context.DoesArchetypeHaveTag<FMassHighLODTag>();
		case EMassLOD::Medium:
			return Context.DoesArchetypeHaveTag<FMassMediumLODTag>();
		case EMassLOD::Low:
			return Context.DoesArchetypeHaveTag<FMassLowLODTag>();
		case EMassLOD::Off:
			return Context.DoesArchetypeHaveTag<FMassOffLODTag>();
		default:
			checkf(false, TEXT("Unsupported LOD Type"));
		case EMassLOD::Max:
			return false;
	}
}

void MASSLOD_API PushSwapTagsCommand(FMassCommandBuffer& CommandBuffer, const FMassEntityHandle Entity, const EMassLOD::Type PrevLOD, const EMassLOD::Type NewLOD);

#if WITH_MASSGAMEPLAY_DEBUG
namespace Debug 
{
	MASSLOD_API extern bool bLODCalculationsPaused;
} // UE::MassLOD::Debug
#endif // WITH_MASSGAMEPLAY_DEBUG
} // UE::MassLOD
============================================


=== Source/MassLOD/Public/MassSimulationLOD.h ===
=================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassProcessor.h"
#include "MassLODCollector.h"
#include "MassLODCalculator.h"
#include "MassLODTickRateController.h"
#include "MassLODLogic.h"
#include "MassEntityTypes.h"
#include "MassLODFragments.h"

#include "MassSimulationLOD.generated.h"

USTRUCT()
struct MASSLOD_API FMassSimulationLODFragment : public FMassFragment
{
	GENERATED_BODY()

	/** Saved closest ViewerDistance */
	float ClosestViewerDistanceSq = FLT_MAX;

	/**LOD information */
	TEnumAsByte<EMassLOD::Type> LOD = EMassLOD::Max;

	/** Previous LOD information*/
	TEnumAsByte<EMassLOD::Type> PrevLOD = EMassLOD::Max;
};

USTRUCT()
struct MASSLOD_API FMassSimulationVariableTickFragment : public FMassFragment
{
	GENERATED_BODY()

	/** Accumulated delta time to use upon next tick */
	double LastTickedTime = 0.;
	float DeltaTime = 0.0f;
};

USTRUCT()
struct MASSLOD_API FMassSimulationVariableTickChunkFragment : public FMassVariableTickChunkFragment
{
	GENERATED_BODY();

	/**
	 * IsChunkHandledThisFrame
	 * 
	 * This function is used by LOD collector query chunk filters to check if the Simulation LOD will be updated this frame.
	 * It defaults to false (no LOD update), if simulation variable tick chunk fragment is NOT present.
	 * 
	 * @return true if the simulation LOD will be updated this frame
	 */
	static bool IsChunkHandledThisFrame(const FMassExecutionContext& Context)
	{
		const FMassSimulationVariableTickChunkFragment* ChunkFragment = Context.GetChunkFragmentPtr<FMassSimulationVariableTickChunkFragment>();
		return ChunkFragment != nullptr && ChunkFragment->ShouldTickThisFrame();
	}

	/**
	 * ShouldTickChunkThisFrame
	 * 
	 * This function is used by query chunk filters in processors that require variable rate ticking based on LOD.
	 * It defaults to true (always ticking) if simulation variable tick chunk fragment is NOT present.
	 * 
	 * @return if the chunk should be ticked this frame
	 */
	static bool ShouldTickChunkThisFrame(const FMassExecutionContext& Context)
	{
		const FMassSimulationVariableTickChunkFragment* ChunkFragment = Context.GetChunkFragmentPtr<FMassSimulationVariableTickChunkFragment>();
		return ChunkFragment == nullptr || ChunkFragment->ShouldTickThisFrame();
	}

	static EMassLOD::Type GetChunkLOD(const FMassExecutionContext& Context)
	{
		const FMassSimulationVariableTickChunkFragment* ChunkFragment = Context.GetChunkFragmentPtr<FMassSimulationVariableTickChunkFragment>();
		return ChunkFragment ? ChunkFragment->GetLOD() : EMassLOD::High;
	}

};

USTRUCT()
struct MASSLOD_API FMassSimulationLODParameters : public FMassConstSharedFragment
{
	GENERATED_BODY()

	FMassSimulationLODParameters();

	/** Distance where each LOD becomes relevant */
	UPROPERTY(EditAnywhere, Category = "LOD", config)
	float LODDistance[EMassLOD::Max];

	/** Hysteresis percentage on delta between the LOD distances */
	UPROPERTY(EditAnywhere, Category = "LOD", meta = (ClampMin = "0.0", UIMin = "0.0"), config)
	float BufferHysteresisOnDistancePercentage = 10.0f;

	/** Maximum limit of entity per LOD */
	UPROPERTY(EditAnywhere, Category = "LOD", config)
	int32 LODMaxCount[EMassLOD::Max];

	/** If true, will set the associated LOD tag on the entity */
	UPROPERTY(EditAnywhere, Category = "LOD", config)
	bool bSetLODTags = false;
};

USTRUCT()
struct MASSLOD_API FMassSimulationVariableTickParameters : public FMassConstSharedFragment
{
	GENERATED_BODY()

	FMassSimulationVariableTickParameters();

	/** Rate in seconds at which entities should update when in this LOD */
	UPROPERTY(EditAnywhere, Category = "VariableTick", config)
	float TickRates[EMassLOD::Max];

	/** If true, will spread the first simulation update over TickRate period */
	UPROPERTY(EditAnywhere, Category = "VariableTick", config)
	bool bSpreadFirstSimulationUpdate = false;
};

USTRUCT()
struct MASSLOD_API FMassSimulationLODSharedFragment : public FMassSharedFragment
{
	GENERATED_BODY()

	FMassSimulationLODSharedFragment() = default;
	FMassSimulationLODSharedFragment(const FMassSimulationLODParameters& LODParams);

	/** Runtime data for matching the simulation LOD parameters */
	TMassLODCalculator<FMassSimulationLODLogic> LODCalculator;
	bool bHasAdjustedDistancesFromCount = false;
};

USTRUCT()
struct MASSLOD_API FMassSimulationVariableTickSharedFragment : public FMassSharedFragment
{
	GENERATED_BODY()

	FMassSimulationVariableTickSharedFragment() = default;
	FMassSimulationVariableTickSharedFragment(const FMassSimulationVariableTickParameters& TickRateParams);

	/** Runtime data for matching the simulation tick rate parameters */
	TMassLODTickRateController<FMassSimulationVariableTickChunkFragment, FMassSimulationLODLogic> LODTickRateController;

	static bool ShouldCalculateLODForChunk(const FMassExecutionContext& Context)
	{
		if (const FMassSimulationVariableTickSharedFragment* TickRateSharedFragment = Context.GetSharedFragmentPtr<FMassSimulationVariableTickSharedFragment>())
		{
			return TickRateSharedFragment->LODTickRateController.ShouldCalculateLODForChunk(Context);
		}
		return true;
	}

	static bool ShouldAdjustLODFromCountForChunk(const FMassExecutionContext& Context)
	{
		if (const FMassSimulationVariableTickSharedFragment* TickRateSharedFragment = Context.GetSharedFragmentPtr<FMassSimulationVariableTickSharedFragment>())
		{
			return TickRateSharedFragment->LODTickRateController.ShouldAdjustLODFromCountForChunk(Context);
		}
		return true;
	}
};

UCLASS(meta = (DisplayName = "Simulation LOD"))
class MASSLOD_API UMassSimulationLODProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassSimulationLODProcessor();

protected:

	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	void CalculateLODForConfig(FMassEntityManager& EntityManager, FMassExecutionContext& Context, FMassSimulationLODParameters& LODParams);

	FMassEntityQuery EntityQuery;
	FMassEntityQuery EntityQueryCalculateLOD;
	FMassEntityQuery EntityQueryAdjustDistances;
	FMassEntityQuery EntityQueryVariableTick;
	FMassEntityQuery EntityQuerySetLODTag;

	UPROPERTY(config, EditDefaultsOnly, Category="Mass")
	bool bDoAdjustmentFromCount = true;
};

=================================================


=== Source/MassLOD/MassLOD.Build.cs ===
=======================================

// Copyright Epic Games, Inc. All Rights Reserved.

namespace UnrealBuildTool.Rules
{
	public class MassLOD : ModuleRules
	{
		public MassLOD(ReadOnlyTargetRules Target) : base(Target)
		{
			PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

			UnsafeTypeCastWarningLevel = WarningLevel.Warning;

			PublicDependencyModuleNames.AddRange(
				new string[] {
					"Core",
					"CoreUObject",
					"Engine",
					"AIModule",
					"MassEntity",
					"MassCommon",
					"MassSimulation",
					"MassSpawner"
				}
			);

			if (Target.bBuildEditor == true)
			{
				PrivateDependencyModuleNames.Add("UnrealEd");
			}
		}
	}
}

=======================================


=== Source/MassMovement/Private/MassMovementDelegates.cpp ===
=============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassMovementDelegates.h"
#include "CoreMinimal.h"

namespace UE::MassMovement::Delegates
{
#if WITH_EDITOR
	FOnMassMovementNamesChanged MASSMOVEMENT_API OnMassMovementNamesChanged;
#endif
} // UEUE::MassMovement::Delegates

=============================================================


=== Source/MassMovement/Private/MassMovementFragments.cpp ===
=============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassMovementFragments.h"

void FMassMovementParameters::Update()
{
	for (FMassMovementStyleParameters& Style : MovementStyles)
	{
		if (Style.DesiredSpeeds.IsEmpty())
		{
			continue;
		}

		// Calculate probability threshold for the speeds, so that a speed can be looked up based in a float in range [0...1]. 
		float Total = 0.0f;
		for (const FMassMovementStyleSpeedParameters& Speed : Style.DesiredSpeeds)
		{
			Total += Speed.Probability;
		}

		if (Total > KINDA_SMALL_NUMBER)
		{
			const float Scale = 1.0f / Total;
			float Sum = 0.0f;
			for (FMassMovementStyleSpeedParameters& Speed : Style.DesiredSpeeds)
			{
				Sum += Speed.Probability;
				Speed.ProbabilityThreshold = FMath::Min(Sum * Scale, 1.0f);
			}
		}
		else
		{
			const float Scale = 1.0f / static_cast<float>(Style.DesiredSpeeds.Num());
			float Sum = 0.0f;
			for (FMassMovementStyleSpeedParameters& Speed : Style.DesiredSpeeds)
			{
				Sum += 1.0f;
				Speed.ProbabilityThreshold = FMath::Min(Sum * Scale, 1.0f);
			}
		}
	}
}

=============================================================


=== Source/MassMovement/Private/MassMovementModule.cpp ===
==========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "CoreMinimal.h"
#include "IMassMovementModule.h"
#include "UObject/CoreRedirects.h"


class FMassMovementModule : public IMassMovementModule
{
	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

IMPLEMENT_MODULE(FMassMovementModule, MassMovement)



void FMassMovementModule::StartupModule()
{
	// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)
}


void FMassMovementModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}




==========================================================


=== Source/MassMovement/Private/MassMovementProcessors.cpp ===
==============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "Movement/MassMovementProcessors.h"
#include "MassCommonUtils.h"
#include "MassCommandBuffer.h"
#include "MassCommonFragments.h"
#include "MassExecutionContext.h"
#include "MassMovementFragments.h"
#include "Math/UnrealMathUtility.h"
#include "MassSimulationLOD.h"

#define UNSAFE_FOR_MT 0
#define MOVEMENT_DEBUGDRAW 0	// Set to 1 to see heading debugdraw

//----------------------------------------------------------------------//
//  UMassApplyMovementProcessor
//----------------------------------------------------------------------//

UMassApplyMovementProcessor::UMassApplyMovementProcessor()
	: EntityQuery(*this)
{
	ExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Movement;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Avoidance);
}

void UMassApplyMovementProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FMassForceFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);
	EntityQuery.AddConstSharedRequirement<FMassMovementParameters>(EMassFragmentPresence::All);
}

void UMassApplyMovementProcessor::Execute(FMassEntityManager& EntityManager,
													FMassExecutionContext& Context)
{
	// Clamp max delta time to avoid force explosion on large time steps (i.e. during initialization).
	const float DeltaTime = FMath::Min(0.1f, Context.GetDeltaTimeSeconds());

	QUICK_SCOPE_CYCLE_COUNTER(HighRes);

	EntityQuery.ForEachEntityChunk(EntityManager, Context, [this, DeltaTime](FMassExecutionContext& Context)
	{
		const int32 NumEntities = Context.GetNumEntities();

		const FMassMovementParameters& MovementParams = Context.GetConstSharedFragment<FMassMovementParameters>();

		const TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();
		const TArrayView<FMassForceFragment> ForceList = Context.GetMutableFragmentView<FMassForceFragment>();
		const TArrayView<FMassVelocityFragment> VelocityList = Context.GetMutableFragmentView<FMassVelocityFragment>();

		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			FMassForceFragment& Force = ForceList[EntityIndex];
			FMassVelocityFragment& Velocity = VelocityList[EntityIndex];
			FTransform& CurrentTransform = LocationList[EntityIndex].GetMutableTransform();

			// Update velocity from steering forces.
			Velocity.Value += Force.Value * DeltaTime;

#if WITH_MASSGAMEPLAY_DEBUG
			if (UE::MassMovement::bFreezeMovement)
			{
				Velocity.Value = FVector::ZeroVector;
			}
#endif // WITH_MASSGAMEPLAY_DEBUG

			FVector CurrentLocation = CurrentTransform.GetLocation();
			CurrentLocation += Velocity.Value * DeltaTime;
			CurrentTransform.SetTranslation(CurrentLocation);

		}
	});
}

#undef UNSAFE_FOR_MT

==============================================================


=== Source/MassMovement/Private/MassMovementSettings.cpp ===
============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassMovementSettings.h"
#include "MassMovementDelegates.h"
#include "MassMovementTypes.h"

//----------------------------------------------------------------------//
// UMassMovementSettings
//----------------------------------------------------------------------//

UMassMovementSettings::UMassMovementSettings(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	// Create default style
	FMassMovementStyle& Style = MovementStyles.AddDefaulted_GetRef();
	Style.Name = FName(TEXT("Default"));
	Style.ID = FGuid::NewGuid();
}


#if WITH_EDITOR
void UMassMovementSettings::PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent)
{
	Super::PostEditChangeChainProperty(PropertyChangedEvent);

	FProperty* Property = PropertyChangedEvent.Property;
	FProperty* MemberProperty = nullptr;
	if (PropertyChangedEvent.PropertyChain.GetActiveMemberNode())
	{
		MemberProperty = PropertyChangedEvent.PropertyChain.GetActiveMemberNode()->GetValue();
	}

	if (MemberProperty && Property)
	{
		if (MemberProperty->GetFName() == GET_MEMBER_NAME_CHECKED(UMassMovementSettings, MovementStyles))
		{
			const int32 ArrayIndex = PropertyChangedEvent.GetArrayIndex(MemberProperty->GetFName().ToString());

			// Ensure unique ID on duplicated items.
			if (PropertyChangedEvent.ChangeType == EPropertyChangeType::ArrayAdd)
			{
				if (MovementStyles.IsValidIndex(ArrayIndex))
				{
					MovementStyles[ArrayIndex].ID = FGuid::NewGuid();
					MovementStyles[ArrayIndex].Name = FName(TEXT("Movement Style"));
				}
			}
			else if (PropertyChangedEvent.ChangeType == EPropertyChangeType::Duplicate)
			{
				if (MovementStyles.IsValidIndex(ArrayIndex))
				{
					MovementStyles[ArrayIndex].ID = FGuid::NewGuid();
					MovementStyles[ArrayIndex].Name = FName(MovementStyles[ArrayIndex].Name.ToString() + TEXT(" Duplicate"));
				}
			}

			UE::MassMovement::Delegates::OnMassMovementNamesChanged.Broadcast();
		}
	}
}
#endif // WITH_EDITOR

const FMassMovementStyle* UMassMovementSettings::GetMovementStyleByID(const FGuid ID) const
{
	return MovementStyles.FindByPredicate([ID](const FMassMovementStyle& Style) { return Style.ID == ID; });
}


============================================================


=== Source/MassMovement/Private/MassMovementTrait.cpp ===
=========================================================

// Copyright Epic Games, Inc. All Rights Reserved.
#include "Movement/MassMovementTrait.h"
#include "MassEntityTemplateRegistry.h"
#include "MassCommonFragments.h"
#include "MassMovementFragments.h"
#include "MassMovementTypes.h"
#include "Engine/World.h"
#include "MassEntityUtils.h"


void UMassMovementTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	FMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(World);

	BuildContext.RequireFragment<FAgentRadiusFragment>();
	BuildContext.RequireFragment<FTransformFragment>();

	BuildContext.AddFragment<FMassVelocityFragment>();
	BuildContext.AddFragment<FMassForceFragment>();

	const FMassMovementParameters MovementValidated = Movement.GetValidated();
	const FConstSharedStruct MovementFragment = EntityManager.GetOrCreateConstSharedFragment(MovementValidated);
	BuildContext.AddConstSharedFragment(MovementFragment);
}

=========================================================


=== Source/MassMovement/Private/MassMovementTypes.cpp ===
=========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassMovementTypes.h"
#include "HAL/IConsoleManager.h"

namespace UE::MassMovement
{
	int32 bFreezeMovement = 0;
	FAutoConsoleVariableRef CVarFreezeMovement(TEXT("mass.debug.FreezeMovement"), bFreezeMovement, TEXT("Freeze any movement by common movement processors."));

} // UE::MassMovement

=========================================================


=== Source/MassMovement/Private/MassSimpleMovementTrait.cpp ===
===============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "Example/MassSimpleMovementTrait.h"
#include "MassEntityTemplateRegistry.h"
#include "Engine/World.h"
#include "MassMovementFragments.h"
#include "MassCommonFragments.h"
#include "MassExecutionContext.h"
#include "MassSimulationLOD.h"


//----------------------------------------------------------------------//
//  UMassSimpleMovementTrait
//----------------------------------------------------------------------//
void UMassSimpleMovementTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	BuildContext.AddFragment<FTransformFragment>();
	BuildContext.AddFragment<FMassVelocityFragment>();
	BuildContext.AddTag<FMassSimpleMovementTag>();	
}

//----------------------------------------------------------------------//
//  UMassSimpleMovementProcessor
//----------------------------------------------------------------------//
UMassSimpleMovementProcessor::UMassSimpleMovementProcessor()
	: EntityQuery(*this)
{
	bAutoRegisterWithProcessingPhases = true;
	ExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Avoidance;
}

void UMassSimpleMovementProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddTagRequirement<FMassSimpleMovementTag>(EMassFragmentPresence::All);

	EntityQuery.AddRequirement<FMassSimulationVariableTickFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);
	EntityQuery.AddChunkRequirement<FMassSimulationVariableTickChunkFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);
	EntityQuery.SetChunkFilter(&FMassSimulationVariableTickChunkFragment::ShouldTickChunkThisFrame);
}

void UMassSimpleMovementProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntityManager, Context, ([this](FMassExecutionContext& Context)
		{
			const TConstArrayView<FMassVelocityFragment> VelocitiesList = Context.GetFragmentView<FMassVelocityFragment>();
			const TArrayView<FTransformFragment> TransformsList = Context.GetMutableFragmentView<FTransformFragment>();
			const TConstArrayView<FMassSimulationVariableTickFragment> SimVariableTickList = Context.GetFragmentView<FMassSimulationVariableTickFragment>();
			const bool bHasVariableTick = (SimVariableTickList.Num() > 0);
			const float WorldDeltaTime = Context.GetDeltaTimeSeconds();
		
			for (int32 EntityIndex = 0; EntityIndex < Context.GetNumEntities(); ++EntityIndex)
			{
				const FMassVelocityFragment& Velocity = VelocitiesList[EntityIndex];
				FTransform& Transform = TransformsList[EntityIndex].GetMutableTransform();
				const float DeltaTime = bHasVariableTick ? SimVariableTickList[EntityIndex].DeltaTime : WorldDeltaTime;
				Transform.SetTranslation(Transform.GetTranslation() + Velocity.Value * DeltaTime);
			}
		}));
}

===============================================================


=== Source/MassMovement/Private/MassVelocityRandomizerTrait.cpp ===
===================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "Example/MassVelocityRandomizerTrait.h"
#include "MassEntityTemplateRegistry.h"
#include "MassExecutionContext.h"
#include "Engine/World.h"
#include "MassMovementFragments.h"
#include "MassCommonUtils.h"

//----------------------------------------------------------------------//
//  UMassVelocityRandomizerTrait
//----------------------------------------------------------------------//
void UMassVelocityRandomizerTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	FMassVelocityFragment& VelocityTemplate = BuildContext.AddFragment_GetRef<FMassVelocityFragment>();
	// This is a small @hack to support sending parameters to initializer.
	// A proper solution will allow users to specify a "lambda" initializer that will be used during creation
	VelocityTemplate.Value.X = MinSpeed;
	VelocityTemplate.Value.Y = MaxSpeed;
	VelocityTemplate.Value.Z = bSetZComponent ? 1.f : 0.f;
}

//----------------------------------------------------------------------//
//  UMassRandomVelocityInitializer
//----------------------------------------------------------------------//
UMassRandomVelocityInitializer::UMassRandomVelocityInitializer()
	: EntityQuery(*this)
{
	ObservedType = FMassVelocityFragment::StaticStruct();
	Operation = EMassObservedOperation::Add;
	RandomStream.Initialize(UE::Mass::Utils::GenerateRandomSeed());
}

void UMassRandomVelocityInitializer::ConfigureQueries()
{
	EntityQuery.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadWrite);
}

void UMassRandomVelocityInitializer::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	// note: the author is aware that the vectors produced below are not distributed uniformly, but it's good enough
	EntityQuery.ForEachEntityChunk(EntityManager, Context, ([this](FMassExecutionContext& Context)
		{
			const TArrayView<FMassVelocityFragment> VelocitiesList = Context.GetMutableFragmentView<FMassVelocityFragment>();
			for (FMassVelocityFragment& VelocityFragment : VelocitiesList)
			{
				// the given VelocityFragment's value is encoding the initialization parameters, as per comment in
				// UMassVelocityRandomizerTrait::BuildTemplate
				const FVector RandomVector = VelocityFragment.Value.Z != 0.f 
					? FVector(RandomStream.FRandRange(-1.f, 1.f), RandomStream.FRandRange(-1.f, 1.f), RandomStream.FRandRange(-1.f, 1.f)).GetSafeNormal()
					: FVector(RandomStream.FRandRange(-1.f, 1.f), RandomStream.FRandRange(-1.f, 1.f), 0).GetSafeNormal();

				VelocityFragment.Value = RandomVector * RandomStream.FRandRange(VelocityFragment.Value.X, VelocityFragment.Value.Y);
			}
		}));
}

===================================================================


=== Source/MassMovement/Public/Example/MassSimpleMovementTrait.h ===
====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "MassEntityTraitBase.h"
#include "MassProcessor.h"
#include "MassSimpleMovementTrait.generated.h"


USTRUCT()
struct FMassSimpleMovementTag : public FMassTag
{
	GENERATED_BODY()
};


UCLASS(meta = (DisplayName = "Simple Movement"))
class MASSMOVEMENT_API UMassSimpleMovementTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;
};


UCLASS()
class MASSMOVEMENT_API UMassSimpleMovementProcessor : public UMassProcessor
{
	GENERATED_BODY()
public:
	UMassSimpleMovementProcessor();
		
protected:	
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};

====================================================================


=== Source/MassMovement/Public/Example/MassVelocityRandomizerTrait.h ===
========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTraitBase.h"
#include "MassObserverProcessor.h"
#include "MassVelocityRandomizerTrait.generated.h"


class UMassRandomVelocityInitializer;

UCLASS(meta = (DisplayName = "Velocity Randomizer"))
class MASSMOVEMENT_API UMassVelocityRandomizerTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;

	/** The speed is expressed in UnrealUnits per second, which usually translates to 0.01m/s */
	UPROPERTY(Category = "Velocity", EditAnywhere, meta = (UIMin = 0.0, ClampMin = 0.0))
	float MinSpeed = 0.f;

	/** The speed is expressed in UnrealUnits per second, which usually translates to 0.01m/s */
	UPROPERTY(Category = "Velocity", EditAnywhere, meta = (UIMin = 1.0, ClampMin = 1.0))
	float MaxSpeed = 200.f;

	UPROPERTY(Category = "Velocity", EditAnywhere)
	bool bSetZComponent = false;
};


UCLASS()
class MASSMOVEMENT_API UMassRandomVelocityInitializer : public UMassObserverProcessor
{
	GENERATED_BODY()
public:
	UMassRandomVelocityInitializer();

	void SetParameters(const float InMinSpeed, const float InMaxSpeed, const bool bInSetZComponent);

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;

	UPROPERTY()
	float MinSpeed = 0.f;

	/** The default max is set to 0 to enforce explicit configuration via SetParameters call. */
	UPROPERTY()
	float MaxSpeed = 0.f;

	UPROPERTY()
	bool bSetZComponent = false;
	FRandomStream RandomStream;
};

========================================================================


=== Source/MassMovement/Public/Movement/MassMovementProcessors.h ===
====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassProcessor.h"
#include "MassMovementProcessors.generated.h"

/**
 * Updates entities position based on force and velocity.
 * Not applied on Off-LOD entities.
 */
UCLASS()
class MASSMOVEMENT_API UMassApplyMovementProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassApplyMovementProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

private:
	FMassEntityQuery EntityQuery;
};

====================================================================


=== Source/MassMovement/Public/Movement/MassMovementTrait.h ===
===============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "MassEntityTraitBase.h"
#include "MassMovementFragments.h"
#include "MassMovementTrait.generated.h"

UCLASS(meta = (DisplayName = "Movement"))
class MASSMOVEMENT_API UMassMovementTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;

	UPROPERTY(Category="Movement", EditAnywhere)
	FMassMovementParameters Movement;
};

===============================================================


=== Source/MassMovement/Public/IMassMovementModule.h ===
========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleInterface.h"
#include "Modules/ModuleManager.h"


/**
 * The public interface to this module.  In most cases, this interface is only public to sibling modules 
 * within this plugin.
 */
class IMassMovementModule : public IModuleInterface
{

public:

	/**
	 * Singleton-like access to this module's interface.  This is just for convenience!
	 * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.
	 *
	 * @return Returns singleton instance, loading the module on demand if needed
	 */
	static inline IMassMovementModule& Get()
	{
		return FModuleManager::LoadModuleChecked<IMassMovementModule>( "MassMovement" );
	}

	/**
	 * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.
	 *
	 * @return True if the module is loaded and ready to use
	 */
	static inline bool IsAvailable()
	{
		return FModuleManager::Get().IsModuleLoaded( "MassMovement" );
	}
};


========================================================


=== Source/MassMovement/Public/MassMovementDelegates.h ===
==========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"

namespace UE::MassMovement::Delegates
{
#if WITH_EDITOR
	/** Called when movement names have changed (UI update). */
	DECLARE_MULTICAST_DELEGATE(FOnMassMovementNamesChanged);
	extern MASSMOVEMENT_API FOnMassMovementNamesChanged OnMassMovementNamesChanged;
#endif // WITH_EDITOR
} // UE::MassMovement::Delegates

==========================================================


=== Source/MassMovement/Public/MassMovementFragments.h ===
==========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "MassCommonTypes.h"
#include "MassMovementTypes.h"
#include "RandomSequence.h"
#include "MassMovementFragments.generated.h"

USTRUCT()
struct MASSMOVEMENT_API FMassVelocityFragment : public FMassFragment
{
	GENERATED_BODY()

	FVector Value = FVector::ZeroVector;
};

USTRUCT()
struct MASSMOVEMENT_API FMassForceFragment : public FMassFragment
{
	GENERATED_BODY()

	FVector Value = FVector::ZeroVector;
};

USTRUCT()
struct MASSMOVEMENT_API FMassMovementParameters : public FMassConstSharedFragment
{
	GENERATED_BODY()

	FMassMovementParameters GetValidated() const
	{
		FMassMovementParameters Copy = *this;
		Copy.Update();
		return Copy;
	}

	/** Updates internal values for faster desired speed generation. */
	void Update();

	/** Generates desired speed based on style and unique id. The id is used deterministically assign a specific speed range. */
	float GenerateDesiredSpeed(const FMassMovementStyleRef& Style, const int32 UniqueId) const
	{
		float DesiredSpeed = DefaultDesiredSpeed;
		float DesiredSpeedVariance = DefaultDesiredSpeedVariance;
		
		const FMassMovementStyleParameters* StyleParams = MovementStyles.FindByPredicate([&Style](const FMassMovementStyleParameters& Config)
			{
				return Config.Style.ID == Style.ID;
			});
		
		if (StyleParams != nullptr)
		{
			const float Prob = UE::RandomSequence::FRand(UniqueId);
			for (const FMassMovementStyleSpeedParameters& Speed : StyleParams->DesiredSpeeds)
			{
				if (Prob < Speed.ProbabilityThreshold)
				{
					DesiredSpeed = Speed.Speed;
					DesiredSpeedVariance = Speed.Variance;
					break;
				}
			}
		}
		
		return DesiredSpeed * UE::RandomSequence::RandRange(UniqueId, 1.0f - DesiredSpeedVariance, 1.0f + DesiredSpeedVariance);;
	}
	
	/** Maximum speed (cm/s). */
	UPROPERTY(EditAnywhere, Category = "Movement", meta = (ClampMin = "0", ForceUnits="cm/s"))
	float MaxSpeed = 200.f;

	/** 200..600 Smaller steering maximum acceleration makes the steering more \"calm\" but less opportunistic, may not find solution, or gets stuck. */
	UPROPERTY(config, EditAnywhere, Category = "Movement", meta = (UIMin = 0.0, ClampMin = 0.0, ForceUnits="cm/s^2"))
	float MaxAcceleration = 250.f;

	/** Default desired speed (cm/s). */
	UPROPERTY(EditAnywhere, Category = "Movement", meta = (ClampMin = "0", ForceUnits="cm/s"))
	float DefaultDesiredSpeed = 140.f;

	/** How much default desired speed is varied randomly. */
	UPROPERTY(EditAnywhere, Category = "Movement", meta = (ClampMin = "0", ClampMax = "1"))
	float DefaultDesiredSpeedVariance = 0.1f;

	/** The time it takes the entity position to catchup to the requested height. */
	UPROPERTY(EditAnywhere, Category = "Movement", meta = (ClampMin = "0.0", ForceUnits="s"))
	float HeightSmoothingTime = 0.2f;

	/** List of supported movement styles for this configuration. */
	UPROPERTY(EditAnywhere, Category = "Movement")
	TArray<FMassMovementStyleParameters> MovementStyles;
};

==========================================================


=== Source/MassMovement/Public/MassMovementSettings.h ===
=========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "MassSettings.h"
#include "MassMovementTypes.h"
#include "MassMovementSettings.generated.h"

UCLASS(config = Mass, defaultconfig, meta = (DisplayName = "Mass Movement"))
class MASSMOVEMENT_API UMassMovementSettings : public UMassModuleSettings
{
	GENERATED_BODY()

public:
	UMassMovementSettings(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
	
	static const UMassMovementSettings* Get()
	{
		return GetDefault<UMassMovementSettings>();
	}

	TConstArrayView<FMassMovementStyle> GetMovementStyles() const { return MovementStyles; }
	const FMassMovementStyle* GetMovementStyleByID(const FGuid ID) const; 
	
private:

#if WITH_EDITOR
	virtual void PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent) override;
#endif

	UPROPERTY(EditAnywhere, config, Category = Movement);
    TArray<FMassMovementStyle> MovementStyles;
};

=========================================================


=== Source/MassMovement/Public/MassMovementTypes.h ===
======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreTypes.h"
#include "MassMovementTypes.generated.h"

namespace UE::MassMovement
{
	extern MASSMOVEMENT_API int32 bFreezeMovement;
};

/** Reference to movement style in MassMovementSettings. */
USTRUCT()
struct MASSMOVEMENT_API FMassMovementStyleRef
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = "Movement")
	FName Name;

	UPROPERTY(EditAnywhere, Category = "Movement", meta = (IgnoreForMemberInitializationTest, EditCondition = "false", EditConditionHides))
	FGuid ID;
};

/** Describes movement style name. */
USTRUCT()
struct MASSMOVEMENT_API FMassMovementStyle
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = "Movement")
	FName Name;

	UPROPERTY(EditAnywhere, Category = "Movement", meta = (IgnoreForMemberInitializationTest, EditCondition = "false", EditConditionHides))
	FGuid ID;
};

/**
 * Movement style consists of multiple speeds which are assigned to agents based on agents unique ID.
 * Same speed is assigned consistently for the same ID.
 */
USTRUCT()
struct MASSMOVEMENT_API FMassMovementStyleSpeedParameters
{
	GENERATED_BODY()

	/** Desired speed */
	UPROPERTY(EditAnywhere, Category = "Movement Style", meta = (UIMin = 0.0, ClampMin = 0.0, ForceUnits="cm/s"))
	float Speed = 140.0f;

	/** How much default desired speed is varied randomly. */
	UPROPERTY(EditAnywhere, Category = "Movement Style", meta = (ClampMin = 0.0, ClampMax = 1.0))
	float Variance = 0.1f;

	/** Probability to assign this speed. */
	UPROPERTY(EditAnywhere, Category = "Movement Style", meta = (UIMin = 1, ClampMin = 1, UIMax = 100, ClampMax = 100))
	float Probability = 1.0f;

	/** Probability threshold for this style, used to faster lookup. Update via FMassMovementConfig::Update(). */
	float ProbabilityThreshold = 0.0f;
};

/** Movement style parameters. A movement style abstracts movement properties for specific style. Behaviors can refer to specific styles when handling speeds. */
USTRUCT()
struct MASSMOVEMENT_API FMassMovementStyleParameters
{
	GENERATED_BODY()

	/** Style of the movement */
	UPROPERTY(EditAnywhere, Category = "Movement Style")
	FMassMovementStyleRef Style;

	/** Array of desired speeds (cm/s) assigned to agents based on probability. */
	UPROPERTY(EditAnywhere, Category = "Movement Style")
	TArray<FMassMovementStyleSpeedParameters> DesiredSpeeds;
};



======================================================


=== Source/MassMovement/MassMovement.Build.cs ===
=================================================

// Copyright Epic Games, Inc. All Rights Reserved.

namespace UnrealBuildTool.Rules
{
	public class MassMovement : ModuleRules
	{
		public MassMovement(ReadOnlyTargetRules Target) : base(Target)
		{
			PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

			UnsafeTypeCastWarningLevel = WarningLevel.Warning;

			PublicDependencyModuleNames.AddRange(
				new string[] {
					"AIModule",
					"MassEntity",
					"Core",
					"CoreUObject",
					"Engine",
					"MassCommon",
					"MassLOD",
					"MassSignals",
					"MassSpawner",
					"NavigationSystem",
					"ZoneGraph",
					"ZoneGraphAnnotations",
				}
			);

			if (Target.bBuildEditor == true)
			{
				PrivateDependencyModuleNames.Add("EditorFramework");
				PrivateDependencyModuleNames.Add("UnrealEd");
			}
		}
	}
}

=================================================


=== Source/MassMovementEditor/Private/MassMovementEditorModule.cpp ===
======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassMovementEditorModule.h"
#include "AssetToolsModule.h"
#include "MassMovementStyleRefDetails.h"
#include "Modules/ModuleManager.h"
#include "PropertyEditorModule.h"
#include "ToolMenus.h"

#define LOCTEXT_NAMESPACE "MassMovementEditor"

IMPLEMENT_MODULE(FMassMovementEditorModule, MassMovementEditor)

void FMassMovementEditorModule::StartupModule()
{
	// Register the details customizer
	FPropertyEditorModule& PropertyModule = FModuleManager::LoadModuleChecked<FPropertyEditorModule>("PropertyEditor");
	PropertyModule.RegisterCustomPropertyTypeLayout(TEXT("MassMovementStyleRef"), FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FMassMovementStyleRefDetails::MakeInstance));
}

void FMassMovementEditorModule::ShutdownModule()
{
	UToolMenus::UnRegisterStartupCallback(this);
	UToolMenus::UnregisterOwner(this);

	if (FModuleManager::Get().IsModuleLoaded(TEXT("PropertyEditor")))
	{
		FPropertyEditorModule& PropertyModule = FModuleManager::GetModuleChecked<FPropertyEditorModule>(TEXT("PropertyEditor"));
		PropertyModule.UnregisterCustomPropertyTypeLayout(TEXT("MassMovementStyleRef"));
	}
}

#undef LOCTEXT_NAMESPACE

======================================================================


=== Source/MassMovementEditor/Private/MassMovementStyleRefDetails.cpp ===
=========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.
#include "MassMovementStyleRefDetails.h"
#include "Widgets/DeclarativeSyntaxSupport.h"
#include "DetailWidgetRow.h"
#include "DetailLayoutBuilder.h"
#include "IPropertyUtilities.h"
#include "IDetailChildrenBuilder.h"
#include "Widgets/Input/SComboButton.h"
#include "Framework/MultiBox/MultiBoxBuilder.h"
#include "ScopedTransaction.h"
#include "MassSettings.h"
#include "MassMovementSettings.h"
#include "Modules/ModuleManager.h"
#include "ISettingsModule.h"
#include "MassMovementPropertyUtils.h"

#define LOCTEXT_NAMESPACE "MassMovementEditor"

TSharedRef<IPropertyTypeCustomization> FMassMovementStyleRefDetails::MakeInstance()
{
	return MakeShareable(new FMassMovementStyleRefDetails);
}

void FMassMovementStyleRefDetails::CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{
	StructProperty = StructPropertyHandle;
	PropUtils = StructCustomizationUtils.GetPropertyUtilities().Get();
	
	NameProperty = StructProperty->GetChildHandle(TEXT("Name"));
	IDProperty = StructProperty->GetChildHandle(TEXT("ID"));

	HeaderRow
		.NameContent()
		[
			StructPropertyHandle->CreatePropertyNameWidget()
		]
		.ValueContent()
		[
			SNew(SComboButton)
			.OnGetMenuContent(this, &FMassMovementStyleRefDetails::OnGetProfileContent)
			.ButtonContent()
			[
				SNew(STextBlock)
				.Text(this, &FMassMovementStyleRefDetails::GetCurrentProfileDesc)
				.Font(IDetailLayoutBuilder::GetDetailFont())
			]
		];
}

void FMassMovementStyleRefDetails::CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder& StructBuilder, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{
}

void FMassMovementStyleRefDetails::OnProfileComboChange(int32 Idx)
{
	if (Idx == -1)
	{
		const UMassSettings* MassSettings = GetDefault<UMassSettings>();
		check(MassSettings);
		
		// Goto settings to create new Profile
		FModuleManager::LoadModuleChecked<ISettingsModule>("Settings").ShowViewer(MassSettings->GetContainerName(), MassSettings->GetCategoryName(), MassSettings->GetSectionName());
		return;
	}

	const UMassMovementSettings* MovementSettings = GetDefault<UMassMovementSettings>();
	check(MovementSettings);

	TConstArrayView<FMassMovementStyle> MovementStyles = MovementSettings->GetMovementStyles();
	if (MovementStyles.IsValidIndex(Idx))
	{
		const FMassMovementStyle& Style = MovementStyles[Idx];

		FScopedTransaction Transaction(FText::Format(LOCTEXT("SetPropertyValue", "Set {0}"), StructProperty->GetPropertyDisplayName()));

		if (NameProperty)
		{
			NameProperty->SetValue(Style.Name, EPropertyValueSetFlags::NotTransactable);
		}

		if (IDProperty)
		{
			UE::MassMovement::PropertyUtils::SetValue<FGuid>(IDProperty, Style.ID, EPropertyValueSetFlags::NotTransactable);
		}

		if (PropUtils)
		{
			PropUtils->ForceRefresh();
		}
	}
}

TSharedRef<SWidget> FMassMovementStyleRefDetails::OnGetProfileContent() const
{
	FMenuBuilder MenuBuilder(true, NULL);
	const UMassMovementSettings* Settings = GetDefault<UMassMovementSettings>();
	check(Settings);

	FUIAction NewItemAction(FExecuteAction::CreateSP(const_cast<FMassMovementStyleRefDetails*>(this), &FMassMovementStyleRefDetails::OnProfileComboChange, -1));
	MenuBuilder.AddMenuEntry(LOCTEXT("CreateOrEditStyles", "Create or Edit Movement Style..."), TAttribute<FText>(), FSlateIcon(), NewItemAction);
	MenuBuilder.AddMenuSeparator();

	TConstArrayView<FMassMovementStyle> MovementStyles = Settings->GetMovementStyles();
	for (int32 Index = 0; Index < MovementStyles.Num(); Index++)
	{
		const FMassMovementStyle& Style = MovementStyles[Index];
		FUIAction ItemAction(FExecuteAction::CreateSP(const_cast<FMassMovementStyleRefDetails*>(this), &FMassMovementStyleRefDetails::OnProfileComboChange, Index));
		MenuBuilder.AddMenuEntry(FText::FromName(Style.Name), TAttribute<FText>(), FSlateIcon(), ItemAction);
	}
	return MenuBuilder.MakeWidget();
}

FText FMassMovementStyleRefDetails::GetCurrentProfileDesc() const
{
	TOptional<FGuid> IDOpt = UE::MassMovement::PropertyUtils::GetValue<FGuid>(IDProperty);
	if (IDOpt.IsSet())
	{
		const FGuid ID = IDOpt.GetValue();
		if (ID.IsValid())
		{
			const UMassMovementSettings* Settings = GetDefault<UMassMovementSettings>();
			check(Settings);
			
			const FMassMovementStyle* Style = Settings->GetMovementStyleByID(ID);
			if (Style)
			{
				return FText::FromName(Style->Name);
			}
			else
			{
				FName OldProfileName;
				if (NameProperty && NameProperty->GetValue(OldProfileName) == FPropertyAccess::Success)
				{
					FFormatNamedArguments Args;
					Args.Add(TEXT("Identifier"), FText::FromName(OldProfileName));
					return FText::Format(LOCTEXT("InvalidStyle", "Invalid Style {Identifier}"), Args);
				}
			}
		}
		else
		{
			return LOCTEXT("Invalid", "Invalid");
		}
	}
	// TODO: handle multiple values
	return FText();
}

#undef LOCTEXT_NAMESPACE
=========================================================================


=== Source/MassMovementEditor/Public/IMassMovementEditor.h ===
==============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Toolkits/AssetEditorToolkit.h"

/** MassMovement Editor public interface */
class MASSMOVEMENTEDITOR_API IMassMovementEditor : public FAssetEditorToolkit
{
public:

};



==============================================================


=== Source/MassMovementEditor/Public/MassMovementEditorModule.h ===
===================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma  once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"
#include "AssetTypeCategories.h"
#include "Toolkits/IToolkitHost.h"
#include "Toolkits/AssetEditorToolkit.h"


class IMassMovementEditor;

/**
* The public interface to this module
*/
class MASSMOVEMENTEDITOR_API FMassMovementEditorModule : public IModuleInterface//, public IHasMenuExtensibility, public IHasToolBarExtensibility
{
public:
	// Begin IModuleInterface
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;

private:
};

===================================================================


=== Source/MassMovementEditor/Public/MassMovementPropertyUtils.h ===
====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once
#include "CoreMinimal.h"
#include "Editor.h"
#include "PropertyHandle.h"

#define LOCTEXT_NAMESPACE "MassMovementEditor"

namespace UE::MassMovement::PropertyUtils
{

// Expects T is struct.
template<typename T>
TOptional<T> GetValue(const TSharedPtr<IPropertyHandle>& ValueProperty)
{
	if (!ValueProperty)
	{
		return TOptional<T>();
	}

	FStructProperty* StructProperty = CastFieldChecked<FStructProperty>(ValueProperty->GetProperty());
	if (!StructProperty)
	{
		return TOptional<T>();
	}
	if (StructProperty->Struct != TBaseStructure<T>::Get())
	{
		return TOptional<T>();
	}

	T Value = T();
	bool bValueSet = false;

	TArray<void*> RawData;
	ValueProperty->AccessRawData(RawData);
	for (void* Data : RawData)
	{
		if (Data)
		{
			T CurValue = *reinterpret_cast<T*>(Data);
			if (!bValueSet)
			{
				bValueSet = true;
				Value = CurValue;
			}
			else if (CurValue != Value)
			{
				// Multiple values
				return TOptional<T>();
			}
		}
	}

	return TOptional<T>(Value);
}

// Expects T is struct.
template<typename T>
void SetValue(TSharedPtr<IPropertyHandle>& ValueProperty, T NewValue, EPropertyValueSetFlags::Type Flags = 0)
{
	if (!ValueProperty)
	{
		return;
	}

	FStructProperty* StructProperty = CastFieldChecked<FStructProperty>(ValueProperty->GetProperty());
	if (!StructProperty)
	{
		return;
	}
	if (StructProperty->Struct != TBaseStructure<T>::Get())
	{
		return;
	}

	const bool bTransactable = (Flags & EPropertyValueSetFlags::NotTransactable) == 0;
	bool bNotifiedPreChange = false;
	TArray<void*> RawData;
	ValueProperty->AccessRawData(RawData);
	for (void* Data : RawData)
	{
		if (Data)
		{
			if (!bNotifiedPreChange)
			{
				if (bTransactable && GEditor)
				{
					GEditor->BeginTransaction(FText::Format(LOCTEXT("SetPropertyValue", "Set {0}"), ValueProperty->GetPropertyDisplayName()));
				}
				ValueProperty->NotifyPreChange();
				bNotifiedPreChange = true;
			}

			T* Value = reinterpret_cast<T*>(Data);
			*Value = NewValue;
		}
	}

	if (bNotifiedPreChange)
	{
		ValueProperty->NotifyPostChange(EPropertyChangeType::ValueSet);
		if (bTransactable && GEditor)
		{
			GEditor->EndTransaction();
		}
	}

	ValueProperty->NotifyFinishedChangingProperties();
}

} // UE::MassMovement::PropertyUtils

#undef LOCTEXT_NAMESPACE
====================================================================


=== Source/MassMovementEditor/Public/MassMovementStyleRefDetails.h ===
======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once
#include "CoreMinimal.h"
#include "UnrealClient.h"
#include "IPropertyTypeCustomization.h"

class IPropertyHandle;
class SWidget;

/**
 * Type customization for FMassMovementStyleRef.
 */
class FMassMovementStyleRefDetails : public IPropertyTypeCustomization
{
public:
	/** Makes a new instance of this detail layout class for a specific detail view requesting it */
	static TSharedRef<IPropertyTypeCustomization> MakeInstance();

	/** IPropertyTypeCustomization interface */
	virtual void CustomizeHeader(TSharedRef<IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils) override;
	virtual void CustomizeChildren(TSharedRef<IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder& StructBuilder, IPropertyTypeCustomizationUtils& StructCustomizationUtils) override;

private:

	void OnProfileComboChange(int32 Idx);
	TSharedRef<SWidget> OnGetProfileContent() const;
	FText GetCurrentProfileDesc() const;

	TSharedPtr<IPropertyHandle> NameProperty;
	TSharedPtr<IPropertyHandle> IDProperty;
	TSharedPtr<IPropertyHandle> LanesProperty;

	class IPropertyUtilities* PropUtils = nullptr;
	TSharedPtr<IPropertyHandle> StructProperty;
};
======================================================================


=== Source/MassMovementEditor/MassMovementEditor.Build.cs ===
=============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

namespace UnrealBuildTool.Rules
{
	public class MassMovementEditor : ModuleRules
	{
		public MassMovementEditor(ReadOnlyTargetRules Target) : base(Target)
		{
			PublicIncludePaths.AddRange(
			new string[] {
			}
			);

			PublicDependencyModuleNames.AddRange(
			new string[] {
				"Core",
				"CoreUObject",
				"Engine",
				"InputCore",
				"AssetTools",
				"EditorFramework",
				"UnrealEd",
				"RHI",
				"Slate",
				"SlateCore",
				
				"PropertyEditor",
				"DetailCustomizations",
				"MassEntity",
				"MassCommon",
				"MassMovement",
			}
			);

			PrivateDependencyModuleNames.AddRange(
			new string[] {
				"RenderCore",
				"KismetWidgets",
				"ToolMenus",
				"AppFramework",
				"Projects",
			}
			);
		}

	}
}

=============================================================


=== Source/MassReplication/Private/MassClientBubbleInfoBase.cpp ===
===================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassClientBubbleInfoBase.h"
#include "MassClientBubbleSerializerBase.h"
#include "MassClientBubbleHandler.h"

AMassClientBubbleInfoBase::AMassClientBubbleInfoBase(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	bReplicates = true;
	bOnlyRelevantToOwner = true;
	bNetUseOwnerRelevancy = true;

	PrimaryActorTick.bCanEverTick = true;
	PrimaryActorTick.TickGroup = TG_LastDemotable;
	PrimaryActorTick.bStartWithTickEnabled = false;
}

void AMassClientBubbleInfoBase::SetClientHandle(FMassClientHandle InClientHandle)
{
	for (const FMassClientBubbleSerializerBase* Serializer : Serializers)
	{
		check(Serializer->GetClientHandler());

		Serializer->GetClientHandler()->SetClientHandle(InClientHandle);
	}
}

void AMassClientBubbleInfoBase::PostInitProperties()
{
	Super::PostInitProperties();

	if (HasAnyFlags(RF_ClassDefaultObject) == false)
	{
		UWorld* World = GetWorld();
		// This logic can't be done in BeginPlay() as the FMassClientBubbleSerializer::PostReplicatedAdd / PostReplicatedChange will already have been called
		// but it does need to be done after the world has been initialized.
		if (World != nullptr && World->bIsWorldInitialized)
		{
			InitializeForWorld(*World);
		}
		else
		{
			OnPostWorldInitDelegateHandle = FWorldDelegates::OnPostWorldInitialization.AddUObject(this, &AMassClientBubbleInfoBase::OnPostWorldInit);
		}
	}
}

void AMassClientBubbleInfoBase::OnPostWorldInit(UWorld* World, const UWorld::InitializationValues)
{
	if (World == GetWorld())
	{
		FWorldDelegates::OnPostWorldInitialization.Remove(OnPostWorldInitDelegateHandle);
		InitializeForWorld(*World);
	}
}

void AMassClientBubbleInfoBase::InitializeForWorld(UWorld& World)
{
	for (const FMassClientBubbleSerializerBase* Serializer : Serializers)
	{
		IClientBubbleHandlerInterface* Handler = Serializer->GetClientHandler();

		checkf(Handler, TEXT("Handler not set up. Call TClientBubbleHandlerBase::Initialize() before InitializeForWorld gets called"));
		Handler->InitializeForWorld(World);
	}
}

void AMassClientBubbleInfoBase::BeginPlay()
{
	Super::BeginPlay();

	UWorld* World = GetWorld();
	check(World);

	// Allow tick function WITH_MASSGAMEPLAY_DEBUG as we have debug functionality there, otherwise only on the clients.
#if WITH_MASSGAMEPLAY_DEBUG
	PrimaryActorTick.SetTickFunctionEnable(true);
#else
	if (World && World->GetNetMode() == NM_Client)
	{
		PrimaryActorTick.SetTickFunctionEnable(true);
	}
#endif // WITH_MASSGAMEPLAY_DEBUG
}

void AMassClientBubbleInfoBase::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	for (FMassClientBubbleSerializerBase* Serializer : Serializers)
	{
		if (ensure(Serializer))
		{
			Serializer->ShutDown();

			check(Serializer->GetClientHandler());
			Serializer->GetClientHandler()->Reset();
		}
	}

	Super::EndPlay(EndPlayReason);
}

void AMassClientBubbleInfoBase::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	for (const FMassClientBubbleSerializerBase* Serializer : Serializers)
	{
		check(Serializer->GetClientHandler());

		Serializer->GetClientHandler()->Tick(DeltaTime);
	}
}

===================================================================


=== Source/MassReplication/Private/MassClientBubbleSerializerBase.cpp ===
=========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassClientBubbleSerializerBase.h"
#include "MassClientBubbleHandler.h"
#include "MassEntityUtils.h"


void FMassClientBubbleSerializerBase::ShutDown()
{
	EntityManager = nullptr;
	World = nullptr;
	SpawnerSubsystem = nullptr;
	ReplicationSubsystem = nullptr;
}

void FMassClientBubbleSerializerBase::InitializeForWorld(UWorld& InWorld)
{
	World = &InWorld;

	SpawnerSubsystem = InWorld.GetSubsystem<UMassSpawnerSubsystem>();
	check(SpawnerSubsystem);

	ReplicationSubsystem = InWorld.GetSubsystem<UMassReplicationSubsystem>();

	EntityManager = UE::Mass::Utils::GetEntityManagerChecked(InWorld).AsShared();

	checkf(ClientHandler, TEXT("ClientHandler must be setup! See SetClientHandler()"));
}

#if UE_REPLICATION_COMPILE_CLIENT_CODE
void FMassClientBubbleSerializerBase::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize) const
{
	check(ClientHandler);

	ClientHandler->PreReplicatedRemove(RemovedIndices, FinalSize);
}

void FMassClientBubbleSerializerBase::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize) const
{
	check(ClientHandler);

	ClientHandler->PostReplicatedAdd(AddedIndices, FinalSize);
}

void FMassClientBubbleSerializerBase::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize) const
{
	check(ClientHandler);

	ClientHandler->PostReplicatedChange(ChangedIndices, FinalSize);
}
#endif //UE_REPLICATION_COMPILE_CLIENT_CODE

=========================================================================


=== Source/MassReplication/Private/MassReplicationFragments.cpp ===
===================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassReplicationFragments.h"
#include "MassReplicationSubsystem.h"
#include "MassReplicationProcessor.h"
#include "MassExecutionContext.h"
#include "Engine/World.h"

//----------------------------------------------------------------------//
// UMassNetworkIDFragmentInitializer 
//----------------------------------------------------------------------//
UMassNetworkIDFragmentInitializer::UMassNetworkIDFragmentInitializer()
	: EntityQuery(*this)
{
	ExecutionFlags = (int32)(EProcessorExecutionFlags::Standalone | EProcessorExecutionFlags::Server);
	ObservedType = FMassNetworkIDFragment::StaticStruct();
	Operation = EMassObservedOperation::Add;
}

void UMassNetworkIDFragmentInitializer::ConfigureQueries()
{
	EntityQuery.AddRequirement<FMassNetworkIDFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddSubsystemRequirement<UMassReplicationSubsystem>(EMassFragmentAccess::ReadWrite);
}

void UMassNetworkIDFragmentInitializer::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	QUICK_SCOPE_CYCLE_COUNTER(MassProcessor_InitNetworkID_Run);

	const UWorld* World = EntityManager.GetWorld();
	const ENetMode NetMode = World->GetNetMode();

	if (NetMode != NM_Client)
	{
#if UE_REPLICATION_COMPILE_SERVER_CODE
		EntityQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)
			{
				UMassReplicationSubsystem& ReplicationSubsystem = Context.GetMutableSubsystemChecked<UMassReplicationSubsystem>();

				const TArrayView<FMassNetworkIDFragment> NetworkIDList = Context.GetMutableFragmentView<FMassNetworkIDFragment>();
				const int32 NumEntities = Context.GetNumEntities();

				for (int32 Idx = 0; Idx < NumEntities; ++Idx)
				{
					NetworkIDList[Idx].NetID = ReplicationSubsystem.GetNextAvailableMassNetID();
				}
			});
#endif //UE_REPLICATION_COMPILE_SERVER_CODE
	}
}

//----------------------------------------------------------------------//
//  FMassReplicationParameters
//----------------------------------------------------------------------//

FMassReplicationParameters::FMassReplicationParameters()
{
	LODDistance[EMassLOD::High] = 0.f;
	LODDistance[EMassLOD::Medium] = 1000.f;
	LODDistance[EMassLOD::Low] = 2500.f;
	LODDistance[EMassLOD::Off] = 5000.f;

	LODMaxCount[EMassLOD::High] = 1600;
	LODMaxCount[EMassLOD::Medium] = 3200;
	LODMaxCount[EMassLOD::Low] = 48000;
	LODMaxCount[EMassLOD::Off] = 0;

	LODMaxCountPerViewer[EMassLOD::High] = 100;
	LODMaxCountPerViewer[EMassLOD::Medium] = 200;
	LODMaxCountPerViewer[EMassLOD::Low] = 300;
	LODMaxCountPerViewer[EMassLOD::Off] = 0;

	UpdateInterval[EMassLOD::High] = 0.1f;
	UpdateInterval[EMassLOD::Medium] = 0.2f;
	UpdateInterval[EMassLOD::Low] = 0.3f;
	UpdateInterval[EMassLOD::Off] = 0.5f;
}

//----------------------------------------------------------------------//
//  FMassReplicationSharedFragment
//----------------------------------------------------------------------//
FMassReplicationSharedFragment::FMassReplicationSharedFragment(UMassReplicationSubsystem& ReplicationSubsystem, const FMassReplicationParameters& Params)
{
	LODCalculator.Initialize(Params.LODDistance, Params.BufferHysteresisOnDistancePercentage / 100.0f, Params.LODMaxCountPerViewer); // Setting the LODMaxCoundPerViewer as the MAXCount as the processor will be called for each client and will recalculate it per client
	BubbleInfoClassHandle = ReplicationSubsystem.GetBubbleInfoClassHandle(Params.BubbleInfoClass);

	CachedReplicator = Params.ReplicatorClass.GetDefaultObject();
	checkf(CachedReplicator, TEXT("Expecting a valid replicator class"))
}
===================================================================


=== Source/MassReplication/Private/MassReplicationGridProcessor.cpp ===
=======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassReplicationGridProcessor.h"
#include "MassReplicationSubsystem.h"
#include "MassReplicationTypes.h"
#include "MassReplicationFragments.h"
#include "MassCommonFragments.h"
#include "MassExecutionContext.h"
#include "Engine/World.h"

//----------------------------------------------------------------------//
//  UMassReplicationGridProcessor
//----------------------------------------------------------------------//
UMassReplicationGridProcessor::UMassReplicationGridProcessor()
	: AddToGridEntityQuery(*this)
	, UpdateGridEntityQuery(*this)
	, RemoveFromGridEntityQuery(*this)
{
#if !UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE
	ExecutionFlags = int32(EProcessorExecutionFlags::Server);
#else
	ExecutionFlags = int32(EProcessorExecutionFlags::AllNetModes);
#endif // UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE

	ProcessingPhase = EMassProcessingPhase::PostPhysics;
}

void UMassReplicationGridProcessor::ConfigureQueries()
{
	AddToGridEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	AddToGridEntityQuery.AddRequirement<FMassReplicationGridCellLocationFragment>(EMassFragmentAccess::ReadWrite);
	AddToGridEntityQuery.AddSubsystemRequirement<UMassReplicationSubsystem>(EMassFragmentAccess::ReadWrite);

	// copying AddToGridEntityQuery to RemoveFromGridEntityQuery now because RemoveFromGridEntityQuery doesn't utilize 
	// the other fragments AddToGridEntityQuery relies on
	RemoveFromGridEntityQuery = AddToGridEntityQuery;

	// FAgentRadiusFragment is optional since it's not strictly required for the provided functionality 
	AddToGridEntityQuery.AddRequirement<FAgentRadiusFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);
	// we don't care about "off-lod" entities
	AddToGridEntityQuery.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);

	// storing the state in UpdateGridEntityQuery, after that both queries diverge in terms of requirements
	UpdateGridEntityQuery = AddToGridEntityQuery;
		
	AddToGridEntityQuery.AddTagRequirement<FMassInReplicationGridTag>(EMassFragmentPresence::None);
		
	UpdateGridEntityQuery.AddTagRequirement<FMassInReplicationGridTag>(EMassFragmentPresence::All);

	RemoveFromGridEntityQuery.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::All);
	RemoveFromGridEntityQuery.AddTagRequirement<FMassInReplicationGridTag>(EMassFragmentPresence::All);
}

void UMassReplicationGridProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	AddToGridEntityQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)
	{
		UMassReplicationSubsystem& ReplicationSubsystem = Context.GetMutableSubsystemChecked<UMassReplicationSubsystem>();
		FReplicationHashGrid2D& ReplicationGrid = ReplicationSubsystem.GetGridMutable();
		const int32 NumEntities = Context.GetNumEntities();

		TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
		TConstArrayView<FAgentRadiusFragment> RadiusList = Context.GetFragmentView<FAgentRadiusFragment>();
		TArrayView<FMassReplicationGridCellLocationFragment> ReplicationCellLocationList = Context.GetMutableFragmentView<FMassReplicationGridCellLocationFragment>();

		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			// Add to the grid
			const FVector NewPos = LocationList[EntityIndex].GetTransform().GetLocation();
			// note that 0-radius is fine, the underlying THierarchicalHashGrid2D supports that just fine
			const float Radius = RadiusList.IsEmpty() ? 0.f : RadiusList[EntityIndex].Radius;

			const FMassEntityHandle EntityHandle = Context.GetEntity(EntityIndex);
			const FBox NewBounds(NewPos - FVector(Radius, Radius, 0.f), NewPos + FVector(Radius, Radius, 0.f));
			ReplicationCellLocationList[EntityIndex].CellLoc = ReplicationGrid.Add(EntityHandle, NewBounds);

			Context.Defer().AddTag<FMassInReplicationGridTag>(EntityHandle);
		}
	});

	UpdateGridEntityQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)
	{
		UMassReplicationSubsystem& ReplicationSubsystem = Context.GetMutableSubsystemChecked<UMassReplicationSubsystem>();
		FReplicationHashGrid2D& ReplicationGrid = ReplicationSubsystem.GetGridMutable();
		const int32 NumEntities = Context.GetNumEntities();

		TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
		TConstArrayView<FAgentRadiusFragment> RadiusList = Context.GetFragmentView<FAgentRadiusFragment>();
		TArrayView<FMassReplicationGridCellLocationFragment> ReplicationCellLocationList = Context.GetMutableFragmentView<FMassReplicationGridCellLocationFragment>();

		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			// Update position in grid
			const FVector NewPos = LocationList[EntityIndex].GetTransform().GetLocation();
			// note that 0-radius is fine, the underlying THierarchicalHashGrid2D supports that just fine
			const float Radius = RadiusList.IsEmpty() ? 0.f : RadiusList[EntityIndex].Radius;
			const FMassEntityHandle EntityHandle = Context.GetEntity(EntityIndex);
			const FBox NewBounds(NewPos - FVector(Radius, Radius, 0.f), NewPos + FVector(Radius, Radius, 0.f));
			ReplicationCellLocationList[EntityIndex].CellLoc = ReplicationGrid.Move(EntityHandle, ReplicationCellLocationList[EntityIndex].CellLoc, NewBounds);

#if WITH_MASSGAMEPLAY_DEBUG && 0
			const FDebugContext BaseDebugContext(this, LogMassReplication, nullptr, EntityHandle);
			if (DebugIsSelected(EntityHandle))
			{
				FBox Box = ReplicationGrid.CalcCellBounds(ReplicationCellLocationList[EntityIndex].CellLoc);
				Box.Max.Z += 200.f;
				DebugDrawBox(BaseDebugContext, Box, FColor::Yellow);
			}
#endif // WITH_MASSGAMEPLAY_DEBUG
		}
	});

	RemoveFromGridEntityQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)
	{
		UMassReplicationSubsystem& ReplicationSubsystem = Context.GetMutableSubsystemChecked<UMassReplicationSubsystem>();
		FReplicationHashGrid2D& ReplicationGrid = ReplicationSubsystem.GetGridMutable();
		const int32 NumEntities = Context.GetNumEntities();

		TArrayView<FMassReplicationGridCellLocationFragment> ReplicationCellLocationList = Context.GetMutableFragmentView<FMassReplicationGridCellLocationFragment>();
		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			const FMassEntityHandle EntityHandle = Context.GetEntity(EntityIndex);
			ReplicationGrid.Remove(EntityHandle, ReplicationCellLocationList[EntityIndex].CellLoc);
			ReplicationCellLocationList[EntityIndex].CellLoc = FReplicationHashGrid2D::FCellLocation();

			Context.Defer().RemoveTag<FMassInReplicationGridTag>(EntityHandle);
		}
	});
}

//----------------------------------------------------------------------//
//  UMassReplicationGridRemoverProcessor
//----------------------------------------------------------------------//
UMassReplicationGridRemoverProcessor::UMassReplicationGridRemoverProcessor()
	: EntityQuery(*this)
{
	ObservedType = FMassReplicationGridCellLocationFragment::StaticStruct();
	Operation = EMassObservedOperation::Remove;
	ExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;
}

void UMassReplicationGridRemoverProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FMassReplicationGridCellLocationFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddSubsystemRequirement<UMassReplicationSubsystem>(EMassFragmentAccess::ReadWrite);
}

void UMassReplicationGridRemoverProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)
	{
		UMassReplicationSubsystem& ReplicationSubsystem = Context.GetMutableSubsystemChecked<UMassReplicationSubsystem>();
		FReplicationHashGrid2D& ReplicationGrid = ReplicationSubsystem.GetGridMutable();
		const int32 NumEntities = Context.GetNumEntities();
		const TArrayView<FMassReplicationGridCellLocationFragment> ReplicationCellLocationList = Context.GetMutableFragmentView<FMassReplicationGridCellLocationFragment>();

		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			const FMassEntityHandle EntityHandle = Context.GetEntity(EntityIndex);
			ReplicationGrid.Remove(EntityHandle, ReplicationCellLocationList[EntityIndex].CellLoc);
			ReplicationCellLocationList[EntityIndex].CellLoc = FReplicationHashGrid2D::FCellLocation();
		}
	});
}
=======================================================================


=== Source/MassReplication/Private/MassReplicationModule.cpp ===
================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "CoreMinimal.h"
#include "IMassReplicationModule.h"


class FMassReplicationModule : public IMassReplicationModule
{
	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

IMPLEMENT_MODULE(FMassReplicationModule, MassReplication)



void FMassReplicationModule::StartupModule()
{
	// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)
}


void FMassReplicationModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}




================================================================


=== Source/MassReplication/Private/MassReplicationProcessor.cpp ===
===================================================================

// Copyright Epic Games, Inc. All Rights Reserved.UMassSimulationSettings

#include "MassReplicationProcessor.h"
#include "MassClientBubbleHandler.h"
#include "MassLODSubsystem.h"
#include "MassCommonFragments.h"
#include "MassExecutionContext.h"

namespace UE::Mass::Replication
{
	int32 DebugClientReplicationLOD = -1;
	FAutoConsoleVariableRef CVarDebugReplicationViewerLOD(TEXT("mass.debug.ClientReplicationLOD"), DebugClientReplicationLOD, TEXT("Debug Replication LOD of the specified client index"), ECVF_Cheat);
} // UE::Mass::Crowd

//----------------------------------------------------------------------//
//  UMassReplicationProcessor
//----------------------------------------------------------------------//
UMassReplicationProcessor::UMassReplicationProcessor()
	: SyncClientData(*this)
	, CollectViewerInfoQuery(*this)
	, CalculateLODQuery(*this)
	, AdjustLODDistancesQuery(*this)
	, EntityQuery(*this)
{
#if !UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE
	ExecutionFlags = int32(EProcessorExecutionFlags::Server);
#else
	ExecutionFlags = int32(EProcessorExecutionFlags::AllNetModes);
#endif // UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE

	ProcessingPhase = EMassProcessingPhase::PostPhysics;

	// Processor might need to create UObjects when synchronizing clients and viewers
	// (e.g. SpawnActor from UMassReplicationSubsystem::SynchronizeClientsAndViewers())
	bRequiresGameThreadExecution = true;
}

void UMassReplicationProcessor::ConfigureQueries()
{
	SyncClientData.AddRequirement<FMassReplicationLODFragment>(EMassFragmentAccess::ReadWrite);
	SyncClientData.AddRequirement<FMassReplicatedAgentFragment>(EMassFragmentAccess::ReadWrite);

	CollectViewerInfoQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	CollectViewerInfoQuery.AddRequirement<FMassReplicationViewerInfoFragment>(EMassFragmentAccess::ReadWrite);
	CollectViewerInfoQuery.AddSharedRequirement<FMassReplicationSharedFragment>(EMassFragmentAccess::ReadWrite);

	CalculateLODQuery.AddRequirement<FMassReplicationViewerInfoFragment>(EMassFragmentAccess::ReadOnly);
	CalculateLODQuery.AddRequirement<FMassReplicationLODFragment>(EMassFragmentAccess::ReadWrite);
	CalculateLODQuery.AddConstSharedRequirement<FMassReplicationParameters>();
	CalculateLODQuery.AddSharedRequirement<FMassReplicationSharedFragment>(EMassFragmentAccess::ReadWrite);

	AdjustLODDistancesQuery.AddRequirement<FMassReplicationViewerInfoFragment>(EMassFragmentAccess::ReadOnly);
	AdjustLODDistancesQuery.AddRequirement<FMassReplicationLODFragment>(EMassFragmentAccess::ReadWrite);
	AdjustLODDistancesQuery.AddSharedRequirement<FMassReplicationSharedFragment>(EMassFragmentAccess::ReadWrite);
	AdjustLODDistancesQuery.SetChunkFilter([](const FMassExecutionContext& Context)
	{
		const FMassReplicationSharedFragment& LODSharedFragment = Context.GetSharedFragment<FMassReplicationSharedFragment>();
		return LODSharedFragment.bHasAdjustedDistancesFromCount;
	});

	EntityQuery.AddRequirement<FMassNetworkIDFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FReplicationTemplateIDFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassReplicationLODFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FMassReplicatedAgentFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddConstSharedRequirement<FMassReplicationParameters>();
	EntityQuery.AddSharedRequirement<FMassReplicationSharedFragment>(EMassFragmentAccess::ReadWrite);

	ProcessorRequirements.AddSubsystemRequirement<UMassLODSubsystem>(EMassFragmentAccess::ReadOnly);
}

void UMassReplicationProcessor::Initialize(UObject& Owner)
{
	Super::Initialize(Owner);

#if UE_REPLICATION_COMPILE_SERVER_CODE
	UWorld* World = Owner.GetWorld();
	ReplicationSubsystem = UWorld::GetSubsystem<UMassReplicationSubsystem>(World);

	check(ReplicationSubsystem);
#endif //UE_REPLICATION_COMPILE_SERVER_CODE
}

void UMassReplicationProcessor::PrepareExecution(FMassEntityManager& EntityManager)
{
#if UE_REPLICATION_COMPILE_SERVER_CODE

	check(ReplicationSubsystem);

	//first synchronize clients and viewers
	ReplicationSubsystem->SynchronizeClientsAndViewers();

	EntityManager.ForEachSharedFragment<FMassReplicationSharedFragment>([this](FMassReplicationSharedFragment& RepSharedFragment)
	{
		if (!ensureMsgf(RepSharedFragment.BubbleInfoClassHandle.IsValid()
			, TEXT("BubbleInfoClassHandle is not valid which means no class has been indicated or the class used has not been registered pre creation of the handle.")))
		{
			return;
		}

		if (!RepSharedFragment.bEntityQueryInitialized)
		{
			RepSharedFragment.EntityQuery = EntityQuery;
			RepSharedFragment.EntityQuery.SetChunkFilter([&RepSharedFragment](const FMassExecutionContext& Context)
			{
				const FMassReplicationSharedFragment& CurRepSharedFragment = Context.GetSharedFragment<FMassReplicationSharedFragment>();
				return &CurRepSharedFragment == &RepSharedFragment;
			});
			RepSharedFragment.CachedReplicator->AddRequirements(RepSharedFragment.EntityQuery);
			RepSharedFragment.bEntityQueryInitialized = true;
		}

		const TArray<FMassClientHandle>& CurrentClientHandles = ReplicationSubsystem->GetClientReplicationHandles();
		const int32 MinNumHandles = FMath::Min(RepSharedFragment.CachedClientHandles.Num(), CurrentClientHandles.Num()); // Why is this the min not the max?

		//check to see if we don't have enough cached client handles
		if (RepSharedFragment.CachedClientHandles.Num() < CurrentClientHandles.Num())
		{
			RepSharedFragment.CachedClientHandles.Reserve(CurrentClientHandles.Num());
			RepSharedFragment.BubbleInfos.Reserve(CurrentClientHandles.Num());

			for (int32 Idx = RepSharedFragment.CachedClientHandles.Num(); Idx < CurrentClientHandles.Num(); ++Idx)
			{
				const FMassClientHandle& CurrentClientHandle = CurrentClientHandles[Idx];

				RepSharedFragment.CachedClientHandles.Add(CurrentClientHandle);
				AMassClientBubbleInfoBase* Info = CurrentClientHandle.IsValid() ?
					ReplicationSubsystem->GetClientBubbleChecked(RepSharedFragment.BubbleInfoClassHandle, CurrentClientHandle) :
					nullptr;

				check(Info);

				RepSharedFragment.BubbleInfos.Add(Info);
			}
		}
		//check to see if we have too many cached client handles
		else if (RepSharedFragment.CachedClientHandles.Num() > CurrentClientHandles.Num())
		{
			const int32 NumRemove = RepSharedFragment.CachedClientHandles.Num() - CurrentClientHandles.Num();

			RepSharedFragment.CachedClientHandles.RemoveAt(CurrentClientHandles.Num(), NumRemove, EAllowShrinking::No);
			RepSharedFragment.BubbleInfos.RemoveAt(CurrentClientHandles.Num(), NumRemove, EAllowShrinking::No);
		}

		//check to see if any cached client handles have changed, if they have set the BubbleInfo[] appropriately
		for (int32 Idx = 0; Idx < MinNumHandles; ++Idx)
		{
			const FMassClientHandle& CurrentClientHandle = CurrentClientHandles[Idx];
			FMassClientHandle& CachedClientHandle = RepSharedFragment.CachedClientHandles[Idx];

			const bool bChanged = (CurrentClientHandle != CachedClientHandle);
			if (bChanged)
			{
				AMassClientBubbleInfoBase* Info = CurrentClientHandle.IsValid() ?
					ReplicationSubsystem->GetClientBubbleChecked(RepSharedFragment.BubbleInfoClassHandle, CurrentClientHandle) :
					nullptr;

				RepSharedFragment.BubbleInfos[Idx] = Info;
				CachedClientHandle = CurrentClientHandle;
			}
		}
	});

#endif //UE_REPLICATION_COMPILE_SERVER_CODE
}

void UMassReplicationProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
#if UE_REPLICATION_COMPILE_SERVER_CODE
	UWorld* World = EntityManager.GetWorld();
	check(World);
	check(ReplicationSubsystem);

	{
		QUICK_SCOPE_CYCLE_COUNTER(UMassReplicationProcessor_Preperation);
		PrepareExecution(EntityManager);
	}

	const UMassLODSubsystem& LODSubsystem = Context.GetSubsystemChecked<UMassLODSubsystem>();
	const TArray<FViewerInfo>& AllViewersInfo = LODSubsystem.GetViewers();
	const TArray<FMassClientHandle>& ClientHandles = ReplicationSubsystem->GetClientReplicationHandles();
	for (const FMassClientHandle ClientHandle : ClientHandles)
	{
		if (ReplicationSubsystem->IsValidClientHandle(ClientHandle) == false)
		{
			continue;
		}

		FMassClientReplicationInfo& ClientReplicationInfo = ReplicationSubsystem->GetMutableClientReplicationInfoChecked(ClientHandle);

		// Figure out all viewer of this client
		TArray<FViewerInfo> Viewers;
		for (const FMassViewerHandle ClientViewerHandle : ClientReplicationInfo.Handles)
		{
			const FViewerInfo* ViewerInfo = AllViewersInfo.FindByPredicate([ClientViewerHandle](const FViewerInfo& ViewerInfo) { return ClientViewerHandle == ViewerInfo.Handle; });
			if (ensureMsgf(ViewerInfo, TEXT("Expecting to find the client viewer handle in the all viewers info list")))
			{
				Viewers.Add(*ViewerInfo);
			}
		}

		// Prepare LOD collector and calculator
		// Remember the max LOD distance from each
		float MaxLODDistance = 0.0f;
		EntityManager.ForEachSharedFragment<FMassReplicationSharedFragment>([&Viewers,&MaxLODDistance](FMassReplicationSharedFragment& RepSharedFragment)
		{
			RepSharedFragment.LODCollector.PrepareExecution(Viewers);
			RepSharedFragment.LODCalculator.PrepareExecution(Viewers);
			MaxLODDistance = FMath::Max(MaxLODDistance, RepSharedFragment.LODCalculator.GetMaxLODDistance());
		});

		// Fetch all entities to process
		const FVector HalfExtent(MaxLODDistance, MaxLODDistance, 0.0f);
		TArray<FMassEntityHandle> EntitiesInRange;
		for (const FViewerInfo& Viewer : Viewers)
		{
			FBox Bounds(Viewer.Location - HalfExtent, Viewer.Location + HalfExtent);
			ReplicationSubsystem->GetGrid().Query(Bounds, EntitiesInRange);
		}

		EntityQuery.CacheArchetypes(EntityManager);
		if (EntityQuery.GetArchetypes().Num() > 0)
		{
			// EntitySet stores array of entities per specified archetype, may contain duplicates.
			struct FEntitySet
			{
				void Reset()
				{
					Entities.Reset();
				}

				FMassArchetypeHandle Archetype;
				TArray<FMassEntityHandle> Entities;
			};
			TArray<FEntitySet> EntitySets;

			for (const FMassArchetypeHandle& Archetype : EntityQuery.GetArchetypes())
			{
				FEntitySet& Set = EntitySets.AddDefaulted_GetRef();
				Set.Archetype = Archetype;
			}

			auto BuildEntitySet = [&EntitySets, &EntityManager](const TArray<FMassEntityHandle>& Entities)
			{
				FEntitySet* PrevSet = Entities.Num() ? &EntitySets[0] : nullptr;
				for (const FMassEntityHandle Entity : Entities)
				{
					// Add to set of supported archetypes. Dont process if we don't care about the type.
					const FMassArchetypeHandle Archetype = EntityManager.GetArchetypeForEntity(Entity);
					FEntitySet* Set = PrevSet && PrevSet->Archetype == Archetype ? PrevSet : EntitySets.FindByPredicate([&Archetype](const FEntitySet& Set) { return Archetype == Set.Archetype; });
					if (Set != nullptr)
					{
						// We don't care about duplicates here, the FMassArchetypeEntityCollection creation below will handle it
						Set->Entities.Add(Entity);
						PrevSet = Set;
					}
				}
			};

			BuildEntitySet(ClientReplicationInfo.HandledEntities);
			BuildEntitySet(EntitiesInRange);

			for (FEntitySet& Set : EntitySets)
			{
				if (Set.Entities.Num() == 0)
				{
					continue;
				}

				Context.SetEntityCollection(FMassArchetypeEntityCollection(Set.Archetype, Set.Entities, FMassArchetypeEntityCollection::FoldDuplicates));

				{
					QUICK_SCOPE_CYCLE_COUNTER(UMassReplicationProcessor_SyncToMass);
					SyncClientData.ForEachEntityChunk(EntityManager, Context, [&ClientReplicationInfo](FMassExecutionContext& Context)
					{
						const TArrayView<FMassReplicationLODFragment> ViewerLODList = Context.GetMutableFragmentView<FMassReplicationLODFragment>();
						TArrayView<FMassReplicatedAgentFragment> ReplicatedAgentList = Context.GetMutableFragmentView<FMassReplicatedAgentFragment>();

						const int32 NumEntities = Context.GetNumEntities();
						for (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
						{
							FMassEntityHandle EntityHandle = Context.GetEntity(EntityIdx);
							FMassReplicatedAgentFragment& AgentFragment = ReplicatedAgentList[EntityIdx];
							FMassReplicationLODFragment& LODFragment = ViewerLODList[EntityIdx];

							if (FMassReplicatedAgentData* AgentData = ClientReplicationInfo.AgentsData.Find(EntityHandle))
							{
								LODFragment.LOD = AgentData->LOD;
								AgentFragment.AgentData = *AgentData;
							}
							else
							{
								LODFragment.LOD = EMassLOD::Off;
								AgentFragment.AgentData.Invalidate();
							}
						}
					});
				}

				{
					QUICK_SCOPE_CYCLE_COUNTER(UMassReplicationProcessor_LODCollection);
					CollectViewerInfoQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)
					{
						const TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
						const TArrayView<FMassReplicationViewerInfoFragment> ViewersInfoList = Context.GetMutableFragmentView<FMassReplicationViewerInfoFragment>();
						FMassReplicationSharedFragment& RepSharedFragment = Context.GetMutableSharedFragment<FMassReplicationSharedFragment>();
						RepSharedFragment.LODCollector.CollectLODInfo(Context, LocationList, ViewersInfoList, ViewersInfoList);
					});
				}

				{
					QUICK_SCOPE_CYCLE_COUNTER(UMassReplicationProcessor_LODCaculation);
					CalculateLODQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)
					{
						const TConstArrayView<FMassReplicationViewerInfoFragment> ViewersInfoList = Context.GetFragmentView<FMassReplicationViewerInfoFragment>();
						const TArrayView<FMassReplicationLODFragment> ViewerLODList = Context.GetMutableFragmentView<FMassReplicationLODFragment>();
						FMassReplicationSharedFragment& RepSharedFragment = Context.GetMutableSharedFragment<FMassReplicationSharedFragment>();
						RepSharedFragment.LODCalculator.CalculateLOD(Context, ViewersInfoList, ViewerLODList, ViewersInfoList);
					});
				}
				Context.ClearEntityCollection();
			}

			{
				QUICK_SCOPE_CYCLE_COUNTER(UMassReplicationProcessor_LODAdjustDistance);
				EntityManager.ForEachSharedFragment<FMassReplicationSharedFragment>([](FMassReplicationSharedFragment& RepSharedFragment)
				{
					RepSharedFragment.bHasAdjustedDistancesFromCount = RepSharedFragment.LODCalculator.AdjustDistancesFromCount();
				});
			}

			for (FEntitySet& Set : EntitySets)
			{
				if (Set.Entities.Num() == 0)
				{
					continue;
				}
				Context.SetEntityCollection(FMassArchetypeEntityCollection(Set.Archetype, Set.Entities, FMassArchetypeEntityCollection::FoldDuplicates));

				{
					QUICK_SCOPE_CYCLE_COUNTER(UMassReplicationProcessor_LODAdjustLODFromCount);
					AdjustLODDistancesQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)
					{
						const TConstArrayView<FMassReplicationViewerInfoFragment> ViewersInfoList = Context.GetFragmentView<FMassReplicationViewerInfoFragment>();
						const TArrayView<FMassReplicationLODFragment> ViewerLODList = Context.GetMutableFragmentView<FMassReplicationLODFragment>();
						FMassReplicationSharedFragment& RepSharedFragment = Context.GetMutableSharedFragment<FMassReplicationSharedFragment>();
						RepSharedFragment.LODCalculator.AdjustLODFromCount(Context, ViewersInfoList, ViewerLODList, ViewersInfoList);
					});
				}

				{
					QUICK_SCOPE_CYCLE_COUNTER(UMassReplicationProcessor_ProcessClientReplication);
					FMassReplicationContext ReplicationContext(*World, LODSubsystem, *ReplicationSubsystem);
					EntityManager.ForEachSharedFragment<FMassReplicationSharedFragment>([&EntityManager, &Context, &ReplicationContext, &ClientHandle](FMassReplicationSharedFragment& RepSharedFragment)
					{
						RepSharedFragment.CurrentClientHandle = ClientHandle;

						RepSharedFragment.EntityQuery.ForEachEntityChunk(EntityManager, Context, [&ReplicationContext, &RepSharedFragment](FMassExecutionContext& Context)
						{
							RepSharedFragment.CachedReplicator->ProcessClientReplication(Context, ReplicationContext);
						});
					});
				}

				{
					QUICK_SCOPE_CYCLE_COUNTER(UMassReplicationProcessor_SyncFromMass);
					SyncClientData.ForEachEntityChunk(EntityManager, Context, [&ClientReplicationInfo](FMassExecutionContext& Context)
					{
						TArrayView<FMassReplicatedAgentFragment> ReplicatedAgentList = Context.GetMutableFragmentView<FMassReplicatedAgentFragment>();

						const int32 NumEntities = Context.GetNumEntities();
						for (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
						{
							FMassEntityHandle EntityHandle = Context.GetEntity(EntityIdx);
							FMassReplicatedAgentFragment& AgentFragment = ReplicatedAgentList[EntityIdx];
							ClientReplicationInfo.AgentsData.Add(EntityHandle, AgentFragment.AgentData);
						}
					});
				}

#if WITH_MASSGAMEPLAY_DEBUG
				// Optional debug display
				if (UE::Mass::Replication::DebugClientReplicationLOD == ClientHandle.GetIndex())
				{
					EntityManager.ForEachSharedFragment<FMassReplicationSharedFragment>([World, &EntityManager, &Context](FMassReplicationSharedFragment& RepSharedFragment)
					{
						RepSharedFragment.EntityQuery.ForEachEntityChunk(EntityManager, Context, [World, &RepSharedFragment](FMassExecutionContext& Context)
						{
							const TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();
							const TConstArrayView<FMassReplicationLODFragment> ViewerLODList = Context.GetFragmentView<FMassReplicationLODFragment>();
							RepSharedFragment.LODCalculator.DebugDisplayLOD(Context, ViewerLODList, TransformList, World);
						});
					});
				}
#endif // WITH_MASSGAMEPLAY_DEBUG

				Context.ClearEntityCollection();
			}
		}
		ClientReplicationInfo.HandledEntities = MoveTemp(EntitiesInRange);

		// Cleanup any AgentData that isn't relevant anymore (that is EMassLOD::OFF)
		for (FMassReplicationAgentDataMap::TIterator It = ClientReplicationInfo.AgentsData.CreateIterator(); It; ++It)
		{
			FMassReplicatedAgentData& AgentData = It.Value();
			if (AgentData.LOD == EMassLOD::Off)
			{
				checkf(!AgentData.Handle.IsValid(), TEXT("This replicated agent should have been removed from this client and was not"));
				It.RemoveCurrent();
			}
		}
	}
#endif //UE_REPLICATION_COMPILE_SERVER_CODE
}

===================================================================


=== Source/MassReplication/Private/MassReplicationSubsystem.cpp ===
===================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassReplicationSubsystem.h"
#include "Engine/World.h"
#include "Engine/ChildConnection.h"
#include "GameFramework/GameModeBase.h"
#include "MassCommonTypes.h"
#include "MassEntityManager.h"
#include "MassClientBubbleHandler.h"
#include "MassClientBubbleInfoBase.h"
#include "MassReplicationSettings.h"
#include "MassEntityUtils.h"
#include "VisualLogger/VisualLogger.h"


uint32 UMassReplicationSubsystem::CurrentNetMassCounter = 0;

void UMassReplicationSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	World = GetWorld();
	check(World);

	MassLODSubsystem = Collection.InitializeDependency<UMassLODSubsystem>();
	check(MassLODSubsystem);

	EntityManager = UE::Mass::Utils::GetEntityManagerChecked(*World).AsShared();
}

void UMassReplicationSubsystem::Deinitialize()
{
	// remove all Clients
	for (const FMassClientHandle& Handle : ClientHandleManager.GetHandles())
	{
		if (Handle.IsValid())
		{
			RemoveClient(Handle);
		}
	}

	// make sure all the other data is reset
	ClientHandleManager.Reset();
	BubbleInfoArray.Reset();
	ClientsReplicationInfo.Reset();
	ClientToViewerHandleArray.Reset();
	ViewerToClientHandleArray.Reset();

	World = nullptr;
	MassLODSubsystem = nullptr;
	EntityManager.Reset();

	Super::Deinitialize();
}

UMassReplicationSubsystem::UMassReplicationSubsystem()
 : ReplicationGrid(GetDefault<UMassReplicationSettings>()->GetReplicationGridCellSize())
{
}

FMassNetworkID UMassReplicationSubsystem::GetNetIDFromHandle(const FMassEntityHandle Handle) const
{
	check(EntityManager);
	const FMassNetworkIDFragment& Data = EntityManager->GetFragmentDataChecked<FMassNetworkIDFragment>(Handle);
	return Data.NetID;
}

namespace UE { namespace Mass { namespace Replication {
// Checks the parent net connection has APlayerController OwningActor, unfortunately GetParentConnection() prevents UChildConnection being const here.
APlayerController* GetValidParentNetConnection(UChildConnection& ChildConnection)
{
	return (ChildConnection.GetParentConnection() != nullptr) ? Cast<APlayerController>(ChildConnection.GetParentConnection()->OwningActor) : nullptr;
}

enum class ENetConnectionType : uint8
{
	None,
	Parent,
	Child,
};

// Checks Controllers net connection is a parent net connection
bool HasParentNetConnection(const APlayerController* Controller)
{
	return (Controller != nullptr) && Controller->NetConnection && (Cast<UChildConnection>(Controller->NetConnection) == nullptr);
}

// If Controller has a UChildConnection then this gets the parent net connection's APlayerController OwningActor otherwise nullptr
APlayerController* GetParentControllerFromChildNetConnection(const APlayerController* Controller)
{
	//ChildConnection can't be const
	UChildConnection* ChildConnection = Controller ? Cast<UChildConnection>(Controller->NetConnection) : nullptr;

	return ChildConnection ? GetValidParentNetConnection(*ChildConnection) : nullptr;
}

// Gets the ENetConnectionType for Controller. Tests if Controller's net connection is a parent or if Controller's net connection is a child and its parent net connection has a APlayerController OwningActor, 
ENetConnectionType HasParentOrChildWithValidParentNetConnection(const APlayerController* Controller)
{
	ENetConnectionType ConnectionType = ENetConnectionType::None;

	if (Controller && Controller->NetConnection)
	{
		UChildConnection* ChildConnection = Cast<UChildConnection>(Controller->NetConnection);

		// if the NetConnection is either a parent connection or a child connection with APlayerController owning actor its valid 
		if (ChildConnection == nullptr)
		{
			ConnectionType = ENetConnectionType::Parent;
		}
		else
		{
			ConnectionType = (GetValidParentNetConnection(*ChildConnection) != nullptr) ? ENetConnectionType::Child : ENetConnectionType::None;
		}		
	}

	return ConnectionType;
}
}}};

bool UMassReplicationSubsystem::SynchronizeClients(const TArray<FViewerInfo>& Viewers)
{
	typedef TMap<FMassViewerHandle, FMassClientHandle> FControllerMap;
	struct FClientAddData
	{
		FClientAddData(FMassViewerHandle InHandle, APlayerController* InController)
			: Handle(InHandle)
			, Controller(InController)
		{}

		FMassViewerHandle Handle;
		APlayerController* Controller = nullptr;
	};

	bool bNeedShrinking = false;

	//we can only replicate if we have some BubbleInfos to use for replication
	if (BubbleInfoArray.Num() == 0)
	{
		return bNeedShrinking;
	}

	// Arbitrarily use index 0, if there are more items the corresponding InfoData, Bubbles will be the same length and corresponding indices between the Bubbles
	// will have the same player controller owner.
	const FMassClientBubbleInfoData& InfoData = BubbleInfoArray[0];

	check(MassLODSubsystem);

	FControllerMap ClientConnectionMap;

	TArray<FClientAddData> ClientsToAdd;

	{
		// Go through the stored Clients, add valid ones to the ClientConnectionMap and remove invalids.
		// Note this is only valid until we next add a client handle.
		const TArray<FMassClientHandle>& ClientHandles = ClientHandleManager.GetHandles();

		for (int32 Idx = 0; Idx < ClientHandles.Num(); ++Idx)
		{
			const FMassClientHandle& ClientHandle = ClientHandles[Idx];

			if (ClientHandle.IsValid())
			{
				check(ClientToViewerHandleArray.IsValidIndex(ClientHandle.GetIndex()));

				const FViewerClientPair ViewerClientPair = ClientToViewerHandleArray[ClientHandle.GetIndex()];

				check(ViewerClientPair.ViewerHandle.IsValid());
				check(ViewerClientPair.ClientHandle == ClientHandle);
				check(InfoData.Bubbles.IsValidIndex(ClientHandle.GetIndex()));

				const AMassClientBubbleInfoBase* ClientBubble = InfoData.Bubbles[ClientHandle.GetIndex()];
				const APlayerController* Controller = ClientBubble ? Cast<APlayerController>(ClientBubble->GetOwner()) : nullptr;

//no need to check netconnection if UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE
#if !UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE
				// must have a valid non child UNetConnection
				if (UE::Mass::Replication::HasParentNetConnection(Controller))
#endif
				{
					ClientConnectionMap.Add(ViewerClientPair.ViewerHandle, ClientHandle);
				}
#if !UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE
				else
				{
					// this is safe as Clients and their handles are free list arrays
					RemoveClient(ClientHandle);
					bNeedShrinking |= Idx == ClientHandles.Num() - 1;
				}
#endif
			}
		}

		// now go through all current Viewers and add if they do not exist
		for (const FViewerInfo& Viewer : Viewers)
		{
			// must have valid Viewer and parent net connection
			if (Viewer.Handle.IsValid())
			{
//no need to check netconnection if UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE
#if !UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE
				APlayerController* ViewerAsPlayerController = Viewer.GetPlayerController();
				if (UE::Mass::Replication::HasParentNetConnection(ViewerAsPlayerController))
#endif
				{
					// check if the controller already exists by trying to remove it from the map which was filled up with controllers we were tracking
					if (ClientConnectionMap.Remove(Viewer.Handle) == 0)
					{
						// If not add it to ClientsToAdd. Its important AddClient isn't called until necessary Clients are removed, as we may reuse 
						// array indices that are already in use.
						ClientsToAdd.Emplace(Viewer.Handle, ViewerAsPlayerController);
					}
				}
			}
		}

		// anything left in the map needs to be removed from the list
		for (FControllerMap::TIterator Itr = ClientConnectionMap.CreateIterator(); Itr; ++Itr)
		{
			const int32 ViewerIdx = Itr->Value.GetIndex();

			RemoveClient(Itr->Value);

			//InfoData must be valid here as ClientConnectionMap can only have items if ClientHandleManager.GetHandles() was greater than 0 
			//when we entered the function.
			bNeedShrinking |= (ViewerIdx == (InfoData.Bubbles.Num() - 1));
		}
	}

	// resize the ViewerToClientHandleArray array to match the viewer handles array (for consistency)
	if (ViewerToClientHandleArray.Num() > Viewers.Num())
	{
		ViewerToClientHandleArray.RemoveAt(Viewers.Num(), ViewerToClientHandleArray.Num() - Viewers.Num(), EAllowShrinking::No);
	}

	for (FClientAddData& ClientAdd : ClientsToAdd)
	{
		//TODO make AddClients (ie plural) functionality
		AddClient(ClientAdd.Handle, *ClientAdd.Controller);
	}

	return bNeedShrinking;
}

// synchronize the ClientViewers
void UMassReplicationSubsystem::SynchronizeClientViewers(const TArray<FViewerInfo>& Viewers)
{
	check(MassLODSubsystem);

	struct FMassClientViewerHandle
	{
		FMassClientViewerHandle(FMassClientHandle InClientHandle, FMassViewerHandle InViewerHandle)
			: ClientHandle(InClientHandle)
			, ViewerHandle(InViewerHandle)
		{}

		FMassClientHandle ClientHandle;
		FMassViewerHandle ViewerHandle;
	};

	// go through the ClientReplicationInfo and check validity and store the valid ones into a map
	typedef TMap<APlayerController*, FMassClientViewerHandle> FViewerMap;

	FViewerMap ClientViewerMap;
	{
		const TArray<FMassClientHandle> ClientHandles = ClientHandleManager.GetHandles();

		for (const FMassClientHandle& ClientHandle : ClientHandles)
		{
			//as this is a fresh handle then we only need to check against !IsInvalid
			if (ClientHandle.IsValid())
			{
				FMassClientReplicationInfo& ClientReplicationInfo = ClientsReplicationInfo[ClientHandle.GetIndex()];

				int32 ViewerIdx = 0;

				while (ViewerIdx < ClientReplicationInfo.Handles.Num())
				{
					const FMassViewerHandle& ClientViewer = ClientReplicationInfo.Handles[ViewerIdx];

					APlayerController* Controller = MassLODSubsystem->GetPlayerControllerFromViewerHandle(ClientViewer);

					const UE::Mass::Replication::ENetConnectionType ConnectionType = UE::Mass::Replication::HasParentOrChildWithValidParentNetConnection(Controller);

					if (ConnectionType != UE::Mass::Replication::ENetConnectionType::None)
					{
						++ViewerIdx;

						// we don't verify or remove Parent Connections here as that was done when we synchronized the client bubbles
						if (ConnectionType == UE::Mass::Replication::ENetConnectionType::Child)
						{
							ClientViewerMap.Add(Controller, FMassClientViewerHandle(ClientHandle, ClientViewer));
						}
					}
					else //remove invalid ClientViewer, but dont increment the ViewerIdx
					{
						ClientReplicationInfo.Handles.RemoveAt(ViewerIdx, EAllowShrinking::No);
					}
				}
			}
		}

		// now go through all current Viewers and add if they are a valid ClientViewer with a child UNetconnection if they do not exist
		for (const FViewerInfo& Viewer : Viewers)
		{
			// we are only interested in valid Viewers
			if (Viewer.Handle.IsValid())
			{
				// we are only processing child UNetConnections that have a valid APlayerController OwningActor
				APlayerController* ViewerAsPlayerController = Viewer.GetPlayerController();
				const APlayerController* ParentController = UE::Mass::Replication::GetParentControllerFromChildNetConnection(ViewerAsPlayerController);

				// check if the parent controller is valid and already exists
				if (ParentController && (ClientViewerMap.Find(ViewerAsPlayerController) == nullptr))
				{
					FMassViewerHandle ParentViewerHandle = MassLODSubsystem->GetViewerHandleFromActor(*ParentController);

					if (ensureMsgf(ParentViewerHandle.IsValid(), TEXT("MassLODSubsystem handles are out of sync with PlayerController NetConnections!")))
					{
						// note all clients (parent NetConnections) should already be set up so we would expect valid handles here
						check(ViewerToClientHandleArray.IsValidIndex(ParentViewerHandle.GetIndex()));

						const FViewerClientPair& ParentViewerClientPair = ViewerToClientHandleArray[ParentViewerHandle.GetIndex()];

						check(MassLODSubsystem->IsValidViewer(ParentViewerClientPair.ViewerHandle));
						check(ClientHandleManager.IsValidHandle(ParentViewerClientPair.ClientHandle));

						// remove APlayerController from the ClientViewerMap and Add the viewer to the ClientsReplicationInfo
						ClientViewerMap.Remove(ViewerAsPlayerController);

						FMassClientReplicationInfo& ClientReplicationInfo = ClientsReplicationInfo[ParentViewerClientPair.ClientHandle.GetIndex()];

						ClientReplicationInfo.Handles.Add(Viewer.Handle);
					}
				}
			}
		}
	}

	{
		// anything left in the map needs to be removed from the list
		for (FViewerMap::TIterator Itr = ClientViewerMap.CreateIterator(); Itr; ++Itr)
		{
			const FMassClientViewerHandle& HandleData = Itr->Value;

			FMassClientReplicationInfo& ClientReplicationInfo = ClientsReplicationInfo[HandleData.ClientHandle.GetIndex()];

			ClientReplicationInfo.Handles.RemoveSingle(HandleData.ViewerHandle);
		}
	}
}

void UMassReplicationSubsystem::SynchronizeClientsAndViewers()
{
	// only execute this code at most once per frame
	if (LastSynchronizedFrame == GFrameCounter)
	{
		return;
	}
	LastSynchronizedFrame = GFrameCounter;

	if (MassLODSubsystem == nullptr)
	{
		checkNoEntry();
		return;
	}

	// makes sure the LOD manager Viewers are synced before we process them
	const TArray<FViewerInfo>& Viewers = MassLODSubsystem->GetSynchronizedViewers();

	const bool bNeedShrinking = SynchronizeClients(Viewers);

	//only synchronize the client viewers outside of the debug functionality for now
#if !UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE
	SynchronizeClientViewers(Viewers);
#endif //UE_ALLOW_REPLICATION_DEBUG_BUBBLES_IN_STANDALONE

	if (bNeedShrinking)
	{
		const int32 NumItems = ClientHandleManager.ShrinkHandles();
		 
		ClientsReplicationInfo.RemoveAt(NumItems, ClientsReplicationInfo.Num() - NumItems, EAllowShrinking::No);
		ClientToViewerHandleArray.RemoveAt(NumItems, ClientToViewerHandleArray.Num() - NumItems, EAllowShrinking::No);

		for (FMassClientBubbleInfoData& InfoData : BubbleInfoArray)
		{
			InfoData.Bubbles.RemoveAt(NumItems, InfoData.Bubbles.Num() - NumItems, EAllowShrinking::No);
		}
	}
}

FMassBubbleInfoClassHandle UMassReplicationSubsystem::RegisterBubbleInfoClass(const TSubclassOf<AMassClientBubbleInfoBase>& BubbleInfoClass)
{
	checkf(BubbleInfoClass.Get() != nullptr, TEXT("BubbleInfoClass must have been set!"));

	if (ClientHandleManager.GetHandles().Num() > 0)
	{
		checkf(false, TEXT("RegisterBubbleInfoClass() must not be called after AddClient, BubbleInfoClass has not been registered"));
		return FMassBubbleInfoClassHandle();
	}

	const int32 IdxFound = BubbleInfoArray.IndexOfByPredicate([BubbleInfoClass](const FMassClientBubbleInfoData& Data)
		{
			return BubbleInfoClass == Data.BubbleClass;
		});

	if (IdxFound != INDEX_NONE)
	{
		UE_LOG(LogMassReplication, Log, TEXT("UMassReplicationSubsystem: Trying to RegisterBubbleInfoClass() twice with the same BubbleInfoClass, Only one BubbleInfoClass will be registered for this type"));
		return FMassBubbleInfoClassHandle(IdxFound);
	}

	const int32 Idx = BubbleInfoArray.Emplace(BubbleInfoClass);

	return FMassBubbleInfoClassHandle(Idx);
}

FMassBubbleInfoClassHandle UMassReplicationSubsystem::GetBubbleInfoClassHandle(const TSubclassOf<AMassClientBubbleInfoBase>& BubbleInfoClass) const
{
	FMassBubbleInfoClassHandle Handle;

	for (int32 Idx = 0; Idx < BubbleInfoArray.Num(); ++Idx)
	{
		const FMassClientBubbleInfoData& BubbleData = BubbleInfoArray[Idx];

		if (BubbleData.BubbleClass == BubbleInfoClass)
		{
			Handle.SetIndex(Idx);
			break;
		}
	}

	UE_CVLOG_UELOG(Handle.IsValid() == false, this, LogMassReplication, Error, TEXT("%hs failed to find required Bubble Info class"), __FUNCTION__);

	return Handle;
}

#if UE_REPLICATION_COMPILE_CLIENT_CODE
void UMassReplicationSubsystem::SetEntity(const FMassNetworkID NetworkID, const FMassEntityHandle Entity)
{
	FMassReplicationEntityInfo* EntityInfo = FindMassEntityInfoMutable(NetworkID);
	check(EntityInfo && !EntityInfo->Entity.IsSet());
	EntityInfo->Entity = Entity;

	OnMassAgentAdded.Broadcast(NetworkID, Entity);
}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

#if UE_REPLICATION_COMPILE_CLIENT_CODE
FMassEntityHandle UMassReplicationSubsystem::ResetEntityIfValid(const FMassNetworkID NetworkID, int32 ReplicationID)
{
	FMassEntityHandle EntityReset;

	FMassReplicationEntityInfo* EntityInfo = FindMassEntityInfoMutable(NetworkID);

	checkf(EntityInfo, TEXT("EntityData must have been added to EntityInfoMap!"));
	checkf(EntityInfo->ReplicationID >= ReplicationID, TEXT("We must not be removing an item we've never added!"));

	// Only reset the item if its currently Set / Valid and its the most recent ReplicationID. Stale removes after more recent adds are ignored
	// We do need to check the ReplicationID in this case
	if (EntityInfo->Entity.IsSet() && (EntityInfo->ReplicationID == ReplicationID))
	{
		OnRemovingMassAgent.Broadcast(NetworkID, EntityReset);

		EntityReset = EntityInfo->Entity;

		//Unset the Entity handle, this indicates that its currently removed from the bubble
		EntityInfo->Entity = FMassEntityHandle();
	}

	return EntityReset;
}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

#if UE_REPLICATION_COMPILE_CLIENT_CODE
void UMassReplicationSubsystem::RemoveFromEntityInfoMap(const FMassNetworkID NetworkID)
{
	check(NetworkID.IsValid());
	FMassReplicationEntityInfo Info;
	ensureMsgf(EntityInfoMap.RemoveAndCopyValue(NetworkID, Info), TEXT("Removing a non-existant NetworkID(%s)!"), *NetworkID.Describe());
}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

#if UE_REPLICATION_COMPILE_CLIENT_CODE
UMassReplicationSubsystem::EFindOrAddMassEntityInfo UMassReplicationSubsystem::FindAndUpdateOrAddMassEntityInfo(const FMassNetworkID NetworkID, int32 ReplicationID, const FMassReplicationEntityInfo*& OutMassEntityInfo)
{
	FMassReplicationEntityInfo* MassEntityInfo = FindMassEntityInfoMutable(NetworkID);
	EFindOrAddMassEntityInfo FindOrAddStatus = EFindOrAddMassEntityInfo::FoundOlderReplicationID;

	if (MassEntityInfo)
	{
		// Currently we don't think this should be needed, but are leaving it in for bomb proofing
		if (ensure(MassEntityInfo->ReplicationID < ReplicationID))
		{
			// Update the replication ID to the latest
			MassEntityInfo->ReplicationID = ReplicationID;
		}
		else
		{
			FindOrAddStatus = EFindOrAddMassEntityInfo::FoundNewerReplicationID;
		}
	}
	else
	{
		MassEntityInfo = &EntityInfoMap.Add(NetworkID, FMassReplicationEntityInfo(FMassEntityHandle(), ReplicationID));
		FindOrAddStatus = EFindOrAddMassEntityInfo::Added;
	}

	OutMassEntityInfo = MassEntityInfo;
	return FindOrAddStatus;
}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

#if UE_REPLICATION_COMPILE_CLIENT_CODE
const FMassReplicationEntityInfo* UMassReplicationSubsystem::FindMassEntityInfo(const FMassNetworkID NetworkID) const
{
	check(NetworkID.IsValid());
	return EntityInfoMap.Find(NetworkID);
}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

#if UE_REPLICATION_COMPILE_CLIENT_CODE
FMassReplicationEntityInfo* UMassReplicationSubsystem::FindMassEntityInfoMutable(const FMassNetworkID NetworkID)
{
	check(NetworkID.IsValid());
	return EntityInfoMap.Find(NetworkID);
}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

#if UE_REPLICATION_COMPILE_CLIENT_CODE
FMassEntityHandle UMassReplicationSubsystem::FindEntity(const FMassNetworkID NetworkID) const
{
	check(NetworkID.IsValid());
	const FMassReplicationEntityInfo* Info = EntityInfoMap.Find(NetworkID);
	return Info ? Info->Entity : FMassEntityHandle();
}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

void UMassReplicationSubsystem::DebugCheckArraysAreInSync()
{
#if UE_DEBUG_REPLICATION

	checkf((ClientToViewerHandleArray.Num() == ClientsReplicationInfo.Num()), TEXT("Client arrays out of sync with each other!"));

	const int32 NumEntries = (BubbleInfoArray.Num() > 0) ? BubbleInfoArray[0].Bubbles.Num() : 0;

	for (int32 IdxOuter = 0; IdxOuter < BubbleInfoArray.Num(); ++IdxOuter)
	{
		FMassClientBubbleInfoData& InfoDataOuter = BubbleInfoArray[IdxOuter];

		checkf((InfoDataOuter.Bubbles.Num() == ClientsReplicationInfo.Num()), TEXT("BubbleInfoArray arrays out of sync with ClientsReplicationInfo!"));
		checkf(InfoDataOuter.Bubbles.Num() == NumEntries, TEXT("Bubbles have different numbers of items!"));

		for (int32 IdxInner = IdxOuter + 1; IdxInner < BubbleInfoArray.Num(); ++IdxInner)
		{
			FMassClientBubbleInfoData& InfoDataInner = BubbleInfoArray[IdxInner];

			for (int32 IdxBubble = 0; IdxBubble < InfoDataOuter.Bubbles.Num(); ++IdxBubble)
			{
				AMassClientBubbleInfoBase* InfoOuter = InfoDataOuter.Bubbles[IdxBubble];
				AMassClientBubbleInfoBase* InfoInner = InfoDataInner.Bubbles[IdxBubble];

				const TArray<FMassClientHandle>& Handles = ClientHandleManager.GetHandles();

				if (ClientHandleManager.IsValidHandle(Handles[IdxBubble]))
				{				
					check(InfoOuter && InfoInner);

					APlayerController* OuterController = Cast<APlayerController>(InfoOuter->GetOwner());
					APlayerController* InnerController = Cast<APlayerController>(InfoInner->GetOwner());

					checkf((OuterController != nullptr) && (InnerController != nullptr), TEXT("Controller owners must be valid in BubbleInfoArray"));
					checkf(OuterController == InnerController, TEXT("Owner controllers at the same indices in different BubbleInfoArray items must be equal!"));
				}
				else
				{
					check(!InfoOuter && !InfoInner);
				}
			}
		}
	}

 #endif // UE_DEBUG_REPLICATION
};

void UMassReplicationSubsystem::AddClient(FMassViewerHandle ViewerHandle, APlayerController& InController)
{
	check(World);
	check(MassLODSubsystem);
	checkf(MassLODSubsystem->IsValidViewer(ViewerHandle), TEXT("ViewerHandle must be valid"));

#if !UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE
	checkf(UE::Mass::Replication::HasParentNetConnection(&InController), TEXT("InController must have a parent net connection or replication will not occur!"));
#endif

	if (!ensureMsgf(BubbleInfoArray.Num() > 0, TEXT("BubbleInfoClass has not been set Client will not be added to UMassReplicationSubsystem!")))
	{
		return;
	}

	if (ViewerHandle.GetIndex() >= ViewerToClientHandleArray.Num())
	{
		// making no assumptions about the order that ViewerHandles are added, make sure we add enough space to accomodate the new ViewerHandle index
		ViewerToClientHandleArray.AddDefaulted(ViewerHandle.GetIndex() - ViewerToClientHandleArray.Num() + 1);
	}
	else 
	{
		checkf(ViewerToClientHandleArray[ViewerHandle.GetIndex()].ViewerHandle.IsValid() == false, TEXT("Adding a Client without removing the previous with the same Index!"));
	}

	FActorSpawnParameters SpawnParams;
	SpawnParams.Owner = &InController;

	const FMassClientHandle ClientHandle = ClientHandleManager.GetNextHandle();

	const FViewerClientPair ViewerClientPair(ViewerHandle, ClientHandle);

	FViewerClientPair& ViewerToClientHandleItem = ViewerToClientHandleArray[ViewerHandle.GetIndex()];

	checkf(ViewerToClientHandleItem.IsValid() == false, TEXT("Handles should have been reset when previous Viewer in this slot was removed"));

	ViewerToClientHandleItem = ViewerClientPair;

	checkf(ClientHandle.GetIndex() <= ClientToViewerHandleArray.Num(), TEXT("ClientHandle out of sync with ClientToViewerHandleArray"));

	// check if the handle is a new entry in the free list arrays or uses an existing entry
	if (ClientHandle.GetIndex() == ClientToViewerHandleArray.Num())
	{
		ClientsReplicationInfo.AddDefaulted();
		ClientToViewerHandleArray.Emplace(ViewerHandle, ClientHandle);
	}
	else
	{
		checkf(ClientsReplicationInfo[ClientHandle.GetIndex()].IsEmpty(), TEXT("ClientsReplicationInfo being replaced must have been reset prior to being reused!"));

		FViewerClientPair& ClientToViewerHandleItem = ClientToViewerHandleArray[ClientHandle.GetIndex()];

		checkf(ClientToViewerHandleItem.IsValid() == false, TEXT("Handles should have been reset when previous Client in this slot was removed"));

		ClientToViewerHandleItem = ViewerClientPair;
	}

	FMassClientReplicationInfo& ClientReplicationInfo = ClientsReplicationInfo[ClientHandle.GetIndex()];
	ClientReplicationInfo.Handles.Add(ViewerHandle);

	for (FMassClientBubbleInfoData& InfoData : BubbleInfoArray)
	{
		AMassClientBubbleInfoBase* ClientBubbleInfo = World->SpawnActor<AMassClientBubbleInfoBase>(InfoData.BubbleClass, SpawnParams);
		ClientBubbleInfo->SetClientHandle(ClientHandle);

		checkf(ClientHandle.GetIndex() <= InfoData.Bubbles.Num(), TEXT("ClientHandle out of sync with Bubbles"));

		// check if the handle is a new entry in the free list arrays or uses an existing entry
		if (ClientHandle.GetIndex() == InfoData.Bubbles.Num())
		{
			InfoData.Bubbles.Push(ClientBubbleInfo);
		}
		else
		{
			TObjectPtr<AMassClientBubbleInfoBase>& BubbleUpdate = InfoData.Bubbles[ClientHandle.GetIndex()];
			checkf(BubbleUpdate == nullptr, TEXT("ClientBubble being replaced must be nullptr it should have been removed first!"));

			BubbleUpdate = ClientBubbleInfo;
		}
	}
	DebugCheckArraysAreInSync();
}

void UMassReplicationSubsystem::RemoveClient(FMassClientHandle ClientHandle)
{
	check(World);

	checkf(ClientHandleManager.IsValidHandle(ClientHandle), TEXT("ClientHandle must be a valid non stale handle"));

	checkf(ClientToViewerHandleArray.IsValidIndex(ClientHandle.GetIndex()), TEXT("ClientHandle is out of sync with ClientToViewerHandleArray!"));
	FViewerClientPair& ClientToViewerHandleItem = ClientToViewerHandleArray[ClientHandle.GetIndex()];

	checkf(ClientToViewerHandleItem.ViewerHandle.IsValid(), TEXT("Invalid ViewerHandle! ClientHandle is out of sync with ClientToViewerHandleArray!"));
	checkf(ClientToViewerHandleItem.ClientHandle == ClientHandle, TEXT("ClientHandle is out of sync with ClientToViewerHandleArray!"));

	{
		FMassClientReplicationInfo& ClientReplicationInfo = ClientsReplicationInfo[ClientHandle.GetIndex()];

		checkf(ClientReplicationInfo.Handles.Num() > 0, TEXT("There should always be atleast one client viewer handle (the parent NetConnection)"));

		ClientReplicationInfo.Reset();
	}

	checkf(ViewerToClientHandleArray.IsValidIndex(ClientToViewerHandleItem.ViewerHandle.GetIndex()), TEXT("ViewerHandle is out of sync with ViewerToClientHandleArray!"));
	FViewerClientPair& ViewerToClientHandleItem = ViewerToClientHandleArray[ClientToViewerHandleItem.ViewerHandle.GetIndex()];

	checkf(ViewerToClientHandleItem == ClientToViewerHandleItem, TEXT("ClientToViewerHandleArray and ViewerToClientHandleArray out of sync!"));

	ViewerToClientHandleItem.Invalidate();
	ClientToViewerHandleItem.Invalidate();

	for (FMassClientBubbleInfoData& InfoData : BubbleInfoArray)
	{
		checkf(InfoData.Bubbles.IsValidIndex(ClientHandle.GetIndex()), TEXT("ClientHandle is out of sync with Bubbles!"));
		TObjectPtr<AMassClientBubbleInfoBase>& BubbleInfoItem = InfoData.Bubbles[ClientHandle.GetIndex()];

		if ((World != nullptr) && (BubbleInfoItem != nullptr))
		{
			World->DestroyActor(BubbleInfoItem);
		}

		BubbleInfoItem = nullptr;
	}

	ClientHandleManager.RemoveHandle(ClientHandle);

	DebugCheckArraysAreInSync();
}

===================================================================


=== Source/MassReplication/Private/MassReplicationTrait.cpp ===
===============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassReplicationTrait.h"
#include "MassEntityTemplateRegistry.h"
#include "Engine/World.h"
#include "MassSpawnerTypes.h"
#include "MassSimulationLOD.h"
#include "MassReplicationTypes.h"
#include "MassReplicationSubsystem.h"
#include "MassEntityUtils.h"


void UMassReplicationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	if (World.IsNetMode(NM_Standalone) && !BuildContext.IsInspectingData())
	{
		return;
	}

	FReplicationTemplateIDFragment& TemplateIDFragment = BuildContext.AddFragment_GetRef<FReplicationTemplateIDFragment>();
	TemplateIDFragment.ID = BuildContext.GetTemplateID();

	BuildContext.AddFragment<FMassNetworkIDFragment>();
	BuildContext.AddFragment<FMassReplicatedAgentFragment>();
	BuildContext.AddFragment<FMassReplicationViewerInfoFragment>();
	BuildContext.AddFragment<FMassReplicationLODFragment>();
	BuildContext.AddFragment<FMassReplicationGridCellLocationFragment>();

	FMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(World);

	UMassReplicationSubsystem* ReplicationSubsystem = UWorld::GetSubsystem<UMassReplicationSubsystem>(&World);

	FConstSharedStruct ParamsFragment = EntityManager.GetOrCreateConstSharedFragment(Params);
	BuildContext.AddConstSharedFragment(ParamsFragment);

	if (LIKELY(!BuildContext.IsInspectingData()))
	{
		check(ReplicationSubsystem);
		FSharedStruct SharedFragment = EntityManager.GetOrCreateSharedFragment<FMassReplicationSharedFragment>(FConstStructView::Make(Params), *ReplicationSubsystem, Params);
		BuildContext.AddSharedFragment(SharedFragment);
	}
	else
	{
		// in the investigation mode we only care about the fragment type
		FSharedStruct SharedFragment = EntityManager.GetOrCreateSharedFragment<FMassReplicationSharedFragment>();
		BuildContext.AddSharedFragment(SharedFragment);
	}
}
===============================================================


=== Source/MassReplication/Private/MassReplicationTransformHandlers.cpp ===
===========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassReplicationTransformHandlers.h"
#include "MassEntityQuery.h"
#include "MassCommonFragments.h"
#include "MassExecutionContext.h"
#include "AIHelpers.h"

void FMassReplicationProcessorTransformHandlerBase::AddRequirements(FMassEntityQuery& InQuery)
{
	InQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);
}

void FMassReplicationProcessorTransformHandlerBase::CacheFragmentViews(FMassExecutionContext& ExecContext)
{
	TransformList = ExecContext.GetMutableFragmentView<FTransformFragment>();
}

void FMassReplicationProcessorPositionYawHandler::AddEntity(const int32 EntityIdx, FReplicatedAgentPositionYawData& InOutReplicatedPositionYawData) const
{
	const FTransformFragment& TransformFragment = TransformList[EntityIdx];
	InOutReplicatedPositionYawData.SetPosition(TransformFragment.GetTransform().GetLocation());

	const FRotator::FReal Yaw = FMath::DegreesToRadians(TransformFragment.GetTransform().Rotator().Yaw);
	InOutReplicatedPositionYawData.SetYaw(static_cast<float>(Yaw));
}

===========================================================================


=== Source/MassReplication/Private/MassReplicationTypes.cpp ===
===============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassReplicationTypes.h"

DEFINE_LOG_CATEGORY(LogMassReplication);

===============================================================


=== Source/MassReplication/Public/IMassReplicationModule.h ===
==============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleInterface.h"
#include "Modules/ModuleManager.h"


/**
 * The public interface to this module.  In most cases, this interface is only public to sibling modules 
 * within this plugin.
 */
class IMassReplicationModule : public IModuleInterface
{

public:

	/**
	 * Singleton-like access to this module's interface.  This is just for convenience!
	 * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.
	 *
	 * @return Returns singleton instance, loading the module on demand if needed
	 */
	static inline IMassReplicationModule& Get()
	{
		return FModuleManager::LoadModuleChecked<IMassReplicationModule>( "MassReplication" );
	}

	/**
	 * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.
	 *
	 * @return True if the module is loaded and ready to use
	 */
	static inline bool IsAvailable()
	{
		return FModuleManager::Get().IsModuleLoaded( "MassReplication" );
	}
};


==============================================================


=== Source/MassReplication/Public/MassClientBubbleHandler.h ===
===============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassCommonTypes.h"
#include "MassReplicationTypes.h"
#include "MassEntityManager.h"
#include "Containers/ArrayView.h"
#include "MassClientBubbleSerializerBase.h"
#include "MassSpawnerSubsystem.h"
#include "MassSpawnerTypes.h"
#include "MassReplicationFragments.h"
#include "MassReplicationSubsystem.h"
#include "Engine/World.h"
#include "MassEntityTemplate.h"
#include "MassEntityView.h"

#include "MassClientBubbleHandler.generated.h"

class UWorld;
struct FMassEntityManager;

namespace UE::Mass::Replication
{
	constexpr float AgentRemoveInterval = 5.f;
}; //namespace UE::Mass::Replication

/**
 *  Base for fast array items. For replication of new entity types this type should be inherited from. FReplicatedAgentBase should also be inherited from
 *  and made a member variable of the FMassFastArrayItemBase derived struct, with the member variable called Agent.
 */
USTRUCT()
struct FMassFastArrayItemBase : public FFastArraySerializerItem
{
	GENERATED_BODY()

	FMassFastArrayItemBase() = default;
	FMassFastArrayItemBase(FMassReplicatedAgentHandle InHandle)
		: Handle(InHandle)
	{};

	FMassReplicatedAgentHandle GetHandle() const { return Handle; }

protected:
	/** Only to be used on a server */
	UPROPERTY(NotReplicated)
	FMassReplicatedAgentHandle Handle;
};

/** Data that can be accessed from a FMassReplicatedAgentHandle on a server */
struct FMassAgentLookupData
{
	FMassAgentLookupData(FMassEntityHandle InEntity, FMassNetworkID InNetID, int32 InAgentsIdx)
		: Entity(InEntity)
		, NetID(InNetID)
		, AgentsIdx(InAgentsIdx)
	{}

	void Invalidate()
	{
		Entity = FMassEntityHandle();
		NetID.Invalidate();
		AgentsIdx = INDEX_NONE;
	}

	bool IsValid() const
	{
		return Entity.IsSet() && NetID.IsValid() && (AgentsIdx >= 0);
	}

	FMassEntityHandle Entity;
	FMassNetworkID NetID;
	int32 AgentsIdx  = INDEX_NONE;
};

/**
 *  Data that is stored when an agent is removed from the bubble, when it times out its safe enough to remove entries in EntityInfoMap.
 *  The idea is that any out of order adds and removes will happen after this time.
 */
struct FMassAgentRemoveData
{
	FMassAgentRemoveData() = default;
	FMassAgentRemoveData(double InTimeLastRemoved)
		: TimeLastRemoved(InTimeLastRemoved)
	{}

	double TimeLastRemoved = 0.;
};

/**
 * Interface for the bubble handler classes. All the outside interaction with the FastArray logic should be done via the Handler interface
 * or derived classes where possible.
 * These virtual functions are either only called once each per frame on the client for a few struct instances
 * or called at startup / shutdown.
 */
class IClientBubbleHandlerInterface
{
public:
	virtual ~IClientBubbleHandlerInterface() {}

	virtual void InitializeForWorld(UWorld& InWorld) = 0;

#if UE_REPLICATION_COMPILE_CLIENT_CODE
	/** These functions are processed internally by TClientBubbleHandlerBase */
	virtual void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize) = 0;
	virtual void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize) = 0;
	virtual void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize) = 0;
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

	virtual void Reset() = 0;
	virtual void UpdateAgentsToRemove() = 0;

	virtual void Tick(float DeltaTime) = 0;
	virtual void SetClientHandle(FMassClientHandle InClientHandle) = 0;

	virtual void DebugValidateBubbleOnServer() = 0;
	virtual void DebugValidateBubbleOnClient() = 0;
};


/** 
 * Template client bubble functionality. Replication logic for specific agent types is provided by deriving from this class.
 * Interaction with the FMassClientBubbleSerializerBase and derived classes should be done from this class 
 */
template<typename AgentArrayItem>
class TClientBubbleHandlerBase : public IClientBubbleHandlerInterface
{
public:
	template<typename T>
	friend class TMassClientBubblePathHandler;

	template<typename T>
	friend class TMassClientBubbleTransformHandler;

	typedef TFunctionRef<void(FMassEntityQuery&)> FAddRequirementsForSpawnQueryFunction;
	typedef TFunctionRef<void(FMassExecutionContext&)> FCacheFragmentViewsForSpawnQueryFunction;
	typedef TFunctionRef<void(const FMassEntityView&, const typename AgentArrayItem::FReplicatedAgentType&, const int32)> FSetSpawnedEntityDataFunction;
	typedef TFunctionRef<void(const FMassEntityView&, const typename AgentArrayItem::FReplicatedAgentType&)> FSetModifiedEntityDataFunction;

	/** This must be called from outside before InitializeForWorld() is called. Its called from agent specific bubble implementations */
	virtual void Initialize(TArray<AgentArrayItem>& InAgents, FMassClientBubbleSerializerBase& InSerializer);

	virtual void InitializeForWorld(UWorld& InWorld) override;

#if UE_REPLICATION_COMPILE_SERVER_CODE
	FMassReplicatedAgentHandle AddAgent(FMassEntityHandle Entity, typename AgentArrayItem::FReplicatedAgentType& Agent);

	bool RemoveAgent(FMassNetworkID NetID);
	bool RemoveAgent(FMassReplicatedAgentHandle AgentHandle);
	void RemoveAgentChecked(FMassReplicatedAgentHandle AgentHandle);

	/** Gets an agent safely */
	const typename AgentArrayItem::FReplicatedAgentType* GetAgent(FMassReplicatedAgentHandle Handle) const;

	/** Faster version to get an agent that performs check()s for debugging */
	const typename AgentArrayItem::FReplicatedAgentType& GetAgentChecked(FMassReplicatedAgentHandle Handle) const;
	const TArray<AgentArrayItem>& GetAgents() const { return *Agents; }
#endif //UE_REPLICATION_COMPILE_SERVER_CODE

protected:

#if UE_REPLICATION_COMPILE_CLIENT_CODE

	virtual void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize) override;

	/** Called from TClientBubbleHandlerBase derived classes in PostReplicatedAd() */
	void PostReplicatedAddHelper(const TArrayView<int32> AddedIndices, FAddRequirementsForSpawnQueryFunction AddRequirementsForSpawnQuery
		, FCacheFragmentViewsForSpawnQueryFunction CacheFragmentViewsForSpawnQuery, FSetSpawnedEntityDataFunction SetSpawnedEntityData, FSetModifiedEntityDataFunction SetModifiedEntityData);

	/** used by PostReplicatedAddHelper */
	void PostReplicatedAddEntitiesHelper(const TArrayView<int32> AddedIndices, FAddRequirementsForSpawnQueryFunction AddRequirementsForSpawnQuery
		, FCacheFragmentViewsForSpawnQueryFunction CacheFragmentViewsForSpawnQuery, FSetSpawnedEntityDataFunction SetSpawnedEntityData);


	/** Called from TClientBubbleHandlerBase derived classes in PostReplicatedChange() */
	void PostReplicatedChangeHelper(const TArrayView<int32> ChangedIndices, FSetModifiedEntityDataFunction SetModifiedEntityData);
#endif //UE_REPLICATION_COMPILE_SERVER_CODE

#if UE_REPLICATION_COMPILE_SERVER_CODE
	void RemoveAgentImpl(FMassReplicatedAgentHandle Handle);
#endif //UE_REPLICATION_COMPILE_SERVER_CODE

	virtual void SetClientHandle(FMassClientHandle InClientHandle) override;

	virtual void Reset() override;
	virtual void Tick(float DeltaTime) override;

	virtual void UpdateAgentsToRemove() override;

	virtual void DebugValidateBubbleOnClient() override;
	virtual void DebugValidateBubbleOnServer() override;

protected:
	/** Pointer to the Agents array in the associated Serializer class */
	TArray<AgentArrayItem>* Agents = nullptr;

	FMassClientHandle ClientHandle;

#if UE_REPLICATION_COMPILE_SERVER_CODE
	FMassReplicatedAgentHandleManager AgentHandleManager;

	/** Used to look up Agent data from a FMassReplicatedAgentHandle, the AgentsIdx member will be the Idx in to the Agents array */
	TArray<FMassAgentLookupData> AgentLookupArray;

	TMap<FMassNetworkID, FMassReplicatedAgentHandle> NetworkIDToAgentHandleMap;
#endif //UE_REPLICATION_COMPILE_SERVER_CODE

#if UE_REPLICATION_COMPILE_CLIENT_CODE
	/**
	 *  Data that is stored when an agent is removed from the bubble, when it times out its safe enough to remove entries in EntityInfoMap
	 *  The idea is that any out of order adds and subsequent removes for this NetID will normally happen before FAgentRemoveData::TimeLastRemoved,
	 *  Those that happen after will be on such a bad connection that it doest matter.
	 */
	TMap<FMassNetworkID, FMassAgentRemoveData> AgentsRemoveDataMap;
#endif //UE_REPLICATION_COMPILE_CLIENT_CODE

	/** Base class pointer to the associated Serializer class */
	FMassClientBubbleSerializerBase* Serializer = nullptr;
};

template<typename AgentArrayItem>
void TClientBubbleHandlerBase<AgentArrayItem>::Initialize(TArray<AgentArrayItem>& InAgents, FMassClientBubbleSerializerBase& InSerializer)
{
	Agents = &InAgents;
	Serializer = &InSerializer;
	Serializer->SetClientHandler(*this);
}

template<typename AgentArrayItem>
void TClientBubbleHandlerBase<AgentArrayItem>::InitializeForWorld(UWorld& InWorld)
{
	checkf(Agents, TEXT("Agents not set up. Call Initialize() before InitializeForWorld() gets called"));
	checkf(Serializer, TEXT("Serializer not set up. Call Initialize() before InitializeForWorld() gets called"));

	Serializer->InitializeForWorld(InWorld);
}

#if UE_REPLICATION_COMPILE_SERVER_CODE
template<typename AgentArrayItem>
FMassReplicatedAgentHandle TClientBubbleHandlerBase<AgentArrayItem>::AddAgent(FMassEntityHandle Entity, typename AgentArrayItem::FReplicatedAgentType& Agent)
{
	checkf(Agent.GetNetID().IsValid(), TEXT("Agent.NetID must be valid!"));
	checkf(NetworkIDToAgentHandleMap.Find(Agent.GetNetID()) == nullptr, TEXT("Only add agents once"));

	FMassReplicatedAgentHandle AgentHandle = AgentHandleManager.GetNextHandle();

	checkf(AgentHandle.GetIndex() <= AgentLookupArray.Num(), TEXT("AgentHandle is out of sync with the AgentLookupArray Array!"));

	const int32 Idx = AgentHandle.GetIndex();

	if (Idx == AgentLookupArray.Num())
	{
		AgentLookupArray.Emplace(Entity, Agent.GetNetID(), (*Agents).Num());
	}
	else
	{
		checkf(AgentLookupArray[Idx].IsValid() == false, TEXT("Agent being replaced must be Invalid (should have been removed first)!"));

		AgentLookupArray[Idx] = FMassAgentLookupData(Entity, Agent.GetNetID(), (*Agents).Num());
	}

	AgentArrayItem& Item = (*Agents).Emplace_GetRef(Agent, AgentHandle);
	Serializer->MarkItemDirty(Item);

	NetworkIDToAgentHandleMap.Add(Agent.GetNetID(), AgentHandle);

	return AgentHandle;
}

template<typename AgentArrayItem>
bool TClientBubbleHandlerBase<AgentArrayItem>::RemoveAgent(FMassNetworkID NetID)
{
	const FMassReplicatedAgentHandle* const AgentHandle = NetworkIDToAgentHandleMap.Find(NetID);

	return (AgentHandle != nullptr) ? RemoveAgent(*AgentHandle) : false;
}

template<typename AgentArrayItem>
bool TClientBubbleHandlerBase<AgentArrayItem>::RemoveAgent(FMassReplicatedAgentHandle AgentHandle)
{
	bool bRemoved = false;

	if (ensureMsgf(AgentHandleManager.IsValidHandle(AgentHandle), TEXT("FMassReplicatedAgentHandle should be Valid")))
	{
		bRemoved = true;
		RemoveAgentImpl(AgentHandle);
	}

	return bRemoved;
}

template<typename AgentArrayItem>
void TClientBubbleHandlerBase<AgentArrayItem>::RemoveAgentChecked(FMassReplicatedAgentHandle Handle)
{
	checkf(AgentHandleManager.IsValidHandle(Handle), TEXT("FMassReplicatedAgentHandle must be Valid"));
	RemoveAgentImpl(Handle);
}

template<typename AgentArrayItem>
void TClientBubbleHandlerBase<AgentArrayItem>::RemoveAgentImpl(FMassReplicatedAgentHandle Handle)
{
	FMassAgentLookupData& LookUpData = AgentLookupArray[Handle.GetIndex()];
	const bool bDidSwap = LookUpData.AgentsIdx < ((*Agents).Num() - 1);

	(*Agents).RemoveAtSwap(LookUpData.AgentsIdx, EAllowShrinking::No);

	Serializer->MarkArrayDirty();

	verifyf(NetworkIDToAgentHandleMap.Remove(LookUpData.NetID) == 1, TEXT("Failed to find 1 matching NetID in NetworkIDToAgentHandleMap"));

	if (bDidSwap)
	{
		//we need to change the AgentsIdx of the Lookup data free list for the item that was swapped
		const FMassReplicatedAgentHandle HandleSwap = (*Agents)[LookUpData.AgentsIdx].GetHandle();
		checkf(AgentHandleManager.IsValidHandle(HandleSwap), TEXT("Handle of the Agent we RemoveAtSwap with must be valid as its in the Agents array"));

		FMassAgentLookupData& LookUpDataSwap = AgentLookupArray[HandleSwap.GetIndex()];
		LookUpDataSwap.AgentsIdx = LookUpData.AgentsIdx;
		checkf(LookUpDataSwap.NetID.IsValid(), TEXT("NetID of item we are swaping with must be valid as its in the Agents array"));
	}

	AgentHandleManager.RemoveHandle(Handle);

	LookUpData.Invalidate();
}

template<typename AgentArrayItem>
const typename AgentArrayItem::FReplicatedAgentType* TClientBubbleHandlerBase<AgentArrayItem>::GetAgent(FMassReplicatedAgentHandle Handle) const
{
	if (AgentHandleManager.IsValidHandle(Handle))
	{
		const FMassAgentLookupData& LookUpData = AgentLookupArray[Handle.GetIndex()];

		return &((*Agents)[LookUpData.AgentsIdx].Agent);
	}
	return nullptr;
}

template<typename AgentArrayItem>
const typename AgentArrayItem::FReplicatedAgentType& TClientBubbleHandlerBase<AgentArrayItem>::GetAgentChecked(FMassReplicatedAgentHandle Handle) const
{
	check(AgentHandleManager.IsValidHandle(Handle));

	const FMassAgentLookupData& LookUpData = AgentLookupArray[Handle.GetIndex()];
	return (*Agents)[LookUpData.AgentsIdx].Agent;
}
#endif //UE_REPLICATION_COMPILE_SERVER_CODE

template<typename AgentArrayItem>
void TClientBubbleHandlerBase<AgentArrayItem>::UpdateAgentsToRemove()
{
#if UE_REPLICATION_COMPILE_CLIENT_CODE
	QUICK_SCOPE_CYCLE_COUNTER(MassProcessor_Replication_CalculateClientReplication);

	check(Serializer->GetWorld());

	UMassReplicationSubsystem* ReplicationSubsystem = Serializer->GetReplicationSubsystem();
	check(ReplicationSubsystem);

	const double TimeRemove = Serializer->GetWorld()->GetRealTimeSeconds() - UE::Mass::Replication::AgentRemoveInterval;

	// @todo do this in a more efficient way, we may potentially be able to use ACK's and FReplicatedAgentBase::bRemovedFromServeSim
	// Check to see if we should free any EntityInfoMap entries, this is to avoid gradually growing EntityInfoMap perpetually
	for (TMap<FMassNetworkID, FMassAgentRemoveData>::TIterator Iter = AgentsRemoveDataMap.CreateIterator(); Iter; ++Iter)
	{
		const FMassAgentRemoveData& RemoveData = (*Iter).Value;

		// The idea here is that AgentRemoveInterval represents a reasonable amount of time that if an out of order add and remove come in after this that we don't care, as the accuracy of the simulation
		// must already be pretty awful.
		if (RemoveData.TimeLastRemoved < TimeRemove)
		{
			const FMassNetworkID NetID = (*Iter).Key;

			ReplicationSubsystem->RemoveFromEntityInfoMap(NetID);
			Iter.RemoveCurrent();
		}
	}
#endif //UE_REPLICATION_COMPILE_CLIENT_CODE
}

#if UE_REPLICATION_COMPILE_CLIENT_CODE
template<typename AgentArrayItem>
void TClientBubbleHandlerBase<AgentArrayItem>::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
{
	TArray<FMassEntityHandle> EntitiesToDestroy;

	UWorld* World = Serializer->GetWorld();
	check(World);

	UMassSpawnerSubsystem* SpawnerSubsystem = Serializer->GetSpawnerSubsystem();
	check(SpawnerSubsystem);

	UMassReplicationSubsystem* ReplicationSubsystem = Serializer->GetReplicationSubsystem();
	check(ReplicationSubsystem);

	for (int32 Idx : RemovedIndices)
	{
		const AgentArrayItem& RemovedItem = (*Agents)[Idx];

		FMassEntityHandle Entity = ReplicationSubsystem->ResetEntityIfValid(RemovedItem.Agent.GetNetID(), RemovedItem.ReplicationID);

		// Only remove the item if its currently Set / Valid and its the most recent ReplicationID. Stale removes after more recent adds are ignored
		// We do need to check the ReplicationID in this case
		if (Entity.IsSet())
		{
			EntitiesToDestroy.Add(Entity);
			
			check(AgentsRemoveDataMap.Find(RemovedItem.Agent.GetNetID()) == nullptr);
			AgentsRemoveDataMap.Add(RemovedItem.Agent.GetNetID(), FMassAgentRemoveData(World->GetRealTimeSeconds()));
		}
	}

	SpawnerSubsystem->DestroyEntities(EntitiesToDestroy);
}
#endif //UE_REPLICATION_COMPILE_CLIENT_CODE

#if UE_REPLICATION_COMPILE_CLIENT_CODE
template<typename AgentArrayItem>
void TClientBubbleHandlerBase<AgentArrayItem>::PostReplicatedAddHelper(const TArrayView<int32> AddedIndices, FAddRequirementsForSpawnQueryFunction AddRequirementsForSpawnQuery
	, FCacheFragmentViewsForSpawnQueryFunction CacheFragmentViewsForSpawnQuery, FSetSpawnedEntityDataFunction SetSpawnedEntityData, FSetModifiedEntityDataFunction SetModifiedEntityData)
{
	FMassEntityManager& EntityManager = Serializer->GetEntityManagerChecked();

	UMassReplicationSubsystem* ReplicationSubsystem = Serializer->GetReplicationSubsystem();
	check(ReplicationSubsystem);

	TMap<FMassNetworkID, int32> AgentsToAddMap; //NetID to index in AgentsToAddArray
	AgentsToAddMap.Reserve(AddedIndices.Num());

	TArray<int32> AgentsToAddArray;
	AgentsToAddArray.Reserve(AddedIndices.Num());

	const FMassReplicationEntityInfo* EntityInfo;

	for (int32 Idx : AddedIndices)
	{
		const AgentArrayItem& AddedItem = (*Agents)[Idx];

		switch (ReplicationSubsystem->FindAndUpdateOrAddMassEntityInfo(AddedItem.Agent.GetNetID(), AddedItem.ReplicationID, EntityInfo))
		{
		case UMassReplicationSubsystem::EFindOrAddMassEntityInfo::FoundOlderReplicationID:
		{
			AgentsRemoveDataMap.Remove(AddedItem.Agent.GetNetID());

			// If EntityData IsSet() it means we have had multiple Adds without a remove and we treat this add as modifying an existing agent.
			if (EntityInfo->Entity.IsSet())
			{
				FMassEntityView EntityView(EntityManager, EntityInfo->Entity);

				SetModifiedEntityData(EntityView, AddedItem.Agent);
			}
			else // This entity is not in the client simulation yet and needs adding.
			{
				const int32* IdxInAgentsToAddArray = AgentsToAddMap.Find(AddedItem.Agent.GetNetID());

				// If IdxInAgentsToAddArray then we've had multiple Adds
				if (IdxInAgentsToAddArray)
				{
					// Adjust the existing AgentsToAddArray index
					AgentsToAddArray[*IdxInAgentsToAddArray] = Idx;
				}
				else // First time we've tried to add an entity with this FMassNetworkID this update
				{	
					const int32 IdxAdd = AgentsToAddArray.Add(Idx);
					AgentsToAddMap.Add(AddedItem.Agent.GetNetID(), IdxAdd);
				}
			}
		}
		break;

		case UMassReplicationSubsystem::EFindOrAddMassEntityInfo::Added:
		{
			check(AgentsToAddMap.Find(AddedItem.Agent.GetNetID()) == nullptr);

			const int32 IdxAdd = AgentsToAddArray.Add(Idx);
			AgentsToAddMap.Add(AddedItem.Agent.GetNetID(), IdxAdd);
		}
		break;

		case UMassReplicationSubsystem::EFindOrAddMassEntityInfo::FoundNewerReplicationID:
			break;

		default:
			checkf(false, TEXT("Unhandled EFindOrAddMassEntityInfo type"));
			break;
		}
	}

	PostReplicatedAddEntitiesHelper(AgentsToAddArray, AddRequirementsForSpawnQuery, CacheFragmentViewsForSpawnQuery, SetSpawnedEntityData);
}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

#if UE_REPLICATION_COMPILE_CLIENT_CODE
template<typename AgentArrayItem>
void TClientBubbleHandlerBase<AgentArrayItem>::PostReplicatedAddEntitiesHelper(const TArrayView<int32> AddedIndices, FAddRequirementsForSpawnQueryFunction AddRequirementsForSpawnQuery
	, FCacheFragmentViewsForSpawnQueryFunction CacheFragmentViewsForSpawnQuery, FSetSpawnedEntityDataFunction SetSpawnedEntityData)
{
	check(Serializer);

	FMassEntityManager& EntityManager = Serializer->GetEntityManagerChecked();

	UMassSpawnerSubsystem* SpawnerSubsystem = Serializer->GetSpawnerSubsystem();
	check(SpawnerSubsystem);

	UMassReplicationSubsystem* ReplicationSubsystem = Serializer->GetReplicationSubsystem();
	check(ReplicationSubsystem);

	TMap<FMassEntityTemplateID, TArray<typename AgentArrayItem::FReplicatedAgentType*>> AgentsSpawnMap;

	// Group together Agents per TemplateID
	for (int32 Idx : AddedIndices)
	{
		typename AgentArrayItem::FReplicatedAgentType& Agent = (*Agents)[Idx].Agent;

		TArray<typename AgentArrayItem::FReplicatedAgentType*>& AgentsArray = AgentsSpawnMap.FindOrAdd(Agent.GetTemplateID());
		AgentsArray.Add(&Agent);
	}

	// Batch spawn per FMassEntityTemplateID
	for (const TPair<FMassEntityTemplateID, TArray<typename AgentArrayItem::FReplicatedAgentType*>>& Item : AgentsSpawnMap)
	{
		const FMassEntityTemplateID& TemplateID = Item.Key;
		const TArray <typename AgentArrayItem::FReplicatedAgentType*>& AgentsSpawn = Item.Value;

		TArray<FMassEntityHandle> Entities;

		SpawnerSubsystem->SpawnEntities(TemplateID, AgentsSpawn.Num(), FStructView(), TSubclassOf<UMassProcessor>(), Entities);

		const FMassEntityTemplate* MassEntityTemplate = SpawnerSubsystem->GetMassEntityTemplate(TemplateID);
		check(MassEntityTemplate);
		const FMassArchetypeHandle& ArchetypeHandle = MassEntityTemplate->GetArchetype();


		FMassExecutionContext ExecContext(EntityManager);
		FMassEntityQuery Query;

		AddRequirementsForSpawnQuery(Query);

		Query.AddRequirement<FMassNetworkIDFragment>(EMassFragmentAccess::ReadWrite);

		int32 AgentsSpawnIdx = 0;

		Query.ForEachEntityChunk(FMassArchetypeEntityCollection(ArchetypeHandle, Entities, FMassArchetypeEntityCollection::NoDuplicates)
								, EntityManager, ExecContext, [&AgentsSpawn, &AgentsSpawnIdx, this, ReplicationSubsystem, &ExecContext, &CacheFragmentViewsForSpawnQuery, &SetSpawnedEntityData, &EntityManager](FMassExecutionContext& Context)
			{
				CacheFragmentViewsForSpawnQuery(ExecContext);

				const TArrayView<FMassNetworkIDFragment> NetworkIDList = Context.GetMutableFragmentView<FMassNetworkIDFragment>();

				for (int32 i = 0; i < Context.GetNumEntities(); ++i)
				{
					const typename AgentArrayItem::FReplicatedAgentType& AgentSpawn = *AgentsSpawn[AgentsSpawnIdx];
					const FMassEntityHandle Entity = Context.GetEntity(i);

					FMassNetworkIDFragment& NetIDFragment = NetworkIDList[i];

					NetIDFragment.NetID = AgentSpawn.GetNetID();
					ReplicationSubsystem->SetEntity(NetIDFragment.NetID, Entity);

					FMassEntityView EntityView(EntityManager, Entity);
					SetSpawnedEntityData(EntityView, AgentSpawn, i);

					++AgentsSpawnIdx;
				}
			});
	}
}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

#if UE_REPLICATION_COMPILE_CLIENT_CODE
template<typename AgentArrayItem>
void TClientBubbleHandlerBase<AgentArrayItem>::PostReplicatedChangeHelper(const TArrayView<int32> ChangedIndices, FSetModifiedEntityDataFunction SetModifiedEntityData)
{
	FMassEntityManager& EntityManager = Serializer->GetEntityManagerChecked();

	UMassReplicationSubsystem* ReplicationSubsystem = Serializer->GetReplicationSubsystem();
	check(ReplicationSubsystem);

	// Go through the changed Entities and update their Mass data
	for (int32 Idx : ChangedIndices)
	{
		const AgentArrayItem& ChangedItem = (*Agents)[Idx];

		const FMassReplicationEntityInfo* EntityInfo = ReplicationSubsystem->FindMassEntityInfo(ChangedItem.Agent.GetNetID());

		checkf(EntityInfo, TEXT("EntityInfo must be valid if the Agent has already been added (which it must have been to get PostReplicatedChange"));
		checkf(EntityInfo->ReplicationID >= ChangedItem.ReplicationID, TEXT("ReplicationID out of sync, this should never happen!"));

		// Currently we don't think this should be needed, but are leaving it in for bomb proofing.
		if (ensure(EntityInfo->ReplicationID == ChangedItem.ReplicationID))
		{
			FMassEntityView EntityView(EntityManager, EntityInfo->Entity);
			SetModifiedEntityData(EntityView, ChangedItem.Agent);
		}
	}
}
#endif //UE_REPLICATION_COMPILE_CLIENT_CODE

template<typename AgentArrayItem>
void TClientBubbleHandlerBase<AgentArrayItem>::SetClientHandle(FMassClientHandle InClientHandle)
{
	ClientHandle = InClientHandle;
}

template<typename AgentArrayItem>
void TClientBubbleHandlerBase<AgentArrayItem>::Reset()
{
	(*Agents).Reset();

#if UE_REPLICATION_COMPILE_SERVER_CODE
	AgentHandleManager.Reset();
	NetworkIDToAgentHandleMap.Reset();
	AgentLookupArray.Reset();
#endif //UE_REPLICATION_COMPILE_SERVER_CODE
}

template<typename AgentArrayItem>
void TClientBubbleHandlerBase<AgentArrayItem>::Tick(float DeltaTime)
{
	UWorld* World = Serializer->GetWorld();
	check(World);

	const ENetMode NetMode = World->GetNetMode();

	if (NetMode != NM_Client)
	{
		DebugValidateBubbleOnServer();
	}
	else
	{
		DebugValidateBubbleOnClient();

		UpdateAgentsToRemove();
	}
}

template<typename AgentArrayItem>
void TClientBubbleHandlerBase<AgentArrayItem>::DebugValidateBubbleOnClient()
{
#if UE_ALLOW_DEBUG_REPLICATION
	const FMassEntityManager& EntityManager = Serializer->GetEntityManagerChecked();

	UMassReplicationSubsystem* ReplicationSubsystem = Serializer->GetReplicationSubsystem();
	check(ReplicationSubsystem);

	for (int32 Idx = 0; Idx < (*Agents).Num(); ++Idx)
	{
		const AgentArrayItem& Item = (*Agents)[Idx];
		const typename AgentArrayItem::FReplicatedAgentType& Agent = Item.Agent;

		check(Agent.GetTemplateID().IsValid());
		check(Agent.GetNetID().IsValid());

		const FMassReplicationEntityInfo* EntityInfo = ReplicationSubsystem->FindMassEntityInfo(Agent.GetNetID());
		checkf(EntityInfo, TEXT("There should always be an EntityInfoMap entry for Agents that are in the Agents array!"));

		if (EntityInfo)
		{
			if (EntityInfo->ReplicationID == Item.ReplicationID)
			{
				const bool bIsEntityValid = EntityManager.IsEntityValid(EntityInfo->Entity);
				checkf(bIsEntityValid, TEXT("Must be valid entity if at latest ReplciationID"));

				if (bIsEntityValid)
				{
					const FMassNetworkIDFragment& FragmentNetID = EntityManager.GetFragmentDataChecked<FMassNetworkIDFragment>(EntityInfo->Entity);

					checkf(FragmentNetID.NetID == Agent.GetNetID(), TEXT("Fragment and Agent NetID do not match!"));
				}
			}
		}
	}

#if UE_ALLOW_DEBUG_SLOW_REPLICATION
	const TMap<FMassNetworkID, FMassReplicationEntityInfo>& EntityInfoMap = ReplicationSubsystem->GetEntityInfoMap();

	for (TMap<FMassNetworkID, FMassReplicationEntityInfo>::TConstIterator Iter = EntityInfoMap.CreateConstIterator(); Iter; ++Iter)
	{
		if (Iter->Value.Entity.IsSet())
		{
			checkf(AgentsRemoveDataMap.Find(Iter->Key) == nullptr, TEXT("If Entity.IsSet() we should not have an entry in AgentsRemoveDataMap!"));
		}
	}

	for (TMap<FMassNetworkID, FMassAgentRemoveData>::TIterator Iter = AgentsRemoveDataMap.CreateIterator(); Iter; ++Iter)
	{
		const FMassReplicationEntityInfo* EntityInfo = EntityInfoMap.Find(Iter->Key);
		check(EntityInfo);

		checkf(EntityInfo->Entity.IsSet() == false, TEXT("AgentsRemoveDataMap NetIDs in EntityInfoMap should be !Entity.IsSet()"));
	}
#endif // UE_ALLOW_DEBUG_SLOW_REPLICATION

#endif // UE_ALLOW_DEBUG_REPLICATION
}

template<typename AgentArrayItem>
void TClientBubbleHandlerBase<AgentArrayItem>::DebugValidateBubbleOnServer()
{
#if UE_ALLOW_DEBUG_REPLICATION
	using namespace UE::Mass::Replication;

	const FMassEntityManager& EntityManager = Serializer->GetEntityManagerChecked();

	for (int32 OuterIdx = 0; OuterIdx < (*Agents).Num(); ++OuterIdx)
	{
		const AgentArrayItem& OuterItem = (*Agents)[OuterIdx];

		//check there are no duplicate NetID's'
		if (OuterItem.Agent.GetNetID().IsValid())
		{
			for (int32 InnerIdx = OuterIdx + 1; InnerIdx < (*Agents).Num(); ++InnerIdx)
			{
				const AgentArrayItem& InnerItem = (*Agents)[InnerIdx];

				checkf(InnerItem.Agent.GetNetID() != OuterItem.Agent.GetNetID(), TEXT("Repeated NetIDs in the server Agents array"));
			}
		}
		checkf(OuterItem.Agent.GetTemplateID().IsValid(), TEXT("Server Agent with Invalid TemplateID"));
		checkf(AgentHandleManager.IsValidHandle(OuterItem.GetHandle()), TEXT("Server Agent with Invalid Handle"));
		checkf(OuterItem.Agent.GetNetID().IsValid(), TEXT("Server Agent with Invalid NetID"));

		const FMassAgentLookupData& LookupData = AgentLookupArray[OuterItem.GetHandle().GetIndex()];

		checkf(LookupData.AgentsIdx == OuterIdx, TEXT("Agent index must match lookup data!"));
		checkf(EntityManager.IsEntityValid(LookupData.Entity), TEXT("Must be valid entity"));

		const FMassNetworkIDFragment& FragmentNetID = EntityManager.GetFragmentDataChecked<FMassNetworkIDFragment>(LookupData.Entity);

		checkf(FragmentNetID.NetID == OuterItem.Agent.GetNetID(), TEXT("Fragment and Agent NetID do not match!"));
		checkf(LookupData.NetID == OuterItem.Agent.GetNetID(), TEXT("LookupData and Agent NetID do not match!"));

		const FReplicationTemplateIDFragment& FragmentTemplateID = EntityManager.GetFragmentDataChecked<FReplicationTemplateIDFragment>(LookupData.Entity);
		checkf(FragmentTemplateID.ID == OuterItem.Agent.GetTemplateID(), TEXT("Agent TemplateID different to Fragment!"));
	}

	checkf(AgentHandleManager.CalcNumUsedHandles() == (*Agents).Num(), TEXT("Num used Agent handles must be the same as the size of the agents array!"));
#endif // UE_ALLOW_DEBUG_REPLICATION
}

===============================================================


=== Source/MassReplication/Public/MassClientBubbleInfoBase.h ===
================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "GameFramework/Info.h"
#include "MassReplicationTypes.h"
#include "Engine/World.h"

#include "MassClientBubbleInfoBase.generated.h"

struct FMassClientBubbleSerializerBase;

/** The info actor base class that provides the actual replication */
UCLASS()
class MASSREPLICATION_API AMassClientBubbleInfoBase : public AInfo
{
	GENERATED_BODY()

public:
	AMassClientBubbleInfoBase(const FObjectInitializer& ObjectInitializer);

	void SetClientHandle(FMassClientHandle InClientHandle);

protected:
	virtual void PostInitProperties() override;

	// Called either on PostWorldInit() or PostInitProperties()
	virtual void InitializeForWorld(UWorld& World);

	virtual void BeginPlay() override;
	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;
	virtual void Tick(float DeltaTime) override;

private:
	void OnPostWorldInit(UWorld* World, const UWorld::InitializationValues);

protected:
	FDelegateHandle OnPostWorldInitDelegateHandle;
	TArray<FMassClientBubbleSerializerBase*> Serializers;
};

================================================================


=== Source/MassReplication/Public/MassClientBubbleSerializerBase.h ===
======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Engine/NetSerialization.h"
#include "MassReplicationTypes.h"
#include "Net/Serialization/FastArraySerializer.h"

#include "MassClientBubbleSerializerBase.generated.h"


class UWorld;
class UMassSpawnerSubsystem;
struct FMassEntityManager;
class IClientBubbleHandlerInterface;

/**
 * Classes derived from this will contain the IClientBubbleHandlerInterface derived class as well as the actual Fast Array.
 * This class mainly provides the base automation with the IClientBubbleHandlerInterface
 */
USTRUCT()
struct MASSREPLICATION_API FMassClientBubbleSerializerBase : public FFastArraySerializer
{
	GENERATED_BODY()

public:

#if UE_REPLICATION_COMPILE_CLIENT_CODE
	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize) const;
	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize) const;
	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize) const;
#endif //UE_REPLICATION_COMPILE_CLIENT_CODE

	void InitializeForWorld(UWorld& InWorld);

	UWorld* GetWorld() const { return World; }
	UMassSpawnerSubsystem* GetSpawnerSubsystem() const { return SpawnerSubsystem; }
	UMassReplicationSubsystem* GetReplicationSubsystem() const { return ReplicationSubsystem; }
	FMassEntityManager& GetEntityManagerChecked() const { check(EntityManager); return *EntityManager.Get(); }

	void SetClientHandler(IClientBubbleHandlerInterface& InClientHandler) { ClientHandler = &InClientHandler; }
	IClientBubbleHandlerInterface* GetClientHandler() const { return ClientHandler; }

	void ShutDown();

private:
	UPROPERTY(Transient)
	TObjectPtr<UWorld> World = nullptr;

	UPROPERTY(Transient)
	TObjectPtr<UMassSpawnerSubsystem> SpawnerSubsystem = nullptr;

	TSharedPtr<FMassEntityManager> EntityManager;

	UPROPERTY(Transient)
	TObjectPtr<UMassReplicationSubsystem> ReplicationSubsystem = nullptr;

	/** Pointer to the IClientBubbleHandlerInterface derived class in the class derived from this one */
	IClientBubbleHandlerInterface* ClientHandler = nullptr;
};

======================================================================


=== Source/MassReplication/Public/MassReplicationFragments.h ===
================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassCommonTypes.h"
#include "MassReplicationTypes.h"
#include "MassLODCollector.h"
#include "MassLODCalculator.h"

#include "MassReplicationFragments.generated.h"

class AMassClientBubbleInfoBase;
class UMassReplicatorBase;

/**
 *  Fragment type for the mass network id of a mass entity
 */
USTRUCT()
struct MASSREPLICATION_API FMassNetworkIDFragment : public FMassFragment
{
	GENERATED_BODY()

	FMassNetworkID NetID;
};

/**
 * Agent handle per client, these will be at TArray indices of the Client handles indicies (used as a free list array)
 */
USTRUCT()
struct MASSREPLICATION_API FMassReplicatedAgentFragment : public FMassFragment
{
	GENERATED_BODY()

	FMassReplicatedAgentData AgentData;
};

/*
 * Data fragment to store the calculated distances to viewers
 */
USTRUCT()
struct MASSREPLICATION_API FMassReplicationViewerInfoFragment : public FMassFragment
{
	GENERATED_BODY()

	/** Closest viewer distance */
	float ClosestViewerDistanceSq;

	/** Distance between each viewer and entity */
	TArray<float> DistanceToViewerSq;
};

USTRUCT()
struct MASSREPLICATION_API FMassReplicationLODFragment : public FMassFragment
{
	GENERATED_BODY()

	/**LOD information */
	TEnumAsByte<EMassLOD::Type> LOD = EMassLOD::Max;

	/** Previous LOD information*/
	TEnumAsByte<EMassLOD::Type> PrevLOD = EMassLOD::Max;
};

UCLASS()
class MASSREPLICATION_API UMassNetworkIDFragmentInitializer : public UMassObserverProcessor
{
	GENERATED_BODY()
public:
	UMassNetworkIDFragmentInitializer();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};

USTRUCT()
struct FMassReplicationParameters : public FMassConstSharedFragment
{
	GENERATED_BODY()
public:
	FMassReplicationParameters();

	/** Distance where each LOD becomes relevant */
	UPROPERTY(EditAnywhere, Category = "Mass|LOD", config)
	float LODDistance[EMassLOD::Max];

	/** Hysteresis percentage on delta between the LOD distances */
	UPROPERTY(EditAnywhere, Category = "Mass|LOD", meta = (ClampMin = "0.0", UIMin = "0.0"), config)
	float BufferHysteresisOnDistancePercentage = 10.0f;

	/** Maximum limit of entity per LOD */
	UPROPERTY(EditAnywhere, Category = "Mass|LOD", config)
	int32 LODMaxCount[EMassLOD::Max];

	/** Maximum limit of entity per LOD per viewer */
	UPROPERTY(EditAnywhere, Category = "Mass|LOD", config)
	int32 LODMaxCountPerViewer[EMassLOD::Max];

	/** Distance where each LOD becomes relevant */
	UPROPERTY(EditAnywhere, Category = "Mass|LOD", config)
	float UpdateInterval[EMassLOD::Max];

	UPROPERTY(EditAnywhere, Category = "Mass|Replication", config)
	TSubclassOf<AMassClientBubbleInfoBase> BubbleInfoClass;

	UPROPERTY(EditAnywhere, Category = "Mass|Replication", config)
	TSubclassOf<UMassReplicatorBase> ReplicatorClass;

};

USTRUCT()
struct FMassReplicationSharedFragment : public FMassSharedFragment
{
	GENERATED_BODY()
public:
	FMassReplicationSharedFragment() = default;
	FMassReplicationSharedFragment(UMassReplicationSubsystem& ReplicationSubsystem, const FMassReplicationParameters& Params);

	FMassBubbleInfoClassHandle BubbleInfoClassHandle;

	FMassClientHandle CurrentClientHandle;
	TArray<FMassClientHandle> CachedClientHandles;

	//TODO review if we need to have this as a UPROPERTY at all and also if we can make this use a TInlineAllocator
	//Can not use TInlineAllocator with UPROPERTY()
	UPROPERTY(Transient)
	TArray<TObjectPtr<AMassClientBubbleInfoBase>> BubbleInfos;

	TMassLODCollector<FReplicationLODLogic> LODCollector;
	TMassLODCalculator<FReplicationLODLogic> LODCalculator;
	bool bHasAdjustedDistancesFromCount = false;

	bool bEntityQueryInitialized = false;
	FMassEntityQuery EntityQuery;

	UPROPERTY(Transient)
	mutable TObjectPtr<UMassReplicatorBase> CachedReplicator = nullptr;

	template<typename T>
	T& GetTypedClientBubbleInfoChecked(FMassClientHandle Handle)
	{
		checkSlow(BubbleInfos.IsValidIndex(Handle.GetIndex()));

		AMassClientBubbleInfoBase* BubbleInfo = BubbleInfos[Handle.GetIndex()];

		checkSlow(BubbleInfo && Cast<T>(BubbleInfo) != nullptr);

		return *static_cast<T*>(BubbleInfo);
	}
};

/** Cell location for replicated mass agents, used to fetch quickly the agents around each clients */
USTRUCT()
struct MASSREPLICATION_API FMassReplicationGridCellLocationFragment : public FMassFragment
{
	GENERATED_BODY()
	FReplicationHashGrid2D::FCellLocation CellLoc;
};

/** Component Tag to tell if the entity is in the replication grid */
USTRUCT()
struct MASSREPLICATION_API FMassInReplicationGridTag : public FMassTag
{
	GENERATED_BODY()
};
================================================================


=== Source/MassReplication/Public/MassReplicationGridProcessor.h ===
====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassProcessor.h"
#include "MassEntityQuery.h"
#include "MassObserverProcessor.h"

#include "MassReplicationGridProcessor.generated.h"

class UMassReplicationSubsystem;

/** Processor to update entity in the replication grid used to fetch entities close to clients */
UCLASS()
class MASSREPLICATION_API UMassReplicationGridProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassReplicationGridProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

private:
	FMassEntityQuery AddToGridEntityQuery;
	FMassEntityQuery UpdateGridEntityQuery;
	FMassEntityQuery RemoveFromGridEntityQuery;
};

/** Deinitializer processor to remove entity from the replication grid */
UCLASS()
class MASSREPLICATION_API UMassReplicationGridRemoverProcessor : public UMassObserverProcessor
{
	GENERATED_BODY()

	UMassReplicationGridRemoverProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};
====================================================================


=== Source/MassReplication/Public/MassReplicationProcessor.h ===
================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Engine/World.h"
#include "MassProcessor.h"
#include "MassCommonTypes.h"
#include "MassSimulationLOD.h"
#include "MassReplicationTypes.h"
#include "MassReplicationFragments.h"
#include "MassSpawnerTypes.h"
#include "MassProcessor.h"
#include "MassReplicationSubsystem.h"
#include "MassReplicationProcessor.generated.h"

class UMassReplicationSubsystem;
class AMassClientBubbleInfoBase;
class UWorld;

/** 
 *  Base processor that handles replication and only runs on the server. You should derive from this per entity type (that require different replication processing). It and its derived classes 
 *  query Mass entity fragments and set those values for replication when appropriate, using the MassClientBubbleHandler.
 */
UCLASS()
class MASSREPLICATION_API UMassReplicationProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassReplicationProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Initialize(UObject& Owner) override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	void PrepareExecution(FMassEntityManager& EntityManager);

protected:

	UPROPERTY(Transient)
	TObjectPtr<UMassReplicationSubsystem> ReplicationSubsystem = nullptr;

	FMassEntityQuery SyncClientData;
	FMassEntityQuery CollectViewerInfoQuery;
	FMassEntityQuery CalculateLODQuery;
	FMassEntityQuery AdjustLODDistancesQuery;
	FMassEntityQuery EntityQuery;
};


struct FMassReplicationContext
{
	FMassReplicationContext(UWorld& InWorld, const UMassLODSubsystem& InLODSubsystem, UMassReplicationSubsystem& InReplicationSubsystem)
		: World(InWorld)
		, LODSubsystem(InLODSubsystem)
		, ReplicationSubsystem(InReplicationSubsystem)
	{}

	UWorld& World;
	const UMassLODSubsystem& LODSubsystem;
	UMassReplicationSubsystem& ReplicationSubsystem;
};

UCLASS(Abstract)
class MASSREPLICATION_API UMassReplicatorBase : public UObject
{
	GENERATED_BODY()

public:
	/**
	 * Must override to add specific entity query requirements for replication
	 * Usually we add replication processor handler requirements
	 */
	virtual void AddRequirements(FMassEntityQuery& EntityQuery) PURE_VIRTUAL(UMassReplicatorBase::ConfigureQueries, );

	/**
	 * Must override to process the client replication
	 * This methods should call CalculateClientReplication with the appropriate callback implementation
	 */
	virtual void ProcessClientReplication(FMassExecutionContext& Context, FMassReplicationContext& ReplicationContext) PURE_VIRTUAL(UMassReplicatorBase::ProcessClientReplication, );

protected:
	/**
	 *  Implemented as straight template callbacks as when profiled this was faster than TFunctionRef. Its probably easier to pass Lamdas in to these
	 *  but Functors can also be used as well as TFunctionRefs etc. Its also fairly straight forward to call member functions via some Lamda glue code
	 */
	template<typename AgentArrayItem, typename CacheViewsCallback, typename AddEntityCallback, typename ModifyEntityCallback, typename RemoveEntityCallback>
	static void CalculateClientReplication(FMassExecutionContext& Context, FMassReplicationContext& ReplicationContext, CacheViewsCallback&& CacheViews, AddEntityCallback&& AddEntity, ModifyEntityCallback&& ModifyEntity, RemoveEntityCallback&& RemoveEntity);
};

template<typename AgentArrayItem, typename CacheViewsCallback, typename AddEntityCallback, typename ModifyEntityCallback, typename RemoveEntityCallback>
void UMassReplicatorBase::CalculateClientReplication(FMassExecutionContext& Context, FMassReplicationContext& ReplicationContext, CacheViewsCallback&& CacheViews, AddEntityCallback&& AddEntity, ModifyEntityCallback&& ModifyEntity, RemoveEntityCallback&& RemoveEntity)
{
#if UE_REPLICATION_COMPILE_SERVER_CODE

	const int32 NumEntities = Context.GetNumEntities();

	TConstArrayView<FMassNetworkIDFragment> NetworkIDList = Context.GetFragmentView<FMassNetworkIDFragment>();
	TArrayView<FMassReplicationLODFragment> ViewerLODList = Context.GetMutableFragmentView<FMassReplicationLODFragment>();
	TArrayView<FMassReplicatedAgentFragment> ReplicatedAgentList = Context.GetMutableFragmentView<FMassReplicatedAgentFragment>();
	TConstArrayView<FReplicationTemplateIDFragment> TemplateIDList = Context.GetFragmentView<FReplicationTemplateIDFragment>();
	FMassReplicationSharedFragment& RepSharedFragment = Context.GetMutableSharedFragment<FMassReplicationSharedFragment>();

	CacheViews(Context);

	const double Time = ReplicationContext.World.GetRealTimeSeconds();

	for (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
	{
		FMassReplicatedAgentFragment& AgentFragment = ReplicatedAgentList[EntityIdx];

		const FMassClientHandle& ClientHandle = RepSharedFragment.CurrentClientHandle;
		check(ClientHandle.IsValid());

		checkSlow(RepSharedFragment.BubbleInfos[ClientHandle.GetIndex()] != nullptr);

		FMassReplicatedAgentData& AgentData = AgentFragment.AgentData;

		const EMassLOD::Type LOD = ViewerLODList[EntityIdx].LOD;

		if (LOD < EMassLOD::Off)
		{
			AgentData.LOD = LOD;

			//if the handle isn't valid we need to add the agent
			if (!AgentData.Handle.IsValid())
			{
				typename AgentArrayItem::FReplicatedAgentType ReplicatedAgent;

				const FMassNetworkIDFragment& NetIDFragment = NetworkIDList[EntityIdx];
				const FReplicationTemplateIDFragment& TemplateIDFragment = TemplateIDList[EntityIdx];

				ReplicatedAgent.SetNetID(NetIDFragment.NetID);
				ReplicatedAgent.SetTemplateID(TemplateIDFragment.ID);

				AgentData.Handle = AddEntity(Context, EntityIdx, ReplicatedAgent, ClientHandle);

				AgentData.LastUpdateTime = Time;
			}
			else
			{
				ModifyEntity(Context, EntityIdx, LOD, Time, AgentData.Handle, ClientHandle);
			}
		}
		else
		{
			// as this is a fresh handle, if its valid then we can use the unsafe remove function
			if (AgentData.Handle.IsValid())
			{
				RemoveEntity(Context, AgentData.Handle, ClientHandle);
				AgentData.Invalidate();
			}
		}
	}
#endif //UE_REPLICATION_COMPILE_SERVER_CODE
}

================================================================


=== Source/MassReplication/Public/MassReplicationSettings.h ===
===============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassSettings.h"
#include "MassReplicationSettings.generated.h"

UCLASS(config = Mass, defaultconfig, meta = (DisplayName = "Mass Replication"))
class MASSREPLICATION_API UMassReplicationSettings : public UMassModuleSettings
{
	GENERATED_BODY()

public:
	static const UMassReplicationSettings* Get()
	{
		return GetDefault<UMassReplicationSettings>();
	}

	float GetReplicationGridCellSize() const
	{ 
		return ReplicationGridCellSize; 
	}
	
private:

	UPROPERTY(EditAnywhere, config, Category = Replication);
	float ReplicationGridCellSize = 5000.0f; // 50 meters;
};

===============================================================


=== Source/MassReplication/Public/MassReplicationSubsystem.h ===
================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassCommonTypes.h"
#include "MassEntityTypes.h"
#include "MassReplicationTypes.h"
#include "MassSubsystemBase.h"

#include "MassReplicationSubsystem.generated.h"

struct FMassEntityManager;
class UMassLODSubsystem;
class AMassClientBubbleInfoBase;

typedef TMap<FMassEntityHandle, FMassReplicatedAgentData> FMassReplicationAgentDataMap;

struct FMassClientReplicationInfo
{
	void Reset()
	{
		Handles.Reset();
		HandledEntities.Reset();
		AgentsData.Reset();
	}

	/** Note this struct is constructed IsEmpty() == true */
	bool IsEmpty() const
	{
		return (Handles.Num() == 0) && (HandledEntities.Num() == 0) && (AgentsData.Num() == 0);
	}

	/** Array of all the viewer of this client */
	TArray<FMassViewerHandle> Handles;

	/** Array of all the entities handled by this client 
	  * This array might contains duplicates if there is more than one viewer per client as this concatenates the entities from all viewer of a client) */
	TArray<FMassEntityHandle> HandledEntities;

	/** The saved agent data of the entities handle by this client */
	FMassReplicationAgentDataMap AgentsData;
};

struct FViewerClientPair
{
	FViewerClientPair() = default;

	FViewerClientPair(FMassViewerHandle InViewerHandle, FMassClientHandle InClientHandle)
		: ViewerHandle(InViewerHandle)
		, ClientHandle(InClientHandle)
	{}

	bool operator== (FViewerClientPair Other) const { return ViewerHandle == Other.ViewerHandle && ClientHandle == Other.ClientHandle; }

	bool IsValid() const { return ViewerHandle.IsValid() && ClientHandle.IsValid(); }
	void Invalidate() { ViewerHandle.Invalidate(); ClientHandle.Invalidate(); }

	FMassViewerHandle ViewerHandle;
	FMassClientHandle ClientHandle;
};

USTRUCT()
struct FMassClientBubbleInfoData
{
	GENERATED_BODY()

	FMassClientBubbleInfoData() = default;

	FMassClientBubbleInfoData(TSubclassOf<AMassClientBubbleInfoBase> InBubbleClass)
		: BubbleClass(InBubbleClass)
	{}

	/** A free list array of AMassClientBubbleInfos. This is organised so the index is that of the client FMassClientHandle */
	UPROPERTY(Transient)
	TArray<TObjectPtr<AMassClientBubbleInfoBase>> Bubbles;

	UPROPERTY(Transient)
	TSubclassOf<AMassClientBubbleInfoBase> BubbleClass;
};

namespace UE::MassReplication
{
	DECLARE_MULTICAST_DELEGATE_TwoParams(FMassAgentDelegate, FMassNetworkID, FMassEntityHandle);

} // UE::MassReplication

/**
 *  Manages the creation of NetworkIDs, ClientBubbles and ClientReplicationInfo.
 *  NetworkIDs are per replicated Agent Entity and are unique and replicated between server and clients.
 *  ClientBubbles relate to the player controller that owns the parent UNetConnection to a Client machine.
 *  ClientReplicationInfo relate to all the player controllers that have a parent or child UNetConnection to a single Client machine (split screen etc).
 */
UCLASS()
class MASSREPLICATION_API UMassReplicationSubsystem : public UMassSubsystemBase
{
	GENERATED_BODY()

public:

	UMassReplicationSubsystem();

	enum class EFindOrAddMassEntityInfo : uint8
	{
		FoundOlderReplicationID,
		FoundNewerReplicationID,
		Added,
	};

	bool IsBubbleClassHandleValid(FMassBubbleInfoClassHandle Handle) const
	{
		return BubbleInfoArray.IsValidIndex(Handle.GetIndex());
	}

	/** Retrieve network id from Mass handle. */
	FMassNetworkID GetNetIDFromHandle(const FMassEntityHandle Handle) const;

	static inline FMassNetworkID GetNextAvailableMassNetID() { return FMassNetworkID(++CurrentNetMassCounter); }

	const TArray<FMassClientHandle>& GetClientReplicationHandles() const { return ClientHandleManager.GetHandles(); }

	bool IsValidClientHandle(FMassClientHandle ClientHandle) const
	{
		return ClientHandleManager.IsValidHandle(ClientHandle);
	}

	/** Gets the client bubble safely */
	AMassClientBubbleInfoBase* GetClientBubble(FMassBubbleInfoClassHandle BubbleClassHandle, FMassClientHandle ClientHandle) const
	{
		AMassClientBubbleInfoBase* ClientBubble = nullptr;

		if (IsBubbleClassHandleValid(BubbleClassHandle) && ClientHandleManager.IsValidHandle(ClientHandle))
		{
			ClientBubble = BubbleInfoArray[BubbleClassHandle.GetIndex()].Bubbles[ClientHandle.GetIndex()];
			check(ClientBubble);
		}
		return ClientBubble;
	}

	/** Get the client bubble. Faster version using check()s */
	AMassClientBubbleInfoBase* GetClientBubbleChecked(FMassBubbleInfoClassHandle BubbleClassHandle, FMassClientHandle ClientHandle) const
	{
		check(IsBubbleClassHandleValid(BubbleClassHandle));
		check(ClientHandleManager.IsValidHandle(ClientHandle));
		AMassClientBubbleInfoBase* ClientBubble = BubbleInfoArray[BubbleClassHandle.GetIndex()].Bubbles[ClientHandle.GetIndex()];

		check(ClientBubble);
		return ClientBubble;
	}

	/** Gets the client bubble safely returning the template type */
	template<typename TType>
	TType* GetTypedClientBubble(FMassBubbleInfoClassHandle BubbleClassHandle, FMassClientHandle ClientHandle) const
	{
		return Cast<TType>(GetClientBubble(BubbleClassHandle, ClientHandle));
	}

	/** Gets the client bubble returning the template type. Faster version using check()s */
	template<typename TType>
	TType* GetTypedClientBubbleChecked(FMassBubbleInfoClassHandle BubbleClassHandle, FMassClientHandle ClientHandle) const
	{
		AMassClientBubbleInfoBase* ClientBubble = GetClientBubbleChecked(BubbleClassHandle, ClientHandle);
		checkSlow(Cast<TType>(ClientBubble) != nullptr);

		return static_cast<TType *>(ClientBubble);
	}

	/** Gets the client replication info safely */
	const FMassClientReplicationInfo* GetClientReplicationInfo(FMassClientHandle Handle) const
	{
		return ClientHandleManager.IsValidHandle(Handle) ? &(ClientsReplicationInfo[Handle.GetIndex()]) : nullptr;
	}

	/** Gets the client replication info. Faster version using check()s */
	const FMassClientReplicationInfo& GetClientReplicationInfoChecked(FMassClientHandle Handle) const
	{
		check(ClientHandleManager.IsValidHandle(Handle));

		return ClientsReplicationInfo[Handle.GetIndex()];
	}

	/** Gets the client replication info. Faster version using check()s */
	FMassClientReplicationInfo* GetMutableClientReplicationInfo(FMassClientHandle Handle)
	{
		return const_cast<FMassClientReplicationInfo*>(GetClientReplicationInfo(Handle));
	}

	/** Gets the client replication info. Faster version using check()s */
	FMassClientReplicationInfo& GetMutableClientReplicationInfoChecked(FMassClientHandle Handle)
	{
		return *const_cast<FMassClientReplicationInfo*>(&GetClientReplicationInfoChecked(Handle));
	}

	void SynchronizeClientsAndViewers();

	/** 
	 * Registers BubbleInfoClass with the system. These are created one per client as clients join. This function can be called multiple times with
	 * different BubbleInfoClass types (but not the same type), in that case each client will get multiple BubbleInfoClasses. This can be useful for 
	 * replicating different Entity types in different bubbles, although its also possible to have multiple TClientBubbleHandlerBase derived class
	 * instances per BubbleInfoClass. This must not be called after AddClient or SynchronizeClientsAndViewers is called
	 * @return FMassBubbleInfoClassHandle Handle to the BubbleInfoClass, this will be an invalid handle if its not been created
	 */
	FMassBubbleInfoClassHandle RegisterBubbleInfoClass(const TSubclassOf<AMassClientBubbleInfoBase>& BubbleInfoClass);

	/** @return FMassBubbleInfoClassHandle Handle to the BubbleInfoClass, this will be an invalid handle if BubbleInfoClass can not be found */
	FMassBubbleInfoClassHandle GetBubbleInfoClassHandle(const TSubclassOf<AMassClientBubbleInfoBase>& BubbleInfoClass) const;

	const FReplicationHashGrid2D& GetGrid() const { return ReplicationGrid; }
	FReplicationHashGrid2D& GetGridMutable() { return ReplicationGrid; }

#if UE_REPLICATION_COMPILE_CLIENT_CODE

	/** 
	 * Must be called immediately after an Entity is added to the simulation and after FindAndUpdateOrAddMassEntityInfo has been called
	 */
	void SetEntity(const FMassNetworkID NetworkID, const FMassEntityHandle Entity);

	/** 
	 * Resets the item with NetworkID in the  EntityInfoMap if its currently Set / Valid and its the most recent ReplicationID. In this case the FMassEntityHandle that was reset is returned.
	 * Otherwise FMassEntityHandle::IsSet() will be false on the returned FMassEntityHandle
	 * Must be called after SetEntity and just before the Entity is removed on the client. This sets the Entity member of the AddToEntityInfoMap item to FMassEntityHandle so it will be not IsSet() 
	 */
	FMassEntityHandle ResetEntityIfValid(const FMassNetworkID NetworkID, int32 ReplicationID);

	void RemoveFromEntityInfoMap(const FMassNetworkID NetworkID);

	/** 
	 * Finds or adds an FMassReplicationEntityInfo to the EntityInfoMap for an Entity with NetWorkID. This will update the ReplicationID if an older one is found but it does not change the 
	 * FMassReplicationEntityInfo::Entity member. Returns whether we added an entry in EntityInfoMap, or if the found item has an older or newer ReplicationID than that that is passed in. 
	 * We shouldn't actually get an equal ReplicationID, but in this case we'll treat the existing EntityInfoMap entry as newer. SetEntity() must be called soon after this if the entity handle is !IsSet()
	 * @param NetworkID ID of the entity we are looking up OutMassEntityInfo for
	 * @param ReplicationID this is the ReplicationID of the FastArray item
	 * @param OutMassEntityInfo retrieved or added FMassReplicationEntityInfo
	 * @return EFindOrAddMassEntityInfo, result of the function call
	 */
	EFindOrAddMassEntityInfo FindAndUpdateOrAddMassEntityInfo(const FMassNetworkID NetworkID, int32 ReplicationID, const FMassReplicationEntityInfo*& OutMassEntityInfo);

	/** 
	 * Finds the FMassReplicationEntityInfo for the Entity with NetworkID. NetworkID must be valid and nullptr is returned if we can't find it. Note FMassReplicationEntityInfo::IsSet() may be false,
	 * in which case this Entity has been removed from the client simulation (but we are still storing the ReplicationID between Removes and Adds!
	 */
	const FMassReplicationEntityInfo* FindMassEntityInfo(const FMassNetworkID NetworkID) const;

	FMassEntityHandle FindEntity(const FMassNetworkID NetworkID) const;

	const TMap<FMassNetworkID, FMassReplicationEntityInfo>& GetEntityInfoMap() const { return EntityInfoMap; }

	UE::MassReplication::FMassAgentDelegate& GetOnMassAgentAdded()
	{
		return OnMassAgentAdded;
	}

	UE::MassReplication::FMassAgentDelegate& GetOnRemovingMassAgent()
	{
		return OnRemovingMassAgent;
	}

#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

protected:
	// USubsystem BEGIN
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;
	// USubsystem END
	
#if UE_REPLICATION_COMPILE_CLIENT_CODE
	FMassReplicationEntityInfo* FindMassEntityInfoMutable(const FMassNetworkID NetworkID);
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

	/** Adds a Client and sets up all the data relevant to the bubble. Where there are multiple viewers for
	 *  one NetConnection only the parent net connection should be added here
	 *  @param ViewerHandle handle to viewer to add as a client. This must be UMassLODSubsystem->IsValidViewer()
	 *  @param InController associated with the viewer
	 */
	void AddClient(FMassViewerHandle ViewerHandle, APlayerController& InController);

	/** Removes a Client and removes up all the data relevant to the bubble
	 *  @param ClientHandle handle to client to remove. This must be ClientHandleManager.IsValidHandle()
	 */
	void RemoveClient(FMassClientHandle ClientHandle);

	/** @return true if we should shrink the number of handles. */
	bool SynchronizeClients(const TArray<FViewerInfo>& Viewers);
	void SynchronizeClientViewers(const TArray<FViewerInfo>& Viewers);

	void DebugCheckArraysAreInSync();

protected:
	static uint32 CurrentNetMassCounter;

	TSharedPtr<FMassEntityManager> EntityManager;

	/** Clients free list FMassClientHandle manager, handles will to the indices of FMassClientReplicationData::ClientBubbles */
	FMassClientHandleManager ClientHandleManager;

	UPROPERTY(Transient)
	TArray<FMassClientBubbleInfoData> BubbleInfoArray;

	/** An Array of each Clients viewer handles (split screen players sharing the same client connections). 
	 *  This will include both the parent and child NetConnections per client.
	 *	The array is organized so the array index is the same as the index of the client FMassClientHandle.
	 */
	TArray<FMassClientReplicationInfo> ClientsReplicationInfo;

	/** A free list array of FViewerClientPairs. This is organized so the index is that of the FMassViewerHandle for fast lookup of the related FMassClientHandle. 
	 *  This only contains viewers that are also clients (ie only parent NetConnections not child ones).
	 */
	TArray<FViewerClientPair> ViewerToClientHandleArray;

	/** A free list array of FViewerClientPairs. This is organized so the index is that of the FMassClientHandle.
	 *  For fast lookup of the related FMassViewerHandle. This only contains viewers that are also clients (ie only parent NetConnections not child ones).
	 */
	TArray<FViewerClientPair> ClientToViewerHandleArray;

	UPROPERTY()
	TObjectPtr<UWorld> World;

	UPROPERTY()
	TObjectPtr<UMassLODSubsystem> MassLODSubsystem;

#if UE_REPLICATION_COMPILE_CLIENT_CODE
	TMap<FMassNetworkID, FMassReplicationEntityInfo> EntityInfoMap;

	// @todo MassReplication consider batching these
	/** Broadcast just after a mass agent is added to the client simulation */
	UE::MassReplication::FMassAgentDelegate OnMassAgentAdded;

	/** Broadcast just before a mass agent is removed from the client simulation */
	UE::MassReplication::FMassAgentDelegate OnRemovingMassAgent;
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

	/**
	 * Used to make sure the FMassEntityHandle_ClientReplications are synchronized immediately before they are needed
	 * @todo this comment is no longer accurate, needs fixing
	 */
	uint64 LastSynchronizedFrame = 0;

	FReplicationHashGrid2D ReplicationGrid;
};

template<>
struct TMassExternalSubsystemTraits<UMassReplicationSubsystem> final
{
	enum
	{
		GameThreadOnly = false
	};
};

================================================================


=== Source/MassReplication/Public/MassReplicationTrait.h ===
============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "MassEntityTraitBase.h"
#include "MassReplicationFragments.h"
#include "MassReplicationTrait.generated.h"


UCLASS(meta=(DisplayName="Replication"))
class MASSREPLICATION_API UMassReplicationTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

public:

	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;

	UPROPERTY(EditAnywhere, Category = "Mass|Replication")
	FMassReplicationParameters Params;
};

============================================================


=== Source/MassReplication/Public/MassReplicationTransformHandlers.h ===
========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassReplicationTypes.h"
#include "MassEntityView.h"
#include "MassClientBubbleHandler.h"
#include "MassCommonFragments.h"
#include "AIHelpers.h"

#include "MassReplicationTransformHandlers.generated.h"

struct FMassEntityQuery;

namespace UE::Mass::Replication
{
	constexpr float PositionReplicateTolerance = 1.f;
	constexpr float YawReplicateTolerance = 0.004363323f;
}; //namespace UE::Mass::Replication


//////////////////////////////////////////////////////////////////////////// FReplicatedAgentPositionYawData ////////////////////////////////////////////////////////////////////////////
/**
 * To replicate position and yaw make a member variable of this class in your FReplicatedAgentBase derived class. In the FReplicatedAgentBase derived class you must also provide an accessor function
 * FReplicatedAgentPathData& GetReplicatedPositionYawDataMutable().
 */
USTRUCT()
struct MASSREPLICATION_API FReplicatedAgentPositionYawData
{
	GENERATED_BODY()
public:
	
	FReplicatedAgentPositionYawData()
		: Position(ForceInitToZero)
	{}

	void SetPosition(const FVector& InPosition) { Position = InPosition; }
	const FVector& GetPosition() const { return Position; }

	void SetYaw(const float InYaw) { Yaw = InYaw; }
	float GetYaw() const { return Yaw; }

private:
	
	UPROPERTY(Transient)
	FVector Position;

	/** Yaw in radians */
	UPROPERTY(Transient)
	float Yaw = 0;
};

//////////////////////////////////////////////////////////////////////////// TMassClientBubbleTransformHandler ////////////////////////////////////////////////////////////////////////////
/**
 * To replicate Transforms make a member variable of this class in your TClientBubbleHandlerBase derived class. This class is a friend of TMassClientBubblePathHandler.
 * It is meant to have access to the protected data declared there.
 */
template<typename AgentArrayItem>
class TMassClientBubbleTransformHandler
{
public:
	TMassClientBubbleTransformHandler(TClientBubbleHandlerBase<AgentArrayItem>& InOwnerHandler)
		: OwnerHandler(InOwnerHandler)
	{}

#if UE_REPLICATION_COMPILE_SERVER_CODE
	/** Sets the position and yaw data in the client bubble on the server */
	void SetBubblePositionYawFromTransform(const FMassReplicatedAgentHandle Handle, const FTransform& Transform);

	// Another function  SetBubbleTransform() could be added here if required
#endif // UE_REPLICATION_COMPILE_SERVER_CODE

#if UE_REPLICATION_COMPILE_CLIENT_CODE
	/**
	 * When entities are spawned in Mass by the replication system on the client, a spawn query is used to set the data on the spawned entities.
	 * The following functions are used to configure the query and then set the position and yaw data.
	 */
	static void AddRequirementsForSpawnQuery(FMassEntityQuery& InQuery);
	void CacheFragmentViewsForSpawnQuery(FMassExecutionContext& InExecContext);
	void ClearFragmentViewsForSpawnQuery();

	void SetSpawnedEntityData(const int32 EntityIdx, const FReplicatedAgentPositionYawData& ReplicatedPathData) const;

	/** Call this when an Entity that has already been spawned is modified on the client */
	static void SetModifiedEntityData(const FMassEntityView& EntityView, const FReplicatedAgentPositionYawData& ReplicatedPathData);

	// We could easily add support replicating FReplicatedAgentTransformData here if required
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

protected:
#if UE_REPLICATION_COMPILE_CLIENT_CODE
	static void SetEntityData(FTransformFragment& TransformFragment, const FReplicatedAgentPositionYawData& ReplicatedPositionYawData);
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

protected:
	TArrayView<FTransformFragment> TransformList;

	TClientBubbleHandlerBase<AgentArrayItem>& OwnerHandler;
};

#if UE_REPLICATION_COMPILE_SERVER_CODE
template<typename AgentArrayItem>
void TMassClientBubbleTransformHandler<AgentArrayItem>::SetBubblePositionYawFromTransform(const FMassReplicatedAgentHandle Handle, const FTransform& Transform)
{
	check(OwnerHandler.AgentHandleManager.IsValidHandle(Handle));

	const int32 AgentsIdx = OwnerHandler.AgentLookupArray[Handle.GetIndex()].AgentsIdx;
	bool bMarkDirty = false;

	AgentArrayItem& Item = (*OwnerHandler.Agents)[AgentsIdx];

	checkf(Item.Agent.GetNetID().IsValid(), TEXT("Pos should not be updated on FCrowdFastArrayItem's that have an Invalid ID! First Add the Agent!"));

	// GetReplicatedPositionYawDataMutable() must be defined in your FReplicatedAgentBase derived class
	FReplicatedAgentPositionYawData& ReplicatedPositionYaw = Item.Agent.GetReplicatedPositionYawDataMutable();

	// Only update the Pos and mark the item as dirty if it has changed more than the tolerance
	const FVector Pos = Transform.GetLocation();
	if (!Pos.Equals(ReplicatedPositionYaw.GetPosition(), UE::Mass::Replication::PositionReplicateTolerance))
	{
		ReplicatedPositionYaw.SetPosition(Pos);
		bMarkDirty = true;
	}

	const float Yaw = static_cast<float>(FMath::DegreesToRadians(Transform.GetRotation().Rotator().Yaw));

	// Only update the Yaw and mark the item as dirty if it has changed more than the tolerance
	if (FMath::Abs(FMath::FindDeltaAngleRadians(Yaw, ReplicatedPositionYaw.GetYaw())) > UE::Mass::Replication::YawReplicateTolerance)
	{
		ReplicatedPositionYaw.SetYaw(Yaw);
		bMarkDirty = true;
	}

	if (bMarkDirty)
	{
		OwnerHandler.Serializer->MarkItemDirty(Item);
	}

}
#endif //UE_REPLICATION_COMPILE_SERVER_CODE

#if UE_REPLICATION_COMPILE_CLIENT_CODE
template<typename AgentArrayItem>
void TMassClientBubbleTransformHandler<AgentArrayItem>::AddRequirementsForSpawnQuery(FMassEntityQuery& InQuery)
{
	InQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);
}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

#if UE_REPLICATION_COMPILE_CLIENT_CODE
template<typename AgentArrayItem>
void TMassClientBubbleTransformHandler<AgentArrayItem>::CacheFragmentViewsForSpawnQuery(FMassExecutionContext& InExecContext)
{
	TransformList = InExecContext.GetMutableFragmentView<FTransformFragment>();
}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

#if UE_REPLICATION_COMPILE_CLIENT_CODE
template<typename AgentArrayItem>
void TMassClientBubbleTransformHandler<AgentArrayItem>::ClearFragmentViewsForSpawnQuery()
{
	TransformList = TArrayView<FTransformFragment>();
}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

#if UE_REPLICATION_COMPILE_CLIENT_CODE
template<typename AgentArrayItem>
void TMassClientBubbleTransformHandler<AgentArrayItem>::SetSpawnedEntityData(const int32 EntityIdx, const FReplicatedAgentPositionYawData& ReplicatedPositionYawData) const
{
	FTransformFragment& TransformFragment = TransformList[EntityIdx];

	SetEntityData(TransformFragment, ReplicatedPositionYawData);
}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

#if UE_REPLICATION_COMPILE_CLIENT_CODE
template<typename AgentArrayItem>
void TMassClientBubbleTransformHandler<AgentArrayItem>::SetModifiedEntityData(const FMassEntityView& EntityView, const FReplicatedAgentPositionYawData& ReplicatedPositionYawData)
{
	FTransformFragment& TransformFragment = EntityView.GetFragmentData<FTransformFragment>();

	SetEntityData(TransformFragment, ReplicatedPositionYawData);
}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

#if UE_REPLICATION_COMPILE_CLIENT_CODE
template<typename AgentArrayItem>
void TMassClientBubbleTransformHandler<AgentArrayItem>::SetEntityData(FTransformFragment& TransformFragment, const FReplicatedAgentPositionYawData& ReplicatedPositionYawData)
{
	TransformFragment.GetMutableTransform().SetLocation(ReplicatedPositionYawData.GetPosition());
	TransformFragment.GetMutableTransform().SetRotation(FQuat(FVector::UpVector, ReplicatedPositionYawData.GetYaw()));
}
#endif // UE_REPLICATION_COMPILE_CLIENT_CODE

//////////////////////////////////////////////////////////////////////////// FMassReplicationProcessorTransformHandlerBase ////////////////////////////////////////////////////////////////////////////

class MASSREPLICATION_API FMassReplicationProcessorTransformHandlerBase
{
public:
	static void AddRequirements(FMassEntityQuery& InQuery);
	void CacheFragmentViews(FMassExecutionContext& ExecContext);

protected:
	TArrayView<FTransformFragment> TransformList;
};

//////////////////////////////////////////////////////////////////////////// FMassReplicationProcessorPositionYawHandler ////////////////////////////////////////////////////////////////////////////
/**
 * Used to replicate position and yaw by your UMassReplicationProcessorBase derived class. This class should only get used on the server.
 * @todo add #if UE_REPLICATION_COMPILE_SERVER_CODE
 */
class MASSREPLICATION_API FMassReplicationProcessorPositionYawHandler : public FMassReplicationProcessorTransformHandlerBase
{
public:
	void AddEntity(const int32 EntityIdx, FReplicatedAgentPositionYawData& InOUtReplicatedPathData) const;

	template<typename AgentArrayItem>
	void ModifyEntity(const FMassReplicatedAgentHandle Handle, const int32 EntityIdx, TMassClientBubbleTransformHandler<AgentArrayItem>& BubblePathHandler);
};

template<typename AgentArrayItem>
void FMassReplicationProcessorPositionYawHandler::ModifyEntity(const FMassReplicatedAgentHandle Handle, const int32 EntityIdx, TMassClientBubbleTransformHandler<AgentArrayItem>& BubbleTransformHandler)
{
	const FTransformFragment& TransformFragment = TransformList[EntityIdx];

	BubbleTransformHandler.SetBubblePositionYawFromTransform(Handle, TransformFragment.GetTransform());
}
========================================================================


=== Source/MassReplication/Public/MassReplicationTypes.h ===
============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassCommonTypes.h"
#include "MassLODSubsystem.h"
#include "IndexedHandle.h"
#include "MassEntityTemplate.h"
#include "MassObserverProcessor.h"
#include "MassLODLogic.h"
#include "HierarchicalHashGrid2D.h"

#include "MassReplicationTypes.generated.h"


/** Debug option to have bubbles on all player controllers in a stand alone game. This is especially useful for testing and profiling
 *  these systems. This will also disable the ClientsViewers functionality. If UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE is set 
 *  UE_REPLICATION_COMPILE_SERVER_CODE will be defined as 1 so server only code is compiled in standalone builds. 
 */ 
#ifndef UE_DEBUG_REPLICATION_BUBBLES_STANDALONE
#define UE_DEBUG_REPLICATION_BUBBLES_STANDALONE 0
#endif

#if UE_DEBUG_REPLICATION_BUBBLES_STANDALONE && !UE_BUILD_SHIPPING && (UE_GAME || UE_EDITOR)
#define UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE 1
#else
#define UE_ALLOW_DEBUG_REPLICATION_BUBBLES_STANDALONE 0
#endif

// WITH_SERVER_CODE is all builds except client only.
#if WITH_SERVER_CODE
#define UE_REPLICATION_COMPILE_SERVER_CODE 1
#else
#define UE_REPLICATION_COMPILE_SERVER_CODE 0
#endif

// If not a dedicated server build then we may need client code
#if !UE_SERVER
#define UE_REPLICATION_COMPILE_CLIENT_CODE 1
#else
#define UE_REPLICATION_COMPILE_CLIENT_CODE 0
#endif

#ifndef UE_DEBUG_SLOW_REPLICATION
#define UE_DEBUG_SLOW_REPLICATION 0
#endif

#if UE_DEBUG_SLOW_REPLICATION && !UE_BUILD_SHIPPING
#define UE_ALLOW_DEBUG_SLOW_REPLICATION 1
#else
#define UE_ALLOW_DEBUG_SLOW_REPLICATION 0
#endif

#ifndef UE_DEBUG_REPLICATION
#define UE_DEBUG_REPLICATION 0
#endif

#if (UE_DEBUG_REPLICATION && !UE_BUILD_SHIPPING) || UE_ALLOW_DEBUG_SLOW_REPLICATION
#define UE_ALLOW_DEBUG_REPLICATION 1
#else
#define UE_ALLOW_DEBUG_REPLICATION 0
#endif

class UMassReplicationSubsystem;

DECLARE_LOG_CATEGORY_EXTERN(LogMassReplication, Log, All);

/** Handle of each Agent per Client (bubble), these handles are not consistent between different client bubbles.
 *  Using the compact handle here will make the memory footprint smaller and help the ECS system be more cache friendly.
 *	TODO: in the long run we can probably use a non serial number handle here, I'd like to stick with the serial number for now though
 */
USTRUCT()
struct MASSREPLICATION_API FMassReplicatedAgentHandle : public FCompactIndexedHandleBase
{
	GENERATED_BODY()

	FMassReplicatedAgentHandle() = default;

	/** @param InIndex - passing INDEX_NONE will make this handle Invalid */
	FMassReplicatedAgentHandle(int32 InIndex, uint32 InSerialNumber) : FCompactIndexedHandleBase(InIndex, InSerialNumber)
	{
	};
};

typedef FCompactIndexedHandleManager<FMassReplicatedAgentHandle> FMassReplicatedAgentHandleManager;

//Handle of each Client on the server. A Client is defined as a player controller with a non nullptr parent NetConnection
USTRUCT()
struct MASSREPLICATION_API FMassClientHandle : public FIndexedHandleBase
{
	GENERATED_BODY()

	FMassClientHandle() = default;

	/** @param InIndex - passing INDEX_NONE will make this handle Invalid */
	FMassClientHandle(int32 InIndex, uint32 InSerialNumber) : FIndexedHandleBase(InIndex, InSerialNumber)
	{
	};
};

typedef FIndexedHandleManager<FMassClientHandle> FMassClientHandleManager;

USTRUCT()
struct MASSREPLICATION_API FMassBubbleInfoClassHandle : public FSimpleIndexedHandleBase
{
	GENERATED_BODY()

	FMassBubbleInfoClassHandle() = default;

	/** @param InIndex - passing INDEX_NONE will make this handle Invalid */
	FMassBubbleInfoClassHandle(int32 InIndex) : FSimpleIndexedHandleBase(InIndex)
	{
	};
};

USTRUCT()
struct FReplicatedAgentBase
{
	GENERATED_BODY()

	FReplicatedAgentBase() = default;

	FReplicatedAgentBase(FMassNetworkID InNetID, FMassEntityTemplateID InTemplateID)
		: NetID(InNetID)
		, TemplateID(InTemplateID)
	{}

	void SetNetID(FMassNetworkID InNetID) { NetID = InNetID; }
	FMassNetworkID GetNetID() const { return NetID; }

	void SetTemplateID(FMassEntityTemplateID InTemplateID) { TemplateID = InTemplateID; }
	FMassEntityTemplateID GetTemplateID() const { return TemplateID; }

private:
	UPROPERTY()
	FMassNetworkID NetID;

	UPROPERTY()
	FMassEntityTemplateID TemplateID;
};

struct FReplicationLODLogic : public FLODDefaultLogic
{
};

struct FMassReplicatedAgentData
{
	void Invalidate()
	{
		Handle.Invalidate();
		LastUpdateTime = 0.;
		LOD = EMassLOD::Off;
	}

	FMassReplicatedAgentHandle Handle;
	double LastUpdateTime = 0.;
	EMassLOD::Type LOD = EMassLOD::Off;
};

#if UE_REPLICATION_COMPILE_CLIENT_CODE
/** Data that can be accessed from a FMassNetworkID on a client */
struct FMassReplicationEntityInfo
{
	FMassReplicationEntityInfo() = default;
	FMassReplicationEntityInfo(FMassEntityHandle InEntity, int32 InReplicationID)
		: Entity(InEntity)
		, ReplicationID(InReplicationID)
	{}

	/** If this is not IsSet() then the entity has been removed from the client simulation */
	FMassEntityHandle Entity; 

	/** This is stored between removes and adds, however this item in the UMassReplicationSubsystem::EntityInfoMap will eventually get cleaned up if Entity.IsSet() == false for a fairly substantial length of time. */
	int32 ReplicationID = INDEX_NONE;
};
#endif //UE_REPLICATION_COMPILE_CLIENT_CODE

typedef THierarchicalHashGrid2D<2, 4, FMassEntityHandle> FReplicationHashGrid2D;	// 2 levels of hierarchy, 4 ratio between levels
============================================================


=== Source/MassReplication/MassReplication.Build.cs ===
=======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

namespace UnrealBuildTool.Rules
{
	public class MassReplication : ModuleRules
	{
		public MassReplication(ReadOnlyTargetRules Target) : base(Target)
		{
			PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

			UnsafeTypeCastWarningLevel = WarningLevel.Warning;

			PublicDependencyModuleNames.AddRange(
				new string[] {
					"Core",
					"CoreUObject",
					"Engine",
					"AIModule",
					"MassEntity",
					"MassCommon",
					"MassSimulation",
					"MassSpawner",
					"MassLOD",
					"NetCore",
					"MassMovement",
					"ZoneGraph"
				}
			);

			if (Target.bBuildEditor == true)
			{
				PrivateDependencyModuleNames.Add("EditorFramework");
				PrivateDependencyModuleNames.Add("UnrealEd");
			}
		}
	}
}

=======================================================


=== Source/MassRepresentation/Private/MassDistanceLODProcessor.cpp ===
======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassDistanceLODProcessor.h"
#include "MassRepresentationDebug.h"
#include "MassExecutionContext.h"

UMassDistanceLODProcessor::UMassDistanceLODProcessor()
{
	bAutoRegisterWithProcessingPhases = true;
	ExecutionFlags = (int32)(EProcessorExecutionFlags::AllNetModes);
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::LOD;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LODCollector);
}

void UMassDistanceLODProcessor::ConfigureQueries()
{
	FMassEntityQuery BaseQuery;
	BaseQuery.AddTagRequirement<FMassDistanceLODProcessorTag>(EMassFragmentPresence::All);
	BaseQuery.AddRequirement<FMassViewerInfoFragment>(EMassFragmentAccess::ReadOnly);
	BaseQuery.AddRequirement<FMassRepresentationLODFragment>(EMassFragmentAccess::ReadWrite);
	BaseQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	BaseQuery.AddConstSharedRequirement<FMassDistanceLODParameters>();
	BaseQuery.AddSharedRequirement<FMassDistanceLODSharedFragment>(EMassFragmentAccess::ReadWrite);

	CloseEntityQuery = BaseQuery;
	CloseEntityQuery.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::None);
	CloseEntityQuery.RegisterWithProcessor(*this);

	FarEntityQuery = BaseQuery;
	FarEntityQuery.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::All);
	FarEntityQuery.AddChunkRequirement<FMassVisualizationChunkFragment>(EMassFragmentAccess::ReadOnly);
	FarEntityQuery.SetChunkFilter(&FMassVisualizationChunkFragment::ShouldUpdateVisualizationForChunk);
	FarEntityQuery.RegisterWithProcessor(*this);

	DebugEntityQuery = BaseQuery;
	DebugEntityQuery.RegisterWithProcessor(*this);

	ProcessorRequirements.AddSubsystemRequirement<UMassLODSubsystem>(EMassFragmentAccess::ReadOnly);
}

void UMassDistanceLODProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	if (bForceOFFLOD)
	{
		CloseEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
		{
			FMassDistanceLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassDistanceLODSharedFragment>();
			TArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetMutableFragmentView<FMassRepresentationLODFragment>();
			LODSharedFragment.LODCalculator.ForceOffLOD(Context, RepresentationLODList);
		});
		return;
	}

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(PrepareExecution)
		const UMassLODSubsystem& LODSubsystem = Context.GetSubsystemChecked<UMassLODSubsystem>();
		const TArray<FViewerInfo>& Viewers = LODSubsystem.GetViewers();
		EntityManager.ForEachSharedFragment<FMassDistanceLODSharedFragment>([this, &Viewers](FMassDistanceLODSharedFragment& LODSharedFragment)
		{
			if (FilterTag == LODSharedFragment.FilterTag)
			{
				LODSharedFragment.LODCalculator.PrepareExecution(Viewers);
			}
		});
	}

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(CalculateLOD)

		auto CalculateLOD = [this](FMassExecutionContext& Context)
		{
			FMassDistanceLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassDistanceLODSharedFragment>();
			TArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetMutableFragmentView<FMassRepresentationLODFragment>();
			TConstArrayView<FMassViewerInfoFragment> ViewerInfoList = Context.GetFragmentView<FMassViewerInfoFragment>();
			LODSharedFragment.LODCalculator.CalculateLOD(Context, ViewerInfoList, RepresentationLODList);
		};
		CloseEntityQuery.ForEachEntityChunk(EntityManager, Context, CalculateLOD);
		FarEntityQuery.ForEachEntityChunk(EntityManager, Context, CalculateLOD);
	}

#if WITH_MASSGAMEPLAY_DEBUG
	// Optional debug display
	if (UE::Mass::Representation::Debug::DebugRepresentationLOD == 1 || UE::Mass::Representation::Debug::DebugRepresentationLOD >= 3)
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(DebugDisplayLOD)
		UWorld* World = EntityManager.GetWorld();
		DebugEntityQuery.ForEachEntityChunk(EntityManager, Context, [World](FMassExecutionContext& Context)
		{
			FMassDistanceLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassDistanceLODSharedFragment>();
			TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();
			TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();
			LODSharedFragment.LODCalculator.DebugDisplaySignificantLOD(Context, RepresentationLODList, TransformList, World, UE::Mass::Representation::Debug::DebugRepresentationLODMaxSignificance);
		});
	}
	// Optional vislog
	if (UE::Mass::Representation::Debug::DebugRepresentationLOD >= 2)
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(VisLogLOD)
		DebugEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
		{
			FMassDistanceLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassDistanceLODSharedFragment>();
			TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();
			TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();
			LODSharedFragment.LODCalculator.VisLogSignificantLOD(Context, RepresentationLODList, TransformList, this, UE::Mass::Representation::Debug::DebugRepresentationLODMaxSignificance);
		});
	}
#endif // WITH_MASSGAMEPLAY_DEBUG
}

======================================================================


=== Source/MassRepresentation/Private/MassDistanceVisualizationTrait.cpp ===
============================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassDistanceVisualizationTrait.h"
#include "MassEntityTemplateRegistry.h"
#include "MassRepresentationSubsystem.h"
#include "MassCommonFragments.h"
#include "MassRepresentationFragments.h"
#include "MassRepresentationActorManagement.h"
#include "Engine/World.h"
#include "MassLODFragments.h"
#include "MassActorSubsystem.h"
#include "MassEntityUtils.h"
#include "MassDistanceLODProcessor.h"
#include "MassRepresentationProcessor.h"


UMassDistanceVisualizationTrait::UMassDistanceVisualizationTrait()
{
	RepresentationSubsystemClass = UMassRepresentationSubsystem::StaticClass();

	Params.RepresentationActorManagementClass = UMassRepresentationActorManagement::StaticClass();
	Params.LODRepresentation[EMassLOD::High] = EMassRepresentationType::HighResSpawnedActor;
	Params.LODRepresentation[EMassLOD::Medium] = EMassRepresentationType::LowResSpawnedActor;
	Params.LODRepresentation[EMassLOD::Low] = EMassRepresentationType::StaticMeshInstance;
	Params.LODRepresentation[EMassLOD::Off] = EMassRepresentationType::None;

	LODParams.LODDistance[EMassLOD::High] = 0.f;
	LODParams.LODDistance[EMassLOD::Medium] = 1000.f;
	LODParams.LODDistance[EMassLOD::Low] = 2500.f;
	LODParams.LODDistance[EMassLOD::Off] = 10000.f;

	LODParams.BufferHysteresisOnDistancePercentage = 10.0f;

	bAllowServerSideVisualization = false;
}

void UMassDistanceVisualizationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	// This should not be ran on NM_Server network mode
	if (World.IsNetMode(NM_DedicatedServer) && !bAllowServerSideVisualization
		&& !BuildContext.IsInspectingData())
	{
		return;
	}

	BuildContext.RequireFragment<FMassViewerInfoFragment>();
	BuildContext.RequireFragment<FTransformFragment>();
	BuildContext.RequireFragment<FMassActorFragment>();

	FMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(World);

	UMassRepresentationSubsystem* RepresentationSubsystem = Cast<UMassRepresentationSubsystem>(World.GetSubsystemBase(RepresentationSubsystemClass));
	if (RepresentationSubsystem == nullptr && !BuildContext.IsInspectingData())
	{
		UE_LOG(LogMassRepresentation, Error, TEXT("Expecting a valid class for the representation subsystem"));
		RepresentationSubsystem = UWorld::GetSubsystem<UMassRepresentationSubsystem>(&World);
		check(RepresentationSubsystem);
	}

	FMassRepresentationSubsystemSharedFragment SubsystemSharedFragment;
	SubsystemSharedFragment.RepresentationSubsystem = RepresentationSubsystem;
	FSharedStruct SubsystemFragment = EntityManager.GetOrCreateSharedFragment<FMassRepresentationSubsystemSharedFragment>(SubsystemSharedFragment);
	BuildContext.AddSharedFragment(SubsystemFragment);

	if (!Params.RepresentationActorManagementClass && !BuildContext.IsInspectingData())
	{
		UE_LOG(LogMassRepresentation, Error, TEXT("Expecting a valid class for the representation actor management"));
	}
	FConstSharedStruct ParamsFragment = EntityManager.GetOrCreateConstSharedFragment(Params);
	ParamsFragment.Get<const FMassRepresentationParameters>().ComputeCachedValues();
	BuildContext.AddConstSharedFragment(ParamsFragment);

	FMassRepresentationFragment& RepresentationFragment = BuildContext.AddFragment_GetRef<FMassRepresentationFragment>();
	if (LIKELY(!BuildContext.IsInspectingData()))
	{
		if (bRegisterStaticMeshDesc && !BuildContext.IsInspectingData())
		{
			RepresentationFragment.StaticMeshDescHandle = RepresentationSubsystem->FindOrAddStaticMeshDesc(StaticMeshInstanceDesc);
		}
		RepresentationFragment.HighResTemplateActorIndex = HighResTemplateActor.Get() ? RepresentationSubsystem->FindOrAddTemplateActor(HighResTemplateActor.Get()) : INDEX_NONE;
		RepresentationFragment.LowResTemplateActorIndex = LowResTemplateActor.Get() ? RepresentationSubsystem->FindOrAddTemplateActor(LowResTemplateActor.Get()) : INDEX_NONE;
	}

	FConstSharedStruct LODParamsFragment = EntityManager.GetOrCreateConstSharedFragment(LODParams);
	BuildContext.AddConstSharedFragment(LODParamsFragment);

	FSharedStruct LODSharedFragment = EntityManager.GetOrCreateSharedFragment<FMassDistanceLODSharedFragment>(FConstStructView::Make(LODParams), LODParams);
	BuildContext.AddSharedFragment(LODSharedFragment);

	BuildContext.AddFragment<FMassRepresentationLODFragment>();
	BuildContext.AddTag<FMassVisibilityCulledByDistanceTag>();
	BuildContext.AddChunkFragment<FMassVisualizationChunkFragment>();

	BuildContext.AddTag<FMassDistanceLODProcessorTag>();
	BuildContext.AddTag<FMassVisualizationProcessorTag>();
}

void UMassDistanceVisualizationTrait::DestroyTemplate(const UWorld& World) const
{
	if (UMassRepresentationSubsystem* RepresentationSubsystem = Cast<UMassRepresentationSubsystem>(World.GetSubsystemBase(RepresentationSubsystemClass)))
	{
		RepresentationSubsystem->ReleaseTemplate(HighResTemplateActor);
		RepresentationSubsystem->ReleaseTemplate(LowResTemplateActor);
	}
}

============================================================================


=== Source/MassRepresentation/Private/MassMovableVisualizationTrait.cpp ===
===========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassMovableVisualizationTrait.h"
#include "MassEntityTemplateRegistry.h"


void UMassMovableVisualizationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	if (!bAllowServerSideVisualization && World.IsNetMode(NM_DedicatedServer)
		&& !BuildContext.IsInspectingData())
	{
		return;
	}

	for (FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : StaticMeshInstanceDesc.Meshes)
	{
		MeshDesc.Mobility = EComponentMobility::Movable;
	}

	Super::BuildTemplate(BuildContext, World);
}

===========================================================================


=== Source/MassRepresentation/Private/MassRepresentationActorManagement.cpp ===
===============================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassRepresentationActorManagement.h"
#include "MassRepresentationSubsystem.h"
#include "MassRepresentationFragments.h"
#include "MassCommandBuffer.h"
#include "MassEntityView.h"
#include "MassActorSubsystem.h"

float UMassRepresentationActorManagement::GetSpawnPriority(const FMassRepresentationLODFragment& Representation) const
{
	// Bump up the spawning priority on the visible entities
	return Representation.LODSignificance - (Representation.Visibility == EMassVisibility::CanBeSeen ? 1.0f : 0.0f);
}

AActor* UMassRepresentationActorManagement::GetOrSpawnActor(UMassRepresentationSubsystem& RepresentationSubsystem, FMassEntityManager& EntityManager
	, const FMassEntityHandle MassAgent, const FTransform& Transform, const int16 TemplateActorIndex
	, FMassActorSpawnRequestHandle& InOutSpawnRequestHandle, const float Priority) const
{
	TSharedRef<FMassEntityManager> SharedEntityManager = EntityManager.AsShared();

	return RepresentationSubsystem.GetOrSpawnActorFromTemplate(MassAgent, Transform, TemplateActorIndex, InOutSpawnRequestHandle, Priority,
		FMassActorPreSpawnDelegate::CreateUObject(this, &UMassRepresentationActorManagement::OnPreActorSpawn, SharedEntityManager),
		FMassActorPostSpawnDelegate::CreateUObject(this, &UMassRepresentationActorManagement::OnPostActorSpawn, SharedEntityManager));
}


void UMassRepresentationActorManagement::SetActorEnabled(const EMassActorEnabledType EnabledType, AActor& Actor, const int32 EntityIdx, FMassCommandBuffer& CommandBuffer) const
{
	const bool bEnabled = EnabledType != EMassActorEnabledType::Disabled;
	if (Actor.IsActorTickEnabled() != bEnabled)
	{
		Actor.SetActorTickEnabled(bEnabled);
	}
	if (Actor.GetActorEnableCollision() != bEnabled)
	{
		// Deferring this as there is a callback internally that could end up doing things outside of the game thread and will fire checks(Chaos mostly)
		CommandBuffer.PushCommand<FMassDeferredSetCommand>([&Actor, bEnabled](FMassEntityManager&)
		{
			Actor.SetActorEnableCollision(bEnabled);
		});
	}
}

void UMassRepresentationActorManagement::TeleportActor(const FTransform& Transform, AActor& Actor, FMassCommandBuffer& CommandBuffer) const
{
	if (!Actor.GetTransform().Equals(Transform))
	{
		CommandBuffer.PushCommand<FMassDeferredSetCommand>([&Actor, Transform](FMassEntityManager&)
		{
			Actor.SetActorTransform(Transform, /*bSweep*/false, /*OutSweepHitResult*/nullptr, ETeleportType::TeleportPhysics);
		});
	}
}

void UMassRepresentationActorManagement::OnPreActorSpawn(const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest, TSharedRef<FMassEntityManager> EntityManager) const
{
	const FMassActorSpawnRequest& MassActorSpawnRequest = SpawnRequest.Get<const FMassActorSpawnRequest>();
	const FMassEntityView EntityView(*EntityManager, MassActorSpawnRequest.MassAgent);
	FMassActorFragment& ActorInfo = EntityView.GetFragmentData<FMassActorFragment>();
	FMassRepresentationFragment& Representation = EntityView.GetFragmentData<FMassRepresentationFragment>();
	UMassRepresentationSubsystem* RepresentationSubsystem = EntityView.GetSharedFragmentData<FMassRepresentationSubsystemSharedFragment>().RepresentationSubsystem;
	check(RepresentationSubsystem);

	// Release any existing actor
	if (AActor* Actor = ActorInfo.GetMutable())
	{
		checkf(ActorInfo.IsOwnedByMass(), TEXT("If we reach here, we expect the actor to be owned by mass, otherwise we should not be spawning a new one one top of this one."));

		// WARNING!
		// Need to reset before ReleaseTemplateActor as this action might move the entity to a new archetype and
		// so the Fragment passed in parameters would not be valid anymore.
		ActorInfo.ResetAndUpdateHandleMap();

		if (!RepresentationSubsystem->ReleaseTemplateActor(MassActorSpawnRequest.MassAgent, Representation.HighResTemplateActorIndex, Actor, /*bImmediate*/ true))
		{
			if (!RepresentationSubsystem->ReleaseTemplateActor(MassActorSpawnRequest.MassAgent, Representation.LowResTemplateActorIndex, Actor, /*bImmediate*/ true))
			{
				checkf(false, TEXT("Expecting to be able to release spawned actor either the high res or low res one"));
			}
		}
	}
}

EMassActorSpawnRequestAction UMassRepresentationActorManagement::OnPostActorSpawn(const FMassActorSpawnRequestHandle& SpawnRequestHandle
	, FConstStructView SpawnRequest, TSharedRef<FMassEntityManager> EntityManager) const
{
	const FMassActorSpawnRequest& MassActorSpawnRequest = SpawnRequest.Get<const FMassActorSpawnRequest>();
	
	if (MassActorSpawnRequest.SpawnedActor)
	{
		// Might be already done if the actor has a MassAgentComponent via the callback OnMassAgentComponentEntityAssociated on the MassRepresentationSubsystem
		FMassActorFragment& ActorInfo = EntityManager->GetFragmentDataChecked<FMassActorFragment>(MassActorSpawnRequest.MassAgent);
		if (ActorInfo.IsValid())
		{
			// If already set, make sure it is pointing to the same actor.
			checkf(ActorInfo.Get() == MassActorSpawnRequest.SpawnedActor, TEXT("Expecting the pointer to the spawned actor in the actor fragment"));
		}
		else
		{
			ActorInfo.SetAndUpdateHandleMap(MassActorSpawnRequest.MassAgent, MassActorSpawnRequest.SpawnedActor, true/*bIsOwnedByMass*/);
		}

		// by default we keep the spawn request since there's code in other places that will consume this request by 
		// calling RemoveActorSpawnRequest (like UMassRepresentationSubsystem::GetOrSpawnActorFromTemplate)
		return EMassActorSpawnRequestAction::Keep;
	}

	return EMassActorSpawnRequestAction::Remove;
}

void UMassRepresentationActorManagement::ReleaseAnyActorOrCancelAnySpawning(FMassEntityManager& EntityManager, const FMassEntityHandle MassAgent)
{
	FMassEntityView EntityView(EntityManager, MassAgent);
	FMassActorFragment& ActorInfo = EntityView.GetFragmentData<FMassActorFragment>();
	FMassRepresentationFragment& Representation = EntityView.GetFragmentData<FMassRepresentationFragment>();
	UMassRepresentationSubsystem* RepresentationSubsystem = EntityView.GetSharedFragmentData<FMassRepresentationSubsystemSharedFragment>().RepresentationSubsystem;
	check(RepresentationSubsystem);
	ReleaseAnyActorOrCancelAnySpawning(*RepresentationSubsystem, MassAgent, ActorInfo, Representation);
}

void UMassRepresentationActorManagement::ReleaseAnyActorOrCancelAnySpawning(UMassRepresentationSubsystem& RepresentationSubsystem
	, const FMassEntityHandle MassAgent, FMassActorFragment& ActorInfo, FMassRepresentationFragment& Representation
	, UMassActorSubsystem* CachedActorSubsystem)
{
	// This method can only release owned by mass actors
	AActor* Actor = ActorInfo.GetOwnedByMassMutable();
	if (Actor)
	{
		// WARNING!
		// Need to reset before ReleaseTemplateActorOrCancelSpawning as this action might move the entity to a new archetype and
		// so the Fragment passed in parameters would not be valid anymore.
		ActorInfo.ResetAndUpdateHandleMap(CachedActorSubsystem);
	}
	// Try releasing both as we can have a low res actor and a high res spawning request
	if (Representation.HighResTemplateActorIndex != INDEX_NONE)
	{
		RepresentationSubsystem.ReleaseTemplateActorOrCancelSpawning(MassAgent, Representation.HighResTemplateActorIndex, Actor, Representation.ActorSpawnRequestHandle);
	}	
	if (Representation.LowResTemplateActorIndex != Representation.HighResTemplateActorIndex && Representation.LowResTemplateActorIndex != INDEX_NONE)
	{
		RepresentationSubsystem.ReleaseTemplateActorOrCancelSpawning(MassAgent, Representation.LowResTemplateActorIndex, Actor, Representation.ActorSpawnRequestHandle);
	}
	check(!Representation.ActorSpawnRequestHandle.IsValid());
}


//-----------------------------------------------------------------------------
// DEPRECATED
//-----------------------------------------------------------------------------
AActor* UMassRepresentationActorManagement::GetOrSpawnActor(UMassRepresentationSubsystem& RepresentationSubsystem, FMassEntityManager& EntityManager
	, const FMassEntityHandle MassAgent, FMassActorFragment&/* OutActorInfo*/, const FTransform& Transform, const int16 TemplateActorIndex
	, FMassActorSpawnRequestHandle& InOutSpawnRequestHandle, const float Priority) const
{
	return GetOrSpawnActor(RepresentationSubsystem, EntityManager
		, MassAgent, Transform, TemplateActorIndex
		, InOutSpawnRequestHandle, Priority);
}

void UMassRepresentationActorManagement::OnPreActorSpawn(const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest, FMassEntityManager* EntityManager) const
{
	if (EntityManager)
	{
		OnPreActorSpawn(SpawnRequestHandle, SpawnRequest, EntityManager->AsShared());
	}
}

EMassActorSpawnRequestAction UMassRepresentationActorManagement::OnPostActorSpawn(const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest, FMassEntityManager* EntityManager) const
{
	if (EntityManager)
	{
		return OnPostActorSpawn(SpawnRequestHandle, SpawnRequest, EntityManager->AsShared());
	}

	return EMassActorSpawnRequestAction::Remove;
}

===============================================================================


=== Source/MassRepresentation/Private/MassRepresentationDebug.cpp ===
=====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassRepresentationDebug.h"

#if WITH_MASSGAMEPLAY_DEBUG

#include "DrawDebugHelpers.h"
#include "MassCommonFragments.h"
#include "MassExecutionContext.h"
#include "MassRepresentationFragments.h"
#include "Math/Color.h"
#include "VisualLogger/VisualLogger.h"

namespace UE::Mass::Representation::Debug
{
	FColor RepresentationColors[] =
	{
		FColor::Purple, // HighResSpawnedActor,
		FColor::Turquoise, // LowResSpawnedActor
		FColor::Orange, // StaticMeshInstance
		FColor::White, // None
	};

	int32 DebugRepresentation = 0;
	FAutoConsoleVariableRef CVarDebugRepresentation(TEXT("mass.debug.Representation"), DebugRepresentation, TEXT("Debug current representation 0 = Off, 1 = Debug Draw, 2 = VisLog, 3 = Both"), ECVF_Cheat);

	float DebugRepresentationMaxSignificance = float(EMassLOD::Max);
	FAutoConsoleVariableRef CVarDebugRepresentationMaxSignificance(TEXT("mass.debug.Representation.MaxSignificance"), DebugRepresentationMaxSignificance, TEXT("Max LODSignificance for entities to draw / vislog with mass.debug.Representation enabled"), ECVF_Cheat);

	int32 DebugRepresentationLOD = 0;
	FAutoConsoleVariableRef CVarDebugRepresentationLOD(TEXT("mass.debug.RepresentationLOD"), DebugRepresentationLOD, TEXT("Debug representation LOD 0 = Off, 1 = Debug Draw, 2 = VisLog, 3 = Both"), ECVF_Cheat);

	float DebugRepresentationLODMaxSignificance = float(EMassLOD::Max);
	FAutoConsoleVariableRef CVarDebugRepresentationLODMaxSignificance(TEXT("mass.debug.RepresentationLOD.MaxSignificance"), DebugRepresentationLODMaxSignificance, TEXT("Max LODSignificance for entities to draw / vislog with mass.debug.RepresentationLOD enabled"), ECVF_Cheat);

	void DebugDisplayRepresentation(FMassExecutionContext& Context, TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList, TConstArrayView<FMassRepresentationFragment> RepresentationList, TConstArrayView<FTransformFragment> LocationList, UWorld* World)
	{
#if UE_ENABLE_DEBUG_DRAWING
		const int32 NumEntities = Context.GetNumEntities();
		for (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
		{
			const FMassRepresentationLODFragment& RepresentationLOD = RepresentationLODList[EntityIdx];
			if (RepresentationLOD.LODSignificance <= UE::Mass::Representation::Debug::DebugRepresentationMaxSignificance)
			{
				const FMassRepresentationFragment& Representation = RepresentationList[EntityIdx];
				const FTransformFragment& EntityLocation = LocationList[EntityIdx];
				int32 CurrentRepresentationIdx = (int32)Representation.CurrentRepresentation;
				DrawDebugSolidBox(World, EntityLocation.GetTransform().GetLocation() + FVector(0.0f, 0.0f, 150.0f), FVector(25.0f), UE::Mass::Representation::Debug::RepresentationColors[CurrentRepresentationIdx]);
			}
		}
#endif // UE_ENABLE_DEBUG_DRAWING
	}

	void VisLogRepresentation(FMassExecutionContext& Context, TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList, TConstArrayView<FMassRepresentationFragment> RepresentationList, TConstArrayView<FTransformFragment> LocationList, UObject* LogOwner)
	{
#if ENABLE_VISUAL_LOG
		const int32 NumEntities = Context.GetNumEntities();
		for (int EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
		{
			const FMassRepresentationLODFragment& RepresentationLOD = RepresentationLODList[EntityIdx];
			if (RepresentationLOD.LODSignificance <= UE::Mass::Representation::Debug::DebugRepresentationMaxSignificance)
			{
				const FTransformFragment& EntityLocation = LocationList[EntityIdx];
				const FMassRepresentationFragment& Representation = RepresentationList[EntityIdx];
				int32 CurrentRepresentationIdx = (int32)Representation.CurrentRepresentation;
				int32 PrevRepresentationIdx = (int32)Representation.PrevRepresentation;
				// Add 20cm +Z offset to draw above mass.debug.RepresentationLOD so they can be viewed together
				UE_CVLOG_LOCATION(Representation.CurrentRepresentation == Representation.PrevRepresentation, LogOwner, LogMassRepresentation, Verbose, EntityLocation.GetTransform().GetLocation() + FVector(0.0f, 0.0f, 20.0f), 20, UE::Mass::Representation::Debug::RepresentationColors[CurrentRepresentationIdx], TEXT("%s %d"), *Context.GetEntity(EntityIdx).DebugGetDescription(), CurrentRepresentationIdx);
				UE_CVLOG_LOCATION(Representation.CurrentRepresentation != Representation.PrevRepresentation, LogOwner, LogMassRepresentation, Verbose, EntityLocation.GetTransform().GetLocation() + FVector(0.0f, 0.0f, 20.0f), 20, UE::Mass::Representation::Debug::RepresentationColors[CurrentRepresentationIdx], TEXT("%s %d -> %d"), *Context.GetEntity(EntityIdx).DebugGetDescription(), PrevRepresentationIdx, CurrentRepresentationIdx);
			}
		}
#endif // ENABLE_VISUAL_LOG
	}
}

#endif // WITH_MASSGAMEPLAY_DEBUG

=====================================================================


=== Source/MassRepresentation/Private/MassRepresentationFragments.cpp ===
=========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassRepresentationFragments.h"

FMassVisualizationLODSharedFragment::FMassVisualizationLODSharedFragment(const FMassVisualizationLODParameters& LODParams)
{
	LODCalculator.Initialize(LODParams.BaseLODDistance, LODParams.BufferHysteresisOnDistancePercentage / 100.f, LODParams.LODMaxCount
		, /*InLODMaxCountPerViewer=*/nullptr, LODParams.DistanceToFrustum, LODParams.DistanceToFrustumHysteresis, LODParams.VisibleLODDistance);
	FilterTag = LODParams.FilterTag;
}

FMassDistanceLODSharedFragment::FMassDistanceLODSharedFragment(const FMassDistanceLODParameters& LODParams)
{
	LODCalculator.Initialize(LODParams.LODDistance, LODParams.BufferHysteresisOnDistancePercentage / 100.f, /*InLODMaxCount=*/nullptr);
	FilterTag = LODParams.FilterTag;
}

=========================================================================


=== Source/MassRepresentation/Private/MassRepresentationModule.cpp ===
======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "CoreMinimal.h"
#include "IMassRepresentationModule.h"
#include "UObject/CoreRedirects.h"

class FMassRepresentationModule : public IMassRepresentationModule
{
	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

IMPLEMENT_MODULE(FMassRepresentationModule, MassRepresentation)



void FMassRepresentationModule::StartupModule()
{
}


void FMassRepresentationModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}




======================================================================


=== Source/MassRepresentation/Private/MassRepresentationProcessor.cpp ===
=========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassRepresentationProcessor.h"
#include "MassRepresentationDebug.h"
#include "MassRepresentationSubsystem.h"
#include "MassRepresentationUtils.h"
#include "MassActorSubsystem.h"
#include "MassCommonFragments.h"
#include "MassCommandBuffer.h"
#include "MassEntityManager.h"
#include "MassEntityView.h"
#include "Engine/World.h"
#include "MassRepresentationActorManagement.h"
#include "MassCommonUtils.h"
#include "MassEntityUtils.h"
#include "MassExecutionContext.h"


DECLARE_CYCLE_STAT(TEXT("Mass Visualization Execute"), STAT_Mass_VisProcessor_Execute, STATGROUP_Mass);

namespace UE::Mass::Representation
{
	int32 bAllowKeepActorExtraFrame = 1;
	FAutoConsoleVariableRef CVarAllowKeepActorExtraFrame(TEXT("ai.massrepresentation.AllowKeepActorExtraFrame"), bAllowKeepActorExtraFrame, TEXT("Allow the mass representation to keep actor an extra frame when switching to ISM"), ECVF_Default);
}

//----------------------------------------------------------------------//
// UMassRepresentationProcessor(); 
//----------------------------------------------------------------------//
UMassRepresentationProcessor::UMassRepresentationProcessor()
	: EntityQuery(*this)
{
	bAutoRegisterWithProcessingPhases = false;

	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Representation;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LOD);
}

void UMassRepresentationProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassRepresentationFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FMassRepresentationLODFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassActorFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddConstSharedRequirement<FMassRepresentationParameters>();
	EntityQuery.AddSharedRequirement<FMassRepresentationSubsystemSharedFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddSubsystemRequirement<UMassActorSubsystem>(EMassFragmentAccess::ReadWrite);
}

void UMassRepresentationProcessor::UpdateRepresentation(FMassExecutionContext& Context, const FMassRepresentationUpdateParams& Params)
{
	UMassRepresentationSubsystem* RepresentationSubsystem = Context.GetMutableSharedFragment<FMassRepresentationSubsystemSharedFragment>().RepresentationSubsystem;
	check(RepresentationSubsystem);

	const FMassRepresentationParameters& RepresentationParams = Context.GetConstSharedFragment<FMassRepresentationParameters>();
	UMassRepresentationActorManagement* RepresentationActorManagement = RepresentationParams.CachedRepresentationActorManagement;
	check(RepresentationActorManagement);

	UMassActorSubsystem* MassActorSubsystem = Context.GetMutableSubsystem<UMassActorSubsystem>();

	FMassEntityManager& CachedEntityManager = Context.GetEntityManagerChecked();
	
	// Get Transform, Representation, RepresentationLOD and Actor fragments from Context
	const TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();
	const TArrayView<FMassRepresentationFragment> RepresentationList = Context.GetMutableFragmentView<FMassRepresentationFragment>();
	const TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();
	const TArrayView<FMassActorFragment> ActorList = Context.GetMutableFragmentView<FMassActorFragment>();

	const bool bDoKeepActorExtraFrame = UE::Mass::Representation::bAllowKeepActorExtraFrame ? RepresentationParams.bKeepLowResActors : false;

	// Iterate over all entities, and:
	// 1. Find their current EMassRepresentationType value based on their current RepresentationLOD;
	// 2. Change EMassRepresentationType value based on some configs (not all flows will care about this);
	// 3. Switch the in-game instance representation depending on the EMassRepresentationType;
	// 		a. If EMassRepresentationType == HighResSpawnedActor or LowResSpawnedActor, sends an Actor SpawnRequest to MassRepresentationActorManagement;
	// 		b. If EMassRepresentationType == StaticMeshInstance, sends an Actor disable request to MassRepresentationActorManagement;
	//		c. If EMassRepresentationType == StaticMeshInstance, sends an Actor disable request to MassRepresentationActorManagement.
	// 		NOTE: I guess this system assumes all instances are already represented by ISMs, which is why we're only dealing with Actor spawn/deactivation
	const int32 NumEntities = Context.GetNumEntities();
	for (int32 EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
	{
		const FMassEntityHandle MassAgentEntityHandle = Context.GetEntity(EntityIdx);
		const FTransformFragment& TransformFragment = TransformList[EntityIdx];
		const FMassRepresentationLODFragment& RepresentationLOD = RepresentationLODList[EntityIdx];
		FMassRepresentationFragment& Representation = RepresentationList[EntityIdx];
		FMassActorFragment& ActorInfo = ActorList[EntityIdx];
		AActor* Actor = ActorInfo.GetMutable();

		// Keeping a copy of the that last calculated previous representation
		const EMassRepresentationType PrevRepresentationCopy = Representation.PrevRepresentation;
		Representation.PrevRepresentation = Representation.CurrentRepresentation;

		// === 1. Find the current EMassRepresentationType value based on their current RepresentationLOD		
		EMassRepresentationType WantedRepresentationType = RepresentationParams.LODRepresentation[FMath::Min((int32)RepresentationLOD.LOD, (int32)EMassLOD::Off)];
		// === 1 end

		// === 2. Change EMassRepresentationType value based on some configs (not all flows will care about this)
		// Make sure we do not have actor spawned in areas not fully loaded
		if (Params.bTestCollisionAvailibilityForActorVisualization
			&& (WantedRepresentationType == EMassRepresentationType::HighResSpawnedActor || WantedRepresentationType == EMassRepresentationType::LowResSpawnedActor)
			&& !RepresentationSubsystem->IsCollisionLoaded(RepresentationParams.WorldPartitionGridNameContainingCollision, TransformFragment.GetTransform()))
		{
			WantedRepresentationType = RepresentationParams.CachedDefaultRepresentationType;
		}

		// If bForceActorRepresentationForExternalActors is enabled and we have an Actor reference for this entity, forcibly use it
		// by enforcing an actor representation as the WantedRepresentation. If we're coming from ISMC, we'll remove the instance
		// and switch to this actor, commiting either LowResSpawnedActor or HighResSpawnedActor as the new CurrentRepresentation.
		// Once the Actor is destroyed however, this override stops, allowing the natural WantedRepresentationType to return.
		//
		// Useful for server-authoritative Actor spawning, with replicated Actors inserting themselves into Mass whilst they're
		// replicated, enforcing actor representation on clients whilst they're present.
		//
		// NOTE:
		// IsOwnedByMass = Hydrated by mass
		// !IsOwnedByMass = Hydrated by some external system
		if (IsValid(Actor))
		{
			if (RepresentationParams.bForceActorRepresentationForExternalActors && !ActorInfo.IsOwnedByMass())
			{
				WantedRepresentationType = (Representation.CurrentRepresentation == EMassRepresentationType::LowResSpawnedActor)
					? EMassRepresentationType::LowResSpawnedActor
					: EMassRepresentationType::HighResSpawnedActor;
			}
		}
		// Has Actor unexpectedly been unset / destroyed since we last ran? 
		else if (Representation.CurrentRepresentation == EMassRepresentationType::LowResSpawnedActor 
			|| Representation.CurrentRepresentation == EMassRepresentationType::HighResSpawnedActor)
		{
			// Set CurrentRepresentation = None so we get a chance to see CurrentRepresentation != WantedRepresentationType and spawn 
			// another actor.
			Representation.CurrentRepresentation = EMassRepresentationType::None;
		}
		// === 2 end

		auto DisableActorForISM = [&](AActor*& Actor)
		{
			if (!Actor || ActorInfo.IsOwnedByMass())
			{
				// Execute only if the high res is different than the low res Actor 
				// Or if we do not wish to keep the low res actor while in TransformList
				if (Representation.HighResTemplateActorIndex != Representation.LowResTemplateActorIndex || !RepresentationParams.bKeepLowResActors)
				{
					// Try releasing the high actor or any high res spawning request
					if (ReleaseActorOrCancelSpawning(*RepresentationSubsystem, MassActorSubsystem, MassAgentEntityHandle, ActorInfo, Representation.HighResTemplateActorIndex, Representation.ActorSpawnRequestHandle, Context.Defer()))
					{
						Actor = ActorInfo.GetOwnedByMassMutable();
					}
					// Do not do the same with low res if indicated so
					if (!RepresentationParams.bKeepLowResActors && ReleaseActorOrCancelSpawning(*RepresentationSubsystem, MassActorSubsystem, MassAgentEntityHandle, ActorInfo, Representation.LowResTemplateActorIndex, Representation.ActorSpawnRequestHandle, Context.Defer()))
					{
						Actor = ActorInfo.GetOwnedByMassMutable();
					}
				}
				// If we already queued spawn request but have changed our mind, continue with it but once we get the actor back, disable it immediately
				if (Representation.ActorSpawnRequestHandle.IsValid())
				{
					Actor = RepresentationActorManagement->GetOrSpawnActor(*RepresentationSubsystem, CachedEntityManager, MassAgentEntityHandle, TransformFragment.GetTransform(), Representation.LowResTemplateActorIndex, Representation.ActorSpawnRequestHandle, RepresentationActorManagement->GetSpawnPriority(RepresentationLOD));
				}
			}
			if (Actor != nullptr)
			{
				RepresentationActorManagement->SetActorEnabled(EMassActorEnabledType::Disabled, *Actor, EntityIdx, Context.Defer());
			}
		};

		// === 3. Switch the in-game instance representation depending on the EMassRepresentationType;
		// Process switch between representation if there is a change in the representation or there is a pending spawning request
		if (WantedRepresentationType != Representation.CurrentRepresentation || Representation.ActorSpawnRequestHandle.IsValid())
		{
			if (Representation.CurrentRepresentation == EMassRepresentationType::None)
			{
				Representation.PrevTransform = TransformFragment.GetTransform();
				Representation.PrevLODSignificance = RepresentationLOD.LODSignificance;
			}

			switch (WantedRepresentationType)
			{
				case EMassRepresentationType::HighResSpawnedActor:
				case EMassRepresentationType::LowResSpawnedActor:
				{
					const bool bHighResActor = WantedRepresentationType == EMassRepresentationType::HighResSpawnedActor;

					// Reuse actor, if it is valid and not owned by mass or same representation as low res without a valid spawning request
					AActor* NewActor = nullptr;
					if (!Actor || ActorInfo.IsOwnedByMass())
					{
						const int16 WantedTemplateActorIndex = bHighResActor ? Representation.HighResTemplateActorIndex : Representation.LowResTemplateActorIndex;

						// If the low res is different than the high res, cancel any pending spawn request that is the opposite of what is needed.
						if (Representation.LowResTemplateActorIndex != Representation.HighResTemplateActorIndex)
						{
							ReleaseActorOrCancelSpawning(*RepresentationSubsystem, MassActorSubsystem, MassAgentEntityHandle, ActorInfo, bHighResActor ? Representation.LowResTemplateActorIndex : Representation.HighResTemplateActorIndex, Representation.ActorSpawnRequestHandle, Context.Defer(), /*bCancelSpawningOnly*/true);
							Actor = ActorInfo.GetOwnedByMassMutable();
						}

						// If there isn't any actor yet or
						// If the actor isn't matching the one needed or
						// If there is still a pending spawn request
						// Then try to retrieve/spawn the new actor
						if (!Actor ||
							!RepresentationSubsystem->DoesActorMatchTemplate(*Actor, WantedTemplateActorIndex) ||
							Representation.ActorSpawnRequestHandle.IsValid())
						{
							NewActor = RepresentationActorManagement->GetOrSpawnActor(*RepresentationSubsystem, CachedEntityManager, MassAgentEntityHandle, TransformFragment.GetTransform(), WantedTemplateActorIndex, Representation.ActorSpawnRequestHandle, RepresentationActorManagement->GetSpawnPriority(RepresentationLOD));
						}
						else
						{
							NewActor = Actor;
						}
					}
					else
					{
						NewActor = Actor;
					}

					if (NewActor)
					{
						// Make sure our (re)activated actor is at the simulated position
						// Needs to be done before enabling the actor so the animation initialization can use the new values
						if (Representation.CurrentRepresentation == EMassRepresentationType::StaticMeshInstance)
						{
							RepresentationActorManagement->TeleportActor(Representation.PrevTransform, *NewActor, Context.Defer());
						}

						RepresentationActorManagement->SetActorEnabled(bHighResActor ? EMassActorEnabledType::HighRes : EMassActorEnabledType::LowRes, *NewActor, EntityIdx, Context.Defer());
						Representation.CurrentRepresentation = WantedRepresentationType;
					}
					else if (!Actor)
					{
						Representation.CurrentRepresentation = RepresentationParams.CachedDefaultRepresentationType;
					}
					break;
				}
				case EMassRepresentationType::StaticMeshInstance:
					if (!bDoKeepActorExtraFrame || 
					   (Representation.PrevRepresentation != EMassRepresentationType::HighResSpawnedActor && Representation.PrevRepresentation != EMassRepresentationType::LowResSpawnedActor))
					{
						DisableActorForISM(Actor);
					}
 
					Representation.CurrentRepresentation = EMassRepresentationType::StaticMeshInstance;
					break;
				case EMassRepresentationType::None:
					if (!Actor || ActorInfo.IsOwnedByMass())
					{
						// Try releasing both, could have an high res spawned actor and a spawning request for a low res one
						ReleaseActorOrCancelSpawning(*RepresentationSubsystem, MassActorSubsystem, MassAgentEntityHandle, ActorInfo, Representation.LowResTemplateActorIndex, Representation.ActorSpawnRequestHandle, Context.Defer());
						ReleaseActorOrCancelSpawning(*RepresentationSubsystem, MassActorSubsystem, MassAgentEntityHandle, ActorInfo, Representation.HighResTemplateActorIndex, Representation.ActorSpawnRequestHandle, Context.Defer());
					}
					else
					{
						RepresentationActorManagement->SetActorEnabled(EMassActorEnabledType::Disabled, *Actor, EntityIdx, Context.Defer());
					}
					Representation.CurrentRepresentation = EMassRepresentationType::None;
					break;
				default:
					checkf(false, TEXT("Unsupported LOD type"));
					break;
			}
		}
		else if (bDoKeepActorExtraFrame
				&& Representation.PrevRepresentation == EMassRepresentationType::StaticMeshInstance 
				&& (PrevRepresentationCopy == EMassRepresentationType::HighResSpawnedActor 
					|| PrevRepresentationCopy == EMassRepresentationType::LowResSpawnedActor))
		{
			DisableActorForISM(Actor);
		}
		// === 3 end
	}

#if WITH_MASSGAMEPLAY_DEBUG
	// Optional debug display
	if (UE::Mass::Representation::Debug::DebugRepresentation == 1 || UE::Mass::Representation::Debug::DebugRepresentation >= 3)
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(DebugDisplayRepresentation)
		UWorld* World = CachedEntityManager.GetWorld();
		UE::Mass::Representation::Debug::DebugDisplayRepresentation(Context, RepresentationLODList, RepresentationList, TransformList, World);
	}
	// Optional vislog
	if (UE::Mass::Representation::Debug::DebugRepresentation >= 2)
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(VisLogRepresentation)
		UE::Mass::Representation::Debug::VisLogRepresentation(Context, RepresentationLODList, RepresentationList, TransformList, RepresentationSubsystem);
	}
#endif
}

void UMassRepresentationProcessor::Execute(FMassEntityManager& InEntityManager, FMassExecutionContext& Context)
{
	// Update entities representation
	EntityQuery.ForEachEntityChunk(InEntityManager, Context, [this](FMassExecutionContext& Context)
	{
		UpdateRepresentation(Context, UpdateParams);
	});
}

bool UMassRepresentationProcessor::ReleaseActorOrCancelSpawning(UMassRepresentationSubsystem& RepresentationSubsystem, UMassActorSubsystem* MassActorSubsystem
	, const FMassEntityHandle MassAgent, FMassActorFragment& ActorInfo, const int16 TemplateActorIndex, FMassActorSpawnRequestHandle& SpawnRequestHandle
	, FMassCommandBuffer& CommandBuffer, bool bCancelSpawningOnly /*= false*/)
{
	if (TemplateActorIndex == INDEX_NONE)
	{
		// Nothing to release
		return false;
	}
	check(!ActorInfo.IsValid() || ActorInfo.IsOwnedByMass());

	AActor* Actor = ActorInfo.GetOwnedByMassMutable();
	// note that it's fine for Actor to be null. That means the RepresentationSubsystem will try to stop 
	// the spawning of whatever SpawnRequestHandle reference to
	const bool bSuccess = bCancelSpawningOnly ? RepresentationSubsystem.CancelSpawning(MassAgent, TemplateActorIndex, SpawnRequestHandle) :
			RepresentationSubsystem.ReleaseTemplateActorOrCancelSpawning(MassAgent, TemplateActorIndex, Actor, SpawnRequestHandle);
	if (bSuccess)
	{
		Actor = ActorInfo.GetOwnedByMassMutable();
		if (Actor && RepresentationSubsystem.DoesActorMatchTemplate(*Actor, TemplateActorIndex))
		{
			ActorInfo.ResetNoHandleMapUpdate();
			
			TObjectKey<const AActor> ActorKey(Actor); 
			if (MassActorSubsystem)
			{
				CommandBuffer.PushCommand<FMassDeferredSetCommand>([MassActorSubsystem, ActorKey](FMassEntityManager&)
				{
					MassActorSubsystem->RemoveHandleForActor(ActorKey);
				});
			}
		}
		return true;
	}
	return false;
}

//----------------------------------------------------------------------//
// UMassVisualizationProcessor 
//----------------------------------------------------------------------//
void UMassVisualizationProcessor::UpdateVisualization(FMassExecutionContext& Context)
{
	FMassVisualizationChunkFragment& ChunkData = UpdateChunkVisibility(Context);
	if (!ChunkData.ShouldUpdateVisualization())
	{
		return;
	}

	UpdateRepresentation(Context, UpdateParams);

	// Update entity visibility
	const TArrayView<FMassRepresentationFragment> RepresentationList = Context.GetMutableFragmentView<FMassRepresentationFragment>();
	const TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();

	const int32 NumEntities = Context.GetNumEntities();
	for (int32 EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
	{
		const FMassEntityHandle Entity = Context.GetEntity(EntityIdx);
		FMassRepresentationFragment& Representation = RepresentationList[EntityIdx];
		const FMassRepresentationLODFragment& RepresentationLOD = RepresentationLODList[EntityIdx];
		UpdateEntityVisibility(Entity, Representation, RepresentationLOD, ChunkData, Context.Defer());
	}
}

void UMassVisualizationProcessor::ConfigureQueries()
{
	Super::ConfigureQueries();
	EntityQuery.AddChunkRequirement<FMassVisualizationChunkFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddTagRequirement<FMassVisualizationProcessorTag>(EMassFragmentPresence::All);
}

FMassVisualizationChunkFragment& UMassVisualizationProcessor::UpdateChunkVisibility(FMassExecutionContext& Context) const
{
	const FMassRepresentationParameters& RepresentationParams = Context.GetConstSharedFragment<FMassRepresentationParameters>();
	bool bFirstUpdate = false;

	// Setup chunk fragment data about visibility
	FMassVisualizationChunkFragment& ChunkData = Context.GetMutableChunkFragment<FMassVisualizationChunkFragment>();
	EMassVisibility ChunkVisibility = ChunkData.GetVisibility();
	if (ChunkVisibility == EMassVisibility::Max)
	{
		// The visibility on the chunk fragment data isn't set yet, let see if the Archetype has an visibility tag and set it on the ChunkData
		ChunkVisibility = UE::Mass::Representation::GetVisibilityFromArchetype(Context);
		ChunkData.SetVisibility(ChunkVisibility);
		bFirstUpdate = RepresentationParams.bSpreadFirstVisualizationUpdate;
	}
	else
	{
		checkfSlow(UE::Mass::Representation::IsVisibilityTagSet(Context, ChunkVisibility), TEXT("Expecting the same Visibility as what we saved in the chunk data, maybe external code is modifying the tags"))
	}

	if (ChunkVisibility == EMassVisibility::CulledByDistance)
	{
		float DeltaTime = ChunkData.GetDeltaTime();
		if (bFirstUpdate)
		{
			// A DeltaTime of 0.0f means it will tick this frame.
			// @todo: Add some randomization for deterministic runs too. The randomization is used to distribute the infrequent ticks evenly on different frames.
			DeltaTime = UE::Mass::Utils::IsDeterministic() ? RepresentationParams.NotVisibleUpdateRate * 0.5f : FMath::RandRange(0.0f, RepresentationParams.NotVisibleUpdateRate);
		}
		else 
		{
			if (DeltaTime < 0.0f)
			{
				// @todo: Add some randomization for deterministic runs too. The randomization is used to distribute the infrequent ticks evenly on different frames.
				DeltaTime += UE::Mass::Utils::IsDeterministic() ? RepresentationParams.NotVisibleUpdateRate : (RepresentationParams.NotVisibleUpdateRate * (1.0f + FMath::RandRange(-0.1f, 0.1f)));
			}
			DeltaTime -= Context.GetDeltaTimeSeconds();
		}

		ChunkData.Update(DeltaTime);
	}

	return ChunkData;
}

void UMassVisualizationProcessor::UpdateEntityVisibility(const FMassEntityHandle Entity, const FMassRepresentationFragment& Representation, const FMassRepresentationLODFragment& RepresentationLOD, FMassVisualizationChunkFragment& ChunkData, FMassCommandBuffer& CommandBuffer)
{
	// Move the visible entities together into same chunks so we can skip entire chunk when not visible as an optimization
	const EMassVisibility Visibility = Representation.CurrentRepresentation != EMassRepresentationType::None ? 
		EMassVisibility::CanBeSeen : RepresentationLOD.Visibility;
	const EMassVisibility ChunkVisibility = ChunkData.GetVisibility();
	if (ChunkVisibility != Visibility)
	{
		UE::Mass::Representation::PushSwapTagsCommand(CommandBuffer, Entity, ChunkVisibility, Visibility);
		ChunkData.SetContainsNewlyVisibleEntity(Visibility == EMassVisibility::CanBeSeen);
	}
}

void UMassVisualizationProcessor::Execute(FMassEntityManager& InEntityManager, FMassExecutionContext& Context)
{
	SCOPE_CYCLE_COUNTER(STAT_Mass_VisProcessor_Execute);

	int32 TotalEntitiesProcessed = 0;
	// Update entities visualization
	EntityQuery.ForEachEntityChunk(InEntityManager, Context, [this, &TotalEntitiesProcessed](FMassExecutionContext& Context)
	{
		TotalEntitiesProcessed += Context.GetNumEntities();
		UpdateVisualization(Context);
	});

	UE_VLOG(this, LogMassRepresentation, Verbose, TEXT("UMassVisualizationProcessor::Execute processed %d entities"), TotalEntitiesProcessed);
}

//----------------------------------------------------------------------//
// UMassRepresentationFragmentDestructor 
//----------------------------------------------------------------------//
UMassRepresentationFragmentDestructor::UMassRepresentationFragmentDestructor()
	: EntityQuery(*this)
{
	ObservedType = FMassRepresentationFragment::StaticStruct();
	Operation = EMassObservedOperation::Remove;
	ExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;
	bRequiresGameThreadExecution = true; // due to FMassRepresentationSubsystemSharedFragment.RepresentationSubsystem use
}

void UMassRepresentationFragmentDestructor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FMassRepresentationFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FMassActorFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddConstSharedRequirement<FMassRepresentationParameters>();
	EntityQuery.AddSharedRequirement<FMassRepresentationSubsystemSharedFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddSubsystemRequirement<UMassActorSubsystem>(EMassFragmentAccess::ReadWrite);
}

void UMassRepresentationFragmentDestructor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
	{
		UMassRepresentationSubsystem* RepresentationSubsystem = Context.GetMutableSharedFragment<FMassRepresentationSubsystemSharedFragment>().RepresentationSubsystem;
		check(RepresentationSubsystem);
		UMassActorSubsystem* ActorSubsystem = Context.GetMutableSubsystem<UMassActorSubsystem>();

		const TArrayView<FMassRepresentationFragment> RepresentationList = Context.GetMutableFragmentView<FMassRepresentationFragment>();
		const TArrayView<FMassActorFragment> ActorList = Context.GetMutableFragmentView<FMassActorFragment>();

		const int32 NumEntities = Context.GetNumEntities();
		for (int32 i = 0; i < NumEntities; ++i)
		{
			FMassRepresentationFragment& Representation = RepresentationList[i];
			FMassActorFragment& ActorInfo = ActorList[i];

			const FMassEntityHandle MassAgentEntityHandle = Context.GetEntity(i);

			UMassRepresentationActorManagement::ReleaseAnyActorOrCancelAnySpawning(*RepresentationSubsystem, MassAgentEntityHandle, ActorInfo, Representation, ActorSubsystem);
		}
	});
}

=========================================================================


=== Source/MassRepresentation/Private/MassRepresentationSubsystem.cpp ===
=========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassRepresentationSubsystem.h"
#include "Engine/World.h"
#include "MassActorSpawnerSubsystem.h"
#include "MassActorSubsystem.h"
#include "MassSimulationSubsystem.h"
#include "MassVisualizationComponent.h"
#include "MassVisualizer.h"
#include "MassRepresentationTypes.h"
#include "MassSimulationSettings.h"
#include "MassAgentComponent.h"
#include "MassAgentSubsystem.h"
#include "MassEntityManager.h"
#include "MassRepresentationFragments.h"
#include "MassRepresentationActorManagement.h"
#include "MassEntityView.h"
#include "WorldPartition/WorldPartitionSubsystem.h"
#include "WorldPartition/WorldPartitionRuntimeCell.h"
#include "MassEntityUtils.h"


FStaticMeshInstanceVisualizationDescHandle UMassRepresentationSubsystem::FindOrAddStaticMeshDesc(const FStaticMeshInstanceVisualizationDesc& Desc)
{
	check(VisualizationComponent);
	return VisualizationComponent->FindOrAddVisualDesc(Desc);
}

FStaticMeshInstanceVisualizationDescHandle UMassRepresentationSubsystem::AddVisualDescWithISMComponent(const FStaticMeshInstanceVisualizationDesc& Desc, UInstancedStaticMeshComponent& ISMComponent)
{
	check(VisualizationComponent);
	return VisualizationComponent->AddVisualDescWithISMComponent(Desc, ISMComponent);
}

FStaticMeshInstanceVisualizationDescHandle UMassRepresentationSubsystem::AddVisualDescWithISMComponents(const FStaticMeshInstanceVisualizationDesc& Desc, TArrayView<TObjectPtr<UInstancedStaticMeshComponent>> ISMComponents)
{
	check(VisualizationComponent);
	return VisualizationComponent->AddVisualDescWithISMComponents(Desc, ISMComponents);
}

const FMassISMCSharedData* UMassRepresentationSubsystem::GetISMCSharedDataForDescriptionIndex(const int32 DescriptionIndex) const
{
	check(VisualizationComponent);
	return VisualizationComponent->GetISMCSharedDataForDescriptionIndex(DescriptionIndex);
}

const FMassISMCSharedData* UMassRepresentationSubsystem::GetISMCSharedDataForInstancedStaticMesh(const UInstancedStaticMeshComponent* ISMC) const
{
	check(VisualizationComponent);
	return VisualizationComponent->GetISMCSharedDataForInstancedStaticMesh(ISMC);
}

void UMassRepresentationSubsystem::RemoveISMComponent(UInstancedStaticMeshComponent& ISMComponent)
{
PRAGMA_DISABLE_DEPRECATION_WARNINGS
	check(VisualizationComponent);
	return VisualizationComponent->RemoveISMComponent(ISMComponent);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
}

void UMassRepresentationSubsystem::RemoveVisualDesc(const FStaticMeshInstanceVisualizationDescHandle VisualizationHandle)
{
	check(VisualizationComponent);
	return VisualizationComponent->RemoveVisualDesc(VisualizationHandle);
}

FMassInstancedStaticMeshInfoArrayView UMassRepresentationSubsystem::GetMutableInstancedStaticMeshInfos()
{
	check(VisualizationComponent);
	FMassInstancedStaticMeshInfoArrayView View = VisualizationComponent->GetMutableVisualInfos();
	return MoveTemp(View);
}

void UMassRepresentationSubsystem::DirtyStaticMeshInstances()
{
	check(VisualizationComponent);
	return VisualizationComponent->DirtyVisuals();
}

int16 UMassRepresentationSubsystem::FindOrAddTemplateActor(const TSubclassOf<AActor>& ActorClass)
{
	UE_MT_SCOPED_WRITE_ACCESS(TemplateActorsMTAccessDetector);

	int32 VisualIndex = TemplateActors.IndexOfByPredicate(FTemplateActorEqualsPredicate{ActorClass});

	if (VisualIndex == INDEX_NONE)
	{
		VisualIndex = TemplateActors.Add({ActorClass, 1u});
	}
	else
	{
		++TemplateActors[VisualIndex].RefCount;
	}

	check(VisualIndex < INT16_MAX);
	return (int16)VisualIndex;
}

AActor* UMassRepresentationSubsystem::GetOrSpawnActorFromTemplate(const FMassEntityHandle MassAgent, const FTransform& Transform
	, const int16 TemplateActorIndex, FMassActorSpawnRequestHandle& InOutSpawnRequestHandle, float Priority
	, FMassActorPreSpawnDelegate ActorPreSpawnDelegate, FMassActorPostSpawnDelegate ActorPostSpawnDelegate)
{
	UE_MT_SCOPED_READ_ACCESS(TemplateActorsMTAccessDetector);
	if (!TemplateActors.IsValidIndex(TemplateActorIndex))
	{
		UE_LOG(LogMassRepresentation, Error, TEXT("Template actor type %i is not referring to a valid type"), TemplateActorIndex);
		return nullptr;
	}

	//@todo: this would be a good place to do pooling of actors instead of spawning them every time
	check(ActorSpawnerSubsystem);
	const TSubclassOf<AActor> TemplateToSpawn = TemplateActors[TemplateActorIndex].Actor;

	if (InOutSpawnRequestHandle.IsValid())
	{
		FMassActorSpawnRequest& SpawnRequest = ActorSpawnerSubsystem->GetMutableSpawnRequest<FMassActorSpawnRequest>(InOutSpawnRequestHandle);
		// Check if this existing spawn request is matching the template actor
		if (SpawnRequest.Template != TemplateToSpawn)
		{
			return nullptr;
		}
		switch (SpawnRequest.SpawnStatus)
		{
			case ESpawnRequestStatus::RetryPending:
			case ESpawnRequestStatus::Pending:
				// Update spawn request with latest information
				SpawnRequest.Transform = Transform;
				SpawnRequest.Priority = Priority;
				return nullptr;
			case ESpawnRequestStatus::Failed:
			{
				check(!SpawnRequest.SpawnedActor);
				// The most common case for failure is that collision was preventing the spawning, the agent might have moved or the thing preventing it from spawning might have moved too.
				UWorld* World = GetWorld();
				check(World);

				// Limits the retry as they are bad for rendering performance
				if ((World->GetTimeSeconds() - SpawnRequest.RequestedTime) > RetryTimeInterval ||
					(SpawnRequest.Transform.GetLocation() - Transform.GetLocation()).SizeSquared() > RetryMovedDistanceSq)
				{
					// Update spawn request with latest information and retry
					SpawnRequest.Transform = Transform;
					SpawnRequest.Priority = Priority;
					ActorSpawnerSubsystem->RetryActorSpawnRequest(InOutSpawnRequestHandle);
				}
				return nullptr;
			}
			case ESpawnRequestStatus::Succeeded:
			{
				AActor* SpawnedActor = SpawnRequest.SpawnedActor;
				check(SpawnedActor);
				ensureMsgf(ActorSpawnerSubsystem->RemoveActorSpawnRequest(InOutSpawnRequestHandle), TEXT("Unable to remove a valid spawn request"));
				return SpawnedActor;
			}
			default:
				checkf(false, TEXT("Unexpected spawn request status!"));
				InOutSpawnRequestHandle.Invalidate();
				return nullptr;
		}
	}

	// If we reach here, means we need to create a spawn request
	FMassActorSpawnRequest SpawnRequest;
	SpawnRequest.MassAgent = MassAgent;
	if (FMassGuidFragment* GuidFragment = EntityManager->GetFragmentDataPtr<FMassGuidFragment>(MassAgent))
	{
		SpawnRequest.Guid = GuidFragment->Guid;
	}
	SpawnRequest.Template = TemplateToSpawn;
	SpawnRequest.Transform = Transform;
	SpawnRequest.Priority = Priority;
	SpawnRequest.ActorPreSpawnDelegate = ActorPreSpawnDelegate;
	SpawnRequest.ActorPostSpawnDelegate = ActorPostSpawnDelegate;
	InOutSpawnRequestHandle = ActorSpawnerSubsystem->RequestActorSpawn(SpawnRequest);

	++(HandledMassAgents.FindOrAdd(MassAgent));

	return nullptr;
}

TSubclassOf<AActor> UMassRepresentationSubsystem::GetTemplateActorClass(const int16 TemplateActorIndex)
{
	UE_MT_SCOPED_READ_ACCESS(TemplateActorsMTAccessDetector);
	if (!TemplateActors.IsValidIndex(TemplateActorIndex))
	{
		UE_LOG(LogMassRepresentation, Error, TEXT("Template actor type %i is not referring to a valid type"), TemplateActorIndex);
		return nullptr;
	}

	return TemplateActors[TemplateActorIndex].Actor;
}

bool UMassRepresentationSubsystem::IsCollisionLoaded(const FName TargetGrid, const FTransform& Transform) const
{
	if (!WorldPartitionSubsystem)
	{
		// Assuming that all collisions are loaded if not using WorldPartition.
		return true;
	}

	// @todo optimize by doing one query per cell
	// Build a query source
	TArray<FWorldPartitionStreamingQuerySource> QuerySources;
	FWorldPartitionStreamingQuerySource& QuerySource = QuerySources.Emplace_GetRef();
	QuerySource.bSpatialQuery = true;
	QuerySource.Location = Transform.GetLocation();
	QuerySource.Rotation = Transform.Rotator();
	if (!TargetGrid.IsNone())
	{
		QuerySource.TargetGrids.Add(TargetGrid);
	}
	QuerySource.bUseGridLoadingRange = false;
	QuerySource.Radius = 1.f; // 1cm should be enough to know if grid is loaded at specific area
	QuerySource.bDataLayersOnly = false;

	// Execute query
	return WorldPartitionSubsystem->IsStreamingCompleted(EWorldPartitionRuntimeCellState::Activated, QuerySources, /*bExactState*/ false);
}

void UMassRepresentationSubsystem::ReleaseTemplate(const TSubclassOf<AActor>& ActorClass)
{
	if (ActorClass)
	{
		UE_MT_SCOPED_WRITE_ACCESS(TemplateActorsMTAccessDetector);
		
		const int32 TemplateActorIndex = TemplateActors.IndexOfByPredicate(FTemplateActorEqualsPredicate{ActorClass});
		check(TemplateActors.IsValidIndex(TemplateActorIndex));

		FTemplateActorData& TemplateActorData = TemplateActors[TemplateActorIndex];
		check(TemplateActorData.RefCount > 0u);
		--TemplateActorData.RefCount;

		if (TemplateActorData.RefCount == 0u)
		{
			TemplateActors.RemoveAt(TemplateActorIndex);
		}
	}
}

void UMassRepresentationSubsystem::ReleaseAllResources()
{
	ensureMsgf(HandledMassAgents.Num() == 0, TEXT("All entities must be released before releasing resources"));

	{
		// Release all template actors
		UE_MT_SCOPED_WRITE_ACCESS(TemplateActorsMTAccessDetector);
		TemplateActors.Reset();
	}

	// Release all static meshes resources
	VisualizationComponent->ClearAllVisualInstances();
}

bool UMassRepresentationSubsystem::ReleaseTemplateActorOrCancelSpawning(const FMassEntityHandle MassAgent, const int16 TemplateActorIndex, AActor* ActorToRelease, FMassActorSpawnRequestHandle& SpawnRequestHandle)
{
	// First try to cancel the spawning request, then try to release the actor
	if( CancelSpawningInternal(TemplateActorIndex, SpawnRequestHandle) ||
		ReleaseTemplateActorInternal(TemplateActorIndex, ActorToRelease, false))
	{ 
		const int32 RefCount = --(HandledMassAgents.FindChecked(MassAgent));
		checkf(RefCount >= 0, TEXT("RefCount are expected to be greater than or equal to 0"));
		if (RefCount == 0)
		{
			HandledMassAgents.Remove(MassAgent);
		}
		return true;
	}

	return false;
}

bool UMassRepresentationSubsystem::ReleaseTemplateActor(const FMassEntityHandle MassAgent, const int16 TemplateActorIndex, AActor* ActorToRelease, bool bImmediate)
{
	if (ReleaseTemplateActorInternal(TemplateActorIndex, ActorToRelease, bImmediate))
	{
		const int32 RefCount = --HandledMassAgents.FindChecked(MassAgent);
		checkf(RefCount >= 0, TEXT("RefCount are expected to be greater than or equal to 0"));
		if (RefCount == 0)
		{
			HandledMassAgents.Remove(MassAgent);
		}
		return true;
	}

	return false;
}

bool UMassRepresentationSubsystem::CancelSpawning(const FMassEntityHandle MassAgent, const int16 TemplateActorIndex, FMassActorSpawnRequestHandle& SpawnRequestHandle)
{
	if (CancelSpawningInternal(TemplateActorIndex, SpawnRequestHandle))
	{
		const int32 RefCount = --HandledMassAgents.FindChecked(MassAgent);
		checkf(RefCount >= 0, TEXT("RefCount are expected to be greater than or equal to 0"));
		if (RefCount == 0)
		{
			HandledMassAgents.Remove(MassAgent);
		}
		return true;
	}
	return false;
}

bool UMassRepresentationSubsystem::ReleaseTemplateActorInternal(const int16 TemplateActorIndex, AActor* ActorToRelease, bool bImmediate)
{
	UE_MT_SCOPED_READ_ACCESS(TemplateActorsMTAccessDetector);
	if (!TemplateActors.IsValidIndex(TemplateActorIndex))
	{
		UE_LOG(LogMassRepresentation, Error, TEXT("Template actor type %i is not referring a valid type"), TemplateActorIndex);
		return false;
	}
	const TSubclassOf<AActor> TemplateToRelease = TemplateActors[TemplateActorIndex].Actor;

	// We can only release existing and matching template actors
	if (!ActorToRelease || ActorToRelease->GetClass() != TemplateToRelease)
	{
		return false;
	}
	ActorSpawnerSubsystem->DestroyActor(ActorToRelease, bImmediate);
	return true;
}

bool UMassRepresentationSubsystem::CancelSpawningInternal(const int16 TemplateActorIndex, FMassActorSpawnRequestHandle& SpawnRequestHandle)
{
	UE_MT_SCOPED_READ_ACCESS(TemplateActorsMTAccessDetector);
	if (!TemplateActors.IsValidIndex(TemplateActorIndex))
	{
		UE_LOG(LogMassRepresentation, Error, TEXT("Template actor type %i is not referring a valid type"), TemplateActorIndex);
		return false;
	}
	const TSubclassOf<AActor> TemplateToRelease = TemplateActors[TemplateActorIndex].Actor;

	check(ActorSpawnerSubsystem);
	// Check if there is something to cancel
	if (!SpawnRequestHandle.IsValid())
	{
		return false;
	}

	const FMassActorSpawnRequest& SpawnRequest = ActorSpawnerSubsystem->GetMutableSpawnRequest<FMassActorSpawnRequest>(SpawnRequestHandle);
	// Check if the spawning request matches the template actor
	if (SpawnRequest.Template != TemplateToRelease)
	{
		return false;
	}

	if (SpawnRequest.SpawnStatus == ESpawnRequestStatus::Succeeded)
	{
		check(SpawnRequest.SpawnedActor);
		ReleaseTemplateActorInternal(TemplateActorIndex, SpawnRequest.SpawnedActor, false);
	}

	// Remove the spawn request
	ensureMsgf(ActorSpawnerSubsystem->RemoveActorSpawnRequest(SpawnRequestHandle), TEXT("Unable to remove a valid spawn request"));

	return true;
}

bool UMassRepresentationSubsystem::DoesActorMatchTemplate(const AActor& Actor, const int16 TemplateActorIndex) const
{
	UE_MT_SCOPED_READ_ACCESS(TemplateActorsMTAccessDetector);
	if (!TemplateActors.IsValidIndex(TemplateActorIndex))
	{
		UE_LOG(LogMassRepresentation, Error, TEXT("Template actor type %i is not referring to a valid type"), TemplateActorIndex);
		return false;
	}

	const TSubclassOf<AActor> Template = TemplateActors[TemplateActorIndex].Actor;
	return Actor.GetClass() == Template;
}

void UMassRepresentationSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Collection.InitializeDependency(UMassSimulationSubsystem::StaticClass());
	Collection.InitializeDependency(UMassActorSpawnerSubsystem::StaticClass());
	Collection.InitializeDependency(UMassAgentSubsystem::StaticClass());
	Super::Initialize(Collection);

	if (UWorld* World = GetWorld())
	{
		EntityManager = UE::Mass::Utils::GetEntityManagerChecked(*World).AsShared();

		ActorSpawnerSubsystem = World->GetSubsystem<UMassActorSpawnerSubsystem>();
		WorldPartitionSubsystem = World->GetSubsystem<UWorldPartitionSubsystem>();

		if (Visualizer == nullptr)
		{
			FActorSpawnParameters SpawnInfo;
			SpawnInfo.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
			// The helper actor is only once per world so we can allow it to spawn during construction script.
			SpawnInfo.bAllowDuringConstructionScript = true;
			Visualizer = World->SpawnActor<AMassVisualizer>(SpawnInfo);
			check(Visualizer);
			VisualizationComponent = &Visualizer->GetVisualizationComponent();

#if WITH_EDITOR
			Visualizer->SetActorLabel(FString::Printf(TEXT("%sVisualizer"), *GetClass()->GetName()), /*bMarkDirty*/false);
#endif
		}

		UMassSimulationSubsystem* SimSystem = World->GetSubsystem<UMassSimulationSubsystem>();
		check(SimSystem);
		SimSystem->GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).AddUObject(this, &UMassRepresentationSubsystem::OnProcessingPhaseStarted, EMassProcessingPhase::PrePhysics);
		SimSystem->GetOnProcessingPhaseFinished(EMassProcessingPhase::PostPhysics).AddUObject(this, &UMassRepresentationSubsystem::OnProcessingPhaseStarted, EMassProcessingPhase::PostPhysics);

		UMassAgentSubsystem* AgentSystem = World->GetSubsystem<UMassAgentSubsystem>();
		check(AgentSystem);
		AgentSystem->GetOnMassAgentComponentEntityAssociated().AddUObject(this, &UMassRepresentationSubsystem::OnMassAgentComponentEntityAssociated);
		AgentSystem->GetOnMassAgentComponentEntityDetaching().AddUObject(this, &UMassRepresentationSubsystem::OnMassAgentComponentEntityDetaching);
	}

	RetryMovedDistanceSq = FMath::Square(GET_MASSSIMULATION_CONFIG_VALUE(DesiredActorFailedSpawningRetryMoveDistance));
	RetryTimeInterval = GET_MASSSIMULATION_CONFIG_VALUE(DesiredActorFailedSpawningRetryTimeInterval);
}

void UMassRepresentationSubsystem::Deinitialize()
{
	if (const UWorld* World = GetWorld())
	{
		if (UMassSimulationSubsystem* SimSystem = World->GetSubsystem<UMassSimulationSubsystem>())
		{
			SimSystem->GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).RemoveAll(this);
			SimSystem->GetOnProcessingPhaseFinished(EMassProcessingPhase::PostPhysics).RemoveAll(this);
		}

		if (UMassAgentSubsystem* AgentSystem = World->GetSubsystem<UMassAgentSubsystem>())
		{
			AgentSystem->GetOnMassAgentComponentEntityAssociated().RemoveAll(this);
			AgentSystem->GetOnMassAgentComponentEntityDetaching().RemoveAll(this);
		}
	}
	EntityManager.Reset();

	Super::Deinitialize();
}

void UMassRepresentationSubsystem::OnProcessingPhaseStarted(const float DeltaSeconds, const EMassProcessingPhase Phase) const
{
	check(VisualizationComponent);
	switch (Phase)
	{
		case EMassProcessingPhase::PrePhysics:
			VisualizationComponent->BeginVisualChanges();
			break;
		case EMassProcessingPhase::PostPhysics:/* Currently this is the end of phases signal */
			VisualizationComponent->EndVisualChanges();
			break;
		default:
			check(false); // Need to handle this case
			break;
	}
}

void UMassRepresentationSubsystem::OnMassAgentComponentEntityAssociated(const UMassAgentComponent& AgentComponent)
{
	check(EntityManager);

	const FMassEntityHandle MassAgent = AgentComponent.GetEntityHandle();
	checkf(EntityManager->IsEntityValid(MassAgent), TEXT("Expecting a valid mass entity"));
	if (EntityManager->IsEntityValid(MassAgent) && AgentComponent.IsNetSimulating())
	{
		// Check if this mass agent already handled by this sub system, if yes than release any local spawned actor or cancel any spawn requests
		if (HandledMassAgents.Find(MassAgent))
		{
			UMassRepresentationActorManagement::ReleaseAnyActorOrCancelAnySpawning(*EntityManager.Get(), MassAgent);
		}
	}
}

void UMassRepresentationSubsystem::OnMassAgentComponentEntityDetaching(const UMassAgentComponent& AgentComponent)
{
	check(EntityManager);

	AActor* ComponentOwner = AgentComponent.GetOwner();
	check(ComponentOwner);

	const FMassEntityHandle MassAgent = AgentComponent.GetEntityHandle();
	checkf(EntityManager->IsEntityValid(MassAgent), TEXT("Expecting a valid mass entity"));
	if (EntityManager->IsEntityValid(MassAgent) && AgentComponent.IsNetSimulating())
	{
		const FMassEntityView EntityView(*EntityManager.Get(), MassAgent);
		if (FMassRepresentationFragment* Representation = EntityView.GetFragmentDataPtr<FMassRepresentationFragment>())
		{
			// Force a reevaluate of the current representation
			Representation->CurrentRepresentation = EMassRepresentationType::None;
		}
	}
}

void UMassRepresentationSubsystem::AddReferencedObjects(UObject* InThis, FReferenceCollector& Collector)
{
	Super::AddReferencedObjects(InThis, Collector);

	UMassRepresentationSubsystem& TypedThis = *CastChecked<UMassRepresentationSubsystem>(InThis);
	for (FTemplateActorData& TemplateActorData : TypedThis.TemplateActors)
	{
		Collector.AddStableReference(&TemplateActorData.Actor.GetGCPtr());
	}
}

=========================================================================


=== Source/MassRepresentation/Private/MassRepresentationTypes.cpp ===
=====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassRepresentationTypes.h"
#include "MassRepresentationUtils.h"
#include "MassCommandBuffer.h"
#include "Components/InstancedStaticMeshComponent.h"

DEFINE_LOG_CATEGORY(LogMassRepresentation);

namespace UE::Mass::Representation
{
void PushSwapTagsCommand(FMassCommandBuffer& CommandBuffer, const FMassEntityHandle Entity, const EMassVisibility PrevVisibility, const EMassVisibility NewVisibility)
{
#define CASE_SWAP_TAGS(OldVisibility, NewVisibility) \
	case NewVisibility: \
		CommandBuffer.SwapTags<TMassVisibilityTagForLevel<OldVisibility>::FTag, TMassVisibilityTagForLevel<NewVisibility>::FTag>(Entity); \
		break

#define CASE_ADD_TAG(NewVisibility) \
case NewVisibility: \
	CommandBuffer.AddTag<TMassVisibilityTagForLevel<NewVisibility>::FTag>(Entity); \
	break

#define DEFAULT_REMOVE_TAG(OldVisibility) \
case EMassVisibility::Max: /* fall through on purpose */ \
default: \
	CommandBuffer.RemoveTag<TMassVisibilityTagForLevel<OldVisibility>::FTag>(Entity); \
	break

	check(PrevVisibility != NewVisibility);

	switch (PrevVisibility)
	{
	case EMassVisibility::CanBeSeen:
		switch (NewVisibility)
		{
		CASE_SWAP_TAGS(EMassVisibility::CanBeSeen, EMassVisibility::CulledByFrustum);
		CASE_SWAP_TAGS(EMassVisibility::CanBeSeen, EMassVisibility::CulledByDistance);
		DEFAULT_REMOVE_TAG(EMassVisibility::CanBeSeen);
		}
		break;
	case EMassVisibility::CulledByFrustum:
		switch (NewVisibility)
		{
		CASE_SWAP_TAGS(EMassVisibility::CulledByFrustum, EMassVisibility::CanBeSeen);
		CASE_SWAP_TAGS(EMassVisibility::CulledByFrustum, EMassVisibility::CulledByDistance);
		DEFAULT_REMOVE_TAG(EMassVisibility::CulledByFrustum);
		}
		break;
	case EMassVisibility::CulledByDistance:
		switch (NewVisibility)
		{
		CASE_SWAP_TAGS(EMassVisibility::CulledByDistance, EMassVisibility::CanBeSeen);
		CASE_SWAP_TAGS(EMassVisibility::CulledByDistance, EMassVisibility::CulledByFrustum);
		DEFAULT_REMOVE_TAG(EMassVisibility::CulledByDistance);
		}
		break;
	case EMassVisibility::Max:
		switch (NewVisibility)
		{
		CASE_ADD_TAG(EMassVisibility::CanBeSeen);
		CASE_ADD_TAG(EMassVisibility::CulledByFrustum);
		CASE_ADD_TAG(EMassVisibility::CulledByDistance);
		default:
			checkf(false, TEXT("Unsupported Visibility types!"));
			break;
		}
		break;
	default:
		checkf(false, TEXT("Unsupported Visibility type!"));
		break;
	}

#undef CASE_SWAP_TAGS
}
} // UE::Mass::Representation

//-----------------------------------------------------------------------------
// FMassInstancedStaticMeshInfo
//-----------------------------------------------------------------------------
void FMassInstancedStaticMeshInfo::ClearVisualInstance(UInstancedStaticMeshComponent& ISMComponent)
{
	if (InstancedStaticMeshComponents.RemoveSingleSwap(&ISMComponent, EAllowShrinking::No))
	{
		ISMComponent.ClearInstances();
		ISMComponent.DestroyComponent();
	}
	else
	{
		InstancedStaticMeshComponents.Reset();
		LODSignificanceRanges.Reset();
	}
}

void FMassInstancedStaticMeshInfo::Reset()
{
	Desc.Reset();
	InstancedStaticMeshComponents.Reset();
	LODSignificanceRanges.Reset();
}

//-----------------------------------------------------------------------------
// FMassStaticMeshInstanceVisualizationMeshDesc
//-----------------------------------------------------------------------------
FMassStaticMeshInstanceVisualizationMeshDesc::FMassStaticMeshInstanceVisualizationMeshDesc()
{
	ISMComponentClass = UInstancedStaticMeshComponent::StaticClass();
}

//-----------------------------------------------------------------------------
// FStaticMeshInstanceVisualizationDesc
//-----------------------------------------------------------------------------
bool FStaticMeshInstanceVisualizationDesc::IsValid() const
{
	for (const FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : Meshes)
	{
		if (MeshDesc.Mesh && MeshDesc.ISMComponentClass)
		{
			return true;
		}
	}
	return false;
}

//-----------------------------------------------------------------------------
// FMassISMCSharedDataMap - DEPRECATED
//-----------------------------------------------------------------------------
FMassISMCSharedData& FMassISMCSharedDataMap::GetAndMarkDirtyChecked(const uint32 Hash)
{
	static FMassISMCSharedData Dummy;
	return Dummy;
}

FMassISMCSharedData* FMassISMCSharedDataMap::GetAndMarkDirty(const uint32 Hash)
{
	return nullptr;
}

FMassISMCSharedData* FMassISMCSharedDataMap::Find(const uint32 Hash)
{
	return nullptr;
}

void FMassISMCSharedDataMap::Remove(const uint32 Hash)
{
}

=====================================================================


=== Source/MassRepresentation/Private/MassStationaryDistanceVisualizationTrait.cpp ===
======================================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassStationaryDistanceVisualizationTrait.h"
#include "MassEntityTemplateRegistry.h"
#include "VisualLogger/VisualLogger.h"


UMassStationaryDistanceVisualizationTrait::UMassStationaryDistanceVisualizationTrait(const FObjectInitializer& ObjectInitializer)
{
	bAllowServerSideVisualization = true;
}

void UMassStationaryDistanceVisualizationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	bool bIssuesFound = false;
	for (FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : StaticMeshInstanceDesc.Meshes)
	{
		bIssuesFound = bIssuesFound || (MeshDesc.Mobility != EComponentMobility::Stationary);
		MeshDesc.Mobility = EComponentMobility::Stationary;
	}
	UE_CVLOG_UELOG(bIssuesFound, this, LogMass, Log, TEXT("%s some Meshes' mobility has been set to non-Stationary. Theese settings will be overridden. "), *GetPathName());

	Super::BuildTemplate(BuildContext, World);

	BuildContext.AddTag<FMassStaticRepresentationTag>();
}

#if WITH_EDITOR
void UMassStationaryDistanceVisualizationTrait::PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent)
{
	static const FName StaticMeshInstanceDescName = GET_MEMBER_NAME_CHECKED(UMassStationaryDistanceVisualizationTrait, StaticMeshInstanceDesc);

	Super::PostEditChangeProperty(PropertyChangedEvent);

	if (PropertyChangedEvent.MemberProperty && PropertyChangedEvent.MemberProperty->GetFName() == StaticMeshInstanceDescName)
	{
		for (FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : StaticMeshInstanceDesc.Meshes)
		{
			MeshDesc.Mobility = EComponentMobility::Stationary;
		}
	}
}
#endif // WITH_EDITOR

======================================================================================


=== Source/MassRepresentation/Private/MassStationaryISMRepresentationFragmentDestructor.cpp ===
===============================================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassStationaryISMRepresentationFragmentDestructor.h"
#include "MassRepresentationSubsystem.h"
#include "MassCommonFragments.h"
#include "MassRepresentationProcessor.h"

//-----------------------------------------------------------------------------
// UMassStationaryISMRepresentationFragmentDestructor
//-----------------------------------------------------------------------------
UMassStationaryISMRepresentationFragmentDestructor::UMassStationaryISMRepresentationFragmentDestructor()
	: EntityQuery(*this)
{
	ObservedType = FMassRepresentationFragment::StaticStruct();
	Operation = EMassObservedOperation::Remove;
	ExecutionFlags = (int32)EProcessorExecutionFlags::AllWorldModes;
	bRequiresGameThreadExecution = true; // not sure about this
}

void UMassStationaryISMRepresentationFragmentDestructor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FMassRepresentationFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddConstSharedRequirement<FMassRepresentationParameters>();
	EntityQuery.AddSharedRequirement<FMassRepresentationSubsystemSharedFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddTagRequirement<FMassStaticRepresentationTag>(EMassFragmentPresence::All);
}

void UMassStationaryISMRepresentationFragmentDestructor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
	{
		UMassRepresentationSubsystem* RepresentationSubsystem = Context.GetMutableSharedFragment<FMassRepresentationSubsystemSharedFragment>().RepresentationSubsystem;
		check(RepresentationSubsystem);
		FMassInstancedStaticMeshInfoArrayView ISMInfosView = RepresentationSubsystem->GetMutableInstancedStaticMeshInfos();

		const TArrayView<FMassRepresentationFragment> RepresentationList = Context.GetMutableFragmentView<FMassRepresentationFragment>();

		const int32 NumEntities = Context.GetNumEntities();
		for (int32 EntityIdx = 0; EntityIdx < NumEntities; ++EntityIdx)
		{
			FMassRepresentationFragment& Representation = RepresentationList[EntityIdx];
			if (Representation.CurrentRepresentation == EMassRepresentationType::StaticMeshInstance)
			{
				FMassInstancedStaticMeshInfo& ISMInfo = ISMInfosView[Representation.StaticMeshDescHandle.ToIndex()];
				if (FMassLODSignificanceRange* OldRange = ISMInfo.GetLODSignificanceRange(Representation.PrevLODSignificance))
				{
					const FMassEntityHandle EntityHandle = Context.GetEntity(EntityIdx);
					if (OldRange)
					{
						OldRange->RemoveInstance(EntityHandle);
					}
				}
				Representation.CurrentRepresentation = EMassRepresentationType::None;
			}
		}
	});
}

===============================================================================================


=== Source/MassRepresentation/Private/MassStationaryISMSwitcherProcessor.cpp ===
================================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassStationaryISMSwitcherProcessor.h"
#include "MassRepresentationSubsystem.h"
#include "MassCommonFragments.h"
#include "MassRepresentationProcessor.h"

#include "MassSignalSubsystem.h"


UMassStationaryISMSwitcherProcessor::UMassStationaryISMSwitcherProcessor(const FObjectInitializer& ObjectInitializer)
	: EntityQuery(*this)
{
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Representation;
	ExecutionOrder.ExecuteAfter.Add(UMassVisualizationProcessor::StaticClass()->GetFName());
	bAutoRegisterWithProcessingPhases = true;
	ExecutionFlags = static_cast<int32>(EProcessorExecutionFlags::AllNetModes);
}

void UMassStationaryISMSwitcherProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FMassRepresentationLODFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassRepresentationFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddConstSharedRequirement<FMassRepresentationParameters>();
	EntityQuery.AddSharedRequirement<FMassRepresentationSubsystemSharedFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddTagRequirement<FMassStaticRepresentationTag>(EMassFragmentPresence::All);
	EntityQuery.AddTagRequirement<FMassStationaryISMSwitcherProcessorTag>(EMassFragmentPresence::All);
	EntityQuery.AddSubsystemRequirement<UMassSignalSubsystem>(EMassFragmentAccess::ReadWrite);
}

void UMassStationaryISMSwitcherProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntityManager, Context, &UMassStationaryISMSwitcherProcessor::ProcessContext);
}
	
void UMassStationaryISMSwitcherProcessor::ProcessContext(FMassExecutionContext& Context)
{
	UMassSignalSubsystem& SignalSubsystem = Context.GetMutableSubsystemChecked<UMassSignalSubsystem>();

	UMassRepresentationSubsystem* RepresentationSubsystem = Context.GetMutableSharedFragment<FMassRepresentationSubsystemSharedFragment>().RepresentationSubsystem;
	check(RepresentationSubsystem);
	FMassInstancedStaticMeshInfoArrayView ISMInfosView = RepresentationSubsystem->GetMutableInstancedStaticMeshInfos();

	const TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();
	const TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();
	const TArrayView<FMassRepresentationFragment> RepresentationList = Context.GetMutableFragmentView<FMassRepresentationFragment>();

	const FMassRepresentationParameters& RepresentationParams = Context.GetConstSharedFragment<FMassRepresentationParameters>();
	const bool bDoKeepActorExtraFrame = UE::Mass::Representation::bAllowKeepActorExtraFrame ? RepresentationParams.bKeepLowResActors : false;

	const int32 NumEntities = Context.GetNumEntities();
	for (int32 EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
	{
		const FMassEntityHandle EntityHandle = Context.GetEntity(EntityIdx);
		const FMassRepresentationLODFragment& RepresentationLOD = RepresentationLODList[EntityIdx];
		const FTransformFragment& TransformFragment = TransformList[EntityIdx];
		FMassRepresentationFragment& Representation = RepresentationList[EntityIdx];

		if (Representation.PrevRepresentation != EMassRepresentationType::StaticMeshInstance
			&& Representation.CurrentRepresentation != EMassRepresentationType::StaticMeshInstance)
		{
			// nothing to do here
			continue;
		}

		if (!ensureMsgf(Representation.StaticMeshDescHandle.IsValid() && ISMInfosView.IsValidIndex(Representation.StaticMeshDescHandle.ToIndex())
						, TEXT("Invalid handle index %u for ISMInfosView"), Representation.StaticMeshDescHandle.ToIndex()))
		{
			continue;
		}

		FMassInstancedStaticMeshInfo& ISMInfo = ISMInfosView[Representation.StaticMeshDescHandle.ToIndex()];
		if (const bool bSwitchedAwayFromStaticMesh = (Representation.PrevRepresentation == EMassRepresentationType::StaticMeshInstance
			&& Representation.CurrentRepresentation != EMassRepresentationType::StaticMeshInstance))
		{
			// note that we're using the PrevLODSignificance here, and the reason for it is that the Prev value matches the 
			// PrevRepresentation - thus we need to remove from the "previously" used LODSignificance range.
			ISMInfo.RemoveInstance(EntityHandle, Representation.PrevLODSignificance);

			// consume "prev" data
			Representation.PrevRepresentation = Representation.CurrentRepresentation;

			if (Representation.PrevRepresentation != EMassRepresentationType::None)
			{
				SignalSubsystem.SignalEntity(UE::Mass::Signals::SwitchedToActor, EntityHandle);
			}
		}
		else if (const bool bSwitchedToStaticMesh = (Representation.PrevRepresentation != EMassRepresentationType::StaticMeshInstance
			&& Representation.CurrentRepresentation == EMassRepresentationType::StaticMeshInstance))
		{
			const FTransform& Transform = TransformFragment.GetTransform();
			const FTransform& PrevTransform = Representation.PrevTransform;
			const float LODSignificance = RepresentationLOD.LODSignificance;
			const float PrevLODSignificance = Representation.PrevLODSignificance;
				
			if (FMassLODSignificanceRange* NewRange = ISMInfo.GetLODSignificanceRange(RepresentationLOD.LODSignificance))
			{
				if (ISMInfo.ShouldUseTransformOffset())
				{
					const FTransform& TransformOffset = ISMInfo.GetTransformOffset();
					const FTransform SMTransform = TransformOffset * Transform;
					NewRange->AddInstance(EntityHandle, SMTransform);
				}
				else
				{
					NewRange->AddInstance(EntityHandle, Transform);
				}
			}

			// consume "prev" data
			// @note crazy hacky, but we don't want to consume if bDoKeepActorExtraFrame is true. In that case 
			// UMassRepresentationProcessor::UpdateRepresentation expects the "prev" state not to be consumed 
			// a frame longer so that it can do the consuming (and call "disable actor").
			if (bDoKeepActorExtraFrame == false)
			{
				Representation.PrevRepresentation = Representation.CurrentRepresentation;
			}

			SignalSubsystem.SignalEntity(UE::Mass::Signals::SwitchedToISM, EntityHandle);
		}
		else if (ISMInfo.GetLODSignificanceRangesNum() > 1 && Representation.PrevLODSignificance != RepresentationLOD.LODSignificance)
		{
			// we remain in ISM land, but LODSignificance changed and we have multiple LODSignificance ranges for this entity
			FMassLODSignificanceRange* OldRange = ISMInfo.GetLODSignificanceRange(Representation.PrevLODSignificance);
			FMassLODSignificanceRange* NewRange = ISMInfo.GetLODSignificanceRange(RepresentationLOD.LODSignificance);
			if (OldRange != NewRange)
			{
				if (OldRange)
				{
					OldRange->RemoveInstance(EntityHandle);
				}
				if (NewRange)
				{
					const FTransform& Transform = TransformFragment.GetTransform();
					NewRange->AddInstance(EntityHandle, Transform);
				}
			}
		}

		// consume "prev" data
		Representation.PrevLODSignificance = RepresentationLOD.LODSignificance;
	}
}

================================================================================


=== Source/MassRepresentation/Private/MassStationaryVisualizationTrait.cpp ===
==============================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassStationaryVisualizationTrait.h"
#include "MassEntityTemplateRegistry.h"
#include "VisualLogger/VisualLogger.h"


UMassStationaryVisualizationTrait::UMassStationaryVisualizationTrait(const FObjectInitializer& ObjectInitializer)
{
	bAllowServerSideVisualization = true;
}

void UMassStationaryVisualizationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	bool bIssuesFound = false;
	for (FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : StaticMeshInstanceDesc.Meshes)
	{
		bIssuesFound = bIssuesFound || (MeshDesc.Mobility != EComponentMobility::Stationary);
		MeshDesc.Mobility = EComponentMobility::Stationary;
	}
	UE_CVLOG_UELOG(bIssuesFound, this, LogMass, Log, TEXT("%s some Meshes' mobility has been set to non-Stationary. Theese settings will be overridden. "), *GetPathName());

	Super::BuildTemplate(BuildContext, World);

	BuildContext.AddTag<FMassStaticRepresentationTag>();
}

#if WITH_EDITOR
void UMassStationaryVisualizationTrait::PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent)
{
	static const FName StaticMeshInstanceDescName = GET_MEMBER_NAME_CHECKED(UMassStationaryVisualizationTrait, StaticMeshInstanceDesc);

	Super::PostEditChangeProperty(PropertyChangedEvent);

	if (PropertyChangedEvent.MemberProperty && PropertyChangedEvent.MemberProperty->GetFName() == StaticMeshInstanceDescName)
	{
		for (FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : StaticMeshInstanceDesc.Meshes)
		{
			MeshDesc.Mobility = EComponentMobility::Stationary;
		}
	}
}
#endif // WITH_EDITOR

==============================================================================


=== Source/MassRepresentation/Private/MassUpdateISMProcessor.cpp ===
====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassUpdateISMProcessor.h"
#include "MassVisualizationComponent.h"
#include "MassRepresentationSubsystem.h"
#include "MassEntityManager.h"
#include "MassRepresentationFragments.h"
#include "MassCommonFragments.h"
#include "MassExecutionContext.h"
#include "MassLODFragments.h"
#include "Engine/World.h"

UMassUpdateISMProcessor::UMassUpdateISMProcessor()
	: EntityQuery(*this)
{
	ExecutionFlags = (int32)(EProcessorExecutionFlags::Client | EProcessorExecutionFlags::Standalone);

	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Representation);
	bRequiresGameThreadExecution = true;
}

void UMassUpdateISMProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassRepresentationFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FMassRepresentationLODFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddChunkRequirement<FMassVisualizationChunkFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.SetChunkFilter(&FMassVisualizationChunkFragment::AreAnyEntitiesVisibleInChunk);
	EntityQuery.AddSharedRequirement<FMassRepresentationSubsystemSharedFragment>(EMassFragmentAccess::ReadWrite);

	// ignore entities configured to have their representation static (@todo maybe just check if there's not movement fragment?)
	EntityQuery.AddTagRequirement<FMassStaticRepresentationTag>(EMassFragmentPresence::None);
}

void UMassUpdateISMProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntityManager, Context, [](FMassExecutionContext& Context)
	{
		UMassRepresentationSubsystem* RepresentationSubsystem = Context.GetSharedFragment<FMassRepresentationSubsystemSharedFragment>().RepresentationSubsystem;
		check(RepresentationSubsystem);
		FMassInstancedStaticMeshInfoArrayView ISMInfo = RepresentationSubsystem->GetMutableInstancedStaticMeshInfos();

		const TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();
		const TArrayView<FMassRepresentationFragment> RepresentationList = Context.GetMutableFragmentView<FMassRepresentationFragment>();
		const TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();

		const int32 NumEntities = Context.GetNumEntities();
		for (int32 EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
		{
			const FTransformFragment& TransformFragment = TransformList[EntityIdx];
			const FMassRepresentationLODFragment& RepresentationLOD = RepresentationLODList[EntityIdx];
			FMassRepresentationFragment& Representation = RepresentationList[EntityIdx];

			if (Representation.CurrentRepresentation == EMassRepresentationType::StaticMeshInstance)
			{
				UpdateISMTransform(Context.GetEntity(EntityIdx), ISMInfo[Representation.StaticMeshDescHandle.ToIndex()], TransformFragment.GetTransform(), Representation.PrevTransform, RepresentationLOD.LODSignificance, Representation.PrevLODSignificance);
			}
			Representation.PrevTransform = TransformFragment.GetTransform();
			Representation.PrevLODSignificance = RepresentationLOD.LODSignificance;
		}
	});
}

void UMassUpdateISMProcessor::UpdateISMTransform(FMassEntityHandle EntityHandle, FMassInstancedStaticMeshInfo& ISMInfo, const FTransform& Transform, const FTransform& PrevTransform, const float LODSignificance, const float PrevLODSignificance/* = -1.0f*/)
{
	if (ISMInfo.ShouldUseTransformOffset())
	{
		const FTransform& TransformOffset = ISMInfo.GetTransformOffset();
		const FTransform SMTransform = TransformOffset * Transform;
		const FTransform SMPrevTransform = TransformOffset * PrevTransform;

		ISMInfo.AddBatchedTransform(EntityHandle, SMTransform, SMPrevTransform, LODSignificance, PrevLODSignificance);
	}
	else
	{
		ISMInfo.AddBatchedTransform(EntityHandle, Transform, PrevTransform, LODSignificance, PrevLODSignificance);
	}
}

====================================================================


=== Source/MassRepresentation/Private/MassVisualizationComponent.cpp ===
========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassVisualizationComponent.h"
#include "CoreGlobals.h"
#include "Logging/LogMacros.h"
#include "MassVisualizer.h"
#include "MassRepresentationTypes.h"
#include "Components/InstancedStaticMeshComponent.h"
#include "Engine/InstancedStaticMesh.h"
#include "Engine/CollisionProfile.h"
#include "RenderUtils.h"
#include "SceneInterface.h"
#include "Components/HierarchicalInstancedStaticMeshComponent.h"
#include "VisualLogger/VisualLogger.h"
#include "Rendering/NaniteResources.h"
#include "AI/NavigationSystemBase.h"


DECLARE_CYCLE_STAT(TEXT("Mass Visualization EndVisualChanges"), STAT_Mass_VisualizationComponent_EndVisualChanges, STATGROUP_Mass);
DECLARE_CYCLE_STAT(TEXT("Mass Visualization HandleIDs"), STAT_Mass_VisualizationComponent_HandleChangesWithExternalIDTracking, STATGROUP_Mass);

DECLARE_DWORD_COUNTER_STAT(TEXT("VisualizationComp Instances Removed"), STAT_Mass_VisualizationComponent_InstancesRemovedNum, STATGROUP_Mass);
DECLARE_DWORD_COUNTER_STAT(TEXT("VisualizationComp Instances Added"), STAT_Mass_VisualizationComponent_InstancesAddedNum, STATGROUP_Mass);

//---------------------------------------------------------------
// UMassVisualizationComponent
//---------------------------------------------------------------

namespace UE::Mass::Representation
{
	int32 GCallUpdateInstances = 1;
	FAutoConsoleVariableRef  CVarCallUpdateInstances(TEXT("Mass.CallUpdateInstances"), GCallUpdateInstances, TEXT("Toggle between UpdateInstances and BatchUpdateTransform."));

#if STATS
	uint32 LastStatsResetFrame = 0;
#endif // STATS
}  // UE::Mass::Representation

void UMassVisualizationComponent::PostInitProperties()
{
	Super::PostInitProperties();
	if (HasAnyFlags(RF_ClassDefaultObject) == false && GetOuter())
	{
		ensureMsgf(GetOuter()->GetClass()->IsChildOf(AMassVisualizer::StaticClass()), TEXT("UMassVisualizationComponent should only be added to AMassVisualizer-like instances"));
	}
}

FStaticMeshInstanceVisualizationDescHandle UMassVisualizationComponent::AddInstancedStaticMeshInfo(const FStaticMeshInstanceVisualizationDesc& Desc)
{
	FStaticMeshInstanceVisualizationDescHandle Handle;
	if (InstancedStaticMeshInfosFreeIndices.Num() > 0)
	{
		Handle = InstancedStaticMeshInfosFreeIndices.Pop(EAllowShrinking::No);
		new(&InstancedStaticMeshInfos[Handle.ToIndex()]) FMassInstancedStaticMeshInfo(Desc);
	}
	else
	{
		int32 AddedInfoIndex = InstancedStaticMeshInfos.Emplace(Desc);
		Handle = FStaticMeshInstanceVisualizationDescHandle(AddedInfoIndex);
	}

	return Handle;
}

FStaticMeshInstanceVisualizationDescHandle UMassVisualizationComponent::FindOrAddVisualDesc(const FStaticMeshInstanceVisualizationDesc& Desc)
{
	UE_MT_SCOPED_WRITE_ACCESS(InstancedStaticMeshInfosDetector);
	// First check to see if we already have a matching Desc already and reuse / return that
	// Note: FStaticMeshInstanceVisualizationDescHandle(int32) handles the INDEX_NONE case here, generating an invalid handle in this case
	FStaticMeshInstanceVisualizationDescHandle VisualDescHandle(InstancedStaticMeshInfos.IndexOfByPredicate([&Desc](const FMassInstancedStaticMeshInfo& Info) { return Info.GetDesc() == Desc; }));
	if (!VisualDescHandle.IsValid())
	{
		if (Desc.IsValid())
		{
			for (const FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : Desc.Meshes)
			{
				if (MeshDesc.Mesh && MeshDesc.ISMComponentClass)
				{
					// if we've already encountered MeshDesc in the past MeshDescToISMCMap already contains information
					// about actual ISMC used to represent it, and at the same time indicates the ISMCSharedData data
					// tied to it. Regardless we need to process all MeshDesc instances here so that we have all the 
					// data ready when InstancedSMComponentsRequiringConstructing gets processed next time
					// UMassVisualizationComponent::ConstructStaticMeshComponents gets called.
					MeshDescToISMCMap.FindOrAdd(GetTypeHash(MeshDesc), FISMCSharedDataKey());
				}
			}

			VisualDescHandle = AddInstancedStaticMeshInfo(Desc);
			check(VisualDescHandle.IsValid());

			// VisualDescHandle is a valid handle now, but there's initialization pending, performed in ConstructStaticMeshComponents
			InstancedSMComponentsRequiringConstructing.Add(VisualDescHandle);
		}
		else
		{
			UE_LOG(LogMassRepresentation, Warning, TEXT("%hs: invalid FStaticMeshInstanceVisualizationDesc passed in. Check the contained meshes."), __FUNCTION__);
		}
	}

	return VisualDescHandle;
}

FStaticMeshInstanceVisualizationDescHandle UMassVisualizationComponent::AddVisualDescWithISMComponent(const FStaticMeshInstanceVisualizationDesc& Desc, UInstancedStaticMeshComponent& ISMComponent)
{
	TObjectPtr<UInstancedStaticMeshComponent> AsObjectPtr = ISMComponent;
	return AddVisualDescWithISMComponents(Desc, MakeArrayView(&AsObjectPtr, 1));
}

FStaticMeshInstanceVisualizationDescHandle UMassVisualizationComponent::AddVisualDescWithISMComponents(const FStaticMeshInstanceVisualizationDesc& Desc, TArrayView<TObjectPtr<UInstancedStaticMeshComponent>> ISMComponents)
{
	check(Desc.Meshes.Num() == ISMComponents.Num());
	
	UE_MT_SCOPED_WRITE_ACCESS(InstancedStaticMeshInfosDetector);


	// 0. Iterate over all meshes in the visualization desc. Each mesh is a descriptor.
	FStaticMeshInstanceVisualizationDescHandle VisualHandle;
	TArray<UInstancedStaticMeshComponent*> ISMComponentsUsed;
	for (int32 EntryIndex = 0; EntryIndex < Desc.Meshes.Num(); ++EntryIndex)
	{
		const FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc = Desc.Meshes[EntryIndex];
		if (MeshDesc.Mesh == nullptr || ISMComponents[EntryIndex] == nullptr)
		{
			// invalid description, log an continue.
			UE_VLOG_UELOG(this, LogMassRepresentation, Error, TEXT("Empty mesh at index %d while registering FStaticMeshInstanceVisualizationDesc instance"), EntryIndex);
			continue;
		}
	
		// 1. Creates a VisualHandle that will be used for all ISMCs
		if (!VisualHandle.IsValid())
		{
			VisualHandle = AddInstancedStaticMeshInfo(Desc);
			check(VisualHandle.IsValid());
		}

		// 2. Stores one FMassISMCSharedData for each ISMC in ISMCSharedData
		// NOTE: FMassISMCSharedData stores a reference to an ISMC and instance transform updates performed in the current frame.
		FMassISMCSharedData& NewData = ISMCSharedData.FindOrAdd(ISMComponents[EntryIndex], FMassISMCSharedData(ISMComponents[EntryIndex], /*bInRequiresExternalInstanceIDTracking=*/true));
		// 3. Stores the newly created FMassISMCSharedData in a VisualHandle -> FMassISMCSharedData array
		// NOTE: This means that one VisualHandle may reference multiple FMassISMCSharedData
		InstancedStaticMeshInfos[VisualHandle.ToIndex()].AddISMComponent(NewData);
		// 4. Stores an ISMC -> VisualHandle map, which allows us to later on use an ISMC to query for its FMassISMCSharedData
		ISMComponentMap.Add(ISMComponents[EntryIndex], VisualHandle);

		ISMComponentsUsed.Add(ISMComponents[EntryIndex]);
	}

	if (VisualHandle.IsValid())
	{
		BuildLODSignificanceForInfo(InstancedStaticMeshInfos[VisualHandle.ToIndex()], ISMComponentsUsed);
	}

	return VisualHandle;
}

const FMassISMCSharedData* UMassVisualizationComponent::GetISMCSharedDataForDescriptionIndex(const int32 DescriptionIndex) const
{
	return ISMCSharedData.GetDataForIndex(DescriptionIndex);
}

const FMassISMCSharedData* UMassVisualizationComponent::GetISMCSharedDataForInstancedStaticMesh(const UInstancedStaticMeshComponent* ISMC) const
{
	return ISMCSharedData.GetDataForKey(ISMC);
}

void UMassVisualizationComponent::RemoveVisualDesc(const FStaticMeshInstanceVisualizationDescHandle VisualizationHandle)
{
	UE_MT_SCOPED_WRITE_ACCESS(InstancedStaticMeshInfosDetector);
	
	if (ensure(InstancedStaticMeshInfos.IsValidIndex(VisualizationHandle.ToIndex()))
		&& ensureMsgf(InstancedStaticMeshInfos[VisualizationHandle.ToIndex()].IsValid(), TEXT("Trying to remove visualization data that has already been cleaned")))
	{
		for (TObjectPtr<UInstancedStaticMeshComponent>& ISMComponent : InstancedStaticMeshInfos[VisualizationHandle.ToIndex()].InstancedStaticMeshComponents)
		{
			const bool bValidKey = ISMComponentMap.Contains(ISMComponent);
			checkf(bValidKey, TEXT("Failed to find ISMC in ISMComponentMap, path: %s"), *ISMComponent.GetPathName());
			if (bValidKey)
			{
				const FStaticMeshInstanceVisualizationDescHandle StoredVisualizationDescHandle = ISMComponentMap.FindAndRemoveChecked(ISMComponent);
				ensure(StoredVisualizationDescHandle == VisualizationHandle);
			}
		
			ISMCSharedData.Remove(ISMComponent);
		}
		
		InstancedStaticMeshInfos[VisualizationHandle.ToIndex()].Reset();
		InstancedStaticMeshInfosFreeIndices.Add(VisualizationHandle);
	}
}

void UMassVisualizationComponent::ConstructStaticMeshComponents()
{
	AActor* ActorOwner = GetOwner();
	check(ActorOwner);
	
	TArray<UInstancedStaticMeshComponent*> TransientISMCs;

	UE_MT_SCOPED_WRITE_ACCESS(InstancedStaticMeshInfosDetector);
	for (const FStaticMeshInstanceVisualizationDescHandle VisualDescHandle : InstancedSMComponentsRequiringConstructing)
	{
		if (!ensureMsgf(InstancedStaticMeshInfos.IsValidIndex(VisualDescHandle.ToIndex())
			, TEXT("InstancedStaticMeshInfos (size: %d) is never expected to shrink, so VisualDescHandle (value: %u) being invalid indicates it was wrong from the start.")
			, InstancedStaticMeshInfos.Num(), VisualDescHandle.ToIndex()))
		{
			continue;
		}

		FMassInstancedStaticMeshInfo& Info = InstancedStaticMeshInfos[VisualDescHandle.ToIndex()];

		// Check if it is already created
		if (!Info.InstancedStaticMeshComponents.IsEmpty())
		{
			continue;
		}

		// Check if there are any specified meshes for this visual type
		if(Info.Desc.Meshes.Num() == 0)
		{
			UE_LOG(LogMassRepresentation, Error, TEXT("No associated meshes for this instanced static mesh type"));
			continue;
		}

		TransientISMCs.Reset();
		for (const FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : Info.Desc.Meshes)
		{
			// MeshDescToISMCMap here lets us figure out whether for the given MeshDesc we need to create a new ISM component
			// or a one has already been created in the past. Note that we only need this intermediate map for 
			// FMassStaticMeshInstanceVisualizationMeshDesc that has been added to the system without specifying an
			// ISM component to handle the instances (i.e. added via FindOrAddVisualDesc rather than AddVisualDescWithISMComponents).
			// This is the only kind of FMassStaticMeshInstanceVisualizationMeshDesc were processing here. 
			FISMCSharedDataKey& ISMCKey = MeshDescToISMCMap.FindChecked(GetTypeHash(MeshDesc));
			FMassISMCSharedData* SharedData = ISMCSharedData.Find(ISMCKey);
			UInstancedStaticMeshComponent* ISMC = SharedData ? SharedData->GetMutableISMComponent() : nullptr;

			if (ISMC == nullptr)
			{
				ISMC = NewObject<UInstancedStaticMeshComponent>(ActorOwner, MeshDesc.ISMComponentClass);	
				CA_ASSUME(ISMC);
				REDIRECT_OBJECT_TO_VLOG(ISMC, this);

				// note that ISMCKey is a reference, so the assignment below actually sets a value in MeshDescToISMCMap
				// and all subsequent handling of a given MeshDesc configuration (i.e. containing same values) will 
				// result in referring to the ISMC we just created.
				ISMCKey = ISMC;

				ISMC->SetStaticMesh(MeshDesc.Mesh);
				for (int32 ElementIndex = 0; ElementIndex < MeshDesc.MaterialOverrides.Num(); ++ElementIndex)
				{
					if (UMaterialInterface* MaterialOverride = MeshDesc.MaterialOverrides[ElementIndex])
					{
						ISMC->SetMaterial(ElementIndex, MaterialOverride);
					}
				}
				ISMC->SetCullDistances(0, 1000000); // @todo: Need to figure out what to do here, either LOD or cull distances.
				ISMC->SetupAttachment(ActorOwner->GetRootComponent());
				ISMC->SetCanEverAffectNavigation(false);
				ISMC->SetCollisionProfileName(UCollisionProfile::NoCollision_ProfileName);
				ISMC->SetCastShadow(MeshDesc.bCastShadows);
				ISMC->Mobility = MeshDesc.Mobility;
				ISMC->SetReceivesDecals(false);
				ISMC->RegisterComponent();

				if (SharedData == nullptr)
				{
					SharedData = &ISMCSharedData.Add(ISMC, FMassISMCSharedData(ISMC));
				}
				else
				{
					SharedData->SetISMComponent(*ISMC);
				}

				ensureMsgf(ISMComponentMap.Find(ISMC) == nullptr, TEXT("We've just created the ISMC that's being used here, so this check failing indicates hash-clash."));
				ISMComponentMap.Add(ISMC, VisualDescHandle); 
			}

			TransientISMCs.Add(ISMC);

			check(SharedData);
			Info.AddISMComponent(*SharedData);
		}

		// Build the LOD significance ranges
		if (TransientISMCs.Num())
		{
			check(Info.LODSignificanceRanges.Num() == 0);
			BuildLODSignificanceForInfo(Info, TransientISMCs);
		}
	}
}

void UMassVisualizationComponent::BuildLODSignificanceForInfo(FMassInstancedStaticMeshInfo& Info, TConstArrayView<UInstancedStaticMeshComponent*> StaticMeshRefKeys)
{
	TArray<float> AllLODSignificances;
	auto UniqueInsertOrdered = [&AllLODSignificances](const float Significance)
	{
		int i = 0;
		for (; i < AllLODSignificances.Num(); ++i)
		{
			// I did not use epsilon check here on purpose, because it will make it hard later meshes inside.
			if (Significance == AllLODSignificances[i])
			{
				return;
			}
			if (AllLODSignificances[i] > Significance)
			{
				break;
			}
		}
		AllLODSignificances.Insert(Significance, i);
	};
	for (const FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc : Info.Desc.Meshes)
	{
		UniqueInsertOrdered(MeshDesc.MinLODSignificance);
		UniqueInsertOrdered(MeshDesc.MaxLODSignificance);
	}

	if (AllLODSignificances.Num() > 1)
	{
		Info.LODSignificanceRanges.SetNum(AllLODSignificances.Num() - 1);
		for (int RangeIndex = 0; RangeIndex < Info.LODSignificanceRanges.Num(); ++RangeIndex)
		{
			FMassLODSignificanceRange& Range = Info.LODSignificanceRanges[RangeIndex];
			Range.MinSignificance = AllLODSignificances[RangeIndex];
			Range.MaxSignificance = AllLODSignificances[RangeIndex + 1];
			Range.ISMCSharedDataPtr = &ISMCSharedData;

			for (int MeshIndex = 0; MeshIndex < Info.Desc.Meshes.Num(); ++MeshIndex)
			{
				const FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc = Info.Desc.Meshes[MeshIndex];
				const bool bAddMeshInRange = (Range.MinSignificance >= MeshDesc.MinLODSignificance && Range.MinSignificance < MeshDesc.MaxLODSignificance);
				if (bAddMeshInRange)
				{
					checkf(StaticMeshRefKeys.IsValidIndex(MeshIndex) && StaticMeshRefKeys[MeshIndex]
						, TEXT("We don't expect receiving null ISMCs at this point"));
					Range.StaticMeshRefs.Add(StaticMeshRefKeys[MeshIndex]);
				}
			}
		}
	}
}

void UMassVisualizationComponent::ClearAllVisualInstances()
{
	UE_MT_SCOPED_WRITE_ACCESS(InstancedStaticMeshInfosDetector);
	
	for (int32 SharedDataIndex = 0; SharedDataIndex < ISMCSharedData.Num(); ++SharedDataIndex)
	{
		if (UInstancedStaticMeshComponent* InstancedStaticMeshComponent = ISMCSharedData.GetAtIndex(SharedDataIndex).GetMutableISMComponent())
		{
			InstancedStaticMeshComponent->ClearInstances();
			InstancedStaticMeshComponent->DestroyComponent();
		}
	}

	MeshDescToISMCMap.Reset();
	ISMCSharedData.Reset();
	InstancedSMComponentsRequiringConstructing.Reset();
	InstancedStaticMeshInfos.Reset();
}

void UMassVisualizationComponent::DirtyVisuals()
{
	UE_MT_SCOPED_WRITE_ACCESS(InstancedStaticMeshInfosDetector);
	for (FMassInstancedStaticMeshInfo& Info : InstancedStaticMeshInfos)
	{
		for (UInstancedStaticMeshComponent* InstancedStaticMeshComponent : Info.InstancedStaticMeshComponents)
		{
			InstancedStaticMeshComponent->MarkRenderStateDirty();
		}
	}
}

void UMassVisualizationComponent::BeginVisualChanges()
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("MassVisualizationComponent BeginVisualChanges")

	// Conditionally construct static mesh components
	if (InstancedSMComponentsRequiringConstructing.Num())
	{
		ConstructStaticMeshComponents();
		InstancedSMComponentsRequiringConstructing.Reset();
	}
}

void UMassVisualizationComponent::HandleChangesWithExternalIDTracking(UInstancedStaticMeshComponent& ISMComponent, FMassISMCSharedData& SharedData)
{
	if (SharedData.HasUpdatesToApply() == false)
	{
		// nothing to do here. We most probably were called as the part of the very first tick of this given SharedData
		// since all the SharedData starts off as `dirty`.
		return;
	}

	SCOPE_CYCLE_COUNTER(STAT_Mass_VisualizationComponent_HandleChangesWithExternalIDTracking);

	// removing instances first, since this operation is more resilient to duplicates. Plus we make an arbitrary decision 
	// that it's better to have redundant things visible than not seeing required things
	ProcessRemoves(ISMComponent, SharedData, /*bUpdateNavigation=*/false);

	// NOTE: This code path is designed to only perform Adds, never updates so updates are filtered out along with duplicates.
	TArray<FMassEntityHandle>& EntityHandles = SharedData.UpdateInstanceIds;
	if (EntityHandles.Num())
	{
		INC_DWORD_STAT_BY(STAT_Mass_VisualizationComponent_InstancesAddedNum, EntityHandles.Num());

		FMassISMCSharedData::FEntityToPrimitiveIdMap& SharedIdMap = SharedData.GetMutableEntityPrimitiveToIdMap();
		TArray<Experimental::FHashElementId> ElementIds;
		ElementIds.SetNumUninitialized(EntityHandles.Num());
		// Filter out all updates & duplicate adds
		for (int32 IDIndex = EntityHandles.Num() - 1; IDIndex >= 0; --IDIndex)
		{
			bool bWasAlreadyInMap = false;
			Experimental::FHashElementId ElementId = SharedIdMap.FindOrAddId(EntityHandles[IDIndex], FPrimitiveInstanceId{INDEX_NONE}, bWasAlreadyInMap);

			if (bWasAlreadyInMap)
			{
				SharedData.RemoveUpdatedInstanceIdsAtSwap(IDIndex);
				ElementIds.RemoveAtSwap(IDIndex);
			}
			else
			{
				ElementIds[IDIndex] = ElementId;
			}
		}

		// it's possible the loop above removed all the data, so we do one last check
		if (!EntityHandles.IsEmpty())
		{
			check(ElementIds.Num() == EntityHandles.Num());

			const TConstArrayView<FMassEntityHandle> InstanceIds = SharedData.UpdateInstanceIds;

			const TArray<FTransform>& InstanceTransforms = SharedData.GetStaticMeshInstanceTransformsArray();
			const int32 InNumCustomDataFloats = SharedData.GetStaticMeshInstanceCustomFloats().Num();
			TConstArrayView<float> CustomFloatData = SharedData.GetStaticMeshInstanceCustomFloats();

			// if these are the first entities we're adding we need to set NumCustomDataFloats so that the PerInstanceSMCustomData
			// gets populated properly by the AddInstancesInternal call below
			const int32 StartingCount = ISMComponent.GetNumInstances();
			const bool bInitiallyEmpty = (StartingCount == 0); 
			if (StartingCount == 0 && CustomFloatData.Num() && ISMComponent.Mobility != EComponentMobility::Static)
			{
				ISMComponent.SetNumCustomDataFloats(InNumCustomDataFloats);
			}

			check(EntityHandles.Num() == InstanceTransforms.Num());
			TArray<FPrimitiveInstanceId> NewIds = ISMComponent.AddInstancesById(InstanceTransforms, /*bWorldSpace=*/true, /*bUpdateNavigation =*/bInitiallyEmpty);
			check(EntityHandles.Num() == NewIds.Num());
			for (int32 i = 0; i < EntityHandles.Num(); ++i)
			{
				SharedIdMap.GetByElementId(ElementIds[i]).Value = NewIds[i];
			}
			ensureMsgf(CustomFloatData.Num() == 0, TEXT("Custom floats not supported with this set up just yet."));
		}
	}

	if (bNavigationRelevant && ISMComponent.GetInstanceCount() == 0)
	{
		FNavigationSystem::UnregisterComponent(ISMComponent);
	}
}


void UMassVisualizationComponent::ProcessRemoves(UInstancedStaticMeshComponent& ISMComponent, FMassISMCSharedData& SharedData, const bool bUpdateNavigation /*= true*/)
{
	if (!SharedData.GetRemoveInstanceIds().IsEmpty())
	{
		FMassISMCSharedData::FEntityToPrimitiveIdMap& SharedIdMap = SharedData.GetMutableEntityPrimitiveToIdMap();
		INC_DWORD_STAT_BY(STAT_Mass_VisualizationComponent_InstancesRemovedNum, SharedData.GetRemoveInstanceIds().Num());

		TConstArrayView<FMassEntityHandle> EntityHandles = SharedData.GetRemoveInstanceIds();

		TArray<FPrimitiveInstanceId> ISMInstanceIds;
		ISMInstanceIds.Reserve(EntityHandles.Num());
		
		// Translate Mass IDs to ISMC IDs
		for (const FMassEntityHandle MassInstanceId : EntityHandles)
		{
			Experimental::FHashElementId ElementId = SharedIdMap.FindId(MassInstanceId);
			if (ElementId.IsValid())
			{
				FPrimitiveInstanceId InstanceId = SharedIdMap.GetByElementId(ElementId).Value;
				check(InstanceId.IsValid());
				SharedIdMap.RemoveByElementId(ElementId);
				ISMInstanceIds.Add(InstanceId);
			}
		}

		ISMComponent.RemoveInstancesById(ISMInstanceIds, bUpdateNavigation);
	}
}

void UMassVisualizationComponent::EndVisualChanges()
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("MassVisualizationComponent EndVisualChanges")
	SCOPE_CYCLE_COUNTER(STAT_Mass_VisualizationComponent_EndVisualChanges);

#if STATS
	if (UE::Mass::Representation::LastStatsResetFrame != GFrameNumber)
	{
		SET_DWORD_STAT(STAT_Mass_VisualizationComponent_InstancesRemovedNum, 0);
		SET_DWORD_STAT(STAT_Mass_VisualizationComponent_InstancesAddedNum, 0);
		UE::Mass::Representation::LastStatsResetFrame = GFrameNumber;
	}
#endif // STATS

	// Batch update gathered instance transforms
	for (FMassISMCSharedDataMap::FDirtyIterator It(ISMCSharedData); It; ++It)
	{
		FMassISMCSharedData& SharedData = *It;

		UInstancedStaticMeshComponent* ISMComponent = SharedData.GetMutableISMComponent();
		// @todo need to check validity this way since Mass used to rely on the assumption that all the ISM components used were
		// under its control. That's no longer the case, but the system has not been updated to take that into consideration.
		// This is a temporary fix. 
		if (IsValid(ISMComponent))
		{
			ensureMsgf(!Cast<UHierarchicalInstancedStaticMeshComponent>(ISMComponent), TEXT("The UMassVisualizationComponent does not support driving a HISM, since it is not suitable for rapid updates, replace `%s`."), *ISMComponent->GetFullName());

			if (SharedData.RequiresExternalInstanceIDTracking())
			{
				HandleChangesWithExternalIDTracking(*ISMComponent, SharedData);
				It.ClearDirtyFlag();
			}
			else
			{
				// Process all removes.
				ProcessRemoves(*ISMComponent, SharedData);

				const int32 NumCustomDataFloats = SharedData.StaticMeshInstanceCustomFloats.Num() / (FMath::Max(1, SharedData.UpdateInstanceIds.Num()));

				// Ensure InstanceCustomData is passed if NumCustomDataFloats > 0. If it is, also make sure
				// its length is NumCustomDataFloats * InstanceTransforms.Num()
				ensure(NumCustomDataFloats == 0 || (SharedData.StaticMeshInstanceCustomFloats.Num() == NumCustomDataFloats * SharedData.UpdateInstanceIds.Num()));
				ISMComponent->SetNumCustomDataFloats(NumCustomDataFloats);
				TArray<FMassEntityHandle>& EntityHandles = SharedData.UpdateInstanceIds;
				{
					// Loop over all the instances in the update and 
					// 1. Sort the data such that all Adds are last
					// 2. Remove any duplicates (unsure if they may exist)
					FMassISMCSharedData::FEntityToPrimitiveIdMap& SharedIdMap = SharedData.GetMutableEntityPrimitiveToIdMap();
					// Filter out all updates & duplicate adds
					TBitArray<> Unprocessed;
					Unprocessed.SetNum(SharedIdMap.GetMaxIndex(), true);
					// Process interval

					TConstArrayView<FTransform> PrevInstanceTransforms = SharedData.GetStaticMeshInstancePrevTransforms();
					TConstArrayView<FTransform> InstanceTransforms = SharedData.GetStaticMeshInstanceTransformsArray();
					TConstArrayView<float> CustomDataFloats = SharedData.GetStaticMeshInstanceCustomFloats();

					// Enable support for per-instance prev transforms, if it was not already enabled it will copy the current transforms.
					ISMComponent->SetHasPerInstancePrevTransforms(!PrevInstanceTransforms.IsEmpty());

					struct FAddItem
					{
						Experimental::FHashElementId ElementId;
						int32 IDIndex;
					};
					TArray<FAddItem> ToAdd;
					ToAdd.Reserve(EntityHandles.Num());
					for (int32 IDIndex = 0; IDIndex < EntityHandles.Num(); ++IDIndex)
					{
						bool bWasAlreadyInMap = false;
						Experimental::FHashElementId ElementId = SharedIdMap.FindOrAddId(EntityHandles[IDIndex], FPrimitiveInstanceId{INDEX_NONE}, bWasAlreadyInMap);

						// if it was already in the map, it may be a duplicate if we have processed it already
						bool bIsDuplicate = bWasAlreadyInMap && !Unprocessed[ElementId.GetIndex()];
						if (bIsDuplicate)
						{
							continue;
						}

						FPrimitiveInstanceId Id = SharedIdMap.GetByElementId(ElementId).Value;
						if (!Id.IsValid())
						{
							check(!bWasAlreadyInMap);
							ToAdd.Emplace(FAddItem{ElementId, IDIndex});
						}
						else
						{
							ISMComponent->UpdateInstanceTransformById(Id, InstanceTransforms[IDIndex]);
							if (!PrevInstanceTransforms.IsEmpty())
							{
								ISMComponent->SetPreviousTransformById(Id, PrevInstanceTransforms[IDIndex]);
							}
							if (!CustomDataFloats.IsEmpty())
							{
								ISMComponent->SetCustomDataById(Id, MakeArrayView(CustomDataFloats.GetData() + IDIndex * NumCustomDataFloats, NumCustomDataFloats));
							}
						}

						// Make sure we have enough space to track the already processed IDs
						Unprocessed.SetNum(SharedIdMap.GetMaxIndex(), true);
						Unprocessed[ElementId.GetIndex()] = false;
					}
					// Collect unwanted items & remove
					TArray<FPrimitiveInstanceId> RemovedISMInstanceIds;
					RemovedISMInstanceIds.Reserve(Unprocessed.Num());
					{
						for(TConstSetBitIterator<> BitIt(Unprocessed); BitIt; ++BitIt)
						{
							Experimental::FHashElementId ElementId(BitIt.GetIndex());
							if (SharedIdMap.ContainsElementId(ElementId))
							{
								FPrimitiveInstanceId InstanceId = SharedIdMap.GetByElementId(ElementId).Value;
								check(InstanceId.IsValid());
								SharedIdMap.RemoveByElementId(ElementId);
								RemovedISMInstanceIds.Add(InstanceId);
							}
						}		
						ISMComponent->RemoveInstancesById(RemovedISMInstanceIds);
					}
					// Process deferred adds.
					for (FAddItem AddItem : ToAdd)
					{
						FPrimitiveInstanceId Id = ISMComponent->AddInstanceById(InstanceTransforms[AddItem.IDIndex]);
						check(!SharedIdMap.GetByElementId(AddItem.ElementId).Value.IsValid());
						SharedIdMap.GetByElementId(AddItem.ElementId).Value = Id;

						if (!PrevInstanceTransforms.IsEmpty())
						{
							ISMComponent->SetPreviousTransformById(Id, PrevInstanceTransforms[AddItem.IDIndex]);
						}
						if (!CustomDataFloats.IsEmpty())
						{
							ISMComponent->SetCustomDataById(Id, MakeArrayView(CustomDataFloats.GetData() + AddItem.IDIndex * NumCustomDataFloats, NumCustomDataFloats));
						}

					}
					// note that we're not clearing the dirty flag on purpose - these components require constant updates
				}
			}

			// bump the touch counter so that anyone caching data based on contents of this SharedData can detect the change
			++SharedData.ComponentInstanceIdTouchCounter;
		}
		
		SharedData.ResetAccumulatedData();
	}
}

//---------------------------------------------------------------
// FMassLODSignificanceRange
//---------------------------------------------------------------

void FMassLODSignificanceRange::AddBatchedTransform(const FMassEntityHandle EntityHandle, const FTransform& Transform, const FTransform& PrevTransform, TConstArrayView<FISMCSharedDataKey> ExcludeStaticMeshRefs)
{
	check(ISMCSharedDataPtr);
	for (int32 StaticMeshIndex = 0; StaticMeshIndex < StaticMeshRefs.Num(); ++StaticMeshIndex)
	{
		if (ExcludeStaticMeshRefs.Contains(StaticMeshRefs[StaticMeshIndex]))
		{
			continue;
		}

		if (FMassISMCSharedData* SharedData = ISMCSharedDataPtr->GetAndMarkDirty(StaticMeshRefs[StaticMeshIndex]))
		{
			SharedData->UpdateInstanceIds.Add(EntityHandle);
			SharedData->StaticMeshInstanceTransforms.Add(Transform);
			SharedData->StaticMeshInstancePrevTransforms.Add(PrevTransform);
		}
	}
}

void FMassLODSignificanceRange::AddBatchedCustomDataFloats(const TArray<float>& CustomFloats, const TArray<FISMCSharedDataKey>& ExcludeStaticMeshRefs)
{
	check(ISMCSharedDataPtr);
	for (int32 StaticMeshIndex = 0; StaticMeshIndex < StaticMeshRefs.Num(); ++StaticMeshIndex)
	{
		if (ExcludeStaticMeshRefs.Contains(StaticMeshRefs[StaticMeshIndex]))
		{
			continue;
		}

		if (FMassISMCSharedData* SharedData = ISMCSharedDataPtr->GetAndMarkDirty(StaticMeshRefs[StaticMeshIndex]))
		{
			SharedData->StaticMeshInstanceCustomFloats.Append(CustomFloats);
		}
	}
}

void FMassLODSignificanceRange::AddInstance(const FMassEntityHandle EntityHandle, const FTransform& Transform)
{
	check(ISMCSharedDataPtr);
	for (int32 StaticMeshIndex = 0; StaticMeshIndex < StaticMeshRefs.Num(); ++StaticMeshIndex)
	{
		if (FMassISMCSharedData* SharedData = ISMCSharedDataPtr->GetAndMarkDirty(StaticMeshRefs[StaticMeshIndex]))
		{
			SharedData->UpdateInstanceIds.Add(EntityHandle);
			SharedData->StaticMeshInstanceTransforms.Add(Transform);
			SharedData->StaticMeshInstancePrevTransforms.Add(Transform);
		}
	}
}

void FMassLODSignificanceRange::RemoveInstance(const FMassEntityHandle EntityHandle)
{
	check(ISMCSharedDataPtr);
	for (int32 StaticMeshIndex = 0; StaticMeshIndex < StaticMeshRefs.Num(); ++StaticMeshIndex)
	{
		if (FMassISMCSharedData* SharedData = ISMCSharedDataPtr->GetAndMarkDirty(StaticMeshRefs[StaticMeshIndex]))
		{
			SharedData->RemoveInstanceIds.Add(EntityHandle);
		}
	}
}

void FMassLODSignificanceRange::WriteCustomDataFloatsAtStartIndex(int32 StaticMeshIndex, const TArrayView<float>& CustomFloats, const int32 FloatsPerInstance, const int32 StartFloatIndex, const TArray<FISMCSharedDataKey>& ExcludeStaticMeshRefs)
{
	check(ISMCSharedDataPtr);
	if (StaticMeshRefs.IsValidIndex(StaticMeshIndex))
	{
		if (ExcludeStaticMeshRefs.Contains(StaticMeshRefs[StaticMeshIndex]))
		{
			return;
		}

		if (FMassISMCSharedData* SharedData = ISMCSharedDataPtr->GetAndMarkDirty(StaticMeshRefs[StaticMeshIndex]))
		{
			const int32 StartIndex = FloatsPerInstance * SharedData->WriteIterator + StartFloatIndex;

			ensure(SharedData->StaticMeshInstanceCustomFloats.Num() >= StartIndex + CustomFloats.Num());

			for (int CustomFloatIdx = 0; CustomFloatIdx < CustomFloats.Num(); CustomFloatIdx++)
			{
				SharedData->StaticMeshInstanceCustomFloats[StartIndex + CustomFloatIdx] = CustomFloats[CustomFloatIdx];
			}
			SharedData->WriteIterator++;
		}
	}
}

//-----------------------------------------------------------------------------
// DEPRECATED
//-----------------------------------------------------------------------------
void UMassVisualizationComponent::RemoveISMComponent(UInstancedStaticMeshComponent& ISMComponent)
{
	UE_MT_SCOPED_WRITE_ACCESS(InstancedStaticMeshInfosDetector);

	const FStaticMeshInstanceVisualizationDescHandle* VisualDescHandlePtr = ISMComponentMap.Find(&ISMComponent);
	if (VisualDescHandlePtr)
	{
		RemoveVisualDesc(*VisualDescHandlePtr);
	}
}

void UMassVisualizationComponent::RemoveVisualDescByIndex(const int32 VisualizationIndex)
{
	RemoveVisualDesc(FStaticMeshInstanceVisualizationDescHandle(VisualizationIndex));
}

========================================================================


=== Source/MassRepresentation/Private/MassVisualizationLODProcessor.cpp ===
===========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassVisualizationLODProcessor.h"
#include "MassRepresentationDebug.h"
#include "MassExecutionContext.h"

UMassVisualizationLODProcessor::UMassVisualizationLODProcessor()
{
	bAutoRegisterWithProcessingPhases = false;

	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::LOD;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LODCollector);
}

void UMassVisualizationLODProcessor::ConfigureQueries()
{
	FMassEntityQuery BaseQuery;
	BaseQuery.AddTagRequirement<FMassVisualizationLODProcessorTag>(EMassFragmentPresence::All);
	BaseQuery.AddRequirement<FMassViewerInfoFragment>(EMassFragmentAccess::ReadOnly);
	BaseQuery.AddRequirement<FMassRepresentationLODFragment>(EMassFragmentAccess::ReadWrite);
	BaseQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	BaseQuery.AddConstSharedRequirement<FMassVisualizationLODParameters>();
	BaseQuery.AddSharedRequirement<FMassVisualizationLODSharedFragment>(EMassFragmentAccess::ReadWrite);

	CloseEntityQuery = BaseQuery;
	CloseEntityQuery.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::None);
	CloseEntityQuery.RegisterWithProcessor(*this);

	CloseEntityAdjustDistanceQuery = CloseEntityQuery;
	CloseEntityAdjustDistanceQuery.SetChunkFilter([](const FMassExecutionContext& Context)
	{
		const FMassVisualizationLODSharedFragment& LODSharedFragment = Context.GetSharedFragment<FMassVisualizationLODSharedFragment>();
		return LODSharedFragment.bHasAdjustedDistancesFromCount;
	});
	CloseEntityAdjustDistanceQuery.RegisterWithProcessor(*this);

	FarEntityQuery = BaseQuery;
	FarEntityQuery.AddTagRequirement<FMassVisibilityCulledByDistanceTag>(EMassFragmentPresence::All);
	FarEntityQuery.AddChunkRequirement<FMassVisualizationChunkFragment>(EMassFragmentAccess::ReadOnly);
	FarEntityQuery.SetChunkFilter(&FMassVisualizationChunkFragment::ShouldUpdateVisualizationForChunk);
	FarEntityQuery.RegisterWithProcessor(*this);

	DebugEntityQuery = BaseQuery;
	DebugEntityQuery.RegisterWithProcessor(*this);

	ProcessorRequirements.AddSubsystemRequirement<UMassLODSubsystem>(EMassFragmentAccess::ReadOnly);
}

void UMassVisualizationLODProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	if (bForceOFFLOD)
	{
		CloseEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
		{
			FMassVisualizationLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassVisualizationLODSharedFragment>();
			TArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetMutableFragmentView<FMassRepresentationLODFragment>();
			LODSharedFragment.LODCalculator.ForceOffLOD(Context, RepresentationLODList);
		});
		return;
	}

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(PrepareExecution)
		const UMassLODSubsystem& LODSubsystem = Context.GetSubsystemChecked<UMassLODSubsystem>();
		const TArray<FViewerInfo>& Viewers = LODSubsystem.GetViewers();
		EntityManager.ForEachSharedFragment<FMassVisualizationLODSharedFragment>([this, &Viewers](FMassVisualizationLODSharedFragment& LODSharedFragment)
		{
			if (FilterTag == LODSharedFragment.FilterTag)
			{
				LODSharedFragment.LODCalculator.PrepareExecution(Viewers);
			}
		});
	}

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(CalculateLOD)

		auto CalculateLOD = [this](FMassExecutionContext& Context)
		{
			FMassVisualizationLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassVisualizationLODSharedFragment>();
			TArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetMutableFragmentView<FMassRepresentationLODFragment>();
			TConstArrayView<FMassViewerInfoFragment> ViewerInfoList = Context.GetFragmentView<FMassViewerInfoFragment>();
			LODSharedFragment.LODCalculator.CalculateLOD(Context, ViewerInfoList, RepresentationLODList);
		};
		CloseEntityQuery.ForEachEntityChunk(EntityManager, Context, CalculateLOD);
		FarEntityQuery.ForEachEntityChunk(EntityManager, Context, CalculateLOD);
	}

	if (bDoAdjustmentFromCount)
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(AdjustDistanceAndLODFromCount)
		EntityManager.ForEachSharedFragment<FMassVisualizationLODSharedFragment>([this](FMassVisualizationLODSharedFragment& LODSharedFragment)
		{
			if (FilterTag == LODSharedFragment.FilterTag)
			{
				LODSharedFragment.bHasAdjustedDistancesFromCount = LODSharedFragment.LODCalculator.AdjustDistancesFromCount();
			}
		});

		CloseEntityAdjustDistanceQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
		{
			FMassVisualizationLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassVisualizationLODSharedFragment>();
			TConstArrayView<FMassViewerInfoFragment> ViewerInfoList = Context.GetFragmentView<FMassViewerInfoFragment>();
			TArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetMutableFragmentView<FMassRepresentationLODFragment>();
			LODSharedFragment.LODCalculator.AdjustLODFromCount(Context, ViewerInfoList, RepresentationLODList);
		});
		// Far entities do not need to maximize count
	}

#if WITH_MASSGAMEPLAY_DEBUG
	// Optional debug display
	if (UE::Mass::Representation::Debug::DebugRepresentationLOD == 1 || UE::Mass::Representation::Debug::DebugRepresentationLOD >= 3)
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(DebugDisplayLOD)
		UWorld* World = EntityManager.GetWorld();
		DebugEntityQuery.ForEachEntityChunk(EntityManager, Context, [World](FMassExecutionContext& Context)
		{
			FMassVisualizationLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassVisualizationLODSharedFragment>();
			TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();
			TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();
			LODSharedFragment.LODCalculator.DebugDisplaySignificantLOD(Context, RepresentationLODList, TransformList, World, UE::Mass::Representation::Debug::DebugRepresentationLODMaxSignificance);
		});
	}
	// Optional vislog
	if (UE::Mass::Representation::Debug::DebugRepresentationLOD >= 2)
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(VisLogLOD)
		DebugEntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
		{
			FMassVisualizationLODSharedFragment& LODSharedFragment = Context.GetMutableSharedFragment<FMassVisualizationLODSharedFragment>();
			TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();
			TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();
			LODSharedFragment.LODCalculator.VisLogSignificantLOD(Context, RepresentationLODList, TransformList, this, UE::Mass::Representation::Debug::DebugRepresentationLODMaxSignificance);
		});
	}
#endif // WITH_MASSGAMEPLAY_DEBUG
}

===========================================================================


=== Source/MassRepresentation/Private/MassVisualizationTrait.cpp ===
====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassVisualizationTrait.h"
#include "MassEntityTemplateRegistry.h"
#include "MassRepresentationSubsystem.h"
#include "MassCommonFragments.h"
#include "MassRepresentationFragments.h"
#include "MassRepresentationActorManagement.h"
#include "Engine/World.h"
#include "MassLODFragments.h"
#include "MassActorSubsystem.h"
#include "MassEntityUtils.h"
#include "MassVisualizationLODProcessor.h"
#include "MassRepresentationProcessor.h"
#if WITH_EDITOR
#include "Logging/MessageLog.h"
#include "Editor.h"
#include "UObject/UnrealType.h"
#endif

#define LOCTEXT_NAMESPACE "Mass"


UMassVisualizationTrait::UMassVisualizationTrait()
{
	RepresentationSubsystemClass = UMassRepresentationSubsystem::StaticClass();

	Params.RepresentationActorManagementClass = UMassRepresentationActorManagement::StaticClass();
	Params.LODRepresentation[EMassLOD::High] = EMassRepresentationType::HighResSpawnedActor;
	Params.LODRepresentation[EMassLOD::Medium] = EMassRepresentationType::LowResSpawnedActor;
	Params.LODRepresentation[EMassLOD::Low] = EMassRepresentationType::StaticMeshInstance;
	Params.LODRepresentation[EMassLOD::Off] = EMassRepresentationType::None;

	LODParams.BaseLODDistance[EMassLOD::High] = 0.f;
	LODParams.BaseLODDistance[EMassLOD::Medium] = 1000.f;
	LODParams.BaseLODDistance[EMassLOD::Low] = 2500.f;
	LODParams.BaseLODDistance[EMassLOD::Off] = 10000.f;

	LODParams.VisibleLODDistance[EMassLOD::High] = 0.f;
	LODParams.VisibleLODDistance[EMassLOD::Medium] = 2000.f;
	LODParams.VisibleLODDistance[EMassLOD::Low] = 4000.f;
	LODParams.VisibleLODDistance[EMassLOD::Off] = 10000.f;

	LODParams.LODMaxCount[EMassLOD::High] = 50;
	LODParams.LODMaxCount[EMassLOD::Medium] = 100;
	LODParams.LODMaxCount[EMassLOD::Low] = 500;
	LODParams.LODMaxCount[EMassLOD::Off] = 0;

	LODParams.BufferHysteresisOnDistancePercentage = 10.0f;
	LODParams.DistanceToFrustum = 0.0f;
	LODParams.DistanceToFrustumHysteresis = 0.0f;

	bAllowServerSideVisualization = false;
}

void UMassVisualizationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	// This should not be ran on NM_Server network mode
	if (World.IsNetMode(NM_DedicatedServer) && !bAllowServerSideVisualization 
		&& !BuildContext.IsInspectingData())
	{
		return;
	}

	BuildContext.RequireFragment<FMassViewerInfoFragment>();
	BuildContext.RequireFragment<FTransformFragment>();
	BuildContext.RequireFragment<FMassActorFragment>();

	FMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(World);

	UMassRepresentationSubsystem* RepresentationSubsystem = Cast<UMassRepresentationSubsystem>(World.GetSubsystemBase(RepresentationSubsystemClass));
	if (RepresentationSubsystem == nullptr && !BuildContext.IsInspectingData())
	{
		UE_LOG(LogMassRepresentation, Error, TEXT("Expecting a valid class for the representation subsystem"));
		RepresentationSubsystem = UWorld::GetSubsystem<UMassRepresentationSubsystem>(&World);
		check(RepresentationSubsystem);
	}

	FMassRepresentationSubsystemSharedFragment SubsystemSharedFragment;
	SubsystemSharedFragment.RepresentationSubsystem = RepresentationSubsystem;
	FSharedStruct SubsystemFragment = EntityManager.GetOrCreateSharedFragment<FMassRepresentationSubsystemSharedFragment>(SubsystemSharedFragment);
	BuildContext.AddSharedFragment(SubsystemFragment);

	if (!Params.RepresentationActorManagementClass)
	{
		UE_LOG(LogMassRepresentation, Error, TEXT("Expecting a valid class for the representation actor management"));
	}

	FMassRepresentationFragment& RepresentationFragment = BuildContext.AddFragment_GetRef<FMassRepresentationFragment>();
	if (LIKELY(BuildContext.IsInspectingData() == false))
	{
		RepresentationFragment.HighResTemplateActorIndex = HighResTemplateActor.Get() ? RepresentationSubsystem->FindOrAddTemplateActor(HighResTemplateActor.Get()) : INDEX_NONE;
		RepresentationFragment.LowResTemplateActorIndex = LowResTemplateActor.Get() ? RepresentationSubsystem->FindOrAddTemplateActor(LowResTemplateActor.Get()) : INDEX_NONE;
	}

	bool bStaticMeshDescriptionValid = StaticMeshInstanceDesc.IsValid();
	if (bStaticMeshDescriptionValid)
	{
		if (bRegisterStaticMeshDesc && !BuildContext.IsInspectingData())
		{
			RepresentationFragment.StaticMeshDescHandle = RepresentationSubsystem->FindOrAddStaticMeshDesc(StaticMeshInstanceDesc);
			ensureMsgf(RepresentationFragment.StaticMeshDescHandle.IsValid()
				, TEXT("Expected to get a valid StaticMeshDescHandle since we already checked that StaticMeshInstanceDesc is valid"));
			// if the unexpected happens and StaticMeshDescHandle is not valid we're going to treat it as if StaticMeshInstanceDesc
			// was not valid in the first place and handle it accordingly in a moment
			bStaticMeshDescriptionValid = RepresentationFragment.StaticMeshDescHandle.IsValid();
		}
	}

	FConstSharedStruct ParamsFragment;
	if (bStaticMeshDescriptionValid)
	{
		ParamsFragment = EntityManager.GetOrCreateConstSharedFragment(Params);
	}
	else
	{
		FMassRepresentationParameters ParamsCopy = Params;
		SanitizeParams(ParamsCopy, bStaticMeshDescriptionValid);
		ParamsFragment = EntityManager.GetOrCreateConstSharedFragment(ParamsCopy);
	}
	ParamsFragment.Get<const FMassRepresentationParameters>().ComputeCachedValues();
	BuildContext.AddConstSharedFragment(ParamsFragment);

	FConstSharedStruct LODParamsFragment = EntityManager.GetOrCreateConstSharedFragment(LODParams);
	BuildContext.AddConstSharedFragment(LODParamsFragment);

	FSharedStruct LODSharedFragment = EntityManager.GetOrCreateSharedFragment<FMassVisualizationLODSharedFragment>(FConstStructView::Make(LODParams), LODParams);
	BuildContext.AddSharedFragment(LODSharedFragment);

	BuildContext.AddFragment<FMassRepresentationLODFragment>();
	BuildContext.AddTag<FMassVisibilityCulledByDistanceTag>();
	BuildContext.AddChunkFragment<FMassVisualizationChunkFragment>();

	BuildContext.AddTag<FMassVisualizationLODProcessorTag>();
	BuildContext.AddTag<FMassVisualizationProcessorTag>();
}

void UMassVisualizationTrait::SanitizeParams(FMassRepresentationParameters& InOutParams, const bool bStaticMeshDeterminedInvalid) const
{
	if (bStaticMeshDeterminedInvalid || (StaticMeshInstanceDesc.IsValid() == false))
	{
		for (int32 LODIndex = 0; LODIndex < EMassLOD::Max; ++LODIndex)
		{
			if (InOutParams.LODRepresentation[LODIndex] == EMassRepresentationType::StaticMeshInstance)
			{
				InOutParams.LODRepresentation[LODIndex] = EMassRepresentationType::None;
			}
		}
	}
}

void UMassVisualizationTrait::Serialize(FArchive& Ar)
{
	Super::Serialize(Ar);

#if WITH_EDITOR
	if (GEditor && (Ar.IsLoading() || Ar.IsSaving()))
	{
		ValidateParams();
	}
#endif // WITH_EDITOR
}

bool UMassVisualizationTrait::ValidateTemplate(const FMassEntityTemplateBuildContext& BuildContext, const UWorld& World, FAdditionalTraitRequirements& OutTraitRequirements) const
{
	Super::ValidateTemplate(BuildContext, World, OutTraitRequirements);

#if WITH_EDITOR
	return ValidateParams();
#else
	return true;
#endif // WITH_EDITOR
}

#if WITH_EDITOR
bool UMassVisualizationTrait::ValidateParams() const
{
	bool bIssuesFound = false;

	// if this test is called on any of the CDOs we don't care, we're never going to utilize those in practice.
	if (HasAnyFlags(RF_ClassDefaultObject) == false)
	{
		// the SM config provided is not valid. We need to check if EMassRepresentationType::StaticMeshInstance
		// is being used as any of the LODRepresentations. If so then we need to clear those out and report an error
		if (StaticMeshInstanceDesc.IsValid() == false)
		{
			for (int32 LODIndex = 0; LODIndex < EMassLOD::Max; ++LODIndex)
			{
				if (Params.LODRepresentation[LODIndex] == EMassRepresentationType::StaticMeshInstance)
				{
					bIssuesFound = true;

					UE_LOG(LogMassRepresentation, Error, TEXT("Trait %s is using StaticMeshInstance representation type for "
						"LODRepresentation[%s] while the trait's StaticMeshInstanceDesc is not valid (has no Meshes). Entities "
						"won't be visible at this LOD level.")
						, *GetPathName(), *UEnum::GetValueAsString(EMassLOD::Type(LODIndex)));
				}
			}
		}
	}

	return !bIssuesFound;
}

void UMassVisualizationTrait::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	static const FName ParamsName = GET_MEMBER_NAME_CHECKED(UMassVisualizationTrait, Params);
	static const FName StaticMeshDescriptionName = GET_MEMBER_NAME_CHECKED(UMassVisualizationTrait, StaticMeshInstanceDesc);

	Super::PostEditChangeProperty(PropertyChangedEvent);

	if (PropertyChangedEvent.MemberProperty)
	{
		const FName PropName = PropertyChangedEvent.MemberProperty->GetFName();
		if (PropName == ParamsName || PropName == StaticMeshDescriptionName)
		{
			ValidateParams();
		}
	}
}

#endif // WITH_EDITOR

#undef LOCTEXT_NAMESPACE 

====================================================================


=== Source/MassRepresentation/Private/MassVisualizer.cpp ===
============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassVisualizer.h"
#include "MassVisualizationComponent.h"

AMassVisualizer::AMassVisualizer()
{
	RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("SceneComp"));
	RootComponent->SetMobility(EComponentMobility::Static);
	VisComponent = CreateDefaultSubobject<UMassVisualizationComponent>(TEXT("VisualizerComponent"));

	// MassVisualizers are created by the subsystems and should not be exposed to users or allowed to be deleted.
#if WITH_EDITORONLY_DATA
	bListedInSceneOutliner = false;
#endif
}


============================================================


=== Source/MassRepresentation/Public/IMassRepresentationModule.h ===
====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleInterface.h"
#include "Modules/ModuleManager.h"


/**
 * The public interface to this module.  In most cases, this interface is only public to sibling modules 
 * within this plugin.
 */
class IMassRepresentationModule : public IModuleInterface
{

public:

	/**
	 * Singleton-like access to this module's interface.  This is just for convenience!
	 * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.
	 *
	 * @return Returns singleton instance, loading the module on demand if needed
	 */
	static inline IMassRepresentationModule& Get()
	{
		return FModuleManager::LoadModuleChecked<IMassRepresentationModule>( "MassRepresentation" );
	}

	/**
	 * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.
	 *
	 * @return True if the module is loaded and ready to use
	 */
	static inline bool IsAvailable()
	{
		return FModuleManager::Get().IsModuleLoaded( "MassRepresentation" );
	}
};


====================================================================


=== Source/MassRepresentation/Public/MassDistanceLODProcessor.h ===
===================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassCommonFragments.h"
#include "MassRepresentationFragments.h"
#include "MassProcessor.h"
#include "MassLODCalculator.h"

#include "MassDistanceLODProcessor.generated.h"


/** 
 * Tag required by Distance LOD Processor to update LOD information. Removing the tag allows to support temporary 
 * disabling of processing for individual entities.
 */
USTRUCT()
struct MASSREPRESENTATION_API FMassDistanceLODProcessorTag : public FMassTag
{
	GENERATED_BODY();
};

UCLASS()
class MASSREPRESENTATION_API UMassDistanceLODProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassDistanceLODProcessor();

protected:

	/** Configure the owned FMassEntityQuery instances to express processor's requirements */
	virtual void ConfigureQueries() override;

	/** 
	 * Execution method for this processor 
	 * @param EntitySubsystem is the system to execute the lambdas on each entity chunk
	 * @param Context is the execution context to be passed when executing the lambdas
	 */
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;
	
	/**
	 * Forces Off LOD on all calculation
	 * @param bForce to whether force or not Off LOD
	 */
	void ForceOffLOD(bool bForce) { bForceOFFLOD = bForce; }

protected:
	FMassEntityQuery CloseEntityQuery;
	FMassEntityQuery FarEntityQuery;
	FMassEntityQuery DebugEntityQuery;

	bool bForceOFFLOD = false;

	UPROPERTY(Transient)
	TObjectPtr<const UScriptStruct> FilterTag = nullptr;
};
===================================================================


=== Source/MassRepresentation/Public/MassDistanceVisualizationTrait.h ===
=========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "MassEntityTraitBase.h"
#include "MassRepresentationTypes.h"
#include "MassRepresentationFragments.h"
#include "GameFramework/Actor.h"

#include "MassDistanceVisualizationTrait.generated.h"

class UMassRepresentationSubsystem;
class UMassRepresentationActorManagement;
class UMassProcessor;

/** This class has been soft-deprecated. Use MassStationaryVisualizationTrait or MassMovableVisualizationTrait */
UCLASS(meta=(DisplayName="DEPRECATED DistanceVisualization"))
class MASSREPRESENTATION_API UMassDistanceVisualizationTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()
public:
	UMassDistanceVisualizationTrait();

	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;
	virtual void DestroyTemplate(const UWorld& World) const override;

	/** Instanced static mesh information for this agent */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	mutable FStaticMeshInstanceVisualizationDesc StaticMeshInstanceDesc;

	/** Actor class of this agent when spawned in high resolution*/
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	TSubclassOf<AActor> HighResTemplateActor;

	/** Actor class of this agent when spawned in low resolution*/
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	TSubclassOf<AActor> LowResTemplateActor;

	/** Allow subclasses to override the representation subsystem to use */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual", meta = (EditCondition = "bCanModifyRepresentationSubsystemClass"))
	TSubclassOf<UMassRepresentationSubsystem> RepresentationSubsystemClass;

	/** Configuration parameters for the representation processor */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	FMassRepresentationParameters Params;

	/** Configuration parameters for the Distance LOD processor */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	FMassDistanceLODParameters LODParams;

	/** If set to true will result in the visualization-related fragments being added to server-size entities as well.
	 *  By default only the clients require visualization fragments */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	bool bAllowServerSideVisualization = false;

#if WITH_EDITORONLY_DATA
	/** the property is marked like this to ensure it won't show up in UI */
	UPROPERTY(EditDefaultsOnly, Category = "Mass|Visual")
	bool bCanModifyRepresentationSubsystemClass = true;
#endif // WITH_EDITORONLY_DATA

protected:
	/** 
	 * Controls whether StaticMeshInstanceDesc gets registered via FindOrAddStaticMeshDesc call. Setting it to `false` 
	 * can be useful for subclasses to avoid needlessly creating visualization data in RepresentationSubsystem, 
	 * data that will never be used.
	 */
	bool bRegisterStaticMeshDesc = true;
};

=========================================================================


=== Source/MassRepresentation/Public/MassMovableVisualizationTrait.h ===
========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "MassVisualizationTrait.h"
#include "MassMovableVisualizationTrait.generated.h"


UCLASS()
class MASSREPRESENTATION_API UMassMovableVisualizationTrait : public UMassVisualizationTrait
{
	GENERATED_BODY()
public:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;
};
	
========================================================================


=== Source/MassRepresentation/Public/MassRepresentationActorManagement.h ===
============================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassRepresentationActorManagement.generated.h"

struct FMassActorSpawnRequestHandle;
struct FMassCommandBuffer;
struct FMassEntityManager;
enum class EMassActorSpawnRequestAction : uint8;
enum class EMassActorEnabledType : uint8;
struct FConstStructView;
struct FMassEntityHandle;
struct FMassActorFragment;
struct FMassRepresentationLODFragment;
struct FMassRepresentationFragment;
class UMassRepresentationSubsystem;
class UMassActorSubsystem;

UCLASS()
class MASSREPRESENTATION_API UMassRepresentationActorManagement : public UObject
{
	GENERATED_BODY()

public:

	/**
	 * Returns the spawn priority from the LOD
	 * @param Representation is the type of enabling to do on this actor
	 */
	virtual float GetSpawnPriority(const FMassRepresentationLODFragment& Representation) const;

	/**
	 * Returns an actor of the template type and setup fragments values from it
	 * @param RepresentationSubsystem to use to get or spawn the actor
	 * @param EntityManager associated to the mass agent
	 * @param MassAgent is the handle to the associated mass agent
	 * @param ActorInfo is the fragment where we are going to store the actor pointer
	 * @param Transform is the spatial information about where to spawn the actor
	 * @param TemplateActorIndex is the index of the type fetched with UMassRepresentationSubsystem::FindOrAddTemplateActor()
	 * @param SpawnRequestHandle (in/out) In: previously requested spawn Out: newly requested spawn
	 * @param Priority of this spawn request in comparison with the others, lower value means higher priority
	 * @return the actor spawned
	 */
	virtual AActor* GetOrSpawnActor(UMassRepresentationSubsystem& RepresentationSubsystem, FMassEntityManager& EntityManager
		, const FMassEntityHandle MassAgent, const FTransform& Transform, const int16 TemplateActorIndex
		, FMassActorSpawnRequestHandle& InOutSpawnRequestHandle, const float Priority) const;

	/**
	 * Enable/disable a spawned actor for a mass entity
	 * @param EnabledType is the type of enabling to do on this actor
	 * @param Actor is the actual actor to perform enabling type on
	 * @param EntityIdx is the entity index currently processing
	 * @param CommandBuffer to queue up anything that is thread sensitive
	 */
	virtual void SetActorEnabled(const EMassActorEnabledType EnabledType, AActor& Actor, const int32 EntityIdx, FMassCommandBuffer& CommandBuffer) const;

	/**
	 * Teleports the actor at the specified transform by preserving its velocity and without collision.
	 * The destination will be adjusted to fit an existing capsule.
	 * @param Transform is the new actor's transform
	 * @param Actor is the actual actor to teleport
	 * @param CommandBuffer to queue up anything that is thread sensitive
	 */
	virtual void TeleportActor(const FTransform& Transform, AActor& Actor, FMassCommandBuffer& CommandBuffer) const;


	/**
	 * Method that will be bound to a delegate called before the spawning of an actor to let the requester prepare it
	 * @param SpawnRequestHandle the handle of the spawn request that is about to spawn
	 * @param SpawnRequest of the actor that is about to spawn
	 * @param EntityManager to use to retrieve the mass agent fragments
	 */
	virtual void OnPreActorSpawn(const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest, TSharedRef<FMassEntityManager> EntityManager) const;

	/**
	 * Method that will be bound to a delegate used post-spawn to notify and let the requester configure the actor
	 * @param SpawnRequestHandle the handle of the spawn request that was just spawned
	 * @param SpawnRequest of the actor that just spawned
	 * @param EntityManager to use to retrieve the mass agent fragments
	 * @return The action to take on the spawn request, either keep it there or remove it.
	 */
	virtual EMassActorSpawnRequestAction OnPostActorSpawn(const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest, TSharedRef<FMassEntityManager> EntityManager) const;

	/**
	 * Static methods to Release an actor or cancel its spawning (calls ReleaseAnyActorOrCancelAnySpawning)
	 * WARNING: This method will destroy the associated actor in any and by the same fact might also move the entity into a new archetype.
	 *          So any reference to fragment might become invalid.
	 * @param EntityManager to use to retrieve the mass agent fragments
	 * @param MassAgent is the handle to the associated mass agent
	 * @return True if actor was release or spawning request was canceled
	 */
	static void ReleaseAnyActorOrCancelAnySpawning(FMassEntityManager& EntityManager, const FMassEntityHandle MassAgent);

	/**
	 * static Release an actor or cancel its spawning
	 * WARNING: This method will destroy the associated actor in any and by the same fact might also move the entity into a new archetype.
	 *          So any reference to fragment might become invalid if you are not within the pipe execution
	 * @param RepresentationSubsystem to use to release any actors or cancel spawning requests
	 * @param MassAgent is the handle to the associated mass agent
	 * @param ActorInfo is the fragment where we are going to store the actor pointer
	 * @param Representation fragment containing the current and previous visual state
	 * @param ActorSubsystem passed over to FMassActorFragment::ResetAndUpdateHandleMap, used to avoid fetching the subsystem
	 *	from UWorld every time.
	 */
	static void ReleaseAnyActorOrCancelAnySpawning(UMassRepresentationSubsystem& RepresentationSubsystem, const FMassEntityHandle MassAgent
		, FMassActorFragment& ActorInfo, FMassRepresentationFragment& Representation, UMassActorSubsystem* ActorSubsystem = nullptr);

	UE_DEPRECATED(5.4, "This flavor of GetOrSpawnActor has been deprecated due to a defunct parameter, OutActorInfo, that was never being used.")
	virtual AActor* GetOrSpawnActor(UMassRepresentationSubsystem& RepresentationSubsystem, FMassEntityManager& EntityManager
		, const FMassEntityHandle MassAgent, FMassActorFragment&/* OutActorInfo*/, const FTransform& Transform, const int16 TemplateActorIndex
		, FMassActorSpawnRequestHandle& InOutSpawnRequestHandle, const float Priority) const final;

	UE_DEPRECATED(5.4, "This flavor of OnPreActorSpawn has been deprecated in favor of the version using TSharedPtr<FMassEntityManager> as a parameter. Use that one instead.")
	virtual void OnPreActorSpawn(const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest, FMassEntityManager* EntityManager) const final;

	UE_DEPRECATED(5.4, "This flavor of OnPostActorSpawn has been deprecated in favor of the version using TSharedPtr<FMassEntityManager> as a parameter. Use that one instead.")
	virtual EMassActorSpawnRequestAction OnPostActorSpawn(const FMassActorSpawnRequestHandle& SpawnRequestHandle, FConstStructView SpawnRequest, FMassEntityManager* EntityManager) const final;
};
============================================================================


=== Source/MassRepresentation/Public/MassRepresentationDebug.h ===
==================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassCommonTypes.h"
#include "Containers/ArrayView.h"

#if WITH_MASSGAMEPLAY_DEBUG

class UWorld;
struct FColor;
struct FMassExecutionContext;
struct FMassRepresentationFragment;
struct FMassRepresentationLODFragment;
struct FTransformFragment;

namespace UE::Mass::Representation::Debug
{
	extern MASSREPRESENTATION_API FColor RepresentationColors[];

	extern MASSREPRESENTATION_API int32 DebugRepresentation;
	extern MASSREPRESENTATION_API float DebugRepresentationMaxSignificance;

	extern MASSREPRESENTATION_API int32 DebugRepresentationLOD;
	extern MASSREPRESENTATION_API float DebugRepresentationLODMaxSignificance;

	void DebugDisplayRepresentation(FMassExecutionContext& Context, TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList, TConstArrayView<FMassRepresentationFragment> RepresentationList, TConstArrayView<FTransformFragment> LocationList, UWorld* World);

	void VisLogRepresentation(FMassExecutionContext& Context, TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList, TConstArrayView<FMassRepresentationFragment> RepresentationList, TConstArrayView<FTransformFragment> LocationList, UObject* LogOwner);
}

#endif // WITH_MASSGAMEPLAY_DEBUG

==================================================================


=== Source/MassRepresentation/Public/MassRepresentationFragments.h ===
======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassLODTypes.h"
#include "MassEntityTypes.h"
#include "MassEntityManager.h"
#include "MassActorSpawnerSubsystem.h"
#include "MassRepresentationTypes.h"
#include "MassRepresentationActorManagement.h"
#include "MassLODCalculator.h"

#include "MassRepresentationFragments.generated.h"

class UMassRepresentationSubsystem;
class UMassRepresentationActorManagement;

USTRUCT()
struct MASSREPRESENTATION_API FMassStaticRepresentationTag : public FMassTag
{
	GENERATED_BODY(); 
};

USTRUCT()
struct MASSREPRESENTATION_API FMassRepresentationLODFragment : public FMassFragment
{
	GENERATED_BODY()

	/** LOD information */
	UPROPERTY()
	TEnumAsByte<EMassLOD::Type> LOD = EMassLOD::Max;

	UPROPERTY()
	TEnumAsByte<EMassLOD::Type> PrevLOD = EMassLOD::Max;

	/** Visibility Info */
	UPROPERTY()
	EMassVisibility Visibility = EMassVisibility::Max;

	UPROPERTY()
	EMassVisibility PrevVisibility = EMassVisibility::Max;

	/** Value scaling from 0 to 3, 0 highest LOD we support and 3 being completely off LOD */
	UPROPERTY()
	float LODSignificance = 0.0f;
};

USTRUCT()
struct MASSREPRESENTATION_API FMassRepresentationFragment : public FMassFragment
{
	GENERATED_BODY()

	UPROPERTY()
	EMassRepresentationType CurrentRepresentation = EMassRepresentationType::None;

	UPROPERTY()
	EMassRepresentationType PrevRepresentation = EMassRepresentationType::None;

	UPROPERTY()
	int16 HighResTemplateActorIndex = INDEX_NONE;

	UPROPERTY()
	int16 LowResTemplateActorIndex = INDEX_NONE;

	UPROPERTY()
	FStaticMeshInstanceVisualizationDescHandle StaticMeshDescHandle;

	UPROPERTY()
	FMassActorSpawnRequestHandle ActorSpawnRequestHandle;

	UPROPERTY()
	FTransform PrevTransform;

	/** Value scaling from 0 to 3, 0 highest LOD we support and 3 being completely off LOD */
	UPROPERTY()
	float PrevLODSignificance = -1.0f;
};

USTRUCT()
struct FMassRepresentationSubsystemSharedFragment : public FMassSharedFragment
{
	GENERATED_BODY()

	UPROPERTY(Transient)
	TObjectPtr<UMassRepresentationSubsystem> RepresentationSubsystem = nullptr;
};

template<>
struct TMassSharedFragmentTraits<FMassRepresentationSubsystemSharedFragment> final
{
	enum
	{
		GameThreadOnly = true
	};
};


USTRUCT()
struct FMassRepresentationParameters : public FMassConstSharedFragment
{
	GENERATED_BODY()

	FMassRepresentationParameters() = default;

	/** Allow subclasses to override the representation actor management behavior */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual", meta = (EditCondition = "bCanModifyRepresentationActorManagementClass"))
	TSubclassOf<UMassRepresentationActorManagement> RepresentationActorManagementClass;

	/** What should be the representation of this entity for each specific LOD */
	UPROPERTY(EditAnywhere, Category = "Mass|Representation", config)
	EMassRepresentationType LODRepresentation[EMassLOD::Max] = { EMassRepresentationType::HighResSpawnedActor, EMassRepresentationType::LowResSpawnedActor, EMassRepresentationType::StaticMeshInstance, EMassRepresentationType::None };

	/** 
	 * If true, forces UMassRepresentationProcessor to override the WantedRepresentationType to actor representation whenever an external (non Mass owned)
	 * actor is set on an entitie's FMassActorFragment fragment. If / when the actor fragment is reset, WantedRepresentationType resumes selecting the 
	 * appropriate representation for the current representation LOD.
	 *
	 * Useful for server-authoritative actor spawning to force actor representation on clients for replicated actors. 
	 */ 
	UPROPERTY(EditAnywhere, Category = "Mass|Representation", config)
	uint8 bForceActorRepresentationForExternalActors : 1 = false;

	/** If true, LowRes actors will be kept around, disabled, whilst StaticMeshInstance representation is active */
	UPROPERTY(EditAnywhere, Category = "Mass|Representation", config)
	uint8 bKeepLowResActors : 1  = true;

	/** When switching to ISM keep the actor an extra frame, helps cover rendering glitches (i.e. occlusion query being one frame late) */
	UPROPERTY(EditAnywhere, Category = "Mass|Representation", config)
	uint8 bKeepActorExtraFrame : 1  = false;

	/** If true, will spread the first visualization update over the period specified in NotVisibleUpdateRate member */
	UPROPERTY(EditAnywhere, Category = "Mass|Representation", config)
	uint8 bSpreadFirstVisualizationUpdate : 1  = false;

#if WITH_EDITORONLY_DATA
	/** the property is marked like this to ensure it won't show up in UI */
	UPROPERTY(EditDefaultsOnly, Category = "Mass|Visual")
	uint8 bCanModifyRepresentationActorManagementClass : 1 = true;
#endif // WITH_EDITORONLY_DATA

	/** World Partition grid name to test collision against, default None will be the main grid */
	UPROPERTY(EditAnywhere, Category = "Mass|Representation", config)
	FName WorldPartitionGridNameContainingCollision;

	/** At what rate should the not visible entity be updated in seconds */
	UPROPERTY(EditAnywhere, Category = "Mass|Visualization", config)
	float NotVisibleUpdateRate = 0.5f;

	inline void ComputeCachedValues() const;

	/** Default representation when unable to spawn an actor, gets calculated at initialization */
	UPROPERTY(Transient)
	mutable EMassRepresentationType CachedDefaultRepresentationType = EMassRepresentationType::None;

	UPROPERTY(Transient)
	mutable TObjectPtr<UMassRepresentationActorManagement> CachedRepresentationActorManagement = nullptr;
};

template<>
struct TMassSharedFragmentTraits<FMassRepresentationParameters> final
{
	enum
	{
		GameThreadOnly = true
	};
};


inline void FMassRepresentationParameters::ComputeCachedValues() const
{
	// Calculate the default representation when actor isn't spawned yet.
	for (int32 LOD = EMassLOD::High; LOD < EMassLOD::Max; LOD++)
	{
		// Find the first representation type after any actors
		if (LODRepresentation[LOD] == EMassRepresentationType::HighResSpawnedActor ||
			LODRepresentation[LOD] == EMassRepresentationType::LowResSpawnedActor)
		{
			continue;
		}

		CachedDefaultRepresentationType = LODRepresentation[LOD];
		break;
	}

	CachedRepresentationActorManagement = RepresentationActorManagementClass.GetDefaultObject();
	if (CachedRepresentationActorManagement == nullptr)
	{
		// We should have warn about it in the traits.
		CachedRepresentationActorManagement = UMassRepresentationActorManagement::StaticClass()->GetDefaultObject<UMassRepresentationActorManagement>();
	}
}

USTRUCT()
struct FMassVisualizationLODParameters : public FMassConstSharedFragment
{
	GENERATED_BODY()

	/** Distances where each LOD becomes relevant */
	UPROPERTY(EditAnywhere, Category = "Mass|LOD", config)
	float BaseLODDistance[EMassLOD::Max] = { 0.f, 1000.f, 2500.f, 10000.f };
	UPROPERTY(EditAnywhere, Category = "Mass|LOD", config)
	float VisibleLODDistance[EMassLOD::Max] = { 0.f, 2000.f, 4000.f, 15000.f };
	UPROPERTY(EditAnywhere, Category = "Mass|LOD", meta = (ClampMin = "0.0", UIMin = "0.0"), config)
	float BufferHysteresisOnDistancePercentage = 10.0f;

	/** Maximum limit for each entity per LOD */
	UPROPERTY(EditAnywhere, Category = "Mass|LOD", config)
	int32 LODMaxCount[EMassLOD::Max] = {50, 100, 500, MAX_int32};

	/** Entities within this distance from frustum will be considered visible. Expressed in Unreal Units. */
	UPROPERTY(EditAnywhere, Category = "Mass|LOD", meta = (ClampMin = "0.0", UIMin = "0.0"), config)
	float DistanceToFrustum = 0.0f;

	/** Once visible how much further than DistanceToFrustum does the entities need to be before being cull again */
	/** 
	 * Once an entity is visible how far away from frustum does it need to get to lose "visible" state. 
	 * Expressed in Unreal Units and is added to DistanceToFrustum to arrive at the final value to be used for testing.
	 */
	UPROPERTY(EditAnywhere, Category = "Mass|LOD", meta = (ClampMin = "0.0", UIMin = "0.0"), config)
	float DistanceToFrustumHysteresis = 0.0f;

	/** Filter these settings with specified tag */
	UPROPERTY(EditAnywhere, Category = "Mass|LOD", meta = (BaseStruct = "/Script/MassEntity.MassTag"))
	TObjectPtr<UScriptStruct> FilterTag = nullptr;
};

USTRUCT()
struct FMassVisualizationLODSharedFragment : public FMassSharedFragment
{
	GENERATED_BODY()

	FMassVisualizationLODSharedFragment() = default;
	FMassVisualizationLODSharedFragment(const FMassVisualizationLODParameters& LODParams);

	TMassLODCalculator<FMassRepresentationLODLogic> LODCalculator;
	bool bHasAdjustedDistancesFromCount = false;

	UPROPERTY(Transient)
	TObjectPtr<const UScriptStruct> FilterTag = nullptr;
};

/** Simplest version of LOD Calculation based strictly on Distance parameters 
 *	Compared to FMassVisualizationLODParameters, we:
 *	* Only include a single set of LOD Distances (radial distance from viewer)
 *	* we do not care about distance to Frustum
 *	* we do not care about Max Count
 */
USTRUCT()
struct FMassDistanceLODParameters : public FMassConstSharedFragment
{
	GENERATED_BODY()

	/** Distances where each LOD becomes relevant */
	UPROPERTY(EditAnywhere, Category = "Mass|LOD", config)
	float LODDistance[EMassLOD::Max] = { 0.f, 1000.f, 2500.f, 10000.f };

	UPROPERTY(EditAnywhere, Category = "Mass|LOD", meta = (ClampMin = "0.0", UIMin = "0.0"), config)
	float BufferHysteresisOnDistancePercentage = 10.0f;

	/** Filter these settings with specified tag */
	UPROPERTY(EditAnywhere, Category = "Mass|LOD", meta = (BaseStruct = "/Script/MassEntity.MassTag"))
	TObjectPtr<UScriptStruct> FilterTag = nullptr;
};

/** Simplest version of LOD Calculation based strictly on Distance parameters 
 *	Compared to FMassVisualizationLODSharedFragment, we:
 *	* Cannot Adjust the Distance from count
 *	* We care about a MassLODCalculator with a new LOD logic that excludes Visibility computation
 */
USTRUCT()
struct FMassDistanceLODSharedFragment : public FMassSharedFragment
{
	GENERATED_BODY()

	FMassDistanceLODSharedFragment() = default;
	FMassDistanceLODSharedFragment(const FMassDistanceLODParameters& LODParams);

	TMassLODCalculator<FMassDistanceLODLogic> LODCalculator;

	UPROPERTY(Transient)
	TObjectPtr<const UScriptStruct> FilterTag = nullptr;
};

======================================================================


=== Source/MassRepresentation/Public/MassRepresentationProcessor.h ===
======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassLODFragments.h"
#include "MassRepresentationFragments.h"
#include "MassActorSpawnerSubsystem.h"
#include "MassObserverProcessor.h"

#include "MassRepresentationProcessor.generated.h"

class UMassRepresentationSubsystem;
class UMassActorSubsystem;
struct FMassActorFragment;


namespace UE::Mass::Representation
{
	extern MASSREPRESENTATION_API int32 bAllowKeepActorExtraFrame;
}

USTRUCT()
struct FMassRepresentationUpdateParams
{
	GENERATED_BODY()

	/** 
	 * Controls whether UpdateRepresentation run will ask the RepresentationSubsystem whether the relevant world 
	 * collision has been already loaded while considering switching an entity to a actor-level representation. Note that
	 * the test is unnecessary for static nor stationary entities.
	 */
	UPROPERTY(config, EditDefaultsOnly, Category = "Mass")
	bool bTestCollisionAvailibilityForActorVisualization = true;
};

UCLASS(Abstract)
class MASSREPRESENTATION_API UMassRepresentationProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassRepresentationProcessor();

	/*
	 * Update representation type for each entity, must be called within a ForEachEntityChunk
	 * @param Context of the execution from the entity sub system
	 */
	static void UpdateRepresentation(FMassExecutionContext& Context, const FMassRepresentationUpdateParams& Params);

protected:

	/** Configure the owned FMassEntityQuery instances to express processor's requirements */
	virtual void ConfigureQueries() override;

	/** 
	 * Execution method for this processor 
	 * @param EntityManager is the system to execute the lambdas on each entity chunk
	 * @param Context is the execution context to be passed when executing the lambdas
	 */
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	/**
	 * Release the actor to the subsystem, will only release it the actor or spawn request matches the template actor
	 * @param RepresentationSubsystem to use to release the actor or cancel the spawning
	 * @param MassAgent is the handle to the associated mass agent
	 * @param ActorInfo is the fragment where we are going to store the actor pointer
	 * @param TemplateActorIndex is the index of the type to release
	 * @param SpawnRequestHandle (in/out) In: previously requested spawn to cancel if any
	 * @param CommandBuffer to queue up anything that is thread sensitive
	 * @param bCancelSpawningOnly tell to only cancel the existing spawning request and to not release the associated actor it any.
	 * @return if the actor was release or the spawning was canceled.
	 */
	static bool ReleaseActorOrCancelSpawning(UMassRepresentationSubsystem& RepresentationSubsystem, UMassActorSubsystem* MassActorSubsystem
		, const FMassEntityHandle MassAgent, FMassActorFragment& ActorInfo, const int16 TemplateActorIndex, FMassActorSpawnRequestHandle& SpawnRequestHandle
		, FMassCommandBuffer& CommandBuffer, const bool bCancelSpawningOnly = false);

	FMassEntityQuery EntityQuery;

	UPROPERTY(config, EditDefaultsOnly, Category = "Mass")
	FMassRepresentationUpdateParams UpdateParams;
};

	
/**
 * Tag required by Visualization Processor to process given archetype. Removing the tag allows to support temporary
 * disabling of processing for individual entities of given archetype.
 */
USTRUCT()
struct MASSREPRESENTATION_API FMassVisualizationProcessorTag : public FMassTag
{
	GENERATED_BODY();
};

UCLASS()
class MASSREPRESENTATION_API UMassVisualizationProcessor : public UMassRepresentationProcessor
{
	GENERATED_BODY()

protected:

	/** Configure the owned FMassEntityQuery instances to express processor's requirements */
	virtual void ConfigureQueries() override;

	/**
	 * Execution method for this processor
	 * @param EntityManager is the system to execute the lambdas on each entity chunk
	 * @param Context is the execution context to be passed when executing the lambdas
	 */
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	/**
	 * Updates chunk visibility info for later chunk logic optimization
	 * @param Context of the execution from the entity sub system
	 * @return The visualization chunk fragment
	 */
	FMassVisualizationChunkFragment& UpdateChunkVisibility(FMassExecutionContext& Context) const;

	/**
	 * Updates entity visibility tag for later chunk logic optimization
	 * @param Entity of the entity to update visibility on
	 * @param Representation fragment containing the current and previous visual state
	 * @param RepresentationLOD fragment containing the visibility information
	 * @param ChunkData is the visualization chunk fragment
	 * @param CommandBuffer to queue up anything that is thread sensitive
	 */
	static void UpdateEntityVisibility(const FMassEntityHandle Entity, const FMassRepresentationFragment& Representation, const FMassRepresentationLODFragment& RepresentationLOD, FMassVisualizationChunkFragment& ChunkData, FMassCommandBuffer& CommandBuffer);

	/**
	 * Update representation and visibility for each entity, must be called within a ForEachEntityChunk
	 * @param Context of the execution from the entity sub system
	 */
	void UpdateVisualization(FMassExecutionContext& Context);
};


UCLASS()
class MASSREPRESENTATION_API UMassRepresentationFragmentDestructor : public UMassObserverProcessor
{
	GENERATED_BODY()

public:
	UMassRepresentationFragmentDestructor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};
======================================================================


=== Source/MassRepresentation/Public/MassRepresentationSubsystem.h ===
======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "GameFramework/Actor.h"
#include "MassCommonTypes.h"
#include "Misc/MTAccessDetector.h"
#include "MassRepresentationTypes.h"
#include "MassActorSpawnerSubsystem.h"
#include "MassSubsystemBase.h"
#include "MassRepresentationSubsystem.generated.h"

class UMassVisualizationComponent;
class AMassVisualizer;
struct FStaticMeshInstanceVisualizationDesc;
struct FMassInstancedStaticMeshInfo;
struct FMassActorSpawnRequestHandle;
class UMassActorSpawnerSubsystem;
class UMassAgentComponent;
struct FMassEntityManager;
enum class EMassProcessingPhase : uint8;
class UWorldPartitionSubsystem;

/**
 * Subsystem responsible for all visual of mass agents, will handle actors spawning and static mesh instances
 */
UCLASS()
class MASSREPRESENTATION_API UMassRepresentationSubsystem : public UMassSubsystemBase
{
	GENERATED_BODY()

public:
	/** 
	 * Get the index of the static mesh visual type, will add a new one if does not exist  
	 * @param Desc is the information for the static mesh that will be instantiated later via AddStaticMeshInstance()
	 * @return The index of the static mesh type 
	 */
	FStaticMeshInstanceVisualizationDescHandle FindOrAddStaticMeshDesc(const FStaticMeshInstanceVisualizationDesc& Desc);

	/**
	 * Creates a dedicated visual type described by host Desc and ties ISMComponent to it.
	 * @note this is a helper function for a common "single ISMComponent" case. Calls AddVisualDescWithISMComponents under the hood.
	 * @return The index of the visual type
	 */
	FStaticMeshInstanceVisualizationDescHandle AddVisualDescWithISMComponent(const FStaticMeshInstanceVisualizationDesc& Desc, UInstancedStaticMeshComponent& ISMComponent);

	/**
	 * Creates a dedicated visual type described by host Desc and ties given ISMComponents to it.
	 * @return The index of the visual type
	 */
	FStaticMeshInstanceVisualizationDescHandle AddVisualDescWithISMComponents(const FStaticMeshInstanceVisualizationDesc& Desc, TArrayView<TObjectPtr<UInstancedStaticMeshComponent>> ISMComponents);

	/**
	 * Fetches FMassISMCSharedData indicated by DescriptionIndex, or nullptr if it's not a valid index
	 */
	const FMassISMCSharedData* GetISMCSharedDataForDescriptionIndex(const int32 DescriptionIndex) const;

	/**
	 * Fetches FMassISMCSharedData indicated by an ISMC, or nullptr if the ISMC is not represented by any shared data.
	 */
	const FMassISMCSharedData* GetISMCSharedDataForInstancedStaticMesh(const UInstancedStaticMeshComponent* ISMC) const;

	/**
	 * Removes the visualization data associated with the given ISM component. Note that this is safe to do only when
	 * there are no entities relying on this data. No entity data patching will take place.
	 * Note that the function will assert if there's more ISM components associated with given visualization. Also, in 
	 * that case RemoveVisualDescByIndex will be called under the hood. 
	 */
	UE_DEPRECATED(5.4, "RemoveISMComponent has been deprecated in favor of RemoveVisualDescByIndex. Please use that instead.")
	void RemoveISMComponent(UInstancedStaticMeshComponent& ISMComponent);

	/** 
	 * Removes all data associated with a given VisualizationIndex. Note that this is safe to do only if there are no
	 * entities relying on this index. No entity data patching will take place.
	 */
	void RemoveVisualDesc(const FStaticMeshInstanceVisualizationDescHandle VisualizationHandle);

	/** 
	 * @return the array of all the static mesh instance component information
	 */
	FMassInstancedStaticMeshInfoArrayView GetMutableInstancedStaticMeshInfos();

	/** Mark render state of the static mesh instances dirty */
	void DirtyStaticMeshInstances();

	/** 
	 * Store the template actor uniquely and return an index to it 
	 * @param ActorClass is a template actor class we will need to spawn for an agent 
	 * @return The index of the template actor type
	 */
	int16 FindOrAddTemplateActor(const TSubclassOf<AActor>& ActorClass);

	/** 
	 * Get or spawn an actor from the TemplateActorIndex
	 * @param MassAgent is the handle to the associated mass agent
	 * @param Transform where to create this actor
	 * @param TemplateActorIndex is the index of the type fetched with FindOrAddTemplateActor()
	 * @param SpawnRequestHandle [IN/OUT] IN: previously requested spawn OUT: newly requested spawn
	 * @param Priority of this spawn request in comparison with the others, lower value means higher priority (optional)
	 * @param ActorPreSpawnDelegate is an optional delegate called before the spawning of an actor
	 * @param ActorPostSpawnDelegate is an optional delegate called once the actor is spawned
	 * @return The spawned actor from the template actor type if ready
	 */
	AActor* GetOrSpawnActorFromTemplate(const FMassEntityHandle MassAgent, const FTransform& Transform, const int16 TemplateActorIndex, FMassActorSpawnRequestHandle& InOutSpawnRequestHandle, float Priority = MAX_FLT,
		FMassActorPreSpawnDelegate ActorPreSpawnDelegate = FMassActorPreSpawnDelegate(), FMassActorPostSpawnDelegate ActorPostSpawnDelegate = FMassActorPostSpawnDelegate());

	/**
	 * Cancel spawning request that is matching the TemplateActorIndex
	 * @param MassAgent is the handle to the associated mass agent
	 * @param TemplateActorIndex is the template type of the actor to release in case it was successfully spawned
	 * @param SpawnRequestHandle [IN/OUT] previously requested spawn, gets invalidated as a result of this call.
	 * @return True if spawning request was canceled
	 */
	bool CancelSpawning(const FMassEntityHandle MassAgent, const int16 TemplateActorIndex, FMassActorSpawnRequestHandle & SpawnRequestHandle);

	/**
	 * Release an actor that is matching the TemplateActorIndex
	 * @param MassAgent is the handle to the associated mass agent
	 * @param TemplateActorIndex is the template type of the actor to release in case it was successfully spawned
	 * @param ActorToRelease is the actual actor to release if any
	 * @param bImmediate means it needs to be done immediately and not queue for later
	 * @return True if actor was released
	 */
	bool ReleaseTemplateActor(const FMassEntityHandle MassAgent, const int16 TemplateActorIndex, AActor* ActorToRelease, bool bImmediate);

	/**
	 * Release an actor or cancel its spawning if it is matching the TemplateActorIndex
	 * @param MassAgent is the handle to the associated mass agent
	 * @param TemplateActorIndex is the template type of the actor to release in case it was successfully spawned
	 * @param ActorToRelease is the actual actor to release if any
	 * @param SpawnRequestHandle [IN/OUT] previously requested spawn, gets invalidated as a result of this call.
	 * @return True if actor was released or spawning request was canceled
	 */
	bool ReleaseTemplateActorOrCancelSpawning(const FMassEntityHandle MassAgent, const int16 TemplateActorIndex, AActor* ActorToRelease, FMassActorSpawnRequestHandle& SpawnRequestHandle);


	/**
	 * Compare if an actor matches the registered template actor
	 * @param Actor to compare its class against the template
	 * @param TemplateActorIndex is the template type of the actor to compare against
	 * @return True if actor matches the template
	 */
	bool DoesActorMatchTemplate(const AActor& Actor, const int16 TemplateActorIndex) const;

	TSubclassOf<AActor> GetTemplateActorClass(const int16 TemplateActorIndex);

	bool IsCollisionLoaded(const FName TargetGrid, const FTransform& Transform) const;

	/**
	 * Responds to the FMassEntityTemplate getting destroyed, and releases reference to corresponding Actor in TemplateActors
	 */
	void ReleaseTemplate(const TSubclassOf<AActor>& ActorClass);

	/**
	 * Release all references to static meshes and template actors
	 * Use with caution, all entities using this representation subsystem must be destroy otherwise they will point to invalid resources */
	void ReleaseAllResources();

	UMassActorSpawnerSubsystem* GetActorSpawnerSubsystem() const { return ActorSpawnerSubsystem; }

protected:
	// USubsystem BEGIN
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;
	// USubsystem END

	/** Needed for batching the update of static mesh transform */
	void OnProcessingPhaseStarted(const float DeltaSeconds, const EMassProcessingPhase Phase) const;

	void OnMassAgentComponentEntityAssociated(const UMassAgentComponent& AgentComponent);
	void OnMassAgentComponentEntityDetaching(const UMassAgentComponent& AgentComponent);

	bool ReleaseTemplateActorInternal(const int16 TemplateActorIndex, AActor* ActorToRelease, bool bImmediate);
	bool CancelSpawningInternal(const int16 TemplateActorIndex, FMassActorSpawnRequestHandle& SpawnRequestHandle);

	static void AddReferencedObjects(UObject* InThis, FReferenceCollector& Collector);

protected:

	struct FTemplateActorData
	{
		TSubclassOf<AActor> Actor;
		uint32 RefCount{0u};
	};
	
	struct FTemplateActorEqualsPredicate
	{
		const TSubclassOf<AActor>& ActorClass;

		FTemplateActorEqualsPredicate(const TSubclassOf<AActor>& ActorClass) : ActorClass(ActorClass) {}

		bool operator()(const FTemplateActorData& ActorData) const
		{
			return ActorData.Actor == ActorClass;
		}
	};

	/** The array of all the template actors */
	TSparseArray<FTemplateActorData> TemplateActors;
	UE_MT_DECLARE_RW_ACCESS_DETECTOR(TemplateActorsMTAccessDetector);

	/** The component that handles all the static mesh instances */
	UPROPERTY(Transient)
	TObjectPtr<UMassVisualizationComponent> VisualizationComponent;

	/** The actor owning the above visualization component */
	UPROPERTY(Transient)
	TObjectPtr<AMassVisualizer> Visualizer;

	UPROPERTY(Transient)
	TObjectPtr<UMassActorSpawnerSubsystem> ActorSpawnerSubsystem;

	TSharedPtr<FMassEntityManager> EntityManager;

	UPROPERTY(Transient)
	TObjectPtr<UWorldPartitionSubsystem> WorldPartitionSubsystem;

	/** The time to wait before retrying a to spawn actor that failed */
	float RetryMovedDistanceSq = 1000000.0f;

	/** The distance a failed spawned actor needs to move before we retry */
	float RetryTimeInterval = 10.0f;

	/** Keeping track of all the mass agent this subsystem is responsible for spawning actors */
	TMap<FMassEntityHandle, int32> HandledMassAgents;
};

template<>
struct TMassExternalSubsystemTraits<UMassRepresentationSubsystem> final
{
	enum
	{
		GameThreadOnly = true
	};
};

======================================================================


=== Source/MassRepresentation/Public/MassRepresentationTypes.h ===
==================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassLODTypes.h"
#include "Engine/DataTable.h"
#include "Misc/MTAccessDetector.h"
#include "InstanceDataTypes.h"
#include "Experimental/Containers/RobinHoodHashTable.h"
#include "UObject/ObjectKey.h"
#include "Components/InstancedStaticMeshComponent.h"
#include "MassRepresentationTypes.generated.h"

class UMaterialInterface;
class UStaticMesh;
struct FMassLODSignificanceRange;
class UMassVisualizationComponent;

DECLARE_LOG_CATEGORY_EXTERN(LogMassRepresentation, Log, All);

namespace UE::Mass::ProcessorGroupNames
{
	const FName Representation = FName(TEXT("Representation"));
}

using FISMCSharedDataKey = TObjectKey<UInstancedStaticMeshComponent>;

UENUM()
enum class EMassRepresentationType : uint8
{
	HighResSpawnedActor,
	LowResSpawnedActor,
	StaticMeshInstance,
	None,
};

enum class EMassActorEnabledType : uint8
{
	Disabled,
	LowRes,
	HighRes,
};

USTRUCT()
struct MASSREPRESENTATION_API FMassStaticMeshInstanceVisualizationMeshDesc
{
	GENERATED_BODY()

	FMassStaticMeshInstanceVisualizationMeshDesc();
	
	/** The static mesh visual representation */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	TObjectPtr<UStaticMesh> Mesh = nullptr;

	/**
	 * Material overrides for the static mesh visual representation. 
	 * 
	 * Array indices correspond to material slot indices on the static mesh.
	 */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	TArray<TObjectPtr<UMaterialInterface>> MaterialOverrides;

	/** The minimum inclusive LOD significance to start using this static mesh */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	float MinLODSignificance = float(EMassLOD::High);

	/** The maximum exclusive LOD significance to stop using this static mesh */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	float MaxLODSignificance = float(EMassLOD::Max);

	/** Controls whether the ISM can cast shadow or not */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	bool bCastShadows = false;
	
	/** Controls the mobility of the ISM */
	EComponentMobility::Type Mobility = EComponentMobility::Movable;

	/** InstancedStaticMeshComponent class to use to manage instances described by this struct instance */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	TSubclassOf<UInstancedStaticMeshComponent> ISMComponentClass;

	bool operator==(const FMassStaticMeshInstanceVisualizationMeshDesc& Other) const
	{
		return Mesh == Other.Mesh && 
			MaterialOverrides == Other.MaterialOverrides && 
			FMath::IsNearlyEqual(MinLODSignificance, Other.MinLODSignificance, KINDA_SMALL_NUMBER) &&
			FMath::IsNearlyEqual(MaxLODSignificance, Other.MaxLODSignificance, KINDA_SMALL_NUMBER) &&
			bCastShadows == Other.bCastShadows && 
			Mobility == Other.Mobility;
	}
	
	friend FORCEINLINE uint32 GetTypeHash(const FMassStaticMeshInstanceVisualizationMeshDesc& MeshDesc)
	{
		uint32 Hash = 0x0;
		Hash = PointerHash(MeshDesc.Mesh, Hash);
		Hash = HashCombine(GetTypeHash(MeshDesc.bCastShadows), Hash);
		Hash = HashCombine(GetTypeHash(MeshDesc.Mobility), Hash);
		for (UMaterialInterface* MaterialOverride : MeshDesc.MaterialOverrides)
		{
			if (MaterialOverride)
			{
				Hash = PointerHash(MaterialOverride, Hash);
			}
		}
		return Hash;
	}

	// convenience function for setting MinLODSinificance and MaxLODSinificance based on EMassLOD values
	void SetSignificanceRange(const EMassLOD::Type MinLOD, const EMassLOD::Type MaxLOD)
	{
		checkSlow(MinLOD <= MaxLOD);
		MinLODSignificance = float(MinLOD);
		MaxLODSignificance = float(MaxLOD);
	}
};

USTRUCT()
struct FStaticMeshInstanceVisualizationDesc : public FTableRowBase
{
	GENERATED_BODY()

	/** 
	 * Mesh descriptions. These will be instanced together using the same transform for each, to 
	 * visualize the given agent.
	 */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	TArray<FMassStaticMeshInstanceVisualizationMeshDesc> Meshes;

	/** Boolean to enable code to transform the static meshes if not align the mass agent transform */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	bool bUseTransformOffset = false;

	/** Transform to offset the static meshes if not align the mass agent transform */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual", meta=(EditCondition="bUseTransformOffset"))
	FTransform TransformOffset;

	bool operator==(const FStaticMeshInstanceVisualizationDesc& Other) const
	{
		return Meshes == Other.Meshes;
	}

	void Reset()
	{
		new(this)FStaticMeshInstanceVisualizationDesc();
	}

	/** @return whether any of descriptions in Meshes is valid. This implies that empty Meshes will be treated as not valid.*/
	bool IsValid() const;
};

/** Handle for FStaticMeshInstanceVisualizationDesc's registered with UMassRepresentationSubsystem */
USTRUCT()
struct alignas(2) FStaticMeshInstanceVisualizationDescHandle
{
	GENERATED_BODY()

	static constexpr uint16 InvalidIndex = TNumericLimits<uint16>::Max();

	FStaticMeshInstanceVisualizationDescHandle() = default;

	explicit FStaticMeshInstanceVisualizationDescHandle(uint16 InIndex)
	: Index(InIndex)
	{}

	explicit FStaticMeshInstanceVisualizationDescHandle(int32 InIndex) 
	{
		// Handle special case INDEX_NONE = InvalidIndex
		if (InIndex == INDEX_NONE)
		{
			Index = InvalidIndex;
		}
		else
		{
			checkf(InIndex < static_cast<int32>(InvalidIndex), TEXT("Visualization description index InIndex %d is out of expected bounds (< %u)"), InIndex, InvalidIndex);
			Index = static_cast<uint16>(InIndex);
		}
	}

	FORCEINLINE int32 ToIndex() const
	{
		return IsValid() ? Index : INDEX_NONE;
	}

	bool IsValid() const
	{
		return Index != InvalidIndex;
	}

	bool operator==(const FStaticMeshInstanceVisualizationDescHandle& Other) const = default;

	UE_DEPRECATED(5.4, "Referring to registered FStaticMeshInstanceVisualizationDesc's by raw int16 index has been deprecated. Please use strictly typed FStaticMeshInstanceVisualizationDescHandle instead.")
	operator int16() const
	{
		if (!IsValid())
		{
			return INDEX_NONE;
		}
		return ensure(Index < TNumericLimits<int16>::Max()) ? static_cast<int16>(Index) : INDEX_NONE; 
	}

private:

	UPROPERTY()
	uint16 Index = InvalidIndex;

	// @todo: Add a version / serial number to protect against recycled handle reuse. Leaving this out for now to keep size down due to 
	// prevalent use in FMassRepresentationFragment. Perhaps serial number could be formed from the referenced 
	// FStaticMeshInstanceVisualizationDesc's hash.
};
static_assert(sizeof(FStaticMeshInstanceVisualizationDescHandle) == sizeof(uint16), "FStaticMeshInstanceVisualizationDescHandle must be uint16 sized to ensure FMassRepresentationFragment memory isn't unexpectedly bloated");

class UInstancedStaticMeshComponent;


struct MASSREPRESENTATION_API FMassISMCSharedData
{
PRAGMA_DISABLE_DEPRECATION_WARNINGS
	FMassISMCSharedData() 
		: bRequiresExternalInstanceIDTracking(false)
	{		
	}

	explicit FMassISMCSharedData(UInstancedStaticMeshComponent* InISMC, bool bInRequiresExternalInstanceIDTracking = false)
		: ISMC(InISMC), bRequiresExternalInstanceIDTracking(bInRequiresExternalInstanceIDTracking)
	{
	}

	FMassISMCSharedData(const FMassISMCSharedData& Other) = default;
	FMassISMCSharedData& operator=(const FMassISMCSharedData& Other) = default;
PRAGMA_ENABLE_DEPRECATION_WARNINGS

	void SetISMComponent(UInstancedStaticMeshComponent& InISMC)
	{
		check(ISMC == nullptr && ISMComponentReferencesCount == 0);
		ISMC = &InISMC;
	}

	UInstancedStaticMeshComponent* GetMutableISMComponent() { return ISMC; }
	const UInstancedStaticMeshComponent* GetISMComponent() const { return ISMC; }
	int32 OnISMComponentReferenceStored() { return ++ISMComponentReferencesCount; }
	int32 OnISMComponentReferenceReleased() { ensure(ISMComponentReferencesCount >= 0); return --ISMComponentReferencesCount; }

	void ResetAccumulatedData()
	{
		UpdateInstanceIds.Reset();
		StaticMeshInstanceCustomFloats.Reset();
		StaticMeshInstanceTransforms.Reset();
		StaticMeshInstancePrevTransforms.Reset();
		RemoveInstanceIds.Reset();
		WriteIterator = 0;
	}

	void RemoveUpdatedInstanceIdsAtSwap(const int32 InstanceIDIndex)
	{
		UpdateInstanceIds.RemoveAtSwap(InstanceIDIndex, EAllowShrinking::No);
		StaticMeshInstanceTransforms.RemoveAtSwap(InstanceIDIndex, EAllowShrinking::No);
		StaticMeshInstancePrevTransforms.RemoveAtSwap(InstanceIDIndex, EAllowShrinking::No);
		if (StaticMeshInstanceCustomFloats.Num())
		{
			StaticMeshInstanceCustomFloats.RemoveAtSwap(InstanceIDIndex, EAllowShrinking::No);
		}
	}

	bool HasUpdatesToApply() const { return UpdateInstanceIds.Num() || RemoveInstanceIds.Num(); }
	TConstArrayView<FMassEntityHandle> GetUpdateInstanceIds() const { return UpdateInstanceIds; }
	TConstArrayView<FTransform> GetStaticMeshInstanceTransforms() const { return StaticMeshInstanceTransforms; }
	/** 
	 * this function is a flavor we need to interact with older engine API that's using TArray references. 
	 * Use GetStaticMeshInstanceTransforms instead whenever possible. 
	 */
	const TArray<FTransform>& GetStaticMeshInstanceTransformsArray() const { return StaticMeshInstanceTransforms; }
	TConstArrayView<FTransform> GetStaticMeshInstancePrevTransforms() const { return StaticMeshInstancePrevTransforms; }
	TConstArrayView<FMassEntityHandle> GetRemoveInstanceIds() const { return RemoveInstanceIds; }
	TConstArrayView<float> GetStaticMeshInstanceCustomFloats() const { return StaticMeshInstanceCustomFloats; }
	
	bool RequiresExternalInstanceIDTracking() const { return bRequiresExternalInstanceIDTracking; }

	void Reset() 
	{
		*this = FMassISMCSharedData();
	}

	using FEntityToPrimitiveIdMap = Experimental::TRobinHoodHashMap<FMassEntityHandle, FPrimitiveInstanceId>;

	FEntityToPrimitiveIdMap& GetMutableEntityPrimitiveToIdMap() { return EntityHandleToPrimitiveIdMap; }
	const FEntityToPrimitiveIdMap& GetEntityPrimitiveToIdMap() const { return EntityHandleToPrimitiveIdMap; }

	int16 GetComponentInstanceIdTouchCounter() const { return ComponentInstanceIdTouchCounter; }

protected:
	friend FMassLODSignificanceRange;
	friend UMassVisualizationComponent;
	/** Buffer holding current frame transforms for the static mesh instances, used to batch update the transforms */
	TArray<FMassEntityHandle> UpdateInstanceIds;
	TArray<FTransform> StaticMeshInstanceTransforms;
	TArray<FTransform> StaticMeshInstancePrevTransforms;
	TArray<FMassEntityHandle> RemoveInstanceIds;

	/** Buffer holding current frame custom floats for the static mesh instances, used to batch update the ISMs custom data */
	TArray<float> StaticMeshInstanceCustomFloats;

	// When initially adding to StaticMeshInstanceCustomFloats, can use the size as the write iterator, but on subsequent processors, we need to know where to start writing
	int32 WriteIterator = 0;

	UInstancedStaticMeshComponent* ISMC = nullptr;
	int32 ISMComponentReferencesCount = 0;

	/** 
	 * When set to true will result in MassVisualizationComponent manually perform Instance ID-related operations 
	 * instead of relying on ISMComponent's internal ID operations. 
	 * @note this mechanism has been added in preparation of changes to ISM component to change access to its internal 
	 *	instance ID logic. WIP as of Jun 17th 2023 
	 */
	uint8 bRequiresExternalInstanceIDTracking : 1;
	
private:
	/** Indicates that mutating changes, that can affect MassInstanceIdToComponentInstanceIdMap, have been performed.
	 *	Can be used to validate whether cached data stored in other placed needs to be re-cached. */
	uint16 ComponentInstanceIdTouchCounter = 0;

protected:
	FEntityToPrimitiveIdMap EntityHandleToPrimitiveIdMap;

	UE_DEPRECATED(5.4, "RefCount is deprecated, use ISMComponentReferencesCount instead")
	int32 RefCount = 0;

public:
	UE_DEPRECATED(5.4, "StoreReference is deprecated, use OnISMComponentReferenceStored instead")
	int32 StoreReference() { return OnISMComponentReferenceStored(); }
	UE_DEPRECATED(5.4, "ReleaseReference is deprecated, use OnISMComponentReferenceReleased instead")
	int32 ReleaseReference() { return OnISMComponentReferenceReleased(); }
};


/** 
 * The container type hosting FMassISMCSharedData instances and supplying functionality of marking entries that require 
 * instance-related operations (adding, removing). 
 * 
 * To get a FMassISMCSharedData instance to add operations to it call GetAndMarkDirty.
 * 
 * Use FDirtyIterator to iterate over just the data that needs processing. 
 * 
 * @see UMassVisualizationComponent::EndVisualChanges for iteration
 * @see FMassLODSignificanceRange methods for performing dirtying operations
 */
struct FMassISMCSharedDataMap
{
	struct FDirtyIterator
	{
		friend FMassISMCSharedDataMap;
		explicit FDirtyIterator(FMassISMCSharedDataMap& InContainer)
			: Container(InContainer), It(InContainer.GetDirtyArray())
		{
			if (It && It.GetValue() != bValueToCheck)
			{
				// will result in either setting IT to the first bInValue, or making bool(It) == false
				++(*this);
			}
		}
	public:
		operator bool() const { return bool(It); }

		FDirtyIterator& operator++()
		{
			while (++It)
			{
				if (It.GetValue() == bValueToCheck)
				{
					break;
				}
			}
			return *this;
		}

		FMassISMCSharedData& operator*() const
		{
			return Container.GetAtIndex(It.GetIndex());
		}

		void ClearDirtyFlag()
		{
			It.GetValue() = false;
		}

	private:
		FMassISMCSharedDataMap& Container;
		TBitArray<>::FIterator It;
		static constexpr bool bValueToCheck = true;
	};

	FMassISMCSharedData& GetAndMarkDirtyChecked(const FISMCSharedDataKey OwnerKey)
	{
		const int32 DataIndex = Map[OwnerKey];
		DirtyData[DataIndex] = true;
		return Data[DataIndex];
	}

	FMassISMCSharedData* GetAndMarkDirty(const FISMCSharedDataKey OwnerKey)
	{
		const int32* DataIndex = Map.Find(OwnerKey);
		if (ensureMsgf(DataIndex, TEXT("%hs Failed to find OwnerKey %u"), __FUNCTION__, *GetNameSafe(OwnerKey.ResolveObjectPtrEvenIfGarbage())))
		{
			DirtyData[*DataIndex] = true;
			return &Data[*DataIndex];
		}
		return nullptr;
	}
	
	template<typename... TArgs>
	FMassISMCSharedData& FindOrAdd(const FISMCSharedDataKey OwnerKey, TArgs&&... InNewInstanceArgs)
	{
		const int32* DataIndex = Map.Find(OwnerKey);
		if (DataIndex == nullptr)
		{
			return Add(OwnerKey, Forward<TArgs>(InNewInstanceArgs)...);
		}
		check(Data.IsValidIndex(*DataIndex));
		return Data[*DataIndex];
	}

	FMassISMCSharedData* Find(const FISMCSharedDataKey OwnerKey)
	{
		int32* DataIndex = Map.Find(OwnerKey);
		return (DataIndex == nullptr || *DataIndex == INDEX_NONE) ? (FMassISMCSharedData*)nullptr : &Data[*DataIndex];
	}

	template<typename... TArgs>
	FMassISMCSharedData& Add(const FISMCSharedDataKey OwnerKey, TArgs&&... InNewInstanceArgs)
	{
		const int32 DataIndex = FreeIndices.Num() ? FreeIndices.Pop() : Data.Num();
		Map.Add(OwnerKey, DataIndex);

		if (DataIndex == Data.Num())
		{
			DirtyData.Add(false, DataIndex - DirtyData.Num() + 1);
			DirtyData[DataIndex] = true;
			return Data.Add_GetRef(FMassISMCSharedData(Forward<TArgs>(InNewInstanceArgs)...));
		}
		else
		{
			DirtyData[DataIndex] = true;
			Data[DataIndex] = FMassISMCSharedData(Forward<TArgs>(InNewInstanceArgs)...);
			return Data[DataIndex];
		}
	}

	void Remove(const FISMCSharedDataKey OwnerKey)
	{
		int32 DataIndex = INDEX_NONE;
		if (ensure(Map.RemoveAndCopyValue(OwnerKey, DataIndex)))
		{
			DirtyData[DataIndex] = false;
			Data[DataIndex].Reset();
			FreeIndices.Add(DataIndex);
		}
	}

	FMassISMCSharedData& GetAtIndex(const int32 DataIndex)
	{
		return Data[DataIndex];
	}
	
	TBitArray<>& GetDirtyArray()
	{ 
		return DirtyData;
	}

	/** @return total number of entries in Data array. Note that some or all entries could be empty (i.e. already freed) */
	int32 Num() const
	{
		return Data.Num();
	}

	/** @return number of non-empty entries in Data. */
	int32 NumValid() const
	{
		return Data.Num() - FreeIndices.Num();
	}

	bool IsDirty(const int32 DataIndex) const
	{
		return DirtyData[DataIndex];
	}

	bool IsEmpty() const
	{
		return NumValid() == 0;
	}

	void Reset()
	{
		*this = FMassISMCSharedDataMap();
	}

	const FMassISMCSharedData* GetDataForIndex(const int32 Index) const
	{
		return Data.IsValidIndex(Index) ? &Data[Index] : nullptr;
	}

	const FMassISMCSharedData* GetDataForKey(const FISMCSharedDataKey Key) const
	{
		const int32* Index = Map.Find(Key);
		return (Index && Data.IsValidIndex(*Index))
			? &Data[*Index]
			: nullptr;
	}

protected:
	TArray<FMassISMCSharedData> Data;
	/** Mapping from Owner (as FObjectKey) of data represented by FMassISMCSharedData to an index to Data */
	TMap<FISMCSharedDataKey, int32> Map;
	/** Indicates whether corresponding Data entry has any instance work assigned to it (instance addition or removal) */
	TBitArray<> DirtyData;
	/** Indices to Data that are available for reuse */
	TArray<int32> FreeIndices;

public:
	UE_DEPRECATED(5.5, "Deprecated. Using hashes in Mass Visualization is being phased out. Use FISMCSharedDataKey instead.")
	FMassISMCSharedData& GetAndMarkDirtyChecked(const uint32 Hash);
	UE_DEPRECATED(5.5, "Deprecated. Using hashes in Mass Visualization is being phased out. Use FISMCSharedDataKey instead.")
	FMassISMCSharedData* GetAndMarkDirty(const uint32 Hash);	
	template<typename... TArgs>
	UE_DEPRECATED(5.5, "Deprecated. Using hashes in Mass Visualization is being phased out. Use FISMCSharedDataKey instead.")
	FMassISMCSharedData& FindOrAdd(const uint32 Hash, TArgs&&... InNewInstanceArgs);
	UE_DEPRECATED(5.5, "Deprecated. Using hashes in Mass Visualization is being phased out. Use FISMCSharedDataKey instead.")
	FMassISMCSharedData* Find(const uint32 Hash);
	template<typename... TArgs>
	UE_DEPRECATED(5.5, "Deprecated. Using hashes in Mass Visualization is being phased out. Use FISMCSharedDataKey instead.")
	FMassISMCSharedData& Add(const uint32 Hash, TArgs&&... InNewInstanceArgs);
	UE_DEPRECATED(5.5, "Deprecated. Using hashes in Mass Visualization is being phased out. Use FISMCSharedDataKey instead.")
	void Remove(const uint32 Hash);
};


USTRUCT()
struct MASSREPRESENTATION_API FMassLODSignificanceRange
{
	GENERATED_BODY()
public:

	void AddBatchedTransform(const FMassEntityHandle EntityHandle, const FTransform& Transform, const FTransform& PrevTransform, TConstArrayView<FISMCSharedDataKey> ExcludeStaticMeshRefs);

	// Adds the specified struct reinterpreted as custom floats to our custom data. Individual members of the specified struct should always fit into a float.
	// When adding any custom data, the custom data must be added for every instance.
	template<typename InCustomDataType>
	void AddBatchedCustomData(InCustomDataType InCustomData, const TArray<FISMCSharedDataKey>& ExcludeStaticMeshRefs, int32 NumFloatsToPad = 0)
	{
		check(ISMCSharedDataPtr);
		static_assert((sizeof(InCustomDataType) % sizeof(float)) == 0, "AddBatchedCustomData: InCustomDataType should have a total size multiple of sizeof(float), and have members that fit in a float's boundaries");
		const size_t StructSize = sizeof(InCustomDataType);
		const size_t StructSizeInFloats = StructSize / sizeof(float);
		for (int i = 0; i < StaticMeshRefs.Num(); i++)
		{
			if (ExcludeStaticMeshRefs.Contains(StaticMeshRefs[i]))
			{
				continue;
			}

			FMassISMCSharedData& SharedData = (*ISMCSharedDataPtr).GetAndMarkDirtyChecked(StaticMeshRefs[i]);
			const int32 StartIndex = SharedData.StaticMeshInstanceCustomFloats.AddDefaulted(StructSizeInFloats + NumFloatsToPad);
			InCustomDataType* CustomData = reinterpret_cast<InCustomDataType*>(&SharedData.StaticMeshInstanceCustomFloats[StartIndex]);
			*CustomData = InCustomData;
		}
	}

	void AddBatchedCustomDataFloats(const TArray<float>& CustomFloats, const TArray<FISMCSharedDataKey>& ExcludeStaticMeshRefs);

	/** Single-instance version of AddBatchedCustomData when called to add entities (as opposed to modify existing ones).*/
	void AddInstance(const FMassEntityHandle EntityHandle, const FTransform& Transform);

	void RemoveInstance(const FMassEntityHandle EntityHandle);

	void WriteCustomDataFloatsAtStartIndex(int32 StaticMeshIndex, const TArrayView<float>& CustomFloats, const int32 FloatsPerInstance, const int32 StartIndex, const TArray<FISMCSharedDataKey>& ExcludeStaticMeshRefs);

	/** LOD Significance range */
	float MinSignificance;
	float MaxSignificance;

	/** The component handling these instances */
	TArray<FISMCSharedDataKey> StaticMeshRefs;

	FMassISMCSharedDataMap* ISMCSharedDataPtr = nullptr;

	//-----------------------------------------------------------------------------
	// DEPRECATED
	//-----------------------------------------------------------------------------
	UE_DEPRECATED(5.4, "Deprecated in favor of new version taking FMassEntityHandle parameter instead of int32 to identify the entity. This deprecated function is now defunct.")
	void AddBatchedTransform(const int32 InstanceId, const FTransform& Transform, const FTransform& PrevTransform, const TArray<uint32>& ExcludeStaticMeshRefs) {}
	UE_DEPRECATED(5.4, "Deprecated in favor of new version taking FMassEntityHandle parameter instead of int32 to identify the entity. This deprecated function is now defunct.")
	void AddInstance(const int32 InstanceId, const FTransform& Transform) {}
	UE_DEPRECATED(5.4, "Deprecated in favor of new version taking FMassEntityHandle parameter instead of int32 to identify the entity. This deprecated function is now defunct.")
	void RemoveInstance(const int32 InstanceId) {}

};

USTRUCT()
struct MASSREPRESENTATION_API FMassInstancedStaticMeshInfo
{
	GENERATED_BODY()
public:

	FMassInstancedStaticMeshInfo() = default;

	explicit FMassInstancedStaticMeshInfo(const FStaticMeshInstanceVisualizationDesc& InDesc)
		: Desc(InDesc)
	{
	}

	/** Clears out contents so that a given FMassInstancedStaticMeshInfo instance can be reused */
	void Reset();

	const FStaticMeshInstanceVisualizationDesc& GetDesc() const
	{
		return Desc;
	}

	/** Whether or not to transform the static meshes if not align the mass agent transform */
	bool ShouldUseTransformOffset() const { return Desc.bUseTransformOffset; }
	FTransform GetTransformOffset() const { return Desc.TransformOffset; }

	FORCEINLINE FMassLODSignificanceRange* GetLODSignificanceRange(float LODSignificance)
	{
		for (FMassLODSignificanceRange& Range : LODSignificanceRanges)
		{
			if (LODSignificance >= Range.MinSignificance && LODSignificance < Range.MaxSignificance)
			{
				return &Range;
			}
		}
		return nullptr;
	}

	void AddBatchedTransform(const FMassEntityHandle EntityHandle, const FTransform& Transform, const FTransform& PrevTransform, const float LODSignificance, const float PrevLODSignificance = -1.0f)
	{
		if (FMassLODSignificanceRange* Range = GetLODSignificanceRange(LODSignificance))
		{
			Range->AddBatchedTransform(EntityHandle, Transform, PrevTransform, {});
			if(PrevLODSignificance >= 0.0f)
			{
				FMassLODSignificanceRange* PrevRange = GetLODSignificanceRange(PrevLODSignificance);
				if (ensureMsgf(PrevRange, TEXT("Couldn't find a valid LODSignificanceRange for PrevLODSignificance %f"), PrevLODSignificance)
					&& PrevRange != Range)
				{
					PrevRange->AddBatchedTransform(EntityHandle, Transform, PrevTransform, Range->StaticMeshRefs);
				}
			}
		}
	}

	FORCEINLINE void RemoveInstance(const FMassEntityHandle EntityHandle, const float LODSignificance)
	{
		if (FMassLODSignificanceRange* Range = GetLODSignificanceRange(LODSignificance))
		{
			Range->RemoveInstance(EntityHandle);
		}
	}

	// Adds the specified struct reinterpreted as custom floats to our custom data. Individual members of the specified struct should always fit into a float.
	// When adding any custom data, the custom data must be added for every instance.
	template<typename InCustomDataType>
	void AddBatchedCustomData(InCustomDataType InCustomData, const float LODSignificance, const float PrevLODSignificance = -1.0f, int32 NumFloatsToPad = 0)
	{
		if (FMassLODSignificanceRange* Range = GetLODSignificanceRange(LODSignificance))
		{
			Range->AddBatchedCustomData(InCustomData, {}, NumFloatsToPad);
			if(PrevLODSignificance >= 0.0f)
			{
				FMassLODSignificanceRange* PrevRange = GetLODSignificanceRange(PrevLODSignificance);
				if (ensureMsgf(PrevRange, TEXT("Couldn't find a valid LODSignificanceRange for PrevLODSignificance %f"), PrevLODSignificance)
					&& PrevRange != Range)
				{
					PrevRange->AddBatchedCustomData(InCustomData, Range->StaticMeshRefs, NumFloatsToPad);
				}
			}
		}
	}

	FORCEINLINE void AddBatchedCustomDataFloats(const TArray<float>& CustomFloats, const float LODSignificance, const float PrevLODSignificance = -1.0f)
	{
		if (FMassLODSignificanceRange* Range = GetLODSignificanceRange(LODSignificance))
		{
			Range->AddBatchedCustomDataFloats(CustomFloats, {});
			if(PrevLODSignificance >= 0.0f)
			{
				FMassLODSignificanceRange* PrevRange = GetLODSignificanceRange(PrevLODSignificance);
				if (ensureMsgf(PrevRange, TEXT("Couldn't find a valid LODSignificanceRange for PrevLODSignificance %f"), PrevLODSignificance)
					&& PrevRange != Range)
				{
					PrevRange->AddBatchedCustomDataFloats(CustomFloats, Range->StaticMeshRefs);
				}
			}
		}
	}

	void WriteCustomDataFloatsAtStartIndex(int32 StaticMeshIndex, const TArrayView<float>& CustomFloats, const float LODSignificance, const int32 FloatsPerInstance, const int32 FloatStartIndex, const float PrevLODSignificance = -1.0f)
	{
		if (FMassLODSignificanceRange* Range = GetLODSignificanceRange(LODSignificance))
		{
			Range->WriteCustomDataFloatsAtStartIndex(StaticMeshIndex, CustomFloats, FloatsPerInstance, FloatStartIndex, {});
			if(PrevLODSignificance >= 0.0f)
			{
				FMassLODSignificanceRange* PrevRange = GetLODSignificanceRange(PrevLODSignificance);
				if (ensureMsgf(PrevRange, TEXT("Couldn't find a valid LODSignificanceRange for PrevLODSignificance %f"), PrevLODSignificance)
					&& PrevRange != Range)
				{
					PrevRange->WriteCustomDataFloatsAtStartIndex(StaticMeshIndex, CustomFloats, FloatsPerInstance, FloatStartIndex, Range->StaticMeshRefs);
				}
			}
		}
	}

	void AddISMComponent(FMassISMCSharedData& SharedData)
	{
		if (ensure(SharedData.GetISMComponent()))
		{
			InstancedStaticMeshComponents.Add(SharedData.GetMutableISMComponent());
			SharedData.OnISMComponentReferenceStored();
		}
	}

	int32 GetLODSignificanceRangesNum() const { return LODSignificanceRanges.Num(); }

	bool IsValid() const
	{
		return Desc.Meshes.Num() && InstancedStaticMeshComponents.Num() && LODSignificanceRanges.Num();
	}

protected:

	/** Destroy the visual instance */
	void ClearVisualInstance(UInstancedStaticMeshComponent& ISMComponent);

	/** Information about this static mesh which will represent all instances */
	UPROPERTY(VisibleAnywhere, Category = "Mass/Debug")
	FStaticMeshInstanceVisualizationDesc Desc;

	/** The components handling these instances */
	UPROPERTY(VisibleAnywhere, Category = "Mass/Debug")
	TArray<TObjectPtr<UInstancedStaticMeshComponent>> InstancedStaticMeshComponents;

	UPROPERTY(VisibleAnywhere, Category = "Mass/Debug")
	TArray<FMassLODSignificanceRange> LODSignificanceRanges;

	friend class UMassVisualizationComponent;

	//-----------------------------------------------------------------------------
	// DEPRECATED
	//-----------------------------------------------------------------------------
	UE_DEPRECATED(5.5, "Deprecated in flavor of the function taking the ISMComponent parameter. This version is not defunct")
	void ClearVisualInstance(FMassISMCSharedDataMap& ISMCSharedData) {}
public:
	UE_DEPRECATED(5.4, "Deprecated in flavor of new version taking FMassEntityHandle parameter instead of int32 to identify the entity. This deprecated function is now defunct.")
	void AddBatchedTransform(const int32 InstanceId, const FTransform& Transform, const FTransform& PrevTransform, const float LODSignificance, const float PrevLODSignificance = -1.0f) {}
	UE_DEPRECATED(5.4, "Deprecated in flavor of new version taking FMassEntityHandle parameter instead of int32 to identify the entity. This deprecated function is now defunct.")
	void RemoveInstance(const int32 InstanceId, const float LODSignificance) {}
};

#if ENABLE_MT_DETECTOR

#define MAKE_MASS_INSTANCED_STATIC_MESH_INFO_ARRAY_VIEW(ArrayView, AccessDetector) FMassInstancedStaticMeshInfoArrayView(ArrayView, AccessDetector)
struct FMassInstancedStaticMeshInfoArrayViewAccessDetector
{
	FMassInstancedStaticMeshInfoArrayViewAccessDetector(TArrayView<FMassInstancedStaticMeshInfo> InInstancedStaticMeshInfos, const FRWRecursiveAccessDetector& InAccessDetector)
		: InstancedStaticMeshInfos(InInstancedStaticMeshInfos)
		, AccessDetector(&InAccessDetector)
	{
		UE_MT_ACQUIRE_WRITE_ACCESS(*AccessDetector);
	}

	FMassInstancedStaticMeshInfoArrayViewAccessDetector(FMassInstancedStaticMeshInfoArrayViewAccessDetector&& Other)
		: InstancedStaticMeshInfos(Other.InstancedStaticMeshInfos)
		, AccessDetector(Other.AccessDetector)
	{
		Other.AccessDetector = nullptr;
	}
	FMassInstancedStaticMeshInfoArrayViewAccessDetector(const FMassInstancedStaticMeshInfoArrayViewAccessDetector& Other) = delete;
	void operator=(const FMassInstancedStaticMeshInfoArrayViewAccessDetector& Other) = delete;

	~FMassInstancedStaticMeshInfoArrayViewAccessDetector()
	{
		if(AccessDetector)
		{
			UE_MT_RELEASE_WRITE_ACCESS(*AccessDetector);
		}
	}

	FORCEINLINE FMassInstancedStaticMeshInfo& operator[](int32 Index) const
	{
		return InstancedStaticMeshInfos[Index];
	}

	bool IsValidIndex(const int32 Index) const
	{
		return InstancedStaticMeshInfos.IsValidIndex(Index);
	}

private:
	TArrayView<FMassInstancedStaticMeshInfo> InstancedStaticMeshInfos;
	const FRWRecursiveAccessDetector* AccessDetector;
};

typedef FMassInstancedStaticMeshInfoArrayViewAccessDetector FMassInstancedStaticMeshInfoArrayView;

#else // ENABLE_MT_DETECTOR

#define MAKE_MASS_INSTANCED_STATIC_MESH_INFO_ARRAY_VIEW(ArrayView, AccessDetector) ArrayView

typedef TArrayView<FMassInstancedStaticMeshInfo> FMassInstancedStaticMeshInfoArrayView;

#endif // ENABLE_MT_DETECTOR

//-----------------------------------------------------------------------------
// DEPRECATED
//-----------------------------------------------------------------------------

template<typename... TArgs>
FMassISMCSharedData& FMassISMCSharedDataMap::FindOrAdd(const uint32 Hash, TArgs&&... InNewInstanceArgs)
{
	static FMassISMCSharedData Dummy;
	return Dummy;
}

template<typename... TArgs>
FMassISMCSharedData& FMassISMCSharedDataMap::Add(const uint32 Hash, TArgs&&... InNewInstanceArgs)
{
	static FMassISMCSharedData Dummy;
	return Dummy;
}

==================================================================


=== Source/MassRepresentation/Public/MassRepresentationUtils.h ===
==================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "MassEntityManager.h"
#include "MassCommonTypes.h"
#include "MassRepresentationTypes.h"
#include "MassLODFragments.h"

struct FMassCommandBuffer;

namespace UE::Mass::Representation
{

inline EMassVisibility GetVisibilityFromArchetype(const FMassExecutionContext& Context)
{
	if (Context.DoesArchetypeHaveTag<FMassVisibilityCanBeSeenTag>())
	{
		return EMassVisibility::CanBeSeen;
	}
	if (Context.DoesArchetypeHaveTag<FMassVisibilityCulledByFrustumTag>())
	{
		return EMassVisibility::CulledByFrustum;
	}
	if (Context.DoesArchetypeHaveTag<FMassVisibilityCulledByDistanceTag>())
	{
		return EMassVisibility::CulledByDistance;
	}
	return EMassVisibility::Max;
}

template <EMassVisibility Level>
struct TMassVisibilityTagForLevel
{
	typedef FMassTag FTag;
};

template<>
struct TMassVisibilityTagForLevel<EMassVisibility::CanBeSeen>
{
	typedef FMassVisibilityCanBeSeenTag FTag;
};

template<>
struct TMassVisibilityTagForLevel<EMassVisibility::CulledByFrustum>
{
	typedef FMassVisibilityCulledByFrustumTag FTag;
};

template<>
struct TMassVisibilityTagForLevel<EMassVisibility::CulledByDistance>
{
	typedef FMassVisibilityCulledByDistanceTag FTag;
};

inline const UScriptStruct* GetTagFromVisibility(EMassVisibility Visibility)
{
	switch (Visibility)
	{
		case EMassVisibility::CanBeSeen:
			return TMassVisibilityTagForLevel<EMassVisibility::CanBeSeen>::FTag::StaticStruct();
		case EMassVisibility::CulledByFrustum:
			return TMassVisibilityTagForLevel<EMassVisibility::CulledByFrustum>::FTag::StaticStruct();
		case EMassVisibility::CulledByDistance:
			return TMassVisibilityTagForLevel<EMassVisibility::CulledByDistance>::FTag::StaticStruct();
		default:
			checkf(false, TEXT("Unsupported visibility Type"));
		case EMassVisibility::Max:
			return nullptr;
	}
}

inline bool IsVisibilityTagSet(const FMassExecutionContext& Context, EMassVisibility Visibility)
{
	switch (Visibility)
	{
		case EMassVisibility::CanBeSeen:
			return Context.DoesArchetypeHaveTag<FMassVisibilityCanBeSeenTag>();
		case EMassVisibility::CulledByFrustum:
			return Context.DoesArchetypeHaveTag<FMassVisibilityCulledByFrustumTag>();
		case EMassVisibility::CulledByDistance:
			return Context.DoesArchetypeHaveTag<FMassVisibilityCulledByDistanceTag>();
		default:
			checkf(false, TEXT("Unsupported visibility Type"));
		case EMassVisibility::Max:
			return false;
	}
}

void PushSwapTagsCommand(FMassCommandBuffer& CommandBuffer, const FMassEntityHandle Entity, const EMassVisibility PrevVisibility, const EMassVisibility NewVisibility);

} // UE::Mass::Representation
==================================================================


=== Source/MassRepresentation/Public/MassStationaryDistanceVisualizationTrait.h ===
===================================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "MassDistanceVisualizationTrait.h"
#include "MassStationaryDistanceVisualizationTrait.generated.h"


UCLASS()
class MASSREPRESENTATION_API UMassStationaryDistanceVisualizationTrait : public UMassDistanceVisualizationTrait
{
	GENERATED_BODY()
public:
	UMassStationaryDistanceVisualizationTrait(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;

protected:
#if WITH_EDITOR
	virtual void PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent) override;
#endif // WITH_EDITOR
};

===================================================================================


=== Source/MassRepresentation/Public/MassStationaryISMRepresentationFragmentDestructor.h ===
============================================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "MassObserverProcessor.h"
#include "MassStationaryISMRepresentationFragmentDestructor.generated.h"


/** 
 * This class is responsible for cleaning up ISM instances visualizing stationary entities
 */
UCLASS()
class MASSREPRESENTATION_API UMassStationaryISMRepresentationFragmentDestructor : public UMassObserverProcessor
{
	GENERATED_BODY()
public:
	UMassStationaryISMRepresentationFragmentDestructor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};

============================================================================================


=== Source/MassRepresentation/Public/MassStationaryISMSwitcherProcessor.h ===
=============================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "MassProcessor.h"
#include "MassStationaryISMSwitcherProcessor.generated.h"


struct FMassExecutionContext;

namespace UE::Mass::Signals
{
	const FName SwitchedToActor = FName(TEXT("SwitchedToActor"));
	const FName SwitchedToISM = FName(TEXT("SwitchedToISM"));
}

/**
 * Tag required by UMassStationaryISMSwitcherProcessor to process given archetype. Removing the tag allows to support temporary
 * disabling of processing for individual entities of given archetype.
 */
USTRUCT()
struct MASSREPRESENTATION_API FMassStationaryISMSwitcherProcessorTag : public FMassTag
{
	GENERATED_BODY();
};

/** 
 * This processor's sole responsibility is to process all entities tagged with FMassStaticRepresentationTag
 * and check if they've switched to or away from EMassRepresentationType::StaticMeshInstance; and acordingly add or remove 
 * the entity from the appropriate FMassInstancedStaticMeshInfoArrayView.
 */
UCLASS()
class MASSREPRESENTATION_API UMassStationaryISMSwitcherProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassStationaryISMSwitcherProcessor(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	static void ProcessContext(FMassExecutionContext& Context);

protected:
	// UMassProcessor overrides begin
	virtual void ConfigureQueries() override;
	// UMassProcessor overrides end
	// 
	// UMassRepresentationProcessor overrides begin
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;
	// UMassRepresentationProcessor overrides end

	FMassEntityQuery EntityQuery;
};

=============================================================================


=== Source/MassRepresentation/Public/MassStationaryVisualizationTrait.h ===
===========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "MassVisualizationTrait.h"
#include "MassStationaryVisualizationTrait.generated.h"


UCLASS()
class MASSREPRESENTATION_API UMassStationaryVisualizationTrait : public UMassVisualizationTrait
{
	GENERATED_BODY()
public:
	UMassStationaryVisualizationTrait(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;

protected:
#if WITH_EDITOR
	virtual void PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent) override;
#endif // WITH_EDITOR
};

===========================================================================


=== Source/MassRepresentation/Public/MassUpdateISMProcessor.h ===
=================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassProcessor.h"

#include "MassUpdateISMProcessor.generated.h"

class UMassRepresentationSubsystem;

struct FMassInstancedStaticMeshInfo;

UCLASS()
class MASSREPRESENTATION_API UMassUpdateISMProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassUpdateISMProcessor();

	static void UpdateISMTransform(FMassEntityHandle EntityHandle, FMassInstancedStaticMeshInfo& ISMInfo, const FTransform& Transform, const FTransform& PrevTransform, const float LODSignificance, const float PrevLODSignificance = -1.0f);

	UE_DEPRECATED(5.4, "Deprecated in favor of new version taking FMassEntityHandle parameter instead of int32 to identify the entity. This deprecated function is now defunct.")
	static void UpdateISMTransform(int32 EntityId, FMassInstancedStaticMeshInfo& ISMInfo, const FTransform& Transform, const FTransform& PrevTransform, const float LODSignificance, const float PrevLODSignificance = -1.0f) {}


protected:

	/** Configure the owned FMassEntityQuery instances to express processor's requirements */
	virtual void ConfigureQueries() override;

	/**
	 * Execution method for this processor
	 * @param EntitySubsystem is the system to execute the lambdas on each entity chunk
	 * @param Context is the execution context to be passed when executing the lambdas */
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};
=================================================================


=== Source/MassRepresentation/Public/MassVisualizationComponent.h ===
=====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassRepresentationTypes.h"
#include "MassCommonTypes.h"
#include "Components/ActorComponent.h"
#include "MassRepresentationTypes.h"
#include "Misc/MTAccessDetector.h"

#include "MassVisualizationComponent.generated.h"


class UInstancedStaticMeshComponent;

/** 
 * This component handles all the static mesh instances for a MassRepresentationProcessor and is an actor component off a MassVisualizer actor.
 * Meant to be created at runtime and owned by an MassVisualizer actor. Will ensure if placed on a different type of actor. 
 */
UCLASS()
class MASSREPRESENTATION_API UMassVisualizationComponent : public UActorComponent
{
	GENERATED_BODY()
public:

	/** 
	 * Get the index of the visual type, will add a new one if does not exist
	 * @param Desc is the information for the visual that will be instantiated later via AddVisualInstance()
	 * @return The index of the visual type 
	 */
	FStaticMeshInstanceVisualizationDescHandle FindOrAddVisualDesc(const FStaticMeshInstanceVisualizationDesc& Desc);

	/** 
	 * Creates a dedicated visual type described by host Desc and ties ISMComponent to it.
	 * @note this is a helper function for a common "single ISMComponent" case. Calls AddVisualDescWithISMComponents under the hood.
	 * @return The index of the visual type 
	 */
	FStaticMeshInstanceVisualizationDescHandle AddVisualDescWithISMComponent(const FStaticMeshInstanceVisualizationDesc& Desc, UInstancedStaticMeshComponent& ISMComponent);

	/**
	 * Creates a dedicated visual type described by host Desc and ties given ISMComponents to it.
	 * @return The index of the visual type
	 */
	FStaticMeshInstanceVisualizationDescHandle AddVisualDescWithISMComponents(const FStaticMeshInstanceVisualizationDesc& Desc, TArrayView<TObjectPtr<UInstancedStaticMeshComponent>> ISMComponents);

	/**
	 * Fetches FMassISMCSharedData indicated by DescriptionIndex, or nullptr if it's not a valid index
	 */
	const FMassISMCSharedData* GetISMCSharedDataForDescriptionIndex(const int32 DescriptionIndex) const;

	/**
	 * Fetches FMassISMCSharedData indicated by an ISMC, or nullptr if the ISMC is not represented by any shared data.
	 */
	const FMassISMCSharedData* GetISMCSharedDataForInstancedStaticMesh(const UInstancedStaticMeshComponent* ISMC) const;

	/** 
	 * Removes all the visualization data associated with the given ISM component. The function resolves the VisualizationIndex
	 * associated with the given ISMComponent and calls RemoveVisualDescByIndex which will remove data on all ISMComponents
	 * associated with the index. Note that this is safe to do only when there are no entities relying on this data. 
	 * No entity data patching will take place. 
	 */
	UE_DEPRECATED(5.4, "RemoveISMComponent has been deprecated in favor of RemoveVisualDesc. Please use that instead.")
	void RemoveISMComponent(UInstancedStaticMeshComponent& ISMComponent);

	/**
	 * Removes all data associated with a given VisualizationIndex. Note that this is safe to do only if there are no
	 * entities relying on this index. No entity data patching will take place.
	 */
	UE_DEPRECATED(5.4, "RemoveVisualDescByIndex has been deprecated in favor of RemoveVisualDesc. Please use that instead.")
	void RemoveVisualDescByIndex(const int32 VisualizationIndex);

	/**
	 * Removes all data associated with a given VisualizationIndex. Note that this is safe to do only if there are no
	 * entities relying on this index. No entity data patching will take place.
	 */
	void RemoveVisualDesc(const FStaticMeshInstanceVisualizationDescHandle VisualizationHandle);

	/** Get the array of all visual instance informations */
	FMassInstancedStaticMeshInfoArrayView GetMutableVisualInfos()
	{
		FMassInstancedStaticMeshInfoArrayView View = MAKE_MASS_INSTANCED_STATIC_MESH_INFO_ARRAY_VIEW(MakeArrayView(InstancedStaticMeshInfos), InstancedStaticMeshInfosDetector);
		return MoveTemp(View);
	}

	/** Destroy all visual instances */
 	void ClearAllVisualInstances();

	/** Dirty render state on all static mesh components */
 	void DirtyVisuals();

	/** Signal the beginning of the static mesh instance changes, used to prepare the batching update of the static mesh instance transforms*/
	void BeginVisualChanges();

	/** Signal the end of the static mesh instance changes, used to batch apply the transforms on the static mesh instances*/
	void EndVisualChanges();

protected:
	/**
	 * Process all removed IDs in FMassISMCSharedData and apply to the ISM component.
	 */
	void ProcessRemoves(UInstancedStaticMeshComponent& ISMComponent, FMassISMCSharedData& SharedData, bool bUpdateNavigation = true);
	
	/** 
	 * Applies changes accumulated in SharedData while manually updating the Instance ID mapping. This approach is done in preparation 
	 * to upcoming ISM changes to keep the mapping management more secure (by making mapping private and fully component-owned).
	 */
	void HandleChangesWithExternalIDTracking(UInstancedStaticMeshComponent& ISMComponent, FMassISMCSharedData& SharedData);

	/** Recreate all the static mesh components from the InstancedStaticMeshInfos */
	void ConstructStaticMeshComponents();

	/** Overridden to make sure this component is only added to a MassVisualizer actor */
	virtual void PostInitProperties() override;

	/**
	 * Creates LODSignificance ranges for all the meshes indicated by Info
	 * @param ForcedStaticMeshRefKeys if not empty will be used when adding individual FMassStaticMeshInstanceVisualizationMeshDesc
	 *	instances to LOD significance ranges.
	 */	
	void BuildLODSignificanceForInfo(FMassInstancedStaticMeshInfo& Info, TConstArrayView<UInstancedStaticMeshComponent*> StaticMeshRefKeys);

	/** Either adds an element to InstancedStaticMeshInfos or reuses an existing entry based on InstancedStaticMeshInfosFreeIndices*/
	FStaticMeshInstanceVisualizationDescHandle AddInstancedStaticMeshInfo(const FStaticMeshInstanceVisualizationDesc& Desc);

	/** The information of all the instanced static meshes. Make sure to use AddInstancedStaticMeshInfo to add elements to it */
	UPROPERTY(Transient)
	TArray<FMassInstancedStaticMeshInfo> InstancedStaticMeshInfos;
	UE_MT_DECLARE_RW_RECURSIVE_ACCESS_DETECTOR(InstancedStaticMeshInfosDetector);

	/** Indices to InstancedStaticMeshInfos that have been released and can be reused */
	TArray<FStaticMeshInstanceVisualizationDescHandle> InstancedStaticMeshInfosFreeIndices;

	/** Mapping from ISMComponent (indicated by FISMCSharedDataKey) to corresponding VisualDescHandle */
	TMap<FISMCSharedDataKey, FStaticMeshInstanceVisualizationDescHandle> ISMComponentMap;

	FMassISMCSharedDataMap ISMCSharedData;

	/** 
	 * Mapping FMassStaticMeshInstanceVisualizationMeshDesc hash to FMassISMCSharedData entries for all FMassStaticMeshInstanceVisualizationMeshDesc
	 * that didn't come with ISMC explicitly provided. Used only for initialization.
	 * Note that FMassStaticMeshInstanceVisualizationMeshDesc that were added with ISMComponents provided directly
	 * (via AddVisualDescWithISMComponents call) will never make it to this map.
	 */
	TMap<uint32, FISMCSharedDataKey> MeshDescToISMCMap;

	/** Indicies to InstancedStaticMeshInfos that need their SMComponent constructed */
	TArray<FStaticMeshInstanceVisualizationDescHandle> InstancedSMComponentsRequiringConstructing;

	UE_DEPRECATED(5.4, "This flavor of BuildLODSignificanceForInfo is no longer supported and is defunct.")
	void BuildLODSignificanceForInfo(FMassInstancedStaticMeshInfo& Info, const uint32 ForcedStaticMeshRefKey){}

	UE_DEPRECATED(5.5, "This flavor of BuildLODSignificanceForInfo is no longer supported and is defunct.")
	void BuildLODSignificanceForInfo(FMassInstancedStaticMeshInfo& Info) {}
};

=====================================================================


=== Source/MassRepresentation/Public/MassVisualizationLODProcessor.h ===
========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassCommonFragments.h"
#include "MassRepresentationFragments.h"
#include "MassProcessor.h"
#include "MassLODCalculator.h"

#include "MassVisualizationLODProcessor.generated.h"


/** 
 * Tag required by Visualization LOD Processor to update LOD information. Removing the tag allows to support temporary 
 * disabling of processing for individual entities.
 */
USTRUCT()
struct MASSREPRESENTATION_API FMassVisualizationLODProcessorTag : public FMassTag
{
	GENERATED_BODY();
};

UCLASS()
class MASSREPRESENTATION_API UMassVisualizationLODProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassVisualizationLODProcessor();

protected:

	/** Configure the owned FMassEntityQuery instances to express processor's requirements */
	virtual void ConfigureQueries() override;

	/** 
	 * Execution method for this processor 
	 * @param EntitySubsystem is the system to execute the lambdas on each entity chunk
	 * @param Context is the execution context to be passed when executing the lambdas
	 */
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;
	
	/**
	 * Forces Off LOD on all calculation
	 * @param bForce to whether force or not Off LOD
	 */
	void ForceOffLOD(bool bForce) { bForceOFFLOD = bForce; }

protected:
	FMassEntityQuery CloseEntityQuery;
	FMassEntityQuery CloseEntityAdjustDistanceQuery;
	FMassEntityQuery FarEntityQuery;
	FMassEntityQuery DebugEntityQuery;

	bool bForceOFFLOD = false;

	UPROPERTY(Transient)
	TObjectPtr<const UScriptStruct> FilterTag = nullptr;

	UPROPERTY(config, EditDefaultsOnly, Category = "Mass")
	bool bDoAdjustmentFromCount = true;
};
========================================================================


=== Source/MassRepresentation/Public/MassVisualizationTrait.h ===
=================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "MassEntityTraitBase.h"
#include "MassRepresentationTypes.h"
#include "MassRepresentationFragments.h"
#include "GameFramework/Actor.h"

#include "MassVisualizationTrait.generated.h"

class UMassRepresentationSubsystem;
class UMassRepresentationActorManagement;
class UMassProcessor;

/** This class has been soft-deprecated. Use MassStationaryVisualizationTrait or MassMovableVisualizationTrait */
UCLASS(meta=(DisplayName="DEPRECATED Visualization"))
class MASSREPRESENTATION_API UMassVisualizationTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()
public:
	UMassVisualizationTrait();

	/** Instanced static mesh information for this agent */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	mutable FStaticMeshInstanceVisualizationDesc StaticMeshInstanceDesc;

	/** Actor class of this agent when spawned in high resolution*/
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	TSubclassOf<AActor> HighResTemplateActor;

	/** Actor class of this agent when spawned in low resolution*/
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	TSubclassOf<AActor> LowResTemplateActor;

	/** Allow subclasses to override the representation subsystem to use */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual", meta = (EditCondition = "bCanModifyRepresentationSubsystemClass"))
	TSubclassOf<UMassRepresentationSubsystem> RepresentationSubsystemClass;

	/** Configuration parameters for the representation processor */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	FMassRepresentationParameters Params;

	/** Configuration parameters for the visualization LOD processor */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	FMassVisualizationLODParameters LODParams;

	/** If set to true will result in the visualization-related fragments being added to server-size entities as well.
	 *  By default only the clients require visualization fragments */
	UPROPERTY(EditAnywhere, Category = "Mass|Visual")
	bool bAllowServerSideVisualization = false;

#if WITH_EDITORONLY_DATA
	/** the property is marked like this to ensure it won't show up in UI */
	UPROPERTY(EditDefaultsOnly, Category = "Mass|Visual")
	bool bCanModifyRepresentationSubsystemClass = true;
#endif // WITH_EDITORONLY_DATA

protected:
	/** 
	 * Controls whether StaticMeshInstanceDesc gets registered via FindOrAddStaticMeshDesc call. Setting it to `false` 
	 * can be useful for subclasses to avoid needlessly creating visualization data in RepresentationSubsystem, 
	 * data that will never be used.
	 */
	bool bRegisterStaticMeshDesc = true;

	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;
	virtual bool ValidateTemplate(const FMassEntityTemplateBuildContext& BuildContext, const UWorld& World, FAdditionalTraitRequirements& OutTraitRequirements) const override;

	/** 
	 * Tests whether StaticMeshInstanceDesc is valid and if not cleans up InOutParamss of EMassRepresentationType::StaticMeshInstance
	 * occurrences. 
	 * @param bStaticMeshDeterminedInvalid if StaticMeshInstanceDesc has already been determined invalid then bStaticMeshDeterminedInvalid
	 *	can be set to `true` to skip the redundant check.
	 */
	virtual void SanitizeParams(FMassRepresentationParameters& InOutParams, const bool bStaticMeshDeterminedInvalid = false) const;

	virtual void Serialize(FArchive& Ar) override;
#if WITH_EDITOR
	virtual void PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent) override;
	virtual bool ValidateParams() const;
#endif // WITH_EDITOR
};

=================================================================


=== Source/MassRepresentation/Public/MassVisualizer.h ===
=========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "GameFramework/Actor.h"
#include "MassVisualizer.generated.h"


class UMassVisualizationComponent;

/**
 * Actor holding the mass visual component responsible to handle the representation of the mass agent as the static mesh instances 
 * There may be a separate instance of these for different types of Agents (Cars, NPC's etc)
 */
UCLASS(NotPlaceable, Transient)
class MASSREPRESENTATION_API AMassVisualizer : public AActor
{
	GENERATED_BODY()
public:
	AMassVisualizer();

	/** Visualization component is guaranteed to exist if this class is created */
	UMassVisualizationComponent& GetVisualizationComponent() const { return *VisComponent; }

protected:
	UPROPERTY()
	TObjectPtr<UMassVisualizationComponent> VisComponent;
};

=========================================================


=== Source/MassRepresentation/MassRepresentation.Build.cs ===
=============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

namespace UnrealBuildTool.Rules
{
	public class MassRepresentation : ModuleRules
	{
		public MassRepresentation(ReadOnlyTargetRules Target) : base(Target)
		{
			PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

			UnsafeTypeCastWarningLevel = WarningLevel.Warning;

			PublicDependencyModuleNames.AddRange(
				new string[] {
					"Core",
					"CoreUObject",
					"Engine",
					"AIModule",
					"MassEntity",
					"MassCommon",
					"MassActors",
					"MassSpawner",
					"MassReplication",
					"MassLOD",
					"MassSimulation",
					"RenderCore",
					"RHI",
					"MassMovement",
					"MassSignals",
				}
			);

			if (Target.bBuildEditor == true)
			{
				PrivateDependencyModuleNames.Add("EditorFramework");
				PrivateDependencyModuleNames.Add("UnrealEd");
			}
		}
	}
}

=============================================================


=== Source/MassSignals/Private/MassSignalProcessorBase.cpp ===
==============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSignalProcessorBase.h"
#include "MassSignalSubsystem.h"
#include "MassArchetypeTypes.h"
#include "MassExecutionContext.h"
#include "Engine/World.h"
#include "Misc/ScopeLock.h"


UMassSignalProcessorBase::UMassSignalProcessorBase(const FObjectInitializer& ObjectInitializer)
	: EntityQuery(*this)
{
	ExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;
}

void UMassSignalProcessorBase::BeginDestroy()
{
	if (UMassSignalSubsystem* SignalSubsystem = UWorld::GetSubsystem<UMassSignalSubsystem>(GetWorld()))
	{
		for (const FName& SignalName : RegisteredSignals)
		{
			SignalSubsystem->GetSignalDelegateByName(SignalName).RemoveAll(this);
		}
	}

	Super::BeginDestroy();
}

void UMassSignalProcessorBase::SubscribeToSignal(UMassSignalSubsystem& SignalSubsystem, const FName SignalName)
{
	check(!RegisteredSignals.Contains(SignalName));
	RegisteredSignals.Add(SignalName);
	SignalSubsystem.GetSignalDelegateByName(SignalName).AddUObject(this, &UMassSignalProcessorBase::OnSignalReceived);
}

void UMassSignalProcessorBase::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	QUICK_SCOPE_CYCLE_COUNTER(SignalEntities);

	const int32 ProcessingFrameBufferIndex = CurrentFrameBufferIndex;
	{
		// we only need to lock the part where we change the current buffer index. Once that's done the incoming signals will end up 
		// in the other buffer
		UE::TScopeLock<UE::FSpinLock> ScopeLock(ReceivedSignalLock);
		CurrentFrameBufferIndex = (CurrentFrameBufferIndex + 1) % BuffersCount;
	}
	
	FFrameReceivedSignals& ProcessingFrameBuffer = FrameReceivedSignals[ProcessingFrameBufferIndex];
	TArray<FEntitySignalRange>& ReceivedSignalRanges = ProcessingFrameBuffer.ReceivedSignalRanges;
	TArray<FMassEntityHandle>& SignaledEntities = ProcessingFrameBuffer.SignaledEntities;

	if (ReceivedSignalRanges.IsEmpty())
	{
		return;
	}

	TArray<FMassArchetypeHandle> ValidArchetypes;
	GetArchetypesMatchingOwnedQueries(EntityManager, ValidArchetypes);

	if (ValidArchetypes.Num() > 0)
	{
		// EntitySet stores unique array of entities per specified archetype.
		// FMassArchetypeEntityCollection expects an array of entities, a set is used to detect unique ones.
		struct FEntitySet
		{
			void Reset()
			{
				Entities.Reset();
			}

			FMassArchetypeHandle Archetype;
			TArray<FMassEntityHandle> Entities;
		};
		TArray<FEntitySet> EntitySets;

		for (const FMassArchetypeHandle& Archetype : ValidArchetypes)
		{
			FEntitySet& Set = EntitySets.AddDefaulted_GetRef();
			Set.Archetype = Archetype;
		}

		// SignalNameLookup has limit of how many signals it can handle at once, we'll do passes until all signals are processed.
		int32 SignalsToProcess = ReceivedSignalRanges.Num();
		while(SignalsToProcess > 0)
		{
			SignalNameLookup.Reset();

			// Convert signals with entity ids into arrays of entities per archetype.
			for (FEntitySignalRange& Range : ReceivedSignalRanges)
			{
				if (Range.bProcessed)
				{
					continue;
				}
				// Get bitflag for the signal name
				const uint64 SignalFlag = SignalNameLookup.GetOrAddSignalName(Range.SignalName);
				if (SignalFlag == 0)
				{
					// Will process that signal in a second iteration
					continue;
				}

				// Entities for this signal
				TArrayView<FMassEntityHandle> Entities(&SignaledEntities[Range.Begin], Range.End - Range.Begin);
				FEntitySet* PrevSet = &EntitySets[0];
				for (const FMassEntityHandle Entity : Entities)
				{
					// Add to set of supported archetypes. Dont process if we don't care about the type.
					FMassArchetypeHandle Archetype = EntityManager.GetArchetypeForEntity(Entity);
					FEntitySet* Set = PrevSet->Archetype == Archetype ? PrevSet : EntitySets.FindByPredicate([&Archetype](const FEntitySet& Set) { return Archetype == Set.Archetype; });
					if (Set != nullptr)
					{
						// We don't care about duplicates here, the FMassArchetypeEntityCollection creation below will handle it
						Set->Entities.Add(Entity);
						SignalNameLookup.AddSignalToEntity(Entity, SignalFlag);
						PrevSet = Set;
					}
				}

				Range.bProcessed = true;
				SignalsToProcess--;
			}

			// Execute per archetype.
			for (FEntitySet& Set : EntitySets)
			{
				if (Set.Entities.Num() > 0)
				{
					Context.SetEntityCollection(FMassArchetypeEntityCollection(Set.Archetype, Set.Entities, FMassArchetypeEntityCollection::FoldDuplicates));
					SignalEntities(EntityManager, Context, SignalNameLookup);
					Context.ClearEntityCollection();
				}
				Set.Reset();
			}
		}
	}

	ReceivedSignalRanges.Reset();
	SignaledEntities.Reset();
}

void UMassSignalProcessorBase::OnSignalReceived(FName SignalName, TConstArrayView<FMassEntityHandle> Entities)
{
	FEntitySignalRange Range;
	Range.SignalName = SignalName;

	UE::TScopeLock<UE::FSpinLock> ScopeLock(ReceivedSignalLock);

	FFrameReceivedSignals& CurrentFrameBuffer = FrameReceivedSignals[CurrentFrameBufferIndex];

	Range.Begin = CurrentFrameBuffer.SignaledEntities.Num();
	CurrentFrameBuffer.SignaledEntities.Append(Entities.GetData(), Entities.Num());
	Range.End = CurrentFrameBuffer.SignaledEntities.Num();
	CurrentFrameBuffer.ReceivedSignalRanges.Add(MoveTemp(Range));
}

==============================================================


=== Source/MassSignals/Private/MassSignalsModule.cpp ===
========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "CoreMinimal.h"
#include "MassSignalTypes.h"
#include "IMassSignalsModule.h"

DEFINE_LOG_CATEGORY(LogMassSignals)


class FMassSignalsModule : public IMassSignalsModule
{
	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

IMPLEMENT_MODULE(FMassSignalsModule, MassSignals)



void FMassSignalsModule::StartupModule()
{
	// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)
}


void FMassSignalsModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}




========================================================


=== Source/MassSignals/Private/MassSignalSubsystem.cpp ===
==========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSignalSubsystem.h"
#include "MassExecutionContext.h"
#include "MassCommandBuffer.h"
#include "MassSignalTypes.h"
#include "VisualLogger/VisualLogger.h"
#include "ProfilingDebugging/CsvProfiler.h"
#include "Engine/World.h"

CSV_DEFINE_CATEGORY(MassSignalsCounters, true);

void UMassSignalSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);
	CachedWorld = &GetWorldRef();
	checkf(CachedWorld, TEXT("UMassSignalSubsystem instances are expected to always be tied to a valid UWorld instance"));
}

void UMassSignalSubsystem::Deinitialize()
{
	CachedWorld = nullptr;
	Super::Deinitialize();
}

void UMassSignalSubsystem::Tick(float DeltaTime)
{
	CA_ASSUME(CachedWorld);
	const double CurrentTime = CachedWorld->GetTimeSeconds();

	for (int i = 0; i < DelayedSignals.Num();)
	{
		FDelayedSignal& DelayedSignal = DelayedSignals[i];
		if (DelayedSignal.TargetTimestamp <= CurrentTime)
		{
			SignalEntities(DelayedSignal.SignalName, MakeArrayView(DelayedSignal.Entities));
			DelayedSignals.RemoveAtSwap(i, EAllowShrinking::No);
		}
		else
		{
			i++;
		}
	}
}

TStatId UMassSignalSubsystem::GetStatId() const
{
	RETURN_QUICK_DECLARE_CYCLE_STAT(UMassSignalSubsystem, STATGROUP_Tickables);
}

void UMassSignalSubsystem::SignalEntity(FName SignalName, const FMassEntityHandle Entity)
{
	checkf(Entity.IsSet(), TEXT("Expecting a valid entity to signal"));
	SignalEntities(SignalName, MakeArrayView(&Entity, 1));
}

void UMassSignalSubsystem::SignalEntities(FName SignalName, TConstArrayView<FMassEntityHandle> Entities)
{
	checkf(Entities.Num() > 0, TEXT("Expecting entities to signal"));
	const UE::MassSignal::FSignalDelegate& SignalDelegate = GetSignalDelegateByName(SignalName);
	SignalDelegate.Broadcast(SignalName, Entities);

#if CSV_PROFILER_STATS
	FCsvProfiler::RecordCustomStat(*SignalName.ToString(), CSV_CATEGORY_INDEX(MassSignalsCounters), Entities.Num(), ECsvCustomStatOp::Accumulate);
#endif

	UE_CVLOG(Entities.Num() == 1, this, LogMassSignals, Log, TEXT("Raising signal [%s] to entity [%s]"), *SignalName.ToString(), *Entities[0].DebugGetDescription());
	UE_CVLOG(Entities.Num() > 1, this, LogMassSignals, Log, TEXT("Raising signal [%s] to %d entities"), *SignalName.ToString(), Entities.Num());
}

void UMassSignalSubsystem::DelaySignalEntity(FName SignalName, const FMassEntityHandle Entity, const float DelayInSeconds)
{
	checkf(Entity.IsSet(), TEXT("Expecting a valid entity to signal"));
	DelaySignalEntities(SignalName, MakeArrayView(&Entity, 1), DelayInSeconds);
}

void UMassSignalSubsystem::DelaySignalEntities(FName SignalName, TConstArrayView<FMassEntityHandle> Entities, const float DelayInSeconds)
{
	FDelayedSignal& DelayedSignal = DelayedSignals.Emplace_GetRef();
	DelayedSignal.SignalName = SignalName;
	DelayedSignal.Entities = Entities;

	check(CachedWorld);
	DelayedSignal.TargetTimestamp = CachedWorld->GetTimeSeconds() + DelayInSeconds;

	UE_CVLOG(Entities.Num() == 1, this, LogMassSignals, Log, TEXT("Delay signal [%s] to entity [%s] in %.2f"), *SignalName.ToString(), *Entities[0].DebugGetDescription(), DelayInSeconds);
	UE_CVLOG(Entities.Num() > 1,this, LogMassSignals, Log, TEXT("Delay signal [%s] to %d entities in %.2f"), *SignalName.ToString(), Entities.Num(), DelayInSeconds);
}

void UMassSignalSubsystem::SignalEntityDeferred(FMassExecutionContext& Context, FName SignalName, const FMassEntityHandle Entity)
{
	checkf(Entity.IsSet(), TEXT("Expecting a valid entity to signal"));
	SignalEntitiesDeferred(Context, SignalName, MakeArrayView(&Entity, 1));
}

void UMassSignalSubsystem::SignalEntitiesDeferred(FMassExecutionContext& Context, FName SignalName, TConstArrayView<FMassEntityHandle> Entities)
{
	checkf(Entities.Num() > 0, TEXT("Expecting entities to signal"));
	Context.Defer().PushCommand<FMassDeferredSetCommand>([SignalName, InEntities = TArray<FMassEntityHandle>(Entities)](const FMassEntityManager& System)
	{
		UMassSignalSubsystem* SignalSubsystem = UWorld::GetSubsystem<UMassSignalSubsystem>(System.GetWorld());
		SignalSubsystem->SignalEntities(SignalName, InEntities);
	});

	UE_CVLOG(Entities.Num() == 1, this, LogMassSignals, Log, TEXT("Raising deferred signal [%s] to entity [%s]"), *SignalName.ToString(), *Entities[0].DebugGetDescription());
	UE_CVLOG(Entities.Num() > 1, this, LogMassSignals, Log, TEXT("Raising deferred signal [%s] to %d entities"), *SignalName.ToString(), Entities.Num());
}

void UMassSignalSubsystem::DelaySignalEntityDeferred(FMassExecutionContext& Context, FName SignalName, const FMassEntityHandle Entity, const float DelayInSeconds)
{
	checkf(Entity.IsSet(), TEXT("Expecting a valid entity to signal"));
	DelaySignalEntitiesDeferred(Context, SignalName, MakeArrayView(&Entity, 1), DelayInSeconds);
}

void UMassSignalSubsystem::DelaySignalEntitiesDeferred(FMassExecutionContext& Context, FName SignalName, TConstArrayView<FMassEntityHandle> Entities, const float DelayInSeconds)
{
	checkf(Entities.Num() > 0, TEXT("Expecting entities to signal"));
	Context.Defer().PushCommand<FMassDeferredSetCommand>([SignalName, InEntities = TArray<FMassEntityHandle>(Entities), DelayInSeconds](const FMassEntityManager& System)
	{
		UMassSignalSubsystem* SignalSubsystem = UWorld::GetSubsystem<UMassSignalSubsystem>(System.GetWorld());
		SignalSubsystem->DelaySignalEntities(SignalName, InEntities, DelayInSeconds);
	});

	UE_CVLOG(Entities.Num() == 1, this, LogMassSignals, Log, TEXT("Delay deferred signal [%s] to entity [%s] in %.2f"), *SignalName.ToString(), *Entities[0].DebugGetDescription(), DelayInSeconds);
	UE_CVLOG(Entities.Num() > 1,this, LogMassSignals, Log, TEXT("Delay deferred signal [%s] to %d entities in %.2f"), *SignalName.ToString(), Entities.Num(), DelayInSeconds);
}

==========================================================


=== Source/MassSignals/Private/MassSignalTypes.cpp ===
======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSignalTypes.h"
#include "MassEntityManager.h"

uint64 FMassSignalNameLookup::GetOrAddSignalName(const FName SignalName)
{
	int32 Index = SignalNames.Find(SignalName);
	if (Index == INDEX_NONE)
	{
		if (SignalNames.Num() >= MaxSignalNames)
		{
			return 0;
		}
		Index = SignalNames.Add(SignalName);
	}
	return 1ULL << Index;
}

void FMassSignalNameLookup::AddSignalToEntity(const FMassEntityHandle Entity, const uint64 SignalFlag)
{
	uint64& Signals = EntitySignals.FindOrAdd(Entity, 0);
	Signals |= SignalFlag;
}

void FMassSignalNameLookup::GetSignalsForEntity(const FMassEntityHandle Entity, TArray<FName>& OutSignals) const
{
	OutSignals.Reset();
	if (const uint64* Signals = EntitySignals.Find(Entity))
	{
		const uint64 Start = FMath::CountTrailingZeros64(*Signals);
		const uint64 End = FMath::CountLeadingZeros64(*Signals);
		for (uint64 i = Start; i < 64 - End; i++)
		{
			const uint64 SignalFlag = 1ULL << i;
			if ((*Signals) & SignalFlag)
			{
				OutSignals.Add(SignalNames[(uint32)i]);
			}
		}
	}
}

void FMassSignalNameLookup::Reset()
{
	SignalNames.Reset();
	EntitySignals.Reset();
}
======================================================


=== Source/MassSignals/Public/IMassSignalsModule.h ===
======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleInterface.h"
#include "Modules/ModuleManager.h"


/**
 * The public interface to this module.  In most cases, this interface is only public to sibling modules 
 * within this plugin.
 */
class IMassSignalsModule : public IModuleInterface
{

public:

	/**
	 * Singleton-like access to this module's interface.  This is just for convenience!
	 * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.
	 *
	 * @return Returns singleton instance, loading the module on demand if needed
	 */
	static inline IMassSignalsModule& Get()
	{
		return FModuleManager::LoadModuleChecked<IMassSignalsModule>( "MassSignals" );
	}

	/**
	 * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.
	 *
	 * @return True if the module is loaded and ready to use
	 */
	static inline bool IsAvailable()
	{
		return FModuleManager::Get().IsModuleLoaded( "MassSignals" );
	}
};


======================================================


=== Source/MassSignals/Public/MassSignalProcessorBase.h ===
===========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassProcessor.h"
#include "MassEntityManager.h"
#include "MassSignalTypes.h"
#include "Containers/StaticArray.h"
#include "Misc/SpinLock.h"
#include "MassSignalProcessorBase.generated.h"

class UMassSignalSubsystem;

/** 
 * Processor for executing signals on each targeted entities
 * The derived classes only need to implement the method SignalEntities to actually received the raised signals for the entities they subscribed to 
 */
UCLASS(abstract)
class MASSSIGNALS_API UMassSignalProcessorBase : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassSignalProcessorBase(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

protected:
	virtual void BeginDestroy() override;

	/** Configure the owned FMassEntityQuery instances to express processor queries requirements */
	virtual void ConfigureQueries() override {}

	/**
	 * Actual method that derived class needs to implement to act on a signal that is raised for that frame
	 * @param EntitySubsystem is the system to execute the lambdas on each entity chunk
	 * @param Context is the execution context to be passed when executing the lambdas
	 * @param EntitySignals Look up to retrieve for each entities their raised signal via GetSignalsForEntity
	 */
	 virtual void SignalEntities(FMassEntityManager& EntityManager, FMassExecutionContext& Context, FMassSignalNameLookup& EntitySignals) PURE_VIRTUAL(UMassSignalProcessorBase::SignalEntities, );

	/**
	 * Callback that is being called when new signal is raised
	 * @param SignalName is the name of the signal being raised
	 * @param Entities are the targeted entities for this signal
	 */
	 virtual void OnSignalReceived(FName SignalName, TConstArrayView<FMassEntityHandle> Entities);

	/**
	 * Execution method for this processor
	 * @param EntitySubsystem is the system to execute the lambdas on each entity chunk
	 * @param Context is the execution context to be passed when executing the lambdas
	 */
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	/** 
	 * We don't want signaling processors to be pruned by default, since that can mess up signal processing 
	 * just after processor's creation (might miss some signals initially).
	 */
	virtual bool ShouldAllowQueryBasedPruning(const bool bRuntimeMode = true) const override { return false; }


	/**
	 * To receive notification about a particular signal, you need to subscribe to it.
	 * @param SignalName is the name of the signal to receive notification about
	 */
	void SubscribeToSignal(UMassSignalSubsystem& SignalSubsystem, const FName SignalName);

	FMassEntityQuery EntityQuery;

private:

	/** Stores a range of indices in the SignaledEntities TArray of Entities and the associated signal name */
	struct FEntitySignalRange
	{
		FName SignalName;
		int32 Begin = 0;
		int32 End = 0;
		bool bProcessed = false;
	};

	struct FFrameReceivedSignals
	{
		/** Received signals are double buffered as we can receive new one while processing them */
		TArray<FEntitySignalRange> ReceivedSignalRanges;

		/** the list of all signaled entities, can contain duplicates */
		TArray<FMassEntityHandle> SignaledEntities;
	};

	static constexpr int BuffersCount = 2;

	/** Double buffer frame received signal as we can receive new signals as we are processing them */
	TStaticArray<FFrameReceivedSignals, BuffersCount> FrameReceivedSignals;
	
	/** Current frame buffer index of FrameReceivedSignals */
	int32 CurrentFrameBufferIndex = 0;

	/** Lookup used to store and retrieve signals per entity, only used during processing */
	FMassSignalNameLookup SignalNameLookup;

	/** List of all the registered signal names*/
	TArray<FName> RegisteredSignals;

	UE::FSpinLock ReceivedSignalLock;
};


===========================================================


=== Source/MassSignals/Public/MassSignalSubsystem.h ===
=======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityManager.h"
#include "MassSubsystemBase.h"
#include "MassSignalSubsystem.generated.h"

namespace UE::MassSignal 
{
	DECLARE_MULTICAST_DELEGATE_TwoParams(FSignalDelegate, FName /*SignalName*/, TConstArrayView<FMassEntityHandle> /*Entities*/);
} // UE::MassSignal

/**
* A subsystem for handling Signals in Mass
*/
UCLASS()
class MASSSIGNALS_API UMassSignalSubsystem : public UMassTickableSubsystemBase
{
	GENERATED_BODY()
	
public:

	/** 
	 * Retrieve the delegate dispatcher from the signal name
	 * @param SignalName is the name of the signal to get the delegate dispatcher from
	 */
	UE::MassSignal::FSignalDelegate& GetSignalDelegateByName(FName SignalName)
	{
		return NamedSignals.FindOrAdd(SignalName);
	}

	/**
	 * Inform a single entity of a signal being raised
	 * @param SignalName is the name of the signal raised
	 * @param Entity entity that should be informed that signal 'SignalName' was raised
	 */
	void SignalEntity(FName SignalName, const FMassEntityHandle Entity);

	/**
	 * Inform multiple entities of a signal being raised
	 * @param SignalName is the name of the signal raised
	 * @param Entities list of entities that should be informed that signal 'SignalName' was raised
	 */
	void SignalEntities(FName SignalName, TConstArrayView<FMassEntityHandle> Entities);

	/**
	 * Inform a single entity of a signal being raised in a certain amount of seconds
	 * @param SignalName is the name of the signal raised
	 * @param Entity entity that should be informed that signal 'SignalName' was raised
	 * @param DelayInSeconds is the amount of time before signaling the entity
	 */
	void DelaySignalEntity(FName SignalName, const FMassEntityHandle Entity, const float DelayInSeconds);

 	/**
	 * Inform multiple entities of a signal being raised in a certain amount of seconds
	 * @param SignalName is the name of the signal raised
	 * @param Entities being informed of the raised signal
	 * @param DelayInSeconds is the amount of time before signaling the entities
	 */
	void DelaySignalEntities(FName SignalName, TConstArrayView<FMassEntityHandle> Entities, const float DelayInSeconds);

	/**
	 * Inform single entity of a signal being raised asynchronously using the Mass Command Buffer
	 * @param Context is the Entity System execution context to push the async command
	 * @param SignalName is the name of the signal raised
	 * @param Entity entity that should be informed that signal 'SignalName' was raised
	 */
	void SignalEntityDeferred(FMassExecutionContext& Context, FName SignalName, const FMassEntityHandle Entity);

	/**
	 * Inform multiple entities of a signal being raised asynchronously using the Mass Command Buffer
	 * @param Context is the Entity System execution context to push the async command
	 * @param SignalName is the name of the signal raised
	 * @param Entities list of entities that should be informed that signal 'SignalName' was raised
	 */
	void SignalEntitiesDeferred(FMassExecutionContext& Context, FName SignalName, TConstArrayView<FMassEntityHandle> Entities);

 	/**
	 * Inform single entity of a signal being raised asynchronously using the Mass Command Buffer
	 * @param Context is the Entity System execution context to push the async command
	 * @param SignalName is the name of the signal raised
	 * @param Entity entity that should be informed that signal 'SignalName' was raised
	 * @param DelayInSeconds is the amount of time before signaling the entities
	 */
	void DelaySignalEntityDeferred(FMassExecutionContext& Context, FName SignalName, const FMassEntityHandle Entity, const float DelayInSeconds);

 	/**
	 * Inform multiple entities of a signal being raised asynchronously using the Mass Command Buffer
	 * @param Context is the Entity System execution context to push the async command
	 * @param SignalName is the name of the signal raised
	 * @param Entities being informed of that signal was raised
	 * @param DelayInSeconds is the amount of time before signaling the entities
	 */
	void DelaySignalEntitiesDeferred(FMassExecutionContext& Context, FName SignalName, TConstArrayView<FMassEntityHandle> Entities, const float DelayInSeconds);

protected:
	// USubsystem implementation Begin
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;
	// USubsystem implementation End	

	virtual void Tick(float DeltaTime) override;
	virtual TStatId GetStatId() const override;

	TMap<FName, UE::MassSignal::FSignalDelegate> NamedSignals;

	struct FDelayedSignal
	{
		FName SignalName;
		TArray<FMassEntityHandle> Entities;
		double TargetTimestamp;
	};

	TArray<FDelayedSignal> DelayedSignals;

	UPROPERTY(transient)
	TObjectPtr<UWorld> CachedWorld;
};

template<>
struct TMassExternalSubsystemTraits<UMassSignalSubsystem> final
{
	enum
	{
		GameThreadOnly = false
	};
};

=======================================================


=== Source/MassSignals/Public/MassSignalTypes.h ===
===================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Logging/LogMacros.h"
#include "MassEntityManager.h"
//#include "MassSignalTypes.generated.h"

DECLARE_LOG_CATEGORY_EXTERN(LogMassSignals, Log, All)


/**
 * MassSignalNameLookup stores list of Signal names for each entity. The names are stored per entity as a bitmask,
 * you can allocate new name using GetOrAddSignalName(). This limits the names to 64.
 */
struct MASSSIGNALS_API FMassSignalNameLookup
{
	/** Max number of names each entity can contain */
	static constexpr int32 MaxSignalNames = 64;

	/** 
	 * Retrieve if it is already registered or adds new signal to the lookup and return the bitflag for that Signal
	 * @SignalName is the name of the signal to retrieve or add to the lookup.
	 * @return bitflag describing the name, or 0 if max names is reached. 
	 */
	uint64 GetOrAddSignalName(const FName SignalName);

	/**
	 * Adds specified Signal name bitflag to an entity 
	 * @param Entity is the entity where the signal has been raised
	 * @param SignalFlag is the actual bitflag describing the signal
	 */
	void AddSignalToEntity(const FMassEntityHandle Entity, const uint64 SignalFlag);

	/** 
	 * Retrieve for a specific entity the raised signal this frame
	 * @return Array of signal names raised for this entity 
	 */
	void GetSignalsForEntity(const FMassEntityHandle Entity, TArray<FName>& OutSignals) const;

	/** Empties the name lookup and entity signals */
	void Reset();

protected:
	/** Array of Signal names */
	TArray<FName> SignalNames;

	/** Map from entity id to name bitmask */
	TMap<FMassEntityHandle, uint64> EntitySignals;
};
===================================================


=== Source/MassSignals/MassSignals.Build.cs ===
===============================================

// Copyright Epic Games, Inc. All Rights Reserved.

namespace UnrealBuildTool.Rules
{
	public class MassSignals : ModuleRules
	{
		public MassSignals(ReadOnlyTargetRules Target) : base(Target)
		{
			PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

			UnsafeTypeCastWarningLevel = WarningLevel.Warning;

			PublicDependencyModuleNames.AddRange(
				new string[] {
					"Core",
					"CoreUObject",
					"Engine",
					"MassEntity",
				}
			);

			if (Target.bBuildEditor == true)
			{
				PrivateDependencyModuleNames.Add("EditorFramework");
				PrivateDependencyModuleNames.Add("UnrealEd");
			}
		}
	}
}

===============================================


=== Source/MassSimulation/Private/MassSimulationModule.cpp ===
==============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "CoreMinimal.h"
#include "IMassSimulationModule.h"


class FMassSimulationModule : public IMassSimulationModule
{
	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

IMPLEMENT_MODULE(FMassSimulationModule, MassSimulation)



void FMassSimulationModule::StartupModule()
{
	// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)
}


void FMassSimulationModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}




==============================================================


=== Source/MassSimulation/Private/MassSimulationSubsystem.cpp ===
=================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSimulationSubsystem.h"
#include "MassEntityManager.h"
#include "MassEntitySubsystem.h"
#include "MassExecutor.h"
#include "MassSimulationSettings.h"
#include "VisualLogger/VisualLogger.h"
#include "MassEntitySettings.h"
#include "Engine/Engine.h"
#if WITH_EDITOR
#include "Editor.h"
#endif // WITH_EDITOR

DEFINE_LOG_CATEGORY(LogMassSim);

namespace UE::Mass::Simulation
{
	bool bDoEntityCompaction = true;
	bool bSimulationTickingEnabled = true;

	namespace Private
	{
	FAutoConsoleVariableRef CVars[] = {
		{TEXT("mass.EntityCompaction"), bDoEntityCompaction, TEXT("Maximize the number of entities per chunk"), ECVF_Cheat}
		, {TEXT("mass.SimulationTickingEnabled"), bSimulationTickingEnabled, TEXT("Controls whether Mass simulation ticking is allowed in game worlds. Upon changing the value it also stops/starts Mass simulation ticking, if needed"), 
			FConsoleVariableDelegate::CreateStatic(UMassSimulationSubsystem::HandleSimulationTickingEnabledCVarChange)}
		};
	}
}

//----------------------------------------------------------------------//
// UMassSimulationSubsystem
//----------------------------------------------------------------------//
UMassSimulationSubsystem::UMassSimulationSubsystem(const FObjectInitializer& ObjectInitializer)
	: Super()
{
}

void UMassSimulationSubsystem::BeginDestroy()
{
#if WITH_EDITOR
	if (PieBeginEventHandle.IsValid())
	{
		FEditorDelegates::BeginPIE.Remove(PieBeginEventHandle);
	}
	if (PieEndedEventHandle.IsValid())
	{
		FEditorDelegates::PrePIEEnded.Remove(PieEndedEventHandle);
	}
	if (MassEntitySettingsChangeHandle.IsValid())
	{
		if (UMassEntitySettings* Settings = GetMutableDefault<UMassEntitySettings>())
		{
			Settings->GetOnSettingsChange().Remove(MassEntitySettingsChangeHandle);
		}
	}
#endif //  WITH_EDITOR

	if (bSimulationStarted)
	{
		check(EntityManager);
		StopSimulation();
	}

	Super::BeginDestroy();
}

FMassProcessingPhase::FOnPhaseEvent& UMassSimulationSubsystem::GetOnProcessingPhaseStarted(const EMassProcessingPhase Phase)
{
	return PhaseManager.GetOnPhaseStart(Phase);
}

FMassProcessingPhase::FOnPhaseEvent& UMassSimulationSubsystem::GetOnProcessingPhaseFinished(const EMassProcessingPhase Phase)
{
	return PhaseManager.GetOnPhaseEnd(Phase);
}

bool UMassSimulationSubsystem::IsDuringMassProcessing() const 
{
	return EntityManager.IsValid() && EntityManager->IsProcessing();
}

void UMassSimulationSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	UMassEntitySubsystem* EntitySubsystem = Collection.InitializeDependency<UMassEntitySubsystem>();
	check(EntitySubsystem);
	EntityManager = EntitySubsystem->GetMutableEntityManager().AsShared();
	
	GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).AddUObject(this, &UMassSimulationSubsystem::OnProcessingPhaseStarted, EMassProcessingPhase::PrePhysics);

	HandleLateCreation();
}

void UMassSimulationSubsystem::Deinitialize()
{
	GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).RemoveAll(this);
	StopSimulation();

	PhaseManager.Deinitialize();
	EntityManager.Reset();

	Super::Deinitialize();
}

void UMassSimulationSubsystem::PostInitialize()
{
	Super::PostInitialize();

#if WITH_EDITOR
	UWorld* World = GetWorld();
	if (GEditor && World != nullptr && !World->IsGameWorld())
	{
		// in editor worlds we need to rebuild the pipeline at this point since OnWorldBeginPlay won't be called
		RebuildTickPipeline();

		PieBeginEventHandle = FEditorDelegates::BeginPIE.AddUObject(this, &UMassSimulationSubsystem::OnPieBegin);
		PieEndedEventHandle = FEditorDelegates::PrePIEEnded.AddUObject(this, &UMassSimulationSubsystem::OnPieEnded);

		UMassEntitySettings* Settings = GetMutableDefault<UMassEntitySettings>();
		check(Settings);
		MassEntitySettingsChangeHandle = Settings->GetOnSettingsChange().AddUObject(this, &UMassSimulationSubsystem::OnMassEntitySettingsChange);

		// note that this starts ticking for the editor world
		StartSimulation(*World);
	}
#endif // WITH_EDITOR
}

void UMassSimulationSubsystem::OnWorldBeginPlay(UWorld& InWorld)
{
	Super::OnWorldBeginPlay(InWorld);

	// To evaluate the effective processors execution mode, we need to wait on OnWorldBeginPlay before calling
	// RebuildTickPipeline as we are sure by this time the network is setup correctly.
	RebuildTickPipeline();
	// note that since we're in this function we're tied to a game world. This means the StartSimulation in 
	// PostInitialize haven't been called.
	StartSimulation(InWorld);
}

void UMassSimulationSubsystem::RegisterDynamicProcessor(UMassProcessor& Processor)
{
	checkf(!IsDuringMassProcessing(), TEXT("Unable to add dynamic processors to Mass during processing."));
	PhaseManager.RegisterDynamicProcessor(Processor);
}

void UMassSimulationSubsystem::UnregisterDynamicProcessor(UMassProcessor& Processor)
{
	checkf(!IsDuringMassProcessing(), TEXT("Unable to remove dynamic processors to Mass during processing."));
	PhaseManager.UnregisterDynamicProcessor(Processor);
}

void UMassSimulationSubsystem::HandleSimulationTickingEnabledCVarChange(IConsoleVariable*)
{
	if (GEngine == nullptr)
	{
		return;
	}

	for (const FWorldContext& Context : GEngine->GetWorldContexts())
	{
		if (Context.WorldType != EWorldType::Inactive)
		{
			UWorld* World = Context.World();
			
			// we only want to affect game worlds
			if (World == nullptr || World->IsGameWorld() == false)
			{
				continue;
			}

			if (UMassSimulationSubsystem* MassSimulationSubsystem = UWorld::GetSubsystem<UMassSimulationSubsystem>(World))
			{
				if (UE::Mass::Simulation::bSimulationTickingEnabled)
				{
					// if enabling call StartSimulation ony if the world has already begun play. Otherwise the 
					// simulation ticking will be started at the right time automatically
					if (World->HasBegunPlay())
					{
						MassSimulationSubsystem->StartSimulation(*World);
					}
				}
				else
				{
					MassSimulationSubsystem->StopSimulation();
				}
			}
		}
	}
}

void UMassSimulationSubsystem::RebuildTickPipeline()
{
	TConstArrayView<FMassProcessingPhaseConfig> ProcessingPhasesConfig = GET_MASS_CONFIG_VALUE(GetProcessingPhasesConfig());
	FString DependencyGraphFileName;

#if WITH_EDITOR
	const UWorld* World = GetWorld();
	const UMassEntitySettings* Settings = GetMutableDefault<UMassEntitySettings>();
	if (World != nullptr && Settings != nullptr && !Settings->DumpDependencyGraphFileName.IsEmpty())
	{
		DependencyGraphFileName = FString::Printf(TEXT("%s_%s"), *Settings->DumpDependencyGraphFileName, *ToString(World->GetNetMode()));
	}
#endif // WITH_EDITOR

	PhaseManager.Initialize(*this, ProcessingPhasesConfig, DependencyGraphFileName);
}

void UMassSimulationSubsystem::StartSimulation(UWorld& InWorld)
{
	if (bSimulationStarted)
	{
		return;
	}

	if (UE::Mass::Simulation::bSimulationTickingEnabled)
	{
		PhaseManager.Start(InWorld);

		bSimulationStarted = true;

		OnSimulationStarted.Broadcast(&InWorld);
	}
}

void UMassSimulationSubsystem::StopSimulation()
{
	if (bSimulationStarted == false)
	{
		return;
	}

	PhaseManager.Stop();

	bSimulationStarted = false;
}

void UMassSimulationSubsystem::OnProcessingPhaseStarted(const float DeltaSeconds, const EMassProcessingPhase Phase) const
{
	switch (Phase)
	{
		case EMassProcessingPhase::PrePhysics:
			{
				if (UE::Mass::Simulation::bDoEntityCompaction && GET_MASSSIMULATION_CONFIG_VALUE(bEntityCompactionEnabled))
				{
					TRACE_CPUPROFILER_EVENT_SCOPE(DoEntityCompaction);
					check(EntityManager);
					EntityManager->DoEntityCompaction(GET_MASSSIMULATION_CONFIG_VALUE(DesiredEntityCompactionTimeSlicePerTick));
				}
			}
			break;
		default:
			// unhandled phases, by design, not every phase needs to be handled by the Actor subsystem
			break;
	}
}


#if WITH_EDITOR
void UMassSimulationSubsystem::OnPieBegin(const bool bIsSimulation)
{
	// called so that we're not processing phases for the editor world while PIE/SIE is running
	StopSimulation();
}

void UMassSimulationSubsystem::OnPieEnded(const bool bIsSimulation)
{
	UWorld* World = GetWorld();
	if (World && !bSimulationStarted)
	{
		// Resume processing phases in the editor world.
		StartSimulation(*World);
	}
}

void UMassSimulationSubsystem::OnMassEntitySettingsChange(const FPropertyChangedEvent& PropertyChangedEvent)
{
	RebuildTickPipeline();
}
#endif // WITH_EDITOR
=================================================================


=== Source/MassSimulation/Public/IMassSimulationModule.h ===
============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleInterface.h"
#include "Modules/ModuleManager.h"


/**
 * The public interface to this module.  In most cases, this interface is only public to sibling modules 
 * within this plugin.
 */
class IMassSimulationModule : public IModuleInterface
{

public:

	/**
	 * Singleton-like access to this module's interface.  This is just for convenience!
	 * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.
	 *
	 * @return Returns singleton instance, loading the module on demand if needed
	 */
	static inline IMassSimulationModule& Get()
	{
		return FModuleManager::LoadModuleChecked<IMassSimulationModule>( "MassSimulation" );
	}

	/**
	 * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.
	 *
	 * @return True if the module is loaded and ready to use
	 */
	static inline bool IsAvailable()
	{
		return FModuleManager::Get().IsModuleLoaded( "MassSimulation" );
	}
};


============================================================


=== Source/MassSimulation/Public/MassSimulationSettings.h ===
=============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassSettings.h"
#include "MassSimulationSettings.generated.h"

#define GET_MASSSIMULATION_CONFIG_VALUE(a) (GetMutableDefault<UMassSimulationSettings>()->a)

/**
 * Implements the settings for MassSimulation
 */
UCLASS(config = Mass, defaultconfig, DisplayName = "Mass Simulation")
class MASSSIMULATION_API UMassSimulationSettings : public UMassModuleSettings
{
	GENERATED_BODY()

public:
	/** The desired budget in seconds allowed to do actor spawning per frame */
	UPROPERTY(EditDefaultsOnly, Category = "Runtime", config)
	double DesiredActorSpawningTimeSlicePerTick = 0.0015;

	/** The desired budget in seconds allowed to do actor destruction per frame */
	UPROPERTY(EditDefaultsOnly, Category = "Runtime", config)
	double DesiredActorDestructionTimeSlicePerTick = 0.0005;

	/** 
	 * Whether the Entity Compaction is allowed. When enabled all the archetypes will be processed on a regular basis
	 * and the entities will be moved around to optimize archetype chunk memory utilization. Note that this might not be
	 * desired if your set up results in individual chunks being often not compatible due to the number and value of chunk 
	 * and shared fragments.
	 */
	UPROPERTY(EditDefaultsOnly, Category = "Runtime", config)
	bool bEntityCompactionEnabled = true;

	/** The desired budget in seconds allowed to do entity compaction per frame */
	UPROPERTY(EditDefaultsOnly, Category = "Runtime", config)
	double DesiredEntityCompactionTimeSlicePerTick = 0.005;

	/** The time to wait before retrying to spawn an actor that previously failed, default 10 seconds */
	UPROPERTY(EditDefaultsOnly, Category = "Runtime", config)
	float DesiredActorFailedSpawningRetryTimeInterval = 5.0f;

	/** The distance a failed spawned actor needs to move before we retry, default 10 meters */
	UPROPERTY(EditDefaultsOnly, Category = "Runtime", config)
	float DesiredActorFailedSpawningRetryMoveDistance = 500.0f;
};

=============================================================


=== Source/MassSimulation/Public/MassSimulationSubsystem.h ===
==============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Delegates/IDelegateInstance.h"
#include "MassProcessingTypes.h"
#include "MassProcessingPhaseManager.h"
#include "MassSubsystemBase.h"
#include "MassSimulationSubsystem.generated.h"


struct FMassEntityManager;
class IConsoleVariable;

DECLARE_LOG_CATEGORY_EXTERN(LogMassSim, Log, All);

UCLASS(config = Game, defaultconfig, MinimalAPI)
class UMassSimulationSubsystem : public UMassSubsystemBase
{
	GENERATED_BODY()
public:
	DECLARE_MULTICAST_DELEGATE_OneParam(FOnSimulationStarted, UWorld* /*World*/);
	
	MASSSIMULATION_API UMassSimulationSubsystem(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	const FMassProcessingPhaseManager& GetPhaseManager() const { return PhaseManager; }

	MASSSIMULATION_API FMassProcessingPhase::FOnPhaseEvent& GetOnProcessingPhaseStarted(const EMassProcessingPhase Phase);
	MASSSIMULATION_API FMassProcessingPhase::FOnPhaseEvent& GetOnProcessingPhaseFinished(const EMassProcessingPhase Phase);
	static FOnSimulationStarted& GetOnSimulationStarted() { return OnSimulationStarted; }

	MASSSIMULATION_API void RegisterDynamicProcessor(UMassProcessor& Processor);
	MASSSIMULATION_API void UnregisterDynamicProcessor(UMassProcessor& Processor);

	bool IsSimulationStarted() const { return bSimulationStarted; }

	/** @return whether hosted EntityManager is currently, actively being used for processing purposes. Equivalent to calling FMassEntityManager.IsProcessing() */
	MASSSIMULATION_API bool IsDuringMassProcessing() const;

	/** Starts/stops simulation ticking for all worlds, based on new `mass.SimulationTickingEnabled` cvar value */
	MASSSIMULATION_API static void HandleSimulationTickingEnabledCVarChange(IConsoleVariable*);

protected:
	// UWorldSubsystem BEGIN
	MASSSIMULATION_API virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	MASSSIMULATION_API virtual void PostInitialize() override;
	MASSSIMULATION_API virtual void OnWorldBeginPlay(UWorld& InWorld) override;
	MASSSIMULATION_API virtual void Deinitialize() override;
	// UWorldSubsystem END
	MASSSIMULATION_API virtual void BeginDestroy() override;
	
	MASSSIMULATION_API void RebuildTickPipeline();

	MASSSIMULATION_API void StartSimulation(UWorld& InWorld);
	MASSSIMULATION_API void StopSimulation();

	MASSSIMULATION_API void OnProcessingPhaseStarted(const float DeltaSeconds, const EMassProcessingPhase Phase) const;

#if WITH_EDITOR
	MASSSIMULATION_API void OnPieBegin(const bool bIsSimulation);
	MASSSIMULATION_API void OnPieEnded(const bool bIsSimulation);
	MASSSIMULATION_API void OnMassEntitySettingsChange(const FPropertyChangedEvent& PropertyChangedEvent);
#endif // WITH_EDITOR

protected:

	TSharedPtr<FMassEntityManager> EntityManager;

	FMassProcessingPhaseManager PhaseManager;

	inline static FOnSimulationStarted OnSimulationStarted={};

	UPROPERTY()
	FMassRuntimePipeline RuntimePipeline;

	float CurrentDeltaSeconds = 0.f;
	bool bTickInProgress = false;
	bool bSimulationStarted = false;

#if WITH_EDITOR
	FDelegateHandle PieBeginEventHandle;
	FDelegateHandle PieEndedEventHandle;

	FDelegateHandle MassEntitySettingsChangeHandle;
#endif // WITH_EDITOR
};

==============================================================


=== Source/MassSimulation/MassSimulation.Build.cs ===
=====================================================

// Copyright Epic Games, Inc. All Rights Reserved.

namespace UnrealBuildTool.Rules
{
	public class MassSimulation : ModuleRules
	{
		public MassSimulation(ReadOnlyTargetRules Target) : base(Target)
		{
			PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

			UnsafeTypeCastWarningLevel = WarningLevel.Warning;

			PublicDependencyModuleNames.AddRange(
				new string[] {
					"Core",
					"CoreUObject",
					"Engine",
					"MassCommon",
					"NavigationSystem",
					"MassEntity",
				}
			);

			if (Target.bBuildEditor == true)
			{
				PrivateDependencyModuleNames.Add("UnrealEd");
				PrivateDependencyModuleNames.Add("MassEntityEditor");
			}
		}
	}
}

=====================================================


=== Source/MassSmartObjects/Private/MassSmartObjectBehaviorDefinition.cpp ===
=============================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSmartObjectBehaviorDefinition.h"

#include "MassCommandBuffer.h"
#include "MassSmartObjectFragments.h"

void USmartObjectMassBehaviorDefinition::Activate(FMassCommandBuffer& CommandBuffer, const FMassBehaviorEntityContext& EntityContext) const
{
	FMassSmartObjectTimedBehaviorFragment TimedBehaviorFragment;
	TimedBehaviorFragment.UseTime = UseTime;
	CommandBuffer.PushCommand<FMassCommandAddFragmentInstances>(EntityContext.EntityView.GetEntity(), TimedBehaviorFragment);
}

void USmartObjectMassBehaviorDefinition::Deactivate(FMassCommandBuffer& CommandBuffer, const FMassBehaviorEntityContext& EntityContext) const
{
	CommandBuffer.RemoveFragment<FMassSmartObjectTimedBehaviorFragment>(EntityContext.EntityView.GetEntity());
}

=============================================================================


=== Source/MassSmartObjects/Private/MassSmartObjectHandler.cpp ===
==================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSmartObjectHandler.h"
#include "MassSmartObjectBehaviorDefinition.h"
#include "MassCommonTypes.h"
#include "MassExecutionContext.h"
#include "SmartObjectSubsystem.h"
#include "VisualLogger/VisualLogger.h"
#include "MassCommandBuffer.h"
#include "MassCommonFragments.h"
#include "MassSignalSubsystem.h"
#include "MassSmartObjectFragments.h"
#include "Engine/World.h"
#include "MassDebugger.h"


namespace UE::Mass::SmartObject
{
	void StopInteraction(FMassCommandBuffer& CommandBuffer, const FMassBehaviorEntityContext& Context, const FSmartObjectClaimHandle& ClaimHandle, const EMassSmartObjectInteractionStatus NewStatus)
	{
		FMassSmartObjectUserFragment& User = Context.EntityView.GetFragmentData<FMassSmartObjectUserFragment>();
		if ( User.InteractionHandle == ClaimHandle)
		{
			if (User.InteractionStatus == EMassSmartObjectInteractionStatus::InProgress ||
				User.InteractionStatus == EMassSmartObjectInteractionStatus::BehaviorCompleted)
			{
				if (const USmartObjectMassBehaviorDefinition* BehaviorDefinition = Context.SmartObjectSubsystem.GetBehaviorDefinition<USmartObjectMassBehaviorDefinition>(User.InteractionHandle))
				{
					BehaviorDefinition->Deactivate(CommandBuffer, Context);
				}
			}

			User.InteractionStatus = NewStatus;
			User.InteractionHandle.Invalidate();
		}
	}

	struct FPayload
	{
		FMassEntityHandle Entity;
		TSharedPtr<FMassEntityManager> EntityManager;
		TWeakObjectPtr<USmartObjectSubsystem> SmartObjectSubsystem;
		TWeakObjectPtr<UMassSignalSubsystem> SignalSubsystem;
	};

	void OnSlotInvalidated(const FSmartObjectClaimHandle& ClaimHandle, const ESmartObjectSlotState State, FPayload Payload)
	{
		USmartObjectSubsystem* SmartObjectSubsystem = Payload.SmartObjectSubsystem.Get();
		FMassEntityManager* EntityManager = Payload.EntityManager.Get();
		UMassSignalSubsystem* SignalSubsystem = Payload.SignalSubsystem.Get();
		if (SmartObjectSubsystem != nullptr && EntityManager != nullptr && SignalSubsystem != nullptr && EntityManager->IsEntityActive(Payload.Entity))
		{
			const FMassEntityView EntityView(*EntityManager, Payload.Entity);
			const FMassBehaviorEntityContext Context(EntityView, *SmartObjectSubsystem);

			StopInteraction(EntityManager->Defer(), Context, ClaimHandle, EMassSmartObjectInteractionStatus::Aborted);
			if (EntityManager->IsProcessing() == false)
			{
				EntityManager->FlushCommands();
			}

			SignalSubsystem->SignalEntity(UE::Mass::Signals::SmartObjectInteractionAborted, Payload.Entity);
		}
	}
} // UE::Mass::SmartObject;

//----------------------------------------------------------------------//
// FMassSmartObjectHandler
//----------------------------------------------------------------------//
FMassSmartObjectRequestID FMassSmartObjectHandler::FindCandidatesAsync(const FMassEntityHandle RequestingEntity, const FGameplayTagContainer& UserTags, const FGameplayTagQuery& ActivityRequirements, const FVector& Location) const
{
	const FMassEntityHandle ReservedEntity = EntityManager.ReserveEntity();

	FMassSmartObjectWorldLocationRequestFragment RequestFragment;
	RequestFragment.SearchOrigin = Location;
	RequestFragment.RequestingEntity = RequestingEntity;
	RequestFragment.UserTags = UserTags;
	RequestFragment.ActivityRequirements = ActivityRequirements;

	FMassSmartObjectRequestResultFragment ResultFragment;

	ExecutionContext.Defer().PushCommand<FMassCommandAddFragmentInstances>(ReservedEntity, RequestFragment, ResultFragment);

	return FMassSmartObjectRequestID(ReservedEntity);
}

FMassSmartObjectRequestID FMassSmartObjectHandler::FindCandidatesAsync(const FMassEntityHandle RequestingEntity, const FGameplayTagContainer& UserTags, const FGameplayTagQuery& ActivityRequirements, const FZoneGraphCompactLaneLocation& LaneLocation) const
{
	const FMassEntityHandle ReservedEntity = EntityManager.ReserveEntity();

	FMassSmartObjectLaneLocationRequestFragment RequestFragment;
	RequestFragment.CompactLaneLocation = LaneLocation;
	RequestFragment.RequestingEntity = RequestingEntity;
	RequestFragment.UserTags = UserTags;
	RequestFragment.ActivityRequirements = ActivityRequirements;

	FMassSmartObjectRequestResultFragment ResultFragment;

	ExecutionContext.Defer().PushCommand<FMassCommandAddFragmentInstances>(ReservedEntity, RequestFragment, ResultFragment);

	return FMassSmartObjectRequestID(ReservedEntity);
}

const FMassSmartObjectCandidateSlots* FMassSmartObjectHandler::GetRequestCandidates(const FMassSmartObjectRequestID& RequestID) const
{
	const FMassEntityHandle RequestEntity = static_cast<FMassEntityHandle>(RequestID);
	if (!ensureMsgf(EntityManager.IsEntityValid(RequestEntity), TEXT("Invalid request.")))
	{
		return nullptr;
	}

	// Check if entity is built by now.
	if (!EntityManager.IsEntityBuilt(RequestEntity))
	{
		return nullptr;
	}

	const FMassSmartObjectRequestResultFragment& RequestFragment = EntityManager.GetFragmentDataChecked<FMassSmartObjectRequestResultFragment>(RequestEntity);

	return RequestFragment.bProcessed ? &RequestFragment.Candidates : nullptr;
}

void FMassSmartObjectHandler::RemoveRequest(const FMassSmartObjectRequestID& RequestID) const
{
	const FMassEntityHandle RequestEntity = static_cast<FMassEntityHandle>(RequestID);
	ExecutionContext.Defer().DestroyEntity(RequestEntity);
}

FSmartObjectClaimHandle FMassSmartObjectHandler::ClaimCandidate(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const FMassSmartObjectCandidateSlots& Candidates, ESmartObjectClaimPriority ClaimPriority) const
{
	checkf(!User.InteractionHandle.IsValid(), TEXT("User should not already have an interaction."));
	
	const TConstArrayView<FSmartObjectCandidateSlot> View = MakeArrayView(Candidates.Slots.GetData(), Candidates.NumSlots);

	FSmartObjectClaimHandle ClaimedSlot;
	
	for (const FSmartObjectCandidateSlot& CandidateSlot : View)
	{
		ClaimedSlot = ClaimSmartObject(Entity, User, CandidateSlot.Result, ClaimPriority);  
		if (ClaimedSlot.IsValid())
		{
#if WITH_MASSGAMEPLAY_DEBUG
			UE_CVLOG(UE::Mass::Debug::IsDebuggingEntity(Entity),
				&SmartObjectSubsystem,
				LogSmartObject,
				Log,
				TEXT("[%s] claimed [%s]"),
				*Entity.DebugGetDescription(),
				*LexToString(CandidateSlot.Result));
#endif // WITH_MASSGAMEPLAY_DEBUG
			break;
		}
	}

	return ClaimedSlot;
}

FSmartObjectClaimHandle FMassSmartObjectHandler::ClaimSmartObject(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const FSmartObjectRequestResult& RequestResult, ESmartObjectClaimPriority ClaimPriority) const
{
	const FSmartObjectClaimHandle ClaimHandle = SmartObjectSubsystem.MarkSlotAsClaimed(RequestResult.SlotHandle, ClaimPriority, FConstStructView::Make(FSmartObjectMassEntityUserData(Entity)));

#if WITH_MASSGAMEPLAY_DEBUG
	UE_CVLOG(UE::Mass::Debug::IsDebuggingEntity(Entity),
		&SmartObjectSubsystem,
		LogSmartObject,
		Log,
		TEXT("[%s] claim for [%s] %s"),
		*Entity.DebugGetDescription(),
		*LexToString(RequestResult),
		ClaimHandle.IsValid() ? TEXT("Succeeded") : TEXT("Failed"));
#endif // WITH_MASSGAMEPLAY_DEBUG

	// Register callback to abort interaction if slot gets invalidated.
	// Callback will be unregistered by UMassSmartObjectUserFragmentDeinitializer
	UE::Mass::SmartObject::FPayload Payload;
	Payload.Entity = Entity;
	Payload.EntityManager = EntityManager.AsShared();
	Payload.SmartObjectSubsystem = &SmartObjectSubsystem;
	Payload.SignalSubsystem = &SignalSubsystem;
	SmartObjectSubsystem.RegisterSlotInvalidationCallback(ClaimHandle, FOnSlotInvalidated::CreateStatic(&UE::Mass::SmartObject::OnSlotInvalidated, Payload));
	
	return ClaimHandle;
}

bool FMassSmartObjectHandler::StartUsingSmartObject(
	const FMassEntityHandle Entity,
	FMassSmartObjectUserFragment& User,
	const FSmartObjectClaimHandle ClaimHandle) const
{
#if WITH_MASSGAMEPLAY_DEBUG
	UE_CVLOG(UE::Mass::Debug::IsDebuggingEntity(Entity),
		&SmartObjectSubsystem,
		LogSmartObject,
		Log,
		TEXT("[%s] starts using [%s]"),
		*Entity.DebugGetDescription(),
		*LexToString(User.InteractionHandle));
#endif // WITH_MASSGAMEPLAY_DEBUG

	const USmartObjectMassBehaviorDefinition* BehaviorDefinition = SmartObjectSubsystem.MarkSlotAsOccupied<USmartObjectMassBehaviorDefinition>(ClaimHandle);
	if (BehaviorDefinition == nullptr)
	{
		return false;
	}

	User.InteractionStatus = EMassSmartObjectInteractionStatus::InProgress;
	User.InteractionHandle = ClaimHandle;

	// Activate behavior
	const FMassEntityView EntityView(EntityManager, Entity);
	const FMassBehaviorEntityContext Context(EntityView, SmartObjectSubsystem);
	BehaviorDefinition->Activate(ExecutionContext.Defer(), Context);

	return true;
}


void FMassSmartObjectHandler::StopUsingSmartObject(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const EMassSmartObjectInteractionStatus NewStatus) const
{
#if WITH_MASSGAMEPLAY_DEBUG
	UE_CVLOG(UE::Mass::Debug::IsDebuggingEntity(Entity),
		&SmartObjectSubsystem,
		LogSmartObject,
		Log,
		TEXT("[%s] releases handle [%s]"),
		*Entity.DebugGetDescription(),
		*LexToString(User.InteractionHandle));
#endif // WITH_MASSGAMEPLAY_DEBUG

#if DO_ENSURE
	const EMassSmartObjectInteractionStatus CurrentStatus = User.InteractionStatus;

	switch (CurrentStatus)
	{
	case EMassSmartObjectInteractionStatus::Unset:
		ensureMsgf(NewStatus == EMassSmartObjectInteractionStatus::Unset,
			TEXT("Not expecting new status for inactive interaction. Received %s"),
			*UEnum::GetValueAsString(NewStatus));
		break;

	case EMassSmartObjectInteractionStatus::InProgress:
		ensureMsgf(NewStatus == EMassSmartObjectInteractionStatus::BehaviorCompleted
			|| NewStatus == EMassSmartObjectInteractionStatus::TaskCompleted
			|| NewStatus == EMassSmartObjectInteractionStatus::Aborted,
			TEXT("Expecting status 'BehaviorCompleted', 'TaskCompleted' or 'Aborted' for in progress interaction. Received %s"),
			*UEnum::GetValueAsString(NewStatus));
		break;

	case EMassSmartObjectInteractionStatus::BehaviorCompleted:
		ensureMsgf(NewStatus == EMassSmartObjectInteractionStatus::TaskCompleted || NewStatus == EMassSmartObjectInteractionStatus::Aborted,
			TEXT("Expecting status 'TaskCompleted' or 'Aborted' for 'BehaviorCompleted' interaction. Received %s"),
			*UEnum::GetValueAsString(NewStatus));
		break;

	case EMassSmartObjectInteractionStatus::TaskCompleted:
	case EMassSmartObjectInteractionStatus::Aborted:
		ensureMsgf(false, TEXT("Not expecting status changes for'Completed' or 'Aborted' interaction. Current %s - Received %s"),
			*UEnum::GetValueAsString(CurrentStatus),
			*UEnum::GetValueAsString(NewStatus));
		break;

	default:
		ensureMsgf(false, TEXT("Unhandled state: %s"), *UEnum::GetValueAsString(NewStatus));
	}
#endif

	const FMassEntityView EntityView(EntityManager, Entity);
	const FMassBehaviorEntityContext Context(EntityView, SmartObjectSubsystem);
	UE::Mass::SmartObject::StopInteraction(ExecutionContext.Defer(), Context, User.InteractionHandle, NewStatus);
}


void FMassSmartObjectHandler::ReleaseSmartObject(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const FSmartObjectClaimHandle ClaimHandle) const
{
#if WITH_MASSGAMEPLAY_DEBUG
	UE_CVLOG(UE::Mass::Debug::IsDebuggingEntity(Entity),
		&SmartObjectSubsystem,
		LogSmartObject,
		Log,
		TEXT("[%s] releases handle [%s]"),
		*Entity.DebugGetDescription(),
		*LexToString(User.InteractionHandle));
#endif // WITH_MASSGAMEPLAY_DEBUG

#if DO_ENSURE
	if (User.InteractionStatus == EMassSmartObjectInteractionStatus::InProgress)
	{
		ensureMsgf(false, TEXT("Expecting interaction to be compled before releasing the SmartObject. Current state %s"), *UEnum::GetValueAsString(User.InteractionStatus));
	}
#endif

	const FMassEntityView EntityView(EntityManager, Entity);
	const FMassBehaviorEntityContext Context(EntityView, SmartObjectSubsystem);

	SmartObjectSubsystem.UnregisterSlotInvalidationCallback(ClaimHandle);

	Context.SmartObjectSubsystem.MarkSlotAsFree(ClaimHandle);
}

==================================================================


=== Source/MassSmartObjects/Private/MassSmartObjectProcessor.cpp ===
====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSmartObjectProcessor.h"
#include "MassCommandBuffer.h"
#include "MassCommonTypes.h"
#include "MassDebugger.h"
#include "MassExecutionContext.h"
#include "MassGameplayExternalTraits.h"
#include "MassSignalSubsystem.h"
#include "MassSmartObjectBehaviorDefinition.h"
#include "MassSmartObjectFragments.h"
#include "MassSmartObjectRequest.h"
#include "MassSmartObjectSettings.h"
#include "MassSmartObjectTypes.h"
#include "Misc/ScopeExit.h"
#include "SmartObjectOctree.h"
#include "SmartObjectSubsystem.h"
#include "SmartObjectZoneAnnotations.h"
#include "VisualLogger/VisualLogger.h"
#include "ZoneGraphAnnotationSubsystem.h"
#include "ZoneGraphSubsystem.h"


//----------------------------------------------------------------------//
// UMassSmartObjectCandidatesFinderProcessor
//----------------------------------------------------------------------//
void UMassSmartObjectCandidatesFinderProcessor::ConfigureQueries()
{
	WorldRequestQuery.AddRequirement<FMassSmartObjectWorldLocationRequestFragment>(EMassFragmentAccess::ReadOnly);
	WorldRequestQuery.AddRequirement<FMassSmartObjectRequestResultFragment>(EMassFragmentAccess::ReadWrite);
	WorldRequestQuery.AddTagRequirement<FMassSmartObjectCompletedRequestTag>(EMassFragmentPresence::None);
	WorldRequestQuery.AddSubsystemRequirement<USmartObjectSubsystem>(EMassFragmentAccess::ReadOnly);
	WorldRequestQuery.RegisterWithProcessor(*this);

	LaneRequestQuery.AddRequirement<FMassSmartObjectLaneLocationRequestFragment>(EMassFragmentAccess::ReadOnly);
	LaneRequestQuery.AddRequirement<FMassSmartObjectRequestResultFragment>(EMassFragmentAccess::ReadWrite);
	LaneRequestQuery.AddTagRequirement<FMassSmartObjectCompletedRequestTag>(EMassFragmentPresence::None);
	LaneRequestQuery.AddSubsystemRequirement<UZoneGraphSubsystem>(EMassFragmentAccess::ReadOnly);
	LaneRequestQuery.AddSubsystemRequirement<USmartObjectSubsystem>(EMassFragmentAccess::ReadOnly);
	LaneRequestQuery.RegisterWithProcessor(*this);

	ProcessorRequirements.AddSubsystemRequirement<UMassSignalSubsystem>(EMassFragmentAccess::ReadWrite);
	ProcessorRequirements.AddSubsystemRequirement<UZoneGraphAnnotationSubsystem>(EMassFragmentAccess::ReadOnly);
}

UMassSmartObjectCandidatesFinderProcessor::UMassSmartObjectCandidatesFinderProcessor()
	: WorldRequestQuery(*this)
	, LaneRequestQuery(*this)
{
	// 1. Frame T Behavior create a request(deferred entity creation)
	// 2. Frame T+1: Processor execute the request might mark it as done(deferred add tag flushed at the end of the frame)
	// 3. Frame T+1: Behavior could cancel request(deferred destroy entity)
	// If the processor does not run before the behaviors, step 2 and 3 are flipped and it will crash while flushing the deferred commands
	ExecutionOrder.ExecuteBefore.Add(UE::Mass::ProcessorGroupNames::Behavior);
}

void UMassSmartObjectCandidatesFinderProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	UMassSignalSubsystem& SignalSubsystem = Context.GetMutableSubsystemChecked<UMassSignalSubsystem>();
	const UZoneGraphAnnotationSubsystem& AnnotationSubsystem = Context.GetSubsystemChecked<UZoneGraphAnnotationSubsystem>();
	
	// Create filter
	FSmartObjectRequestFilter Filter;
	Filter.BehaviorDefinitionClasses = { USmartObjectMassBehaviorDefinition::StaticClass() };

	// Build list of request owner entities to send a completion signal
	TArray<FMassEntityHandle> EntitiesToSignal;

	auto BeginRequestProcessing = [](const FMassEntityHandle Entity, FMassExecutionContext& Context, FMassSmartObjectRequestResultFragment& Result)
	{
		Context.Defer().AddTag<FMassSmartObjectCompletedRequestTag>(Entity);
		Result.Candidates.NumSlots = 0;
	};

	auto EndRequestProcessing = [](const UObject* LogOwner, const FMassEntityHandle Entity, FMassSmartObjectRequestResultFragment& Result)
	{
		if (Result.Candidates.NumSlots > 0)
		{
			TArrayView<FSmartObjectCandidateSlot> View = MakeArrayView(Result.Candidates.Slots.GetData(), Result.Candidates.NumSlots);
			Algo::Sort(View, [](const FSmartObjectCandidateSlot& LHS, const FSmartObjectCandidateSlot& RHS) { return LHS.Cost < RHS.Cost; });
		}
		Result.bProcessed = true;

#if WITH_MASSGAMEPLAY_DEBUG
		UE_VLOG(LogOwner, LogSmartObject, Verbose, TEXT("[%s] search completed: found %d"), *Entity.DebugGetDescription(), Result.Candidates.NumSlots);
#endif // WITH_MASSGAMEPLAY_DEBUG
	};

	// Process world location based requests
	WorldRequestQuery.ForEachEntityChunk(EntityManager, Context, [this, &Filter, &EntitiesToSignal, &BeginRequestProcessing, &EndRequestProcessing](FMassExecutionContext& Context)
	{
		const USmartObjectSubsystem& SmartObjectSubsystem = Context.GetSubsystemChecked<USmartObjectSubsystem>();

		const int32 NumEntities = Context.GetNumEntities();
		EntitiesToSignal.Reserve(EntitiesToSignal.Num() + NumEntities);

		const TConstArrayView<FMassSmartObjectWorldLocationRequestFragment> RequestList = Context.GetFragmentView<FMassSmartObjectWorldLocationRequestFragment>();
		const TArrayView<FMassSmartObjectRequestResultFragment> ResultList = Context.GetMutableFragmentView<FMassSmartObjectRequestResultFragment>();

		TArray<FSmartObjectRequestResult> QueryResults;
		TArray<FSmartObjectCandidateSlot> SortedCandidateSlots;

		for (int32 i = 0; i < NumEntities; ++i)
		{
			const FMassSmartObjectWorldLocationRequestFragment& RequestFragment = RequestList[i];
			FMassSmartObjectRequestResultFragment& Result = ResultList[i];
			
			EntitiesToSignal.Add(RequestFragment.RequestingEntity);

			const FVector& SearchOrigin = RequestFragment.SearchOrigin;
			const FBox& SearchBounds = FBox::BuildAABB(SearchOrigin, FVector(SearchExtents));

			const FMassEntityHandle Entity = Context.GetEntity(i);
			bool bDisplayDebug = false;
			FColor DebugColor(FColor::White);

#if WITH_MASSGAMEPLAY_DEBUG
			bDisplayDebug = UE::Mass::Debug::IsDebuggingEntity(Entity, &DebugColor);
#endif // WITH_MASSGAMEPLAY_DEBUG

			BeginRequestProcessing(Entity, Context, Result);
			ON_SCOPE_EXIT{ EndRequestProcessing(&SmartObjectSubsystem, Entity, Result);	};

			Filter.UserTags = RequestFragment.UserTags;
			Filter.ActivityRequirements = RequestFragment.ActivityRequirements;
			
			QueryResults.Reset();
			SmartObjectSubsystem.FindSmartObjects(FSmartObjectRequest(SearchBounds, Filter), QueryResults);

			SortedCandidateSlots.Reset(QueryResults.Num());
			for (const FSmartObjectRequestResult& QueryResult : QueryResults)
			{
				const FVector SlotLocation = SmartObjectSubsystem.GetSlotLocation(QueryResult.SlotHandle).GetValue();
				SortedCandidateSlots.Emplace(QueryResult, UE_REAL_TO_FLOAT_CLAMPED_MAX(FVector::DistSquared(SearchOrigin, SlotLocation)));

#if WITH_MASSGAMEPLAY_DEBUG
				if (bDisplayDebug)
				{
					constexpr uint16 DebugRadius = 10;
					UE_VLOG_LOCATION(&SmartObjectSubsystem, LogSmartObject, Display, SlotLocation, DebugRadius, DebugColor, TEXT("%s"), *LexToString(QueryResult.SmartObjectHandle));
					UE_VLOG_SEGMENT(&SmartObjectSubsystem, LogSmartObject, Display, SearchOrigin, SlotLocation, DebugColor, TEXT(""));
				}
#endif // WITH_MASSGAMEPLAY_DEBUG
			}
			SortedCandidateSlots.Sort([](const FSmartObjectCandidateSlot& First, const FSmartObjectCandidateSlot& Second){ return First.Cost < Second.Cost; });

			Result.Candidates.NumSlots = IntCastChecked<uint8>(FMath::Min(FMassSmartObjectCandidateSlots::MaxNumCandidates, (uint32)SortedCandidateSlots.Num()));
			for (int ResultIndex = 0; ResultIndex < Result.Candidates.NumSlots; ResultIndex++)
			{
				Result.Candidates.Slots[ResultIndex] = SortedCandidateSlots[ResultIndex];
			}
		}
	});

	// Process lane based requests
	const FZoneGraphTag SmartObjectTag = GetDefault<UMassSmartObjectSettings>()->SmartObjectTag;
	USmartObjectZoneAnnotations* Annotations = Cast<USmartObjectZoneAnnotations>(AnnotationSubsystem.GetFirstAnnotationForTag(SmartObjectTag));

	LaneRequestQuery.ForEachEntityChunk(EntityManager, Context,
		[&AnnotationSubsystem, Annotations, &Filter, SmartObjectTag, &EntitiesToSignal, &BeginRequestProcessing, &EndRequestProcessing](FMassExecutionContext& Context)
		{
#if WITH_MASSGAMEPLAY_DEBUG
			const UZoneGraphSubsystem& ZoneGraphSubsystem = Context.GetSubsystemChecked<UZoneGraphSubsystem>();
#endif // WITH_MASSGAMEPLAY_DEBUG
			const USmartObjectSubsystem& SmartObjectSubsystem = Context.GetSubsystemChecked<USmartObjectSubsystem>();

			const int32 NumEntities = Context.GetNumEntities();
			EntitiesToSignal.Reserve(EntitiesToSignal.Num() + NumEntities);

			TConstArrayView<FMassSmartObjectLaneLocationRequestFragment> RequestList = Context.GetFragmentView<FMassSmartObjectLaneLocationRequestFragment>();
			TArrayView<FMassSmartObjectRequestResultFragment> ResultList = Context.GetMutableFragmentView<FMassSmartObjectRequestResultFragment>();

			// Cache latest used data since request are most of the time on the same zone graph
			FZoneGraphDataHandle LastUsedDataHandle;
			const FSmartObjectAnnotationData* GraphData = nullptr;

			for (int32 i = 0; i < NumEntities; ++i)
			{
				const FMassSmartObjectLaneLocationRequestFragment& RequestFragment = RequestList[i];
				FMassSmartObjectRequestResultFragment& Result = ResultList[i];
				
				EntitiesToSignal.Add(RequestFragment.RequestingEntity);

				const FZoneGraphCompactLaneLocation RequestLocation = RequestFragment.CompactLaneLocation;
				const FZoneGraphLaneHandle RequestLaneHandle = RequestLocation.LaneHandle;

				const FMassEntityHandle Entity = Context.GetEntity(i);
				bool bDisplayDebug = false;
#if WITH_MASSGAMEPLAY_DEBUG
				FColor DebugColor(FColor::White);
				bDisplayDebug = UE::Mass::Debug::IsDebuggingEntity(Entity, &DebugColor);
#endif // WITH_MASSGAMEPLAY_DEBUG

				BeginRequestProcessing(Entity, Context, Result);
				ON_SCOPE_EXIT{ EndRequestProcessing(&SmartObjectSubsystem, Entity, Result); };

				if (!ensureMsgf(RequestLaneHandle.IsValid(), TEXT("Requesting smart objects using an invalid handle")))
				{
					continue;
				}

				if (Annotations == nullptr)
				{
					UE_VLOG(&SmartObjectSubsystem, LogSmartObject, Warning, TEXT("%d lane location based requests failed since SmartObject annotations are not available"), NumEntities);
					return;
				}

				// Fetch smart object data associated to the current graph if different than last used one
				if (LastUsedDataHandle != RequestLaneHandle.DataHandle)
				{
					LastUsedDataHandle = RequestLaneHandle.DataHandle;
					GraphData = Annotations->GetAnnotationData(RequestLaneHandle.DataHandle);
				}

				if (GraphData == nullptr)
				{
					continue;
				}

				// Fetch current annotations for the specified lane and look for the smart object tag
				const FZoneGraphTagMask LaneMask = AnnotationSubsystem.GetAnnotationTags(RequestLaneHandle);
				if (!LaneMask.Contains(SmartObjectTag))
				{
					continue;
				}

				const FSmartObjectLaneLocationIndices* SmartObjectList = GraphData->LaneToLaneLocationIndicesLookup.Find(RequestLaneHandle.Index);
				if (SmartObjectList == nullptr || !ensureMsgf(SmartObjectList->SmartObjectLaneLocationIndices.Num() > 0, TEXT("Lookup table should only contains lanes with one or more associated object(s).")))
				{
					continue;
				}

				Filter.UserTags = RequestFragment.UserTags;
				Filter.ActivityRequirements = RequestFragment.ActivityRequirements;

				for (const int32 Index : SmartObjectList->SmartObjectLaneLocationIndices)
				{
					// Find entry point using FindChecked since all smart objects added to LaneToSmartObjects lookup table
					// were also added to the entry point lookup table
					check(GraphData->SmartObjectLaneLocations.IsValidIndex(Index));
					const FSmartObjectLaneLocation& EntryPoint = GraphData->SmartObjectLaneLocations[Index];
					const FSmartObjectHandle Handle = EntryPoint.ObjectHandle;

					float Cost = 0.f;
					if (ensureMsgf(EntryPoint.LaneIndex == RequestLocation.LaneHandle.Index, TEXT("Must be on same lane to be able to use distance along lane.")))
					{
						// Only consider object ahead
						const float DistAhead = EntryPoint.DistanceAlongLane - RequestLocation.DistanceAlongLane;
						if (DistAhead < 0)
						{
							continue;
						}
						Cost = DistAhead;
					}

					// Make sure that we can use a slot in that object (availability with supported definitions, etc.)
					TArray<FSmartObjectSlotHandle> SlotHandles;
					SmartObjectSubsystem.FindSlots(Handle, Filter, SlotHandles, FConstStructView::Make(FSmartObjectMassEntityUserData(Entity)));

					if (SlotHandles.IsEmpty())
					{
						continue;
					}

					for (FSmartObjectSlotHandle SlotHandle : SlotHandles)
					{
						Result.Candidates.Slots[Result.Candidates.NumSlots++] = FSmartObjectCandidateSlot(FSmartObjectRequestResult(Handle, SlotHandle), Cost);

#if WITH_MASSGAMEPLAY_DEBUG
						if (bDisplayDebug)
						{
							FZoneGraphLaneLocation RequestLaneLocation, EntryPointLaneLocation;
							ZoneGraphSubsystem.CalculateLocationAlongLane(RequestLaneHandle, RequestLocation.DistanceAlongLane, RequestLaneLocation);
							ZoneGraphSubsystem.CalculateLocationAlongLane(RequestLaneHandle, EntryPoint.DistanceAlongLane, EntryPointLaneLocation);

							constexpr uint16 DebugRadius = 10;
							FVector SlotLocation = SmartObjectSubsystem.GetSlotLocation(SlotHandle).Get(EntryPointLaneLocation.Position);
							UE_VLOG_LOCATION(&SmartObjectSubsystem, LogSmartObject, Display, SlotLocation, DebugRadius, DebugColor, TEXT("%s"), *LexToString(SlotHandle));
							UE_VLOG_SEGMENT(&SmartObjectSubsystem, LogSmartObject, Display, SlotLocation, EntryPointLaneLocation.Position, DebugColor, TEXT(""));
							UE_VLOG_SEGMENT(&SmartObjectSubsystem, LogSmartObject, Display, RequestLaneLocation.Position, EntryPointLaneLocation.Position, DebugColor, TEXT(""));
						}
#endif // WITH_MASSGAMEPLAY_DEBUG
						if (Result.Candidates.NumSlots == FMassSmartObjectCandidateSlots::MaxNumCandidates)
						{
							break;
						}
					}

					if (Result.Candidates.NumSlots == FMassSmartObjectCandidateSlots::MaxNumCandidates)
					{
						break;
					}
				}
			}
		});

	// Signal entities that their search results are ready
	if (EntitiesToSignal.Num())
	{
		SignalSubsystem.SignalEntities(UE::Mass::Signals::SmartObjectCandidatesReady, EntitiesToSignal);
	}
}

//----------------------------------------------------------------------//
// UMassSmartObjectTimedBehaviorProcessor
//----------------------------------------------------------------------//
void UMassSmartObjectTimedBehaviorProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FMassSmartObjectUserFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FMassSmartObjectTimedBehaviorFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddSubsystemRequirement<USmartObjectSubsystem>(EMassFragmentAccess::ReadOnly);

	ProcessorRequirements.AddSubsystemRequirement<UMassSignalSubsystem>(EMassFragmentAccess::ReadWrite);
}

UMassSmartObjectTimedBehaviorProcessor::UMassSmartObjectTimedBehaviorProcessor()
	: EntityQuery(*this)
{
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::SyncWorldToMass;
}

void UMassSmartObjectTimedBehaviorProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	TArray<FMassEntityHandle> ToRelease;

	QUICK_SCOPE_CYCLE_COUNTER(UMassProcessor_SmartObjectTestBehavior_Run);

	EntityQuery.ForEachEntityChunk(EntityManager, Context, [this, &ToRelease](FMassExecutionContext& Context)
	{
		const USmartObjectSubsystem& SmartObjectSubsystem = Context.GetSubsystemChecked<USmartObjectSubsystem>();

		const int32 NumEntities = Context.GetNumEntities();
		const TArrayView<FMassSmartObjectUserFragment> UserList = Context.GetMutableFragmentView<FMassSmartObjectUserFragment>();
		const TArrayView<FMassSmartObjectTimedBehaviorFragment> TimedBehaviorFragments = Context.GetMutableFragmentView<FMassSmartObjectTimedBehaviorFragment>();

		for (int32 i = 0; i < NumEntities; ++i)
		{
			FMassSmartObjectUserFragment& SOUser = UserList[i];
			FMassSmartObjectTimedBehaviorFragment& TimedBehaviorFragment = TimedBehaviorFragments[i];
			ensureMsgf(SOUser.InteractionStatus == EMassSmartObjectInteractionStatus::InProgress, TEXT("TimedBehavior fragment should only be present for in-progress interactions: %s"), *Context.GetEntity(i).DebugGetDescription());

			const float DT = Context.GetDeltaTimeSeconds();
			float& UseTime = TimedBehaviorFragment.UseTime;
			UseTime = FMath::Max(UseTime - DT, 0.0f);
			const bool bMustRelease = UseTime <= 0.f;

#if WITH_MASSGAMEPLAY_DEBUG
			const FMassEntityHandle Entity = Context.GetEntity(i);
			FColor DebugColor(FColor::White);
			const bool bIsDebuggingEntity = UE::Mass::Debug::IsDebuggingEntity(Entity, &DebugColor);
			if (bIsDebuggingEntity)
			{
				UE_CVLOG(bMustRelease, &SmartObjectSubsystem, LogSmartObject, Log, TEXT("[%s] stops using [%s]"), *Entity.DebugGetDescription(), *LexToString(SOUser.InteractionHandle));
				UE_CVLOG(!bMustRelease, &SmartObjectSubsystem, LogSmartObject, Verbose, TEXT("[%s] using [%s]. Time left: %.1f"), *Entity.DebugGetDescription(), *LexToString(SOUser.InteractionHandle), UseTime);

				const TOptional<FTransform> Transform = SmartObjectSubsystem.GetSlotTransform(SOUser.InteractionHandle);
				if (Transform.IsSet())
				{
					constexpr float Radius = 40.f;
					const FVector HalfHeightOffset(0.f, 0.f, 100.f);
					const FVector Pos = Transform.GetValue().GetLocation();
					const FVector Dir = Transform.GetValue().GetRotation().GetForwardVector();
					UE_VLOG_CYLINDER(&SmartObjectSubsystem, LogSmartObject, Display, Pos - HalfHeightOffset, Pos + HalfHeightOffset, Radius, DebugColor, TEXT(""));
					UE_VLOG_ARROW(&SmartObjectSubsystem, LogSmartObject, Display, Pos, Pos + Dir * 2.0f * Radius, DebugColor, TEXT(""));
				}
			}
#endif // WITH_MASSGAMEPLAY_DEBUG

			if (bMustRelease)
			{
				SOUser.InteractionStatus = EMassSmartObjectInteractionStatus::BehaviorCompleted;
				ToRelease.Add(Context.GetEntity(i));
			}
		}
	});

	if (ToRelease.Num())
	{
		UMassSignalSubsystem& SignalSubsystem = Context.GetMutableSubsystemChecked<UMassSignalSubsystem>();
		SignalSubsystem.SignalEntities(UE::Mass::Signals::SmartObjectInteractionDone, ToRelease);
	}
}

//----------------------------------------------------------------------//
//  UMassSmartObjectUserFragmentDeinitializer
//----------------------------------------------------------------------//
UMassSmartObjectUserFragmentDeinitializer::UMassSmartObjectUserFragmentDeinitializer()
	: EntityQuery(*this)
{
	ObservedType = FMassSmartObjectUserFragment::StaticStruct();
	Operation = EMassObservedOperation::Remove;
	ExecutionFlags = (int32)EProcessorExecutionFlags::AllNetModes;
}

void UMassSmartObjectUserFragmentDeinitializer::ConfigureQueries()
{
	EntityQuery.AddRequirement<FMassSmartObjectUserFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddSubsystemRequirement<USmartObjectSubsystem>(EMassFragmentAccess::ReadWrite);
}

void UMassSmartObjectUserFragmentDeinitializer::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
		{
			USmartObjectSubsystem& SmartObjectSubsystem = Context.GetMutableSubsystemChecked<USmartObjectSubsystem>();
			const int32 NumEntities = Context.GetNumEntities();
			const TArrayView<FMassSmartObjectUserFragment> SmartObjectUserFragments = Context.GetMutableFragmentView<FMassSmartObjectUserFragment>();

			for (int32 i = 0; i < NumEntities; ++i)
			{
				SmartObjectSubsystem.UnregisterSlotInvalidationCallback(SmartObjectUserFragments[i].InteractionHandle);
			}
		});
}
====================================================================


=== Source/MassSmartObjects/Private/MassSmartObjectRegistration.cpp ===
=======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSmartObjectRegistration.h"

#include "MassActorSubsystem.h"
#include "MassCommonFragments.h"
#include "MassGameplayExternalTraits.h" // required for USmartObjectSubsystem trait (i.e. TMassExternalSubsystemTraits<USmartObjectSubsystem>)
#include "MassExecutionContext.h"
#include "MassSignalSubsystem.h"
#include "SmartObjectSubsystem.h"

namespace UE::Mass::Signals
{
	const FName SmartObjectActivationChanged = FName(TEXT("SmartObjectActivated"));
}

//----------------------------------------------------------------------//
// UMassSmartObjectInitializerBase
//----------------------------------------------------------------------//
UMassSmartObjectInitializerBase::UMassSmartObjectInitializerBase()
	: EntityQuery(*this)
{
	ExecutionFlags = static_cast<int32>(EProcessorExecutionFlags::Standalone | EProcessorExecutionFlags::Server);
	Operation = EMassObservedOperation::Add;
}

void UMassSmartObjectInitializerBase::ConfigureQueries()
{
	ProcessorRequirements.AddSubsystemRequirement<UMassSignalSubsystem>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddTagRequirement<FMassInActiveSmartObjectsRangeTag>(EMassFragmentPresence::All);
	EntityQuery.AddRequirement<FMassActorInstanceFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FSmartObjectRegistrationFragment>(EMassFragmentAccess::ReadWrite);
}

void UMassSmartObjectInitializerBase::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	UMassSignalSubsystem& SignalSubsystem = Context.GetMutableSubsystemChecked<UMassSignalSubsystem>();
	TArray<FMassEntityHandle> EntitiesToSignal;

	EntityQuery.ForEachEntityChunk(EntityManager, Context,[&EntitiesToSignal](FMassExecutionContext& Context)
	{
		const TConstArrayView<FMassActorInstanceFragment> InstancedActorFragments = Context.GetFragmentView<FMassActorInstanceFragment>();
		const TArrayView<FSmartObjectRegistrationFragment> RegistrationFragments = Context.GetMutableFragmentView<FSmartObjectRegistrationFragment>();

		const int32 NumEntities = Context.GetNumEntities();
		EntitiesToSignal.Reserve(EntitiesToSignal.Num() + NumEntities);

		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			FSmartObjectRegistrationFragment& RegistrationFragment = RegistrationFragments[EntityIndex];
			const FMassActorInstanceFragment& InstancedActorFragment = InstancedActorFragments[EntityIndex];

			checkf(!RegistrationFragment.Handle.IsValid(), TEXT("Should create smartobject only once."))
			if (RegistrationFragment.Asset.Get() == nullptr)
			{
				continue;
			}

			if (!InstancedActorFragment.Handle.IsValid())
			{
				continue;
			}

			EntitiesToSignal.Add(Context.GetEntity(EntityIndex));
		}
	});

	// Signal all entities inside the consolidated list
	if (EntitiesToSignal.Num())
	{
		SignalSubsystem.SignalEntities(Signal, EntitiesToSignal);
	}
}

//----------------------------------------------------------------------//
// UMassSmartObjectDeinitializerBase
//----------------------------------------------------------------------//
UMassSmartObjectDeinitializerBase::UMassSmartObjectDeinitializerBase()
	: EntityQuery(*this)
{
	ExecutionFlags = static_cast<int32>(EProcessorExecutionFlags::Standalone | EProcessorExecutionFlags::Server);
	Operation = EMassObservedOperation::Remove;
}

void UMassSmartObjectDeinitializerBase::ConfigureQueries()
{
	ProcessorRequirements.AddSubsystemRequirement<UMassSignalSubsystem>(EMassFragmentAccess::ReadWrite);
}

void UMassSmartObjectDeinitializerBase::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	UMassSignalSubsystem& SignalSubsystem = Context.GetMutableSubsystemChecked<UMassSignalSubsystem>();
	TArray<FMassEntityHandle> EntitiesToSignal;

	EntityQuery.ForEachEntityChunk(EntityManager, Context, [&EntitiesToSignal](FMassExecutionContext& Context)
	{
		const int32 NumEntities = Context.GetNumEntities();
		EntitiesToSignal.Reserve(EntitiesToSignal.Num() + NumEntities);
		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			EntitiesToSignal.Add(Context.GetEntity(EntityIndex));
		}
	});
	
	// Signal all entities inside the consolidated list
	if (EntitiesToSignal.Num())
	{
		SignalSubsystem.SignalEntities(Signal, EntitiesToSignal);
	}
}

//----------------------------------------------------------------------//
// UMassActiveSmartObjectInitializer
//----------------------------------------------------------------------//
UMassActiveSmartObjectInitializer::UMassActiveSmartObjectInitializer()
{
	ObservedType = FMassInActiveSmartObjectsRangeTag::StaticStruct();
	Signal = UE::Mass::Signals::SmartObjectActivationChanged;
}

//----------------------------------------------------------------------//
// UMassActiveSmartObjectDeinitializer
//----------------------------------------------------------------------//
UMassActiveSmartObjectDeinitializer::UMassActiveSmartObjectDeinitializer()
{
	ObservedType = FMassInActiveSmartObjectsRangeTag::StaticStruct();
	Signal = UE::Mass::Signals::SmartObjectActivationChanged;
}

//----------------------------------------------------------------------//
// UMassActorInstanceHandleInitializer
//----------------------------------------------------------------------//
UMassActorInstanceHandleInitializer::UMassActorInstanceHandleInitializer()
{
	ObservedType = FMassActorInstanceFragment::StaticStruct();
	Signal = UE::Mass::Signals::ActorInstanceHandleChanged;
}

//----------------------------------------------------------------------//
// UMassActorInstanceHandleDeinitializer
//----------------------------------------------------------------------//
UMassActorInstanceHandleDeinitializer::UMassActorInstanceHandleDeinitializer()
{
	ObservedType = FMassActorInstanceFragment::StaticStruct();
	Signal = UE::Mass::Signals::ActorInstanceHandleChanged;
}

//-----------------------------------------------------------------------------
// UMassActiveSmartObjectSignalProcessor
//-----------------------------------------------------------------------------
UMassActiveSmartObjectSignalProcessor::UMassActiveSmartObjectSignalProcessor()
	: InsideSmartObjectActiveRangeQuery(*this)
	, OutsideSmartObjectActiveRangeQuery(*this)
{
	// USmartObjectSubsystem CreateSmartObject/DestroySmartObject methods called
	// from this process are not safe to call from other threads.
	bRequiresGameThreadExecution = true;
}

void UMassActiveSmartObjectSignalProcessor::ConfigureQueries()
{
	InsideSmartObjectActiveRangeQuery.AddSubsystemRequirement<USmartObjectSubsystem>(EMassFragmentAccess::ReadWrite);
	InsideSmartObjectActiveRangeQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	InsideSmartObjectActiveRangeQuery.AddRequirement<FMassActorInstanceFragment>(EMassFragmentAccess::ReadOnly);
	InsideSmartObjectActiveRangeQuery.AddRequirement<FSmartObjectRegistrationFragment>(EMassFragmentAccess::ReadWrite);
	InsideSmartObjectActiveRangeQuery.AddTagRequirement<FMassInActiveSmartObjectsRangeTag>(EMassFragmentPresence::All);

	OutsideSmartObjectActiveRangeQuery.AddSubsystemRequirement<USmartObjectSubsystem>(EMassFragmentAccess::ReadWrite);
	OutsideSmartObjectActiveRangeQuery.AddRequirement<FSmartObjectRegistrationFragment>(EMassFragmentAccess::ReadWrite);
	OutsideSmartObjectActiveRangeQuery.AddTagRequirement<FMassInActiveSmartObjectsRangeTag>(EMassFragmentPresence::None);
}

void UMassActiveSmartObjectSignalProcessor::Initialize(UObject& Owner)
{
	Super::Initialize(Owner);

	UMassSignalSubsystem* SignalSubsystem = UWorld::GetSubsystem<UMassSignalSubsystem>(Owner.GetWorld());
	SubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::ActorInstanceHandleChanged);
	SubscribeToSignal(*SignalSubsystem, UE::Mass::Signals::SmartObjectActivationChanged);
}

void UMassActiveSmartObjectSignalProcessor::SignalEntities(FMassEntityManager& EntityManager, FMassExecutionContext& Context, FMassSignalNameLookup&)
{
	// Process entities in active range
	InsideSmartObjectActiveRangeQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
	{
		USmartObjectSubsystem& Subsystem = Context.GetMutableSubsystemChecked<USmartObjectSubsystem>();
		const TConstArrayView<FTransformFragment> TransformFragments = Context.GetFragmentView<FTransformFragment>();
		const TConstArrayView<FMassActorInstanceFragment> InstancedActorFragments = Context.GetFragmentView<FMassActorInstanceFragment>();
		const TArrayView<FSmartObjectRegistrationFragment> RegistrationFragments = Context.GetMutableFragmentView<FSmartObjectRegistrationFragment>();

		const int32 NumEntities = Context.GetNumEntities();
		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			FSmartObjectRegistrationFragment& RegistrationFragment = RegistrationFragments[EntityIndex];
			const FMassActorInstanceFragment& InstancedActorFragment = InstancedActorFragments[EntityIndex];
			const FTransformFragment& TransformFragment = TransformFragments[EntityIndex];

			// Creation
			if (!RegistrationFragment.Handle.IsValid() && InstancedActorFragment.Handle.IsValid())
			{
				if (const USmartObjectDefinition* Definition = RegistrationFragment.Asset.Get())
				{
					FSmartObjectActorOwnerData InstancedActorOwnerData(InstancedActorFragment.Handle);
					RegistrationFragment.Handle = Subsystem.CreateSmartObject(
						*Definition,
						TransformFragment.GetTransform(),
						FConstStructView::Make(InstancedActorOwnerData));
				}
			}
			// Destruction
			else if (RegistrationFragment.Handle.IsValid() && !InstancedActorFragment.Handle.IsValid())
			{
				Subsystem.DestroySmartObject(RegistrationFragment.Handle);
				RegistrationFragment.Handle.Invalidate();
			}
		}
	});

	// Process out of active range entities
	OutsideSmartObjectActiveRangeQuery.ForEachEntityChunk(EntityManager, Context, [this](FMassExecutionContext& Context)
	{
		USmartObjectSubsystem& Subsystem = Context.GetMutableSubsystemChecked<USmartObjectSubsystem>();
		const TArrayView<FSmartObjectRegistrationFragment> RegistrationFragments = Context.GetMutableFragmentView<FSmartObjectRegistrationFragment>();

		const int32 NumEntities = Context.GetNumEntities();
		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			FSmartObjectRegistrationFragment& RegistrationFragment = RegistrationFragments[EntityIndex];

			if (RegistrationFragment.Handle.IsValid())
			{
				Subsystem.DestroySmartObject(RegistrationFragment.Handle);
				RegistrationFragment.Handle.Invalidate();
			}
		}
	});
}

=======================================================================


=== Source/MassSmartObjects/Private/MassSmartObjectSettings.cpp ===
===================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSmartObjectSettings.h"

#if WITH_EDITOR
void UMassSmartObjectSettings::PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent)
{
	Super::PostEditChangeChainProperty(PropertyChangedEvent);

	FProperty* Property = PropertyChangedEvent.Property;
	FProperty* MemberProperty = nullptr;
	if (PropertyChangedEvent.PropertyChain.GetActiveMemberNode())
	{
		MemberProperty = PropertyChangedEvent.PropertyChain.GetActiveMemberNode()->GetValue();
	}

	if (MemberProperty != nullptr && Property != nullptr)
	{
		if (MemberProperty->GetFName() == GET_MEMBER_NAME_CHECKED(UMassSmartObjectSettings, SmartObjectTag))
		{
			OnAnnotationSettingsChanged.Broadcast();
		}
	}
}
#endif // WITH_EDITOR
===================================================================


=== Source/MassSmartObjects/Private/MassSmartObjectsModule.cpp ===
==================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "CoreMinimal.h"
#include "IMassSmartObjectsModule.h"
#include "UObject/CoreRedirects.h"

class FMassSmartObjectsModule : public IMassSmartObjectsModule
{
	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

IMPLEMENT_MODULE(FMassSmartObjectsModule, MassSmartObjects)



void FMassSmartObjectsModule::StartupModule()
{
	// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)
}


void FMassSmartObjectsModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}




==================================================================


=== Source/MassSmartObjects/Private/MassSmartObjectTypes.cpp ===
================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSmartObjectTypes.h"

================================================================


=== Source/MassSmartObjects/Private/MassSmartObjectUserTrait.cpp ===
====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSmartObjectUserTrait.h"

#include "MassSmartObjectFragments.h"
#include "MassEntityTemplateRegistry.h"

void UMassSmartObjectUserTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	FMassSmartObjectUserFragment SmartObjectUser;
	SmartObjectUser.UserTags = UserTags;
	
	BuildContext.AddFragment(FConstStructView::Make(SmartObjectUser));
}

====================================================================


=== Source/MassSmartObjects/Private/SmartObjectZoneAnnotations.cpp ===
======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "SmartObjectZoneAnnotations.h"
#include "MassSmartObjectSettings.h"
#include "SmartObjectComponent.h"
#include "SmartObjectSubsystem.h"
#include "ZoneGraphAnnotationSubsystem.h"
#include "ZoneGraphAnnotationTypes.h"
#include "ZoneGraphDelegates.h"
#include "ZoneGraphQuery.h"
#include "ZoneGraphSubsystem.h"
#include "GameFramework/Character.h"
#include "VisualLogger/VisualLogger.h"

void USmartObjectZoneAnnotations::PostSubsystemsInitialized()
{
	SmartObjectSubsystem = UWorld::GetSubsystem<USmartObjectSubsystem>(GetWorld());

#if WITH_EDITOR
	// Monitor collection changes to rebuild our lookup data
	if (SmartObjectSubsystem != nullptr)
	{
		OnMainCollectionChangedHandle = SmartObjectSubsystem->OnMainCollectionChanged.AddLambda([this]()
		{
			const UWorld* World = GetWorld();
			if (World != nullptr && !World->IsGameWorld())
			{
				RebuildForAllGraphs();
			}
		});

		OnMainCollectionDirtiedHandle = SmartObjectSubsystem->OnMainCollectionDirtied.AddLambda([this]()
		{
			const UWorld* World = GetWorld();
			if (World != nullptr && !World->IsGameWorld())
			{
				// Simply queue a rebuild request until we serialize the annotations.
				// This is to avoid large amount of rebuild triggered from SmartObjectComponents being constantly
				// unregistered/registered when modifying their properties (e.g. dragging the actor(s) in the level)
				bRebuildAllGraphsRequested = true;
				MarkPackageDirty();
			}
		});
	}

	const UMassSmartObjectSettings* MassSmartObjectSettings = GetDefault<UMassSmartObjectSettings>();
	BehaviorTag = MassSmartObjectSettings->SmartObjectTag;

	// Track density settings changes
	OnAnnotationSettingsChangedHandle = MassSmartObjectSettings->OnAnnotationSettingsChanged.AddLambda([this]()
	{
		BehaviorTag = GetDefault<UMassSmartObjectSettings>()->SmartObjectTag;
	});

	// Monitor zone graph changes to rebuild our lookup data
	OnGraphDataChangedHandle = UE::ZoneGraphDelegates::OnZoneGraphDataBuildDone.AddLambda([this](const FZoneGraphBuildData& BuildData)
	{
		RebuildForAllGraphs();
	});
#endif // WITH_EDITOR

	// Update our cached members before calling base class since it might call
	// PostZoneGraphDataAdded and we need to be all set.
	Super::PostSubsystemsInitialized();
}

void USmartObjectZoneAnnotations::PostZoneGraphDataAdded(const AZoneGraphData& ZoneGraphData)
{
	const FZoneGraphStorage& Storage = ZoneGraphData.GetStorage();
	const int32 Index = Storage.DataHandle.Index;

#if WITH_EDITOR
	if (Index >= SmartObjectAnnotationDataArray.Num())
	{
		SmartObjectAnnotationDataArray.SetNum(Index + 1);
	}
#endif

	checkf(SmartObjectAnnotationDataArray.IsValidIndex(Index), TEXT("In Editor should always resize when necessary and runtime should always have valid precomputed data."));
	FSmartObjectAnnotationData& Data = SmartObjectAnnotationDataArray[Index];
	if (!Data.IsValid())
	{
		Data.DataHandle = Storage.DataHandle;
	}

#if WITH_EDITOR
	// We don't rebuild for runtime world, we use precomputed data
	if (!ZoneGraphData.GetWorld()->IsGameWorld())
	{
		RebuildForSingleGraph(Data, Storage);
	}
#endif // WITH_EDITOR

	Data.bInitialTaggingCompleted = false;
}

void USmartObjectZoneAnnotations::PreZoneGraphDataRemoved(const AZoneGraphData& ZoneGraphData)
{
	const FZoneGraphStorage& Storage = ZoneGraphData.GetStorage();
	const int32 Index = Storage.DataHandle.Index;

	if (!SmartObjectAnnotationDataArray.IsValidIndex(Index))
	{
		return;
	}

	FSmartObjectAnnotationData& Data = SmartObjectAnnotationDataArray[Index];

	// We use precomputed data for runtime so we only mark it as not longer used
	if (ZoneGraphData.GetWorld()->IsGameWorld())
	{
		Data.DataHandle = {};
	}
	else
	{
		Data.Reset();
	}
}

FZoneGraphTagMask USmartObjectZoneAnnotations::GetAnnotationTags() const
{
	return FZoneGraphTagMask(BehaviorTag);
}

const FSmartObjectAnnotationData* USmartObjectZoneAnnotations::GetAnnotationData(const FZoneGraphDataHandle DataHandle) const
{
	const int32 Index = DataHandle.Index;
	if (!SmartObjectAnnotationDataArray.IsValidIndex(Index))
	{
		return nullptr;
	}

	return &SmartObjectAnnotationDataArray[Index];
}

TOptional<FSmartObjectLaneLocation> USmartObjectZoneAnnotations::GetSmartObjectLaneLocation(const FZoneGraphDataHandle DataHandle, const FSmartObjectHandle SmartObjectHandle) const
{
	TOptional<FSmartObjectLaneLocation> SmartObjectLaneLocation;
	if (const FSmartObjectAnnotationData* AnnotationData = GetAnnotationData(DataHandle))
	{
		const int32 Index = AnnotationData->SmartObjectToLaneLocationIndexLookup.FindChecked(SmartObjectHandle);
		if (AnnotationData->SmartObjectLaneLocations.IsValidIndex(Index))
		{
			SmartObjectLaneLocation = AnnotationData->SmartObjectLaneLocations[Index];
		}
	}
	return SmartObjectLaneLocation;
}

void USmartObjectZoneAnnotations::TickAnnotation(const float DeltaTime, FZoneGraphAnnotationTagContainer& BehaviorTagContainer)
{
	if (!BehaviorTag.IsValid())
	{
		return;
	}

	for (FSmartObjectAnnotationData& Data : SmartObjectAnnotationDataArray)
	{
		if (Data.bInitialTaggingCompleted || !Data.IsValid() || Data.SmartObjectToLaneLocationIndexLookup.IsEmpty())
		{
			continue;
		}

		// Apply tags
		TArrayView<FZoneGraphTagMask> LaneTags = BehaviorTagContainer.GetMutableAnnotationTagsForData(Data.DataHandle);
		for (const int32 LaneIndex : Data.AffectedLanes)
		{
			LaneTags[LaneIndex].Add(BehaviorTag);
		}

		Data.bInitialTaggingCompleted = true;
	}

#if UE_ENABLE_DEBUG_DRAWING
	MarkRenderStateDirty();
#endif // UE_ENABLE_DEBUG_DRAWING
}

#if UE_ENABLE_DEBUG_DRAWING
void USmartObjectZoneAnnotations::DebugDraw(FZoneGraphAnnotationSceneProxy* DebugProxy)
{
	UZoneGraphSubsystem* ZoneGraph = UWorld::GetSubsystem<UZoneGraphSubsystem>(GetWorld());
	if (ZoneGraph == nullptr)
	{
		return;
	}

	const FSmartObjectContainer& SmartObjectContainer = SmartObjectSubsystem->GetSmartObjectContainer();

	for (FSmartObjectAnnotationData& AnnotationData : SmartObjectAnnotationDataArray)
	{
		const FZoneGraphStorage* ZoneStorage = AnnotationData.DataHandle.IsValid() ? ZoneGraph->GetZoneGraphStorage(AnnotationData.DataHandle) : nullptr;
		if (ZoneStorage == nullptr)
		{
			continue;
		}

		for (const FSmartObjectCollectionEntry& Entry : SmartObjectContainer.GetEntries())
		{
			int32* Index = AnnotationData.SmartObjectToLaneLocationIndexLookup.Find(Entry.GetHandle());
			if (Index == nullptr)
			{
				continue;
			}
			const FSmartObjectLaneLocation& SOLaneLocation = AnnotationData.SmartObjectLaneLocations[*Index];

			const FVector& ObjectLocation = Entry.GetTransform().GetLocation();
			FZoneGraphLaneLocation EntryPointLocation;
			UE::ZoneGraph::Query::CalculateLocationAlongLane(*ZoneStorage, SOLaneLocation.LaneIndex, SOLaneLocation.DistanceAlongLane, EntryPointLocation);
			const FColor Color = FColor::Silver;
			constexpr float SphereRadius = 25.f;
			DebugProxy->Spheres.Emplace(SphereRadius, EntryPointLocation.Position, Color);
			DebugProxy->Spheres.Emplace(SphereRadius, ObjectLocation, Color);
			DebugProxy->DashedLines.Emplace(ObjectLocation, EntryPointLocation.Position, Color, /*dash size*/10.f);
		}
	}
}
#endif // UE_ENABLE_DEBUG_DRAWING

#if WITH_EDITORONLY_DATA
void USmartObjectZoneAnnotations::Serialize(FArchive& Ar)
{
	if (bRebuildAllGraphsRequested
		&& Ar.IsSaving()
		&& Ar.IsPersistent()	// saving archive for persistent storage (package)
		&& !Ar.IsTransacting()	// do not rebuild for transactions (i.e. undo/redo)
		)
	{
		RebuildForAllGraphs();
	}

	Super::Serialize(Ar);
}
#endif // WITH_EDITORONLY_DATA

#if WITH_EDITOR
void USmartObjectZoneAnnotations::OnUnregister()
{
	if (SmartObjectSubsystem != nullptr)
	{
		SmartObjectSubsystem->OnMainCollectionChanged.Remove(OnMainCollectionChangedHandle);
		OnMainCollectionChangedHandle.Reset();

		SmartObjectSubsystem->OnMainCollectionDirtied.Remove(OnMainCollectionDirtiedHandle);
		OnMainCollectionDirtiedHandle.Reset();
	}

	GetDefault<UMassSmartObjectSettings>()->OnAnnotationSettingsChanged.Remove(OnAnnotationSettingsChangedHandle);
	OnAnnotationSettingsChangedHandle.Reset();

	UE::ZoneGraphDelegates::OnZoneGraphDataBuildDone.Remove(OnGraphDataChangedHandle);
	OnGraphDataChangedHandle.Reset();

	Super::OnUnregister();
}

void USmartObjectZoneAnnotations::PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent)
{
	Super::PostEditChangeChainProperty(PropertyChangedEvent);

	FProperty* Property = PropertyChangedEvent.Property;
	FProperty* MemberProperty = nullptr;
	if (PropertyChangedEvent.PropertyChain.GetActiveMemberNode())
	{
		MemberProperty = PropertyChangedEvent.PropertyChain.GetActiveMemberNode()->GetValue();
	}

	if (MemberProperty && Property)
	{
		if (MemberProperty->GetFName() == GET_MEMBER_NAME_CHECKED(USmartObjectZoneAnnotations, AffectedLaneTags))
		{
			RebuildForAllGraphs();
		}
	}
}

void USmartObjectZoneAnnotations::RebuildForSingleGraph(FSmartObjectAnnotationData& Data, const FZoneGraphStorage& Storage)
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("ZoneGraphSmartObjectBehavior RebuildData")

	if (SmartObjectSubsystem == nullptr)
	{
		UE_VLOG_UELOG(this, LogSmartObject, Error, TEXT("Attempting to rebuild data while SmartObjectSubsystem is not set. This indicates a problem in the initialization flow."));
		return;
	}

	if (!BehaviorTag.IsValid())
	{
		UE_VLOG_UELOG(this, LogSmartObject, Warning, TEXT("Attempting to rebuild data while BehaviorTag is invalid (e.g. not set in MassSmartObjectSettings)"));
		return;
	}
	
	const FSmartObjectContainer& SmartObjectContainer = SmartObjectSubsystem->GetSmartObjectContainer();

	const FVector SearchExtent(GetDefault<UMassSmartObjectSettings>()->SearchExtents);
	int32 NumAdded = 0;
	int32 NumDiscarded = 0;

	const int32 NumSO = SmartObjectContainer.GetEntries().Num();
	const int32 NumLanes = Storage.Lanes.Num();
	Data.SmartObjectLaneLocations.Empty(NumSO);
	Data.SmartObjectToLaneLocationIndexLookup.Empty(NumSO);
	Data.LaneToLaneLocationIndicesLookup.Empty(NumLanes);
	Data.AffectedLanes.Empty(NumLanes);

	for (const FSmartObjectCollectionEntry& Entry : SmartObjectContainer.GetEntries())
	{
		FSmartObjectHandle Handle = Entry.GetHandle();
		const FVector& ObjectLocation = Entry.GetTransform().GetLocation();
		const FBox QueryBounds(ObjectLocation - SearchExtent, ObjectLocation + SearchExtent);

		FZoneGraphLaneLocation LaneLocation;
		float DistanceSqr = 0.f;
		const bool bFound = UE::ZoneGraph::Query::FindNearestLane(Storage, QueryBounds, AffectedLaneTags, LaneLocation, DistanceSqr);
		if (bFound)
		{
			NumAdded++;

			const int32 LaneIndex = LaneLocation.LaneHandle.Index;

			const int32 SOLaneLocationIndex = Data.SmartObjectLaneLocations.Add(FSmartObjectLaneLocation(Handle, LaneIndex, LaneLocation.DistanceAlongLane));
			Data.SmartObjectToLaneLocationIndexLookup.Add(Handle, SOLaneLocationIndex);
			Data.AffectedLanes.AddUnique(LaneIndex);
			Data.LaneToLaneLocationIndicesLookup.FindOrAdd(LaneIndex).SmartObjectLaneLocationIndices.Add(SOLaneLocationIndex);

			UE_VLOG_UELOG(this, LogSmartObject, Verbose, TEXT("Adding ZG annotation for SmartObject '%s' on lane '%s'"), *LexToString(Handle), *LaneLocation.LaneHandle.ToString());
			UE_VLOG_SEGMENT(this, LogSmartObject, Display, ObjectLocation, LaneLocation.Position, FColor::Green, TEXT(""));
			UE_VLOG_LOCATION(this, LogSmartObject, Display, ObjectLocation, 50 /*radius*/, FColor::Green, TEXT("%s"), *LexToString(Handle));
		}
		else
		{
			NumDiscarded++;
			UE_VLOG_LOCATION(this, LogSmartObject, Display, ObjectLocation, 75 /*radius*/, FColor::Red, TEXT("%s"), *LexToString(Handle));
		}
	}

	// Sort all entry points per distance on lane
	for (auto It(Data.LaneToLaneLocationIndicesLookup.CreateIterator()); It; ++It)
	{
		It.Value().SmartObjectLaneLocationIndices.Sort([Locations = Data.SmartObjectLaneLocations](const int32 FirstIndex, const int32 SecondIndex)
		{
			return Locations[FirstIndex].DistanceAlongLane < Locations[SecondIndex].DistanceAlongLane;
		});
	}

	Data.SmartObjectLaneLocations.Shrink();
	Data.SmartObjectToLaneLocationIndexLookup.Shrink();
	Data.AffectedLanes.Shrink();
	Data.LaneToLaneLocationIndicesLookup.Shrink();
	Data.bInitialTaggingCompleted = false;

	UE_VLOG_UELOG(this, LogSmartObject, Log, TEXT("Summary: %d entry points added, %d discarded%s."), NumAdded, NumDiscarded, NumDiscarded == 0 ? TEXT("") : TEXT(" (too far from any lane)"));
}

void USmartObjectZoneAnnotations::RebuildForAllGraphs()
{
	bRebuildAllGraphsRequested = false;

	UZoneGraphSubsystem* ZoneGraphSubsystem = UWorld::GetSubsystem<UZoneGraphSubsystem>(GetWorld());
	if (!ZoneGraphSubsystem)
	{
		return;
	}

	for (const FRegisteredZoneGraphData& RegisteredZoneGraphData : ZoneGraphSubsystem->GetRegisteredZoneGraphData())
	{
		if (!RegisteredZoneGraphData.bInUse || RegisteredZoneGraphData.ZoneGraphData == nullptr)
		{
			continue;
		}

		const FZoneGraphStorage& Storage = RegisteredZoneGraphData.ZoneGraphData->GetStorage();
		const int32 Index = Storage.DataHandle.Index;

		if (SmartObjectAnnotationDataArray.IsValidIndex(Index))
		{
			FSmartObjectAnnotationData& AnnotationData = SmartObjectAnnotationDataArray[Index];
			AnnotationData.Reset();
			RebuildForSingleGraph(AnnotationData, Storage);
		}
	}
}
#endif // WITH_EDITOR

======================================================================


=== Source/MassSmartObjects/Public/IMassSmartObjectsModule.h ===
================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleInterface.h"
#include "Modules/ModuleManager.h"


/**
 * The public interface to this module.  In most cases, this interface is only public to sibling modules 
 * within this plugin.
 */
class IMassSmartObjectsModule : public IModuleInterface
{

public:

	/**
	 * Singleton-like access to this module's interface.  This is just for convenience!
	 * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.
	 *
	 * @return Returns singleton instance, loading the module on demand if needed
	 */
	static inline IMassSmartObjectsModule& Get()
	{
		return FModuleManager::LoadModuleChecked<IMassSmartObjectsModule>( "MassSmartObjects" );
	}

	/**
	 * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.
	 *
	 * @return True if the module is loaded and ready to use
	 */
	static inline bool IsAvailable()
	{
		return FModuleManager::Get().IsModuleLoaded( "MassSmartObjects" );
	}
};


================================================================


=== Source/MassSmartObjects/Public/MassSmartObjectBehaviorDefinition.h ===
==========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "MassEntityView.h"
#include "SmartObjectDefinition.h"
#include "MassSmartObjectBehaviorDefinition.generated.h"

struct FMassEntityManager;
class USmartObjectSubsystem;
struct FMassExecutionContext;
struct FTransformFragment;
struct FMassSmartObjectUserFragment;

/**
 * Struct to pass around the required set of information to activate a mass behavior definition on a given entity.
 * Context must be created on stack and not kept around since EntityView validity is not guaranteed.
 */
struct MASSSMARTOBJECTS_API FMassBehaviorEntityContext
{
	FMassBehaviorEntityContext() = delete;

	FMassBehaviorEntityContext(const FMassEntityView InEntityView, USmartObjectSubsystem& InSubsystem)
		: EntityView(InEntityView)
		, SmartObjectSubsystem(InSubsystem)
	{}

	const FMassEntityView EntityView;
	USmartObjectSubsystem& SmartObjectSubsystem;
};

/**
 * Base class for MassAIBehavior definitions. This is the type of definitions that MassEntity queries will look for.
 * Definition subclass can parameterized its associated behavior by overriding method Activate.
 */
UCLASS(EditInlineNew)
class MASSSMARTOBJECTS_API USmartObjectMassBehaviorDefinition : public USmartObjectBehaviorDefinition
{
	GENERATED_BODY()

public:
	/** This virtual method allows subclasses to configure the MassEntity based on their parameters (e.g. Add fragments) */
	virtual void Activate(FMassCommandBuffer& CommandBuffer, const FMassBehaviorEntityContext& EntityContext) const;

	/** This virtual method allows subclasses to update the MassEntity on interaction deactivation (e.g. Remove fragments) */
	virtual void Deactivate(FMassCommandBuffer& CommandBuffer, const FMassBehaviorEntityContext& EntityContext) const;

	/**
	 * Indicates the amount of time the Massentity
	 * will execute its behavior when reaching the smart object.
	 */
	UPROPERTY(EditDefaultsOnly, Category = SmartObject)
	float UseTime;
};

==========================================================================


=== Source/MassSmartObjects/Public/MassSmartObjectFragments.h ===
=================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "MassSmartObjectTypes.h"
#include "MassSmartObjectRequest.h"
#include "SmartObjectRuntime.h"
#include "MassSmartObjectFragments.generated.h"

/** Fragment used by an entity to be able to interact with smart objects */
USTRUCT()
struct MASSSMARTOBJECTS_API FMassSmartObjectUserFragment : public FMassFragment
{
	GENERATED_BODY()

	/** Tags describing the smart object user. */
	UPROPERTY(Transient)
	FGameplayTagContainer UserTags;

	/** Claim handle for the currently active smart object interaction. */
	UPROPERTY(Transient)
	FSmartObjectClaimHandle InteractionHandle;

	/** Status of the current active smart object interaction. */
	UPROPERTY(Transient)
	EMassSmartObjectInteractionStatus InteractionStatus = EMassSmartObjectInteractionStatus::Unset;

	/**
	 * World time in seconds before which the user is considered in cooldown and
	 * won't look for new interactions (value of 0 indicates no cooldown).
	 */
	UPROPERTY(Transient)
	double InteractionCooldownEndTime = 0.;
};

/** Fragment used to process time based smartobject interactions */
USTRUCT()
struct MASSSMARTOBJECTS_API FMassSmartObjectTimedBehaviorFragment : public FMassFragment
{
	GENERATED_BODY()

	UPROPERTY(Transient)
	float UseTime = 0.f;
};
=================================================================


=== Source/MassSmartObjects/Public/MassSmartObjectHandler.h ===
===============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassSmartObjectRequest.h"
#include "MassSmartObjectTypes.h"

struct FMassEntityManager;
class UMassSignalSubsystem;
class USmartObjectSubsystem;
struct FMassExecutionContext;
struct FMassEntityHandle;
struct FMassSmartObjectUserFragment;
struct FTransformFragment;
struct FSmartObjectClaimHandle;
struct FSmartObjectHandle;
struct FZoneGraphCompactLaneLocation;
enum class ESmartObjectSlotState : uint8;

/**
 * Mediator struct that encapsulates communication between SmartObjectSubsystem and Mass.
 * This object is meant to be created and used in method scope to guarantee subsystems validity.
 */
struct MASSSMARTOBJECTS_API FMassSmartObjectHandler
{
	/**
	 * FMassSmartObjectHandler constructor
	 * @param InEntitySubsystem is the entity subsystem that the smart object should belong to
	 * @param InExecutionContext is the current execution context of the entity subsystem
	 * @param InSmartObjectSubsystem is the smart object subsystem
	 * @param InSignalSubsystem is the mass signal subsystem to use to send signal to affected entities
	 */
	FMassSmartObjectHandler(FMassEntityManager& InEntityManager, FMassExecutionContext& InExecutionContext, USmartObjectSubsystem& InSmartObjectSubsystem, UMassSignalSubsystem& InSignalSubsystem)
		: EntityManager(InEntityManager)
		, ExecutionContext(InExecutionContext)
		, SmartObjectSubsystem(InSmartObjectSubsystem)
		, SignalSubsystem(InSignalSubsystem)
	{
	}

	/**
	 * Creates an async request to build a list of compatible smart objects
	 * around the provided location. The caller must poll using the request id
	 * to know when the reservation can be done.
	 * @param RequestingEntity Entity requesting the candidates list
	 * @param Location The center of the query
	 * @return Request identifier that can be used to try claiming a result once available
	 */
	[[nodiscard]] FMassSmartObjectRequestID FindCandidatesAsync(const FMassEntityHandle RequestingEntity, const FGameplayTagContainer& UserTags, const FGameplayTagQuery& ActivityRequirements, const FVector& Location) const;

	/**
	 * Creates an async request to build a list of compatible smart objects
	 * around the provided lane location. The caller must poll using the request id
	 * to know when the reservation can be done.
	 * @param RequestingEntity Entity requesting the candidates list
	 * @param LaneLocation The lane location as reference for the query
	 * @return Request identifier that can be used to try claiming a result once available
	 */
	[[nodiscard]] FMassSmartObjectRequestID FindCandidatesAsync(const FMassEntityHandle RequestingEntity, const FGameplayTagContainer& UserTags, const FGameplayTagQuery& ActivityRequirements, const FZoneGraphCompactLaneLocation& LaneLocation) const;

	/**
	 * Provides the result of a previously created request from FindCandidatesAsync to indicate if it has been processed
	 * and the results can be used by ClaimCandidate.
	 * @param RequestID A valid request identifier (method will ensure otherwise)
	 * @return The current request's result, nullptr if request not ready yet.
	 */
	[[nodiscard]] const FMassSmartObjectCandidateSlots* GetRequestCandidates(const FMassSmartObjectRequestID& RequestID) const;

	/**
	 * Deletes the request associated to the specified identifier
	 * @param RequestID A valid request identifier (method will ensure otherwise)
	 */
	void RemoveRequest(const FMassSmartObjectRequestID& RequestID) const;

	/**
	 * Claims the first available smart object from the provided candidates.
	 * @param Entity MassEntity associated to the user fragment
	 * @param User Fragment of the user claiming
	 * @param Candidates Candidate slots to choose from.
	 * @param ClaimPriority Claim priority, a slot claimed at lower priority can be claimed by higher priority (unless already in use).
	 * @return Whether the slot has been successfully claimed or not
	 */
	[[nodiscard]] FSmartObjectClaimHandle ClaimCandidate(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const FMassSmartObjectCandidateSlots& Candidates, ESmartObjectClaimPriority ClaimPriority = ESmartObjectClaimPriority::Normal) const;

	/**
	 * Claims the first available slot holding any type of USmartObjectMassBehaviorDefinition in the smart object
	 * associated to the provided identifier.
	 * @param Entity MassEntity associated to the user fragment
	 * @param User Fragment of the user claiming
	 * @param RequestResult A valid smart object request result (method will ensure otherwise)
	 * @param ClaimPriority Claim priority, a slot claimed at lower priority can be claimed by higher priority (unless already in use).
	 * @return Whether the slot has been successfully claimed or not
	 */
	[[nodiscard]] FSmartObjectClaimHandle ClaimSmartObject(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const FSmartObjectRequestResult& RequestResult, ESmartObjectClaimPriority ClaimPriority = ESmartObjectClaimPriority::Normal) const;

	/**
	 * Activates the mass gameplay behavior associated to the previously claimed smart object.
	 * @param Entity MassEntity associated to the user fragment
	 * @param User Fragment of the user claiming
	 * @param ClaimHandle claimed smart object slot to use.
	 * @param Transform Fragment holding the transform of the user claiming
	 * @return Whether the slot has been successfully claimed or not
	 */
	bool StartUsingSmartObject(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const FSmartObjectClaimHandle ClaimHandle) const;

	/**
	 * Deactivates the mass gameplay behavior started using StartUsingSmartObject.
	 * @param Entity MassEntity associated to the user fragment
	 * @param User Fragment of the user claiming
	 * @param NewStatus Reason of the deactivation.
	 */
	void StopUsingSmartObject(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const EMassSmartObjectInteractionStatus NewStatus) const;

	/**
	 * Releases a claimed/in-use smart object and update user fragment.
	 * @param Entity MassEntity associated to the user fragment
	 * @param User Fragment of the user claiming
	 * @param ClaimHandle claimed smart object slot to release.
	 */
	void ReleaseSmartObject(const FMassEntityHandle Entity, FMassSmartObjectUserFragment& User, const FSmartObjectClaimHandle ClaimHandle) const;

private:
	FMassEntityManager& EntityManager;
	FMassExecutionContext& ExecutionContext;
	USmartObjectSubsystem& SmartObjectSubsystem;
	UMassSignalSubsystem& SignalSubsystem;
};

===============================================================


=== Source/MassSmartObjects/Public/MassSmartObjectProcessor.h ===
=================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassObserverProcessor.h"
#include "MassProcessor.h"
#include "MassSmartObjectProcessor.generated.h"

class UMassSignalSubsystem;
class UZoneGraphAnnotationSubsystem;

/** Processor that builds a list of candidates objects for each users. */
UCLASS()
class MASSSMARTOBJECTS_API UMassSmartObjectCandidatesFinderProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassSmartObjectCandidatesFinderProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	/** Extents used to perform the spatial query in the octree for world location queries. */
	UPROPERTY(EditDefaultsOnly, Category = SmartObject, config)
	float SearchExtents = 5000.f;

	/** Query to fetch and process requests to find smart objects using spacial query around a given world location. */
	FMassEntityQuery WorldRequestQuery;

	/** Query to fetch and process requests to find smart objects on zone graph lanes. */
	FMassEntityQuery LaneRequestQuery;
};

/** Processor for time based user's behavior that waits x seconds then releases its claim on the object */
UCLASS()
class MASSSMARTOBJECTS_API UMassSmartObjectTimedBehaviorProcessor : public UMassProcessor
{
	GENERATED_BODY()
public:
	UMassSmartObjectTimedBehaviorProcessor();

protected:
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;
	virtual void ConfigureQueries() override;

	FMassEntityQuery EntityQuery;
};

/** Deinitializer processor to unregister slot invalidation callback when SmartObjectUser fragment gets removed */
UCLASS()
class MASSSMARTOBJECTS_API UMassSmartObjectUserFragmentDeinitializer : public UMassObserverProcessor
{
	GENERATED_BODY()

	UMassSmartObjectUserFragmentDeinitializer();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};
=================================================================


=== Source/MassSmartObjects/Public/MassSmartObjectRegistration.h ===
====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassObserverProcessor.h"
#include "MassSignalProcessorBase.h"
#include "SmartObjectTypes.h"
#include "MassSmartObjectRegistration.generated.h"

class USmartObjectDefinition;

/** Mass Tag applied on entities with FFSmartObjectRegistrationFragment that need to create smart objects */
USTRUCT()
struct MASSSMARTOBJECTS_API FMassInActiveSmartObjectsRangeTag : public FMassTag
{
	GENERATED_BODY()
};

/** Mass Fragment storing the handle associated to the created smart object */
USTRUCT()
struct MASSSMARTOBJECTS_API FSmartObjectRegistrationFragment : public FMassFragment
{
	GENERATED_BODY()

	UPROPERTY()
	TWeakObjectPtr<USmartObjectDefinition> Asset;

	UPROPERTY()
	FSmartObjectHandle Handle;
};

/**
 * Processor that signals entities with FSmartObjectRegistration and FMassActorInstanceFragment fragments
 * when the a given tag or fragment is added to an entity.
 * @see FSmartObjectRegistrationFragment
 * @see FMassActorInstanceFragment
 */
UCLASS(Abstract)
class UMassSmartObjectInitializerBase : public UMassObserverProcessor
{
	GENERATED_BODY()
public:
	UMassSmartObjectInitializerBase();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
	FName Signal;
};

/**
 * Processor that signals entities with FSmartObjectRegistration and FMassActorInstanceFragment fragments
 * when the a given tag or fragment is removed from an entity.
 * @see FSmartObjectRegistrationFragment
 * @see FMassActorInstanceFragment
 */
UCLASS(Abstract)
class UMassSmartObjectDeinitializerBase : public UMassObserverProcessor
{
	GENERATED_BODY()
public:
	UMassSmartObjectDeinitializerBase();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
	FName Signal;
};

/**
 * Signals entities with UE::Mass::Signals::SmartObjectActivationChanged when 'FMassInActiveSmartObjectsRangeTag' is added.
 */
UCLASS()
class UMassActiveSmartObjectInitializer : public UMassSmartObjectInitializerBase
{
	GENERATED_BODY()
public:
	UMassActiveSmartObjectInitializer();
};

/**
 * Signals entities with UE::Mass::Signals::SmartObjectActivationChanged when 'FMassInActiveSmartObjectsRangeTag' is removed.
 */
UCLASS()
class UMassActiveSmartObjectDeinitializer : public UMassSmartObjectDeinitializerBase
{
	GENERATED_BODY()

public:
	UMassActiveSmartObjectDeinitializer();
};

/**
 * Signals entities with UE::Mass::Signals::ActorInstanceHandleChanged when 'FMassActorInstanceFragment' is added.
 */
UCLASS()
class UMassActorInstanceHandleInitializer : public UMassSmartObjectInitializerBase
{
	GENERATED_BODY()
public:
	UMassActorInstanceHandleInitializer();
};

/**
 * Signals entities with UE::Mass::Signals::ActorInstanceHandleChanged when 'FMassActorInstanceFragment' is removed.
 */
UCLASS()
class UMassActorInstanceHandleDeinitializer : public UMassSmartObjectDeinitializerBase
{
	GENERATED_BODY()

public:
	UMassActorInstanceHandleDeinitializer();
};

/**
 * Signal based processor that creates and destroys the smart object instance associated to an entity based
 * on valid FSmartObjectRegistration and FMassActorInstance fragments.
 * The registration is processed on the following events:
 * 	 UE::Mass::Signals::ActorInstanceHandleChanged
 * 	 UE::Mass::Signals::SmartObjectActivationChanged
 * @see FFSmartObjectRegistrationFragment
 */
UCLASS()
class UMassActiveSmartObjectSignalProcessor : public UMassSignalProcessorBase
{
	GENERATED_BODY()

public:
	UMassActiveSmartObjectSignalProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Initialize(UObject& Owner) override;
	virtual void SignalEntities(FMassEntityManager& EntityManager, FMassExecutionContext& Context, FMassSignalNameLookup& /*Unused*/) override;

private:
	FMassEntityQuery InsideSmartObjectActiveRangeQuery;
	FMassEntityQuery OutsideSmartObjectActiveRangeQuery;
};
====================================================================


=== Source/MassSmartObjects/Public/MassSmartObjectRequest.h ===
===============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "SmartObjectSubsystem.h"
#include "MassEntityTypes.h"
#include "ZoneGraphTypes.h"
#include "Containers/StaticArray.h"
#include "MassSmartObjectRequest.generated.h"

/**
 * Structure that represents a potential smart object slot for a MassEntity during the search
 */
USTRUCT()
struct MASSSMARTOBJECTS_API FSmartObjectCandidateSlot
{
	GENERATED_BODY()

	FSmartObjectCandidateSlot() = default;
	FSmartObjectCandidateSlot(const FSmartObjectRequestResult InResult, const float InCost)	: Result(InResult), Cost(InCost) {}

	UPROPERTY(Transient)
	FSmartObjectRequestResult Result;

	UPROPERTY(Transient)
	float Cost = 0.f;
};

/**
 * Identifier associated to a request for smart object candidates. We use a 1:1 match
 * with an FMassEntityHandle since all requests are batched together using the EntitySubsystem.
 */
USTRUCT()
struct MASSSMARTOBJECTS_API FMassSmartObjectRequestID
{
	GENERATED_BODY()

	FMassSmartObjectRequestID() = default;
	explicit FMassSmartObjectRequestID(const FMassEntityHandle InEntity) : Entity(InEntity) {}

	bool IsSet() const { return Entity.IsSet(); }
	void Reset() { Entity.Reset(); }

	explicit operator FMassEntityHandle() const { return Entity; }

private:
	UPROPERTY(Transient)
	FMassEntityHandle Entity;
};

/**
 * Struct that holds status and results of a candidate finder request
 */
USTRUCT(BlueprintType)
struct MASSSMARTOBJECTS_API FMassSmartObjectCandidateSlots
{
	GENERATED_BODY()

	void Reset()
	{
		NumSlots = 0;
	}
	
	static constexpr uint32 MaxNumCandidates = 4;
	TStaticArray<FSmartObjectCandidateSlot, MaxNumCandidates> Slots;

	UPROPERTY(Transient)
	uint8 NumSlots = 0;
};

/**
 * Fragment that holds the result of a request to find candidates.
 */
USTRUCT()
struct MASSSMARTOBJECTS_API FMassSmartObjectRequestResultFragment : public FMassFragment
{
	GENERATED_BODY()

	UPROPERTY(Transient)
	FMassSmartObjectCandidateSlots Candidates;

	UPROPERTY(Transient)
	bool bProcessed = false;
};

/**
 * Fragment used to build a list potential smart objects to use. Once added to an entity
 * this will be processed by the candidates finder processor to fill a SmartObjectCandidates
 * fragment that could then be processed by the reservation processor
 */
USTRUCT()
struct MASSSMARTOBJECTS_API FMassSmartObjectWorldLocationRequestFragment : public FMassFragment
{
	GENERATED_BODY()

	UPROPERTY(Transient)
	FVector SearchOrigin = FVector::ZeroVector;

	UPROPERTY(Transient)
	FMassEntityHandle RequestingEntity;

	UPROPERTY(Transient)
	FGameplayTagContainer UserTags;

	UPROPERTY(Transient)
	FGameplayTagQuery ActivityRequirements;
};

/**
 * Fragment used to build a list potential smart objects to use. Once added to an entity
 * this will be processed by the candidates finder processor to fill a SmartObjectCandidates
 * fragment that could then be processed by the reservation processor
 */
USTRUCT()
struct MASSSMARTOBJECTS_API FMassSmartObjectLaneLocationRequestFragment : public FMassFragment
{
	GENERATED_BODY()

	FZoneGraphCompactLaneLocation CompactLaneLocation;

	UPROPERTY(Transient)
	FMassEntityHandle RequestingEntity;

	UPROPERTY(Transient)
	FGameplayTagContainer UserTags;

	UPROPERTY(Transient)
	FGameplayTagQuery ActivityRequirements;
};

/**
 * Special tag to mark processed requests
 */
USTRUCT()
struct MASSSMARTOBJECTS_API FMassSmartObjectCompletedRequestTag : public FMassTag
{
	GENERATED_BODY()
};

===============================================================


=== Source/MassSmartObjects/Public/MassSmartObjectSettings.h ===
================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once
#include "ZoneGraphTypes.h"
#include "MassSettings.h"
#include "MassSmartObjectSettings.generated.h"

#if WITH_EDITOR
/** Called when annotation tag settings changed. */
DECLARE_MULTICAST_DELEGATE(FOnAnnotationSettingsChanged);
#endif

/**
 * Settings for the MassSmartObject module.
 */
UCLASS(config = Plugins, defaultconfig, DisplayName = "Mass SmartObject")
class MASSSMARTOBJECTS_API UMassSmartObjectSettings : public UMassModuleSettings
{
	GENERATED_BODY()

public:
#if WITH_EDITOR
	mutable FOnAnnotationSettingsChanged OnAnnotationSettingsChanged;
#endif

	/** Tag used to indicate that smart objects are associated to a lane for queries using lanes. */
	UPROPERTY(EditDefaultsOnly, Category = ZoneGraph, config)
	FZoneGraphTag SmartObjectTag;

	/** Extents used to find precomputed entry points to reach a smart object from a zone graph lane. */
	UPROPERTY(EditDefaultsOnly, Category = ZoneGraph, config)
	float SearchExtents = 500.f;

protected:

#if WITH_EDITOR
	virtual void PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent) override;
#endif
};

================================================================


=== Source/MassSmartObjects/Public/MassSmartObjectTypes.h ===
=============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTypes.h"
#include "MassSmartObjectTypes.generated.h"

namespace UE::Mass::Signals
{
	const FName SmartObjectRequestCandidates = FName(TEXT("SmartObjectRequestCandidates"));
	const FName SmartObjectCandidatesReady = FName(TEXT("SmartObjectCandidatesReady"));
	const FName SmartObjectInteractionDone = FName(TEXT("SmartObjectInteractionDone"));
	const FName SmartObjectInteractionAborted = FName(TEXT("SmartObjectInteractionAborted"));
}

UENUM()
enum class EMassSmartObjectInteractionStatus: uint8
{
	Unset,
    InProgress,			// Claimed and Behavior activated
    BehaviorCompleted,	// Behavior is completed but task still running (not updated yet)
	TaskCompleted,		// Task has been notified that behavior is completed and completes
    Aborted				// Task and Behavior were aborted
};

/**
 * Struct that can be used to pass data to the find or filtering methods.
 * Properties will be used as external data to fill values expected by the world condition schema
 * specified by the smart object definition.
 *		e.g. FilterSlotsBySelectionConditions(SlotHandles, FConstStructView::Make(FSmartObjectMassEntityUserData(Entity)));
 *
 * It can be inherited from to provide additional data to another world condition schema inheriting
 * from USmartObjectWorldConditionSchema.
 *	e.g.
 *		UCLASS()
 *		class USmartObjectWorldConditionExtendedSchema : public USmartObjectWorldConditionSchema
 *		{
 *			...
 *			USmartObjectWorldConditionExtendedSchema(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
 *			{
 *				OtherEntityRef = AddContextDataDesc(TEXT("OtherEntity"), FMassEntityHandle::StaticStruct(), EWorldConditionContextDataType::Dynamic);
 *			}
 *			
 *			FWorldConditionContextDataRef OtherEntityRef;
 *		};
 *
 *		USTRUCT()
 *		struct FSmartObjectMassEntityExtendedUserData : public FSmartObjectMassEntityUserData
 *		{
 *			UPROPERTY()
 *			FMassEntityHandle OtherEntity;
 *		}
 *
 * The struct can also be used to be added to a Smart Object slot when it gets claimed.
 *		e.g. Claim(SlotHandle, FConstStructView::Make(FSmartObjectMassEntityUserData(Entity)));
 */
USTRUCT()
struct FSmartObjectMassEntityUserData
{
	GENERATED_BODY()

	FSmartObjectMassEntityUserData() = default;
	explicit FSmartObjectMassEntityUserData(const FMassEntityHandle InEntityHandle) : UserEntity(InEntityHandle) {}

	UPROPERTY()
	FMassEntityHandle UserEntity;
};
=============================================================


=== Source/MassSmartObjects/Public/MassSmartObjectUserTrait.h ===
=================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityTraitBase.h"
#include "GameplayTagContainer.h"
#include "MassSmartObjectUserTrait.generated.h"

/**
 * Trait to allow an entity to interact with SmartObjects
 */
UCLASS(meta = (DisplayName = "SmartObject User"))
class MASSSMARTOBJECTS_API UMassSmartObjectUserTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;

	/** Tags describing the SmartObject user. Used when searching smart objects. */
	UPROPERTY(EditAnywhere, Category = Parameter)
	FGameplayTagContainer UserTags;
};

=================================================================


=== Source/MassSmartObjects/Public/SmartObjectZoneAnnotations.h ===
===================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "SmartObjectTypes.h"
#include "ZoneGraphAnnotationComponent.h"
#include "ZoneGraphTypes.h"
#include "SmartObjectZoneAnnotations.generated.h"

class AZoneGraphData;
class USmartObjectSubsystem;

/** Struct to keep track of a SmartObject entry point on a given lane. */
USTRUCT()
struct FSmartObjectLaneLocation
{
	GENERATED_BODY()

	FSmartObjectLaneLocation() = default;
	FSmartObjectLaneLocation(const FSmartObjectHandle InObjectHandle, const int32 InLaneIndex, const float InDistanceAlongLane)
        : ObjectHandle(InObjectHandle)
        , LaneIndex(InLaneIndex)
        , DistanceAlongLane(InDistanceAlongLane)
	{
	}

	UPROPERTY()
	FSmartObjectHandle ObjectHandle;

	UPROPERTY()
	int32 LaneIndex = INDEX_NONE;

	UPROPERTY()
	float DistanceAlongLane = 0.0f;
};

/**
 * Struct to store indices to all entry points on a given lane.
 * Used as a container wrapper to be able to use in a TMap.
 */
USTRUCT()
struct FSmartObjectLaneLocationIndices
{
	GENERATED_BODY()

	UPROPERTY(VisibleAnywhere, Category = SmartObject)
	TArray<int32> SmartObjectLaneLocationIndices;
};

/** Per ZoneGraphData smart object look up data. */
USTRUCT()
struct FSmartObjectAnnotationData
{
	GENERATED_BODY()

	/** @return True if this entry is valid (associated to a valid zone graph data), false otherwise. */
	bool IsValid() const { return DataHandle.IsValid(); }

	/** Reset all internal data. */
	void Reset()
	{
		DataHandle = {};
		AffectedLanes.Reset();
		SmartObjectLaneLocations.Reset();
		SmartObjectToLaneLocationIndexLookup.Reset();
		LaneToLaneLocationIndicesLookup.Reset();
	}

	/** Handle of the ZoneGraphData that this smart object annotation data is associated to */
	UPROPERTY(VisibleAnywhere, Category = SmartObject)
	FZoneGraphDataHandle DataHandle;

	UPROPERTY(VisibleAnywhere, Category = SmartObject)
	TArray<int32> AffectedLanes;

	UPROPERTY(VisibleAnywhere, Category = SmartObject)
	TArray<FSmartObjectLaneLocation> SmartObjectLaneLocations;

	UPROPERTY(VisibleAnywhere, Category = SmartObject)
	TMap<FSmartObjectHandle, int32> SmartObjectToLaneLocationIndexLookup;

	UPROPERTY(VisibleAnywhere, Category = SmartObject)
	TMap<int32, FSmartObjectLaneLocationIndices> LaneToLaneLocationIndicesLookup;

	bool bInitialTaggingCompleted = false;
};

/**
 * ZoneGraph annotations for smart objects
 */
UCLASS(ClassGroup = AI, BlueprintType, meta = (BlueprintSpawnableComponent))
class MASSSMARTOBJECTS_API USmartObjectZoneAnnotations : public UZoneGraphAnnotationComponent
{
	GENERATED_BODY()

public:
	const FSmartObjectAnnotationData* GetAnnotationData(FZoneGraphDataHandle DataHandle) const;
	TOptional<FSmartObjectLaneLocation> GetSmartObjectLaneLocation(const FZoneGraphDataHandle DataHandle, const FSmartObjectHandle SmartObjectHandle) const;

protected:
	virtual void PostSubsystemsInitialized() override;
	virtual FZoneGraphTagMask GetAnnotationTags() const override;
	virtual void TickAnnotation(const float DeltaTime, FZoneGraphAnnotationTagContainer& BehaviorTagContainer) override;

	virtual void PostZoneGraphDataAdded(const AZoneGraphData& ZoneGraphData) override;
	virtual void PreZoneGraphDataRemoved(const AZoneGraphData& ZoneGraphData) override;

#if UE_ENABLE_DEBUG_DRAWING
	virtual void DebugDraw(FZoneGraphAnnotationSceneProxy* DebugProxy) override;
#endif // UE_ENABLE_DEBUG_DRAWING

	/** Filter specifying which lanes the behavior is applied to. */
	UPROPERTY(EditAnywhere, Category = SmartObject)
	FZoneGraphTagFilter AffectedLaneTags;

	/** Entry points graph for each ZoneGraphData. */
	UPROPERTY(VisibleAnywhere, Category = SmartObject)
	TArray<FSmartObjectAnnotationData> SmartObjectAnnotationDataArray;

	/** Tag to mark the lanes that offers smart objects. */
	UPROPERTY(VisibleAnywhere, Category = SmartObject)
	FZoneGraphTag BehaviorTag;

#if WITH_EDITOR
	virtual void PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent) override;
	virtual void OnUnregister() override;

	void RebuildForSingleGraph(FSmartObjectAnnotationData& Data, const FZoneGraphStorage& Storage);
	void RebuildForAllGraphs();

	FDelegateHandle OnAnnotationSettingsChangedHandle;
	FDelegateHandle OnGraphDataChangedHandle;
	FDelegateHandle OnMainCollectionChangedHandle;
	FDelegateHandle OnMainCollectionDirtiedHandle;
#endif // WITH_EDITOR

#if WITH_EDITORONLY_DATA
	virtual void Serialize(FArchive& Ar) override;
	bool bRebuildAllGraphsRequested = false;
#endif

	/** Cached SmartObjectSubsystem */
	UPROPERTY(Transient)
	TObjectPtr<USmartObjectSubsystem> SmartObjectSubsystem = nullptr;
};

===================================================================


=== Source/MassSmartObjects/MassSmartObjects.Build.cs ===
=========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

namespace UnrealBuildTool.Rules
{
	public class MassSmartObjects : ModuleRules
	{
		public MassSmartObjects(ReadOnlyTargetRules Target) : base(Target)
		{
			PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

			UnsafeTypeCastWarningLevel = WarningLevel.Warning;

			PublicDependencyModuleNames.AddRange(
				new string[] {
					"MassEntity",
					"Core",
					"CoreUObject",
					"Engine",
					"GameplayTags",
					"MassCommon",
					"MassLOD",
					"MassMovement",
					"MassSignals",
					"MassSimulation",
					"MassSpawner",
					"SmartObjectsModule",
					"ZoneGraph",
					"ZoneGraphAnnotations",
					"MassGameplayExternalTraits"
				}
			);

			PrivateDependencyModuleNames.AddRange(
				new string[] {
					"MassActors"
				}
			);
		}
	}
}

=========================================================


=== Source/MassSpawner/Private/MassAssortedFragmentsTrait.cpp ===
=================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassAssortedFragmentsTrait.h"
#include "MassEntityTemplateRegistry.h"


void UMassAssortedFragmentsTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	for (const FInstancedStruct& Fragment : Fragments)
	{
		if (Fragment.IsValid())
		{
			const UScriptStruct* Type = Fragment.GetScriptStruct();
			CA_ASSUME(Type);
			if (Type->IsChildOf(FMassFragment::StaticStruct()))
			{
				BuildContext.AddFragment(Fragment);
			}
			else
			{
				UE_LOG(LogMass, Error, TEXT("Struct type %s is not a child of FMassFragment"), *GetPathNameSafe(Type));
			}
		}
	}
	
	for (const FInstancedStruct& Tag : Tags)
	{
		if (Tag.IsValid())
		{
			const UScriptStruct* Type = Tag.GetScriptStruct();
			CA_ASSUME(Type);
			if (Type->IsChildOf(FMassTag::StaticStruct()))
			{
				BuildContext.AddTag(*Type);
			}
			else
			{
				UE_LOG(LogMass, Error, TEXT("Struct type %s is not a child of FMassTag"), *GetPathNameSafe(Type));
			}
		}
	}
}

=================================================================


=== Source/MassSpawner/Private/MassEntityConfigAsset.cpp ===
============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEntityConfigAsset.h"
#include "Logging/MessageLog.h"
#include "MassEntityTraitBase.h"
#include "MassSpawnerTypes.h"
#include "MassSpawnerSubsystem.h"
#include "MassEntityTemplateRegistry.h"
#include "Serialization/ArchiveObjectCrc32.h"
#include "VisualLogger/VisualLogger.h"
#include "Engine/World.h"
#if WITH_EDITOR
#include "Editor.h"
#include "MassEntityEditor.h"
#include "ScopedTransaction.h"
#endif // WITH_EDITOR

#define LOCTEXT_NAMESPACE "Mass"


//-----------------------------------------------------------------------------
// FMassEntityConfig
//-----------------------------------------------------------------------------
FMassEntityConfig::FMassEntityConfig()
{
	ConfigGuid = FGuid::NewGuid();
}

FMassEntityConfig::FMassEntityConfig(UObject& InOwner)
	: ConfigOwner(&InOwner)
{
	ConfigGuid = FGuid::NewGuid();
}

UMassEntityTraitBase* FMassEntityConfig::FindTraitInternal(TSubclassOf<UMassEntityTraitBase> TraitClass, const bool bExactMatch) const
{
	for (const TObjectPtr<UMassEntityTraitBase>& Trait : Traits)
	{
		if (Trait && (bExactMatch ? Trait->GetClass() == TraitClass : Trait->IsA(TraitClass)))
		{
			return Trait;
		}
	}

	return Parent ? Parent->GetConfig().FindTraitInternal(TraitClass, bExactMatch) : nullptr;
}

const FMassEntityTemplate& FMassEntityConfig::GetOrCreateEntityTemplate(const UWorld& World) const
{
	FMassEntityTemplateID TemplateID;
	if (const FMassEntityTemplate* ExistingTemplate = GetEntityTemplateInternal(World, TemplateID))
	{
		return *ExistingTemplate;
	}

	UMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(&World);
	check(SpawnerSystem);
	FMassEntityTemplateRegistry& TemplateRegistry = SpawnerSystem->GetMutableTemplateRegistryInstance();

	// Build new template
	// TODO: Add methods to FMassEntityTemplateBuildContext to indicate dependency vs setup.
	// Dependency should add a fragment with default values (which later can be overridden),
	// while setup would override values and should be run just once.

	FMassEntityTemplateData TemplateData;
	FMassEntityTemplateBuildContext BuildContext(TemplateData, TemplateID);

	TArray<UMassEntityTraitBase*> CombinedTraits;
	GetCombinedTraits(CombinedTraits);

	BuildContext.BuildFromTraits(CombinedTraits, World);
	BuildContext.SetTemplateName(GetNameSafe(ConfigOwner));

	return TemplateRegistry.FindOrAddTemplate(TemplateID, MoveTemp(TemplateData)).Get();
}

void FMassEntityConfig::DestroyEntityTemplate(const UWorld& World) const
{
	FMassEntityTemplateID TemplateID;
	const FMassEntityTemplate* Template = GetEntityTemplateInternal(World, TemplateID);
	if (Template == nullptr)
	{
		return;
	}

	UMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(&World);
	check(SpawnerSystem);
	FMassEntityTemplateRegistry& TemplateRegistry = SpawnerSystem->GetMutableTemplateRegistryInstance();

	TArray<UMassEntityTraitBase*> CombinedTraits;
	GetCombinedTraits(CombinedTraits);

	for (const UMassEntityTraitBase* Trait : CombinedTraits)
	{
		check(Trait);
		Trait->DestroyTemplate(World);
	}

	// TODO - The templates are not being torn down completely, resulting in traits that leave data in various subsystems. (Representation system)
	
	TemplateRegistry.DestroyTemplate(TemplateID);
}

const FMassEntityTemplate& FMassEntityConfig::GetEntityTemplateChecked(const UWorld& World) const
{
	FMassEntityTemplateID TemplateID;
	const FMassEntityTemplate* ExistingTemplate = GetEntityTemplateInternal(World, TemplateID);
	check(ExistingTemplate);
	return *ExistingTemplate;
}

const FMassEntityTemplate* FMassEntityConfig::GetEntityTemplateInternal(const UWorld& World, FMassEntityTemplateID& OutTemplateID) const
{
	UMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(&World);
	check(SpawnerSystem);
	const FMassEntityTemplateRegistry& TemplateRegistry = SpawnerSystem->GetTemplateRegistryInstance();

	// Return existing template if found.
	OutTemplateID = FMassEntityTemplateIDFactory::Make(ConfigGuid);
	const TSharedRef<FMassEntityTemplate>* TemplateFound = TemplateRegistry.FindTemplateFromTemplateID(OutTemplateID);
	return TemplateFound ? &TemplateFound->Get() : nullptr;
}

void FMassEntityConfig::GetCombinedTraits(TArray<UMassEntityTraitBase*>& OutTraits) const
{
	TArray<const UObject*> Visited;
	OutTraits.Reset();
	Visited.Add(ConfigOwner);
	GetCombinedTraitsInternal(OutTraits, Visited);
}

void FMassEntityConfig::GetCombinedTraitsInternal(TArray<UMassEntityTraitBase*>& OutTraits, TArray<const UObject*>& Visited) const
{
	if (Parent)
	{
		if (Visited.IndexOfByKey(Parent) != INDEX_NONE)
		{
			// Infinite loop detected.
			FString Path;
			for (const UObject* Object : Visited)
			{
				Path += Object->GetName();
				Path += TEXT("/");
			}
			UE_VLOG(ConfigOwner, LogMassSpawner, Error, TEXT("%s: Encountered %s as parent second time (Infinite loop). %s"), *GetNameSafe(ConfigOwner), *GetNameSafe(Parent), *Path);
		}
		else
		{
			Visited.Add(Parent);
			Parent->GetConfig().GetCombinedTraitsInternal(OutTraits, Visited);
		}
	}

	for (UMassEntityTraitBase* Trait : Traits)
	{
		if (!Trait)
		{
			continue;
		}
		// Allow only one feature per type. This is also used to allow child configs override parent features.
		const int32 Index = OutTraits.IndexOfByPredicate([Trait](const UMassEntityTraitBase* ExistingFeature) -> bool { return Trait->GetClass() == ExistingFeature->GetClass(); });
		if (Index != INDEX_NONE)
		{
			OutTraits[Index] = Trait;
		}
		else
		{
			OutTraits.Add(Trait);
		}
	}
}

void FMassEntityConfig::AddTrait(UMassEntityTraitBase& Trait)
{
	Traits.Add(&Trait);
}

bool FMassEntityConfig::ValidateEntityTemplate(const UWorld& World)
{
	TArray<UMassEntityTraitBase*> CombinedTraits;
	GetCombinedTraits(CombinedTraits);

	FMassEntityTemplateData Template;
	FMassEntityTemplateBuildContext BuildContext(Template);

	return BuildContext.BuildFromTraits(CombinedTraits, World);
}

//-----------------------------------------------------------------------------
// DEPRECATED
//-----------------------------------------------------------------------------
const FMassEntityTemplate& FMassEntityConfig::GetOrCreateEntityTemplate(const UWorld& World, const UObject& InConfigOwner) const
{
	return GetOrCreateEntityTemplate(World);
}

void FMassEntityConfig::DestroyEntityTemplate(const UWorld& World, const UObject& InConfigOwner) const
{
	DestroyEntityTemplate(World);
}

const FMassEntityTemplate& FMassEntityConfig::GetEntityTemplateChecked(const UWorld& World, const UObject& InConfigOwner) const
{
	return GetEntityTemplateChecked(World);
}

bool FMassEntityConfig::ValidateEntityTemplate(const UWorld& World, const UObject& InConfigOwner)
{
	return ValidateEntityTemplate(World);
}

void FMassEntityConfig::GetCombinedTraits(TArray<UMassEntityTraitBase*>& OutTraits, TArray<const UObject*>& Visited, const UObject& InConfigOwner) const
{
	return GetCombinedTraitsInternal(OutTraits, Visited);
}

#if WITH_EDITOR
void FMassEntityConfig::PostDuplicate(const bool bDuplicateForPIE)
{
	if (bDuplicateForPIE == false)
	{
		ConfigGuid = FGuid::NewGuid();
	}
}

UMassEntityTraitBase* FMassEntityConfig::FindMutableTrait(TSubclassOf<UMassEntityTraitBase> TraitClass, const bool bExactMatch)
{
	return FindTraitInternal(TraitClass, bExactMatch);
}
#endif // WITH_EDITOR

//-----------------------------------------------------------------------------
// UMassEntityConfigAsset
//-----------------------------------------------------------------------------
#if WITH_EDITOR
void UMassEntityConfigAsset::PostDuplicate(const bool bDuplicateForPIE)
{
	Super::PostDuplicate(bDuplicateForPIE);
	
	Config.PostDuplicate(bDuplicateForPIE);
}

void UMassEntityConfigAsset::ValidateEntityConfig()
{
	if (UWorld* EditorWorld = GEditor->GetEditorWorldContext().World())
	{
		FMessageLog MessageLog(UE::Mass::Editor::MessageLogPageName);
		MessageLog.NewPage(FText::FromName(UE::Mass::Editor::MessageLogPageName));

		if (Config.ValidateEntityTemplate(*EditorWorld))
		{
			FMassEditorNotification Notification;
			Notification.Message = FText::FormatOrdered(LOCTEXT("MassEntityConfigAssetNoErrorsDetected", "There were no errors detected during validation of {0}")
				, FText::FromName(GetFName()));
			Notification.Severity = EMessageSeverity::Info;
			Notification.Show();
		}
	}
}

UMassEntityTraitBase* UMassEntityConfigAsset::AddTrait(TSubclassOf<UMassEntityTraitBase> TraitClass)
{
	check(TraitClass);

	UMassEntityTraitBase* TraitInstance = Config.FindMutableTrait(TraitClass, /*bExactMatch=*/true);
	if (TraitInstance == nullptr)
	{
		const FScopedTransaction Transaction(LOCTEXT("ProcedurallyAddingTrait", "Adding a trait procedurally"));

		Modify();

		TraitInstance = NewObject<UMassEntityTraitBase>(this, TraitClass, FName(), RF_Transactional);
		check(TraitInstance);
		Config.AddTrait(*TraitInstance);
	}
	return TraitInstance;
}
#endif // WITH_EDITOR

#undef LOCTEXT_NAMESPACE 

============================================================


=== Source/MassSpawner/Private/MassEntityEQSSpawnPointsGenerator.cpp ===
========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEntityEQSSpawnPointsGenerator.h"
#include "MassSpawnerTypes.h"
#include "MassSpawnLocationProcessor.h"
#include "VisualLogger/VisualLogger.h"
#include "MassGameplaySettings.h"
#include "MassCommonUtils.h"


UMassEntityEQSSpawnPointsGenerator::UMassEntityEQSSpawnPointsGenerator()
{
	EQSRequest.RunMode = EEnvQueryRunMode::AllMatching; 
}

void UMassEntityEQSSpawnPointsGenerator::Generate(UObject& QueryOwner, TConstArrayView<FMassSpawnedEntityType> EntityTypes, const int32 Count, FFinishedGeneratingSpawnDataSignature& FinishedGeneratingSpawnPointsDelegate) const
{
	if (Count <= 0)
	{
		FinishedGeneratingSpawnPointsDelegate.Execute(TArray<FMassEntitySpawnDataGeneratorResult>());
		return;
	}
	
	// Need to copy the request as it is called inside a CDO and CDO states cannot be changed.
	FEQSParametrizedQueryExecutionRequest EQSRequestInstanced = EQSRequest;
	if (EQSRequestInstanced.IsValid() == false)
	{
		EQSRequestInstanced.InitForOwnerAndBlackboard(QueryOwner, /*BBAsset=*/nullptr);
		if (!ensureMsgf(EQSRequestInstanced.IsValid(), TEXT("Query request initialization can fail due to missing parameters. See the runtime log for details")))
		{
			return;
		}
	}

	// Build array of entity types to spawn.
	// @todo: I dont like that this get's passed by value to OnEQSQueryFinished, but seemed like the cleanest solution.
	TArray<FMassEntitySpawnDataGeneratorResult> Results;
	BuildResultsFromEntityTypes(Count, EntityTypes, Results);

	FQueryFinishedSignature Delegate = FQueryFinishedSignature::CreateUObject(this, &UMassEntityEQSSpawnPointsGenerator::OnEQSQueryFinished, Results, FinishedGeneratingSpawnPointsDelegate);
	EQSRequestInstanced.Execute(QueryOwner, /*BlackboardComponent=*/nullptr, Delegate);
}

void UMassEntityEQSSpawnPointsGenerator::OnEQSQueryFinished(TSharedPtr<FEnvQueryResult> EQSResult, TArray<FMassEntitySpawnDataGeneratorResult> Results,
															FFinishedGeneratingSpawnDataSignature FinishedGeneratingSpawnPointsDelegate) const
{
	if (EQSResult.IsValid() == false || EQSResult->IsSuccessful() == false)
	{
		UE_VLOG_UELOG(this, LogMassSpawner, Error, TEXT("EQS query failed or result is invalid"));
		// Return empty result.
		Results.Reset();
		FinishedGeneratingSpawnPointsDelegate.Execute(Results);
		return;
	}

	TArray<FVector> Locations;
	EQSResult->GetAllAsLocations(Locations);

	// Randomize them
	FRandomStream RandomStream(UE::Mass::Utils::OverrideRandomSeedForTesting(GetRandomSelectionSeed()));
	for (int32 I = 0; I < Locations.Num(); ++I)
	{
		const int32 J = RandomStream.RandHelper(Locations.Num());
		Locations.Swap(I, J);
	}

	const int32 LocationCount = Locations.Num();
	int32 LocationIndex = 0;

	// Distribute points amongst the entities to spawn.
	for (FMassEntitySpawnDataGeneratorResult& Result : Results)
	{
		Result.SpawnDataProcessor = UMassSpawnLocationProcessor::StaticClass();
		Result.SpawnData.InitializeAs<FMassTransformsSpawnData>();
		FMassTransformsSpawnData& Transforms = Result.SpawnData.GetMutable<FMassTransformsSpawnData>();

		Transforms.Transforms.Reserve(Result.NumEntities);
		for (int i = 0; i < Result.NumEntities; i++)
		{
			FTransform& Transform = Transforms.Transforms.AddDefaulted_GetRef();
			Transform.SetLocation(Locations[LocationIndex % LocationCount]);
			LocationIndex++;
		}
	}

#if ENABLE_VISUAL_LOG
	UE_VLOG(this, LogMassSpawner, Log, TEXT("Spawning at %d locations"), LocationIndex);
	if (GetDefault<UMassGameplaySettings>()->bLogSpawnLocations)
	{
		if (FVisualLogEntry* LogEntry = FVisualLogger::Get().GetLastEntryForObject(this))
		{
			FVisualLogShapeElement Element(TEXT(""), FColor::Orange, /*Thickness*/20, LogMassSpawner.GetCategoryName());

			Element.Points.Reserve(LocationIndex);
			for (const FMassEntitySpawnDataGeneratorResult& Result : Results)
			{
				const FMassTransformsSpawnData& Transforms = Result.SpawnData.Get<FMassTransformsSpawnData>();
				for (int i = 0; i < Result.NumEntities; i++)
				{
					Element.Points.Add(Transforms.Transforms[i].GetLocation());
				}
			}
			
			Element.Type = EVisualLoggerShapeElement::SinglePoint;
			Element.Verbosity = ELogVerbosity::Display;
			LogEntry->AddElement(Element);
		}
	}
#endif // ENABLE_VISUAL_LOG

	FinishedGeneratingSpawnPointsDelegate.Execute(Results);
}

#if WITH_EDITOR
void UMassEntityEQSSpawnPointsGenerator::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	static const FName EQSRequestName = GET_MEMBER_NAME_CHECKED(UMassEntityEQSSpawnPointsGenerator, EQSRequest);

	Super::PostEditChangeProperty(PropertyChangedEvent);

	if (PropertyChangedEvent.MemberProperty && PropertyChangedEvent.MemberProperty->GetFName() == EQSRequestName)
	{
		EQSRequest.PostEditChangeProperty(*this, PropertyChangedEvent);
	}
}
#endif
========================================================================


=== Source/MassSpawner/Private/MassEntitySpawnDataGeneratorBase.cpp ===
=======================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEntitySpawnDataGeneratorBase.h"
#include "VisualLogger/VisualLogger.h"
#include "MassSpawnerTypes.h"

void UMassEntitySpawnDataGeneratorBase::BuildResultsFromEntityTypes(const int32 SpawnCount, TConstArrayView<FMassSpawnedEntityType> EntityTypes, TArray<FMassEntitySpawnDataGeneratorResult>& OutResults) const
{
	float TotalProportion = 0.0f;
	for (const FMassSpawnedEntityType& EntityType : EntityTypes)
	{
		TotalProportion += EntityType.Proportion;
	}

	if (TotalProportion <= 0)
	{
		UE_VLOG_UELOG(this, LogMassSpawner, Error, TEXT("The total combined proportion of all the entity types needs to be greater than 0."));
		return;
	}

	for (int32 i = 0; i < EntityTypes.Num(); i++)
	{
		const FMassSpawnedEntityType& EntityType = EntityTypes[i];
		const int32 EntityCount = static_cast<int32>(static_cast<float>(SpawnCount) * EntityType.Proportion / TotalProportion);
		if (EntityCount > 0 && EntityType.GetEntityConfig() != nullptr)
		{
			FMassEntitySpawnDataGeneratorResult& Res = OutResults.AddDefaulted_GetRef();
			Res.NumEntities = EntityCount;
			Res.EntityConfigIndex = i;
		}
	}
}
=======================================================================


=== Source/MassSpawner/Private/MassEntityTemplate.cpp ===
=========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEntityTemplate.h"
#include "VisualLogger/VisualLoggerTypes.h"
#include "MassDebugger.h"
#include "Algo/Find.h"

//----------------------------------------------------------------------//
//  FMassEntityTemplateID
//----------------------------------------------------------------------//
FString FMassEntityTemplateID::ToString() const
{
	return IsValid() ? FString::Printf(TEXT("[%s:%d]"), *ConfigGuid.ToString(EGuidFormats::DigitsLower), FlavorHash) 
			: FString::Printf(TEXT("[Invalid]"));
}

//----------------------------------------------------------------------//
//  FMassEntityTemplateData
//----------------------------------------------------------------------//
FMassEntityTemplateData::FMassEntityTemplateData(const FMassEntityTemplate& InFinalizedTemplate)
	: FMassEntityTemplateData(InFinalizedTemplate.GetTemplateData())
{

}

bool FMassEntityTemplateData::SlowIsEquivalent(const FMassEntityTemplateData& Other) const
{
	if (Composition.IsEquivalent(Other.GetCompositionDescriptor()) == false)
	{
		return false;
	}
	else if (SharedFragmentValues.IsEquivalent(Other.GetSharedFragmentValues()) == false)
	{
		return false;
	}
	
	TConstArrayView<FInstancedStruct> OtherInitialFragmentValues = Other.GetInitialFragmentValues();
	
	if (OtherInitialFragmentValues.Num() != InitialFragmentValues.Num())
	{
		return false;
	}

	for (const FInstancedStruct& InitialValue : InitialFragmentValues)
	{
		const FInstancedStruct* FoundElement = Algo::FindByPredicate(OtherInitialFragmentValues, [&InitialValue](const FInstancedStruct& Element)
		{
			return InitialValue == Element;
		});

		if (FoundElement == nullptr)
		{
			return false;
		}
	}
	return true;
}

uint32 GetTypeHash(const FMassEntityTemplateData& Template)
{
	// @todo: using the template name is temporary solution to allow to tell two templates apart based on something 
	// else than composition. Ideally we would hash the fragment values instead.
	const int32 NameHash = GetTypeHash(Template.GetTemplateName());
	const uint32 CompositionHash = Template.GetCompositionDescriptor().CalculateHash();
	// @todo shared fragments hash is based on pointers - this needs to be changed as well
	const uint32 SharedFragmentValuesHash = GetTypeHash(Template.GetSharedFragmentValues());
	
	uint32 InitialValuesHash = 0;
	// Initial fragment values, this is not part of the archetype as it is the spawner job to set them.
	for (const FInstancedStruct& Struct : Template.GetInitialFragmentValues())
	{
		InitialValuesHash = UE::StructUtils::GetStructCrc32(Struct, InitialValuesHash);
	}

	// These functions will be called to initialize entity's UObject-based fragments
	// @todo this is very bad for hash creation - no way to make this consistent between client server. Might need some "initializer index"
	uint32 InitializersHash = 0;
	/* left here on purpose, will address in following CLs
	for (const FMassEntityTemplateData::FObjectFragmentInitializerFunction& Initializer : Template.ObjectInitializers)
	{
		InitializersHash = HashCombine(InitializersHash, GetTypeHash(Initializer));
	}*/

	// @todo maybe better to have two separate hashes - one for composition and maybe shared fragments, and then the other one for the rest, and use multimap for look up
	return HashCombine(NameHash, HashCombine(HashCombine(CompositionHash, SharedFragmentValuesHash), HashCombine(InitialValuesHash, InitializersHash)));
}

//-----------------------------------------------------------------------------
// FMassEntityTemplate
//-----------------------------------------------------------------------------
TSharedRef<FMassEntityTemplate> FMassEntityTemplate::MakeFinalTemplate(FMassEntityManager& EntityManager, FMassEntityTemplateData&& TempTemplateData, FMassEntityTemplateID InTemplateID)
{
	return MakeShared<FMassEntityTemplate>(MoveTemp(TempTemplateData), EntityManager, InTemplateID);
}

FMassEntityTemplate::FMassEntityTemplate(const FMassEntityTemplateData& InData, FMassEntityManager& EntityManager, FMassEntityTemplateID InTemplateID)
	: TemplateData(InData)
	, TemplateID(InTemplateID)
{
	// Sort anything there is to sort for later comparison purposes
	TemplateData.Sort();

	TemplateData.GetArchetypeCreationParams().DebugName = FName(GetTemplateName());
	const FMassArchetypeHandle ArchetypeHandle = EntityManager.CreateArchetype(GetCompositionDescriptor(), TemplateData.GetArchetypeCreationParams());
	SetArchetype(ArchetypeHandle);
}

FMassEntityTemplate::FMassEntityTemplate(FMassEntityTemplateData&& InData, FMassEntityManager& EntityManager, FMassEntityTemplateID InTemplateID)
	: TemplateData(InData)
	, TemplateID(InTemplateID)
{
	// Sort anything there is to sort for later comparison purposes
	TemplateData.Sort();

	TemplateData.GetArchetypeCreationParams().DebugName = FName(GetTemplateName());
	const FMassArchetypeHandle ArchetypeHandle = EntityManager.CreateArchetype(GetCompositionDescriptor(), TemplateData.GetArchetypeCreationParams());
	SetArchetype(ArchetypeHandle);
}

void FMassEntityTemplate::SetArchetype(const FMassArchetypeHandle& InArchetype)
{
	check(InArchetype.IsValid());
	Archetype = InArchetype;
}

FString FMassEntityTemplate::DebugGetArchetypeDescription(FMassEntityManager& EntityManager) const
{
	FStringOutputDevice OutDescription;
#if WITH_MASSGAMEPLAY_DEBUG
	FMassDebugger::OutputArchetypeDescription(OutDescription, Archetype);
#endif // WITH_MASSGAMEPLAY_DEBUG
	return MoveTemp(OutDescription);
}

FString FMassEntityTemplate::DebugGetDescription(FMassEntityManager* EntityManager) const
{
	FStringOutputDevice Ar;
#if WITH_MASSGAMEPLAY_DEBUG
	Ar.SetAutoEmitLineTerminator(true);

	if (EntityManager)
	{
		Ar += TEXT("Archetype details:\n");
		Ar += DebugGetArchetypeDescription(*EntityManager);
	}
	else
	{
		Ar += TEXT("Composition:\n");
		GetCompositionDescriptor().DebugOutputDescription(Ar);
	}

#endif // WITH_MASSGAMEPLAY_DEBUG
	return MoveTemp(Ar);
}

//-----------------------------------------------------------------------------
// FMassEntityTemplateIDFactory
//-----------------------------------------------------------------------------
FMassEntityTemplateID FMassEntityTemplateIDFactory::Make(const FGuid& ConfigGuid)
{
	return FMassEntityTemplateID(ConfigGuid);
}

FMassEntityTemplateID FMassEntityTemplateIDFactory::MakeFlavor(const FMassEntityTemplateID& SourceTemplateID, const int32 Flavor)
{
	return FMassEntityTemplateID(SourceTemplateID.ConfigGuid, Flavor);
}

=========================================================


=== Source/MassSpawner/Private/MassEntityTemplateRegistry.cpp ===
=================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEntityTemplateRegistry.h"
#include "MassSpawnerTypes.h"
#include "MassEntityManager.h"
#include "Engine/World.h"
#include "VisualLogger/VisualLogger.h"
#include "MassSpawnerSubsystem.h"
#include "MassEntityTypes.h"
#include "MassEntityTraitBase.h"

#if WITH_EDITOR
#include "Editor.h"
#include "MassDebugger.h"
#include "MassEntityEditor.h"
#endif

#define LOCTEXT_NAMESPACE "Mass"

namespace UE::Mass::Debug
{
	const FName TraitFailedValidation(TEXT("TraitFailedValidation"));
	const FName TraitIgnored(TEXT("TraitIgnored"));

	static bool bReportDuplicatedFragmentsAsWarnings = false;
	// anonymous namespace to force CVars's uniqueness - we use the same name in many places, sometimes withing same namespaces
	namespace 
	{
		FAutoConsoleVariableRef CVars[] =
		{
			{ TEXT("mass.template.DuplicateElementsAsWarnings")
				, bReportDuplicatedFragmentsAsWarnings
				, TEXT("Whether to report a detection of a given element type being added by multiple traits as a Warning. Otherise we print the information out as `Info`")
				, ECVF_Cheat}
		};
	}
}

//----------------------------------------------------------------------//
// FMassEntityTemplateRegistry 
//----------------------------------------------------------------------//
TMap<const UScriptStruct*, FMassEntityTemplateRegistry::FStructToTemplateBuilderDelegate> FMassEntityTemplateRegistry::StructBasedBuilders;

FMassEntityTemplateRegistry::FMassEntityTemplateRegistry(UObject* InOwner)
	: Owner(InOwner)
{
}

void FMassEntityTemplateRegistry::ShutDown()
{
	TemplateIDToTemplateMap.Reset();
	EntityManager = nullptr;
}

UWorld* FMassEntityTemplateRegistry::GetWorld() const 
{
	return Owner.IsValid() ? Owner->GetWorld() : nullptr;
}

FMassEntityTemplateRegistry::FStructToTemplateBuilderDelegate& FMassEntityTemplateRegistry::FindOrAdd(const UScriptStruct& DataType)
{
	return StructBasedBuilders.FindOrAdd(&DataType);
}

void FMassEntityTemplateRegistry::Initialize(const TSharedPtr<FMassEntityManager>& InEntityManager)
{
	if (EntityManager)
	{
		ensureMsgf(EntityManager == InEntityManager, TEXT("Attempting to store a different EntityManager then the previously stored one - this indicated a set up issue, attempting to use multiple EntityManager instances"));
		return;
	}

	EntityManager = InEntityManager;
}

void FMassEntityTemplateRegistry::DebugReset()
{
#if WITH_MASSGAMEPLAY_DEBUG
	TemplateIDToTemplateMap.Reset();
#endif // WITH_MASSGAMEPLAY_DEBUG
}

const TSharedRef<FMassEntityTemplate>* FMassEntityTemplateRegistry::FindTemplateFromTemplateID(FMassEntityTemplateID TemplateID) const
{
	return TemplateIDToTemplateMap.Find(TemplateID);
}

const TSharedRef<FMassEntityTemplate>& FMassEntityTemplateRegistry::FindOrAddTemplate(FMassEntityTemplateID TemplateID, FMassEntityTemplateData&& TemplateData)
{
	check(EntityManager);
	const TSharedRef<FMassEntityTemplate>* ExistingTemplate = FindTemplateFromTemplateID(TemplateID);
	if (ExistingTemplate != nullptr)
	{
		return *ExistingTemplate;
	}

	return TemplateIDToTemplateMap.Add(TemplateID, FMassEntityTemplate::MakeFinalTemplate(*EntityManager, MoveTemp(TemplateData), TemplateID));
}

void FMassEntityTemplateRegistry::DestroyTemplate(FMassEntityTemplateID TemplateID)
{
	TemplateIDToTemplateMap.Remove(TemplateID);
}

//----------------------------------------------------------------------//
// FMassEntityTemplateBuildContext 
//----------------------------------------------------------------------//
bool FMassEntityTemplateBuildContext::BuildFromTraits(TConstArrayView<UMassEntityTraitBase*> Traits, const UWorld& World)
{
	ensureMsgf(bBuildInProgress == false, TEXT("Unexpected occurrence - it suggests FMassEntityTemplateBuildContext::BuildFromTraits "
		"has been called as a consequence of some UMassEntityTraitBase::BuildTemplate call. Check the callstack."));

	bBuildInProgress = true;
	for (const UMassEntityTraitBase* Trait : Traits)
	{
		check(Trait);
		if (SetTraitBeingProcessed(Trait))
		{
			Trait->BuildTemplate(*this, World);
		}
	}
	// now remove all that has been requested to be removed
	// those are only tags for now, thus the shortcut of going directly for tags
	for (FRemovedType& Removed : RemovedTypes)
	{
		check(Removed.TypeRemoved);
		TemplateData.RemoveTag(*CastChecked<UScriptStruct>(Removed.TypeRemoved));
	}

	bBuildInProgress = false;

	const bool bTemplateValid = ValidateBuildContext(World);
	
	ResetBuildTimeData();

	return bTemplateValid;
}

bool FMassEntityTemplateBuildContext::SetTraitBeingProcessed(const UMassEntityTraitBase* Trait)
{
	if (Trait == nullptr || TraitsProcessed.Contains(Trait) == false)
	{
		TraitsData.Add({Trait});
		return true;
	}

	UE_LOG(LogMass, Warning, TEXT("Attempting to add %s to FMassEntityTemplateBuildContext while this or another instance of the trait class has already been added.")
		, *GetNameSafe(Trait));

	IgnoredTraits.Add(Trait);
	return false;
}

bool FMassEntityTemplateBuildContext::ValidateBuildContext(const UWorld& World)
{
#if WITH_UNREAL_DEVELOPER_TOOLS && WITH_EDITOR && WITH_EDITORONLY_DATA && WITH_MASSENTITY_DEBUG
#define IF_MESSAGES(Message) if (GEditor) { Message }
#else
#define IF_MESSAGES(_)
#endif

	int32 ErrorCount = 0;
	int32 WarningCount = 0;

	// Doing the trait-specific validation first since it can add required elements to the build context
	for (FTraitData& TraitData : TraitsData)
	{
		UMassEntityTraitBase::FAdditionalTraitRequirements TraitRequirementsWrapper(TraitData.TypesRequired);
		if (LIKELY(TraitData.Trait) && TraitData.Trait->ValidateTemplate(*this, World, TraitRequirementsWrapper) == false)
		{
			++ErrorCount;
			IF_MESSAGES(
				FMassDebugger::DebugEvent(UE::Mass::Debug::TraitFailedValidation, FConstStructView::Make(FMassGenericDebugEvent{TraitData.Trait}));
			);
		}
	}

	TMap<const UStruct*, const UMassEntityTraitBase*> TypesAlreadyAdded;

	// these are non-critical warnings, we want to report these to the users as a potential configuration issue,
	// but it won't affect the final entity template composition (for example adding the same fragment is fine since 
	// the entity template handles that gracefully).
	for (const FTraitData& TraitData : TraitsData)
	{
		for (const UStruct* TypeAdded : TraitData.TypesAdded)
		{
			const UMassEntityTraitBase*& SourceTrait = TypesAlreadyAdded.FindOrAdd(TypeAdded);
			if (SourceTrait != nullptr)
			{
				if (UE::Mass::Debug::bReportDuplicatedFragmentsAsWarnings)
				{
					// we report this only if it wasn't added twice by the same trait, the one we're processing right now
					UE_CLOG(SourceTrait != TraitData.Trait
						, LogMass, Warning, TEXT("%s: Fragment %s already added by %s. Check the entity config for conflicting traits")
						, *GetNameSafe(TraitData.Trait), *GetNameSafe(TypeAdded), *SourceTrait->GetName());
					++WarningCount;
				}
				IF_MESSAGES(
					FMassDebugger::DebugEvent(FMassDuplicateElementsMessage::StaticStruct()->GetFName()
						, FConstStructView::Make(FMassDuplicateElementsMessage{TraitData.Trait, SourceTrait, TypeAdded})
						, UE::Mass::Debug::bReportDuplicatedFragmentsAsWarnings ? EMassDebugMessageSeverity::Warning : EMassDebugMessageSeverity::Info);
				);
			}
			else
			{
				SourceTrait = TraitData.Trait;
			}
		}
	}

	// now to properly test if something required was removed we need to filter TypesAlreadyAdded first
	for (const FRemovedType& RemovedElement : RemovedTypes)
	{
		if (RemovedElement.TypeRemoved)
		{
			TypesAlreadyAdded.Remove(RemovedElement.TypeRemoved);
		}
	}

	// these are critical, we're going to fail the validation if anything here fails
	for (const FTraitData& TraitData : TraitsData)
	{
		for (const UStruct* TypeRequired : TraitData.TypesRequired)
		{
			if (TypesAlreadyAdded.Contains(TypeRequired) == false)
			{
				UE_LOG(LogMass, Error, TEXT("%s: Missing required element of type %s")
					, *GetNameSafe(TraitData.Trait), *GetNameSafe(TypeRequired));
				++ErrorCount;
				IF_MESSAGES(
				{
					// check if it was removed
					const UMassEntityTraitBase* RemovedByTrait = nullptr;
					const int32 RemoverIndex = RemovedTypes.Find(FRemovedType({TypeRequired}));
					if (RemoverIndex != INDEX_NONE)
					{
						RemovedByTrait = RemovedTypes[RemoverIndex].Remover;
					}

					FMassDebugger::DebugEvent<FMassMissingTraitMessage>(TraitData.Trait, TypeRequired, RemovedByTrait);
				});
			}
		}
	}

	for (const UMassEntityTraitBase* IgnoredTrait : IgnoredTraits)
	{
		IF_MESSAGES(
			FMassDebugger::DebugEvent(UE::Mass::Debug::TraitIgnored, FConstStructView::Make(FMassGenericDebugEvent{IgnoredTrait}));
		);
		++WarningCount;
	}
	
	// @todo add dependencies on trait classes? might be hard if traits are unrelated, like requiring UMassLODCollectorTrait 
	// or UMassDistanceLODCollectorTrait - both supply alternative implementations of a given functionality, but are unrelated.
	// Could be done with a complex requirements system (similar to entity queries - "all of X", "any of Y", etc) - probably 
	// not worth it since we don't even have a use case for it right now.

#if WITH_UNREAL_DEVELOPER_TOOLS && WITH_EDITOR
	if (GEditor && (ErrorCount || WarningCount))
	{
		FMassEditorNotification Notification;
		Notification.Message = FText::FormatOrdered(LOCTEXT("TraitResult", "Mass Entity Template validation:\n{0} errors and {1} warnings found"), ErrorCount, WarningCount);
		Notification.Severity = ErrorCount ? EMessageSeverity::Error : EMessageSeverity::Warning;
		Notification.bIncludeSeeOutputLogForDetails = true;
		Notification.Show();
	}
#endif // WITH_UNREAL_DEVELOPER_TOOLS && WITH_EDITOR

#undef IF_MESSAGES

	// only the Errors render the template invalid, Warnings just warn about stuff not being set up quite right, but we can recover.
	return (ErrorCount == 0);
}

//-----------------------------------------------------------------------------
// DEPRECATED
//-----------------------------------------------------------------------------
FMassEntityTemplate* FMassEntityTemplateRegistry::FindMutableTemplateFromTemplateID(FMassEntityTemplateID TemplateID)
{
	return nullptr;
}

FMassEntityTemplate& FMassEntityTemplateRegistry::CreateTemplate(const uint32 HashLookup, FMassEntityTemplateID TemplateID)
{
	static FMassEntityTemplate Dummy;
	return Dummy;
}

void FMassEntityTemplateRegistry::InitializeEntityTemplate(FMassEntityTemplate& InOutTemplate) const
{}

#undef LOCTEXT_NAMESPACE 

=================================================================


=== Source/MassSpawner/Private/MassEntityTraitBase.cpp ===
==========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEntityTraitBase.h"

//----------------------------------------------------------------------//
//  UMassEntityTraitBase
//----------------------------------------------------------------------//
void UMassEntityTraitBase::DestroyTemplate() const 
{

}

bool UMassEntityTraitBase::ValidateTemplate(const FMassEntityTemplateBuildContext& BuildContext, const UWorld& World, FAdditionalTraitRequirements& OutTraitRequirements) const
{
	return true;
}

#if WITH_EDITOR
UMassEntityTraitBase::FOnNewTraitType UMassEntityTraitBase::OnNewTraitTypeEvent;

void UMassEntityTraitBase::PostInitProperties()
{
	Super::PostInitProperties();

	if (HasAnyFlags(RF_ClassDefaultObject))
	{
		OnNewTraitTypeEvent.Broadcast(*this);
	}
}

#endif // WITH_EDITOR

//-----------------------------------------------------------------------------
// DEPRECATED
//-----------------------------------------------------------------------------
bool UMassEntityTraitBase::ValidateTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const
{
	TArray<const UStruct*> AdditionalRequirements;
	FAdditionalTraitRequirements AdditionalTraitRequirementsWrapper(AdditionalRequirements);
	return ValidateTemplate(BuildContext, World, AdditionalTraitRequirementsWrapper);
}
==========================================================


=== Source/MassSpawner/Private/MassEntityZoneGraphSpawnPointsGenerator.cpp ===
==============================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassEntityZoneGraphSpawnPointsGenerator.h"
#include "ZoneGraphSubsystem.h"
#include "ZoneGraphQuery.h"
#include "MassSpawnerTypes.h"
#include "Engine/World.h"
#include "VisualLogger/VisualLogger.h"
#include "MassGameplaySettings.h"
#include "MassSpawnLocationProcessor.h"
#include "Engine/World.h"
#include "MassCommonUtils.h"

void UMassEntityZoneGraphSpawnPointsGenerator::Generate(UObject& QueryOwner, TConstArrayView<FMassSpawnedEntityType> EntityTypes, int32 Count, FFinishedGeneratingSpawnDataSignature& FinishedGeneratingSpawnPointsDelegate) const
{
	if (Count <= 0)
	{
		FinishedGeneratingSpawnPointsDelegate.Execute(TArray<FMassEntitySpawnDataGeneratorResult>());
		return;
	}
	
	const UZoneGraphSubsystem* ZoneGraph = UWorld::GetSubsystem<UZoneGraphSubsystem>(QueryOwner.GetWorld());
	if (ZoneGraph == nullptr)
	{
		UE_VLOG_UELOG(&QueryOwner, LogMassSpawner, Error, TEXT("No zone graph subsystem found in world"));
		return;
	}

	TArray<FVector> Locations;
	
	const FRandomStream RandomStream(UE::Mass::Utils::OverrideRandomSeedForTesting(GetRandomSelectionSeed()));
	const TConstArrayView<FRegisteredZoneGraphData> RegisteredZoneGraphs = ZoneGraph->GetRegisteredZoneGraphData();
	if (RegisteredZoneGraphs.IsEmpty())
	{
		UE_VLOG_UELOG(&QueryOwner, LogMassSpawner, Error, TEXT("No zone graphs found"));
		return;
	}

	for (const FRegisteredZoneGraphData& Registered : RegisteredZoneGraphs)
	{
		if (Registered.bInUse && Registered.ZoneGraphData)
		{
			GeneratePointsForZoneGraphData(*Registered.ZoneGraphData, Locations, RandomStream);
		}
	}

	if (Locations.IsEmpty())
	{
		UE_VLOG_UELOG(&QueryOwner, LogMassSpawner, Error, TEXT("No locations found on zone graphs"));
		return;
	}

	// Randomize them
	for (int32 I = 0; I < Locations.Num(); ++I)
	{
		const int32 J = RandomStream.RandHelper(Locations.Num());
		Locations.Swap(I, J);
	}

	// If we generated too many, shrink it.
	if (Locations.Num() > Count)
	{
		Locations.SetNum(Count);
	}

	// Build array of entity types to spawn.
	TArray<FMassEntitySpawnDataGeneratorResult> Results;
	BuildResultsFromEntityTypes(Count, EntityTypes, Results);

	const int32 LocationCount = Locations.Num();
	int32 LocationIndex = 0;

	// Distribute points amongst the entities to spawn.
	for (FMassEntitySpawnDataGeneratorResult& Result : Results)
	{
		// @todo: Make separate processors and pass the ZoneGraph locations directly.
		Result.SpawnDataProcessor = UMassSpawnLocationProcessor::StaticClass();
		Result.SpawnData.InitializeAs<FMassTransformsSpawnData>();
		FMassTransformsSpawnData& Transforms = Result.SpawnData.GetMutable<FMassTransformsSpawnData>();

		Transforms.Transforms.Reserve(Result.NumEntities);
		for (int i = 0; i < Result.NumEntities; i++)
		{
			FTransform& Transform = Transforms.Transforms.AddDefaulted_GetRef();
			Transform.SetLocation(Locations[LocationIndex % LocationCount]);
			LocationIndex++;
		}
	}

#if ENABLE_VISUAL_LOG
	UE_VLOG(this, LogMassSpawner, Log, TEXT("Spawning at %d locations"), LocationIndex);
	if (GetDefault<UMassGameplaySettings>()->bLogSpawnLocations)
	{
		if (FVisualLogEntry* LogEntry = FVisualLogger::Get().GetLastEntryForObject(this))
		{
			FVisualLogShapeElement Element(TEXT(""), FColor::Orange, /*Thickness*/20, LogMassSpawner.GetCategoryName());

			Element.Points.Reserve(LocationIndex);
			for (const FMassEntitySpawnDataGeneratorResult& Result : Results)
			{
				const FMassTransformsSpawnData& Transforms = Result.SpawnData.Get<FMassTransformsSpawnData>();
				for (int i = 0; i < Result.NumEntities; i++)
				{
					Element.Points.Add(Transforms.Transforms[i].GetLocation());
				}
			}
			
			Element.Type = EVisualLoggerShapeElement::SinglePoint;
			Element.Verbosity = ELogVerbosity::Display;
			LogEntry->AddElement(Element);
		}
	}
#endif // ENABLE_VISUAL_LOG

	FinishedGeneratingSpawnPointsDelegate.Execute(Results);
}

void UMassEntityZoneGraphSpawnPointsGenerator::GeneratePointsForZoneGraphData(const ::AZoneGraphData& ZoneGraphData, TArray<FVector>& Locations, const FRandomStream& RandomStream) const
{
	// Avoid an infinite loop.
	if (MinGap == 0.0f && MaxGap == 0.0f)
	{
		UE_VLOG_UELOG(this, LogMassSpawner, Error, TEXT("You cannot set both Min Gap and Max Gap to 0.0f"));
		return;						
	}

	const FZoneGraphStorage &ZoneGraphStorage = ZoneGraphData.GetStorage();
	
	// Loop through all lanes
	for (int32 LaneIndex = 0; LaneIndex < ZoneGraphStorage.Lanes.Num(); ++LaneIndex)
	{
		const FZoneLaneData& Lane = ZoneGraphStorage.Lanes[LaneIndex];
		const float LaneHalfWidth = Lane.Width / 2.0f;
		if (TagFilter.Pass(Lane.Tags))
		{
			float LaneLength = 0.0f;
			UE::ZoneGraph::Query::GetLaneLength(ZoneGraphStorage, LaneIndex, LaneLength);

			float Distance = static_cast<float>(RandomStream.FRandRange(MinGap, MaxGap)); // ..initially
			while (Distance <= LaneLength)
			{
				// Add location at the center of this space.
				FZoneGraphLaneLocation LaneLocation;
				UE::ZoneGraph::Query::CalculateLocationAlongLane(ZoneGraphStorage, LaneIndex, Distance, LaneLocation);
				const FVector Perp = LaneLocation.Direction ^ LaneLocation.Up;
				Locations.Add(LaneLocation.Position + Perp * RandomStream.FRandRange(-LaneHalfWidth, LaneHalfWidth));

				// Advance ahead past the space we just consumed, plus a random gap.
				Distance += static_cast<float>(RandomStream.FRandRange(MinGap, MaxGap));
			}
		}
	}
}

==============================================================================


=== Source/MassSpawner/Private/MassSpawner.cpp ===
==================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSpawner.h"
#include "Engine/Engine.h"
#include "Engine/World.h"
#include "UObject/ConstructorHelpers.h"
#include "Components/SceneComponent.h"
#include "Components/BillboardComponent.h"
#include "MassSpawnerTypes.h"
#include "MassSpawnerSubsystem.h"
#include "MassSimulationSubsystem.h"
#include "EnvironmentQuery/EnvQuery.h"
#include "VisualLogger/VisualLogger.h"
#include "MassEntityConfigAsset.h"
#include "MassEntityManager.h"
#include "EngineUtils.h"
#include "Engine/StreamableManager.h"
#include "Engine/AssetManager.h"
#include "MassSpawnLocationProcessor.h"
#include "MassExecutor.h"
#include "MassEntityUtils.h"
#if WITH_EDITOR
#include "Engine/Texture2D.h"
#endif


namespace UE::MassSpawner
{
	float ScalabilitySpawnDensityMultiplier = 1.f;
	FAutoConsoleVariableRef CVarScalabilitySpawnDensityMultiplier(TEXT("ai.mass.scalability.SpawnDensityMultiplier"), ScalabilitySpawnDensityMultiplier, TEXT("Spawn Density Multiplier, must be set before Mass Spawn Init"), ECVF_Scalability);

#if WITH_EDITOR
	static FAutoConsoleCommandWithWorld ForceSpawningCommand(
	TEXT("ai.mass.ForceSpawn"),
	TEXT("Command to Force Spawn all mass entities generated by MassSpawners"),
	FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* World)
	{
		for (TActorIterator<AActor> It(World, AMassSpawner::StaticClass()); It; ++It)
		{
			if (AMassSpawner* Spawner = Cast<AMassSpawner>(*It))
			{
				Spawner->DoSpawning();
			}
		}
	}));

	static FAutoConsoleCommandWithWorld ForceDespawningCommand(
	TEXT("ai.mass.ForceDespawn"),
	TEXT("Command to Force Despawn all mass entities generated by MassSpawners"),
	FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* World)
	{
		for (TActorIterator<AActor> It(World, AMassSpawner::StaticClass()); It; ++It)
		{
			if (AMassSpawner* Spawner = Cast<AMassSpawner>(*It))
			{
				Spawner->DoDespawning();
			}
		}
	}));

	static FAutoConsoleCommandWithWorld ResetSpawningCommand(
	TEXT("ai.mass.ResetSpawning"),
	TEXT("Command to Force Despawn and Respawn all mass entities generated by MassSpawners"),
	FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* World)
	{
		for (TActorIterator<AActor> It(World, AMassSpawner::StaticClass()); It; ++It)
		{
			if (AMassSpawner* Spawner = Cast<AMassSpawner>(*It))
			{
				Spawner->DoDespawning();
				Spawner->DoSpawning();
			}
		}
	}));
#endif // WITH_EDITOR
}

AMassSpawner::AMassSpawner()
{
	RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("SceneComp"));
	RootComponent->Mobility = EComponentMobility::Static;

#if WITH_EDITOR
	SpriteComponent = CreateEditorOnlyDefaultSubobject<UBillboardComponent>(TEXT("Sprite"));

	// SpriteComponent can be null for editor builds running "-game|server"
	if (!IsRunningCommandlet() && SpriteComponent != nullptr)
	{
		// Structure to hold one-time initialization
		struct FConstructorStatics
		{
			ConstructorHelpers::FObjectFinderOptional<UTexture2D> IconTextureObject;
			FName MassSpawnerID;
			FText MassSpawnerName;
			FConstructorStatics()
				: IconTextureObject(TEXT("/MassGameplay/S_MassCrowd"))
				, MassSpawnerID(TEXT("MassSpawner"))
				, MassSpawnerName(NSLOCTEXT("SpriteCategory", "MassSpawner", "MassSpawner"))
			{
			}
		};
		static FConstructorStatics ConstructorStatics;
		
		SpriteComponent->Sprite = ConstructorStatics.IconTextureObject.Get();
		SpriteComponent->SetRelativeScale3D(FVector(0.5f, 0.5f, 0.5f));
		SpriteComponent->SpriteInfo.Category = ConstructorStatics.MassSpawnerID;
		SpriteComponent->SpriteInfo.DisplayName = ConstructorStatics.MassSpawnerName;
		SpriteComponent->SetupAttachment(RootComponent);
		SpriteComponent->Mobility = EComponentMobility::Static;
	}
#endif // WITH_EDITOR

	SetCanBeDamaged(false);

#if UE_BUILD_SHIPPING || UE_BUILD_TEST
	SetActorHiddenInGame(true);
#endif

	bAutoSpawnOnBeginPlay = true;
	bOverrideSchematics = false;
}

void AMassSpawner::PostLoad()
{
	Super::PostLoad();

	for (FMassSpawnDataGenerator& SpawnPointsGenerator : SpawnDataGenerators)
	{
		if (SpawnPointsGenerator.GeneratorClass)
		{
			SpawnPointsGenerator.GeneratorInstance = NewObject<UMassEntitySpawnDataGeneratorBase>(this, SpawnPointsGenerator.GeneratorClass);
			SpawnPointsGenerator.GeneratorClass = nullptr;
			MarkPackageDirty();
		}
	}
}

void AMassSpawner::PostRegisterAllComponents()
{
	Super::PostRegisterAllComponents();

	if (HasAnyFlags(RF_ClassDefaultObject) == false)
	{
		UWorld* World = GetWorld();
		check(World);


		// This is a temp fix for streaming levels async loading MassSpawners after UMassSpawnerSubsystem::OnPostWorldInit, 
		// in the long run we are going to need a better system for making sure all the entity templates are registered
		// on the clients before replication of Agents occurs. This is only required to be done for clients.
		if (GEngine->GetNetMode(GetWorld()) == NM_Client)
		{
			UMassSpawnerSubsystem* MassSpawnerSubsystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(World);
			if (MassSpawnerSubsystem)
			{
				RegisterEntityTemplates();
			}
			else
			{
				FWorldDelegates::OnPostWorldInitialization.AddUObject(this, &AMassSpawner::OnPostWorldInit);
			}
		}
	}
}

void AMassSpawner::OnPostWorldInit(UWorld* World, const UWorld::InitializationValues)
{
	if (World == GetWorld())
	{
		UMassSpawnerSubsystem* MassSpawnerSubsystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(World);
		check(MassSpawnerSubsystem);

		RegisterEntityTemplates();

		FWorldDelegates::OnPostWorldInitialization.Remove(OnPostWorldInitDelegateHandle);
	}
}

void AMassSpawner::BeginDestroy()
{
	FWorldDelegates::OnPostWorldInitialization.Remove(OnPostWorldInitDelegateHandle);

	DoDespawning();
	
	if (StreamingHandle.IsValid() && StreamingHandle->IsActive())
	{
		StreamingHandle->CancelHandle();
	}

	Super::BeginDestroy();
}

void AMassSpawner::BeginPlay()
{
	check(GEngine);

	Super::BeginPlay();

	const ENetMode NetMode = GEngine->GetNetMode(GetWorld());

	if (bAutoSpawnOnBeginPlay && NetMode != NM_Client)
	{
		const UMassSimulationSubsystem* MassSimulationSubsystem = UWorld::GetSubsystem<UMassSimulationSubsystem>(GetWorld());
		if (MassSimulationSubsystem == nullptr || MassSimulationSubsystem->IsSimulationStarted())
		{
			DoSpawning();
		}
		else
		{
			
			SimulationStartedHandle = UMassSimulationSubsystem::GetOnSimulationStarted().AddLambda([this](UWorld* InWorld)
				{
					UWorld* World = GetWorld();

					if (World == InWorld)
					{
						DoSpawning();
					}
				});
		}
	}
}

void AMassSpawner::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	UMassSimulationSubsystem::GetOnSimulationStarted().Remove(SimulationStartedHandle);

	DoDespawning();

	Super::EndPlay(EndPlayReason);
}

#if WITH_EDITOR
void AMassSpawner::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	static const FName EntityTypesName = GET_MEMBER_NAME_CHECKED(AMassSpawner, EntityTypes);

	Super::PostEditChangeProperty(PropertyChangedEvent);

	if (PropertyChangedEvent.Property)
	{
		const FName PropName = PropertyChangedEvent.Property->GetFName();
		if (PropName == EntityTypesName)
		{
			// TODO: Should optimize this, i.e. set a dirty flag and update only when needed.
			UMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(GetWorld());
			if (SpawnerSystem)
			{
				RegisterEntityTemplates();
			}
		}
	}
}

void AMassSpawner::DEBUG_Spawn()
{
	DoSpawning();
}

void AMassSpawner::DEBUG_Clear()
{
	DoDespawning();
}

#endif // WITH_EDITOR

void AMassSpawner::RegisterEntityTemplates()
{
	UWorld* World = GetWorld();
	check(World);
	for (FMassSpawnedEntityType& EntityType : EntityTypes)
	{
		if (const UMassEntityConfigAsset* EntityConfig = EntityType.GetEntityConfig())
		{
			EntityConfig->GetOrCreateEntityTemplate(*World);
		}
	}
}

void AMassSpawner::DoSpawning()
{
	// no spawn point generators configured. Let user know and fall back to the spawner's location
	if (SpawnDataGenerators.Num() == 0)
	{
		UE_VLOG_UELOG(this, LogMassSpawner, Warning, TEXT("No Spawn Data Generators configured."));
		return;
	}
	
	if (EntityTypes.Num() == 0)
	{
		UE_VLOG_UELOG(this, LogMassSpawner, Warning, TEXT("No EntityTypes configured."));
		return;
	}

	AllGeneratedResults.Reset();
	
	float TotalProportion = 0.0f;
	for (FMassSpawnDataGenerator& Generator : SpawnDataGenerators)
	{
		if (Generator.GeneratorInstance)
		{
			Generator.bDataGenerated = false;
			TotalProportion += Generator.Proportion;
		}
	}

	if (TotalProportion <= 0.0f)
	{
		UE_VLOG_UELOG(this, LogMassSpawner, Error, TEXT("The total combined proportion of all the generator needs to be greater than 0."));
		return;
	}
	
	// Check if it needs loading
	if (StreamingHandle.IsValid() && StreamingHandle->IsActive())
	{
		// @todo, instead of blindly canceling, we should remember what was asked to load with that handle and compare if more is needed?
		StreamingHandle->CancelHandle();
	}
	TArray<FSoftObjectPath> AssetsToLoad;
	for (const FMassSpawnedEntityType& EntityType : EntityTypes)
	{
		if (!EntityType.IsLoaded())
		{
			AssetsToLoad.Add(EntityType.EntityConfig.ToSoftObjectPath());
		}
	}
	
	const int32 TotalSpawnCount = GetSpawnCount();
	
	auto GenerateSpawningPoints = [this, TotalSpawnCount, TotalProportion]()
	{
		int32 SpawnCountRemaining = TotalSpawnCount;
		float ProportionRemaining = TotalProportion;
		for (FMassSpawnDataGenerator& Generator : SpawnDataGenerators)
		{
			if (Generator.Proportion == 0.0f || ProportionRemaining <= 0.0f)
			{
				// If there's nothing to spawn, mark the generator done as OnSpawnDataGenerationFinished() will wait for all generators to complete before the actual spawning.
				Generator.bDataGenerated = true;
				continue;
			}

			if (Generator.GeneratorInstance)
			{
				const float ProportionRatio = FMath::Min(Generator.Proportion / ProportionRemaining, 1.0f);
				const int32 SpawnCount = FMath::CeilToInt(static_cast<float>(SpawnCountRemaining) * ProportionRatio);
				
				FFinishedGeneratingSpawnDataSignature Delegate = FFinishedGeneratingSpawnDataSignature::CreateUObject(this, &AMassSpawner::OnSpawnDataGenerationFinished, &Generator);
				Generator.GeneratorInstance->Generate(*this, EntityTypes, SpawnCount, Delegate);
				SpawnCountRemaining -= SpawnCount;
				ProportionRemaining -= Generator.Proportion;
			}
		}
	};
	
	if (AssetsToLoad.Num())
	{
		FStreamableManager& StreamableManager = UAssetManager::GetStreamableManager();
		StreamingHandle = StreamableManager.RequestAsyncLoad(AssetsToLoad, GenerateSpawningPoints);
	}
	else
	{
		GenerateSpawningPoints();
	}
}

void AMassSpawner::OnSpawnDataGenerationFinished(TConstArrayView<FMassEntitySpawnDataGeneratorResult> Results, FMassSpawnDataGenerator* FinishedGenerator)
{
	// @todo: this can be potentially expensive copy for the instanced structs, could there be a way to use move gere instead?
	AllGeneratedResults.Append(Results.GetData(), Results.Num());

	bool bAllSpawnPointsGenerated = true;
	bool bFoundFinishedGenerator = false;
	for (FMassSpawnDataGenerator& Generator : SpawnDataGenerators)
	{
		if (&Generator == FinishedGenerator)
		{
			Generator.bDataGenerated = true;
			bFoundFinishedGenerator = true;
		}

		bAllSpawnPointsGenerated &= Generator.bDataGenerated;
	}

	checkf(bFoundFinishedGenerator, TEXT("Something went wrong, we are receiving a callback on an unknow spawn point generator"));
	
	if (bAllSpawnPointsGenerated)
	{
		SpawnGeneratedEntities(AllGeneratedResults);
		AllGeneratedResults.Reset();
	}
}

int32 AMassSpawner::GetSpawnCount() const
{
	const float FinalSpawningCountScale = SpawningCountScale * UE::MassSpawner::ScalabilitySpawnDensityMultiplier;
	return static_cast<int32>(FinalSpawningCountScale * static_cast<float>(Count));
}

UMassProcessor* AMassSpawner::GetPostSpawnProcessor(TSubclassOf<UMassProcessor> ProcessorClass)
{
	if (!ProcessorClass)
	{
		return nullptr;
	}

	TObjectPtr<UMassProcessor>* const Initializer = PostSpawnProcessors.FindByPredicate([ProcessorClass](const UMassProcessor* Processor)
		{
			return Processor && Processor->GetClass() == ProcessorClass;
		}
	);

	if (Initializer == nullptr)
	{
		UMassProcessor* NewInitializer = NewObject<UMassProcessor>(this, ProcessorClass);
		NewInitializer->Initialize(*this);
		PostSpawnProcessors.Add(NewInitializer);
		return NewInitializer;
	}

	return *Initializer;
}

void AMassSpawner::SpawnGeneratedEntities(TConstArrayView<FMassEntitySpawnDataGeneratorResult> Results)
{
	UMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(GetWorld());
	if (SpawnerSystem == nullptr)
	{
		UE_VLOG_UELOG(this, LogMassSpawner, Error, TEXT("UMassSpawnerSubsystem missing while trying to spawn entities"));
		return;
	}

	UWorld* World = GetWorld();
	check(World);

	int32 TotalNum = 0;
	const int32 StartIndex = AllSpawnedEntities.Num();

	for (const FMassEntitySpawnDataGeneratorResult& Result : Results)
	{
		if (Result.NumEntities <= 0)
		{
			continue;
		}
		
		check(EntityTypes.IsValidIndex(Result.EntityConfigIndex));
		check(Result.SpawnDataProcessor != nullptr);
		
		const FMassSpawnedEntityType& EntityType = EntityTypes[Result.EntityConfigIndex];

		if (const UMassEntityConfigAsset* EntityConfig = EntityType.GetEntityConfig())
		{
			const FMassEntityTemplate& EntityTemplate = EntityConfig->GetOrCreateEntityTemplate(*World);
			if (EntityTemplate.IsValid())
			{
				FSpawnedEntities& SpawnedEntities = AllSpawnedEntities.AddDefaulted_GetRef();
				SpawnedEntities.TemplateID = EntityTemplate.GetTemplateID();
				SpawnerSystem->SpawnEntities(EntityTemplate.GetTemplateID(), Result.NumEntities, Result.SpawnData, Result.SpawnDataProcessor, SpawnedEntities.Entities);
				TotalNum += SpawnedEntities.Entities.Num();
			}
		}
	}

	// Run post spawn processors only on the freshly spawned entities.
	if (TotalNum)
	{
		TArray<UMassProcessor*> Processors;
		TSet<TSubclassOf<UMassProcessor>> AddedProcessorClasses;

		for (const FMassEntitySpawnDataGeneratorResult& Result : Results)
		{
			for (const TSubclassOf<UMassProcessor>& ProcessorClass : Result.PostSpawnProcessors)
			{
				if (AddedProcessorClasses.Contains(ProcessorClass) == false)
				{
					if (UMassProcessor* Processor = GetPostSpawnProcessor(ProcessorClass))
					{
						Processors.Add(Processor);
					}
					AddedProcessorClasses.Add(ProcessorClass);
				}
			}
		}

		if (Processors.Num() > 0)
		{
			FMassEntityManager& EntityManager = UE::Mass::Utils::GetEntityManagerChecked(*World);
			FMassProcessingContext ProcessingContext(EntityManager, /*TimeDelta=*/0.0f);

			// gather freshly spawned entities
			TArray<FMassEntityHandle> AllEntities;
			AllEntities.Reserve(TotalNum);
			
			for (int32 Index = StartIndex; Index < AllSpawnedEntities.Num(); ++Index)
			{
				AllEntities.Append(AllSpawnedEntities[Index].Entities);
			}

			// create entity collections and run Processors on them. 
			TArray<FMassArchetypeEntityCollection> EntityCollections;
			UE::Mass::Utils::CreateEntityCollections(EntityManager, AllEntities, FMassArchetypeEntityCollection::NoDuplicates, EntityCollections);
			UE::Mass::Executor::RunProcessorsView(Processors, ProcessingContext, EntityCollections);
		}
	}

	OnSpawningFinishedEvent.Broadcast();
}

void AMassSpawner::DoDespawning()
{
	if (AllSpawnedEntities.IsEmpty())
	{
		return;
	}
	
	UMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(GetWorld());
	if (SpawnerSystem == nullptr)
	{
		UE_LOG(LogMassSpawner, Error, TEXT("UMassSpawnerSubsystem missing while trying to despawn entities"));
		return;
	}

	for (const FSpawnedEntities& SpawnedEntities : AllSpawnedEntities)
	{
		SpawnerSystem->DestroyEntities(SpawnedEntities.Entities);
	}
	AllSpawnedEntities.Reset();

	OnDespawningFinishedEvent.Broadcast();
}

void AMassSpawner::DoDespawning(TConstArrayView<FMassEntityHandle> EntitiesToIgnore)
{
	// Remove EntitiesToIgnore from SpawnedEntities so they get skipped by DoDespawning() and add to AllEntitiesToKeep
	// to restore after.
	TArray<FSpawnedEntities> AllEntitiesToKeep;
	for (FSpawnedEntities& SpawnedEntities : AllSpawnedEntities)
	{
		FSpawnedEntities* EntitiesToKeep = nullptr;
		for (const FMassEntityHandle& EntityToIgnore : EntitiesToIgnore)
		{
			if (SpawnedEntities.Entities.RemoveSingleSwap(EntityToIgnore, EAllowShrinking::No))
			{
				if (!EntitiesToKeep)
				{
					EntitiesToKeep = &AllEntitiesToKeep.AddDefaulted_GetRef();
					EntitiesToKeep->TemplateID = SpawnedEntities.TemplateID;
				}
				
				EntitiesToKeep->Entities.Add(EntityToIgnore);
			}
		}
	}

	// Despawn the remaining entities in AllSpawnedEntities
	DoDespawning();

	// Restore AllEntitiesToKeep to AllSpawnedEntities so they remain tracked
	AllSpawnedEntities = AllEntitiesToKeep;
}

bool AMassSpawner::DespawnEntity(const FMassEntityHandle Entity)
{
	UMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(GetWorld());
	if (SpawnerSystem == nullptr)
	{
		UE_LOG(LogMassSpawner, Error, TEXT("UMassSpawnerSubsystem missing while trying to despawn a single entity"));
		return false;
	}

	for (FSpawnedEntities& SpawnedEntities : AllSpawnedEntities)
	{
		const int32 Index = SpawnedEntities.Entities.Find(Entity);
		if (Index != INDEX_NONE)
		{
			SpawnerSystem->DestroyEntities(MakeArrayView(&Entity, 1));
			SpawnedEntities.Entities.RemoveAtSwap(Index, EAllowShrinking::No);
			return true;
		}
	}
	return false;
}

int32 AMassSpawner::GetCount() const
{
	return Count;
}

float AMassSpawner::GetSpawningCountScale() const
{
	return SpawningCountScale;
}

void AMassSpawner::ClearTemplates()
{
	UWorld* World = GetWorld();
	check(World);

	for (FMassSpawnedEntityType& EntityType : EntityTypes)
	{
		if (const UMassEntityConfigAsset* EntityConfig = EntityType.GetEntityConfig())
		{
			EntityConfig->DestroyEntityTemplate(*World);
		}
	}
}

void AMassSpawner::UnloadConfig()
{
	// Clear all templates that were created by the config
	ClearTemplates();
	for (FMassSpawnedEntityType& EntityType : EntityTypes)
	{
		EntityType.UnloadEntityConfig();
	}

	if (StreamingHandle.IsValid() && StreamingHandle->IsActive())
	{
		StreamingHandle->CancelHandle();
	}
}

==================================================


=== Source/MassSpawner/Private/MassSpawnerModule.cpp ===
========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "CoreMinimal.h"
#include "MassSpawnerTypes.h"
#include "IMassSpawnerModule.h"


DEFINE_LOG_CATEGORY(LogMassSpawner);

class FMassSpawnerModule : public IMassSpawnerModule
{
	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

IMPLEMENT_MODULE(FMassSpawnerModule, MassSpawner)



void FMassSpawnerModule::StartupModule()
{
	// This code will execute after your module is loaded into memory (but after global variables are initialized, of course.)
}


void FMassSpawnerModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}




========================================================


=== Source/MassSpawner/Private/MassSpawnerSubsystem.cpp ===
===========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSpawnerSubsystem.h"
#include "MassSpawnerTypes.h"
#include "MassEntityTemplate.h"
#include "MassEntityManager.h"
#include "MassEntityTemplateRegistry.h"
#include "Engine/World.h"
#include "MassExecutor.h"
#include "StructUtils/InstancedStruct.h"
#include "VisualLogger/VisualLogger.h"
#include "MassSpawner.h"
#include "MassObserverProcessor.h"
#include "ProfilingDebugging/CpuProfilerTrace.h"
#include "MassSimulationSubsystem.h"
#include "MassProcessor.h"
#include "MassEntityUtils.h"

//----------------------------------------------------------------------//
//  UMassSpawnerSubsystem
//----------------------------------------------------------------------//
UMassSpawnerSubsystem::UMassSpawnerSubsystem()
	: TemplateRegistryInstance(this)
{

}

void UMassSpawnerSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{	
	Super::Initialize(Collection);

	// making sure UMassSimulationSubsystem gets created before the MassSpawnerSubsystem, since UMassSimulationSubsystem
	// is where the EntityManager gets created for the runtime MassGameplay simulation
	Collection.InitializeDependency<UMassSimulationSubsystem>();

	UWorld* World = GetWorld();
	check(World);
	EntityManager = UE::Mass::Utils::GetEntityManagerChecked(*World).AsShared();
	TemplateRegistryInstance.Initialize(EntityManager);
}

void UMassSpawnerSubsystem::Deinitialize() 
{
	EntityManager.Reset();
	TemplateRegistryInstance.ShutDown();

	Super::Deinitialize();
}

void UMassSpawnerSubsystem::SpawnEntities(const FMassEntityTemplate& EntityTemplate, const uint32 NumberToSpawn, TArray<FMassEntityHandle>& OutEntities)
{
	check(EntityManager);
	check(EntityTemplate.IsValid());

	if (NumberToSpawn == 0)
	{
		UE_VLOG(this, LogMassSpawner, Warning, TEXT("Trying to spawn 0 entities. This would cause inefficiency. Bailing out with result FALSE."));
		return;
	}

	DoSpawning(EntityTemplate, NumberToSpawn, FStructView(), TSubclassOf<UMassProcessor>(), OutEntities);
}

void UMassSpawnerSubsystem::SpawnEntities(FMassEntityTemplateID TemplateID, const uint32 NumberToSpawn, FConstStructView SpawnData, TSubclassOf<UMassProcessor> InitializerClass, TArray<FMassEntityHandle>& OutEntities)
{
	check(TemplateID.IsValid());

	const TSharedRef<FMassEntityTemplate>* EntityTemplate = TemplateRegistryInstance.FindTemplateFromTemplateID(TemplateID);
	checkf(EntityTemplate, TEXT("SpawnEntities: TemplateID must have been registered!"));

	DoSpawning(EntityTemplate->Get(), NumberToSpawn, SpawnData, InitializerClass, OutEntities);
}

void UMassSpawnerSubsystem::DestroyEntities(TConstArrayView<FMassEntityHandle> Entities)
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("MassSpawnerSubsystem_DestroyEntities")

	check(EntityManager);
	checkf(!EntityManager->IsProcessing()
		, TEXT("%s called while MassEntity processing in progress. This is unsupported and dangerous!"), ANSI_TO_TCHAR(__FUNCTION__));

	UWorld* World = GetWorld();
	check(World);


	TArray<FMassArchetypeEntityCollection> EntityCollections;
	UE::Mass::Utils::CreateEntityCollections(*EntityManager.Get(), Entities, FMassArchetypeEntityCollection::NoDuplicates, EntityCollections);
	EntityManager->BatchDestroyEntityChunks(EntityCollections);
}

UMassProcessor* UMassSpawnerSubsystem::GetSpawnDataInitializer(TSubclassOf<UMassProcessor> InitializerClass)
{	
	if (!InitializerClass)
	{
		return nullptr;
	}

	TObjectPtr<UMassProcessor>* const Initializer = SpawnDataInitializers.FindByPredicate([InitializerClass](const UMassProcessor* Processor)
		{
			return Processor && Processor->GetClass() == InitializerClass;
		}
	);

	if (Initializer == nullptr)
	{
		UMassProcessor* NewInitializer = NewObject<UMassProcessor>(this, InitializerClass);
		NewInitializer->Initialize(*this);
		SpawnDataInitializers.Add(NewInitializer);
		return NewInitializer;
	}

	return *Initializer;
}

void UMassSpawnerSubsystem::DoSpawning(const FMassEntityTemplate& EntityTemplate, const int32 NumToSpawn, FConstStructView SpawnData, TSubclassOf<UMassProcessor> InitializerClass, TArray<FMassEntityHandle>& OutEntities)
{
	check(EntityManager);
	check(EntityTemplate.GetArchetype().IsValid());
	UE_VLOG(this, LogMassSpawner, Log, TEXT("Spawning with EntityTemplate:\n%s"), *EntityTemplate.DebugGetDescription(EntityManager.Get()));

	if (NumToSpawn <= 0)
	{
		UE_VLOG(this, LogMassSpawner, Warning, TEXT("%s: Trying to spawn %d entities. Ignoring."), ANSI_TO_TCHAR(__FUNCTION__), NumToSpawn);
		return;
	}

	LLM_SCOPE_BYNAME(TEXT("Mass/Spawner"))
	//TRACE_CPUPROFILER_EVENT_SCOPE_STR("MassSpawnerSubsystem DoSpawning");

	// 1. Create required number of entities with EntityTemplate.Archetype
	TArray<FMassEntityHandle> SpawnedEntities;
	TSharedRef<FMassEntityManager::FEntityCreationContext> CreationContext
		= EntityManager->BatchCreateEntities(EntityTemplate.GetArchetype(), EntityTemplate.GetSharedFragmentValues(), NumToSpawn, SpawnedEntities);

	// 2. Copy data from FMassEntityTemplate.Fragments.
	//		a. @todo, could be done as part of creation?
	TConstArrayView<FInstancedStruct> FragmentInstances = EntityTemplate.GetInitialFragmentValues();
	EntityManager->BatchSetEntityFragmentsValues(CreationContext->GetEntityCollections(), FragmentInstances);
	
	// 3. Run SpawnDataInitializer, if set. This is a special type of processor that operates on the entities to initialize them.
	// e.g., will run UInstancedActorsInitializerProcessor for Mass InstancedActors
	UMassProcessor* SpawnDataInitializer = SpawnData.IsValid() 
		? GetSpawnDataInitializer(InitializerClass) 
		: nullptr;

	if (SpawnDataInitializer)
	{
		FMassProcessingContext ProcessingContext(EntityManager, /*TimeDelta=*/0.0f);
		ProcessingContext.AuxData = SpawnData;
		UE::Mass::Executor::RunProcessorsView(MakeArrayView(&SpawnDataInitializer, 1), ProcessingContext, CreationContext->GetEntityCollections());
	}

	OutEntities.Append(MoveTemp(SpawnedEntities));
	// 4. "OnEntitiesCreated" notifies will be sent out once the CreationContext gets destroyed (via its destructor).
}

const FMassEntityTemplate* UMassSpawnerSubsystem::GetMassEntityTemplate(FMassEntityTemplateID TemplateID) const
{
	check(TemplateID.IsValid());
	const TSharedRef<FMassEntityTemplate>* TemplateFound = TemplateRegistryInstance.FindTemplateFromTemplateID(TemplateID);
	return TemplateFound ? &TemplateFound->Get() : nullptr;
}

===========================================================


=== Source/MassSpawner/Private/MassSpawnerTypes.cpp ===
=======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSpawnerTypes.h"
#include "MassEntityConfigAsset.h"
#include "Serialization/ArchiveObjectCrc32.h"
#include "MassEntityTraitBase.h"

namespace UE::MassSpawner
{
	uint32 HashTraits(TConstArrayView<UMassEntityTraitBase*> CombinedTraits)
	{
		class FArchiveObjectCRC32AgentConfig : public FArchiveObjectCrc32
		{
		public:
			virtual bool ShouldSkipProperty(const FProperty* InProperty) const override
			{
				check(InProperty);
				return FArchiveObjectCrc32::ShouldSkipProperty(InProperty) || InProperty->HasAllPropertyFlags(CPF_Transient);
			}
		};

		uint32 CRC = 0;
		for (UMassEntityTraitBase* Trait : CombinedTraits)
		{
			FArchiveObjectCRC32AgentConfig Archive;
			CRC = Archive.Crc32(Trait, CRC);
			// @todo this piece is here to avoid an easy to repro hash class - all one needs to do is to add a 
			// trait subclass that sets different default values
			check(Trait && Trait->GetClass());
			CRC = HashCombine(CRC, GetTypeHash(Trait->GetClass()->GetName()));
		}
		return CRC;
	}
} // UE::MassSpawner

//-----------------------------------------------------------------------------
// FMassSpawnedEntityType
//-----------------------------------------------------------------------------
const UMassEntityConfigAsset* FMassSpawnedEntityType::GetEntityConfig() const
{
	if (EntityConfigPtr == nullptr)
	{
		EntityConfigPtr = EntityConfig.LoadSynchronous();
	}
	return EntityConfigPtr;
}

UMassEntityConfigAsset* FMassSpawnedEntityType::GetEntityConfig()
{
	if (EntityConfigPtr == nullptr)
	{
		EntityConfigPtr = EntityConfig.LoadSynchronous();
	}
	return EntityConfigPtr;
}
=======================================================


=== Source/MassSpawner/Private/MassSpawnLocationProcessor.cpp ===
=================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSpawnLocationProcessor.h"
#include "MassCommonFragments.h"
#include "MassEntityManager.h"
#include "MassExecutionContext.h"
#include "MassSpawnerTypes.h"
#include "MassCommonUtils.h"
#include "Engine/World.h"
#include "VisualLogger/VisualLogger.h"

//----------------------------------------------------------------------//
// UMassSpawnLocationProcessor 
//----------------------------------------------------------------------//
UMassSpawnLocationProcessor::UMassSpawnLocationProcessor()
	: EntityQuery(*this)
{
	bAutoRegisterWithProcessingPhases = false;
	RandomStream.Initialize(UE::Mass::Utils::GenerateRandomSeed());
}

void UMassSpawnLocationProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);
}

void UMassSpawnLocationProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
	if (!ensure(Context.ValidateAuxDataType<FMassTransformsSpawnData>()))
	{
		UE_VLOG_UELOG(this, LogMass, Log, TEXT("Execution context has invalid AuxData or it's not FMassSpawnAuxData. Entity transforms won't be initialized."));
		return;
	}

	const UWorld* World = EntityManager.GetWorld();
	check(World);

	const ENetMode NetMode = World->GetNetMode();

	FMassTransformsSpawnData& AuxData = Context.GetMutableAuxData().GetMutable<FMassTransformsSpawnData>();
	TArray<FTransform>& Transforms = AuxData.Transforms;

	const int32 NumSpawnTransforms = Transforms.Num();
	if (NumSpawnTransforms == 0)
	{
		UE_VLOG_UELOG(this, LogMass, Error, TEXT("No spawn transforms provided. Entity transforms won't be initialized."));
		return;
	}

	int32 NumRequiredSpawnTransforms = 0;
	EntityQuery.ForEachEntityChunk(EntityManager, Context, [&NumRequiredSpawnTransforms](const FMassExecutionContext& Context)
		{
			NumRequiredSpawnTransforms += Context.GetNumEntities();
		});

	const int32 NumToAdd = NumRequiredSpawnTransforms - NumSpawnTransforms;
	if (NumToAdd > 0)
	{
		UE_VLOG_UELOG(this, LogMass, Warning,
			TEXT("Not enough spawn locations provided (%d) for all entities (%d). Existing locations will be reused randomly to fill the %d missing positions."),
			NumSpawnTransforms, NumRequiredSpawnTransforms, NumToAdd);

		Transforms.AddUninitialized(NumToAdd);
		for (int i = 0; i < NumToAdd; ++i)
		{
			Transforms[NumSpawnTransforms + i] = Transforms[RandomStream.RandRange(0, NumSpawnTransforms - 1)];
		}
	}

	if (AuxData.bRandomize && !UE::Mass::Utils::IsDeterministic())
	{
		EntityQuery.ForEachEntityChunk(EntityManager, Context, [&Transforms, this](FMassExecutionContext& Context)
			{
				const TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();
				const int32 NumEntities = Context.GetNumEntities();
				for (int32 i = 0; i < NumEntities; ++i)
				{
					const int32 AuxIndex = RandomStream.RandRange(0, Transforms.Num() - 1);
					LocationList[i].GetMutableTransform() = Transforms[AuxIndex];
					Transforms.RemoveAtSwap(AuxIndex, EAllowShrinking::No);
				}
			});
	}
	else
	{
		int32 NextTransformIndex = 0;
		EntityQuery.ForEachEntityChunk(EntityManager, Context, [&Transforms, &NextTransformIndex, this](FMassExecutionContext& Context)
			{
				const int32 NumEntities = Context.GetNumEntities();
				TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();
				check(NextTransformIndex + NumEntities <= Transforms.Num());
	
				FMemory::Memcpy(LocationList.GetData(), &Transforms[NextTransformIndex], NumEntities * LocationList.GetTypeSize());
				NextTransformIndex += NumEntities;
			});
	}
}

=================================================================


=== Source/MassSpawner/Private/MassTranslator.cpp ===
=====================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassTranslator.h"
#include "MassCommonTypes.h"

//----------------------------------------------------------------------//
//  UMassTranslator
//----------------------------------------------------------------------//
UMassTranslator::UMassTranslator()
{
	bAutoRegisterWithProcessingPhases = true;
	ExecutionFlags = (int32)EProcessorExecutionFlags::All;
}

void UMassTranslator::AddRequiredTagsToQuery(FMassEntityQuery& EntityQuery)
{
	EntityQuery.AddTagRequirements<EMassFragmentPresence::All>(RequiredTags);
}

=====================================================


=== Source/MassSpawner/Public/IMassSpawnerModule.h ===
======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleInterface.h"
#include "Modules/ModuleManager.h"


/**
 * The public interface to this module.  In most cases, this interface is only public to sibling modules 
 * within this plugin.
 */
class IMassSpawnerModule : public IModuleInterface
{

public:

	/**
	 * Singleton-like access to this module's interface.  This is just for convenience!
	 * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.
	 *
	 * @return Returns singleton instance, loading the module on demand if needed
	 */
	static inline IMassSpawnerModule& Get()
	{
		return FModuleManager::LoadModuleChecked<IMassSpawnerModule>( "MassSpawner" );
	}

	/**
	 * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.
	 *
	 * @return True if the module is loaded and ready to use
	 */
	static inline bool IsAvailable()
	{
		return FModuleManager::Get().IsModuleLoaded( "MassSpawner" );
	}
};


======================================================


=== Source/MassSpawner/Public/MassAssortedFragmentsTrait.h ===
==============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "CoreMinimal.h"
#include "MassEntityTraitBase.h"
#include "StructUtils/InstancedStruct.h"
#include "MassAssortedFragmentsTrait.generated.h"

/**
* Mass Agent Feature which appends a list of specified fragments.  
*/
UCLASS(meta=(DisplayName="Assorted Fragments"))
class MASSSPAWNER_API UMassAssortedFragmentsTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:

	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const override;

	UPROPERTY(Category="Mass", EditAnywhere, meta = (BaseStruct = "/Script/MassEntity.MassFragment", ExcludeBaseStruct))
	TArray<FInstancedStruct> Fragments;

	UPROPERTY(Category="Mass", EditAnywhere, meta = (BaseStruct = "/Script/MassEntity.MassTag", ExcludeBaseStruct))
	TArray<FInstancedStruct> Tags;
};

==============================================================


=== Source/MassSpawner/Public/MassEntityConfigAsset.h ===
=========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "MassEntityTemplate.h"
#include "MassEntityTemplateRegistry.h"
#include "MassEntityConfigAsset.generated.h"

class UMassEntityConfigAsset;
class UMassEntityTraitBase;

/**
 * Describes a Mass agent to spawn. The struct can be embedded to allow last minute changes to the agent (i.e. for debugging).
 * The agent config describes a unique list of features which are used to create an entity template.
 * Derived configs can override parent features.
 */
USTRUCT()
struct MASSSPAWNER_API FMassEntityConfig
{
	friend class UMassTemplateRegistry;

	GENERATED_BODY()

	FMassEntityConfig();
	FMassEntityConfig(UObject& InOwner);

	/** Create entity template based on the features included in this config.
	 *  @param World in which we are creating the template.
	 */
	const FMassEntityTemplate& GetOrCreateEntityTemplate(const UWorld& World) const;

	void DestroyEntityTemplate(const UWorld& World) const;

	/** 
	 * Fetches the EntityTemplate for given World, fails a check if one cannot be found.
	 */
	const FMassEntityTemplate& GetEntityTemplateChecked(const UWorld& World) const;

	/** @return Parent config */
	const UMassEntityConfigAsset* GetParent() const { return Parent; }

	void SetParentAsset(const UMassEntityConfigAsset& InParent) { Parent = &InParent; }
	
	/** @return View to the array of features defined on this config */
	TConstArrayView<UMassEntityTraitBase*> GetTraits() const { return Traits; }

	/** Looks for a trait of the indicated type, accepting all child classes as well, unless bExactMatch == true */
	const UMassEntityTraitBase* FindTrait(TSubclassOf<UMassEntityTraitBase> TraitClass, const bool bExactMatch = false) const
	{
		return FindTraitInternal(TraitClass, bExactMatch);
	}

	/** Adds Trait to the collection of traits hosted by this FMassEntityConfig instance */
	void AddTrait(UMassEntityTraitBase& Trait);

	/** Validates if the entity template is well built */
	bool ValidateEntityTemplate(const UWorld& World);

	void SetOwner(UObject& InOwner) { ConfigOwner = &InOwner; }

	UE_DEPRECATED(5.3, "This flavor of GetOrCreateEntityTemplate is deprecated. Use the one without the ConfigOwner parameter (now a property of the FMassEntityConfig itself)")
	const FMassEntityTemplate& GetOrCreateEntityTemplate(const UWorld& World, const UObject& ConfigOwner) const;

	UE_DEPRECATED(5.3, "This flavor of DestroyEntityTemplate is deprecated. Use the one without the ConfigOwner parameter (now a property of the FMassEntityConfig itself)")
	void DestroyEntityTemplate(const UWorld& World, const UObject& ConfigOwner) const;

	UE_DEPRECATED(5.3, "This flavor of GetEntityTemplateChecked is deprecated. Use the one without the ConfigOwner parameter (now a property of the FMassEntityConfig itself)")
	const FMassEntityTemplate& GetEntityTemplateChecked(const UWorld& World, const UObject& ConfigOwner) const;

	UE_DEPRECATED(5.3, "This flavor of ValidateEntityTemplate is deprecated. Use the one without the ConfigOwner parameter (now a property of the FMassEntityConfig itself)")
	bool ValidateEntityTemplate(const UWorld& World, const UObject& ConfigOwner);

	bool IsEmpty() const { return Parent == nullptr && Traits.Num() == 0; }

	const FGuid& GetGuid() const { return ConfigGuid; }
	
#if WITH_EDITOR
	/** Needs to be called when the given config is being duplicated - ensured the ConfigGuid remains unique */
	void PostDuplicate(bool bDuplicateForPIE);

	UMassEntityTraitBase* FindMutableTrait(TSubclassOf<UMassEntityTraitBase> TraitClass, const bool bExactMatch = false);
#endif // WITH_EDITOR
	
protected:
	/** Combines traits based on the config hierarchy and returns list of unique traits */
	void GetCombinedTraits(TArray<UMassEntityTraitBase*>& OutTraits) const;

	/** Looks for a trait of the indicated type, accepting all child classes as well, unless bExactMatch == true */
	UMassEntityTraitBase* FindTraitInternal(TSubclassOf<UMassEntityTraitBase> TraitClass, const bool bExactMatch = false) const;

	/** Combines traits based on the config hierarchy and returns list of unique traits */
	UE_DEPRECATED(5.3, "This flavor of GetCombinedTraits is deprecated. Use the one without the ConfigOwner parameter (now a property of the FMassEntityConfig itself)")
	void GetCombinedTraits(TArray<UMassEntityTraitBase*>& OutTraits, TArray<const UObject*>& Visited, const UObject& ConfigOwner) const;

	/** Reference to parent config asset */
	UPROPERTY(Category = "Derived Traits", EditAnywhere)
	TObjectPtr<const UMassEntityConfigAsset> Parent = nullptr;

	/** Array of unique traits of this config */
	UPROPERTY(Category = "Traits", EditAnywhere, Instanced)
	TArray<TObjectPtr<UMassEntityTraitBase>> Traits;

	UPROPERTY(transient)
	TObjectPtr<UObject> ConfigOwner = nullptr;

private:
	UPROPERTY(VisibleAnywhere, Category="Mass", meta = (IgnoreForMemberInitializationTest))
	FGuid ConfigGuid;

private:
	void GetCombinedTraitsInternal(TArray<UMassEntityTraitBase*>& OutTraits, TArray<const UObject*>& Visited) const;
	const FMassEntityTemplate* GetEntityTemplateInternal(const UWorld& World, FMassEntityTemplateID& TemplateIDOut) const;
};

/**
 * Agent Config asset allows to create shared configs that can be used as base for derived configs.
 * The asset can be used as is i.e. on a spawner, or you can use FMassEntityConfig to allow last minute changes at use site.
 */
UCLASS(BlueprintType)
class MASSSPAWNER_API UMassEntityConfigAsset : public UDataAsset
{
	GENERATED_BODY()

public:
	UMassEntityConfigAsset()
		: Config(*this)
	{}

	/** @return Agent config stored in this asset */
	const FMassEntityConfig& GetConfig() const { return Config; }

	/** @return Mutable agent config stored in this asset */
	FMassEntityConfig& GetMutableConfig() { return Config; }

	const FMassEntityTemplate& GetOrCreateEntityTemplate(const UWorld& World) const
	{
		return Config.GetOrCreateEntityTemplate(World);
	}

	void DestroyEntityTemplate(const UWorld& World) const
	{
		Config.DestroyEntityTemplate(World);
	}

	/** Looks for a trait of the indicated type, accepting all child classes as well, unless bExactMatch == true */
	const UMassEntityTraitBase* FindTrait(TSubclassOf<UMassEntityTraitBase> TraitClass, const bool bExactMatch = false) const
	{
		return Config.FindTrait(TraitClass, bExactMatch);
	}

#if WITH_EDITOR
	/** Called upon asset's dupllication. Ensured the underlying config's ConfigGuid remains unique */
	virtual void PostDuplicate(bool bDuplicateForPIE) override;

	UFUNCTION(CallInEditor, Category = "Entity Config")
	void ValidateEntityConfig();

	/**
	 * Returns a mutable instance of given trait class. If an instance of the given class can be found in
	 * the hosted FMassEntityConfig then that instance is returned. Otherwise one will be created, added to
	 * the FMassEntityConfig and returned.
	 */
	UMassEntityTraitBase* AddTrait(TSubclassOf<UMassEntityTraitBase> TraitClass);
#endif // WITH_EDITOR

protected:
	/** The config described in this asset. */
	UPROPERTY(Category = "Entity Config", EditAnywhere)
	FMassEntityConfig Config;
};
=========================================================


=== Source/MassSpawner/Public/MassEntityEQSSpawnPointsGenerator.h ===
=====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "CoreMinimal.h"
#include "MassEntitySpawnDataGeneratorBase.h"
#include "EnvironmentQuery/EnvQueryTypes.h"
#include "MassEntityEQSSpawnPointsGenerator.generated.h"

/**
 * Describes the SpawnPoints Generator when we want to leverage the points given by an EQS Query
 */
UCLASS(BlueprintType, meta=(DisplayName="EQS SpawnPoints Generator"))
class MASSSPAWNER_API UMassEntityEQSSpawnPointsGenerator : public UMassEntitySpawnDataGeneratorBase
{	
	GENERATED_BODY()

public:
	UMassEntityEQSSpawnPointsGenerator();
	
	virtual void Generate(UObject& QueryOwner, TConstArrayView<FMassSpawnedEntityType> EntityTypes, int32 Count, FFinishedGeneratingSpawnDataSignature& FinishedGeneratingSpawnPointsDelegate) const override;

protected:

#if WITH_EDITOR
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;
#endif

	void OnEQSQueryFinished(TSharedPtr<FEnvQueryResult> EQSResult, TArray<FMassEntitySpawnDataGeneratorResult> Results, FFinishedGeneratingSpawnDataSignature FinishedGeneratingSpawnPointsDelegate) const;

	UPROPERTY(Category = "Query", EditAnywhere)
	FEQSParametrizedQueryExecutionRequest EQSRequest;
};

=====================================================================


=== Source/MassSpawner/Public/MassEntitySpawnDataGeneratorBase.h ===
====================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "CoreMinimal.h"
#include "StructUtils/InstancedStruct.h"
#include "MassSpawnerTypes.h"
#include "MassEntitySpawnDataGeneratorBase.generated.h"

class UMassEntityConfigAsset;
class UMassProcessor;

/**
 * The result of the spawn point generator.
 */
USTRUCT()
struct FMassEntitySpawnDataGeneratorResult
{
	GENERATED_BODY()

	// Spawn data that is passed to the InitSpawnDataProcessor. E.g. the data could contain array of locations, one for each entity.
	UPROPERTY()
	FInstancedStruct SpawnData;
	
	// Processor that understands how to apply SpawnData to the spawned entities. 
	UPROPERTY()
	TSubclassOf<UMassProcessor> SpawnDataProcessor;

	// Processors that are run for all entities after they entities for a MassSpawner are initialized.
	UPROPERTY()
	TArray<TSubclassOf<UMassProcessor>> PostSpawnProcessors;

	// Index in the EntityTypes array passed to Generate().
	UPROPERTY()
	int32 EntityConfigIndex = INDEX_NONE;

	// Number of entities to spawn.
	UPROPERTY()
	int32 NumEntities = 0;
};


DECLARE_DELEGATE_OneParam(FFinishedGeneratingSpawnDataSignature, TConstArrayView<FMassEntitySpawnDataGeneratorResult>);

/**
 * Base class for Mass Entity Spawn Points Generator.
 * A Mass Spawn Points Generator can be of several type (EQS, ZoneGraph, Volume, Area, etc.)
 * The concept is to override the GenerateSpawnPoints() method and requesting a certain number of Spawn Point Locations to the method.
 */
UCLASS(Abstract, Blueprintable, EditInlineNew)
class MASSSPAWNER_API UMassEntitySpawnDataGeneratorBase : public UObject
{
	GENERATED_BODY()

public:

	/** Generate "Count" number of SpawnPoints and return as a list of position
	 * @param Count of point to generate
	 * @param FinishedGeneratingSpawnPointsDelegate is the callback to call once the generation is done
	 */
	virtual void Generate(UObject& QueryOwner, TConstArrayView<FMassSpawnedEntityType> EntityTypes, int32 Count, FFinishedGeneratingSpawnDataSignature& FinishedGeneratingSpawnPointsDelegate) const PURE_VIRTUAL(UMassEntitySpawnDataGeneratorBase::GenerateSpawnPoints, );

	/** Populates empty generator results from EntityTypes based on the provided proportions. 
	 * @param SpawnCount How many entities to distributed among the EntityTypes
	 * @param EntityTypes Types of entities to generate data for.
	 * @param OutResults Generator result for each entity type that had > 0 entities assigned to it.
	 */
	void BuildResultsFromEntityTypes(const int32 SpawnCount, TConstArrayView<FMassSpawnedEntityType> EntityTypes, TArray<FMassEntitySpawnDataGeneratorResult>& OutResults) const;

protected:
	int32 GetRandomSelectionSeed() const { return bUseCustomSeed ? RandomSelectionSeed : GFrameNumber; }

	UPROPERTY(Category = "Query", EditAnywhere, meta=(EditCondition="bUseCustomSeed"))
	int32 RandomSelectionSeed = 0;

	UPROPERTY()
	uint8 bUseCustomSeed : 1;
};

====================================================================


=== Source/MassSpawner/Public/MassEntityTemplate.h ===
======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassProcessingTypes.h"
#include "MassEntityManager.h"
#include "MassCommonTypes.h"
#include "MassTranslator.h"
#include "Templates/SharedPointer.h"
#include "Misc/Guid.h"
#include "Hash/CityHash.h"
#include "MassEntityTemplate.generated.h"


class UMassEntityTraitBase;
struct FMassEntityView;
struct FMassEntityTemplateIDFactory;
struct FMassEntityTemplate;


//ID of the template an entity is using
USTRUCT()
struct MASSSPAWNER_API FMassEntityTemplateID
{
	GENERATED_BODY()

	FMassEntityTemplateID() 
		: FlavorHash(0), TotalHash(InvalidHash)
	{}

private:
	friend FMassEntityTemplateIDFactory;
	// use FMassEntityTemplateIDFactory to access this constructor flavor
	explicit FMassEntityTemplateID(const FGuid& InGuid, const int32 InFlavorHash = 0)
		: ConfigGuid(InGuid), FlavorHash(InFlavorHash)
	{
		 const uint64 GuidHash = CityHash64((char*)&ConfigGuid, sizeof(FGuid));
		 TotalHash = CityHash128to64({GuidHash, (uint64)InFlavorHash});
	}

public:
	uint64 GetHash64() const 
	{
		return TotalHash;
	}
	
	void Invalidate()
	{
		TotalHash = InvalidHash;
	}

	bool operator==(const FMassEntityTemplateID& Other) const
	{
		return (TotalHash == Other.TotalHash);
	}
	
	bool operator!=(const FMassEntityTemplateID& Other) const
	{
		return !(*this == Other);
	}

	/** 
	 * Note that since the function is 32-hashing a 64-bit value it's not guaranteed to produce globally unique values.
	 * But also note that it's still fine to use FMassEntityTemplateID as a TMap key type, since TMap is using 32bit hash
	 * to assign buckets rather than identify individual values.
	 */
	friend uint32 GetTypeHash(const FMassEntityTemplateID& TemplateID)
	{
		return GetTypeHash(TemplateID.TotalHash);
	}

	bool IsValid() const { return (TotalHash != InvalidHash); }

	FString ToString() const;

protected:
	UPROPERTY(VisibleAnywhere, Category="Mass")
	FGuid ConfigGuid;

	UPROPERTY()
	uint32 FlavorHash;

	UPROPERTY()
	uint64 TotalHash;

private:
	static constexpr uint64 InvalidHash = 0;
};


/** 
 * Serves as data used to define and build finalized FMassEntityTemplate instances. Describes composition and initial
 * values of fragments for entities created with this data, and lets users modify and extend the data. Once finalized as 
 * FMassEntityTemplate the data will become immutable. 
 */
USTRUCT()
struct MASSSPAWNER_API FMassEntityTemplateData
{
	GENERATED_BODY()

	typedef TFunction<void(UObject& /*Owner*/, FMassEntityView& /*EntityView*/, const EMassTranslationDirection /*CurrentDirection*/)> FObjectFragmentInitializerFunction;

	FMassEntityTemplateData() = default;
	explicit FMassEntityTemplateData(const FMassEntityTemplate& InFinalizedTemplate);

	bool IsEmpty() const { return Composition.IsEmpty(); }

	TConstArrayView<FObjectFragmentInitializerFunction> GetObjectFragmentInitializers() const { return ObjectInitializers; }
	const FString& GetTemplateName() const { return TemplateName; }
	const FMassArchetypeCompositionDescriptor& GetCompositionDescriptor() const { return Composition; }
	const FMassArchetypeSharedFragmentValues& GetSharedFragmentValues() const { return SharedFragmentValues; }
	TConstArrayView<FInstancedStruct> GetInitialFragmentValues() const { return InitialFragmentValues; }

	TArray<FMassEntityTemplateData::FObjectFragmentInitializerFunction>& GetMutableObjectFragmentInitializers() { return ObjectInitializers; }

	void SetTemplateName(const FString& Name) { TemplateName = Name; }
	
	template<typename T>
	void AddFragment()
	{
		static_assert(TIsDerivedFrom<T, FMassFragment>::IsDerived, "Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.");
		Composition.Fragments.Add<T>();
	}

	void AddFragment(const UScriptStruct& FragmentType)
	{
		checkf(FragmentType.IsChildOf(FMassFragment::StaticStruct()), TEXT("Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types."));
		Composition.Fragments.Add(FragmentType);
	}

	// @todo this function is doing nothing if a given fragment's initial value has already been created. This seems inconsistent with the other AddFragment functions (especially AddFragment_GetRef).
	void AddFragment(FConstStructView Fragment)
	{
		const UScriptStruct* FragmentType = Fragment.GetScriptStruct();
		checkf(FragmentType && FragmentType->IsChildOf(FMassFragment::StaticStruct()), TEXT("Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types."));
		if (!Composition.Fragments.Contains(*FragmentType))
		{
			Composition.Fragments.Add(*FragmentType);
			InitialFragmentValues.Emplace(Fragment);
		}
		else if (!InitialFragmentValues.ContainsByPredicate(FStructTypeEqualOperator(FragmentType)))
		{
			InitialFragmentValues.Emplace(Fragment);
		}
	}

	template<typename T>
	T& AddFragment_GetRef()
	{
		static_assert(TIsDerivedFrom<T, FMassFragment>::IsDerived, "Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.");
		if (!Composition.Fragments.Contains<T>())
		{
			Composition.Fragments.Add<T>();
		}
		else if (FInstancedStruct* Fragment = InitialFragmentValues.FindByPredicate(FStructTypeEqualOperator(T::StaticStruct())))
		{
			return Fragment->template GetMutable<T>();
		}

		// Add a default initial fragment value
		return InitialFragmentValues.Emplace_GetRef(T::StaticStruct()).template GetMutable<T>();
	}

	template<typename T>
	T* GetMutableFragment()
	{
		static_assert(TIsDerivedFrom<T, FMassFragment>::IsDerived, "Given struct doesn't represent a valid fragment type. Make sure to inherit from FMassFragment or one of its child-types.");
		FInstancedStruct* Fragment = InitialFragmentValues.FindByPredicate(FStructTypeEqualOperator(T::StaticStruct()));
		return Fragment ? &Fragment->template GetMutable<T>() : (T*)nullptr;
	}

	template<typename T>
	void AddTag()
	{
		static_assert(TIsDerivedFrom<T, FMassTag>::IsDerived, "Given struct doesn't represent a valid mass tag type. Make sure to inherit from FMassTag or one of its child-types.");
		Composition.Tags.Add<T>();
	}
	
	void AddTag(const UScriptStruct& TagType)
	{
		checkf(TagType.IsChildOf(FMassTag::StaticStruct()), TEXT("Given struct doesn't represent a valid mass tag type. Make sure to inherit from FMassTag or one of its child-types."));
		Composition.Tags.Add(TagType);
	}

	template<typename T>
	void RemoveTag()
	{
		static_assert(TIsDerivedFrom<T, FMassTag>::IsDerived, "Given struct doesn't represent a valid mass tag type. Make sure to inherit from FMassTag or one of its child-types.");
		Composition.Tags.Remove<T>();
	}

	void RemoveTag(const UScriptStruct& TagType)
	{
		checkf(TagType.IsChildOf(FMassTag::StaticStruct()), TEXT("Given struct doesn't represent a valid mass tag type. Make sure to inherit from FMassTag or one of its child-types."));
		Composition.Tags.Remove(TagType);
	}

	const FMassTagBitSet& GetTags() const { return Composition.Tags; }
	FMassTagBitSet& GetMutableTags() { return Composition.Tags; }

	template<typename T>
	void AddChunkFragment()
	{
		static_assert(TIsDerivedFrom<T, FMassChunkFragment>::IsDerived, "Given struct doesn't represent a valid chunk fragment type. Make sure to inherit from FMassChunkFragment or one of its child-types.");
		Composition.ChunkFragments.Add<T>();
	}

	void AddConstSharedFragment(const FConstSharedStruct& SharedFragment)
	{
		const UScriptStruct* FragmentType = SharedFragment.GetScriptStruct();
		if(ensureMsgf(FragmentType && FragmentType->IsChildOf(FMassConstSharedFragment::StaticStruct()), TEXT("Given struct doesn't represent a valid const shared fragment type. Make sure to inherit from FMassConstSharedFragment or one of its child-types.")))
		{
			if (!Composition.ConstSharedFragments.Contains(*FragmentType))
			{
				Composition.ConstSharedFragments.Add(*FragmentType);
				SharedFragmentValues.AddConstSharedFragment(SharedFragment);
			}
#if DO_ENSURE
			else
			{
				const FConstSharedStruct* Struct = SharedFragmentValues.GetConstSharedFragments().FindByPredicate(FStructTypeEqualOperator(SharedFragment));
				ensureMsgf(Struct && *Struct == SharedFragment, TEXT("Adding 2 different const shared fragment of the same type is not allowed"));

			}
#endif // DO_ENSURE
		}
	}

	void AddSharedFragment(const FSharedStruct& SharedFragment)
	{
		const UScriptStruct* FragmentType = SharedFragment.GetScriptStruct();
		if(ensureMsgf(FragmentType && FragmentType->IsChildOf(FMassSharedFragment::StaticStruct()), TEXT("Given struct doesn't represent a valid shared fragment type. Make sure to inherit from FMassSharedFragment or one of its child-types.")))
		{
			if (!Composition.SharedFragments.Contains(*FragmentType))
			{
				Composition.SharedFragments.Add(*FragmentType);
				SharedFragmentValues.AddSharedFragment(SharedFragment);
			}
	#if DO_ENSURE
			else
			{
				const FSharedStruct* Struct = SharedFragmentValues.GetSharedFragments().FindByPredicate(FStructTypeEqualOperator(SharedFragment));
				ensureMsgf(Struct && *Struct == SharedFragment, TEXT("Adding 2 different shared fragment of the same type is not allowed"));

			}
	#endif // DO_ENSURE
		}
	}

	template<typename T>
	bool HasFragment() const
	{
		return Composition.Fragments.Contains<T>();
	}
	
	bool HasFragment(const UScriptStruct& ScriptStruct) const
	{
		return Composition.Fragments.Contains(ScriptStruct);
	}

	template<typename T>
	bool HasTag() const
	{
		return Composition.Tags.Contains<T>();
	}

	template<typename T>
	bool HasChunkFragment() const
	{
		return Composition.ChunkFragments.Contains<T>();
	}

	template<typename T>
	bool HasSharedFragment() const
	{
		return Composition.SharedFragments.Contains<T>();
	}

	bool HasSharedFragment(const UScriptStruct& ScriptStruct) const
	{
		return Composition.SharedFragments.Contains(ScriptStruct);
	}

	template<typename T>
	bool HasConstSharedFragment() const
	{
		return Composition.ConstSharedFragments.Contains<T>();
	}

	bool HasConstSharedFragment(const UScriptStruct& ScriptStruct) const
	{
		return Composition.ConstSharedFragments.Contains(ScriptStruct);
	}

	void Sort()
	{
		SharedFragmentValues.Sort();
	}

	/** Compares contents of two archetypes (this and Other). Returns whether both are equivalent.
	 *  @Note that the function can be slow, depending on how elaborate the template is. This function is meant for debugging purposes. */
	bool SlowIsEquivalent(const FMassEntityTemplateData& Other) const;

	FMassArchetypeCreationParams& GetArchetypeCreationParams() { return CreationParams; }
	
protected:
	FMassArchetypeCompositionDescriptor Composition;
	FMassArchetypeSharedFragmentValues SharedFragmentValues;

	// Initial fragment values, this is not part of the archetype as it is the spawner job to set them.
	TArray<FInstancedStruct> InitialFragmentValues;

	// These functions will be called to initialize entity's UObject-based fragments
	TArray<FObjectFragmentInitializerFunction> ObjectInitializers;

	FMassArchetypeCreationParams CreationParams;

	FString TemplateName;
};

/**
 * A finalized and const wrapper for FMassEntityTemplateData, associated with a Mass archetype and template ID. 
 * Designed to never be changed. If a change is needed a copy of the hosted FMassEntityTemplateData needs to be made and 
 * used to create another finalized FMassEntityTemplate (via FMassEntityTemplateManager).
 */
struct MASSSPAWNER_API FMassEntityTemplate final : public TSharedFromThis<FMassEntityTemplate> 
{
	friend TSharedFromThis<FMassEntityTemplate>;

	FMassEntityTemplate() = default;
	FMassEntityTemplate(const FMassEntityTemplateData& InData, FMassEntityManager& EntityManager, FMassEntityTemplateID InTemplateID);
	FMassEntityTemplate(FMassEntityTemplateData&& InData, FMassEntityManager& EntityManager, FMassEntityTemplateID InTemplateID);

	/** InArchetype is expected to be valid. The function will crash-check it. */
	void SetArchetype(const FMassArchetypeHandle& InArchetype);
	const FMassArchetypeHandle& GetArchetype() const { return Archetype; }

	bool IsValid() const { return Archetype.IsValid(); }

	void SetTemplateID(FMassEntityTemplateID InTemplateID) { TemplateID = InTemplateID; }
	FMassEntityTemplateID GetTemplateID() const { return TemplateID; }

	FString DebugGetDescription(FMassEntityManager* EntityManager = nullptr) const;
	FString DebugGetArchetypeDescription(FMassEntityManager& EntityManager) const;

	static TSharedRef<FMassEntityTemplate> MakeFinalTemplate(FMassEntityManager& EntityManager, FMassEntityTemplateData&& TempTemplateData, FMassEntityTemplateID InTemplateID);

	//-----------------------------------------------------------------------------
	// FMassEntityTemplateData getters
	//-----------------------------------------------------------------------------
	FORCEINLINE TConstArrayView<FMassEntityTemplateData::FObjectFragmentInitializerFunction> GetObjectFragmentInitializers() const { return TemplateData.GetObjectFragmentInitializers(); }
	FORCEINLINE const FString& GetTemplateName() const { return TemplateData.GetTemplateName(); }
	FORCEINLINE const FMassArchetypeCompositionDescriptor& GetCompositionDescriptor() const { return TemplateData.GetCompositionDescriptor(); }
	FORCEINLINE const FMassArchetypeSharedFragmentValues& GetSharedFragmentValues() const { return TemplateData.GetSharedFragmentValues(); }
	FORCEINLINE TConstArrayView<FInstancedStruct> GetInitialFragmentValues() const { return TemplateData.GetInitialFragmentValues(); }

	const FMassEntityTemplateData& GetTemplateData() const { return TemplateData; }

private:
	FMassEntityTemplateData TemplateData;
	FMassArchetypeHandle Archetype;
	FMassEntityTemplateID TemplateID;
};


struct MASSSPAWNER_API FMassEntityTemplateIDFactory
{
	static FMassEntityTemplateID Make(const FGuid& ConfigGuid);
	static FMassEntityTemplateID MakeFlavor(const FMassEntityTemplateID& SourceTemplateID, const int32 Flavor);
};

======================================================


=== Source/MassSpawner/Public/MassEntityTemplateRegistry.h ===
==============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "MassCommonTypes.h"
#include "MassEntityTemplate.h"
#include "MassTranslator.h"
#include "MassEntityTemplateRegistry.generated.h"

#define ENSURE_SUPPORTED_TRAIT_OPERATION() ensureMsgf(bBuildInProgress == false, TEXT("This method is not expected to be called as "\
	"part of trait's BuildTemplate call. Traits are not supposed to add elements based on other traits due to arbitrary trait ordering."));

class UWorld;
class UMassEntityTraitBase;

USTRUCT()
struct MASSSPAWNER_API FMassMissingTraitMessage
{
	GENERATED_BODY()

#if WITH_EDITORONLY_DATA
	explicit FMassMissingTraitMessage(const UMassEntityTraitBase* InRequestingTrait = nullptr, const UStruct* InMissingType = nullptr, const UMassEntityTraitBase* InRemovedByTrait = nullptr)
		: RequestingTrait(InRequestingTrait), MissingType(InMissingType), RemovedByTrait(InRemovedByTrait)
	{}

	const UMassEntityTraitBase* RequestingTrait = nullptr;
	const UStruct* MissingType = nullptr;
	// if set indicates that the missing type has been explicitly removed by given trait.
	const UMassEntityTraitBase* RemovedByTrait = nullptr;
#endif // WITH_EDITORONLY_DATA
};

USTRUCT()
struct MASSSPAWNER_API FMassDuplicateElementsMessage
{
	GENERATED_BODY()
#if WITH_EDITORONLY_DATA
	const UMassEntityTraitBase* DuplicatingTrait = nullptr;
	const UMassEntityTraitBase* OriginalTrait = nullptr;
	const UStruct* Element = nullptr;
#endif // WITH_EDITORONLY_DATA
};

#if WITH_EDITORONLY_DATA
namespace UE::Mass::Debug
{
	extern MASSSPAWNER_API const FName TraitFailedValidation;
	extern MASSSPAWNER_API const FName TraitIgnored;
}
#endif // WITH_EDITORONLY_DATA

enum class EFragmentInitialization : uint8
{
	DefaultInitializer,
	NoInitializer
};

struct FMassEntityTemplateBuildContext
{
	explicit FMassEntityTemplateBuildContext(FMassEntityTemplateData& InTemplate, FMassEntityTemplateID InTemplateID = FMassEntityTemplateID())
		: TemplateData(InTemplate)
		, TemplateID(InTemplateID)
	{}

	void SetTemplateName(const FString& Name)
	{
		TemplateData.SetTemplateName(Name);
	}

	//----------------------------------------------------------------------//
	// Fragments 
	//----------------------------------------------------------------------//
	template<typename T>
	T& AddFragment_GetRef()
	{
		TypeAdded(*T::StaticStruct());
		return TemplateData.AddFragment_GetRef<T>();
	}

	template<typename T>
	void AddFragment()
	{
		TypeAdded(*T::StaticStruct());
		TemplateData.AddFragment<T>();
	}

	void AddFragment(FConstStructView InFragment)
	{ 
		checkf(InFragment.GetScriptStruct(), TEXT("Expecting a valid fragment type"));
		TypeAdded(*InFragment.GetScriptStruct());
		TemplateData.AddFragment(InFragment);
	}

	template<typename T>
	void AddTag()
	{
		// Tags can be added by multiple traits, so they do not follow the same rules as fragments
		TemplateData.AddTag<T>();
		TypeAdded(*T::StaticStruct());
	}

	void AddTag(const UScriptStruct& TagType)
	{
		// Tags can be added by multiple traits, so they do not follow the same rules as fragments
		TemplateData.AddTag(TagType);
		TypeAdded(TagType);
	}

	template<typename T>
	void AddChunkFragment()
	{
		TypeAdded(*T::StaticStruct());
		TemplateData.AddChunkFragment<T>();
	}

	void AddConstSharedFragment(const FConstSharedStruct& InSharedFragment)
	{
		checkf(InSharedFragment.GetScriptStruct(), TEXT("Expecting a valide shared fragment type"));
		TypeAdded(*InSharedFragment.GetScriptStruct());
		TemplateData.AddConstSharedFragment(InSharedFragment);
	}

	void AddSharedFragment(const FSharedStruct& InSharedFragment)
	{
		checkf(InSharedFragment.GetScriptStruct(), TEXT("Expecting a valide shared fragment type"));
		TypeAdded(*InSharedFragment.GetScriptStruct());
		TemplateData.AddSharedFragment(InSharedFragment);
	}

	/**
	 * Removes given tag from collected data. More precisely: it will store the information and apply upon template creation (an optimization). 
	 * WARNING: use with caution and only in cases where you know for certain what the given tag does and which processors rely on it.
	 *		Using this functionality makes most sense for removing tags that specifically mean that entities having it are to be
	 *		processed by a given processor.
	 */
	void RemoveTag(const UScriptStruct& TagType)
	{
		checkf(TagType.IsChildOf(FMassTag::StaticStruct()), TEXT("Given struct doesn't represent a valid mass tag type. Make sure to inherit from FMassTag or one of its child-types."));
		RemovedTypes.Add({&TagType
#if WITH_EDITORONLY_DATA
			, TraitsData.Last().Trait
#endif // WITH_EDITORONLY_DATA
		});
	}

	template<typename T>
	void RemoveTag()
	{
		RemoveTag(*T::StaticStruct());
	}

	template<typename T>
	T* GetFragment()
	{
		return TemplateData.GetMutableFragment<T>();
	}

	template<typename T>
	bool HasFragment() const
	{
		ENSURE_SUPPORTED_TRAIT_OPERATION();
		return TemplateData.HasFragment<T>();
	}
	
	bool HasFragment(const UScriptStruct& ScriptStruct) const
	{
		ENSURE_SUPPORTED_TRAIT_OPERATION();
		return TemplateData.HasFragment(ScriptStruct);
	}

	template<typename T>
	bool HasTag() const
	{
		return TemplateData.HasTag<T>();
	}

	template<typename T>
	bool HasChunkFragment() const
	{
		ENSURE_SUPPORTED_TRAIT_OPERATION();
		return TemplateData.HasChunkFragment<T>();
	}

	template<typename T>
	bool HasSharedFragment() const
	{
		ENSURE_SUPPORTED_TRAIT_OPERATION();
		return TemplateData.HasSharedFragment<T>();
	}

	bool HasSharedFragment(const UScriptStruct& ScriptStruct) const
	{
		ENSURE_SUPPORTED_TRAIT_OPERATION();
		return TemplateData.HasSharedFragment(ScriptStruct);
	}

	template<typename T>
	bool HasConstSharedFragment() const
	{
		ENSURE_SUPPORTED_TRAIT_OPERATION();
		return TemplateData.HasConstSharedFragment<T>();
	}

	bool HasConstSharedFragment(const UScriptStruct& ScriptStruct) const
	{
		ENSURE_SUPPORTED_TRAIT_OPERATION();
		return TemplateData.HasConstSharedFragment(ScriptStruct);
	}

	//----------------------------------------------------------------------//
	// Translators
	//----------------------------------------------------------------------//
	template<typename T>
	void AddTranslator()
	{
		TypeAdded(*T::StaticClass());
		GetDefault<T>()->AppendRequiredTags(TemplateData.GetMutableTags());
	}

	//----------------------------------------------------------------------//
	// Dependencies
	//----------------------------------------------------------------------//
	template<typename T>
	void RequireFragment()
	{
		static_assert(TIsDerivedFrom<T, FMassTag>::IsDerived == false, "Given struct type is a valid fragment type.");
		AddDependency(T::StaticStruct());
	}

	template<typename T>
	void RequireTag()
	{
		static_assert(TIsDerivedFrom<T, FMassTag>::IsDerived, "Given struct type is not a valid tag type.");
		AddDependency(T::StaticStruct());
	}

	void AddDependency(const UStruct* Dependency)
	{
		TraitsData.Last().TypesRequired.Add(Dependency);
	}

	//----------------------------------------------------------------------//
	// Template access
	//----------------------------------------------------------------------//
	FMassEntityTemplateID GetTemplateID() const { return TemplateID; }
	TArray<FMassEntityTemplateData::FObjectFragmentInitializerFunction>& GetMutableObjectFragmentInitializers() { return TemplateData.GetMutableObjectFragmentInitializers(); }

	//----------------------------------------------------------------------//
	// Build methods
	//----------------------------------------------------------------------//

	/**
	 * Builds context from a list of traits
	 * @param Traits is the list of all the traits to build an entity
	 * @param World owning the MassEntitySubsystem for which the entity template is built
	 * @return true if there were no validation errors
	 */
	bool BuildFromTraits(TConstArrayView<UMassEntityTraitBase*> Traits, const UWorld& World);

	/** 
	 * The method that allows to distinguish between regular context use (using traits to build templates) and 
	 * the "data investigation" mode (used for debugging and authoring purposes). Utilize this function to 
	 * avoid UWorld-specific operations (like getting subsystems). This method should also be used when a trait 
	 * contains conditional logic - in that case it's required for the trait to add all the types that are potentially
	 * added at runtime (even if seemingly conflicting information will be added). 
	 * 
	 * @return whether this context is in data inspection mode.
	 */
#if WITH_EDITORONLY_DATA
	bool IsInspectingData() const
	{
		return bIsInspectingData;
	}
#else
	constexpr bool IsInspectingData() const
	{
		return false;
	}
#endif

#if WITH_EDITORONLY_DATA
	void EnableDataInvestigationMode()
	{
		checkf(TemplateData.IsEmpty(), TEXT("Marking a FMassEntityTemplateBuildContext as being in 'investigation mode` is only supported before the context is first used."));
		bIsInspectingData = true;
	}
#endif // WITH_EDITORONLY_DATA


protected:

	/**
	 * Validate the build context for fragment trait ownership and trait fragment missing dependency
	 * @param World owning the MassEntitySubsystem for which the entity template is validated against
	 * @return true if there were no validation errors
	 */
	bool ValidateBuildContext(const UWorld& World);

	void TypeAdded(const UStruct& Type)
	{
		checkf(TraitsData.Num(), TEXT("Adding elements to the build context before BuildFromTraits or SetTraitBeingProcessed was called is unsupported"));
		TraitsData.Last().TypesAdded.Add(&Type);
	}

	/** 
	 * Return true if the given trait can be used. The function will fail if a trait instance of the given class has already 
	 * been processed. The function will also fail the very same trait instance is used multiple times.
	 * Note that it's ok for Trait to be nullptr to indicate the subsequent additions to the build context are procedural
	 * in nature and are not associated with any traits. In that case it's ok to have multiple SetTraitBeingProcessed(nullptr)
	 * calls.
	 */
	MASSSPAWNER_API bool SetTraitBeingProcessed(const UMassEntityTraitBase* Trait);

	void ResetBuildTimeData()
	{
		TraitsData.Reset();
		TraitsProcessed.Reset();
		IgnoredTraits.Reset();
		RemovedTypes.Reset();
		bBuildInProgress = false;
	}

	struct FTraitData
	{
		const UMassEntityTraitBase* Trait = nullptr;
		TArray<const UStruct*> TypesAdded;
		TArray<const UStruct*> TypesRequired;
	};
	TArray<FTraitData> TraitsData;
	TSet<const UMassEntityTraitBase*> TraitsProcessed;
	TSet<const UMassEntityTraitBase*> IgnoredTraits;

	struct FRemovedType
	{
		const UStruct* TypeRemoved = nullptr;
#if WITH_EDITOR
		const UMassEntityTraitBase* Remover = nullptr;
#endif // WITH_EDITOR
		bool operator==(const FRemovedType& Other) const
		{
			return TypeRemoved == Other.TypeRemoved;
		}
	};
	/**
	 * These tags will be removed from the resulting entity template
	 * @see RemoveTag for more details
	 */
	TArray<FRemovedType> RemovedTypes;

	bool bBuildInProgress = false;

	FMassEntityTemplateData& TemplateData;
	FMassEntityTemplateID TemplateID;

#if WITH_EDITORONLY_DATA
private:
	/**
	 * This being set to `true` indicates that the context is being used to gather information, not to create actual
	 * entity templates.
	 */
	bool bIsInspectingData = false;
#endif // WITH_EDITORONLY_DATA
};

/** 
 * Represents a repository storing all the FMassEntityTemplate that have been created and registered as part of FMassEntityConfig
 * processing or via custom code (like we do in InstancedActors plugin).
 */
struct MASSSPAWNER_API FMassEntityTemplateRegistry
{
	// @todo consider TFunction instead
	DECLARE_DELEGATE_ThreeParams(FStructToTemplateBuilderDelegate, const UWorld* /*World*/, const FConstStructView /*InStructInstance*/, FMassEntityTemplateBuildContext& /*BuildContext*/);

	explicit FMassEntityTemplateRegistry(UObject* InOwner = nullptr);

	/** Initializes and stores the EntityManager the templates will be associated with. Needs to be called before any template operations.
	 *  Note that the function will only let users set the EntityManager once. Once it's set the subsequent calls will
	 *  have no effect. If attempting to set a different EntityManaget an ensure will trigger. */
	void Initialize(const TSharedPtr<FMassEntityManager>& InEntityManager);

	void ShutDown();

	UWorld* GetWorld() const;

	static FStructToTemplateBuilderDelegate& FindOrAdd(const UScriptStruct& DataType);

	/** Removes all the cached template instances */
	void DebugReset();

	const TSharedRef<FMassEntityTemplate>* FindTemplateFromTemplateID(FMassEntityTemplateID TemplateID) const;

	/**
	 * Adds a template based on TemplateData
	 */
	const TSharedRef<FMassEntityTemplate>& FindOrAddTemplate(FMassEntityTemplateID TemplateID, FMassEntityTemplateData&& TemplateData);

	UE_DEPRECATED(5.3, "We no longer support fething mutable templates from the TemplateRegistry. Stored templates are considered const.")
	FMassEntityTemplate* FindMutableTemplateFromTemplateID(FMassEntityTemplateID TemplateID);

	UE_DEPRECATED(5.3, "CreateTemplate is no longer available. Use FindOrAddTemplate instead.")
	FMassEntityTemplate& CreateTemplate(const uint32 HashLookup, FMassEntityTemplateID TemplateID);

	void DestroyTemplate(FMassEntityTemplateID TemplateID);

	UE_DEPRECATED(5.3, "InitializeEntityTemplate is no longer available. Use FindOrAddTemplate instead.")
	void InitializeEntityTemplate(FMassEntityTemplate& InOutTemplate) const;

	FMassEntityManager& GetEntityManagerChecked() { check(EntityManager); return *EntityManager; }

protected:
	static TMap<const UScriptStruct*, FStructToTemplateBuilderDelegate> StructBasedBuilders;

	TMap<FMassEntityTemplateID, TSharedRef<FMassEntityTemplate>> TemplateIDToTemplateMap;

	/** 
	 * EntityManager the hosted templates are associated with. Storing instead of fetching at runtime to ensure all 
	 *	templates are tied to the same EntityManager
	 */
	TSharedPtr<FMassEntityManager> EntityManager;

	TWeakObjectPtr<UObject> Owner;
};

#undef ENSURE_SUPPORTED_TRAIT_OPERATION

==============================================================


=== Source/MassSpawner/Public/MassEntityTraitBase.h ===
=======================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "MassEntityTraitBase.generated.h"

struct FMassEntityTemplateBuildContext;

/**
 * Base class for Mass Entity Traits.
 * An entity trait is a set of fragments that create a logical trait tha makes sense to end use (i.e. replication, visualization).
 * The template building method allows to configure some fragments based on properties or cached values.
 * For example, a fragment can be added based on a referenced asset, or some memory hungry settings can be
 * cached and just and index stored on a fragment.
 */
UCLASS(Abstract, BlueprintType, EditInlineNew, CollapseCategories)
class MASSSPAWNER_API UMassEntityTraitBase : public UObject
{
	GENERATED_BODY()

public:
	/** 
	 * This is a type wrapping an existing TArray to limit how users can interact with the contained data. 
	 * We essentially limit users to just adding elements, no other operations.
	 */
	struct FAdditionalTraitRequirements
	{
		explicit FAdditionalTraitRequirements(TArray<const UStruct*>& InTargetContainer)
			: TargetContainer(InTargetContainer)
		{
		}
		
		// Copying constructor and assignment deleted to prevent users storing copies of the type, 
		// which wouldn't be safe due to this type hosting a reference to an array that can go out of scope.
		FAdditionalTraitRequirements(const FAdditionalTraitRequirements&) = delete;
		FAdditionalTraitRequirements& operator=(const FAdditionalTraitRequirements&) = delete;

		FAdditionalTraitRequirements& Add(const UScriptStruct* RequiredType)
		{
			TargetContainer.Add(RequiredType);
			return *this;
		}

	private:
		TArray<const UStruct*>& TargetContainer;
	};


	/** Appends items into the entity template required for the trait. */
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const PURE_VIRTUAL(UMassEntityTraitBase::BuildTemplate, return; );

	UE_DEPRECATED(5.5, "This flavor of DestroyTemplate has been deprecated, use the version taking the World parameter")
	virtual void DestroyTemplate() const;

	virtual void DestroyTemplate(const UWorld& World) const {}

	/**
	 * Called once all traits have been processed and fragment requirements have been checked. Override this function
	 * to perform additional Trait's configuration validation. Returning `false` will indicate that the trait instance
	 * is not happy with the validation results - this result will be treated as an error.
	 * @param OutTraitRequirements contains requirements declared by this trait and gives ValidateTemplate a chance to add 
	 *		to the dependencies based on the state of BuildContext, which by this point should contain all the elements 
	 *		added by all the relevant traits.
	 * @return whether the validation was successful
	 */
	virtual bool ValidateTemplate(const FMassEntityTemplateBuildContext& BuildContext, const UWorld& World, FAdditionalTraitRequirements& OutTraitRequirements) const;
	
	UE_DEPRECATED(5.5, "This flavor of ValidateTemplate is deprecated. Use the three-parameter one instead.")
	virtual bool ValidateTemplate(FMassEntityTemplateBuildContext& BuildContext, const UWorld& World) const;

#if WITH_EDITOR
	DECLARE_MULTICAST_DELEGATE_OneParam(FOnNewTraitType, UMassEntityTraitBase&);
	static FOnNewTraitType& GetOnNewTraitTypeEvent()
	{
		return OnNewTraitTypeEvent;
	}

protected:
	virtual void PostInitProperties() override;

private:
	static FOnNewTraitType OnNewTraitTypeEvent;
#endif // WITH_EDITOR
};

#if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_5
#include "CoreMinimal.h"
#endif

=======================================================


=== Source/MassSpawner/Public/MassEntityZoneGraphSpawnPointsGenerator.h ===
===========================================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "CoreMinimal.h"
#include "MassEntitySpawnDataGeneratorBase.h"
#include "ZoneGraphTypes.h"

#include "MassEntityZoneGraphSpawnPointsGenerator.generated.h"

class AZoneGraphData;

/**
 * Describes the SpawnPoints Generator when we want to spawn directly on Zone Graph
 */
UCLASS(BlueprintType, meta=(DisplayName="ZoneGraph SpawnPoints Generator"))
class MASSSPAWNER_API UMassEntityZoneGraphSpawnPointsGenerator : public UMassEntitySpawnDataGeneratorBase
{
	GENERATED_BODY()

public:
	virtual void Generate(UObject& QueryOwner, TConstArrayView<FMassSpawnedEntityType> EntityTypes, int32 Count, FFinishedGeneratingSpawnDataSignature& FinishedGeneratingSpawnPointsDelegate) const override;

protected:
	void GeneratePointsForZoneGraphData(const ::AZoneGraphData& ZoneGraphData, TArray<FVector>& Locations, const FRandomStream& RandomStream) const;

	/** Tags to filter which lane to use to generate points on */
	UPROPERTY(EditAnywhere, Category = "ZoneGraph Generator Config")
	FZoneGraphTagFilter TagFilter;

	/** Minimum gap for spawning entities on a given lanes */
	UPROPERTY(EditAnywhere, Category = "ZoneGraph Generator Config")
	float MinGap = 100;

	/** Maximum gap for spawning entities on a given lanes */
	UPROPERTY(EditAnywhere, Category = "ZoneGraph Generator Config")
	float MaxGap = 300;
};

===========================================================================


=== Source/MassSpawner/Public/MassSpawner.h ===
===============================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "GameFramework/Actor.h"
#include "Engine/World.h"
#include "MassSpawnerTypes.h"
#include "MassEntitySpawnDataGeneratorBase.h"
#include "MassSpawner.generated.h"


struct FStreamableHandle;

DECLARE_DYNAMIC_MULTICAST_DELEGATE(FMassSpawnerOnSpawningFinishedEvent);
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FMassSpawnerOnDespawningFinishedEvent);

/** A spawner you can put on a map and configure it to spawn different things */
UCLASS(hidecategories = (Object, Actor, Input, Rendering, LOD, Cooking, Collision, HLOD, Partition))
class MASSSPAWNER_API AMassSpawner : public AActor
{
	GENERATED_BODY()
public:
	AMassSpawner();

protected:
	virtual void BeginPlay() override;
	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;
	virtual void PostLoad() override;
	virtual void PostRegisterAllComponents() override;
	virtual void BeginDestroy() override;

public:
#if WITH_EDITOR
	UFUNCTION(BlueprintCallable, CallInEditor, Category = "Debug")
	void DEBUG_Spawn();

	/** Remove all the entities */
	UFUNCTION(BlueprintCallable, CallInEditor, Category = "Debug")
	void DEBUG_Clear();
#endif // WITH_EDITOR

protected:
#if WITH_EDITOR
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;
#endif // WITH_EDITOR

	void RegisterEntityTemplates();

public:
	/**
	 * Starts the spawning of all the agent types of this spawner
	 */
	UFUNCTION(BlueprintCallable, Category = "Spawning")
	void DoSpawning();

	/**
	 * Despawn all mass agent that was spawned by this spawner
	 */
	UFUNCTION(BlueprintCallable, Category = "Spawning")
	void DoDespawning();

	/**
	 * Despawn all mass agent that was spawned by this spawner, except EntitiesToIgnore.
	 *
	 * Any EntitiesToIgnore previously spawned by this spawner will remain spawned and tracked by this spawner.   
	 */
	void DoDespawning(TConstArrayView<FMassEntityHandle> EntitiesToIgnore);

	UFUNCTION(BlueprintCallable, Category = "Spawning")
	void ClearTemplates();

	UFUNCTION(BlueprintCallable, Category = "Spawning")
	void UnloadConfig();

	/**
	 * If given entity has been spawned by this MassSpawner instance then it will get destroyed and all the book keeping 
	 * updated. Otherwise the call has no effect.
	 * @return true if the entity got removed. False otherwise.
	 */
	bool DespawnEntity(const FMassEntityHandle Entity);

	/**
	 * Scales the spawning counts
	 * @param Scale is the number to multiply the all counts of each agent types 
	 */
	UFUNCTION(BlueprintCallable, Category = "Spawning")
	void ScaleSpawningCount(float Scale) { SpawningCountScale = Scale; }

	UFUNCTION(BlueprintCallable, Category = "Spawning")
	int32 GetCount() const;

	UFUNCTION(BlueprintCallable, Category = "Spawning")
	float GetSpawningCountScale() const;

	/** Called once DoSpawning completes and all entities have been spawned. */
	UPROPERTY(BlueprintAssignable)
	FMassSpawnerOnSpawningFinishedEvent OnSpawningFinishedEvent;

	/** Called once DoDespawning completes and all mass agents spawned by this spawner have been despawned. */
	UPROPERTY(BlueprintAssignable)
	FMassSpawnerOnDespawningFinishedEvent OnDespawningFinishedEvent; 

protected:
	void OnPostWorldInit(UWorld* World, const UWorld::InitializationValues);
	void SpawnGeneratedEntities(TConstArrayView<FMassEntitySpawnDataGeneratorResult> Results);
	void OnSpawnDataGenerationFinished(TConstArrayView<FMassEntitySpawnDataGeneratorResult> Results, FMassSpawnDataGenerator* FinishedGenerator);

	int32 GetSpawnCount() const;
	UMassProcessor* GetPostSpawnProcessor(TSubclassOf<UMassProcessor> ProcessorClass);

protected:

	struct FSpawnedEntities
	{
		FMassEntityTemplateID TemplateID;
		TArray<FMassEntityHandle> Entities;
	};

	UPROPERTY(EditAnywhere, Category = "Mass|Spawn")
	int32 Count;

	/** Array of entity types to spawn. These define which entities to spawn. */
	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "Mass|Spawn")
	TArray<FMassSpawnedEntityType> EntityTypes;

	/** Array of entity spawn generators. These define where to spawn entities. */
	UPROPERTY(EditAnywhere, Category = "Mass|Spawn")
	TArray<FMassSpawnDataGenerator> SpawnDataGenerators;

	UPROPERTY(Category = "Mass|Spawn", EditAnywhere)
	uint32 bAutoSpawnOnBeginPlay : 1;

	/** By default TickSchematics will be appended to the simulation's schematics. If this property is set to true the
	 *  TickSchematics will override the original simulation schematics */
	UPROPERTY(Category = "Mass|Simulation", EditAnywhere)
	uint32 bOverrideSchematics : 1;

	UPROPERTY()
	TArray<TObjectPtr<UMassProcessor>> PostSpawnProcessors;

	/** Scale of the spawning count */
	UPROPERTY(EditAnywhere, Category = "Mass|Spawn")
	float SpawningCountScale = 1.0f;

	FDelegateHandle SimulationStartedHandle;

	FDelegateHandle OnPostWorldInitDelegateHandle;

	TArray<FSpawnedEntities> AllSpawnedEntities;
	
	TArray<FMassEntitySpawnDataGeneratorResult> AllGeneratedResults;
	
	TSharedPtr<FStreamableHandle> StreamingHandle;

#if WITH_EDITORONLY_DATA
private:
	UPROPERTY()
	TObjectPtr<UBillboardComponent> SpriteComponent;
#endif // WITH_EDITORONLY_DATA
 };

namespace UE::MassSpawner
{
	MASSSPAWNER_API extern float ScalabilitySpawnDensityMultiplier;
}


===============================================


=== Source/MassSpawner/Public/MassSpawnerSubsystem.h ===
========================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassEntityManager.h"
#include "StructUtils/InstancedStruct.h"
#include "MassSubsystemBase.h"
#include "MassEntityTemplateRegistry.h"
#include "MassSpawnerSubsystem.generated.h"

struct FMassEntityManager;
struct FMassEntityTemplate;
struct FInstancedStruct;
struct FStructView;
struct FMassEntityTemplateID;
class UMassSimulationSubsystem;

UCLASS()
class MASSSPAWNER_API UMassSpawnerSubsystem : public UMassSubsystemBase
{
	GENERATED_BODY()

public:
	UMassSpawnerSubsystem();

	/** Spawns entities of the kind described by the given EntityTemplate. The spawned entities are fully initialized
	 *  meaning the EntityTemplate.InitializationPipeline gets run for all spawned entities.
	 *  @param EntityTemplate template to use for spawning entities
	 *  @param NumberToSpawn number of entities to spawn
	 *  @param OutEntities where the IDs of created entities get added. Note that the contents of OutEntities get overridden by the function.
	 *  @return true if spawning was successful, false otherwise. In case of failure see logs for more details. */
	void SpawnEntities(const FMassEntityTemplate& EntityTemplate, const uint32 NumberToSpawn, TArray<FMassEntityHandle>& OutEntities);

	void SpawnEntities(FMassEntityTemplateID TemplateID, const uint32 NumberToSpawn, FConstStructView SpawnData, TSubclassOf<UMassProcessor> InitializerClass, TArray<FMassEntityHandle>& OutEntities);

	void DestroyEntities(TConstArrayView<FMassEntityHandle> Entities);

	UE_DEPRECATED(5.3, "This flavor of DestroyEntities has been deprecated. Use the one without the FMassEntityTemplateID parameter")
	void DestroyEntities(const FMassEntityTemplateID TemplateID, TConstArrayView<FMassEntityHandle> Entities)
	{
		DestroyEntities(Entities);
	}

	const FMassEntityTemplateRegistry& GetTemplateRegistryInstance() const { return TemplateRegistryInstance; }
	FMassEntityTemplateRegistry& GetMutableTemplateRegistryInstance() { return TemplateRegistryInstance; }

	const FMassEntityTemplate* GetMassEntityTemplate(FMassEntityTemplateID TemplateID) const;

	FMassEntityManager& GetEntityManagerChecked()
	{
		check(EntityManager.IsValid());
		return *EntityManager.Get();
	}

protected:
	// UWorldSubsystem BEGIN
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;
	// UWorldSubsystem END

	void DoSpawning(const FMassEntityTemplate& EntityTemplate, const int32 NumToSpawn, FConstStructView SpawnData, TSubclassOf<UMassProcessor> InitializerClass, TArray<FMassEntityHandle>& OutEntities);

	UMassProcessor* GetSpawnDataInitializer(TSubclassOf<UMassProcessor> InitializerClass);

	UPROPERTY()
	TArray<TObjectPtr<UMassProcessor>> SpawnDataInitializers;

	TSharedPtr<FMassEntityManager> EntityManager;

	FMassEntityTemplateRegistry TemplateRegistryInstance;
};


========================================================


=== Source/MassSpawner/Public/MassSpawnerTypes.h ===
====================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "Logging/LogMacros.h"
#include "MassEntityTemplate.h"
#include "MassSpawnerTypes.generated.h"


DECLARE_LOG_CATEGORY_EXTERN(LogMassSpawner, Warning, All);

class APawn;
class UCurveFloat;
class UMassEntityConfigAsset;
class UMassEntitySpawnDataGeneratorBase;
class UMassEntityTraitBase;

namespace UE::MassSpawner
{
	MASSSPAWNER_API uint32 HashTraits(TConstArrayView<UMassEntityTraitBase*> CombinedTraits);
}

USTRUCT()
struct FMassTransformsSpawnData
{
	GENERATED_BODY()

	FMassTransformsSpawnData()
	: bRandomize(true)
	{}

	// declaring the type used to be able to statically test it against other types 
	using FTransformsContainerType = TArray<FTransform>;
	FTransformsContainerType Transforms;
	
	// When true, Transforms will be assigned to entities as if pre-shuffled. 
	// If Transforms >= Entities, this provides the best chance for a good spread of entity transforms 
	// and transforms choices will be guaranteed unique. If Transforms < Entities, the same 
	// transform will be used for multiple entities and a warning logged.
	//
	// When false, Transforms will be assigned in order to spawned entities.
	bool bRandomize : 1;
};

/**
 * Describes an entity type to spawn.
 */
USTRUCT(BlueprintType)
struct FMassSpawnedEntityType
{
	GENERATED_BODY()

	/** Asset that describes the entity */
	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "Mass|Spawn")
	TSoftObjectPtr<UMassEntityConfigAsset> EntityConfig;

	/** Proportion of the count that should be this agent type, (the proportions will be normalized with other sibling agent types) */
	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "Mass|Spawn", meta = (ClampMin = 0.0f, UIMin = 0.0f))
	float Proportion = 1.0f;
	
	bool IsLoaded() const { return EntityConfigPtr != nullptr; }

	void UnloadEntityConfig()
	{
		EntityConfigPtr = nullptr;
		EntityConfig.ResetWeakPtr();
	}

	MASSSPAWNER_API const UMassEntityConfigAsset* GetEntityConfig() const;
	MASSSPAWNER_API UMassEntityConfigAsset* GetEntityConfig();

private:
	UPROPERTY(Transient)
	mutable TObjectPtr<UMassEntityConfigAsset> EntityConfigPtr = nullptr;
};

USTRUCT(BlueprintType)
struct FMassSpawnDataGenerator
{
	GENERATED_BODY()

	/** The Generator to use to generate the spawn the points */
	UPROPERTY()
	TSubclassOf<UMassEntitySpawnDataGeneratorBase> GeneratorClass;

	UPROPERTY(BlueprintReadWrite, EditAnywhere, Instanced, Category = "Mass|Generator")
	TObjectPtr<UMassEntitySpawnDataGeneratorBase> GeneratorInstance = nullptr;

	/** Proportion of the spawn points that should be generated by this generator, (the proportions will be normalized with other sibling generators) */
	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "Mass|Generator", meta = (ClampMin = 0.0f, UIMin = 0.0f))
	float Proportion = 1.0f;

	/** Runtime value to know if we received the generated data for this generator */
	bool bDataGenerated = false;
};

USTRUCT()
struct MASSSPAWNER_API FReplicationTemplateIDFragment : public FMassFragment
{
	GENERATED_BODY()

	UPROPERTY(Transient)
	FMassEntityTemplateID ID;
};

====================================================


=== Source/MassSpawner/Public/MassSpawnLocationProcessor.h ===
==============================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "MassProcessor.h"
#include "MassSpawnLocationProcessor.generated.h"

UCLASS()
class MASSSPAWNER_API UMassSpawnLocationProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassSpawnLocationProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
	FRandomStream RandomStream;
};

==============================================================


=== Source/MassSpawner/Public/MassTranslator.h ===
==================================================

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "MassProcessor.h"
#include "MassEntityTypes.h"
#include "MassTranslator.generated.h"


UENUM()
enum class EMassTranslationDirection : uint8
{
	None = 0,
	InitializationOnly = 1,
	ActorToMass = 1 << 1,
	MassToActor = 1 << 2,
	BothWays = ActorToMass | MassToActor
};
ENUM_CLASS_FLAGS(EMassTranslationDirection);

/** 
 *  A class that's responsible for translation between UObjects and Mass. A translator knows how to initialize 
 *  fragments related to the UClass that the given translator cares about. It can also be used at runtime to 
 *  copy values from UObjects to fragments and back.
 */
UCLASS(abstract)
class MASSSPAWNER_API UMassTranslator : public UMassProcessor
{
	GENERATED_BODY()

protected:
	UMassTranslator();
public:
	/** Fetches the FMassTag-derived types required by this Translator. And entity needs these tags to be 
	 *  processed by this Translator instance. 
	 * 
	 *  @todo might want this function on the MassProcessor level. TBD
	 * 
	 *  @param OutTagTypes tag types will be appended to this array. No uniqueness checks are performed. */
	void AppendRequiredTags(FMassTagBitSet& InOutTags) const { InOutTags += RequiredTags; }

protected:
	void AddRequiredTagsToQuery(FMassEntityQuery& EntityQuery);

protected:
	/** These are the tag fragments expected by this translator that let other code (like entity traits) hint to 
	 *  the system which translators they'd want their entity to be processed by. */
	FMassTagBitSet RequiredTags;
};

==================================================


=== Source/MassSpawner/MassSpawner.Build.cs ===
===============================================

// Copyright Epic Games, Inc. All Rights Reserved.

namespace UnrealBuildTool.Rules
{
	public class MassSpawner : ModuleRules
	{
		public MassSpawner(ReadOnlyTargetRules Target) : base(Target)
		{
			PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

			UnsafeTypeCastWarningLevel = WarningLevel.Warning;

			PublicDependencyModuleNames.AddRange(
				new string[] {
					"Core",
					"CoreUObject",
					"Engine",
					"AIModule",
					"MassEntity",
					"MassCommon",
					"MassSimulation",
					"ZoneGraph",
				}
			);

			if (Target.bBuildEditor == true)
			{
				PrivateDependencyModuleNames.AddRange(
					new string[] {
						"UnrealEd",
						"Slate"
					}
				);

				PublicDependencyModuleNames.Add("MassEntityEditor");
				// here for communication with MassTraitRepository
				PrivateIncludePathModuleNames.Add("MassGameplayEditor");
				DynamicallyLoadedModuleNames.Add("MassGameplayEditor");
			}
		}
	}
}

===============================================

