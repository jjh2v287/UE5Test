## C++ `new`/`delete` 및 배치 `new` (Placement `new`)

**요약:** 일반 `new`/`delete`는 힙 메모리 할당/해제와 생성자/소멸자 호출을 모두 수행하지만, 배치 `new`는 이미 존재하는 메모리에 생성자만 호출하므로 소멸자도 직접 호출해야 합니다.

`void UUKHTNTask_ScheduleBase::InitializeMemory(UHTNComponent& OwnerComp, uint8* NodeMemory, const FHTNPlan& Plan, const FHTNPlanStepID& StepID) const`  
`{`  
    `Super::InitializeMemory(OwnerComp, NodeMemory, Plan, StepID);`
	`// 생성자 함수만 호출`
    ==`new(NodeMemory) FUKHTNTask_ScheduleMemory;`== 
`}`

### 1. 표준 `new` 및 `delete` 연산자

C++에서 동적 메모리 할당과 해제를 위한 가장 기본적인 메커니즘입니다.

- **`new Type` 또는 `new Type(args)`:**
    
    1. **메모리 할당:** 힙(Heap) 영역에서 `Type` 객체를 저장하기에 충분한 크기의 메모리 블록을 찾거나 할당합니다. 실패하면 `std::bad_alloc` 예외를 던질 수 있습니다.
        
    2. **생성자 호출:** 할당된 메모리 공간에 `Type`의 적절한 생성자를 호출하여 객체를 초기화합니다.
        
    3. **포인터 반환:** 생성된 객체를 가리키는 `Type*` 타입의 포인터를 반환합니다.
        
- **`delete ptr`:**
    
    1. **소멸자 호출:** `ptr`이 가리키는 객체의 소멸자 (`~Type()`)를 호출하여 객체가 사용하던 리소스(메모리, 파일 핸들 등)를 정리합니다. `ptr`이 널 포인터(nullptr)이면 아무 작업도 하지 않습니다.
        
    2. **메모리 해제:** 이전에 `new`를 통해 할당되었던 힙 메모리 공간을 운영체제나 메모리 관리자에게 반환합니다.
        
    
    - **주의:** `new`로 할당하지 않은 메모리(스택 변수 주소 등)나 이미 `delete`된 포인터에 사용하면 정의되지 않은 동작(Undefined Behavior)을 일으킵니다.
        
- **배열 `new[]` 및 `delete[]`:**
    
    - `Type* arr = new Type[N];` : 힙에 `N`개의 `Type` 객체를 저장할 연속된 메모리를 할당하고, 각 요소에 대해 **기본 생성자**를 호출합니다.
        
    - `delete[] arr;` : 배열의 각 요소에 대해 **소멸자**를 호출한 후, 전체 배열 메모리를 해제합니다.
        
    - **매칭 필수:** `new[]`로 할당한 배열은 반드시 `delete[]`로 해제해야 합니다. `delete`를 사용하면 첫 번째 요소의 소멸자만 호출되고 메모리 해제 과정에서 문제가 발생할 수 있습니다.
        

**주요 특징:** 메모리 할당/해제와 객체 생성/소멸이 긴밀하게 연결되어 있습니다.

### 2. 배치 `new` (Placement `new`)

미리 할당된 특정 메모리 주소에 객체를 생성(초기화)하기 위한 특별한 형태의 `new` 문법입니다.

- **문법:** `new (address) Type(args);`
    
    - `address`: 객체를 생성할 메모리의 시작 주소를 나타내는 포인터 (보통 `void*` 또는 `char*`).
        
    - `Type`: 생성할 객체의 타입.
        
    - `args`: 생성자에 전달할 인자들.
        
- **작동 방식:**
    
    1. **메모리 할당 안 함:** 새로운 메모리를 할당하지 않습니다. `address`가 가리키는 메모리 공간이 이미 유효하고 충분한 크기이며 적절히 정렬되어 있다고 가정합니다.
        
    2. **생성자만 호출:** `address`가 가리키는 메모리 위치에 `Type`의 생성자를 호출하여 객체를 초기화합니다.
        
    3. **포인터 반환:** `address`와 동일한 주소 값을 가진 `Type*` 타입의 포인터를 반환합니다.
        
- **배치 `new` 사용 시 객체 파괴:**
    
    - **`delete` 사용 불가:** 배치 `new`로 생성된 객체에 일반 `delete`를 사용하면 안 됩니다. `delete`는 메모리 해제를 시도하는데, 해당 메모리는 `new`가 할당한 것이 아니므로 오류가 발생합니다.
        
    - **소멸자 직접 호출 필수:** 객체가 더 이상 필요 없을 때, 해당 메모리를 재사용하거나 해제하기 전에 반드시 **명시적으로 소멸자를 호출**해야 합니다.
        
        ```
        Type* ptr = reinterpret_cast<Type*>(address); // 또는 배치 new가 반환한 포인터 사용
        ptr->~Type(); // 소멸자 직접 호출
        ```
        
        이렇게 하면 객체가 사용하던 내부 리소스만 정리되고, `address`가 가리키던 메모리 자체는 해제되지 않습니다. 해당 메모리의 관리는 원래 메모리를 제공한 쪽(예: 메모리 풀, 스택 버퍼 관리자)의 책임입니다.
        
- **헤더 필요:** 배치 `new`를 사용하려면 `<new>` 헤더 파일을 포함해야 합니다.
    

**주요 특징:** 메모리 할당과 객체 생성을 분리합니다. 개발자가 메모리 위치를 직접 제어할 수 있게 해줍니다.

### 3. 배치 `new` 사용 사례

- **커스텀 메모리 관리자/메모리 풀:** 미리 큰 메모리 블록을 할당해 두고, 필요할 때마다 이 풀의 일부에 배치 `new`를 사용하여 객체를 생성함으로써 동적 할당 오버헤드를 줄이고 메모리 단편화를 관리합니다. (Unreal Engine 내부에서도 유사한 기법 사용 가능성 있음)
    
- **성능 최적화:** 매우 빈번하게 객체를 생성/파괴해야 하는 성능 민감 코드에서 힙 할당/해제 비용을 피하기 위해 스택 기반 버퍼나 정적 버퍼에 객체를 생성할 때 사용합니다.
    
- **하드웨어 직접 제어:** 메모리에 맵핑된 하드웨어 레지스터 주소에 C++ 객체 인터페이스를 직접 생성(overlay)할 때 사용합니다.
    
- **표준 라이브러리 컨테이너 구현:** `std::vector`, `std::list` 등 많은 표준 컨테이너는 내부적으로 할당된 버퍼에 요소를 추가할 때 배치 `new`를 사용하여 객체를 생성합니다.
    

**결론:**

`new`/`delete`는 C++에서 동적 객체의 전체 생명 주기(메모리 할당, 생성, 소멸, 메모리 해제)를 관리하는 표준적인 방법입니다. 반면, 배치 `new`는 메모리 할당 단계를 건너뛰고 지정된 메모리에 객체 생성(초기화)만 수행하는 저수준 기능으로, 메모리 관리와 객체 생성을 분리해야 하는 특별한 상황에서 사용되며, 반드시 명시적인 소멸자 호출이 뒤따라야 합니다.